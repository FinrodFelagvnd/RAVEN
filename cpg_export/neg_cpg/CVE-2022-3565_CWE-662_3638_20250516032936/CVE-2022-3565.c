static int
l1oip_socket_send(struct l1oip *hc, u8 localcodec, u8 channel, u32 chanmask,
		  u16 timebase, u8 *buf, int len)
{
	u8 *p;
	u8 frame[MAX_DFRAME_LEN_L1 + 32];
	struct socket *socket = NULL;

	if (debug & DEBUG_L1OIP_MSG)
		printk(KERN_DEBUG "%s: sending data to socket (len = %d)\n",
		       __func__, len);

	p = frame;

	/* restart timer */
	if (time_before(hc->keep_tl.expires, jiffies + 5 * HZ))
		mod_timer(&hc->keep_tl, jiffies + L1OIP_KEEPALIVE * HZ);
	else
		hc->keep_tl.expires = jiffies + L1OIP_KEEPALIVE * HZ;

	if (debug & DEBUG_L1OIP_MSG)
		printk(KERN_DEBUG "%s: resetting timer\n", __func__);

	/* drop if we have no remote ip or port */
	if (!hc->sin_remote.sin_addr.s_addr || !hc->sin_remote.sin_port) {
		if (debug & DEBUG_L1OIP_MSG)
			printk(KERN_DEBUG "%s: dropping frame, because remote "
			       "IP is not set.\n", __func__);
		return len;
	}

	/* assemble frame */
	*p++ = (L1OIP_VERSION << 6) /* version and coding */
		| (hc->pri ? 0x20 : 0x00) /* type */
		| (hc->id ? 0x10 : 0x00) /* id */
		| localcodec;
	if (hc->id) {
		*p++ = hc->id >> 24; /* id */
		*p++ = hc->id >> 16;
		*p++ = hc->id >> 8;
		*p++ = hc->id;
	}
	*p++ =  0x00 + channel; /* m-flag, channel */
	*p++ = timebase >> 8; /* time base */
	*p++ = timebase;

	if (buf && len) { /* add data to frame */
		if (localcodec == 1 && ulaw)
			l1oip_ulaw_to_alaw(buf, len, p);
		else if (localcodec == 2 && !ulaw)
			l1oip_alaw_to_ulaw(buf, len, p);
		else if (localcodec == 3)
			len = l1oip_law_to_4bit(buf, len, p,
						&hc->chan[channel].codecstate);
		else
			memcpy(p, buf, len);
	}
	len += p - frame;

	/* check for socket in safe condition */
	spin_lock(&hc->socket_lock);
	if (!hc->socket) {
		spin_unlock(&hc->socket_lock);
		return 0;
	}
	/* seize socket */
	socket = hc->socket;
	hc->socket = NULL;
	spin_unlock(&hc->socket_lock);
	/* send packet */
	if (debug & DEBUG_L1OIP_MSG)
		printk(KERN_DEBUG "%s: sending packet to socket (len "
		       "= %d)\n", __func__, len);
	hc->sendiov.iov_base = frame;
	hc->sendiov.iov_len  = len;
	len = kernel_sendmsg(socket, &hc->sendmsg, &hc->sendiov, 1, len);
	/* give socket back */
	hc->socket = socket; /* no locking required */

	return len;
}