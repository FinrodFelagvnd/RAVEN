int l2tp_tunnel_register(struct l2tp_tunnel *tunnel, struct net *net,
			 struct l2tp_tunnel_cfg *cfg)
{
	struct l2tp_tunnel *tunnel_walk;
	struct l2tp_net *pn;
	struct socket *sock;
	struct sock *sk;
	int ret;

	if (tunnel->fd < 0) {
		ret = l2tp_tunnel_sock_create(net, tunnel->tunnel_id,
					      tunnel->peer_tunnel_id, cfg,
					      &sock);
		if (ret < 0)
			goto err;
	} else {
		sock = sockfd_lookup(tunnel->fd, &ret);
		if (!sock)
			goto err;

		ret = l2tp_validate_socket(sock->sk, net, tunnel->encap);
		if (ret < 0)
			goto err_sock;
	}

	tunnel->l2tp_net = net;
	pn = l2tp_pernet(net);

	sk = sock->sk;
	sock_hold(sk);
	tunnel->sock = sk;

	spin_lock_bh(&pn->l2tp_tunnel_list_lock);
	list_for_each_entry(tunnel_walk, &pn->l2tp_tunnel_list, list) {
		if (tunnel_walk->tunnel_id == tunnel->tunnel_id) {
			spin_unlock_bh(&pn->l2tp_tunnel_list_lock);
			sock_put(sk);
			ret = -EEXIST;
			goto err_sock;
		}
	}
	list_add_rcu(&tunnel->list, &pn->l2tp_tunnel_list);
	spin_unlock_bh(&pn->l2tp_tunnel_list_lock);

	if (tunnel->encap == L2TP_ENCAPTYPE_UDP) {
		struct udp_tunnel_sock_cfg udp_cfg = {
			.sk_user_data = tunnel,
			.encap_type = UDP_ENCAP_L2TPINUDP,
			.encap_rcv = l2tp_udp_encap_recv,
			.encap_destroy = l2tp_udp_encap_destroy,
		};

		setup_udp_tunnel_sock(net, sock, &udp_cfg);
	} else {
		sk->sk_user_data = tunnel;
	}

	tunnel->old_sk_destruct = sk->sk_destruct;
	sk->sk_destruct = &l2tp_tunnel_destruct;
	lockdep_set_class_and_name(&sk->sk_lock.slock, &l2tp_socket_class,
				   "l2tp_sock");
	sk->sk_allocation = GFP_ATOMIC;

	trace_register_tunnel(tunnel);

	if (tunnel->fd >= 0)
		sockfd_put(sock);

	return 0;

err_sock:
	if (tunnel->fd < 0)
		sock_release(sock);
	else
		sockfd_put(sock);
err:
	return ret;
}