static void
l1oip_socket_parse(struct l1oip *hc, struct sockaddr_in *sin, u8 *buf, int len)
{
	u32			packet_id;
	u8			channel;
	u8			remotecodec;
	u16			timebase;
	int			m, mlen;
	int			len_start = len; /* initial frame length */
	struct dchannel		*dch = hc->chan[hc->d_idx].dch;

	if (debug & DEBUG_L1OIP_MSG)
		printk(KERN_DEBUG "%s: received frame, parsing... (%d)\n",
		       __func__, len);

	/* check length */
	if (len < 1 + 1 + 2) {
		printk(KERN_WARNING "%s: packet error - length %d below "
		       "4 bytes\n", __func__, len);
		return;
	}

	/* check version */
	if (((*buf) >> 6) != L1OIP_VERSION) {
		printk(KERN_WARNING "%s: packet error - unknown version %d\n",
		       __func__, buf[0]>>6);
		return;
	}

	/* check type */
	if (((*buf) & 0x20) && !hc->pri) {
		printk(KERN_WARNING "%s: packet error - received E1 packet "
		       "on S0 interface\n", __func__);
		return;
	}
	if (!((*buf) & 0x20) && hc->pri) {
		printk(KERN_WARNING "%s: packet error - received S0 packet "
		       "on E1 interface\n", __func__);
		return;
	}

	/* get id flag */
	packet_id = (*buf >> 4) & 1;

	/* check coding */
	remotecodec = (*buf) & 0x0f;
	if (remotecodec > 3) {
		printk(KERN_WARNING "%s: packet error - remotecodec %d "
		       "unsupported\n", __func__, remotecodec);
		return;
	}
	buf++;
	len--;

	/* check packet_id */
	if (packet_id) {
		if (!hc->id) {
			printk(KERN_WARNING "%s: packet error - packet has id "
			       "0x%x, but we have not\n", __func__, packet_id);
			return;
		}
		if (len < 4) {
			printk(KERN_WARNING "%s: packet error - packet too "
			       "short for ID value\n", __func__);
			return;
		}
		packet_id = (*buf++) << 24;
		packet_id += (*buf++) << 16;
		packet_id += (*buf++) << 8;
		packet_id += (*buf++);
		len -= 4;

		if (packet_id != hc->id) {
			printk(KERN_WARNING "%s: packet error - ID mismatch, "
			       "got 0x%x, we 0x%x\n",
			       __func__, packet_id, hc->id);
			return;
		}
	} else {
		if (hc->id) {
			printk(KERN_WARNING "%s: packet error - packet has no "
			       "ID, but we have\n", __func__);
			return;
		}
	}

multiframe:
	if (len < 1) {
		printk(KERN_WARNING "%s: packet error - packet too short, "
		       "channel expected at position %d.\n",
		       __func__, len-len_start + 1);
		return;
	}

	/* get channel and multiframe flag */
	channel = *buf & 0x7f;
	m = *buf >> 7;
	buf++;
	len--;

	/* check length on multiframe */
	if (m) {
		if (len < 1) {
			printk(KERN_WARNING "%s: packet error - packet too "
			       "short, length expected at position %d.\n",
			       __func__, len_start - len - 1);
			return;
		}

		mlen = *buf++;
		len--;
		if (mlen == 0)
			mlen = 256;
		if (len < mlen + 3) {
			printk(KERN_WARNING "%s: packet error - length %d at "
			       "position %d exceeds total length %d.\n",
			       __func__, mlen, len_start-len - 1, len_start);
			return;
		}
		if (len == mlen + 3) {
			printk(KERN_WARNING "%s: packet error - length %d at "
			       "position %d will not allow additional "
			       "packet.\n",
			       __func__, mlen, len_start-len + 1);
			return;
		}
	} else
		mlen = len - 2; /* single frame, subtract timebase */

	if (len < 2) {
		printk(KERN_WARNING "%s: packet error - packet too short, time "
		       "base expected at position %d.\n",
		       __func__, len-len_start + 1);
		return;
	}

	/* get time base */
	timebase = (*buf++) << 8;
	timebase |= (*buf++);
	len -= 2;

	/* if inactive, we send up a PH_ACTIVATE and activate */
	if (!test_bit(FLG_ACTIVE, &dch->Flags)) {
		if (debug & (DEBUG_L1OIP_MSG | DEBUG_L1OIP_SOCKET))
			printk(KERN_DEBUG "%s: interface become active due to "
			       "received packet\n", __func__);
		test_and_set_bit(FLG_ACTIVE, &dch->Flags);
		_queue_data(&dch->dev.D, PH_ACTIVATE_IND, MISDN_ID_ANY, 0,
			    NULL, GFP_ATOMIC);
	}

	/* distribute packet */
	l1oip_socket_recv(hc, remotecodec, channel, timebase, buf, mlen);
	buf += mlen;
	len -= mlen;

	/* multiframe */
	if (m)
		goto multiframe;

	/* restart timer */
	if (time_before(hc->timeout_tl.expires, jiffies + 5 * HZ) || !hc->timeout_on) {
		hc->timeout_on = 1;
		mod_timer(&hc->timeout_tl, jiffies + L1OIP_TIMEOUT * HZ);
	} else /* only adjust timer */
		hc->timeout_tl.expires = jiffies + L1OIP_TIMEOUT * HZ;

	/* if ip or source port changes */
	if ((hc->sin_remote.sin_addr.s_addr != sin->sin_addr.s_addr)
	    || (hc->sin_remote.sin_port != sin->sin_port)) {
		if (debug & DEBUG_L1OIP_SOCKET)
			printk(KERN_DEBUG "%s: remote address changes from "
			       "0x%08x to 0x%08x (port %d to %d)\n", __func__,
			       ntohl(hc->sin_remote.sin_addr.s_addr),
			       ntohl(sin->sin_addr.s_addr),
			       ntohs(hc->sin_remote.sin_port),
			       ntohs(sin->sin_port));
		hc->sin_remote.sin_addr.s_addr = sin->sin_addr.s_addr;
		hc->sin_remote.sin_port = sin->sin_port;
	}
}