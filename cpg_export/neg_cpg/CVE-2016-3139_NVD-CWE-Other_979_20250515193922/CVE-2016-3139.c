static int wacom_parse_hid(struct hid_device *hdev,
			   struct wacom_features *features)
{
	/* result has to be defined as int for some devices */
	int result = 0, touch_max = 0;
	int i = 0, page = 0, finger = 0, pen = 0;
	unsigned char *report = hdev->rdesc;

	for (i = 0; i < hdev->rsize; i++) {

		switch (report[i]) {
		case HID_HDESC_USAGE_PAGE:
			page = report[i + 1];
			i++;
			break;

		case HID_HDESC_USAGE:
			switch (page << 16 | report[i + 1]) {
			case HID_GD_X:
				if (finger) {
					features->device_type = BTN_TOOL_FINGER;
					/* touch device at least supports one touch point */
					touch_max = 1;
					switch (features->type) {
					case TABLETPC2FG:
						features->pktlen = WACOM_PKGLEN_TPC2FG;
						break;

					case MTSCREEN:
					case WACOM_24HDT:
						features->pktlen = WACOM_PKGLEN_MTOUCH;
						break;

					case MTTPC:
					case MTTPC_B:
						features->pktlen = WACOM_PKGLEN_MTTPC;
						break;

					case BAMBOO_PT:
						features->pktlen = WACOM_PKGLEN_BBTOUCH;
						break;

					default:
						features->pktlen = WACOM_PKGLEN_GRAPHIRE;
						break;
					}

					switch (features->type) {
					case BAMBOO_PT:
						features->x_phy =
							get_unaligned_le16(&report[i + 5]);
						features->x_max =
							get_unaligned_le16(&report[i + 8]);
						i += 15;
						break;

					case WACOM_24HDT:
						features->x_max =
							get_unaligned_le16(&report[i + 3]);
						features->x_phy =
							get_unaligned_le16(&report[i + 8]);
						features->unit = report[i - 1];
						features->unitExpo = report[i - 3];
						i += 12;
						break;

					case MTTPC_B:
						features->x_max =
							get_unaligned_le16(&report[i + 3]);
						features->x_phy =
							get_unaligned_le16(&report[i + 6]);
						features->unit = report[i - 5];
						features->unitExpo = report[i - 3];
						i += 9;
						break;

					default:
						features->x_max =
							get_unaligned_le16(&report[i + 3]);
						features->x_phy =
							get_unaligned_le16(&report[i + 6]);
						features->unit = report[i + 9];
						features->unitExpo = report[i + 11];
						i += 12;
						break;
					}
				} else if (pen) {
					/* penabled only accepts exact bytes of data */
					if (features->type >= TABLETPC)
						features->pktlen = WACOM_PKGLEN_GRAPHIRE;
					features->device_type = BTN_TOOL_PEN;
					features->x_max =
						get_unaligned_le16(&report[i + 3]);
					i += 4;
				}
				break;

			case HID_GD_Y:
				if (finger) {
					switch (features->type) {
					case TABLETPC2FG:
					case MTSCREEN:
					case MTTPC:
						features->y_max =
							get_unaligned_le16(&report[i + 3]);
						features->y_phy =
							get_unaligned_le16(&report[i + 6]);
						i += 7;
						break;

					case WACOM_24HDT:
						features->y_max =
							get_unaligned_le16(&report[i + 3]);
						features->y_phy =
							get_unaligned_le16(&report[i - 2]);
						i += 7;
						break;

					case BAMBOO_PT:
						features->y_phy =
							get_unaligned_le16(&report[i + 3]);
						features->y_max =
							get_unaligned_le16(&report[i + 6]);
						i += 12;
						break;

					case MTTPC_B:
						features->y_max =
							get_unaligned_le16(&report[i + 3]);
						features->y_phy =
							get_unaligned_le16(&report[i + 6]);
						i += 9;
						break;

					default:
						features->y_max =
							features->x_max;
						features->y_phy =
							get_unaligned_le16(&report[i + 3]);
						i += 4;
						break;
					}
				} else if (pen) {
					features->y_max =
						get_unaligned_le16(&report[i + 3]);
					i += 4;
				}
				break;

			case HID_DG_FINGER:
				finger = 1;
				i++;
				break;

			/*
			 * Requiring Stylus Usage will ignore boot mouse
			 * X/Y values and some cases of invalid Digitizer X/Y
			 * values commonly reported.
			 */
			case HID_DG_STYLUS:
				pen = 1;
				i++;
				break;

			case HID_DG_CONTACTMAX:
				/* leave touch_max as is if predefined */
				if (!features->touch_max)
					wacom_retrieve_report_data(hdev, features);
				i++;
				break;

			case HID_DG_TIPPRESSURE:
				if (pen) {
					features->pressure_max =
						get_unaligned_le16(&report[i + 3]);
					i += 4;
				}
				break;
			}
			break;

		case HID_HDESC_COLLECTION_END:
			/* reset UsagePage and Finger */
			finger = page = 0;
			break;

		case HID_HDESC_COLLECTION:
			i++;
			switch (report[i]) {
			case HID_HDESC_COLLECTION_LOGICAL:
				i += wacom_parse_logical_collection(&report[i],
								    features);
				break;
			}
			break;
		}
	}

	if (!features->touch_max && touch_max)
		features->touch_max = touch_max;
	result = 0;
	return result;
}