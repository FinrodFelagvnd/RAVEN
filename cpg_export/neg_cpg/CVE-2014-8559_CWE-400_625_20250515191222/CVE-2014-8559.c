void ll_invalidate_aliases(struct inode *inode)
{
	struct dentry *dentry;
	struct ll_d_hlist_node *p;

	LASSERT(inode != NULL);

	CDEBUG(D_INODE, "marking dentries for ino %lu/%u(%p) invalid\n",
	       inode->i_ino, inode->i_generation, inode);

	ll_lock_dcache(inode);
	ll_d_hlist_for_each_entry(dentry, p, &inode->i_dentry, d_alias) {
		CDEBUG(D_DENTRY, "dentry in drop %.*s (%p) parent %p "
		       "inode %p flags %d\n", dentry->d_name.len,
		       dentry->d_name.name, dentry, dentry->d_parent,
		       dentry->d_inode, dentry->d_flags);

		if (unlikely(dentry == dentry->d_sb->s_root)) {
			CERROR("%s: called on root dentry=%p, fid="DFID"\n",
			       ll_get_fsname(dentry->d_sb, NULL, 0),
			       dentry, PFID(ll_inode2fid(inode)));
			lustre_dump_dentry(dentry, 1);
			dump_stack();
		}

		d_lustre_invalidate(dentry, 0);
	}
	ll_unlock_dcache(inode);
}