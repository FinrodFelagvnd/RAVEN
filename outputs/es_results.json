[
  {
    "id": 1,
    "cwe": "CWE-119",
    "cve": "CVE-2006-3635",
    "purpose": "Code purpose:\"\"\"初始化IA-64架构的系统环境，包括处理器、内存、ACPI、控制台等硬件相关设置，并处理启动参数。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核ia64子系统中对无效寄存器栈引擎(RSE)状态处理不当，导致本地用户可通过特制应用程序消耗栈空间造成系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: setup_arch\n- 参数: [char **cmdline_p]\n- 调用者: 未显示\n- 被调用者: [unw_init, ia64_patch_vtop, __va, strlcpy, efi_init, io_port_init, machvec_init_from_cmdline, parse_early_param, early_console_setup, mark_bsp_online, acpi_table_init, acpi_numa_init, per_cpu_scan_finalize, cpus_weight, smp_build_cpu_map, find_memory, ia64_sal_init, hard_smp_processor_id, cpu_init, mmu_context_init, check_sal_cache_flush, acpi_boot_init, efi_mem_type, ia64_mca_init, platform_setup, paging_init]\n\n2. 函数名: unw_init\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n3. 函数名: ia64_patch_vtop\n- 参数: [(u64) __start___vtop_patchlist, (u64) __end___vtop_patchlist]\n- 调用者: setup_arch\n- 被调用者: []\n\n4. 函数名: __va\n- 参数: [ia64_boot_param->command_line]\n- 调用者: setup_arch\n- 被调用者: []\n\n5. 函数名: strlcpy\n- 参数: [boot_command_line, *cmdline_p, COMMAND_LINE_SIZE]\n- 调用者: setup_arch\n- 被调用者: []\n\n6. 函数名: efi_init\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n7. 函数名: io_port_init\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n8. 函数名: machvec_init_from_cmdline\n- 参数: [*cmdline_p]\n- 调用者: setup_arch\n- 被调用者: []\n\n9. 函数名: parse_early_param\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n10. 函数名: early_console_setup\n- 参数: [*cmdline_p]\n- 调用者: setup_arch\n- 被调用者: []\n\n11. 函数名: mark_bsp_online\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n12. 函数名: acpi_table_init\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n13. 函数名: acpi_numa_init\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n14. 函数名: per_cpu_scan_finalize\n- 参数: [(cpus_weight(early_cpu_possible_map) == 0 ? 32 : cpus_weight(early_cpu_possible_map)), additional_cpus]\n- 调用者: setup_arch\n- 被调用者: [cpus_weight]\n\n15. 函数名: cpus_weight\n- 参数: [early_cpu_possible_map]\n- 调用者: per_cpu_scan_finalize\n- 被调用者: []\n\n16. 函数名: smp_build_cpu_map\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n17. 函数名: find_memory\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n18. 函数名: ia64_sal_init\n- 参数: [__va(efi.sal_systab)]\n- 调用者: setup_arch\n- 被调用者: [__va]\n\n19. 函数名: hard_smp_processor_id\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n20. 函数名: cpu_init\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n21. 函数名: mmu_context_init\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n22. 函数名: check_sal_cache_flush\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n23. 函数名: acpi_boot_init\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n24. 函数名: efi_mem_type\n- 参数: [0xA0000]\n- 调用者: setup_arch\n- 被调用者: []\n\n25. 函数名: ia64_mca_init\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n26. 函数名: platform_setup\n- 参数: [cmdline_p]\n- 调用者: setup_arch\n- 被调用者: []\n\n27. 函数名: paging_init\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []"
  },
  {
    "id": 4,
    "cwe": "CWE-119",
    "cve": "CVE-2007-6761",
    "purpose": "Code purpose:\"\"\"该代码用于实现视频缓冲区的内存映射功能，将用户空间的虚拟内存区域(vma)映射到内核空间的视频缓冲区，以便用户空间可以直接访问视频数据。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"未正确初始化videobuf_mapping数据结构，导致计数错误和videobuf泄漏\"\"\"",
    "functions": "Functions:\n1. 函数名: __videobuf_mmap_mapper\n- 参数: [struct videobuf_queue *q, struct vm_area_struct *vma]\n- 调用者: 未明确（应为内核中调用mmap相关操作的代码）\n- 被调用者: [kmalloc, dprintk, kfree, remap_vmalloc_range, memcpy, videobuf_vm_open]\n\n2. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: __videobuf_mmap_mapper\n- 被调用者: []\n\n3. 函数名: dprintk\n- 参数: [int level, const char *fmt, ...]\n- 调用者: __videobuf_mmap_mapper\n- 被调用者: []\n\n4. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: __videobuf_mmap_mapper\n- 被调用者: []\n\n5. 函数名: remap_vmalloc_range\n- 参数: [struct vm_area_struct *vma, void *addr, unsigned long pgoff]\n- 调用者: __videobuf_mmap_mapper\n- 被调用者: []\n\n6. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: __videobuf_mmap_mapper\n- 被调用者: []\n\n7. 函数名: videobuf_vm_open\n- 参数: [struct vm_area_struct *vma]\n- 调用者: __videobuf_mmap_mapper\n- 被调用者: []"
  },
  {
    "id": 5,
    "cwe": "CWE-119",
    "cve": "CVE-2007-6761",
    "purpose": "Code purpose:\"\"\"该代码用于处理视频缓冲区的虚拟内存区域关闭操作，包括减少映射计数、释放相关资源并在计数为零时释放映射结构体。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"未正确初始化videobuf_mapping数据结构，导致count值不正确和videobuf泄漏\"\"\"",
    "functions": "Functions:\n1. 函数名: videobuf_vm_close\n- 参数: [struct vm_area_struct *vma]\n- 调用者: 内核虚拟内存管理系统（当vma区域关闭时）\n- 被调用者: [mutex_lock, mutex_unlock, kfree, dprintk]\n\n2. 函数名: dprintk\n- 参数: [int level, const char *fmt, ...]\n- 调用者: videobuf_vm_close\n- 被调用者: []\n\n3. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: videobuf_vm_close\n- 被调用者: []\n\n4. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: videobuf_vm_close\n- 被调用者: []\n\n5. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: videobuf_vm_close\n- 被调用者: []\n\n6. 函数名: buf_release\n- 参数: [struct videobuf_queue *q, struct videobuf_buffer *buf]\n- 调用者: videobuf_vm_close (通过q->ops->buf_release调用)\n- 被调用者: []"
  },
  {
    "id": 6,
    "cwe": "CWE-119",
    "cve": "CVE-2007-6761",
    "purpose": "Code purpose:\"\"\"该代码片段用于处理视频缓冲区的虚拟内存映射打开操作，增加映射计数器的值\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"未初始化videobuf_mapping数据结构导致计数错误和videobuf泄漏\"\"\"",
    "functions": "Functions:\n1. 函数名: videobuf_vm_open\n- 参数: [struct vm_area_struct *vma]\n- 调用者: 未明确指定（通常由内核内存管理子系统调用）\n- 被调用者: [dprintk]"
  },
  {
    "id": 7,
    "cwe": "CWE-119",
    "cve": "CVE-2007-6762",
    "purpose": "Code purpose:\"\"\"该代码用于处理CIPSO v4协议的标签列表，将网络标签信息添加到DOI定义结构中，但存在数组越界漏洞。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在循环条件中未正确处理数组边界检查，导致doi_def->tags数组可能被越界写入一个元素\"\"\"",
    "functions": "Functions:\n1. 函数名: netlbl_cipsov4_add_common\n- 参数: [info, doi_def]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [nla_get_u32, nla_validate_nested, nla_for_each_nested, nla_get_u8]\n\n2. 函数名: nla_get_u32\n- 参数: [info->attrs[NLBL_CIPSOV4_A_DOI]]\n- 调用者: netlbl_cipsov4_add_common\n- 被调用者: []\n\n3. 函数名: nla_validate_nested\n- 参数: [info->attrs[NLBL_CIPSOV4_A_TAGLST], NLBL_CIPSOV4_A_MAX, netlbl_cipsov4_genl_policy]\n- 调用者: netlbl_cipsov4_add_common\n- 被调用者: []\n\n4. 函数名: nla_for_each_nested\n- 参数: [nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem]\n- 调用者: netlbl_cipsov4_add_common\n- 被调用者: []\n\n5. 函数名: nla_get_u8\n- 参数: [nla]\n- 调用者: netlbl_cipsov4_add_common\n- 被调用者: []"
  },
  {
    "id": 10,
    "cwe": "CWE-119",
    "cve": "CVE-2009-2692",
    "purpose": "Code purpose:\"\"\"该代码片段实现了通过socket发送页面数据的核心功能，主要处理非阻塞标志和多次发送标志的设置，并调用底层操作发送数据\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核未初始化proto_ops结构中的所有函数指针，导致本地用户可通过映射零页并触发空指针解引用获取权限\"\"\"",
    "functions": "Functions:\n1. 函数名: sock_sendpage\n- 参数: [struct file *file, struct page *page, int offset, size_t size, loff_t *ppos, int more]\n- 调用者: 未指定（由内核其他部分调用）\n- 被调用者: [sock->ops->sendpage]\n\n2. 函数名: sock->ops->sendpage\n- 参数: [struct socket *sock, struct page *page, int offset, size_t size, int flags]\n- 调用者: sock_sendpage\n- 被调用者: 未指定（由具体协议实现提供）"
  },
  {
    "id": 28,
    "cwe": "CWE-119",
    "cve": "CVE-2010-5332",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中为Mellanox网卡设备注册MAC地址，并管理MAC地址表的引用计数和空闲索引\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当MAC表中没有空闲条目时，循环结束后未检查free变量仍为初始值-1，导致后续数组越界访问\"\"\"",
    "functions": "Functions:\n1. 函数名: mlx4_register_mac\n- 参数: [struct mlx4_dev *dev, u8 port, u64 mac, int *index]\n- 调用者: N/A\n- 被调用者: [mlx4_dbg, mutex_lock, be64_to_cpu, cpu_to_be64, mlx4_set_port_mac_table, mlx4_err, mutex_unlock]\n\n2. 函数名: mlx4_dbg\n- 参数: [struct mlx4_dev *dev, const char *fmt, ...]\n- 调用者: mlx4_register_mac\n- 被调用者: N/A\n\n3. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: mlx4_register_mac\n- 被调用者: N/A\n\n4. 函数名: be64_to_cpu\n- 参数: [__be64 x]\n- 调用者: mlx4_register_mac\n- 被调用者: N/A\n\n5. 函数名: cpu_to_be64\n- 参数: [u64 x]\n- 调用者: mlx4_register_mac\n- 被调用者: N/A\n\n6. 函数名: mlx4_set_port_mac_table\n- 参数: [struct mlx4_dev *dev, u8 port, __be64 *entries]\n- 调用者: mlx4_register_mac\n- 被调用者: N/A\n\n7. 函数名: mlx4_err\n- 参数: [struct mlx4_dev *dev, const char *fmt, ...]\n- 调用者: mlx4_register_mac\n- 被调用者: N/A\n\n8. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: mlx4_register_mac\n- 被调用者: N/A"
  },
  {
    "id": 29,
    "cwe": "CWE-119",
    "cve": "CVE-2010-5332",
    "purpose": "Code purpose:\"\"\"在Linux内核中为指定端口注册VLAN并管理VLAN表项\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当在mlx4_register_vlan()函数中搜索空闲条目时，如果没有找到空闲条目且循环结束时未更新free变量，会导致后续数组越界访问。\"\"\"",
    "functions": "Functions:\n1. 函数名: mlx4_register_vlan\n- 参数: [struct mlx4_dev *dev, u8 port, u16 vlan, int *index]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [mlx4_set_port_vlan_table, mlx4_warn, mutex_lock, mutex_unlock, be32_to_cpu, cpu_to_be32]\n\n2. 函数名: mlx4_set_port_vlan_table\n- 参数: [struct mlx4_dev *dev, u8 port, u32 *entries]\n- 调用者: mlx4_register_vlan\n- 被调用者: 未明确（可能是底层驱动函数）\n\n3. 函数名: mlx4_warn\n- 参数: [struct mlx4_dev *dev, const char *format, ...]\n- 调用者: mlx4_register_vlan\n- 被调用者: 未明确（可能是内核打印函数）\n\n4. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: mlx4_register_vlan\n- 被调用者: 未明确（内核互斥锁函数）\n\n5. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: mlx4_register_vlan\n- 被调用者: 未明确（内核互斥锁函数）\n\n6. 函数名: be32_to_cpu\n- 参数: [__be32 val]\n- 调用者: mlx4_register_vlan\n- 被调用者: 未明确（字节序转换函数）\n\n7. 函数名: cpu_to_be32\n- 参数: [u32 val]\n- 调用者: mlx4_register_vlan\n- 被调用者: 未明确（字节序转换函数）"
  },
  {
    "id": 30,
    "cwe": "CWE-119",
    "cve": "CVE-2011-4098",
    "purpose": "Code purpose:\"\"\"该代码实现了GFS2文件系统中块分配的功能，包括处理间接块分配、树高度增长以及数据块分配等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"GFS2文件系统中的fallocate实现依赖于页面缓存，在内存不足的情况下可能导致本地用户通过预分配块造成拒绝服务\"\"\"",
    "functions": "Functions:\n1. 函数名: gfs2_bmap_alloc\n- 参数: [inode, lblock, bh_map, mp, sheight, height, maxlen]\n- 调用者: N/A (top-level function)\n- 被调用者: [GFS2_I, GFS2_SB, gfs2_trans_add_bh, gfs2_extent_length, metapointer, min, metapath_branch_start, gfs2_alloc_block, gfs2_is_jdata, gfs2_trans_add_unrevoke, gfs2_indirect_init, gfs2_buffer_copy_tail, gfs2_buffer_clear_tail, brelse, cpu_to_be64, gfs2_add_inode_blocks, gfs2_dinode_out, map_bh, set_buffer_new]\n\n2. 函数名: GFS2_I\n- 参数: [inode]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n3. 函数名: GFS2_SB\n- 参数: [inode]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n4. 函数名: gfs2_trans_add_bh\n- 参数: [ip->i_gl, dibh, 1]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n5. 函数名: gfs2_extent_length\n- 参数: [bh->b_data, bh->b_size, ptr, maxlen, &eob]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n6. 函数名: metapointer\n- 参数: [end_of_metadata, mp]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n7. 函数名: min\n- 参数: [maxlen, ptrs_per_blk - mp->mp_list[end_of_metadata]]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n8. 函数名: metapath_branch_start\n- 参数: [mp]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n9. 函数名: gfs2_alloc_block\n- 参数: [ip, &bn, &n]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n10. 函数名: gfs2_is_jdata\n- 参数: [ip]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n11. 函数名: gfs2_trans_add_unrevoke\n- 参数: [sdp, bn, n]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n12. 函数名: gfs2_indirect_init\n- 参数: [mp, ip->i_gl, i, 0, bn++]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n13. 函数名: gfs2_buffer_copy_tail\n- 参数: [mp->mp_bh[i], sizeof(struct gfs2_meta_header), dibh, sizeof(struct gfs2_dinode)]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n14. 函数名: gfs2_buffer_clear_tail\n- 参数: [dibh, sizeof(struct gfs2_dinode) + sizeof(__be64)]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n15. 函数名: brelse\n- 参数: [mp->mp_bh[i]]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n16. 函数名: cpu_to_be64\n- 参数: [bn++]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n17. 函数名: gfs2_add_inode_blocks\n- 参数: [&ip->i_inode, alloced]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n18. 函数名: gfs2_dinode_out\n- 参数: [ip, mp->mp_bh[0]->b_data]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n19. 函数名: map_bh\n- 参数: [bh_map, inode->i_sb, dblock]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n20. 函数名: set_buffer_new\n- 参数: [bh_map]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []"
  },
  {
    "id": 31,
    "cwe": "CWE-119",
    "cve": "CVE-2011-4098",
    "purpose": "Code purpose:\"\"\"该代码实现了GFS2文件系统中预分配文件空间的功能，通过操作页缓存来扩展文件大小并分配物理块。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"GFS2文件系统中的fallocate实现过度依赖页面缓存，在内存不足的情况下可能导致本地用户通过预分配块造成拒绝服务。\"\"\"",
    "functions": "Functions:\n1. 函数名: fallocate_chunk\n- 参数: [struct inode *inode, loff_t offset, loff_t len, int mode]\n- 调用者: 未显示\n- 被调用者: [GFS2_I, gfs2_meta_inode_buffer, gfs2_trans_add_bh, gfs2_is_stuffed, gfs2_unstuff_dinode, grab_cache_page_write_begin, write_empty_blocks, i_size_write, unlock_page, page_cache_release, mark_inode_dirty, brelse]\n\n2. 函数名: GFS2_I\n- 参数: [struct inode *inode]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示\n\n3. 函数名: gfs2_meta_inode_buffer\n- 参数: [struct gfs2_inode *ip, struct buffer_head **dibh]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示\n\n4. 函数名: gfs2_trans_add_bh\n- 参数: [struct gfs2_glock *gl, struct buffer_head *bh, int meta]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示\n\n5. 函数名: gfs2_is_stuffed\n- 参数: [struct gfs2_inode *ip]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示\n\n6. 函数名: gfs2_unstuff_dinode\n- 参数: [struct gfs2_inode *ip, struct page *page]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示\n\n7. 函数名: grab_cache_page_write_begin\n- 参数: [struct address_space *mapping, pgoff_t index, unsigned flags]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示\n\n8. 函数名: write_empty_blocks\n- 参数: [struct page *page, unsigned int from, unsigned int to, int mode]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示\n\n9. 函数名: i_size_write\n- 参数: [struct inode *inode, loff_t i_size]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示\n\n10. 函数名: unlock_page\n- 参数: [struct page *page]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示\n\n11. 函数名: page_cache_release\n- 参数: [struct page *page]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示\n\n12. 函数名: mark_inode_dirty\n- 参数: [struct inode *inode]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示\n\n13. 函数名: brelse\n- 参数: [struct buffer_head *bh]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示"
  },
  {
    "id": 32,
    "cwe": "CWE-119",
    "cve": "CVE-2011-4098",
    "purpose": "Code purpose:\"\"\"该代码实现了GFS2文件系统中的fallocate功能，用于预分配文件空间，但在内存不足时可能因依赖页面缓存而导致拒绝服务漏洞\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"GFS2文件系统中的fallocate实现依赖于页缓存，在内存不足的情况下可能导致本地用户通过预分配块造成拒绝服务\"\"\"",
    "functions": "Functions:\n1. 函数名: gfs2_fallocate\n- 参数: [struct file *file, int mode, loff_t offset, loff_t len]\n- 调用者: 无（系统调用接口）\n- 被调用者: [gfs2_holder_init, gfs2_glock_nq, gfs2_write_alloc_required, gfs2_alloc_get, gfs2_quota_lock_check, gfs2_write_calc_reserv, gfs2_inplace_reserve, calc_max_reserv, gfs2_trans_begin, fallocate_chunk, gfs2_trans_end, gfs2_inplace_release, gfs2_quota_unlock, gfs2_alloc_put, gfs2_glock_dq, gfs2_holder_uninit]\n\n2. 函数名: gfs2_holder_init\n- 参数: [ip->i_gl, LM_ST_EXCLUSIVE, 0, &ip->i_gh]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n3. 函数名: gfs2_glock_nq\n- 参数: [&ip->i_gh]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n4. 函数名: gfs2_write_alloc_required\n- 参数: [ip, offset, len]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n5. 函数名: gfs2_alloc_get\n- 参数: [ip]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n6. 函数名: gfs2_quota_lock_check\n- 参数: [ip]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n7. 函数名: gfs2_write_calc_reserv\n- 参数: [ip, bytes, &data_blocks, &ind_blocks]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n8. 函数名: gfs2_inplace_reserve\n- 参数: [ip]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n9. 函数名: calc_max_reserv\n- 参数: [ip, len, &max_bytes, &data_blocks, &ind_blocks]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n10. 函数名: gfs2_trans_begin\n- 参数: [sdp, rblocks, PAGE_CACHE_SIZE/sdp->sd_sb.sb_bsize]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n11. 函数名: fallocate_chunk\n- 参数: [inode, offset, max_bytes, mode]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n12. 函数名: gfs2_trans_end\n- 参数: [sdp]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n13. 函数名: gfs2_inplace_release\n- 参数: [ip]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n14. 函数名: gfs2_quota_unlock\n- 参数: [ip]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n15. 函数名: gfs2_alloc_put\n- 参数: [ip]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n16. 函数名: gfs2_glock_dq\n- 参数: [&ip->i_gh]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n17. 函数名: gfs2_holder_uninit\n- 参数: [&ip->i_gh]\n- 调用者: gfs2_fallocate\n- 被调用者: 无"
  },
  {
    "id": 39,
    "cwe": "CWE-119",
    "cve": "CVE-2011-5327",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中为TCM（Target Core Module）环回驱动创建和注册一个NAA（Network Address Authority）目标端口组，处理传入的配置参数并验证其有效性。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在tcm_loop_make_naa_tpg函数中，对tpgt值的边界检查不严格，存在off-by-one错误，可能导致数组越界访问和内存损坏\"\"\"",
    "functions": "Functions:\n1. 函数名: tcm_loop_make_naa_tpg\n- 参数: [wwn, group, name]\n- 调用者: 未明确显示（由configfs调用）\n- 被调用者: [container_of, strstr, printk, simple_strtoul, core_tpg_register, tcm_loop_dump_proto_id, config_item_name]\n\n2. 函数名: container_of\n- 参数: [wwn, struct tcm_loop_hba, tl_hba_wwn]\n- 调用者: tcm_loop_make_naa_tpg\n- 被调用者: []\n\n3. 函数名: strstr\n- 参数: [name, \"tpgt_\"]\n- 调用者: tcm_loop_make_naa_tpg\n- 被调用者: []\n\n4. 函数名: printk\n- 参数: [KERN_ERR, \"Unable to locate \\\"tpgt_#\\\" directory group\\n\"] 和 [KERN_ERR, \"Passed tpgt: %hu exceeds TL_TPGS_PER_HBA: %u\\n\", tpgt, TL_TPGS_PER_HBA] 和 [KERN_INFO, \"TCM_Loop_ConfigFS: Allocated Emulated %s Target Port %s,t,0x%04x\\n\", tcm_loop_dump_proto_id(tl_hba), config_item_name(&wwn->wwn_group.cg_item), tpgt]\n- 调用者: tcm_loop_make_naa_tpg\n- 被调用者: []\n\n5. 函数名: simple_strtoul\n- 参数: [tpgt_str, &end_ptr, 0]\n- 调用者: tcm_loop_make_naa_tpg\n- 被调用者: []\n\n6. 函数名: core_tpg_register\n- 参数: [&tcm_loop_fabric_configfs->tf_ops, wwn, &tl_tpg->tl_se_tpg, tl_tpg, TRANSPORT_TPG_TYPE_NORMAL]\n- 调用者: tcm_loop_make_naa_tpg\n- 被调用者: []\n\n7. 函数名: tcm_loop_dump_proto_id\n- 参数: [tl_hba]\n- 调用者: tcm_loop_make_naa_tpg\n- 被调用者: []\n\n8. 函数名: config_item_name\n- 参数: [&wwn->wwn_group.cg_item]\n- 调用者: tcm_loop_make_naa_tpg\n- 被调用者: []"
  },
  {
    "id": 40,
    "cwe": "CWE-119",
    "cve": "CVE-2012-2119",
    "purpose": "Code purpose:\"\"\"将用户空间的iovec数据通过零拷贝方式复制到内核空间的sk_buff中\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理长向量长度时未正确验证边界条件，导致缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: zerocopy_sg_from_iovec\n- 参数: [skb, from, offset, count]\n- 调用者: 未显示（由macvtap设备驱动调用）\n- 被调用者: [iov_length, min_t, copy_from_user, get_user_pages_fast, skb_shinfo, __skb_fill_page_desc]\n\n2. 函数名: iov_length\n- 参数: [from, count]\n- 调用者: zerocopy_sg_from_iovec\n- 被调用者: 未显示\n\n3. 函数名: min_t\n- 参数: [unsigned int, copy, from->iov_len - offset]\n- 调用者: zerocopy_sg_from_iovec\n- 被调用者: 未显示\n\n4. 函数名: copy_from_user\n- 参数: [skb->data + offset1, from->iov_base + offset, size]\n- 调用者: zerocopy_sg_from_iovec\n- 被调用者: 未显示\n\n5. 函数名: get_user_pages_fast\n- 参数: [base, size, 0, &page[i]]\n- 调用者: zerocopy_sg_from_iovec\n- 被调用者: 未显示\n\n6. 函数名: skb_shinfo\n- 参数: [skb]\n- 调用者: zerocopy_sg_from_iovec\n- 被调用者: 未显示\n\n7. 函数名: __skb_fill_page_desc\n- 参数: [skb, i, page[i], off, size]\n- 调用者: zerocopy_sg_from_iovec\n- 被调用者: 未显示"
  },
  {
    "id": 42,
    "cwe": "CWE-119",
    "cve": "CVE-2012-2137",
    "purpose": "Code purpose:\"\"\"该代码用于设置KVM虚拟机的IRQ路由表条目，处理不同类型的中断路由配置，包括IRQ芯片和MSI中断。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"setup_routing_entry函数在处理MSI中断路由时未正确验证输入参数，导致缓冲区溢出漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: setup_routing_entry\n- 参数: [struct kvm_irq_routing_table *rt, struct kvm_kernel_irq_routing_entry *e, const struct kvm_irq_routing_entry *ue]\n- 调用者: 未明确显示（通常是KVM子系统中的IRQ路由设置相关函数）\n- 被调用者: [kvm_set_pic_irq, kvm_set_ioapic_irq, kvm_set_msi]\n\n2. 函数名: kvm_set_pic_irq\n- 参数: 未显示（由函数指针调用）\n- 调用者: setup_routing_entry\n- 被调用者: []\n\n3. 函数名: kvm_set_ioapic_irq\n- 参数: 未显示（由函数指针调用）\n- 调用者: setup_routing_entry\n- 被调用者: []\n\n4. 函数名: kvm_set_msi\n- 参数: 未显示（由函数指针调用）\n- 调用者: setup_routing_entry\n- 被调用者: []\n\n5. 函数名: hlist_for_each_entry\n- 参数: [ei, n, &rt->map[ue->gsi], link]\n- 调用者: setup_routing_entry\n- 被调用者: []\n\n6. 函数名: hlist_add_head\n- 参数: [&e->link, &rt->map[e->gsi]]\n- 调用者: setup_routing_entry\n- 被调用者: []"
  },
  {
    "id": 53,
    "cwe": "CWE-119",
    "cve": "CVE-2012-2745",
    "purpose": "Code purpose:\"\"\"该代码用于在进程创建时复制或创建新的凭证(credentials)，包括处理线程组凭证、密钥环(keyring)以及用户命名空间等，确保新进程或线程拥有适当的权限和访问控制。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在copy_creds函数中，当CLONE_THREAD标志被设置时，未能正确处理会话密钥环的替换，导致子进程获得了无效的会话密钥环引用\"\"\"",
    "functions": "Functions:\n1. 函数名: copy_creds\n- 参数: [struct task_struct *p, unsigned long clone_flags]\n- 调用者: N/A\n- 被调用者: [get_cred, alter_cred_subscribers, atomic_read, read_cred_subscribers, atomic_inc, prepare_creds, create_user_ns, key_put, install_thread_keyring_to_cred, kmalloc, atomic_set, spin_lock_init, key_get, release_tgcred, validate_creds, put_cred]\n\n2. 函数名: get_cred\n- 参数: [struct cred *cred]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n3. 函数名: alter_cred_subscribers\n- 参数: [struct cred *cred, int count]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n4. 函数名: atomic_read\n- 参数: [atomic_t *v]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n5. 函数名: read_cred_subscribers\n- 参数: [struct cred *cred]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n6. 函数名: atomic_inc\n- 参数: [atomic_t *v]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n7. 函数名: prepare_creds\n- 参数: []\n- 调用者: copy_creds\n- 被调用者: N/A\n\n8. 函数名: create_user_ns\n- 参数: [struct cred *new]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n9. 函数名: key_put\n- 参数: [struct key *key]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n10. 函数名: install_thread_keyring_to_cred\n- 参数: [struct cred *new]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n11. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n12. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n13. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n14. 函数名: key_get\n- 参数: [struct key *key]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n15. 函数名: release_tgcred\n- 参数: [struct cred *new]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n16. 函数名: validate_creds\n- 参数: [struct cred *cred]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n17. 函数名: put_cred\n- 参数: [struct cred *cred]\n- 调用者: copy_creds\n- 被调用者: N/A"
  },
  {
    "id": 54,
    "cwe": "CWE-119",
    "cve": "CVE-2012-3364",
    "purpose": "Code purpose:\"\"\"处理NFC设备激活参数，根据不同的RF技术和模式提取并复制相应的数据到结构体中\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"未验证输入数据的长度是否超出目标缓冲区大小，导致栈缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: nci_extract_activation_params_iso_dep\n- 参数: [struct nci_dev *ndev, struct nci_rf_intf_activated_ntf *ntf, __u8 *data]\n- 调用者: 未显示在代码片段中\n- 被调用者: [memcpy, pr_debug, pr_err]\n\n2. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: nci_extract_activation_params_iso_dep\n- 被调用者: []\n\n3. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: nci_extract_activation_params_iso_dep\n- 被调用者: []\n\n4. 函数名: pr_err\n- 参数: [const char *fmt, ...]\n- 调用者: nci_extract_activation_params_iso_dep\n- 被调用者: []"
  },
  {
    "id": 55,
    "cwe": "CWE-119",
    "cve": "CVE-2012-3364",
    "purpose": "Code purpose:\"\"\"从NCI数据中提取NFCF被动轮询模式的RF参数，包括比特率和sensf_res数据\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未验证输入数据中sensf_res_len字段的长度，导致memcpy操作可能引发栈缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: nci_extract_rf_params_nfcf_passive_poll\n- 参数: [struct nci_dev *ndev, struct rf_tech_specific_params_nfcf_poll *nfcf_poll, __u8 *data]\n- 调用者: 未明确（由NCI模块调用）\n- 被调用者: [memcpy, pr_debug]\n\n2. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: nci_extract_rf_params_nfcf_passive_poll\n- 被调用者: []\n\n3. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: nci_extract_rf_params_nfcf_passive_poll\n- 被调用者: []"
  },
  {
    "id": 56,
    "cwe": "CWE-119",
    "cve": "CVE-2012-3364",
    "purpose": "Code purpose:\"\"\"从NFC数据中提取NFCA被动轮询模式的RF技术特定参数\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对输入的nfcid1_len和sel_res_len长度进行有效验证，导致memcpy操作可能引发栈缓冲区溢出漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: nci_extract_rf_params_nfca_passive_poll\n- 参数: [struct nci_dev *ndev, struct rf_tech_specific_params_nfca_poll *nfca_poll, __u8 *data]\n- 调用者: 未明确显示（由NCI接口调用）\n- 被调用者: [__le16_to_cpu, memcpy, pr_debug]\n\n2. 函数名: __le16_to_cpu\n- 参数: [__u16 *data]\n- 调用者: nci_extract_rf_params_nfca_passive_poll\n- 被调用者: []\n\n3. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: nci_extract_rf_params_nfca_passive_poll\n- 被调用者: []\n\n4. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: nci_extract_rf_params_nfca_passive_poll\n- 被调用者: []"
  },
  {
    "id": 57,
    "cwe": "CWE-119",
    "cve": "CVE-2012-3364",
    "purpose": "Code purpose:\"\"\"从NFC数据中提取RF技术特定参数并复制到目标缓冲区\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"未对输入的sensb_res_len进行有效验证，导致memcpy操作时可能发生栈缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: nci_extract_rf_params_nfcb_passive_poll\n- 参数: [struct nci_dev *ndev, struct rf_tech_specific_params_nfcb_poll *nfcb_poll, __u8 *data]\n- 调用者: 未明确（由NCI模块调用）\n- 被调用者: [memcpy, pr_debug]\n\n2. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: nci_extract_rf_params_nfcb_passive_poll\n- 被调用者: []\n\n3. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: nci_extract_rf_params_nfcb_passive_poll\n- 被调用者: []"
  },
  {
    "id": 142,
    "cwe": "CWE-119",
    "cve": "CVE-2012-6704",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中获取套接字选项(sock_getsockopt)的功能，处理各种套接字选项的查询请求并将结果返回给用户空间。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理SO_SNDBUF和SO_RCVBUF选项时未正确验证负数值，导致本地用户可利用CAP_NET_ADMIN权限通过特制的setsockopt系统调用造成内存破坏或系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: sock_getsockopt\n- 参数: [struct socket *sock, int level, int optname, char __user *optval, int __user *optlen]\n- 调用者: 未明确显示（通常是系统调用或内核其他模块）\n- 被调用者: [get_user, memset, sock_flag, sock_error, xchg, sock_warn_obsolete_bsdism, cred_to_ucred, copy_to_user, put_user, security_socket_getpeersec_stream]\n\n2. 函数名: get_user\n- 参数: [len, optlen]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n3. 函数名: memset\n- 参数: [&v, 0, sizeof(v)]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n4. 函数名: sock_flag\n- 参数: [sk, SOCK_DBG/SOCK_LOCALROUTE/SOCK_BROADCAST/SOCK_KEEPOPEN/SOCK_URGINLINE/SOCK_LINGER/SOCK_RCVTSTAMP/SOCK_RCVTSTAMPNS/SOCK_TIMESTAMPING_TX_HARDWARE/SOCK_TIMESTAMPING_TX_SOFTWARE/SOCK_TIMESTAMPING_RX_HARDWARE/SOCK_TIMESTAMPING_RX_SOFTWARE/SOCK_TIMESTAMPING_SOFTWARE/SOCK_TIMESTAMPING_SYS_HARDWARE/SOCK_TIMESTAMPING_RAW_HARDWARE/SOCK_RXQ_OVFL/SOCK_WIFI_STATUS/SOCK_NOFCS]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n5. 函数名: sock_error\n- 参数: [sk]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n6. 函数名: xchg\n- 参数: [&sk->sk_err_soft, 0]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n7. 函数名: sock_warn_obsolete_bsdism\n- 参数: [\"getsockopt\"]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n8. 函数名: cred_to_ucred\n- 参数: [sk->sk_peer_pid, sk->sk_peer_cred, &peercred]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n9. 函数名: copy_to_user\n- 参数: [optval, &peercred/address/&v, len]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n10. 函数名: put_user\n- 参数: [len, optlen]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n11. 函数名: security_socket_getpeersec_stream\n- 参数: [sock, optval, optlen, len]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n12. 函数名: sock->ops->getname\n- 参数: [sock, (struct sockaddr *)address, &lv, 2]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n13. 函数名: sock->ops->set_peek_off\n- 参数: 未显示具体参数\n- 调用者: sock_getsockopt\n- 被调用者: []"
  },
  {
    "id": 143,
    "cwe": "CWE-119",
    "cve": "CVE-2012-6712",
    "purpose": "Code purpose:\"\"\"处理无线网络接口中添加或修改站点(STA)的响应，包括状态检查和内存操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理添加站点的响应时，未正确验证sta_id的范围，导致可能访问超出stations数组边界的元素，造成内存损坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: iwl_process_add_sta_resp\n- 参数: [priv, addsta, pkt]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [IWL_ERR, IWL_DEBUG_INFO, iwl_sta_ucode_activate, spin_lock_irqsave, spin_unlock_irqrestore, IWL_DEBUG_ASSOC]\n\n2. 函数名: IWL_ERR\n- 参数: [priv, format_string, ...]\n- 调用者: iwl_process_add_sta_resp\n- 被调用者: []\n\n3. 函数名: IWL_DEBUG_INFO\n- 参数: [priv, format_string, ...]\n- 调用者: iwl_process_add_sta_resp\n- 被调用者: []\n\n4. 函数名: iwl_sta_ucode_activate\n- 参数: [priv, sta_id]\n- 调用者: iwl_process_add_sta_resp\n- 被调用者: []\n\n5. 函数名: spin_lock_irqsave\n- 参数: [lock, flags]\n- 调用者: iwl_process_add_sta_resp\n- 被调用者: []\n\n6. 函数名: spin_unlock_irqrestore\n- 参数: [lock, flags]\n- 调用者: iwl_process_add_sta_resp\n- 被调用者: []\n\n7. 函数名: IWL_DEBUG_ASSOC\n- 参数: [priv, format_string, ...]\n- 调用者: iwl_process_add_sta_resp\n- 被调用者: []"
  },
  {
    "id": 144,
    "cwe": "CWE-119",
    "cve": "CVE-2012-6712",
    "purpose": "Code purpose:\"\"\"该代码用于激活无线网络驱动中指定站点的Ucode状态，并检查站点是否已激活或存在于驱动程序中\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"未对sta_id参数进行边界检查，导致数组越界访问，造成内存损坏\"\"\"",
    "functions": "Functions:\n1. 函数名: iwl_sta_ucode_activate\n- 参数: [struct iwl_priv *priv, u8 sta_id]\n- 调用者: 未显示（上下文不足）\n- 被调用者: [IWL_ERR, IWL_DEBUG_ASSOC]\n\n2. 函数名: IWL_ERR\n- 参数: [struct iwl_priv *priv, const char *fmt, ...]\n- 调用者: iwl_sta_ucode_activate\n- 被调用者: 未显示（假设为内核日志打印函数）\n\n3. 函数名: IWL_DEBUG_ASSOC\n- 参数: [struct iwl_priv *priv, const char *fmt, ...]\n- 调用者: iwl_sta_ucode_activate\n- 被调用者: 未显示（假设为调试日志打印函数）"
  },
  {
    "id": 151,
    "cwe": "CWE-119",
    "cve": "CVE-2013-0231",
    "purpose": "Code purpose:\"\"\"该代码用于在Xen的PCI后端驱动中启用MSI（消息信号中断）功能，并处理相关的中断向量映射和状态返回。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对verbose_request进行限制，攻击者可通过大量触发MSI启用请求导致内核日志被填满，造成拒绝服务\"\"\"",
    "functions": "Functions:\n1. 函数名: xen_pcibk_enable_msi\n- 参数: [struct xen_pcibk_device *pdev, struct pci_dev *dev, struct xen_pci_op *op]\n- 调用者: 未明确显示（由PCI后端驱动调用）\n- 被调用者: [printk, pci_enable_msi, xen_pirq_from_irq, pci_get_drvdata]\n\n2. 函数名: printk\n- 参数: [KERN_DEBUG/KERN_ERR, format string, variables...]\n- 调用者: xen_pcibk_enable_msi\n- 被调用者: []\n\n3. 函数名: pci_enable_msi\n- 参数: [struct pci_dev *dev]\n- 调用者: xen_pcibk_enable_msi\n- 被调用者: []\n\n4. 函数名: xen_pirq_from_irq\n- 参数: [dev->irq]\n- 调用者: xen_pcibk_enable_msi\n- 被调用者: []\n\n5. 函数名: pci_get_drvdata\n- 参数: [struct pci_dev *dev]\n- 调用者: xen_pcibk_enable_msi\n- 被调用者: []"
  },
  {
    "id": 152,
    "cwe": "CWE-119",
    "cve": "CVE-2013-0231",
    "purpose": "Code purpose:\"\"\"该代码用于在Xen的PCI后端驱动中启用MSI-X中断功能，处理来自客户操作系统的MSI-X请求。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对op->value进行有效限制，导致可以触发大量内核日志消息，造成拒绝服务攻击\"\"\"",
    "functions": "Functions:\n1. 函数名: xen_pcibk_enable_msix\n- 参数: [struct xen_pcibk_device *pdev, struct pci_dev *dev, struct xen_pci_op *op]\n- 调用者: 未明确显示（由PCI后端驱动调用）\n- 被调用者: [printk, kmalloc, pci_enable_msix, xen_pirq_from_irq, kfree, pci_get_drvdata]\n\n2. 函数名: printk\n- 参数: [KERN_DEBUG/KERN_WARNING, format string, ...]\n- 调用者: xen_pcibk_enable_msix\n- 被调用者: []\n\n3. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: xen_pcibk_enable_msix\n- 被调用者: []\n\n4. 函数名: pci_enable_msix\n- 参数: [struct pci_dev *dev, struct msix_entry *entries, int nvec]\n- 调用者: xen_pcibk_enable_msix\n- 被调用者: []\n\n5. 函数名: xen_pirq_from_irq\n- 参数: [int irq]\n- 调用者: xen_pcibk_enable_msix\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: xen_pcibk_enable_msix\n- 被调用者: []\n\n7. 函数名: pci_get_drvdata\n- 参数: [struct pci_dev *pdev]\n- 调用者: xen_pcibk_enable_msix\n- 被调用者: []"
  },
  {
    "id": 155,
    "cwe": "CWE-119",
    "cve": "CVE-2013-0309",
    "purpose": "Code purpose:\"\"\"检查页中间目录(PMD)条目是否标记为存在(_PAGE_PRESENT)\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当使用透明大页时，内核未能正确处理PROT_NONE内存区域的pmd_present检查，导致本地用户可通过特制应用造成系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: pmd_present\n- 参数: [pmd_t pmd]\n- 调用者: 未明确（需结合完整代码上下文）\n- 被调用者: [pmd_flags]\n\n2. 函数名: pmd_flags\n- 参数: [pmd_t pmd]\n- 调用者: [pmd_present]\n- 被调用者: 未明确（需结合完整代码上下文）"
  },
  {
    "id": 156,
    "cwe": "CWE-119",
    "cve": "CVE-2013-0309",
    "purpose": "Code purpose:\"\"\"检查页中间目录(PMD)条目是否标记为大页且存在\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"内核在处理使用透明大页(PROT_NONE)的内存区域时，未能正确验证页表项标志位(_PAGE_PSE和_PAGE_PRESENT)的组合情况，导致本地用户可通过特制应用触发系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: pmd_large\n- 参数: [pmd_t pte]\n- 调用者: 未提供（上下文不足）\n- 被调用者: [pmd_flags]\n\n2. 函数名: pmd_flags\n- 参数: [pmd_t pte]\n- 调用者: [pmd_large]\n- 被调用者: 未提供（上下文不足）"
  },
  {
    "id": 157,
    "cwe": "CWE-119",
    "cve": "CVE-2013-0310",
    "purpose": "Code purpose:\"\"\"验证CIPSO IPv4选项的有效性，包括长度检查、标签验证和内容校验，以防止无效或恶意输入导致系统问题\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在cipso_v4_validate函数中，当处理IPOPT_CIPSO选项时，未充分验证skb->dev指针是否为空，导致本地用户可通过特制的setsockopt调用触发空指针解引用，造成系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: cipso_v4_validate\n- 参数: [const struct sk_buff *skb, unsigned char **option]\n- 调用者: 未明确显示（由系统调用触发）\n- 被调用者: [cipso_v4_doi_search, get_unaligned_be32, cipso_v4_map_lvl_valid, cipso_v4_map_cat_rbm_valid, cipso_v4_map_cat_enum_valid, cipso_v4_map_cat_rng_valid]\n\n2. 函数名: cipso_v4_doi_search\n- 参数: [u32 doi]\n- 调用者: cipso_v4_validate\n- 被调用者: []\n\n3. 函数名: get_unaligned_be32\n- 参数: [const void *p]\n- 调用者: cipso_v4_validate\n- 被调用者: []\n\n4. 函数名: cipso_v4_map_lvl_valid\n- 参数: [struct cipso_v4_doi *doi_def, unsigned char level]\n- 调用者: cipso_v4_validate\n- 被调用者: []\n\n5. 函数名: cipso_v4_map_cat_rbm_valid\n- 参数: [struct cipso_v4_doi *doi_def, unsigned char *catmap, u32 catmap_len]\n- 调用者: cipso_v4_validate\n- 被调用者: []\n\n6. 函数名: cipso_v4_map_cat_enum_valid\n- 参数: [struct cipso_v4_doi *doi_def, unsigned char *catmap, u32 catmap_len]\n- 调用者: cipso_v4_validate\n- 被调用者: []\n\n7. 函数名: cipso_v4_map_cat_rng_valid\n- 参数: [struct cipso_v4_doi *doi_def, unsigned char *catmap, u32 catmap_len]\n- 调用者: cipso_v4_validate\n- 被调用者: []"
  },
  {
    "id": 170,
    "cwe": "CWE-119",
    "cve": "CVE-2013-1772",
    "purpose": "Code purpose:\"\"\"将用户空间提供的多个iovec数据合并为一个字符串并通过printk输出到内核日志\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"内核日志处理函数未正确移除syslog头部的前缀字符串，导致本地用户可通过写入/dev/kmsg触发缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: kmsg_writev\n- 参数: [struct kiocb *iocb, const struct iovec *iv, unsigned long count, loff_t pos]\n- 调用者: 系统调用（未明确显示）\n- 被调用者: [iov_length, kmalloc, copy_from_user, printk, kfree]\n\n2. 函数名: iov_length\n- 参数: [const struct iovec *iv, unsigned long count]\n- 调用者: kmsg_writev\n- 被调用者: []\n\n3. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: kmsg_writev\n- 被调用者: []\n\n4. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: kmsg_writev\n- 被调用者: []\n\n5. 函数名: printk\n- 参数: [const char *fmt, ...]\n- 调用者: kmsg_writev\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: kmsg_writev\n- 被调用者: []"
  },
  {
    "id": 171,
    "cwe": "CWE-119",
    "cve": "CVE-2013-1772",
    "purpose": "Code purpose:\"\"\"该代码用于解锁控制台并处理内核日志缓冲区中的消息，包括将消息传递给控制台驱动程序和唤醒日志守护进程。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"log_prefix函数未能正确移除syslog头部的前缀字符串，导致本地用户可通过写入/dev/kmsg触发call_console_drivers函数调用，造成缓冲区溢出和系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: console_unlock\n- 参数: []\n- 调用者: N/A\n- 被调用者: [up, raw_spin_lock_irqsave, raw_spin_unlock, stop_critical_timings, call_console_drivers, start_critical_timings, local_irq_restore, raw_spin_unlock_irqrestore, console_trylock, wake_up_klogd]\n\n2. 函数名: up\n- 参数: [console_sem]\n- 调用者: console_unlock\n- 被调用者: []\n\n3. 函数名: raw_spin_lock_irqsave\n- 参数: [logbuf_lock, flags]\n- 调用者: console_unlock\n- 被调用者: []\n\n4. 函数名: raw_spin_unlock\n- 参数: [logbuf_lock]\n- 调用者: console_unlock\n- 被调用者: []\n\n5. 函数名: stop_critical_timings\n- 参数: []\n- 调用者: console_unlock\n- 被调用者: []\n\n6. 函数名: call_console_drivers\n- 参数: [_con_start, _log_end]\n- 调用者: console_unlock\n- 被调用者: []\n\n7. 函数名: start_critical_timings\n- 参数: []\n- 调用者: console_unlock\n- 被调用者: []\n\n8. 函数名: local_irq_restore\n- 参数: [flags]\n- 调用者: console_unlock\n- 被调用者: []\n\n9. 函数名: raw_spin_unlock_irqrestore\n- 参数: [logbuf_lock, flags]\n- 调用者: console_unlock\n- 被调用者: []\n\n10. 函数名: console_trylock\n- 参数: []\n- 调用者: console_unlock\n- 被调用者: []\n\n11. 函数名: wake_up_klogd\n- 参数: []\n- 调用者: console_unlock\n- 被调用者: []"
  },
  {
    "id": 172,
    "cwe": "CWE-119",
    "cve": "CVE-2013-1772",
    "purpose": "Code purpose:\"\"\"初始化内核日志缓冲区并处理日志数据的迁移和缓冲区大小调整\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"内核日志缓冲区处理函数未正确移除syslog头部的prefix字符串，导致本地用户可通过写入/dev/kmsg触发缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: setup_log_buf\n- 参数: [early]\n- 调用者: 未显示\n- 被调用者: [memblock_alloc, __va, alloc_bootmem_nopanic, raw_spin_lock_irqsave, raw_spin_unlock_irqrestore, pr_err, pr_info]\n\n2. 函数名: memblock_alloc\n- 参数: [new_log_buf_len, PAGE_SIZE]\n- 调用者: setup_log_buf\n- 被调用者: 未显示\n\n3. 函数名: __va\n- 参数: [mem]\n- 调用者: setup_log_buf\n- 被调用者: 未显示\n\n4. 函数名: alloc_bootmem_nopanic\n- 参数: [new_log_buf_len]\n- 调用者: setup_log_buf\n- 被调用者: 未显示\n\n5. 函数名: raw_spin_lock_irqsave\n- 参数: [&logbuf_lock, flags]\n- 调用者: setup_log_buf\n- 被调用者: 未显示\n\n6. 函数名: raw_spin_unlock_irqrestore\n- 参数: [&logbuf_lock, flags]\n- 调用者: setup_log_buf\n- 被调用者: 未显示\n\n7. 函数名: pr_err\n- 参数: [\"log_buf_len: %ld bytes not available\\n\", new_log_buf_len]\n- 调用者: setup_log_buf\n- 被调用者: 未显示\n\n8. 函数名: pr_info\n- 参数: [\"log_buf_len: %d\\n\", log_buf_len]\n- 调用者: setup_log_buf\n- 被调用者: 未显示\n\n9. 函数名: pr_info\n- 参数: [\"early log buf free: %d(%d%%)\\n\", free, (free * 100) / __LOG_BUF_LEN]\n- 调用者: setup_log_buf\n- 被调用者: 未显示"
  },
  {
    "id": 173,
    "cwe": "CWE-119",
    "cve": "CVE-2013-1772",
    "purpose": "Code purpose:\"\"\"该代码用于设置syslog数据的指针数组，指向内核日志缓冲区的不同位置。\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"未正确处理syslog头部的prefix字符串导致缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: kdb_syslog_data\n- 参数: [syslog_data]\n- 调用者: 未明确（可能是内核其他模块）\n- 被调用者: []"
  },
  {
    "id": 174,
    "cwe": "CWE-119",
    "cve": "CVE-2013-1772",
    "purpose": "Code purpose:\"\"\"为内核崩溃转储设置日志缓冲区的相关符号信息\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核3.x版本中log_prefix函数未能正确移除syslog头部的前缀字符串，导致本地用户可通过写入/dev/kmsg触发缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: log_buf_kexec_setup\n- 参数: []\n- 调用者: N/A\n- 被调用者: [VMCOREINFO_SYMBOL]\n\n2. 函数名: VMCOREINFO_SYMBOL\n- 参数: [log_buf, log_end, log_buf_len, logged_chars]\n- 调用者: log_buf_kexec_setup\n- 被调用者: []"
  },
  {
    "id": 175,
    "cwe": "CWE-119",
    "cve": "CVE-2013-1772",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中的printk功能，用于处理内核消息的格式化输出和日志记录，包括日志级别处理、前缀解析和缓冲区管理等功能。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"log_prefix函数未能正确移除syslog头中的前缀字符串，导致本地用户可通过写入/dev/kmsg触发缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: vprintk\n- 参数: [const char *fmt, va_list args]\n- 调用者: N/A (kernel function)\n- 被调用者: [boot_delay_msec, printk_delay, local_irq_save, smp_processor_id, zap_locks, lockdep_off, raw_spin_lock, strcpy, strlen, vscnprintf, log_prefix, emit_log_char, cpu_clock, do_div, sprintf, console_trylock_for_printk, console_unlock, lockdep_on, local_irq_restore]\n\n2. 函数名: boot_delay_msec\n- 参数: []\n- 调用者: vprintk\n- 被调用者: []\n\n3. 函数名: printk_delay\n- 参数: []\n- 调用者: vprintk\n- 被调用者: []\n\n4. 函数名: local_irq_save\n- 参数: [unsigned long flags]\n- 调用者: vprintk\n- 被调用者: []\n\n5. 函数名: smp_processor_id\n- 参数: []\n- 调用者: vprintk\n- 被调用者: []\n\n6. 函数名: zap_locks\n- 参数: []\n- 调用者: vprintk\n- 被调用者: []\n\n7. 函数名: lockdep_off\n- 参数: []\n- 调用者: vprintk\n- 被调用者: []\n\n8. 函数名: raw_spin_lock\n- 参数: [&logbuf_lock]\n- 调用者: vprintk\n- 被调用者: []\n\n9. 函数名: strcpy\n- 参数: [printk_buf, recursion_bug_msg]\n- 调用者: vprintk\n- 被调用者: []\n\n10. 函数名: strlen\n- 参数: [recursion_bug_msg]\n- 调用者: vprintk\n- 被调用者: []\n\n11. 函数名: vscnprintf\n- 参数: [printk_buf + printed_len, sizeof(printk_buf) - printed_len, fmt, args]\n- 调用者: vprintk\n- 被调用者: []\n\n12. 函数名: log_prefix\n- 参数: [p, &current_log_level, &special]\n- 调用者: vprintk\n- 被调用者: []\n\n13. 函数名: emit_log_char\n- 参数: [char]\n- 调用者: vprintk\n- 被调用者: []\n\n14. 函数名: cpu_clock\n- 参数: [printk_cpu]\n- 调用者: vprintk\n- 被调用者: []\n\n15. 函数名: do_div\n- 参数: [t, 1000000000]\n- 调用者: vprintk\n- 被调用者: []\n\n16. 函数名: sprintf\n- 参数: [tbuf, \"[%5lu.%06lu] \", (unsigned long) t, nanosec_rem / 1000]\n- 调用者: vprintk\n- 被调用者: []\n\n17. 函数名: console_trylock_for_printk\n- 参数: [this_cpu]\n- 调用者: vprintk\n- 被调用者: []\n\n18. 函数名: console_unlock\n- 参数: []\n- 调用者: vprintk\n- 被调用者: []\n\n19. 函数名: lockdep_on\n- 参数: []\n- 调用者: vprintk\n- 被调用者: []\n\n20. 函数名: local_irq_restore\n- 参数: [flags]\n- 调用者: vprintk\n- 被调用者: []"
  },
  {
    "id": 176,
    "cwe": "CWE-119",
    "cve": "CVE-2013-1772",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中系统日志(syslog)的各种操作功能，包括读取、清除日志、控制台日志级别设置等系统调用处理。\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核3.x版本中log_prefix函数未能正确移除syslog头部的前缀字符串，导致本地用户可通过写入/dev/kmsg触发缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: do_syslog\n- 参数: [int type, char __user *buf, int len, bool from_file]\n- 调用者: 未显示（系统调用）\n- 被调用者: [check_syslog_permissions, security_syslog, access_ok, wait_event_interruptible, __put_user, cond_resched, __get_user]\n\n2. 函数名: check_syslog_permissions\n- 参数: [int type, bool from_file]\n- 调用者: do_syslog\n- 被调用者: 未显示\n\n3. 函数名: security_syslog\n- 参数: [int type]\n- 调用者: do_syslog\n- 被调用者: 未显示\n\n4. 函数名: access_ok\n- 参数: [VERIFY_WRITE, buf, len]\n- 调用者: do_syslog\n- 被调用者: 未显示\n\n5. 函数名: wait_event_interruptible\n- 参数: [log_wait, (log_start - log_end)]\n- 调用者: do_syslog\n- 被调用者: 未显示\n\n6. 函数名: __put_user\n- 参数: [c, buf] 或 [c, &buf[count-1-i]] 或 [c, &buf[i]]\n- 调用者: do_syslog\n- 被调用者: 未显示\n\n7. 函数名: cond_resched\n- 参数: []\n- 调用者: do_syslog\n- 被调用者: 未显示\n\n8. 函数名: __get_user\n- 参数: [c, &buf[i+offset]]\n- 调用者: do_syslog\n- 被调用者: 未显示"
  },
  {
    "id": 177,
    "cwe": "CWE-119",
    "cve": "CVE-2013-1772",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中的printk函数，用于内核日志记录，支持可变参数处理并通过不同路径输出日志信息。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"内核printk函数在处理syslog头部前缀字符串时未正确移除前缀，导致本地用户可通过写入/dev/kmsg触发缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: printk\n- 参数: [const char *fmt, ...]\n- 调用者: N/A (kernel-level function)\n- 被调用者: [vkdb_printf, vprintk]\n\n2. 函数名: vkdb_printf\n- 参数: [const char *fmt, va_list args]\n- 调用者: printk\n- 被调用者: N/A\n\n3. 函数名: vprintk\n- 参数: [const char *fmt, va_list args]\n- 调用者: printk\n- 被调用者: N/A\n\n4. 函数名: va_start\n- 参数: [va_list ap, last_arg]\n- 调用者: printk\n- 被调用者: N/A\n\n5. 函数名: va_end\n- 参数: [va_list ap]\n- 调用者: printk\n- 被调用者: N/A\n\n6. 函数名: unlikely\n- 参数: [bool condition]\n- 调用者: printk\n- 被调用者: N/A"
  },
  {
    "id": 178,
    "cwe": "CWE-119",
    "cve": "CVE-2013-1772",
    "purpose": "Code purpose:\"\"\"该代码用于在内核发生特定事件(如OOPS)时转储内核日志缓冲区内容，以便调试或记录系统状态。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"内核日志处理函数未正确移除syslog头部的前缀字符串，导致本地用户可通过写入/dev/kmsg触发缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: kmsg_dump\n- 参数: [reason]\n- 调用者: 未显示（由系统调用）\n- 被调用者: [raw_spin_lock_irqsave, raw_spin_unlock_irqrestore, rcu_read_lock, list_for_each_entry_rcu, rcu_read_unlock, dumper->dump]\n\n2. 函数名: raw_spin_lock_irqsave\n- 参数: [&logbuf_lock, flags]\n- 调用者: kmsg_dump\n- 被调用者: []\n\n3. 函数名: raw_spin_unlock_irqrestore\n- 参数: [&logbuf_lock, flags]\n- 调用者: kmsg_dump\n- 被调用者: []\n\n4. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: kmsg_dump\n- 被调用者: []\n\n5. 函数名: list_for_each_entry_rcu\n- 参数: [dumper, &dump_list, list]\n- 调用者: kmsg_dump\n- 被调用者: [dumper->dump]\n\n6. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: kmsg_dump\n- 被调用者: []\n\n7. 函数名: dumper->dump\n- 参数: [dumper, reason, s1, l1, s2, l2]\n- 调用者: list_for_each_entry_rcu\n- 被调用者: []"
  },
  {
    "id": 179,
    "cwe": "CWE-119",
    "cve": "CVE-2013-1772",
    "purpose": "Code purpose:\"\"\"注册新的控制台设备并管理控制台驱动程序的启用、禁用和切换，包括处理引导控制台和常规控制台之间的关系\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"内核的log_prefix函数未能正确从syslog头部移除前缀字符串，导致本地用户可通过/dev/kmsg写入访问触发缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: register_console\n- 参数: [struct console *newcon]\n- 调用者: 无（顶级函数）\n- 被调用者: [printk, for_each_console, newcon->early_setup, newcon->setup, strcmp, braille_register_console, console_lock, raw_spin_lock_irqsave, raw_spin_unlock_irqrestore, console_unlock, console_sysfs_notify, unregister_console]\n\n2. 函数名: printk\n- 参数: [const char *fmt, ...]\n- 调用者: register_console\n- 被调用者: 无（假设为标准库函数）\n\n3. 函数名: for_each_console\n- 参数: [struct console *con]\n- 调用者: register_console\n- 被调用者: 无（宏定义）\n\n4. 函数名: early_setup\n- 参数: 无\n- 调用者: register_console\n- 被调用者: 无（函数指针）\n\n5. 函数名: setup\n- 参数: [struct console *con, char *options]\n- 调用者: register_console\n- 被调用者: 无（函数指针）\n\n6. 函数名: strcmp\n- 参数: [const char *s1, const char *s2]\n- 调用者: register_console\n- 被调用者: 无（标准库函数）\n\n7. 函数名: braille_register_console\n- 参数: [struct console *con, int index, char *options, char *brl_options]\n- 调用者: register_console\n- 被调用者: 无\n\n8. 函数名: console_lock\n- 参数: 无\n- 调用者: register_console\n- 被调用者: 无\n\n9. 函数名: raw_spin_lock_irqsave\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: register_console\n- 被调用者: 无\n\n10. 函数名: raw_spin_unlock_irqrestore\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: register_console\n- 被调用者: 无\n\n11. 函数名: console_unlock\n- 参数: 无\n- 调用者: register_console\n- 被调用者: 无\n\n12. 函数名: console_sysfs_notify\n- 参数: 无\n- 调用者: register_console\n- 被调用者: 无\n\n13. 函数名: unregister_console\n- 参数: [struct console *con]\n- 调用者: register_console\n- 被调用者: 无"
  },
  {
    "id": 180,
    "cwe": "CWE-119",
    "cve": "CVE-2013-1772",
    "purpose": "Code purpose:\"\"\"该代码片段用于在打印内核日志时尝试获取控制台锁，并在无法使用控制台时安全释放锁以防止缓冲区溢出。\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"内核的log_prefix函数未能正确移除syslog头中的前缀字符串，导致本地用户可通过写入/dev/kmsg触发缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: console_trylock_for_printk\n- 参数: [unsigned int cpu]\n- 调用者: 未显示（上下文不足）\n- 被调用者: [console_trylock, can_use_console, up, raw_spin_unlock]\n\n2. 函数名: console_trylock\n- 参数: []\n- 调用者: console_trylock_for_printk\n- 被调用者: 未显示（上下文不足）\n\n3. 函数名: can_use_console\n- 参数: [unsigned int cpu]\n- 调用者: console_trylock_for_printk\n- 被调用者: 未显示（上下文不足）\n\n4. 函数名: up\n- 参数: [&console_sem]\n- 调用者: console_trylock_for_printk\n- 被调用者: 未显示（上下文不足）\n\n5. 函数名: raw_spin_unlock\n- 参数: [&logbuf_lock]\n- 调用者: console_trylock_for_printk\n- 被调用者: 未显示（上下文不足）"
  },
  {
    "id": 181,
    "cwe": "CWE-119",
    "cve": "CVE-2013-1773",
    "purpose": "Code purpose:\"\"\"该代码用于处理主机与虚拟机之间的键值对(KVP)通信，包括错误处理和UTF-8到UTF-16的字符串编码转换。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在UTF-8到UTF-16的转换过程中，未对输入数据进行有效边界检查，导致缓冲区溢出漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: kvp_respond_to_host\n- 参数: [char *key, char *value, int error]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [utf8s_to_utf16s, strlen, pr_warn, vmbus_sendpacket]\n\n2. 函数名: utf8s_to_utf16s\n- 参数: [char *key_name, int strlen(key_name), wchar_t *kvp_data->data.key]\n- 调用者: kvp_respond_to_host\n- 被调用者: 未显示（可能是内核函数）\n\n3. 函数名: strlen\n- 参数: [char *key_name]\n- 调用者: kvp_respond_to_host\n- 被调用者: 未显示（标准库函数）\n\n4. 函数名: pr_warn\n- 参数: [const char *fmt]\n- 调用者: kvp_respond_to_host\n- 被调用者: 未显示（内核打印函数）\n\n5. 函数名: vmbus_sendpacket\n- 参数: [struct vmbus_channel *channel, char *recv_buffer, u32 buf_len, u64 req_id, int VM_PKT_DATA_INBAND, int 0]\n- 调用者: kvp_respond_to_host\n- 被调用者: 未显示（可能是Hyper-V通信函数）"
  },
  {
    "id": 182,
    "cwe": "CWE-119",
    "cve": "CVE-2013-1773",
    "purpose": "Code purpose:\"\"\"将文件名从UTF-8或本地字符集转换为UTF-16编码格式，并处理VFAT文件系统中的长文件名限制\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核VFAT文件系统实现中，在启用utf8挂载选项时，未正确处理UTF-8到UTF-16转换过程中的缓冲区边界检查，导致缓冲区溢出漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: xlate_to_uni\n- 参数: [const unsigned char *name, int len, unsigned char *outname, int *longlen, int *outlen, int escape, int utf8, struct nls_table *nls]\n- 调用者: 未显示（由VFAT文件系统实现调用）\n- 被调用者: [utf8s_to_utf16s, nls->char2uni]\n\n2. 函数名: utf8s_to_utf16s\n- 参数: [const unsigned char *name, int len, wchar_t *outname]\n- 调用者: xlate_to_uni\n- 被调用者: 未显示\n\n3. 函数名: char2uni\n- 参数: [const unsigned char *ip, int len, wchar_t *op]\n- 调用者: xlate_to_uni\n- 被调用者: 未显示"
  },
  {
    "id": 201,
    "cwe": "CWE-119",
    "cve": "CVE-2013-1860",
    "purpose": "Code purpose:\"\"\"该代码实现了USB CDC-WDM设备驱动中的读取功能，处理来自用户空间的数据读取请求，并管理设备状态和缓冲区。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"wdm_read函数在处理USB设备数据时未充分验证用户空间缓冲区大小，导致堆缓冲区溢出漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: wdm_read\n- 参数: [struct file *file, char __user *buffer, size_t count, loff_t *ppos]\n- 调用者: 未显示（由文件操作结构调用）\n- 被调用者: [mutex_lock_interruptible, ACCESS_ONCE, test_bit, wait_event_interruptible, usb_mark_last_busy, spin_lock_irq, spin_unlock_irq, copy_to_user, mutex_unlock]\n\n2. 函数名: mutex_lock_interruptible\n- 参数: [&desc->rlock]\n- 调用者: wdm_read\n- 被调用者: 未显示（内核函数）\n\n3. 函数名: ACCESS_ONCE\n- 参数: [desc->length]\n- 调用者: wdm_read\n- 被调用者: 未显示（内核宏）\n\n4. 函数名: test_bit\n- 参数: [WDM_DISCONNECTING, &desc->flags], [WDM_READ, &desc->flags], [WDM_RESETTING, &desc->flags]\n- 调用者: wdm_read\n- 被调用者: 未显示（内核函数）\n\n5. 函数名: wait_event_interruptible\n- 参数: [desc->wait, test_bit(WDM_READ, &desc->flags)]\n- 调用者: wdm_read\n- 被调用者: 未显示（内核函数）\n\n6. 函数名: usb_mark_last_busy\n- 参数: [interface_to_usbdev(desc->intf)]\n- 调用者: wdm_read\n- 被调用者: 未显示（内核函数）\n\n7. 函数名: spin_lock_irq\n- 参数: [&desc->iuspin]\n- 调用者: wdm_read\n- 被调用者: 未显示（内核函数）\n\n8. 函数名: spin_unlock_irq\n- 参数: [&desc->iuspin]\n- 调用者: wdm_read\n- 被调用者: 未显示（内核函数）\n\n9. 函数名: copy_to_user\n- 参数: [buffer, desc->ubuf, cntr]\n- 调用者: wdm_read\n- 被调用者: 未显示（内核函数）\n\n10. 函数名: mutex_unlock\n- 参数: [&desc->rlock]\n- 调用者: wdm_read\n- 被调用者: 未显示（内核函数）"
  },
  {
    "id": 202,
    "cwe": "CWE-119",
    "cve": "CVE-2013-1860",
    "purpose": "Code purpose:\"\"\"处理USB接口重置后的恢复操作，包括清除重置标志、恢复URB丢失状态并释放读写锁\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"wdm_post_reset函数在释放锁之前未正确验证描述符状态，可能导致堆缓冲区溢出漏洞，允许通过特制USB设备触发系统崩溃或执行任意代码。\"\"\"",
    "functions": "Functions:\n1. 函数名: wdm_post_reset\n- 参数: [struct usb_interface *intf]\n- 调用者: 未显示\n- 被调用者: [wdm_find_device, clear_bit, recover_from_urb_loss, mutex_unlock]\n\n2. 函数名: wdm_find_device\n- 参数: [struct usb_interface *intf]\n- 调用者: wdm_post_reset\n- 被调用者: 未显示\n\n3. 函数名: clear_bit\n- 参数: [WDM_RESETTING, &desc->flags]\n- 调用者: wdm_post_reset\n- 被调用者: 未显示\n\n4. 函数名: recover_from_urb_loss\n- 参数: [struct wdm_device *desc]\n- 调用者: wdm_post_reset\n- 被调用者: 未显示\n\n5. 函数名: mutex_unlock\n- 参数: [&desc->wlock], [&desc->rlock]\n- 调用者: wdm_post_reset\n- 被调用者: 未显示"
  },
  {
    "id": 203,
    "cwe": "CWE-119",
    "cve": "CVE-2013-1860",
    "purpose": "Code purpose:\"\"\"处理USB CDC-WDM设备的URB回调，将接收到的数据移动到缓冲区并更新状态\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在wdm_in_callback函数中，memmove操作未对desc->length和desc->reslength进行边界检查，导致堆缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: wdm_in_callback\n- 参数: [struct urb *urb]\n- 调用者: 未显示（由USB子系统调用）\n- 被调用者: [dev_dbg, dev_err, memmove, wake_up, clear_bit, set_bit, spin_lock, spin_unlock]\n\n2. 函数名: dev_dbg\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: wdm_in_callback\n- 被调用者: []\n\n3. 函数名: dev_err\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: wdm_in_callback\n- 被调用者: []\n\n4. 函数名: memmove\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: wdm_in_callback\n- 被调用者: []\n\n5. 函数名: wake_up\n- 参数: [wait_queue_head_t *q]\n- 调用者: wdm_in_callback\n- 被调用者: []\n\n6. 函数名: clear_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: wdm_in_callback\n- 被调用者: []\n\n7. 函数名: set_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: wdm_in_callback\n- 被调用者: []\n\n8. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: wdm_in_callback\n- 被调用者: []\n\n9. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: wdm_in_callback\n- 被调用者: []"
  },
  {
    "id": 205,
    "cwe": "CWE-119",
    "cve": "CVE-2013-1929",
    "purpose": "Code purpose:\"\"\"读取和处理PCI设备的VPD(Vital Product Data)信息，包括制造商ID、版本号和部件号等，并将其存储到驱动程序数据结构中。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理VPD数据时未充分验证输入长度，导致堆缓冲区溢出漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: tg3_read_vpd\n- 参数: [struct tg3 *tp]\n- 调用者: 未显示\n- 被调用者: [tg3_vpd_readblock, pci_vpd_find_tag, pci_vpd_lrdt_size, pci_vpd_find_info_keyword, pci_vpd_info_field_size, memcmp, memcpy, strncat, kfree, tg3_asic_rev, strcpy]\n\n2. 函数名: tg3_vpd_readblock\n- 参数: [struct tg3 *tp, u32 *vpdlen]\n- 调用者: tg3_read_vpd\n- 被调用者: 未显示\n\n3. 函数名: pci_vpd_find_tag\n- 参数: [u8 *vpd_data, int offset, int len, int tag]\n- 调用者: tg3_read_vpd\n- 被调用者: 未显示\n\n4. 函数名: pci_vpd_lrdt_size\n- 参数: [u8 *lrdt]\n- 调用者: tg3_read_vpd\n- 被调用者: 未显示\n\n5. 函数名: pci_vpd_find_info_keyword\n- 参数: [u8 *vpd_data, int offset, int len, int keyword]\n- 调用者: tg3_read_vpd\n- 被调用者: 未显示\n\n6. 函数名: pci_vpd_info_field_size\n- 参数: [u8 *info_field]\n- 调用者: tg3_read_vpd\n- 被调用者: 未显示\n\n7. 函数名: memcmp\n- 参数: [const void *s1, const void *s2, size_t n]\n- 调用者: tg3_read_vpd\n- 被调用者: 未显示\n\n8. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: tg3_read_vpd\n- 被调用者: 未显示\n\n9. 函数名: strncat\n- 参数: [char *dest, const char *src, size_t n]\n- 调用者: tg3_read_vpd\n- 被调用者: 未显示\n\n10. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: tg3_read_vpd\n- 被调用者: 未显示\n\n11. 函数名: tg3_asic_rev\n- 参数: [struct tg3 *tp]\n- 调用者: tg3_read_vpd\n- 被调用者: 未显示\n\n12. 函数名: strcpy\n- 参数: [char *dest, const char *src]\n- 调用者: tg3_read_vpd\n- 被调用者: 未显示"
  },
  {
    "id": 224,
    "cwe": "CWE-119",
    "cve": "CVE-2013-2234",
    "purpose": "Code purpose:\"\"\"该代码用于在IPSec密钥套接字中创建并广播一个SADB_FLUSH类型的消息，通知安全关联(SA)的刷新操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"未初始化结构体成员导致内核堆内存敏感信息泄露\"\"\"",
    "functions": "Functions:\n1. 函数名: key_notify_sa_flush\n- 参数: [const struct km_event *c]\n- 调用者: 未指定（由内核其他部分调用）\n- 被调用者: [alloc_skb, skb_put, pfkey_proto2satype, pfkey_broadcast]\n\n2. 函数名: alloc_skb\n- 参数: [sizeof(struct sadb_msg) + 16, GFP_ATOMIC]\n- 调用者: key_notify_sa_flush\n- 被调用者: []\n\n3. 函数名: skb_put\n- 参数: [skb, sizeof(struct sadb_msg)]\n- 调用者: key_notify_sa_flush\n- 被调用者: []\n\n4. 函数名: pfkey_proto2satype\n- 参数: [c->data.proto]\n- 调用者: key_notify_sa_flush\n- 被调用者: []\n\n5. 函数名: pfkey_broadcast\n- 参数: [skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net]\n- 调用者: key_notify_sa_flush\n- 被调用者: []"
  },
  {
    "id": 225,
    "cwe": "CWE-119",
    "cve": "CVE-2013-2234",
    "purpose": "Code purpose:\"\"\"该代码用于在IPSec密钥套接字中初始化并广播策略刷新通知消息\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"未初始化结构体成员导致内核堆内存敏感信息泄露\"\"\"",
    "functions": "Functions:\n1. 函数名: key_notify_policy_flush\n- 参数: [const struct km_event *c]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [alloc_skb, skb_put, pfkey_broadcast]\n\n2. 函数名: alloc_skb\n- 参数: [sizeof(struct sadb_msg) + 16, GFP_ATOMIC]\n- 调用者: key_notify_policy_flush\n- 被调用者: []\n\n3. 函数名: skb_put\n- 参数: [skb_out, sizeof(struct sadb_msg)]\n- 调用者: key_notify_policy_flush\n- 被调用者: []\n\n4. 函数名: pfkey_broadcast\n- 参数: [skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net]\n- 调用者: key_notify_policy_flush\n- 被调用者: []"
  },
  {
    "id": 238,
    "cwe": "CWE-119",
    "cve": "CVE-2013-2850",
    "purpose": "Code purpose:\"\"\"该代码用于解码iSCSI协议中的文本输入参数，处理安全阶段检查、参数验证及响应生成，并将结果存储在连接参数列表中\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理长密钥时未正确验证输入长度，导致堆缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: iscsi_decode_text_input\n- 参数: [u8 phase, u8 sender, char *textbuf, u32 length, struct iscsi_conn *conn]\n- 调用者: N/A\n- 被调用者: [kzalloc, memcpy, iscsi_extract_key_value, pr_debug, iscsi_check_for_auth_key, strlen, iscsi_check_key, iscsi_add_notunderstood_response, iscsi_check_value, iscsi_check_proposer_state, iscsi_check_acceptor_state, kfree]\n\n2. 函数名: iscsi_extract_key_value\n- 参数: [char *start, char **key, char **value]\n- 调用者: iscsi_decode_text_input\n- 被调用者: N/A\n\n3. 函数名: iscsi_check_for_auth_key\n- 参数: [char *key]\n- 调用者: iscsi_decode_text_input\n- 被调用者: N/A\n\n4. 函数名: iscsi_check_key\n- 参数: [char *key, u8 phase, u8 sender, struct iscsi_param_list *param_list]\n- 调用者: iscsi_decode_text_input\n- 被调用者: N/A\n\n5. 函数名: iscsi_add_notunderstood_response\n- 参数: [char *key, char *value, struct iscsi_param_list *param_list]\n- 调用者: iscsi_decode_text_input\n- 被调用者: N/A\n\n6. 函数名: iscsi_check_value\n- 参数: [struct iscsi_param *param, char *value]\n- 调用者: iscsi_decode_text_input\n- 被调用者: N/A\n\n7. 函数名: iscsi_check_proposer_state\n- 参数: [struct iscsi_param *param, char *value]\n- 调用者: iscsi_decode_text_input\n- 被调用者: N/A\n\n8. 函数名: iscsi_check_acceptor_state\n- 参数: [struct iscsi_param *param, char *value, struct iscsi_conn *conn]\n- 调用者: iscsi_decode_text_input\n- 被调用者: N/A"
  },
  {
    "id": 239,
    "cwe": "CWE-119",
    "cve": "CVE-2013-2850",
    "purpose": "Code purpose:\"\"\"该代码用于在iSCSI协议中为无法识别的键值对添加错误响应，包括内存分配和字符串复制操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理长键名时未正确检查键名长度，导致堆缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: iscsi_add_notunderstood_response\n- 参数: [key, value, param_list]\n- 调用者: 未指定（由外部调用）\n- 被调用者: [strlen, pr_err, kzalloc, INIT_LIST_HEAD, strncpy, list_add_tail]\n\n2. 函数名: strlen\n- 参数: [str]\n- 调用者: iscsi_add_notunderstood_response\n- 被调用者: []\n\n3. 函数名: pr_err\n- 参数: [format, ...]\n- 调用者: iscsi_add_notunderstood_response\n- 被调用者: []\n\n4. 函数名: kzalloc\n- 参数: [size, flags]\n- 调用者: iscsi_add_notunderstood_response\n- 被调用者: []\n\n5. 函数名: INIT_LIST_HEAD\n- 参数: [list]\n- 调用者: iscsi_add_notunderstood_response\n- 被调用者: []\n\n6. 函数名: strncpy\n- 参数: [dest, src, count]\n- 调用者: iscsi_add_notunderstood_response\n- 被调用者: []\n\n7. 函数名: list_add_tail\n- 参数: [new, head]\n- 调用者: iscsi_add_notunderstood_response\n- 被调用者: []"
  },
  {
    "id": 247,
    "cwe": "CWE-119",
    "cve": "CVE-2013-2890",
    "purpose": "Code purpose:\"\"\"该代码用于初始化Buzz控制器的LED设备，包括分配内存、设置LED属性并注册LED设备，同时处理可能的错误情况。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证设备名称长度，导致在分配和格式化LED名称时可能发生堆溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: buzz_init\n- 参数: [struct hid_device *hdev]\n- 调用者: 未显示（由HID子系统调用）\n- 被调用者: [hid_get_drvdata, kzalloc, hid_err, buzz_set_leds, strlen, dev_name, snprintf, led_classdev_register, led_classdev_unregister, kfree]\n\n2. 函数名: hid_get_drvdata\n- 参数: [struct hid_device *hdev]\n- 调用者: buzz_init\n- 被调用者: 未显示\n\n3. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: buzz_init\n- 被调用者: 未显示\n\n4. 函数名: hid_err\n- 参数: [const struct hid_device *hdev, const char *fmt, ...]\n- 调用者: buzz_init\n- 被调用者: 未显示\n\n5. 函数名: buzz_set_leds\n- 参数: [struct hid_device *hdev, int value]\n- 调用者: buzz_init\n- 被调用者: 未显示\n\n6. 函数名: strlen\n- 参数: [const char *s]\n- 调用者: buzz_init\n- 被调用者: 未显示\n\n7. 函数名: dev_name\n- 参数: [const struct device *dev]\n- 调用者: buzz_init\n- 被调用者: 未显示\n\n8. 函数名: snprintf\n- 参数: [char *str, size_t size, const char *format, ...]\n- 调用者: buzz_init\n- 被调用者: 未显示\n\n9. 函数名: led_classdev_register\n- 参数: [struct device *parent, struct led_classdev *led_cdev]\n- 调用者: buzz_init\n- 被调用者: 未显示\n\n10. 函数名: led_classdev_unregister\n- 参数: [struct led_classdev *led_cdev]\n- 调用者: buzz_init\n- 被调用者: 未显示\n\n11. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: buzz_init\n- 被调用者: 未显示\n\n12. 函数名: buzz_led_get_brightness\n- 参数: 未显示（函数指针赋值）\n- 调用者: 未显示（通过led->brightness_get调用）\n- 被调用者: 未显示\n\n13. 函数名: buzz_led_set_brightness\n- 参数: 未显示（函数指针赋值）\n- 调用者: 未显示（通过led->brightness_set调用）\n- 被调用者: 未显示"
  },
  {
    "id": 248,
    "cwe": "CWE-119",
    "cve": "CVE-2013-2891",
    "purpose": "Code purpose:\"\"\"该代码用于实现SteelSeries SRW-S1设备的HID驱动，包括初始化设备、分配内存、注册LED子系统以及处理LED控制功能。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证设备唯一标识符(hdev->uniq)的长度，导致在分配内存和格式化字符串时可能发生堆溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: steelseries_srws1_probe\n- 参数: [struct hid_device *hdev, const struct hid_device_id *id]\n- 调用者: 内核HID子系统（驱动探测时调用）\n- 被调用者: [kzalloc, hid_err, hid_set_drvdata, hid_parse, hid_hw_start, steelseries_srws1_set_leds, strlen, snprintf, led_classdev_register, led_classdev_unregister, kfree]\n\n2. 函数名: steelseries_srws1_set_leds\n- 参数: [struct hid_device *hdev, int value]\n- 调用者: steelseries_srws1_probe\n- 被调用者: []\n\n3. 函数名: steelseries_srws1_led_all_get_brightness\n- 参数: [未显示完整参数]\n- 调用者: LED子系统（回调）\n- 被调用者: []\n\n4. 函数名: steelseries_srws1_led_all_set_brightness\n- 参数: [未显示完整参数]\n- 调用者: LED子系统（回调）\n- 被调用者: []\n\n5. 函数名: steelseries_srws1_led_get_brightness\n- 参数: [未显示完整参数]\n- 调用者: LED子系统（回调）\n- 被调用者: []\n\n6. 函数名: steelseries_srws1_led_set_brightness\n- 参数: [未显示完整参数]\n- 调用者: LED子系统（回调）\n- 被调用者: []"
  },
  {
    "id": 249,
    "cwe": "CWE-119",
    "cve": "CVE-2013-2893",
    "purpose": "Code purpose:\"\"\"初始化Logitech力反馈设备，设置力反馈参数并通过HID子系统与设备通信。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证输入设备的报告字段数量和大小，导致攻击者可通过特制设备触发堆越界写入漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: lg2ff_init\n- 参数: [struct hid_device *hid]\n- 调用者: 未明确（由HID子系统调用）\n- 被调用者: [list_entry, hid_err, kmalloc, set_bit, input_ff_create_memless, kfree, hid_hw_request, hid_info]\n\n2. 函数名: list_entry\n- 参数: [未明确（宏定义参数）]\n- 调用者: lg2ff_init\n- 被调用者: []\n\n3. 函数名: hid_err\n- 参数: [struct hid_device *hid, const char *fmt, ...]\n- 调用者: lg2ff_init\n- 被调用者: []\n\n4. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: lg2ff_init\n- 被调用者: []\n\n5. 函数名: set_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: lg2ff_init\n- 被调用者: []\n\n6. 函数名: input_ff_create_memless\n- 参数: [struct input_dev *dev, void *data, int (*play_effect)(struct input_dev *, void *, struct ff_effect *)]\n- 调用者: lg2ff_init\n- 被调用者: []\n\n7. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: lg2ff_init\n- 被调用者: []\n\n8. 函数名: hid_hw_request\n- 参数: [struct hid_device *hid, struct hid_report *report, enum hid_class_request reqtype]\n- 调用者: lg2ff_init\n- 被调用者: []\n\n9. 函数名: hid_info\n- 参数: [struct hid_device *hid, const char *fmt, ...]\n- 调用者: lg2ff_init\n- 被调用者: []"
  },
  {
    "id": 250,
    "cwe": "CWE-119",
    "cve": "CVE-2013-2893",
    "purpose": "Code purpose:\"\"\"处理来自Logitech力反馈设备的输入，并将力反馈效果转换为设备特定的输出报告\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证report->field[0]->maxusage的值，导致memset操作可能超出分配的堆内存边界，造成堆溢出漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: hid_lg3ff_play\n- 参数: [struct input_dev *dev, void *data, struct ff_effect *effect]\n- 调用者: 未明确显示（通常由输入子系统调用）\n- 被调用者: [input_get_drvdata, memset, hid_hw_request]\n\n2. 函数名: input_get_drvdata\n- 参数: [struct input_dev *dev]\n- 调用者: hid_lg3ff_play\n- 被调用者: []\n\n3. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: hid_lg3ff_play\n- 被调用者: []\n\n4. 函数名: hid_hw_request\n- 参数: [struct hid_device *hid, struct hid_report *report, enum hid_class_request reqtype]\n- 调用者: hid_lg3ff_play\n- 被调用者: []\n\n5. 函数名: list_entry\n- 参数: [struct list_head *ptr, type, member]\n- 调用者: hid_lg3ff_play\n- 被调用者: []"
  },
  {
    "id": 251,
    "cwe": "CWE-119",
    "cve": "CVE-2013-2893",
    "purpose": "Code purpose:\"\"\"该代码用于初始化Logitech游戏方向盘设备，包括检测设备兼容性、设置力反馈功能、创建sysfs接口以及LED子系统支持，以实现对设备的控制和反馈功能。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证来自物理设备的输入数据，导致堆基缓冲区溢出漏洞，允许攻击者通过特制设备触发越界写入。\"\"\"",
    "functions": "Functions:\n1. 函数名: lg4ff_init\n- 参数: [struct hid_device *hid]\n- 调用者: 无（驱动初始化函数）\n- 被调用者: [list_entry, hid_err, dbg_hid, hid_lg4ff_switch_native, hid_info, set_bit, input_ff_create_memless, test_bit, hid_get_drvdata, kzalloc, device_create_file, snprintf, lg4ff_set_leds, led_classdev_register, led_classdev_unregister, kfree]\n\n2. 函数名: list_entry\n- 参数: [pointer, type, member]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n3. 函数名: hid_err\n- 参数: [struct hid_device *hid, const char *fmt, ...]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n4. 函数名: dbg_hid\n- 参数: [const char *fmt, ...]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n5. 函数名: hid_lg4ff_switch_native\n- 参数: [struct hid_device *hid, __u8 command]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n6. 函数名: hid_info\n- 参数: [struct hid_device *hid, const char *fmt, ...]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n7. 函数名: set_bit\n- 参数: [int nr, volatile void *addr]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n8. 函数名: input_ff_create_memless\n- 参数: [struct input_dev *dev, void *data, int (*play)(struct input_dev *dev, void *data, struct ff_effect *effect)]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n9. 函数名: test_bit\n- 参数: [int nr, const volatile void *addr]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n10. 函数名: hid_get_drvdata\n- 参数: [struct hid_device *hid]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n11. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n12. 函数名: device_create_file\n- 参数: [struct device *dev, const struct device_attribute *attr]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n13. 函数名: snprintf\n- 参数: [char *str, size_t size, const char *format, ...]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n14. 函数名: lg4ff_set_leds\n- 参数: [struct hid_device *hid, __u8 value]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n15. 函数名: led_classdev_register\n- 参数: [struct device *parent, struct led_classdev *led_cdev]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n16. 函数名: led_classdev_unregister\n- 参数: [struct led_classdev *led_cdev]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n17. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: [lg4ff_init]\n- 被调用者: 无"
  },
  {
    "id": 252,
    "cwe": "CWE-119",
    "cve": "CVE-2013-2894",
    "purpose": "Code purpose:\"\"\"该代码用于探测并初始化联想ThinkPad键盘设备，包括创建sysfs属性组、分配内存存储设备数据、设置LED控制参数等。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证设备名称长度，导致分配的内存不足，可能造成堆溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: tpkbd_probe_tp\n- 参数: [struct hid_device *hdev]\n- 调用者: 未显示（通常由HID子系统调用）\n- 被调用者: [dev_name, sysfs_create_group, kzalloc, hid_warn, hid_err, snprintf, hid_set_drvdata, led_classdev_register, tpkbd_features_set, kfree, tpkbd_led_brightness_get, tpkbd_led_brightness_set]\n\n2. 函数名: dev_name\n- 参数: [struct device *dev]\n- 调用者: [tpkbd_probe_tp]\n- 被调用者: []\n\n3. 函数名: sysfs_create_group\n- 参数: [struct kobject *kobj, const struct attribute_group *grp]\n- 调用者: [tpkbd_probe_tp]\n- 被调用者: []\n\n4. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: [tpkbd_probe_tp]\n- 被调用者: []\n\n5. 函数名: hid_warn\n- 参数: [struct hid_device *hdev, const char *fmt, ...]\n- 调用者: [tpkbd_probe_tp]\n- 被调用者: []\n\n6. 函数名: hid_err\n- 参数: [struct hid_device *hdev, const char *fmt, ...]\n- 调用者: [tpkbd_probe_tp]\n- 被调用者: []\n\n7. 函数名: snprintf\n- 参数: [char *str, size_t size, const char *format, ...]\n- 调用者: [tpkbd_probe_tp]\n- 被调用者: []\n\n8. 函数名: hid_set_drvdata\n- 参数: [struct hid_device *hdev, void *data]\n- 调用者: [tpkbd_probe_tp]\n- 被调用者: []\n\n9. 函数名: led_classdev_register\n- 参数: [struct device *parent, struct led_classdev *led_cdev]\n- 调用者: [tpkbd_probe_tp]\n- 被调用者: []\n\n10. 函数名: tpkbd_features_set\n- 参数: [struct hid_device *hdev]\n- 调用者: [tpkbd_probe_tp]\n- 被调用者: []\n\n11. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: [tpkbd_probe_tp]\n- 被调用者: []\n\n12. 函数名: tpkbd_led_brightness_get\n- 参数: [未显示]\n- 调用者: [tpkbd_probe_tp（通过函数指针）]\n- 被调用者: []\n\n13. 函数名: tpkbd_led_brightness_set\n- 参数: [未显示]\n- 调用者: [tpkbd_probe_tp（通过函数指针）]\n- 被调用者: []"
  },
  {
    "id": 253,
    "cwe": "CWE-119",
    "cve": "CVE-2013-2895",
    "purpose": "Code purpose:\"\"\"该代码用于处理Logitech无线接收器设备的探测和初始化，包括分配资源、解析HID描述符、启动硬件设备以及设置设备间的通信。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_HID_LOGITECH_DJ时，内核未正确处理来自恶意设备的异常输入，导致空指针解引用和内核内存信息泄露\"\"\"",
    "functions": "Functions:\n1. 函数名: logi_dj_probe\n- 参数: [struct hid_device *hdev, const struct hid_device_id *id]\n- 调用者: 内核HID子系统\n- 被调用者: [is_dj_device, kzalloc, INIT_WORK, spin_lock_init, kfifo_alloc, hid_set_drvdata, hid_parse, hid_hw_start, logi_dj_recv_switch_to_dj_mode, hid_hw_open, hid_device_io_start, logi_dj_recv_query_paired_devices, hid_hw_close, hid_hw_stop, kfifo_free, kfree]\n\n2. 函数名: is_dj_device\n- 参数: [struct dj_device *]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n3. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n4. 函数名: INIT_WORK\n- 参数: [struct work_struct *work, work_func_t func]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n5. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n6. 函数名: kfifo_alloc\n- 参数: [struct kfifo *fifo, unsigned int size, gfp_t gfp_mask]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n7. 函数名: hid_set_drvdata\n- 参数: [struct hid_device *hdev, void *data]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n8. 函数名: hid_parse\n- 参数: [struct hid_device *hdev]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n9. 函数名: hid_hw_start\n- 参数: [struct hid_device *hdev, unsigned int connect_mask]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n10. 函数名: logi_dj_recv_switch_to_dj_mode\n- 参数: [struct dj_receiver_dev *djrcv_dev, unsigned int timeout]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n11. 函数名: hid_hw_open\n- 参数: [struct hid_device *hdev]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n12. 函数名: hid_device_io_start\n- 参数: [struct hid_device *hdev]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n13. 函数名: logi_dj_recv_query_paired_devices\n- 参数: [struct dj_receiver_dev *djrcv_dev]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n14. 函数名: hid_hw_close\n- 参数: [struct hid_device *hdev]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n15. 函数名: hid_hw_stop\n- 参数: [struct hid_device *hdev]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n16. 函数名: kfifo_free\n- 参数: [struct kfifo *fifo]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n17. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: logi_dj_probe\n- 被调用者: []"
  },
  {
    "id": 254,
    "cwe": "CWE-119",
    "cve": "CVE-2013-2895",
    "purpose": "Code purpose:\"\"\"该代码用于处理Logitech无线设备的HID报告，将接收到的数据填充到输出报告中并发送给硬件设备。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对report->field[0]进行空指针检查，导致当其为NULL时可能引发空指针解引用，造成拒绝服务或内核信息泄露\"\"\"",
    "functions": "Functions:\n1. 函数名: logi_dj_recv_send_report\n- 参数: [djrcv_dev, dj_report]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [dev_err, hid_hw_request]\n\n2. 函数名: dev_err\n- 参数: [&hdev->dev, \"%s: unable to find dj report\\n\", __func__]\n- 调用者: logi_dj_recv_send_report\n- 被调用者: 未明确（内核函数）\n\n3. 函数名: hid_hw_request\n- 参数: [hdev, report, HID_REQ_SET_REPORT]\n- 调用者: logi_dj_recv_send_report\n- 被调用者: 未明确（内核函数）"
  },
  {
    "id": 259,
    "cwe": "CWE-119",
    "cve": "CVE-2013-2899",
    "purpose": "Code purpose:\"\"\"该代码用于处理PicoLCD设备操作模式的存储请求，根据输入内容切换设备模式并设置相关报告参数。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当输入既不匹配'lcd'也不匹配'bootloader'时，report指针保持NULL，后续未检查就直接使用导致空指针解引用\"\"\"",
    "functions": "Functions:\n1. 函数名: picolcd_operation_mode_store\n- 参数: [struct device *dev, struct device_attribute *attr, const char *buf, size_t count]\n- 调用者: 未显示（由设备属性系统调用）\n- 被调用者: [dev_get_drvdata, strncmp, picolcd_out_report, hid_set_field, hid_hw_request, spin_lock_irqsave, spin_unlock_irqrestore]\n\n2. 函数名: dev_get_drvdata\n- 参数: [struct device *dev]\n- 调用者: picolcd_operation_mode_store\n- 被调用者: 未显示\n\n3. 函数名: strncmp\n- 参数: [const char *s1, const char *s2, size_t n]\n- 调用者: picolcd_operation_mode_store\n- 被调用者: 未显示\n\n4. 函数名: picolcd_out_report\n- 参数: [int report_type, struct hid_device *hdev]\n- 调用者: picolcd_operation_mode_store\n- 被调用者: 未显示\n\n5. 函数名: hid_set_field\n- 参数: [struct hid_field *field, unsigned offset, __s32 value]\n- 调用者: picolcd_operation_mode_store\n- 被调用者: 未显示\n\n6. 函数名: hid_hw_request\n- 参数: [struct hid_device *hdev, struct hid_report *report, enum hid_class_request reqtype]\n- 调用者: picolcd_operation_mode_store\n- 被调用者: 未显示\n\n7. 函数名: spin_lock_irqsave\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: picolcd_operation_mode_store\n- 被调用者: 未显示\n\n8. 函数名: spin_unlock_irqrestore\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: picolcd_operation_mode_store\n- 被调用者: 未显示"
  },
  {
    "id": 295,
    "cwe": "CWE-119",
    "cve": "CVE-2013-4312",
    "purpose": "Code purpose:\"\"\"该代码用于管理UNIX域套接字的引用计数并在引用计数为零时从垃圾回收链表中移除对应的套接字\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确维护UNIX套接字垃圾回收机制中的引用计数，导致本地用户可通过重复发送文件描述符绕过文件描述符限制，造成内存耗尽拒绝服务\"\"\"",
    "functions": "Functions:\n1. 函数名: unix_notinflight\n- 参数: [struct file *fp]\n- 调用者: 未指定（由外部调用）\n- 被调用者: [unix_get_socket, unix_sk, spin_lock, atomic_long_dec_and_test, list_del_init, spin_unlock]\n\n2. 函数名: unix_get_socket\n- 参数: [struct file *fp]\n- 调用者: unix_notinflight\n- 被调用者: 未指定\n\n3. 函数名: unix_sk\n- 参数: [struct sock *s]\n- 调用者: unix_notinflight\n- 被调用者: 未指定\n\n4. 函数名: spin_lock\n- 参数: [&unix_gc_lock]\n- 调用者: unix_notinflight\n- 被调用者: 未指定\n\n5. 函数名: atomic_long_dec_and_test\n- 参数: [&u->inflight]\n- 调用者: unix_notinflight\n- 被调用者: 未指定\n\n6. 函数名: list_del_init\n- 参数: [&u->link]\n- 调用者: unix_notinflight\n- 被调用者: 未指定\n\n7. 函数名: spin_unlock\n- 参数: [&unix_gc_lock]\n- 调用者: unix_notinflight\n- 被调用者: 未指定"
  },
  {
    "id": 296,
    "cwe": "CWE-119",
    "cve": "CVE-2013-4312",
    "purpose": "Code purpose:\"\"\"管理UNIX域套接字的引用计数，防止垃圾回收过早释放正在使用的套接字\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确限制UNIX套接字文件描述符的引用计数，导致本地用户可通过反复发送和关闭描述符绕过文件描述符限制，造成内存耗尽的服务拒绝\"\"\"",
    "functions": "Functions:\n1. 函数名: unix_inflight\n- 参数: [struct file *fp]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [unix_get_socket, unix_sk, atomic_long_inc_return, spin_lock, spin_unlock]\n\n2. 函数名: unix_get_socket\n- 参数: [struct file *fp]\n- 调用者: unix_inflight\n- 被调用者: []\n\n3. 函数名: unix_sk\n- 参数: [struct sock *s]\n- 调用者: unix_inflight\n- 被调用者: []\n\n4. 函数名: atomic_long_inc_return\n- 参数: [atomic_long_t *v]\n- 调用者: unix_inflight\n- 被调用者: []\n\n5. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: unix_inflight\n- 被调用者: []\n\n6. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: unix_inflight\n- 被调用者: []"
  },
  {
    "id": 302,
    "cwe": "CWE-119",
    "cve": "CVE-2013-4387",
    "purpose": "Code purpose:\"\"\"处理IPv6数据包的组装和分片，包括UDP分片卸载(UFO)功能，以支持大包传输\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理UDP Fragmentation Offload(UFO)时，未能正确处理大包之后小包的分片需求，导致内存损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: ip6_append_data\n- 参数: [struct sock *sk, int getfrag(void *from, char *to, int offset, int len, int odd, struct sk_buff *skb), void *from, int length, int transhdrlen, int hlimit, int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6, struct rt6_info *rt, unsigned int flags, int dontfrag]\n- 调用者: 未显示\n- 被调用者: [ip6_opt_dup, ip6_rthdr_dup, dst_hold, ipv6_local_error, sock_tx_timestamp, ipv6_local_rxpmtu, ip6_ufo_append_data, skb_peek_tail, ip6_append_data_mtu, sock_alloc_send_skb, sock_wmalloc, skb_put, skb_copy_and_csum_bits, csum_sub, pskb_trim_unique, __skb_queue_tail, sk_page_frag_refill, skb_can_coalesce, __skb_fill_page_desc, page_address]\n\n2. 函数名: getfrag\n- 参数: [void *from, char *to, int offset, int len, int odd, struct sk_buff *skb]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n3. 函数名: ip6_opt_dup\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n4. 函数名: ip6_rthdr_dup\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n5. 函数名: dst_hold\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n6. 函数名: ipv6_local_error\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n7. 函数名: sock_tx_timestamp\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n8. 函数名: ipv6_local_rxpmtu\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n9. 函数名: ip6_ufo_append_data\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n10. 函数名: skb_peek_tail\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n11. 函数名: ip6_append_data_mtu\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n12. 函数名: sock_alloc_send_skb\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n13. 函数名: sock_wmalloc\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n14. 函数名: skb_put\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n15. 函数名: skb_copy_and_csum_bits\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n16. 函数名: csum_sub\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n17. 函数名: pskb_trim_unique\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n18. 函数名: __skb_queue_tail\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n19. 函数名: sk_page_frag_refill\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n20. 函数名: skb_can_coalesce\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n21. 函数名: __skb_fill_page_desc\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n22. 函数名: page_address\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示"
  },
  {
    "id": 322,
    "cwe": "CWE-119",
    "cve": "CVE-2013-4512",
    "purpose": "Code purpose:\"\"\"该代码用于处理用户空间传递的退出码，并将其转换为整型值存储在内核变量中\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对用户输入的count参数进行边界检查，导致copy_from_user操作可能超出buf数组的固定大小，造成缓冲区溢出漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: exitcode_proc_write\n- 参数: [struct file *file, const char __user *buffer, size_t count, loff_t *pos]\n- 调用者: 未明确（由内核proc文件系统调用）\n- 被调用者: [copy_from_user, simple_strtol, isspace]\n\n2. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: exitcode_proc_write\n- 被调用者: []\n\n3. 函数名: simple_strtol\n- 参数: [const char *cp, char **endp, unsigned int base]\n- 调用者: exitcode_proc_write\n- 被调用者: []\n\n4. 函数名: isspace\n- 参数: [int c]\n- 调用者: exitcode_proc_write\n- 被调用者: []"
  },
  {
    "id": 323,
    "cwe": "CWE-119",
    "cve": "CVE-2013-4513",
    "purpose": "Code purpose:\"\"\"该代码实现了通过字符设备写入数据到OZWPAN协议栈的功能，处理来自用户空间的数据并将其封装为协议元素进行传输。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"oz_cdev_write函数在处理用户空间数据时未正确验证count参数的大小，导致缓冲区溢出漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: oz_cdev_write\n- 参数: [struct file *filp, const char __user *buf, size_t count, loff_t *fpos]\n- 调用者: 外部调用\n- 被调用者: [spin_lock_bh, oz_pd_get, spin_unlock_bh, oz_elt_info_alloc, copy_from_user, oz_queue_elt_info, oz_elt_info_free, oz_pd_put]\n\n2. 函数名: spin_lock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: oz_cdev_write\n- 被调用者: []\n\n3. 函数名: oz_pd_get\n- 参数: [struct oz_pd *pd]\n- 调用者: oz_cdev_write\n- 被调用者: []\n\n4. 函数名: spin_unlock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: oz_cdev_write\n- 被调用者: []\n\n5. 函数名: oz_elt_info_alloc\n- 参数: [struct oz_elt_buf *eb]\n- 调用者: oz_cdev_write\n- 被调用者: []\n\n6. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: oz_cdev_write\n- 被调用者: []\n\n7. 函数名: oz_queue_elt_info\n- 参数: [struct oz_elt_buf *eb, u8 isoc, u8 id, struct oz_elt_info *ei]\n- 调用者: oz_cdev_write\n- 被调用者: []\n\n8. 函数名: oz_elt_info_free\n- 参数: [struct oz_elt_buf *eb, struct oz_elt_info *ei]\n- 调用者: oz_cdev_write\n- 被调用者: []\n\n9. 函数名: oz_pd_put\n- 参数: [struct oz_pd *pd]\n- 调用者: oz_cdev_write\n- 被调用者: []\n\n10. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: oz_cdev_write\n- 被调用者: []\n\n11. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: oz_cdev_write\n- 被调用者: []"
  },
  {
    "id": 324,
    "cwe": "CWE-119",
    "cve": "CVE-2013-4514",
    "purpose": "Code purpose:\"\"\"处理无线网络配置请求，包括验证用户权限、复制用户数据到内核空间、处理不同类型的网络配置命令，并更新相应的网络参数\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理用户提供的长字符串时，未正确验证输入长度，导致缓冲区溢出漏洞，攻击者可利用CAP_NET_ADMIN权限造成拒绝服务或其他影响。\"\"\"",
    "functions": "Functions:\n1. 函数名: wvlan_uil_put_info\n- 参数: [struct uilreq *urq, struct wl_private *lp]\n- 调用者: 未显示（外部调用）\n- 被调用者: [capable, verify_area, copy_from_user, kmalloc, kfree, CNV_INT_TO_LITTLE, memset, memcpy, strlen, strcmp, wl_wep_decode, hcf_cntl, wl_act_int_off, hcf_put_info, wl_act_int_on]\n\n2. 函数名: wl_wep_decode\n- 参数: 未显示完整（代码中调用时参数为CRYPT_CODE, &sEncryption, lp->szEncryption）\n- 调用者: wvlan_uil_put_info\n- 被调用者: 未显示\n\n3. 函数名: hcf_cntl\n- 参数: 未显示完整（代码中调用时参数为&(lp->hcfCtx), HCF_CNTL_ENABLE | HCF_PORT_0等）\n- 调用者: wvlan_uil_put_info\n- 被调用者: 未显示\n\n4. 函数名: wl_act_int_off\n- 参数: [struct wl_private *lp]\n- 调用者: wvlan_uil_put_info\n- 被调用者: 未显示\n\n5. 函数名: hcf_put_info\n- 参数: 未显示完整（代码中调用时参数为&(lp->hcfCtx), (LTVP) pLtv）\n- 调用者: wvlan_uil_put_info\n- 被调用者: 未显示\n\n6. 函数名: wl_act_int_on\n- 参数: [struct wl_private *lp]\n- 调用者: wvlan_uil_put_info\n- 被调用者: 未显示"
  },
  {
    "id": 325,
    "cwe": "CWE-119",
    "cve": "CVE-2013-4514",
    "purpose": "Code purpose:\"\"\"该代码用于设置无线网络设备的站点昵称，将用户提供的昵称字符串复制到设备驱动程序的缓冲区中。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对用户输入的'wrqu->data.length'进行有效验证，导致memcpy操作可能超出目标缓冲区'lp->StationName'的大小限制，造成缓冲区溢出漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: wvlan_set_station_nickname\n- 参数: [struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra]\n- 调用者: 未明确（由内核网络子系统调用）\n- 被调用者: [wl_priv, DBG_FUNC, DBG_ENTER, wl_lock, memset, memcpy, wl_apply, wl_unlock, DBG_LEAVE]\n\n2. 函数名: wl_priv\n- 参数: [struct net_device *dev]\n- 调用者: wvlan_set_station_nickname\n- 被调用者: []\n\n3. 函数名: DBG_FUNC\n- 参数: [const char *]\n- 调用者: wvlan_set_station_nickname\n- 被调用者: []\n\n4. 函数名: DBG_ENTER\n- 参数: [DbgInfo]\n- 调用者: wvlan_set_station_nickname\n- 被调用者: []\n\n5. 函数名: wl_lock\n- 参数: [struct wl_private *lp, unsigned long *flags]\n- 调用者: wvlan_set_station_nickname\n- 被调用者: []\n\n6. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: wvlan_set_station_nickname\n- 被调用者: []\n\n7. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: wvlan_set_station_nickname\n- 被调用者: []\n\n8. 函数名: wl_apply\n- 参数: [struct wl_private *lp]\n- 调用者: wvlan_set_station_nickname\n- 被调用者: []\n\n9. 函数名: wl_unlock\n- 参数: [struct wl_private *lp, unsigned long *flags]\n- 调用者: wvlan_set_station_nickname\n- 被调用者: []\n\n10. 函数名: DBG_LEAVE\n- 参数: [DbgInfo]\n- 调用者: wvlan_set_station_nickname\n- 被调用者: []"
  },
  {
    "id": 333,
    "cwe": "CWE-119",
    "cve": "CVE-2013-4588",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中IP虚拟服务(IPVS)的控制功能，包括服务管理、超时设置、同步守护进程操作等，供具有CAP_NET_ADMIN权限的用户通过系统调用进行配置。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对用户输入的参数长度进行充分验证，导致在copy_from_user操作时可能发生栈缓冲区溢出，本地用户可利用CAP_NET_ADMIN权限提升特权。\"\"\"",
    "functions": "Functions:\n1. 函数名: do_ip_vs_set_ctl\n- 参数: [struct sock *sk, int cmd, void __user *user, unsigned int len]\n- 调用者: 未显示（应为系统调用处理函数）\n- 被调用者: [capable, copy_from_user, ip_vs_use_count_inc, mutex_lock_interruptible, ip_vs_flush, ip_vs_set_timeout, start_sync_thread, stop_sync_thread, ip_vs_copy_usvc_compat, ip_vs_copy_udest_compat, ip_vs_zero_all, __ip_vs_service_get, __ip_vs_svc_fwm_get, ip_vs_add_service, ip_vs_edit_service, ip_vs_del_service, ip_vs_zero_service, ip_vs_add_dest, ip_vs_edit_dest, ip_vs_del_dest, ip_vs_service_put, mutex_unlock, ip_vs_use_count_dec]\n\n2. 函数名: capable\n- 参数: [CAP_NET_ADMIN]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n3. 函数名: copy_from_user\n- 参数: [arg, user, len]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n4. 函数名: ip_vs_use_count_inc\n- 参数: []\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n5. 函数名: mutex_lock_interruptible\n- 参数: [&__ip_vs_mutex]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n6. 函数名: ip_vs_flush\n- 参数: []\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n7. 函数名: ip_vs_set_timeout\n- 参数: [(struct ip_vs_timeout_user *)arg]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n8. 函数名: start_sync_thread\n- 参数: [dm->state, dm->mcast_ifn, dm->syncid]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n9. 函数名: stop_sync_thread\n- 参数: [dm->state]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n10. 函数名: ip_vs_copy_usvc_compat\n- 参数: [&usvc, usvc_compat]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n11. 函数名: ip_vs_copy_udest_compat\n- 参数: [&udest, udest_compat]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n12. 函数名: ip_vs_zero_all\n- 参数: []\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n13. 函数名: __ip_vs_service_get\n- 参数: [usvc.af, usvc.protocol, &usvc.addr, usvc.port]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n14. 函数名: __ip_vs_svc_fwm_get\n- 参数: [usvc.af, usvc.fwmark]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n15. 函数名: ip_vs_add_service\n- 参数: [&usvc, &svc]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n16. 函数名: ip_vs_edit_service\n- 参数: [svc, &usvc]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n17. 函数名: ip_vs_del_service\n- 参数: [svc]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n18. 函数名: ip_vs_zero_service\n- 参数: [svc]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n19. 函数名: ip_vs_add_dest\n- 参数: [svc, &udest]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n20. 函数名: ip_vs_edit_dest\n- 参数: [svc, &udest]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n21. 函数名: ip_vs_del_dest\n- 参数: [svc, &udest]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n22. 函数名: ip_vs_service_put\n- 参数: [svc]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n23. 函数名: mutex_unlock\n- 参数: [&__ip_vs_mutex]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n24. 函数名: ip_vs_use_count_dec\n- 参数: []\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []"
  },
  {
    "id": 334,
    "cwe": "CWE-119",
    "cve": "CVE-2013-4588",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中IP虚拟服务器(IPVS)的控制接口功能，允许具有CAP_NET_ADMIN权限的用户通过getsockopt系统调用获取IPVS相关配置信息。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对用户提供的参数进行充分验证，导致在do_ip_vs_get_ctl函数中存在栈缓冲区溢出漏洞，本地用户可利用CAP_NET_ADMIN权限提升特权\"\"\"",
    "functions": "Functions:\n1. 函数名: do_ip_vs_get_ctl\n- 参数: [struct sock *sk, int cmd, void __user *user, int *len]\n- 调用者: 未显示（应为系统调用处理函数）\n- 被调用者: [capable, copy_from_user, mutex_lock_interruptible, sprintf, copy_to_user, strlen, __ip_vs_get_service_entries, __ip_vs_svc_fwm_get, __ip_vs_service_get, ip_vs_copy_service, ip_vs_service_put, __ip_vs_get_dest_entries, __ip_vs_get_timeouts, memset, strlcpy, mutex_unlock]\n\n2. 函数名: capable\n- 参数: [CAP_NET_ADMIN]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n3. 函数名: copy_from_user\n- 参数: [arg, user, get_arglen[GET_CMDID(cmd)]]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n4. 函数名: mutex_lock_interruptible\n- 参数: [&__ip_vs_mutex]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n5. 函数名: sprintf\n- 参数: [buf, \"IP Virtual Server version %d.%d.%d (size=%d)\", NVERSION(IP_VS_VERSION_CODE), IP_VS_CONN_TAB_SIZE]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n6. 函数名: copy_to_user\n- 参数: [user, buf, strlen(buf)+1] 或 [user, &info, sizeof(info)] 或 [user, entry, sizeof(*entry)] 或 [user, &t, sizeof(t)] 或 [user, &d, sizeof(d)]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n7. 函数名: strlen\n- 参数: [buf]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n8. 函数名: __ip_vs_get_service_entries\n- 参数: [get, user]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n9. 函数名: __ip_vs_svc_fwm_get\n- 参数: [AF_INET, entry->fwmark]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n10. 函数名: __ip_vs_service_get\n- 参数: [AF_INET, entry->protocol, &addr, entry->port]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n11. 函数名: ip_vs_copy_service\n- 参数: [entry, svc]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n12. 函数名: ip_vs_service_put\n- 参数: [svc]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n13. 函数名: __ip_vs_get_dest_entries\n- 参数: [get, user]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n14. 函数名: __ip_vs_get_timeouts\n- 参数: [&t]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n15. 函数名: memset\n- 参数: [&d, 0, sizeof(d)]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n16. 函数名: strlcpy\n- 参数: [d[0].mcast_ifn, ip_vs_master_mcast_ifn, sizeof(d[0].mcast_ifn)] 或 [d[1].mcast_ifn, ip_vs_backup_mcast_ifn, sizeof(d[1].mcast_ifn)]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n17. 函数名: mutex_unlock\n- 参数: [&__ip_vs_mutex]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []"
  },
  {
    "id": 335,
    "cwe": "CWE-119",
    "cve": "CVE-2013-4591",
    "purpose": "Code purpose:\"\"\"该代码用于从NFSv4文件系统获取未缓存的ACL(访问控制列表)数据，并将其写入指定缓冲区或返回ACL长度。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证用户提供的buflen参数，导致在分配内存页面时可能超出预设的NFS4ACL_MAXPAGES数组边界，造成缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: __nfs4_get_acl_uncached\n- 参数: [struct inode *inode, void *buf, size_t buflen]\n- 调用者: 未显示（应为外部调用）\n- 被调用者: [alloc_page, nfs4_call_sync, nfs4_write_cached_acl, _copy_from_pages, __free_page]\n\n2. 函数名: alloc_page\n- 参数: [GFP_KERNEL]\n- 调用者: __nfs4_get_acl_uncached\n- 被调用者: []\n\n3. 函数名: nfs4_call_sync\n- 参数: [NFS_SERVER(inode)->client, NFS_SERVER(inode), &msg, &args.seq_args, &res.seq_res, 0]\n- 调用者: __nfs4_get_acl_uncached\n- 被调用者: []\n\n4. 函数名: nfs4_write_cached_acl\n- 参数: [struct inode *inode, struct page **pages, res.acl_data_offset, res.acl_len]\n- 调用者: __nfs4_get_acl_uncached\n- 被调用者: []\n\n5. 函数名: _copy_from_pages\n- 参数: [buf, pages, res.acl_data_offset, res.acl_len]\n- 调用者: __nfs4_get_acl_uncached\n- 被调用者: []\n\n6. 函数名: __free_page\n- 参数: [pages[i]] 或 [res.acl_scratch]\n- 调用者: __nfs4_get_acl_uncached\n- 被调用者: []"
  },
  {
    "id": 348,
    "cwe": "CWE-119",
    "cve": "CVE-2013-6381",
    "purpose": "Code purpose:\"\"\"处理SNMP命令请求，包括从用户空间复制数据、分配内存、执行命令并将结果返回给用户空间\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证用户提供的req_len长度，导致在memcpy操作时可能发生缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: qeth_snmp_command\n- 参数: [struct qeth_card *card, char __user *udata]\n- 调用者: 未显示（应为外部调用）\n- 被调用者: [copy_from_user, memdup_user, kzalloc, kfree, qeth_get_adapter_cmd, memcpy, qeth_send_ipa_snmp_cmd, QETH_CARD_TEXT, QETH_DBF_MESSAGE, copy_to_user]\n\n2. 函数名: copy_from_user\n- 参数: [&req_len, udata + sizeof(int), sizeof(int)]\n- 调用者: qeth_snmp_command\n- 被调用者: 无（内核函数）\n\n3. 函数名: memdup_user\n- 参数: [udata, req_len + sizeof(struct qeth_snmp_ureq_hdr)]\n- 调用者: qeth_snmp_command\n- 被调用者: 无（内核函数）\n\n4. 函数名: kzalloc\n- 参数: [qinfo.udata_len, GFP_KERNEL]\n- 调用者: qeth_snmp_command\n- 被调用者: 无（内核函数）\n\n5. 函数名: kfree\n- 参数: [ureq], [qinfo.udata]\n- 调用者: qeth_snmp_command\n- 被调用者: 无（内核函数）\n\n6. 函数名: qeth_get_adapter_cmd\n- 参数: [card, IPA_SETADP_SET_SNMP_CONTROL, QETH_SNMP_SETADP_CMDLENGTH + req_len]\n- 调用者: qeth_snmp_command\n- 被调用者: 无（外部函数）\n\n7. 函数名: memcpy\n- 参数: [&cmd->data.setadapterparms.data.snmp, &ureq->cmd, req_len]\n- 调用者: qeth_snmp_command\n- 被调用者: 无（内核函数）\n\n8. 函数名: qeth_send_ipa_snmp_cmd\n- 参数: [card, iob, QETH_SETADP_BASE_LEN + req_len, qeth_snmp_command_cb, (void *)&qinfo]\n- 调用者: qeth_snmp_command\n- 被调用者: 无（外部函数）\n\n9. 函数名: QETH_CARD_TEXT\n- 参数: [card, 3, \"snmpcmd\"], [card, 2, \"snmpnome\"]\n- 调用者: qeth_snmp_command\n- 被调用者: 无（宏/外部函数）\n\n10. 函数名: QETH_DBF_MESSAGE\n- 参数: [2, \"SNMP command failed on %s: (0x%x)\\n\", QETH_CARD_IFNAME(card), rc]\n- 调用者: qeth_snmp_command\n- 被调用者: 无（宏/外部函数）\n\n11. 函数名: copy_to_user\n- 参数: [udata, qinfo.udata, qinfo.udata_len]\n- 调用者: qeth_snmp_command\n- 被调用者: 无（内核函数）"
  },
  {
    "id": 349,
    "cwe": "CWE-119",
    "cve": "CVE-2013-6382",
    "purpose": "Code purpose:\"\"\"该代码实现了XFS文件系统中通过句柄获取属性列表的功能，包括权限检查、参数验证、内存分配和属性列表拷贝等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证用户提供的buflen参数，导致在处理XFS_IOC_ATTRLIST_BY_HANDLE或XFS_IOC_ATTRLIST_BY_HANDLE_32 ioctl调用时可能发生缓冲区下溢，造成内存损坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: xfs_attrlist_by_handle\n- 参数: [struct file *parfilp, void __user *arg]\n- 调用者: 未显示（由ioctl调用）\n- 被调用者: [capable, copy_from_user, xfs_handlereq_to_dentry, kmem_zalloc_large, xfs_attr_list, copy_to_user, kmem_free, dput]\n\n2. 函数名: capable\n- 参数: [CAP_SYS_ADMIN]\n- 调用者: xfs_attrlist_by_handle\n- 被调用者: []\n\n3. 函数名: copy_from_user\n- 参数: [&al_hreq, arg, sizeof(xfs_fsop_attrlist_handlereq_t)]\n- 调用者: xfs_attrlist_by_handle\n- 被调用者: []\n\n4. 函数名: xfs_handlereq_to_dentry\n- 参数: [parfilp, &al_hreq.hreq]\n- 调用者: xfs_attrlist_by_handle\n- 被调用者: []\n\n5. 函数名: kmem_zalloc_large\n- 参数: [al_hreq.buflen, KM_SLEEP]\n- 调用者: xfs_attrlist_by_handle\n- 被调用者: []\n\n6. 函数名: xfs_attr_list\n- 参数: [XFS_I(dentry->d_inode), kbuf, al_hreq.buflen, al_hreq.flags, cursor]\n- 调用者: xfs_attrlist_by_handle\n- 被调用者: []\n\n7. 函数名: copy_to_user\n- 参数: [al_hreq.buffer, kbuf, al_hreq.buflen]\n- 调用者: xfs_attrlist_by_handle\n- 被调用者: []\n\n8. 函数名: kmem_free\n- 参数: [kbuf]\n- 调用者: xfs_attrlist_by_handle\n- 被调用者: []\n\n9. 函数名: dput\n- 参数: [dentry]\n- 调用者: xfs_attrlist_by_handle\n- 被调用者: []"
  },
  {
    "id": 350,
    "cwe": "CWE-119",
    "cve": "CVE-2013-6382",
    "purpose": "Code purpose:\"\"\"该代码用于处理XFS文件系统中兼容模式下通过句柄获取属性列表的请求，涉及权限检查、内存分配和数据拷贝等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证用户提供的buflen参数，导致在处理XFS_IOC_ATTRLIST_BY_HANDLE或XFS_IOC_ATTRLIST_BY_HANDLE_32 ioctl调用时可能发生缓冲区下溢，造成内存损坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: xfs_compat_attrlist_by_handle\n- 参数: [struct file *parfilp, void __user *arg]\n- 调用者: 未显示（应为ioctl调用者）\n- 被调用者: [capable, copy_from_user, xfs_compat_handlereq_to_dentry, IS_ERR, PTR_ERR, kmem_zalloc_large, xfs_attr_list, copy_to_user, kmem_free, dput]\n\n2. 函数名: capable\n- 参数: [CAP_SYS_ADMIN]\n- 调用者: xfs_compat_attrlist_by_handle\n- 被调用者: []\n\n3. 函数名: copy_from_user\n- 参数: [&al_hreq, arg, sizeof(compat_xfs_fsop_attrlist_handlereq_t)]\n- 调用者: xfs_compat_attrlist_by_handle\n- 被调用者: []\n\n4. 函数名: xfs_compat_handlereq_to_dentry\n- 参数: [parfilp, &al_hreq.hreq]\n- 调用者: xfs_compat_attrlist_by_handle\n- 被调用者: []\n\n5. 函数名: IS_ERR\n- 参数: [dentry]\n- 调用者: xfs_compat_attrlist_by_handle\n- 被调用者: []\n\n6. 函数名: PTR_ERR\n- 参数: [dentry]\n- 调用者: xfs_compat_attrlist_by_handle\n- 被调用者: []\n\n7. 函数名: kmem_zalloc_large\n- 参数: [al_hreq.buflen, KM_SLEEP]\n- 调用者: xfs_compat_attrlist_by_handle\n- 被调用者: []\n\n8. 函数名: xfs_attr_list\n- 参数: [XFS_I(dentry->d_inode), kbuf, al_hreq.buflen, al_hreq.flags, cursor]\n- 调用者: xfs_compat_attrlist_by_handle\n- 被调用者: []\n\n9. 函数名: copy_to_user\n- 参数: [compat_ptr(al_hreq.buffer), kbuf, al_hreq.buflen]\n- 调用者: xfs_compat_attrlist_by_handle\n- 被调用者: []\n\n10. 函数名: kmem_free\n- 参数: [kbuf]\n- 调用者: xfs_compat_attrlist_by_handle\n- 被调用者: []\n\n11. 函数名: dput\n- 参数: [dentry]\n- 调用者: xfs_compat_attrlist_by_handle\n- 被调用者: []"
  },
  {
    "id": 358,
    "cwe": "CWE-119",
    "cve": "CVE-2013-7027",
    "purpose": "Code purpose:\"\"\"初始化radiotap迭代器，用于解析无线网络数据包的radiotap头部信息，但不充分验证数据包是否包含超出头部的数据\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"代码未验证帧数据是否超出头部范围，导致可能读取到非法内存区域\"\"\"",
    "functions": "Functions:\n1. 函数名: ieee80211_radiotap_iterator_init\n- 参数: [iterator, radiotap_header, max_length, vns]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [get_unaligned_le16, get_unaligned_le32]\n\n2. 函数名: get_unaligned_le16\n- 参数: [&radiotap_header->it_len]\n- 调用者: ieee80211_radiotap_iterator_init\n- 被调用者: []\n\n3. 函数名: get_unaligned_le32\n- 参数: [&radiotap_header->it_present, iterator->_arg]\n- 调用者: ieee80211_radiotap_iterator_init\n- 被调用者: []"
  },
  {
    "id": 426,
    "cwe": "CWE-119",
    "cve": "CVE-2014-0069",
    "purpose": "Code purpose:\"\"\"处理CIFS文件系统的非缓存写入操作，将用户空间的数据通过writev系统调用写入远程文件\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"内核未正确处理未缓存写入操作中拷贝字节数少于请求数的情况，导致内存泄露或破坏\"\"\"",
    "functions": "Functions:\n1. 函数名: cifs_iovec_write\n- 参数: [struct file *file, const struct iovec *iov, unsigned long nr_segs, loff_t *poffset]\n- 调用者: 未显示（系统调用层）\n- 被调用者: [iov_length, generic_write_checks, INIT_LIST_HEAD, tlink_tcon, iov_iter_init, get_numpages, cifs_writedata_alloc, cifs_write_allocate_pages, min_t, iov_iter_copy_from_user, iov_iter_advance, cifsFileInfo_get, cifs_uncached_retry_writev, kref_put, list_add_tail, wait_for_completion_killable, list_del_init, cifs_stats_bytes_written]\n\n2. 函数名: iov_length\n- 参数: [const struct iovec *iov, unsigned long nr_segs]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n3. 函数名: generic_write_checks\n- 参数: [struct file *file, loff_t *poffset, size_t *len, unsigned int flags]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n4. 函数名: INIT_LIST_HEAD\n- 参数: [struct list_head *list]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n5. 函数名: tlink_tcon\n- 参数: [struct tcon_link *tlink]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n6. 函数名: iov_iter_init\n- 参数: [struct iov_iter *iter, const struct iovec *iov, unsigned long nr_segs, size_t count, size_t written]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n7. 函数名: get_numpages\n- 参数: [size_t wsize, size_t len, size_t *cur_len]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n8. 函数名: cifs_writedata_alloc\n- 参数: [unsigned long nr_pages, work_func_t complete]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n9. 函数名: cifs_write_allocate_pages\n- 参数: [struct page **pages, unsigned long nr_pages]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n10. 函数名: min_t\n- 参数: [type, x, y]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n11. 函数名: iov_iter_copy_from_user\n- 参数: [struct page *page, struct iov_iter *i, unsigned long offset, size_t bytes]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n12. 函数名: iov_iter_advance\n- 参数: [struct iov_iter *i, size_t bytes]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n13. 函数名: cifsFileInfo_get\n- 参数: [struct cifsFileInfo *cifs_file]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n14. 函数名: cifs_uncached_retry_writev\n- 参数: [struct cifs_writedata *wdata]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n15. 函数名: kref_put\n- 参数: [struct kref *kref, void (*release)(struct kref *kref)]\n- 调用者: cifs_iovec_write\n- 被调用者: [cifs_uncached_writedata_release]\n\n16. 函数名: list_add_tail\n- 参数: [struct list_head *new, struct list_head *head]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n17. 函数名: wait_for_completion_killable\n- 参数: [struct completion *x]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n18. 函数名: list_del_init\n- 参数: [struct list_head *entry]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n19. 函数名: cifs_stats_bytes_written\n- 参数: [struct cifs_tcon *tcon, unsigned int bytes]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n20. 函数名: cifs_uncached_writedata_release\n- 参数: [struct kref *refcount]\n- 调用者: kref_put\n- 被调用者: 未显示"
  },
  {
    "id": 464,
    "cwe": "CWE-119",
    "cve": "CVE-2014-0205",
    "purpose": "Code purpose:\"\"\"该代码片段用于在futex操作中解锁队列并减少键的引用计数\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在requeue操作期间未能正确维护引用计数，导致引用计数可能为零，从而引发use-after-free问题\"\"\"",
    "functions": "Functions:\n1. 函数名: queue_unlock\n- 参数: [struct futex_q *q, struct futex_hash_bucket *hb]\n- 被调用者: [spin_unlock, drop_futex_key_refs]\n\n2. 函数名: spin_unlock\n- 参数: [&hb->lock]\n- 调用者: queue_unlock\n\n3. 函数名: drop_futex_key_refs\n- 参数: [&q->key]\n- 调用者: queue_unlock"
  },
  {
    "id": 465,
    "cwe": "CWE-119",
    "cve": "CVE-2014-0205",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中的futex_wait功能，用于在用户空间地址上等待特定条件满足或超时发生，支持可中断的等待操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在requeue操作期间未能正确维护引用计数，导致引用计数可能变为零，从而引发use-after-free问题\"\"\"",
    "functions": "Functions:\n1. 函数名: futex_wait\n- 参数: [u32 __user *uaddr, int fshared, u32 val, ktime_t *abs_time, u32 bitset, int clockrt]\n- 调用者: N/A (top-level function)\n- 被调用者: [futex_wait_setup, futex_wait_queue_me, unqueue_me, signal_pending, put_futex_key, hrtimer_init_on_stack, hrtimer_init_sleeper, hrtimer_set_expires_range_ns, hrtimer_cancel, destroy_hrtimer_on_stack]\n\n2. 函数名: futex_wait_setup\n- 参数: [u32 __user *uaddr, u32 val, int fshared, struct futex_q *q, struct futex_hash_bucket **hb]\n- 调用者: futex_wait\n- 被调用者: []\n\n3. 函数名: futex_wait_queue_me\n- 参数: [struct futex_hash_bucket *hb, struct futex_q *q, struct hrtimer_sleeper *to]\n- 调用者: futex_wait\n- 被调用者: []\n\n4. 函数名: unqueue_me\n- 参数: [struct futex_q *q]\n- 调用者: futex_wait\n- 被调用者: []\n\n5. 函数名: signal_pending\n- 参数: [struct task_struct *current]\n- 调用者: futex_wait\n- 被调用者: []\n\n6. 函数名: put_futex_key\n- 参数: [int fshared, struct futex_key *key]\n- 调用者: futex_wait\n- 被调用者: []\n\n7. 函数名: hrtimer_init_on_stack\n- 参数: [struct hrtimer *timer, clockid_t which_clock, enum hrtimer_mode mode]\n- 调用者: futex_wait\n- 被调用者: []\n\n8. 函数名: hrtimer_init_sleeper\n- 参数: [struct hrtimer_sleeper *sl, struct task_struct *task]\n- 调用者: futex_wait\n- 被调用者: []\n\n9. 函数名: hrtimer_set_expires_range_ns\n- 参数: [struct hrtimer *timer, ktime_t time, u64 delta]\n- 调用者: futex_wait\n- 被调用者: []\n\n10. 函数名: hrtimer_cancel\n- 参数: [struct hrtimer *timer]\n- 调用者: futex_wait\n- 被调用者: []\n\n11. 函数名: destroy_hrtimer_on_stack\n- 参数: [struct hrtimer *timer]\n- 调用者: futex_wait\n- 被调用者: []"
  },
  {
    "id": 466,
    "cwe": "CWE-119",
    "cve": "CVE-2014-0205",
    "purpose": "Code purpose:\"\"\"实现futex(快速用户空间互斥锁)的等待和重新排队功能，用于进程间同步和互斥操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在futex_wait函数中进行requeue操作时未正确维护引用计数，导致引用计数可能变为零，从而引发use-after-free问题\"\"\"",
    "functions": "Functions:\n1. 函数名: futex_wait_requeue_pi\n- 参数: [u32 __user *uaddr, int fshared, u32 val, ktime_t *abs_time, u32 bitset, int clockrt, u32 __user *uaddr2]\n- 调用者: 未显示\n- 被调用者: [hrtimer_init_on_stack, hrtimer_init_sleeper, hrtimer_set_expires_range_ns, debug_rt_mutex_init_waiter, get_futex_key, futex_wait_setup, futex_wait_queue_me, handle_early_requeue_pi_wakeup, fixup_pi_state_owner, rt_mutex_finish_proxy_lock, debug_rt_mutex_free_waiter, fixup_owner, unqueue_me_pi, rt_mutex_unlock, put_futex_key, hrtimer_cancel, destroy_hrtimer_on_stack]\n\n2. 函数名: hrtimer_init_on_stack\n- 参数: [&to->timer, clockrt ? CLOCK_REALTIME : CLOCK_MONOTONIC, HRTIMER_MODE_ABS]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n3. 函数名: hrtimer_init_sleeper\n- 参数: [to, current]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n4. 函数名: hrtimer_set_expires_range_ns\n- 参数: [&to->timer, *abs_time, current->timer_slack_ns]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n5. 函数名: debug_rt_mutex_init_waiter\n- 参数: [&rt_waiter]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n6. 函数名: get_futex_key\n- 参数: [uaddr2, fshared, &key2]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n7. 函数名: futex_wait_setup\n- 参数: [uaddr, val, fshared, &q, &hb]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n8. 函数名: futex_wait_queue_me\n- 参数: [hb, &q, to]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n9. 函数名: handle_early_requeue_pi_wakeup\n- 参数: [hb, &q, &key2, to]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n10. 函数名: fixup_pi_state_owner\n- 参数: [uaddr2, &q, current, fshared]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n11. 函数名: rt_mutex_finish_proxy_lock\n- 参数: [pi_mutex, to, &rt_waiter, 1]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n12. 函数名: debug_rt_mutex_free_waiter\n- 参数: [&rt_waiter]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n13. 函数名: fixup_owner\n- 参数: [uaddr2, fshared, &q, !ret]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n14. 函数名: unqueue_me_pi\n- 参数: [&q]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n15. 函数名: rt_mutex_unlock\n- 参数: [pi_mutex]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n16. 函数名: put_futex_key\n- 参数: [fshared, &q.key] 和 [fshared, &key2]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n17. 函数名: hrtimer_cancel\n- 参数: [&to->timer]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n18. 函数名: destroy_hrtimer_on_stack\n- 参数: [&to->timer]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示"
  },
  {
    "id": 467,
    "cwe": "CWE-119",
    "cve": "CVE-2014-0205",
    "purpose": "Code purpose:\"\"\"该代码片段用于在Linux内核的futex机制中获取并锁定与给定futex队列项相关联的哈希桶\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在requeue操作期间未能正确维护引用计数，导致引用计数可能为零，引发use-after-free问题\"\"\"",
    "functions": "Functions:\n1. 函数名: queue_lock\n- 参数: [struct futex_q *q]\n- 调用者: 未提供\n- 被调用者: [get_futex_key_refs, hash_futex, spin_lock]\n\n2. 函数名: get_futex_key_refs\n- 参数: [&q->key]\n- 调用者: queue_lock\n- 被调用者: 未提供\n\n3. 函数名: hash_futex\n- 参数: [&q->key]\n- 调用者: queue_lock\n- 被调用者: 未提供\n\n4. 函数名: spin_lock\n- 参数: [&hb->lock]\n- 调用者: queue_lock\n- 被调用者: 未提供"
  },
  {
    "id": 468,
    "cwe": "CWE-119",
    "cve": "CVE-2014-0205",
    "purpose": "Code purpose:\"\"\"该代码片段用于在Linux内核中处理futex队列的解除排队操作，释放相关资源并减少引用计数\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在requeue操作期间未能正确维护引用计数，导致引用计数可能为零，从而引发use-after-free问题\"\"\"",
    "functions": "Functions:\n1. 函数名: unqueue_me_pi\n- 参数: [struct futex_q *q]\n- 调用者: 未明确（由系统调用或内核其他部分调用）\n- 被调用者: [WARN_ON, plist_del, BUG_ON, free_pi_state, spin_unlock, drop_futex_key_refs]\n\n2. 函数名: WARN_ON\n- 参数: [plist_node_empty(&q->list)]\n- 调用者: unqueue_me_pi\n- 被调用者: [plist_node_empty]\n\n3. 函数名: plist_node_empty\n- 参数: [&q->list]\n- 调用者: WARN_ON\n- 被调用者: []\n\n4. 函数名: plist_del\n- 参数: [&q->list, &q->list.plist]\n- 调用者: unqueue_me_pi\n- 被调用者: []\n\n5. 函数名: BUG_ON\n- 参数: [!q->pi_state]\n- 调用者: unqueue_me_pi\n- 被调用者: []\n\n6. 函数名: free_pi_state\n- 参数: [q->pi_state]\n- 调用者: unqueue_me_pi\n- 被调用者: []\n\n7. 函数名: spin_unlock\n- 参数: [q->lock_ptr]\n- 调用者: unqueue_me_pi\n- 被调用者: []\n\n8. 函数名: drop_futex_key_refs\n- 参数: [&q->key]\n- 调用者: unqueue_me_pi\n- 被调用者: []"
  },
  {
    "id": 480,
    "cwe": "CWE-119",
    "cve": "CVE-2014-2309",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理IPv6路由的添加操作，包括验证配置参数、创建路由表项、设置路由属性和安装路由等功能\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中的ip6_route_add函数在处理ICMPv6路由器通告包时未正确限制路由添加数量，导致攻击者可通过洪水攻击造成内存耗尽\"\"\"",
    "functions": "Functions:\n1. 函数名: ip6_route_add\n- 参数: [struct fib6_config *cfg]\n- 调用者: 未显示（外部调用）\n- 被调用者: [dev_get_by_index, in6_dev_get, fib6_get_table, fib6_new_table, ip6_dst_alloc, rt6_set_expires, rt6_clean_expires, ipv6_addr_type, ipv6_addr_prefix, kzalloc, dst_init_metrics, dev_put, in6_dev_put, dev_hold, in6_dev_get, in6_dev_hold, rt6_lookup, ip6_rt_put, ipv6_chk_addr, dst_metric_set, dst_free, __ip6_ins_rt]\n\n2. 函数名: dev_get_by_index\n- 参数: [struct net *net, int ifindex]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n3. 函数名: in6_dev_get\n- 参数: [struct net_device *dev]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n4. 函数名: fib6_get_table\n- 参数: [struct net *net, u32 id]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n5. 函数名: fib6_new_table\n- 参数: [struct net *net, u32 id]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n6. 函数名: ip6_dst_alloc\n- 参数: [struct net *net, struct net_device *dev, int flags, struct fib6_table *table]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n7. 函数名: rt6_set_expires\n- 参数: [struct rt6_info *rt, unsigned long expires]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n8. 函数名: rt6_clean_expires\n- 参数: [struct rt6_info *rt]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n9. 函数名: ipv6_addr_type\n- 参数: [const struct in6_addr *addr]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n10. 函数名: ipv6_addr_prefix\n- 参数: [struct in6_addr *pfx, const struct in6_addr *addr, int plen]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n11. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n12. 函数名: dst_init_metrics\n- 参数: [struct dst_entry *dst, u32 *src_metrics, bool override]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n13. 函数名: dev_put\n- 参数: [struct net_device *dev]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n14. 函数名: in6_dev_put\n- 参数: [struct inet6_dev *idev]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n15. 函数名: dev_hold\n- 参数: [struct net_device *dev]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n16. 函数名: in6_dev_hold\n- 参数: [struct inet6_dev *idev]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n17. 函数名: rt6_lookup\n- 参数: [struct net *net, const struct in6_addr *daddr, const struct in6_addr *saddr, int oif, int strict]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n18. 函数名: ip6_rt_put\n- 参数: [struct rt6_info *rt]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n19. 函数名: ipv6_chk_addr\n- 参数: [struct net *net, const struct in6_addr *addr, const struct net_device *dev, int strict]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n20. 函数名: dst_metric_set\n- 参数: [struct dst_entry *dst, int metric, u32 val]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n21. 函数名: dst_free\n- 参数: [struct dst_entry *dst]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n22. 函数名: __ip6_ins_rt\n- 参数: [struct rt6_info *rt, struct nl_info *info]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）"
  },
  {
    "id": 511,
    "cwe": "CWE-119",
    "cve": "CVE-2014-3181",
    "purpose": "Code purpose:\"\"\"处理Magic Mouse和Magic Trackpad设备的原始输入数据，包括解析触摸点信息和按钮点击事件，并将这些事件报告给输入子系统。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"magicmouse_raw_event函数在处理来自设备的输入数据时，未充分验证数据大小，导致栈缓冲区溢出漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: magicmouse_raw_event\n- 参数: [struct hid_device *hdev, struct hid_report *report, u8 *data, int size]\n- 调用者: 外部调用（未在代码中显示）\n- 被调用者: [magicmouse_emit_touch, magicmouse_emit_buttons, input_report_rel, input_report_key, input_mt_report_pointer_emulation, input_sync, magicmouse_raw_event]\n\n2. 函数名: magicmouse_emit_touch\n- 参数: [struct magicmouse_sc *msc, int ii, u8 *data]\n- 调用者: magicmouse_raw_event\n- 被调用者: []\n\n3. 函数名: magicmouse_emit_buttons\n- 参数: [struct magicmouse_sc *msc, int clicks]\n- 调用者: magicmouse_raw_event\n- 被调用者: []\n\n4. 函数名: input_report_rel\n- 参数: [struct input_dev *input, int REL_X, int x]\n- 调用者: magicmouse_raw_event\n- 被调用者: []\n\n5. 函数名: input_report_key\n- 参数: [struct input_dev *input, int BTN_MOUSE, int clicks]\n- 调用者: magicmouse_raw_event\n- 被调用者: []\n\n6. 函数名: input_mt_report_pointer_emulation\n- 参数: [struct input_dev *input, bool true]\n- 调用者: magicmouse_raw_event\n- 被调用者: []\n\n7. 函数名: input_sync\n- 参数: [struct input_dev *input]\n- 调用者: magicmouse_raw_event\n- 被调用者: []"
  },
  {
    "id": 512,
    "cwe": "CWE-119",
    "cve": "CVE-2014-3182",
    "purpose": "Code purpose:\"\"\"该代码用于处理Logitech Unifying无线接收器接收到的设备配对报告，分配并初始化新的HID设备，并将其添加到系统中。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理REPORT_TYPE_NOTIF_DEVICE_UNPAIRED报告时，由于未正确验证设备索引范围，导致数组越界访问和无效内存释放漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: logi_dj_recv_add_djhid_device\n- 参数: [djrcv_dev, dj_report]\n- 调用者: 未显示（应为外部调用）\n- 被调用者: [hid_allocate_device, IS_ERR, snprintf, usb_make_path, strlcat, kzalloc, get_unaligned_le32, hid_add_device, kfree, hid_destroy_device]\n\n2. 函数名: hid_allocate_device\n- 参数: []\n- 调用者: logi_dj_recv_add_djhid_device\n- 被调用者: []\n\n3. 函数名: IS_ERR\n- 参数: [dj_hiddev]\n- 调用者: logi_dj_recv_add_djhid_device\n- 被调用者: []\n\n4. 函数名: snprintf\n- 参数: [dj_hiddev->name, sizeof(dj_hiddev->name), \"Logitech Unifying Device. Wireless PID:%02x%02x\", dj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_MSB], dj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_LSB]]\n- 调用者: logi_dj_recv_add_djhid_device\n- 被调用者: []\n\n5. 函数名: usb_make_path\n- 参数: [usbdev, dj_hiddev->phys, sizeof(dj_hiddev->phys)]\n- 调用者: logi_dj_recv_add_djhid_device\n- 被调用者: []\n\n6. 函数名: strlcat\n- 参数: [dj_hiddev->phys, tmpstr, sizeof(dj_hiddev->phys)]\n- 调用者: logi_dj_recv_add_djhid_device\n- 被调用者: []\n\n7. 函数名: kzalloc\n- 参数: [sizeof(struct dj_device), GFP_KERNEL]\n- 调用者: logi_dj_recv_add_djhid_device\n- 被调用者: []\n\n8. 函数名: get_unaligned_le32\n- 参数: [dj_report->report_params + DEVICE_PAIRED_RF_REPORT_TYPE]\n- 调用者: logi_dj_recv_add_djhid_device\n- 被调用者: []\n\n9. 函数名: hid_add_device\n- 参数: [dj_hiddev]\n- 调用者: logi_dj_recv_add_djhid_device\n- 被调用者: []\n\n10. 函数名: kfree\n- 参数: [dj_dev]\n- 调用者: logi_dj_recv_add_djhid_device\n- 被调用者: []\n\n11. 函数名: hid_destroy_device\n- 参数: [dj_hiddev]\n- 调用者: logi_dj_recv_add_djhid_device\n- 被调用者: []"
  },
  {
    "id": 513,
    "cwe": "CWE-119",
    "cve": "CVE-2014-3182",
    "purpose": "Code purpose:\"\"\"处理来自Logitech DJ设备的原始HID报告数据，包括设备配对/取消配对通知、连接状态变化和输入事件转发等功能。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理REPORT_TYPE_NOTIF_DEVICE_UNPAIRED类型的报告时，由于未对输入数据进行充分验证，导致数组索引错误或无效内存释放。\"\"\"",
    "functions": "Functions:\n1. 函数名: logi_dj_raw_event\n- 参数: [struct hid_device *hdev, struct hid_report *report, u8 *data, int size]\n- 调用者: hid-core (implied by raw event handling)\n- 被调用者: [hid_get_drvdata, logi_dj_recv_queue_notification, logi_dj_recv_forward_null_report, logi_dj_recv_forward_report]\n\n2. 函数名: hid_get_drvdata\n- 参数: [struct hid_device *hdev]\n- 调用者: logi_dj_raw_event\n- 被调用者: []\n\n3. 函数名: logi_dj_recv_queue_notification\n- 参数: [struct dj_receiver_dev *djrcv_dev, struct dj_report *dj_report]\n- 调用者: logi_dj_raw_event\n- 被调用者: []\n\n4. 函数名: logi_dj_recv_forward_null_report\n- 参数: [struct dj_receiver_dev *djrcv_dev, struct dj_report *dj_report]\n- 调用者: logi_dj_raw_event\n- 被调用者: []\n\n5. 函数名: logi_dj_recv_forward_report\n- 参数: [struct dj_receiver_dev *djrcv_dev, struct dj_report *dj_report]\n- 调用者: logi_dj_raw_event\n- 被调用者: []"
  },
  {
    "id": 514,
    "cwe": "CWE-119",
    "cve": "CVE-2014-3183",
    "purpose": "Code purpose:\"\"\"处理来自Logitech无线设备的HID原始请求，特别是LED报告类型的请求，并将请求转发给接收器设备。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证输入报告的大小，导致在memcpy操作时可能发生堆缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: logi_dj_ll_raw_request\n- 参数: [struct hid_device *hid, unsigned char reportnum, __u8 *buf, size_t count, unsigned char report_type, int reqtype]\n- 调用者: 未指定（由HID子系统调用）\n- 被调用者: [kzalloc, memcpy, hid_hw_raw_request, kfree]\n\n2. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: logi_dj_ll_raw_request\n- 被调用者: []\n\n3. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: logi_dj_ll_raw_request\n- 被调用者: []\n\n4. 函数名: hid_hw_raw_request\n- 参数: [struct hid_device *hdev, unsigned char reportnum, __u8 *buf, size_t count, unsigned char report_type, int reqtype]\n- 调用者: logi_dj_ll_raw_request\n- 被调用者: []\n\n5. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: logi_dj_ll_raw_request\n- 被调用者: []"
  },
  {
    "id": 515,
    "cwe": "CWE-119",
    "cve": "CVE-2014-3184",
    "purpose": "Code purpose:\"\"\"修复Cherry Cymotion设备的报告描述符，通过修改特定位置的字节值来纠正描述符格式。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证输入报告描述符的大小，导致在处理特定设备提供的过小报告描述符时可能发生越界写入\"\"\"",
    "functions": "Functions:\n1. 函数名: ch_report_fixup\n- 参数: [hdev, rdesc, rsize]\n- 调用者: HID subsystem in the Linux kernel\n- 被调用者: [hid_info]"
  },
  {
    "id": 516,
    "cwe": "CWE-119",
    "cve": "CVE-2014-3184",
    "purpose": "Code purpose:\"\"\"该代码用于修复特定USB设备（如KYE/Genius品牌的鼠标和键盘）的报告描述符，确保其与HID子系统兼容，但存在缓冲区溢出漏洞风险。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证输入报告描述符的大小，导致在处理小型报告描述符时可能发生越界写入\"\"\"",
    "functions": "Functions:\n1. 函数名: kye_report_fixup\n- 参数: [struct hid_device *hdev, __u8 *rdesc, unsigned int *rsize]\n- 调用者: 未显示（由HID子系统调用）\n- 被调用者: [kye_consumer_control_fixup]\n\n2. 函数名: kye_consumer_control_fixup\n- 参数: [struct hid_device *hdev, __u8 *rdesc, unsigned int *rsize, int value, char *name]\n- 调用者: kye_report_fixup\n- 被调用者: []"
  },
  {
    "id": 517,
    "cwe": "CWE-119",
    "cve": "CVE-2014-3184",
    "purpose": "Code purpose:\"\"\"该代码用于修正Logitech设备的HID报告描述符，处理不同型号设备的特定描述符格式问题，以防止设备通信异常。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证输入报告描述符的大小，导致在处理特定设备的小型报告描述符时可能发生越界写入\"\"\"",
    "functions": "Functions:\n1. 函数名: lg_report_fixup\n- 参数: [struct hid_device *hdev, __u8 *rdesc, unsigned int *rsize]\n- 调用者: 未显示（由HID子系统调用）\n- 被调用者: [hid_get_drvdata, hid_info, hid_err, le16_to_cpu]\n\n2. 函数名: hid_get_drvdata\n- 参数: [struct hid_device *hdev]\n- 调用者: lg_report_fixup\n- 被调用者: 未显示\n\n3. 函数名: hid_info\n- 参数: [struct hid_device *hdev, const char *fmt, ...]\n- 调用者: lg_report_fixup\n- 被调用者: 未显示\n\n4. 函数名: hid_err\n- 参数: [struct hid_device *hdev, const char *fmt, ...]\n- 调用者: lg_report_fixup\n- 被调用者: 未显示\n\n5. 函数名: le16_to_cpu\n- 参数: [__u16 val]\n- 调用者: lg_report_fixup\n- 被调用者: 未显示\n\n6. 函数名: hid_to_usb_dev\n- 参数: [struct hid_device *hdev]\n- 调用者: lg_report_fixup\n- 被调用者: 未显示"
  },
  {
    "id": 518,
    "cwe": "CWE-119",
    "cve": "CVE-2014-3184",
    "purpose": "Code purpose:\"\"\"修复HID报告描述符中的按钮/消费者控制项，防止设备提供不正确的描述符导致问题\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证输入报告描述符的大小，导致在处理小型报告描述符时可能发生越界写入\"\"\"",
    "functions": "Functions:\n1. 函数名: mr_report_fixup\n- 参数: [struct hid_device *hdev, __u8 *rdesc, unsigned int *rsize]\n- 调用者: HID子系统（具体调用者未在代码片段中显示）\n- 被调用者: [hid_info]"
  },
  {
    "id": 519,
    "cwe": "CWE-119",
    "cve": "CVE-2014-3184",
    "purpose": "Code purpose:\"\"\"修复Petalynx Maxter Remote设备的报告描述符中的特定字节值以防止越界写入漏洞\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证输入报告描述符的大小，导致在边界检查不足的情况下可能发生越界写入\"\"\"",
    "functions": "Functions:\n1. 函数名: pl_report_fixup\n- 参数: [struct hid_device *hdev, __u8 *rdesc, unsigned int *rsize]\n- 调用者: 未明确（由HID子系统调用）\n- 被调用者: [hid_info]"
  },
  {
    "id": 520,
    "cwe": "CWE-119",
    "cve": "CVE-2014-3184",
    "purpose": "Code purpose:\"\"\"修复Sunplus无线桌面设备的报告描述符，防止因描述符过小导致的越界写入问题\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证输入报告描述符的大小，导致在处理小型恶意描述符时可能发生越界写入\"\"\"",
    "functions": "Functions:\n1. 函数名: sp_report_fixup\n- 参数: [struct hid_device *hdev, __u8 *rdesc, unsigned int *rsize]\n- 调用者: 未明确显示（由HID子系统调用）\n- 被调用者: [hid_info]"
  },
  {
    "id": 521,
    "cwe": "CWE-119",
    "cve": "CVE-2014-3185",
    "purpose": "Code purpose:\"\"\"处理USB串行端口命令的回调函数，包括命令完成状态检查、事件处理和内存数据拷贝等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理USB设备返回的批量响应数据时，未对urb->actual_length进行有效验证，导致缓冲区溢出漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: command_port_read_callback\n- 参数: [struct urb *urb]\n- 调用者: 未被直接显示（由USB子系统调用）\n- 被调用者: [usb_get_serial_port_data, dev_dbg, wake_up, usb_serial_debug_data, memcpy, usb_submit_urb]\n\n2. 函数名: usb_get_serial_port_data\n- 参数: [struct usb_serial_port *command_port]\n- 调用者: command_port_read_callback\n- 被调用者: []\n\n3. 函数名: dev_dbg\n- 参数: [&urb->dev->dev, format_string, ...]\n- 调用者: command_port_read_callback\n- 被调用者: []\n\n4. 函数名: wake_up\n- 参数: [&command_info->wait_command]\n- 调用者: command_port_read_callback\n- 被调用者: []\n\n5. 函数名: usb_serial_debug_data\n- 参数: [&command_port->dev, __func__, urb->actual_length, data]\n- 调用者: command_port_read_callback\n- 被调用者: []\n\n6. 函数名: memcpy\n- 参数: [command_info->result_buffer, &data[1], urb->actual_length - 1]\n- 调用者: command_port_read_callback\n- 被调用者: []\n\n7. 函数名: usb_submit_urb\n- 参数: [command_port->read_urb, GFP_ATOMIC]\n- 调用者: command_port_read_callback\n- 被调用者: []"
  },
  {
    "id": 522,
    "cwe": "CWE-119",
    "cve": "CVE-2014-3186",
    "purpose": "Code purpose:\"\"\"处理来自PicoLCD HID设备的原始输入事件，包括按键状态、红外数据和其他报告类型的数据\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理来自PicoLCD设备的报告数据时，未对输入的raw_data+1和size-1进行边界检查，导致缓冲区溢出漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: picolcd_raw_event\n- 参数: [struct hid_device *hdev, struct hid_report *report, u8 *raw_data, int size]\n- 调用者: 未指定（由HID子系统调用）\n- 被调用者: [hid_get_drvdata, picolcd_raw_keypad, picolcd_raw_cir, spin_lock_irqsave, memcpy, complete, spin_unlock_irqrestore, picolcd_debug_raw_event]\n\n2. 函数名: hid_get_drvdata\n- 参数: [struct hid_device *hdev]\n- 调用者: picolcd_raw_event\n- 被调用者: []\n\n3. 函数名: picolcd_raw_keypad\n- 参数: [struct picolcd_data *data, struct hid_report *report, u8 *raw_data, int size]\n- 调用者: picolcd_raw_event\n- 被调用者: []\n\n4. 函数名: picolcd_raw_cir\n- 参数: [struct picolcd_data *data, struct hid_report *report, u8 *raw_data, int size]\n- 调用者: picolcd_raw_event\n- 被调用者: []\n\n5. 函数名: spin_lock_irqsave\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: picolcd_raw_event\n- 被调用者: []\n\n6. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: picolcd_raw_event\n- 被调用者: []\n\n7. 函数名: complete\n- 参数: [struct completion *x]\n- 调用者: picolcd_raw_event\n- 被调用者: []\n\n8. 函数名: spin_unlock_irqrestore\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: picolcd_raw_event\n- 被调用者: []\n\n9. 函数名: picolcd_debug_raw_event\n- 参数: [struct picolcd_data *data, struct hid_device *hdev, struct hid_report *report, u8 *raw_data, int size]\n- 调用者: picolcd_raw_event\n- 被调用者: []"
  },
  {
    "id": 581,
    "cwe": "CWE-119",
    "cve": "CVE-2014-6416",
    "purpose": "Code purpose:\"\"\"验证来自Ceph认证服务的授权回复消息的合法性，包括解密回复和检查nonce值是否正确\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对输入的auth ticket长度进行有效验证，导致缓冲区溢出漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: ceph_x_verify_authorizer_reply\n- 参数: [struct ceph_auth_client *ac, struct ceph_authorizer *a, size_t len]\n- 调用者: 未显示\n- 被调用者: [get_ticket_handler, ceph_x_decrypt, le64_to_cpu]\n\n2. 函数名: get_ticket_handler\n- 参数: [struct ceph_auth_client *ac, au->service]\n- 调用者: ceph_x_verify_authorizer_reply\n- 被调用者: 未显示\n\n3. 函数名: ceph_x_decrypt\n- 参数: [&th->session_key, &p, end, &reply, sizeof(reply)]\n- 调用者: ceph_x_verify_authorizer_reply\n- 被调用者: 未显示\n\n4. 函数名: le64_to_cpu\n- 参数: [reply.nonce_plus_one]\n- 调用者: ceph_x_verify_authorizer_reply\n- 被调用者: 未显示"
  },
  {
    "id": 582,
    "cwe": "CWE-119",
    "cve": "CVE-2014-6416",
    "purpose": "Code purpose:\"\"\"处理来自Ceph认证服务器的票据回复，包括解码和验证票据信息\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理长认证票据时，由于未对输入数据进行有效长度检查，导致缓冲区溢出漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: ceph_x_proc_ticket_reply\n- 参数: [struct ceph_auth_client *ac, struct ceph_crypto_key *secret, void *buf, void *end]\n- 调用者: 未显示（外部调用）\n- 被调用者: [kmalloc, kfree, ceph_decode_8_safe, ceph_decode_32_safe, process_one_ticket]\n\n2. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: [ceph_x_proc_ticket_reply]\n- 被调用者: 未显示（内核函数）\n\n3. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: [ceph_x_proc_ticket_reply]\n- 被调用者: 未显示（内核函数）\n\n4. 函数名: ceph_decode_8_safe\n- 参数: [void **p, void *end, u8 *v, label]\n- 调用者: [ceph_x_proc_ticket_reply]\n- 被调用者: 未显示（外部函数）\n\n5. 函数名: ceph_decode_32_safe\n- 参数: [void **p, void *end, u32 *v, label]\n- 调用者: [ceph_x_proc_ticket_reply]\n- 被调用者: 未显示（外部函数）\n\n6. 函数名: process_one_ticket\n- 参数: [struct ceph_auth_client *ac, struct ceph_crypto_key *secret, void **p, void *end, char *dbuf, char *ticket_buf]\n- 调用者: [ceph_x_proc_ticket_reply]\n- 被调用者: 未显示（外部函数）"
  },
  {
    "id": 622,
    "cwe": "CWE-119",
    "cve": "CVE-2014-8369",
    "purpose": "Code purpose:\"\"\"该代码用于在KVM虚拟化环境中将客户机的内存页映射到IOMMU域中，处理内存页的映射和错误情况\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理映射失败时，函数错误计算了需要取消映射的页面数量，导致可能解钉错误的页面或造成其他未指定影响\"\"\"",
    "functions": "Functions:\n1. 函数名: kvm_iommu_map_pages\n- 参数: [kvm, slot]\n- 调用者: 未显示（外部调用）\n- 被调用者: [iommu_iova_to_phys, gfn_to_gpa, kvm_host_page_size, __gfn_to_hva_memslot, kvm_pin_pages, is_error_noslot_pfn, iommu_map, pfn_to_hpa, kvm_unpin_pages, kvm_iommu_put_pages]\n\n2. 函数名: iommu_iova_to_phys\n- 参数: [domain, gfn_to_gpa(gfn)]\n- 调用者: kvm_iommu_map_pages\n- 被调用者: []\n\n3. 函数名: gfn_to_gpa\n- 参数: [gfn]\n- 调用者: kvm_iommu_map_pages\n- 被调用者: []\n\n4. 函数名: kvm_host_page_size\n- 参数: [kvm, gfn]\n- 调用者: kvm_iommu_map_pages\n- 被调用者: []\n\n5. 函数名: __gfn_to_hva_memslot\n- 参数: [slot, gfn]\n- 调用者: kvm_iommu_map_pages\n- 被调用者: []\n\n6. 函数名: kvm_pin_pages\n- 参数: [slot, gfn, page_size]\n- 调用者: kvm_iommu_map_pages\n- 被调用者: []\n\n7. 函数名: is_error_noslot_pfn\n- 参数: [pfn]\n- 调用者: kvm_iommu_map_pages\n- 被调用者: []\n\n8. 函数名: iommu_map\n- 参数: [domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn), page_size, flags]\n- 调用者: kvm_iommu_map_pages\n- 被调用者: []\n\n9. 函数名: pfn_to_hpa\n- 参数: [pfn]\n- 调用者: kvm_iommu_map_pages\n- 被调用者: []\n\n10. 函数名: kvm_unpin_pages\n- 参数: [kvm, pfn, page_size]\n- 调用者: kvm_iommu_map_pages\n- 被调用者: []\n\n11. 函数名: kvm_iommu_put_pages\n- 参数: [kvm, slot->base_gfn, gfn - slot->base_gfn]\n- 调用者: kvm_iommu_map_pages\n- 被调用者: []"
  },
  {
    "id": 676,
    "cwe": "CWE-119",
    "cve": "CVE-2014-8884",
    "purpose": "Code purpose:\"\"\"该代码用于处理DVB-S前端设备的DiSEqC主命令发送，将命令消息复制到缓冲区并通过配置的发送命令接口进行传输\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对cmd->msg_len进行边界检查，导致memcpy操作可能超出数组b的边界，造成栈缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: ttusbdecfe_dvbs_diseqc_send_master_cmd\n- 参数: [struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd]\n- 调用者: 外部调用（通过ioctl）\n- 被调用者: [memcpy, state->config->send_command]\n\n2. 函数名: memcpy\n- 参数: [void* dest, const void* src, size_t n]\n- 调用者: ttusbdecfe_dvbs_diseqc_send_master_cmd\n- 被调用者: []\n\n3. 函数名: send_command\n- 参数: [struct dvb_frontend* fe, u8 command, u16 param_length, u8* params, u32* result_length, u8* cmd_result]\n- 调用者: ttusbdecfe_dvbs_diseqc_send_master_cmd\n- 被调用者: []"
  },
  {
    "id": 693,
    "cwe": "CWE-119",
    "cve": "CVE-2014-9728",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中UDF文件系统的inode读取功能，用于处理文件系统中的元数据信息并构建内存中的inode结构\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中的UDF文件系统实现未对某些长度进行验证，导致可通过特制的文件系统映像触发缓冲区越界读取，造成系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: udf_read_inode\n- 参数: [struct inode *inode, bool hidden_inode]\n- 调用者: 未显示（通常是文件系统操作调用）\n- 被调用者: [udf_debug, udf_read_ptagged, udf_err, brelse, memcpy, udf_alloc_i_data, i_uid_write, i_gid_write, udf_convert_permissions, set_nlink, udf_disk_stamp_to_time, inc_nlink, init_special_inode, udf_get_extendedattr, le32_to_cpu, le16_to_cpu, le64_to_cpu, cpu_to_le16, MKDEV]\n\n2. 函数名: udf_read_ptagged\n- 参数: [struct super_block *sb, struct kernel_lb_addr *loc, int offset, uint16_t *ident]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n3. 函数名: udf_err\n- 参数: [struct super_block *sb, const char *fmt, ...]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n4. 函数名: udf_debug\n- 参数: [const char *fmt, ...]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n5. 函数名: udf_alloc_i_data\n- 参数: [struct inode *inode, int size]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n6. 函数名: udf_convert_permissions\n- 参数: [struct fileEntry *fe]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n7. 函数名: udf_disk_stamp_to_time\n- 参数: [struct timespec *dest, struct timestamp src]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n8. 函数名: udf_get_extendedattr\n- 参数: [struct inode *inode, int type, int subtype]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n9. 函数名: brelse\n- 参数: [struct buffer_head *bh]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n10. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n11. 函数名: i_uid_write\n- 参数: [struct inode *inode, uid_t uid]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n12. 函数名: i_gid_write\n- 参数: [struct inode *inode, gid_t gid]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n13. 函数名: set_nlink\n- 参数: [struct inode *inode, unsigned int nlink]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n14. 函数名: inc_nlink\n- 参数: [struct inode *inode]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n15. 函数名: init_special_inode\n- 参数: [struct inode *inode, umode_t mode, dev_t rdev]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n16. 函数名: le32_to_cpu\n- 参数: [__le32 val]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n17. 函数名: le16_to_cpu\n- 参数: [__le16 val]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n18. 函数名: le64_to_cpu\n- 参数: [__le64 val]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n19. 函数名: cpu_to_le16\n- 参数: [__u16 val]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n20. 函数名: MKDEV\n- 参数: [unsigned int major, unsigned int minor]\n- 调用者: udf_read_inode\n- 被调用者: 未显示"
  },
  {
    "id": 728,
    "cwe": "CWE-119",
    "cve": "CVE-2015-1333",
    "purpose": "Code purpose:\"\"\"在密钥环中完成密钥链接操作并释放相关资源\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在__key_link_end函数中，当edit存在且不是dead_leaf时，未能正确释放edit结构体导致内存泄漏\"\"\"",
    "functions": "Functions:\n1. 函数名: __key_link_end\n- 参数: [struct key *keyring, const struct keyring_index_key *index_key, struct assoc_array_edit *edit]\n- 调用者: 未明确（通常是keyring相关操作调用）\n- 被调用者: [kenter, up_write, key_payload_reserve, assoc_array_cancel_edit]\n\n2. 函数名: kenter\n- 参数: [格式化字符串, keyring->serial, index_key->type->name]\n- 调用者: __key_link_end\n- 被调用者: []\n\n3. 函数名: up_write\n- 参数: [&keyring_serialise_link_sem], [&keyring->sem]\n- 调用者: __key_link_end\n- 被调用者: []\n\n4. 函数名: key_payload_reserve\n- 参数: [keyring, keyring->datalen - KEYQUOTA_LINK_BYTES]\n- 调用者: __key_link_end\n- 被调用者: []\n\n5. 函数名: assoc_array_cancel_edit\n- 参数: [edit]\n- 调用者: __key_link_end\n- 被调用者: []"
  },
  {
    "id": 740,
    "cwe": "CWE-119",
    "cve": "CVE-2015-2666",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核启动早期阶段，根据CPU型号匹配并保存相应的微码更新补丁，以修复CPU漏洞或缺陷。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对mc_saved_tmp数组的索引进行边界检查，导致在_save_mc函数中可能发生栈缓冲区溢出，攻击者可利用特制的微代码头文件通过root权限提升权限。\"\"\"",
    "functions": "Functions:\n1. 函数名: get_matching_model_microcode\n- 参数: [cpu, start, data, size, mc_saved_data, mc_saved_in_initrd, uci]\n- 调用者: 未显示（外部调用）\n- 被调用者: [get_totalsize, microcode_sanity_check, matching_model_microcode, _save_mc]\n\n2. 函数名: get_totalsize\n- 参数: [mc_header]\n- 调用者: get_matching_model_microcode\n- 被调用者: []\n\n3. 函数名: microcode_sanity_check\n- 参数: [ucode_ptr, 0]\n- 调用者: get_matching_model_microcode\n- 被调用者: []\n\n4. 函数名: matching_model_microcode\n- 参数: [mc_header, uci->cpu_sig.sig]\n- 调用者: get_matching_model_microcode\n- 被调用者: []\n\n5. 函数名: _save_mc\n- 参数: [mc_saved_tmp, ucode_ptr, &mc_saved_count]\n- 调用者: get_matching_model_microcode\n- 被调用者: []"
  },
  {
    "id": 753,
    "cwe": "CWE-119",
    "cve": "CVE-2015-3214",
    "purpose": "Code purpose:\"\"\"该代码实现了从KVM虚拟机的PIT(可编程间隔定时器)读取端口数据的操作，包括处理状态锁存和计数锁存情况，并将读取的数据复制到输出缓冲区。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"代码未正确验证输入的长度参数，导致可能使用无效索引访问内存，造成缓冲区溢出。\"\"\"",
    "functions": "Functions:\n1. 函数名: pit_ioport_read\n- 参数: [struct kvm_io_device *this, gpa_t addr, int len, void *data]\n- 调用者: 未明确（由KVM/QEMU的I/O端口读取机制调用）\n- 被调用者: [pit_in_range, dev_to_pit, mutex_lock, pit_get_count, memcpy, mutex_unlock]\n\n2. 函数名: pit_in_range\n- 参数: [gpa_t addr]\n- 调用者: pit_ioport_read\n- 被调用者: 未明确\n\n3. 函数名: dev_to_pit\n- 参数: [struct kvm_io_device *this]\n- 调用者: pit_ioport_read\n- 被调用者: 未明确\n\n4. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: pit_ioport_read\n- 被调用者: 未明确\n\n5. 函数名: pit_get_count\n- 参数: [struct kvm *kvm, int addr]\n- 调用者: pit_ioport_read\n- 被调用者: 未明确\n\n6. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: pit_ioport_read\n- 被调用者: 未明确\n\n7. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: pit_ioport_read\n- 被调用者: 未明确"
  },
  {
    "id": 757,
    "cwe": "CWE-119",
    "cve": "CVE-2015-3331",
    "purpose": "Code purpose:\"\"\"该代码实现了RFC4106标准的AES-GCM解密功能，用于处理加密数据的解密和认证。\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理加密数据时未正确计算关联数据(assoc)的内存位置，导致缓冲区溢出漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: __driver_rfc4106_decrypt\n- 参数: [struct aead_request *req]\n- 调用者: 未明确显示（由内核加密API调用）\n- 被调用者: [cpu_to_be32, crypto_aead_reqtfm, aesni_rfc4106_gcm_ctx_get, crypto_aead_authsize, PTR_ALIGN, scatterwalk_start, scatterwalk_map, sg_is_last, kmalloc, scatterwalk_map_and_copy, aesni_gcm_dec_tfm, crypto_memneq, scatterwalk_unmap, scatterwalk_done, kfree]\n\n2. 函数名: cpu_to_be32\n- 参数: [u32]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n3. 函数名: crypto_aead_reqtfm\n- 参数: [struct aead_request *]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n4. 函数名: aesni_rfc4106_gcm_ctx_get\n- 参数: [struct crypto_aead *]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n5. 函数名: crypto_aead_authsize\n- 参数: [struct crypto_aead *]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n6. 函数名: PTR_ALIGN\n- 参数: [u8 *, AESNI_ALIGN]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n7. 函数名: scatterwalk_start\n- 参数: [struct scatter_walk *, struct scatterlist *]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n8. 函数名: scatterwalk_map\n- 参数: [struct scatter_walk *]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n9. 函数名: sg_is_last\n- 参数: [struct scatterlist *]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n10. 函数名: kmalloc\n- 参数: [size_t, gfp_t]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n11. 函数名: scatterwalk_map_and_copy\n- 参数: [void *, struct scatterlist *, unsigned int, unsigned int, int]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n12. 函数名: aesni_gcm_dec_tfm\n- 参数: [void *, u8 *, u8 *, unsigned long, u8 *, u8 *, u8 *, unsigned long, u8 *, unsigned long]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n13. 函数名: crypto_memneq\n- 参数: [const void *, const void *, size_t]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n14. 函数名: scatterwalk_unmap\n- 参数: [void *]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n15. 函数名: scatterwalk_done\n- 参数: [struct scatter_walk *, int, int]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n16. 函数名: kfree\n- 参数: [const void *]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []"
  },
  {
    "id": 759,
    "cwe": "CWE-119",
    "cve": "CVE-2015-4002",
    "purpose": "Code purpose:\"\"\"处理USB设备接收到的数据包，包括描述符请求、配置设置、接口设置和端点数据传输等USB通信功能\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"代码未对输入的elt->length进行充分验证，导致可能处理恶意构造的异常长度值，造成系统崩溃或任意代码执行\"\"\"",
    "functions": "Functions:\n1. 函数名: oz_usb_rx\n- 参数: [pd, elt]\n- 调用者: 未显示（外部调用）\n- 被调用者: [spin_lock_bh, oz_usb_get, spin_unlock_bh, le16_to_cpu, get_unaligned, oz_dbg, oz_hcd_get_desc_cnf, oz_hcd_control_cnf, oz_usb_handle_ep_data, oz_usb_put]\n\n2. 函数名: spin_lock_bh\n- 参数: [&pd->app_lock[OZ_APPID_USB]]\n- 调用者: oz_usb_rx\n- 被调用者: []\n\n3. 函数名: oz_usb_get\n- 参数: [usb_ctx]\n- 调用者: oz_usb_rx\n- 被调用者: []\n\n4. 函数名: spin_unlock_bh\n- 参数: [&pd->app_lock[OZ_APPID_USB]]\n- 调用者: oz_usb_rx\n- 被调用者: []\n\n5. 函数名: le16_to_cpu\n- 参数: [get_unaligned(&body->offset), get_unaligned(&body->total_size)]\n- 调用者: oz_usb_rx\n- 被调用者: []\n\n6. 函数名: get_unaligned\n- 参数: [&body->offset, &body->total_size]\n- 调用者: oz_usb_rx\n- 被调用者: []\n\n7. 函数名: oz_dbg\n- 参数: [ON, \"USB_REQ_GET_DESCRIPTOR - cnf\\n\"]\n- 调用者: oz_usb_rx\n- 被调用者: []\n\n8. 函数名: oz_hcd_get_desc_cnf\n- 参数: [usb_ctx->hport, body->req_id, body->rcode, body->data, data_len, offs, total_size]\n- 调用者: oz_usb_rx\n- 被调用者: []\n\n9. 函数名: oz_hcd_control_cnf\n- 参数: [usb_ctx->hport, body->req_id, body->rcode, NULL, 0] (多次调用)\n- 调用者: oz_usb_rx\n- 被调用者: []\n\n10. 函数名: oz_usb_handle_ep_data\n- 参数: [usb_ctx, usb_hdr, elt->length]\n- 调用者: oz_usb_rx\n- 被调用者: []\n\n11. 函数名: oz_usb_put\n- 参数: [usb_ctx]\n- 调用者: oz_usb_rx\n- 被调用者: []"
  },
  {
    "id": 761,
    "cwe": "CWE-119",
    "cve": "CVE-2015-4036",
    "purpose": "Code purpose:\"\"\"该代码用于在vhost_scsi驱动中创建并注册一个目标端口组(Target Portal Group, TPG)，处理用户提供的配置参数并初始化相关数据结构。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理VHOST_SCSI_SET_ENDPOINT ioctl调用时，vhost_scsi_make_tpg函数未能充分验证输入的'tpgt'参数，可能导致内存越界访问或内存损坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: vhost_scsi_make_tpg\n- 参数: [struct se_wwn *wwn, struct config_group *group, const char *name]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [container_of, strstr, kstrtoul, kzalloc, pr_err, mutex_init, INIT_LIST_HEAD, core_tpg_register, kfree, mutex_lock, list_add_tail, mutex_unlock]\n\n2. 函数名: container_of\n- 参数: [未显示完整参数]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []\n\n3. 函数名: strstr\n- 参数: [const char *name, const char *\"tpgt_\"]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []\n\n4. 函数名: kstrtoul\n- 参数: [const char *name + 5, int 10, unsigned long *tpgt]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []\n\n5. 函数名: kzalloc\n- 参数: [sizeof(struct vhost_scsi_tpg), GFP_KERNEL]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []\n\n6. 函数名: pr_err\n- 参数: [const char *\"Unable to allocate struct vhost_scsi_tpg\"]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []\n\n7. 函数名: mutex_init\n- 参数: [&tpg->tv_tpg_mutex]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []\n\n8. 函数名: INIT_LIST_HEAD\n- 参数: [&tpg->tv_tpg_list]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []\n\n9. 函数名: core_tpg_register\n- 参数: [&vhost_scsi_fabric_configfs->tf_ops, wwn, &tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []\n\n10. 函数名: kfree\n- 参数: [tpg]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []\n\n11. 函数名: mutex_lock\n- 参数: [&vhost_scsi_mutex]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []\n\n12. 函数名: list_add_tail\n- 参数: [&tpg->tv_tpg_list, &vhost_scsi_list]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []\n\n13. 函数名: mutex_unlock\n- 参数: [&vhost_scsi_mutex]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []"
  },
  {
    "id": 762,
    "cwe": "CWE-119",
    "cve": "CVE-2015-4036",
    "purpose": "Code purpose:\"\"\"该代码用于在vhost-scsi驱动中处理并发送SCSI事件通知，包括设置LUN信息并将其添加到事件列表中以供后续处理。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对lun->unpacked_lun的值进行充分验证，可能导致数组越界访问，造成内存损坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: vhost_scsi_send_evt\n- 参数: [struct vhost_scsi *vs, struct vhost_scsi_tpg *tpg, struct se_lun *lun, u32 event, u32 reason]\n- 调用者: 未明确显示（由外部调用）\n- 被调用者: [vhost_scsi_allocate_evt, llist_add, vhost_work_queue]\n\n2. 函数名: vhost_scsi_allocate_evt\n- 参数: [struct vhost_scsi *vs, u32 event, u32 reason]\n- 调用者: vhost_scsi_send_evt\n- 被调用者: 未明确显示\n\n3. 函数名: llist_add\n- 参数: [&evt->list, &vs->vs_event_list]\n- 调用者: vhost_scsi_send_evt\n- 被调用者: 未明确显示\n\n4. 函数名: vhost_work_queue\n- 参数: [&vs->dev, &vs->vs_event_work]\n- 调用者: vhost_scsi_send_evt\n- 被调用者: 未明确显示"
  },
  {
    "id": 772,
    "cwe": "CWE-119",
    "cve": "CVE-2015-5156",
    "purpose": "Code purpose:\"\"\"该代码实现了virtio网络设备的探测和初始化功能，包括设备特性验证、网络设备分配、队列设置、特性协商和缓冲区管理等，用于支持虚拟化环境中的网络通信。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"virtnet_probe函数在支持FRAGLIST特性时未正确分配内存，导致恶意构造的分片数据包可能引发缓冲区溢出和内存破坏\"\"\"",
    "functions": "Functions:\n1. 函数名: virtnet_probe\n- 参数: [struct virtio_device *vdev]\n- 调用者: 内核驱动框架\n- 被调用者: [virtnet_validate_features, virtio_cread_feature, virtio_has_feature, alloc_etherdev_mq, eth_hw_addr_random, netdev_priv, alloc_percpu, per_cpu_ptr, u64_stats_init, INIT_WORK, init_vqs, register_netdev, virtio_device_ready, try_fill_recv, virtqueue_get_vring_size, free_unused_bufs, register_hotcpu_notifier, schedule_work, free_receive_bufs, unregister_netdev, cancel_delayed_work_sync, free_receive_page_frags, virtnet_del_vqs, free_percpu, free_netdev]\n\n2. 函数名: virtnet_validate_features\n- 参数: [struct virtio_device *vdev]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n3. 函数名: virtio_cread_feature\n- 参数: [struct virtio_device *vdev, unsigned int fbit, struct virtio_net_config, max_virtqueue_pairs, u16 *val]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n4. 函数名: virtio_has_feature\n- 参数: [struct virtio_device *vdev, unsigned int fbit]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n5. 函数名: alloc_etherdev_mq\n- 参数: [int sizeof_priv, unsigned int queue_count]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n6. 函数名: eth_hw_addr_random\n- 参数: [struct net_device *dev]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n7. 函数名: netdev_priv\n- 参数: [const struct net_device *dev]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n8. 函数名: alloc_percpu\n- 参数: [type]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n9. 函数名: per_cpu_ptr\n- 参数: [const void *ptr, int cpu]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n10. 函数名: u64_stats_init\n- 参数: [struct u64_stats_sync *syncp]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n11. 函数名: INIT_WORK\n- 参数: [struct work_struct *work, work_func_t func]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n12. 函数名: init_vqs\n- 参数: [struct virtnet_info *vi]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n13. 函数名: register_netdev\n- 参数: [struct net_device *dev]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n14. 函数名: virtio_device_ready\n- 参数: [struct virtio_device *dev]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n15. 函数名: try_fill_recv\n- 参数: [struct virtnet_info *vi, struct receive_queue *rq, gfp_t gfp]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n16. 函数名: virtqueue_get_vring_size\n- 参数: [struct virtqueue *vq]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n17. 函数名: free_unused_bufs\n- 参数: [struct virtnet_info *vi]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n18. 函数名: register_hotcpu_notifier\n- 参数: [struct notifier_block *nb]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n19. 函数名: schedule_work\n- 参数: [struct work_struct *work]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n20. 函数名: free_receive_bufs\n- 参数: [struct virtnet_info *vi]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n21. 函数名: unregister_netdev\n- 参数: [struct net_device *dev]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n22. 函数名: cancel_delayed_work_sync\n- 参数: [struct delayed_work *work]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n23. 函数名: free_receive_page_frags\n- 参数: [struct virtnet_info *vi]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n24. 函数名: virtnet_del_vqs\n- 参数: [struct virtnet_info *vi]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n25. 函数名: free_percpu\n- 参数: [void *__pdata]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n26. 函数名: free_netdev\n- 参数: [struct net_device *dev]\n- 调用者: virtnet_probe\n- 被调用者: []"
  },
  {
    "id": 773,
    "cwe": "CWE-119",
    "cve": "CVE-2015-5283",
    "purpose": "Code purpose:\"\"\"初始化SCTP协议栈，包括分配内存、创建哈希表、设置系统参数等，以支持SCTP套接字通信功能\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"SCTP协议初始化步骤顺序不正确，在未完成所有初始化步骤前就允许创建SCTP套接字，导致本地用户可能引发拒绝服务\"\"\"",
    "functions": "Functions:\n1. 函数名: sctp_init\n- 参数: [void]\n- 调用者: 内核初始化\n- 被调用者: [kmem_cache_create, percpu_counter_init, idr_init, max, min, sysctl_sctp_register, INIT_LIST_HEAD, sctp_v4_pf_init, sctp_v6_pf_init, sctp_v4_protosw_init, sctp_v6_protosw_init, register_pernet_subsys, sctp_v4_add_protocol, sctp_v6_add_protocol, sctp_v4_del_protocol, unregister_pernet_subsys, sctp_v6_protosw_exit, sctp_v4_protosw_exit, sctp_v4_pf_exit, sctp_v6_pf_exit, sctp_sysctl_unregister, free_pages, kfree, percpu_counter_destroy, kmem_cache_destroy]\n\n2. 函数名: kmem_cache_create\n- 参数: [\"sctp_bind_bucket\", sizeof(struct sctp_bind_bucket), 0, SLAB_HWCACHE_ALIGN, NULL]\n- 调用者: sctp_init\n- 被调用者: []\n\n3. 函数名: percpu_counter_init\n- 参数: [&sctp_sockets_allocated, 0, GFP_KERNEL]\n- 调用者: sctp_init\n- 被调用者: []\n\n4. 函数名: idr_init\n- 参数: [&sctp_assocs_id]\n- 调用者: sctp_init\n- 被调用者: []\n\n5. 函数名: max\n- 参数: [limit, 128UL]\n- 调用者: sctp_init\n- 被调用者: []\n\n6. 函数名: min\n- 参数: [4UL*1024*1024, limit]\n- 调用者: sctp_init\n- 被调用者: []\n\n7. 函数名: sysctl_sctp_register\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n8. 函数名: INIT_LIST_HEAD\n- 参数: [&sctp_address_families]\n- 调用者: sctp_init\n- 被调用者: []\n\n9. 函数名: sctp_v4_pf_init\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n10. 函数名: sctp_v6_pf_init\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n11. 函数名: sctp_v4_protosw_init\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n12. 函数名: sctp_v6_protosw_init\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n13. 函数名: register_pernet_subsys\n- 参数: [&sctp_net_ops]\n- 调用者: sctp_init\n- 被调用者: []\n\n14. 函数名: sctp_v4_add_protocol\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n15. 函数名: sctp_v6_add_protocol\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n16. 函数名: sctp_v4_del_protocol\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n17. 函数名: unregister_pernet_subsys\n- 参数: [&sctp_net_ops]\n- 调用者: sctp_init\n- 被调用者: []\n\n18. 函数名: sctp_v6_protosw_exit\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n19. 函数名: sctp_v4_protosw_exit\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n20. 函数名: sctp_v4_pf_exit\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n21. 函数名: sctp_v6_pf_exit\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n22. 函数名: sctp_sysctl_unregister\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n23. 函数名: free_pages\n- 参数: [(unsigned long)sctp_port_hashtable, get_order(sctp_port_hashsize * sizeof(struct sctp_bind_hashbucket))]\n- 调用者: sctp_init\n- 被调用者: []\n\n24. 函数名: kfree\n- 参数: [sctp_ep_hashtable]\n- 调用者: sctp_init\n- 被调用者: []\n\n25. 函数名: percpu_counter_destroy\n- 参数: [&sctp_sockets_allocated]\n- 调用者: sctp_init\n- 被调用者: []\n\n26. 函数名: kmem_cache_destroy\n- 参数: [sctp_chunk_cachep]\n- 调用者: sctp_init\n- 被调用者: []"
  },
  {
    "id": 774,
    "cwe": "CWE-119",
    "cve": "CVE-2015-5283",
    "purpose": "Code purpose:\"\"\"该代码片段实现了SCTP协议栈的退出清理功能，包括注销协议处理、释放内存资源和销毁缓存等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"SCTP协议初始化步骤顺序不正确，导致在初始化完成前创建SCTP套接字可能引发拒绝服务\"\"\"",
    "functions": "Functions:\n1. 函数名: sctp_exit\n- 参数: [void]\n- 调用者: 无（静态函数，__exit修饰）\n- 被调用者: [sctp_v6_del_protocol, sctp_v4_del_protocol, unregister_pernet_subsys, sctp_v6_protosw_exit, sctp_v4_protosw_exit, sctp_v6_pf_exit, sctp_v4_pf_exit, sctp_sysctl_unregister, free_pages, get_order, kfree, percpu_counter_destroy, rcu_barrier, kmem_cache_destroy]\n\n2. 函数名: sctp_v6_del_protocol\n- 参数: []\n- 调用者: sctp_exit\n- 被调用者: []\n\n3. 函数名: sctp_v4_del_protocol\n- 参数: []\n- 调用者: sctp_exit\n- 被调用者: []\n\n4. 函数名: unregister_pernet_subsys\n- 参数: [&sctp_net_ops]\n- 调用者: sctp_exit\n- 被调用者: []\n\n5. 函数名: sctp_v6_protosw_exit\n- 参数: []\n- 调用者: sctp_exit\n- 被调用者: []\n\n6. 函数名: sctp_v4_protosw_exit\n- 参数: []\n- 调用者: sctp_exit\n- 被调用者: []\n\n7. 函数名: sctp_v6_pf_exit\n- 参数: []\n- 调用者: sctp_exit\n- 被调用者: []\n\n8. 函数名: sctp_v4_pf_exit\n- 参数: []\n- 调用者: sctp_exit\n- 被调用者: []\n\n9. 函数名: sctp_sysctl_unregister\n- 参数: []\n- 调用者: sctp_exit\n- 被调用者: []\n\n10. 函数名: free_pages\n- 参数: [(unsigned long)sctp_assoc_hashtable, get_order(...)]\n- 调用者: sctp_exit\n- 被调用者: []\n\n11. 函数名: get_order\n- 参数: [sctp_assoc_hashsize * sizeof(struct sctp_hashbucket)]\n- 调用者: sctp_exit\n- 被调用者: []\n\n12. 函数名: kfree\n- 参数: [sctp_ep_hashtable]\n- 调用者: sctp_exit\n- 被调用者: []\n\n13. 函数名: free_pages\n- 参数: [(unsigned long)sctp_port_hashtable, get_order(...)]\n- 调用者: sctp_exit\n- 被调用者: []\n\n14. 函数名: get_order\n- 参数: [sctp_port_hashsize * sizeof(struct sctp_bind_hashbucket)]\n- 调用者: sctp_exit\n- 被调用者: []\n\n15. 函数名: percpu_counter_destroy\n- 参数: [&sctp_sockets_allocated]\n- 调用者: sctp_exit\n- 被调用者: []\n\n16. 函数名: rcu_barrier\n- 参数: []\n- 调用者: sctp_exit\n- 被调用者: []\n\n17. 函数名: kmem_cache_destroy\n- 参数: [sctp_chunk_cachep]\n- 调用者: sctp_exit\n- 被调用者: []\n\n18. 函数名: kmem_cache_destroy\n- 参数: [sctp_bucket_cachep]\n- 调用者: sctp_exit\n- 被调用者: []"
  },
  {
    "id": 897,
    "cwe": "CWE-119",
    "cve": "CVE-2016-10154",
    "purpose": "Code purpose:\"\"\"该代码片段实现了SMB协议中的密码哈希加密功能，使用DES算法对输入数据进行加密处理。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，smbhash函数使用的scatterlist可能跨越多个虚拟页面，导致系统崩溃或内存损坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: smbhash\n- 参数: [out, in, key]\n- 调用者: 未指定\n- 被调用者: [str_to_key, crypto_alloc_skcipher, skcipher_request_alloc, crypto_skcipher_setkey, sg_init_one, skcipher_request_set_callback, skcipher_request_set_crypt, crypto_skcipher_encrypt, skcipher_request_free, crypto_free_skcipher]\n\n2. 函数名: str_to_key\n- 参数: [key, key2]\n- 调用者: smbhash\n- 被调用者: 未指定\n\n3. 函数名: crypto_alloc_skcipher\n- 参数: [\"ecb(des)\", 0, CRYPTO_ALG_ASYNC]\n- 调用者: smbhash\n- 被调用者: 未指定\n\n4. 函数名: skcipher_request_alloc\n- 参数: [tfm_des, GFP_KERNEL]\n- 调用者: smbhash\n- 被调用者: 未指定\n\n5. 函数名: crypto_skcipher_setkey\n- 参数: [tfm_des, key2, 8]\n- 调用者: smbhash\n- 被调用者: 未指定\n\n6. 函数名: sg_init_one\n- 参数: [&sgin, in, 8]\n- 调用者: smbhash\n- 被调用者: 未指定\n\n7. 函数名: sg_init_one\n- 参数: [&sgout, out, 8]\n- 调用者: smbhash\n- 被调用者: 未指定\n\n8. 函数名: skcipher_request_set_callback\n- 参数: [req, 0, NULL, NULL]\n- 调用者: smbhash\n- 被调用者: 未指定\n\n9. 函数名: skcipher_request_set_crypt\n- 参数: [req, &sgin, &sgout, 8, NULL]\n- 调用者: smbhash\n- 被调用者: 未指定\n\n10. 函数名: crypto_skcipher_encrypt\n- 参数: [req]\n- 调用者: smbhash\n- 被调用者: 未指定\n\n11. 函数名: skcipher_request_free\n- 参数: [req]\n- 调用者: smbhash\n- 被调用者: 未指定\n\n12. 函数名: crypto_free_skcipher\n- 参数: [tfm_des]\n- 调用者: smbhash\n- 被调用者: 未指定"
  },
  {
    "id": 906,
    "cwe": "CWE-119",
    "cve": "CVE-2016-10764",
    "purpose": "Code purpose:\"\"\"该代码用于设置和管理SPI NOR闪存设备，包括初始化闪存参数、注册MTD设备以及处理芯片选择逻辑。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"数组索引越界漏洞，由于使用'>'而不是'>='来检查芯片选择值，导致可以访问超出数组边界的一个元素\"\"\"",
    "functions": "Functions:\n1. 函数名: cqspi_setup_flash\n- 参数: [struct cqspi_st *cqspi, struct device_node *np]\n- 调用者: 未显示（外部调用）\n- 被调用者: [of_property_read_u32, dev_err, cqspi_of_get_flash_pdata, spi_nor_set_flash_node, devm_kasprintf, spi_nor_scan, mtd_device_register, mtd_device_unregister]\n\n2. 函数名: of_property_read_u32\n- 参数: [struct device_node *np, const char *propname, u32 *out_value]\n- 调用者: cqspi_setup_flash\n- 被调用者: 未显示（内核API）\n\n3. 函数名: dev_err\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: cqspi_setup_flash\n- 被调用者: 未显示（内核API）\n\n4. 函数名: cqspi_of_get_flash_pdata\n- 参数: [struct platform_device *pdev, struct cqspi_flash_pdata *f_pdata, struct device_node *np]\n- 调用者: cqspi_setup_flash\n- 被调用者: 未显示（外部函数）\n\n5. 函数名: spi_nor_set_flash_node\n- 参数: [struct spi_nor *nor, struct device_node *np]\n- 调用者: cqspi_setup_flash\n- 被调用者: 未显示（外部函数）\n\n6. 函数名: devm_kasprintf\n- 参数: [struct device *dev, gfp_t gfp, const char *fmt, ...]\n- 调用者: cqspi_setup_flash\n- 被调用者: 未显示（内核API）\n\n7. 函数名: spi_nor_scan\n- 参数: [struct spi_nor *nor, const char *name, enum spi_nor_protocol proto]\n- 调用者: cqspi_setup_flash\n- 被调用者: 未显示（外部函数）\n\n8. 函数名: mtd_device_register\n- 参数: [struct mtd_info *mtd, const char * const *part_probe_types, struct mtd_part_parser_data *parser_data]\n- 调用者: cqspi_setup_flash\n- 被调用者: 未显示（内核API）\n\n9. 函数名: mtd_device_unregister\n- 参数: [struct mtd_info *master]\n- 调用者: cqspi_setup_flash\n- 被调用者: 未显示（内核API）"
  },
  {
    "id": 914,
    "cwe": "CWE-119",
    "cve": "CVE-2016-1583",
    "purpose": "Code purpose:\"\"\"该代码实现了proc文件系统的挂载功能，包括权限检查、选项解析和超级块初始化等操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确处理/proc路径名的mmap调用导致的递归页面错误处理，可能引发权限提升或拒绝服务\"\"\"",
    "functions": "Functions:\n1. 函数名: proc_mount\n- 参数: [struct file_system_type *fs_type, int flags, const char *dev_name, void *data]\n- 调用者: 未显示（应为文件系统挂载相关调用）\n- 被调用者: [task_active_pid_ns, ns_capable, sget, IS_ERR, ERR_CAST, proc_parse_options, deactivate_locked_super, ERR_PTR, proc_fill_super, dget]\n\n2. 函数名: task_active_pid_ns\n- 参数: [struct task_struct *current]\n- 调用者: proc_mount\n- 被调用者: []\n\n3. 函数名: ns_capable\n- 参数: [struct user_namespace *user_ns, int CAP_SYS_ADMIN]\n- 调用者: proc_mount\n- 被调用者: []\n\n4. 函数名: sget\n- 参数: [struct file_system_type *fs_type, proc_test_super, proc_set_super, int flags, struct pid_namespace *ns]\n- 调用者: proc_mount\n- 被调用者: []\n\n5. 函数名: IS_ERR\n- 参数: [struct super_block *sb]\n- 调用者: proc_mount\n- 被调用者: []\n\n6. 函数名: ERR_CAST\n- 参数: [struct super_block *sb]\n- 调用者: proc_mount\n- 被调用者: []\n\n7. 函数名: proc_parse_options\n- 参数: [char *options, struct pid_namespace *ns]\n- 调用者: proc_mount\n- 被调用者: []\n\n8. 函数名: deactivate_locked_super\n- 参数: [struct super_block *sb]\n- 调用者: proc_mount\n- 被调用者: []\n\n9. 函数名: ERR_PTR\n- 参数: [int err]\n- 调用者: proc_mount\n- 被调用者: []\n\n10. 函数名: proc_fill_super\n- 参数: [struct super_block *sb]\n- 调用者: proc_mount\n- 被调用者: []\n\n11. 函数名: dget\n- 参数: [struct dentry *sb->s_root]\n- 调用者: proc_mount\n- 被调用者: []"
  },
  {
    "id": 962,
    "cwe": "CWE-119",
    "cve": "CVE-2016-3134",
    "purpose": "Code purpose:\"\"\"验证和设置netfilter子系统中的ARP表条目，包括检查偏移量、钩子位置和下溢条件，以确保内存安全和规则有效性\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统未充分验证arpt_entry结构中的next_offset字段，导致可通过IPT_SO_SET_REPLACE setsockopt调用触发堆内存破坏\"\"\"",
    "functions": "Functions:\n1. 函数名: check_entry_size_and_hooks\n- 参数: [struct arpt_entry *e, struct xt_table_info *newinfo, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, unsigned int valid_hooks]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [check_entry, check_underflow]\n\n2. 函数名: check_entry\n- 参数: [struct arpt_entry *e]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: 未显示\n\n3. 函数名: check_underflow\n- 参数: [struct arpt_entry *e]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: 未显示"
  },
  {
    "id": 963,
    "cwe": "CWE-119",
    "cve": "CVE-2016-3134",
    "purpose": "Code purpose:\"\"\"检查ARP表条目是否会导致下溢，防止内存损坏\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统中未对偏移量字段进行充分验证，导致通过IPT_SO_SET_REPLACE setsockopt调用可造成堆内存破坏\"\"\"",
    "functions": "Functions:\n1. 函数名: check_underflow\n- 参数: [const struct arpt_entry *e]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [unconditional, arpt_get_target_c, strcmp]\n\n2. 函数名: unconditional\n- 参数: [const struct arpt_entry *e]\n- 调用者: check_underflow\n- 被调用者: []\n\n3. 函数名: arpt_get_target_c\n- 参数: [const struct arpt_entry *e]\n- 调用者: check_underflow\n- 被调用者: []\n\n4. 函数名: strcmp\n- 参数: [const char *s1, const char *s2]\n- 调用者: check_underflow\n- 被调用者: []"
  },
  {
    "id": 964,
    "cwe": "CWE-119",
    "cve": "CVE-2016-3134",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的netfilter子系统中标记ARP表规则链的源路径，处理规则跳转和回溯，但未充分验证偏移字段导致安全漏洞\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统中未对某些偏移字段进行充分验证，导致通过IPT_SO_SET_REPLACE setsockopt调用可造成堆内存破坏\"\"\"",
    "functions": "Functions:\n1. 函数名: mark_source_chains\n- 参数: [const struct xt_table_info *newinfo, unsigned int valid_hooks, void *entry0]\n- 调用者: 未明确（由内核调用）\n- 被调用者: [arpt_get_target_c, unconditional, strcmp, duprintf, pr_notice]\n\n2. 函数名: arpt_get_target_c\n- 参数: [struct arpt_entry *e]\n- 调用者: mark_source_chains\n- 被调用者: 未明确\n\n3. 函数名: unconditional\n- 参数: [struct arpt_entry *e]\n- 调用者: mark_source_chains\n- 被调用者: 未明确\n\n4. 函数名: strcmp\n- 参数: [const char *s1, const char *s2]\n- 调用者: mark_source_chains\n- 被调用者: 未明确\n\n5. 函数名: duprintf\n- 参数: [const char *format, ...]\n- 调用者: mark_source_chains\n- 被调用者: 未明确\n\n6. 函数名: pr_notice\n- 参数: [const char *format, ...]\n- 调用者: mark_source_chains\n- 被调用者: 未明确"
  },
  {
    "id": 965,
    "cwe": "CWE-119",
    "cve": "CVE-2016-3134",
    "purpose": "Code purpose:\"\"\"验证ipt_entry结构体的偏移量和钩子设置，防止内存越界和非法访问\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统中未充分验证ipt_entry结构体的next_offset字段，导致可通过IPT_SO_SET_REPLACE setsockopt调用触发堆内存破坏\"\"\"",
    "functions": "Functions:\n1. 函数名: check_entry_size_and_hooks\n- 参数: [struct ipt_entry *e, struct xt_table_info *newinfo, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, unsigned int valid_hooks]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [check_entry, check_underflow]\n\n2. 函数名: check_entry\n- 参数: [struct ipt_entry *e]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: 未显示\n\n3. 函数名: check_underflow\n- 参数: [struct ipt_entry *e]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: 未显示"
  },
  {
    "id": 966,
    "cwe": "CWE-119",
    "cve": "CVE-2016-3134",
    "purpose": "Code purpose:\"\"\"该代码用于处理iptables规则链中的链名和规则编号，并在特定条件下设置注释信息。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统未验证某些偏移字段，导致通过IPT_SO_SET_REPLACE setsockopt调用可造成堆内存破坏\"\"\"",
    "functions": "Functions:\n1. 函数名: get_chainname_rulenum\n- 参数: [const struct ipt_entry *s, const struct ipt_entry *e, const char *hookname, const char **chainname, const char **comment, unsigned int *rulenum]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [ipt_get_target_c, strcmp, unconditional]\n\n2. 函数名: ipt_get_target_c\n- 参数: [const struct ipt_entry *s]\n- 调用者: get_chainname_rulenum\n- 被调用者: 未显示\n\n3. 函数名: strcmp\n- 参数: [const char *s1, const char *s2]\n- 调用者: get_chainname_rulenum\n- 被调用者: 未显示\n\n4. 函数名: unconditional\n- 参数: [const struct ipt_entry *s]\n- 调用者: get_chainname_rulenum\n- 被调用者: 未显示"
  },
  {
    "id": 967,
    "cwe": "CWE-119",
    "cve": "CVE-2016-3134",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的netfilter子系统中标记和验证iptables规则链的源跳转关系，防止规则循环并确保跳转目标的有效性。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统中未对某些偏移字段进行充分验证，导致通过IPT_SO_SET_REPLACE setsockopt调用可造成堆内存破坏\"\"\"",
    "functions": "Functions:\n1. 函数名: mark_source_chains\n- 参数: [const struct xt_table_info *newinfo, unsigned int valid_hooks, void *entry0]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [ipt_get_target_c, unconditional, strcmp, duprintf, pr_err]\n\n2. 函数名: ipt_get_target_c\n- 参数: [struct ipt_entry *e]\n- 调用者: mark_source_chains\n- 被调用者: 未显示\n\n3. 函数名: unconditional\n- 参数: [struct ipt_entry *e]\n- 调用者: mark_source_chains\n- 被调用者: 未显示\n\n4. 函数名: strcmp\n- 参数: [const char *s1, const char *s2]\n- 调用者: mark_source_chains\n- 被调用者: 未显示\n\n5. 函数名: duprintf\n- 参数: [const char *format, ...]\n- 调用者: mark_source_chains\n- 被调用者: 未显示\n\n6. 函数名: pr_err\n- 参数: [const char *format, ...]\n- 调用者: mark_source_chains\n- 被调用者: 未显示"
  },
  {
    "id": 968,
    "cwe": "CWE-119",
    "cve": "CVE-2016-3134",
    "purpose": "Code purpose:\"\"\"检查iptables规则条目是否会导致下溢，防止内存损坏\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统中未对偏移量字段进行充分验证，导致通过IPT_SO_SET_REPLACE setsockopt调用可造成堆内存破坏\"\"\"",
    "functions": "Functions:\n1. 函数名: check_underflow\n- 参数: [const struct ipt_entry *e]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [unconditional, ipt_get_target_c, strcmp]\n\n2. 函数名: unconditional\n- 参数: [const struct ipt_entry *e]\n- 调用者: check_underflow\n- 被调用者: []\n\n3. 函数名: ipt_get_target_c\n- 参数: [const struct ipt_entry *e]\n- 调用者: check_underflow\n- 被调用者: []\n\n4. 函数名: strcmp\n- 参数: [const char *s1, const char *s2]\n- 调用者: check_underflow\n- 被调用者: []"
  },
  {
    "id": 969,
    "cwe": "CWE-119",
    "cve": "CVE-2016-3134",
    "purpose": "Code purpose:\"\"\"该代码用于处理IPv6防火墙规则链中的链名和规则编号，并检查特定目标类型以确定链的头部或尾部\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统未验证某些偏移字段，导致通过IPT_SO_SET_REPLACE setsockopt调用可造成堆内存破坏\"\"\"",
    "functions": "Functions:\n1. 函数名: get_chainname_rulenum\n- 参数: [const struct ip6t_entry *s, const struct ip6t_entry *e, const char *hookname, const char **chainname, const char **comment, unsigned int *rulenum]\n- 调用者: 未显示\n- 被调用者: [ip6t_get_target_c, strcmp, unconditional]\n\n2. 函数名: ip6t_get_target_c\n- 参数: [const struct ip6t_entry *s]\n- 调用者: get_chainname_rulenum\n- 被调用者: 未显示\n\n3. 函数名: strcmp\n- 参数: [const char *str1, const char *str2]\n- 调用者: get_chainname_rulenum\n- 被调用者: 未显示\n\n4. 函数名: unconditional\n- 参数: [const struct ip6t_entry *s]\n- 调用者: get_chainname_rulenum\n- 被调用者: 未显示"
  },
  {
    "id": 970,
    "cwe": "CWE-119",
    "cve": "CVE-2016-3134",
    "purpose": "Code purpose:\"\"\"检查IPv6数据包是否满足无条件规则并验证目标裁决是否为NF_DROP或NF_ACCEPT\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统中未对偏移字段进行充分验证，导致通过IPT_SO_SET_REPLACE setsockopt调用可造成堆内存破坏\"\"\"",
    "functions": "Functions:\n1. 函数名: check_underflow\n- 参数: [const struct ip6t_entry *e]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [unconditional, ip6t_get_target_c, strcmp]\n\n2. 函数名: unconditional\n- 参数: [const struct ip6t_entry *e]\n- 调用者: check_underflow\n- 被调用者: []\n\n3. 函数名: ip6t_get_target_c\n- 参数: [const struct ip6t_entry *e]\n- 调用者: check_underflow\n- 被调用者: []\n\n4. 函数名: strcmp\n- 参数: [const char *s1, const char *s2]\n- 调用者: check_underflow\n- 被调用者: []"
  },
  {
    "id": 971,
    "cwe": "CWE-119",
    "cve": "CVE-2016-3134",
    "purpose": "Code purpose:\"\"\"验证IP6表条目的大小和钩子位置，防止内存越界和无效偏移\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统中未充分验证IP6t_entry结构体的next_offset字段，导致可通过精心构造的IPT_SO_SET_REPLACE setsockopt调用触发堆内存破坏\"\"\"",
    "functions": "Functions:\n1. 函数名: check_entry_size_and_hooks\n- 参数: [struct ip6t_entry *e, struct xt_table_info *newinfo, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, unsigned int valid_hooks]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [check_entry, check_underflow]\n\n2. 函数名: check_entry\n- 参数: [struct ip6t_entry *e]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: 未显示\n\n3. 函数名: check_underflow\n- 参数: [struct ip6t_entry *e]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: 未显示"
  },
  {
    "id": 972,
    "cwe": "CWE-119",
    "cve": "CVE-2016-3134",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的netfilter子系统中标记和验证iptables规则链的源路径，防止规则循环并确保规则跳转的有效性。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统中未正确验证偏移字段，导致通过IPT_SO_SET_REPLACE setsockopt调用可造成堆内存破坏\"\"\"",
    "functions": "Functions:\n1. 函数名: mark_source_chains\n- 参数: [const struct xt_table_info *newinfo, unsigned int valid_hooks, void *entry0]\n- 调用者: 未显示（由内核调用）\n- 被调用者: [ip6t_get_target_c, strcmp, unconditional, duprintf, pr_err]\n\n2. 函数名: ip6t_get_target_c\n- 参数: [struct ip6t_entry *e]\n- 调用者: mark_source_chains\n- 被调用者: 未显示\n\n3. 函数名: strcmp\n- 参数: [const char *s1, const char *s2]\n- 调用者: mark_source_chains\n- 被调用者: 未显示\n\n4. 函数名: unconditional\n- 参数: [struct ip6t_entry *e]\n- 调用者: mark_source_chains\n- 被调用者: 未显示\n\n5. 函数名: duprintf\n- 参数: [const char *format, ...]\n- 调用者: mark_source_chains\n- 被调用者: 未显示\n\n6. 函数名: pr_err\n- 参数: [const char *format, ...]\n- 调用者: mark_source_chains\n- 被调用者: 未显示"
  },
  {
    "id": 1013,
    "cwe": "CWE-119",
    "cve": "CVE-2016-3955",
    "purpose": "Code purpose:\"\"\"该代码用于在USB/IP协议中接收传输缓冲区数据，根据传输方向验证并处理接收到的数据长度\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证USB/IP数据包中的长度字段，导致可能发生越界写入漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: usbip_recv_xbuff\n- 参数: [struct usbip_device *ud, struct urb *urb]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [usb_pipein, usb_pipeout, usbip_recv, dev_err, usbip_event_add]\n\n2. 函数名: usb_pipein\n- 参数: [urb->pipe]\n- 调用者: usbip_recv_xbuff\n- 被调用者: []\n\n3. 函数名: usb_pipeout\n- 参数: [urb->pipe]\n- 调用者: usbip_recv_xbuff\n- 被调用者: []\n\n4. 函数名: usbip_recv\n- 参数: [ud->tcp_socket, urb->transfer_buffer, size]\n- 调用者: usbip_recv_xbuff\n- 被调用者: []\n\n5. 函数名: dev_err\n- 参数: [&urb->dev->dev, \"recv xbuf, %d\\n\", ret]\n- 调用者: usbip_recv_xbuff\n- 被调用者: []\n\n6. 函数名: usbip_event_add\n- 参数: [ud, SDEV_EVENT_ERROR_TCP] 或 [ud, VDEV_EVENT_ERROR_TCP]\n- 调用者: usbip_recv_xbuff\n- 被调用者: []"
  },
  {
    "id": 1045,
    "cwe": "CWE-119",
    "cve": "CVE-2016-4998",
    "purpose": "Code purpose:\"\"\"检查兼容性ARP表条目的大小和钩子函数，确保其符合规范并正确设置相关偏移量和目标信息\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"内核在处理IPT_SO_SET_REPLACE套接字选项时，未充分验证用户提供的偏移量，导致可以越界读取内核堆内存数据。\"\"\"",
    "functions": "Functions:\n1. 函数名: check_compat_entry_size_and_hooks\n- 参数: [struct compat_arpt_entry *e, struct xt_table_info *newinfo, unsigned int *size, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, const char *name]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [duprintf, arp_checkentry, xt_compat_check_entry_offsets, compat_arpt_get_target, xt_request_find_target, xt_compat_target_offset, xt_compat_add_offset, module_put]\n\n2. 函数名: duprintf\n- 参数: [const char *format, ...]\n- 调用者: [check_compat_entry_size_and_hooks]\n- 被调用者: []\n\n3. 函数名: arp_checkentry\n- 参数: [struct arpt_arp *arp]\n- 调用者: [check_compat_entry_size_and_hooks]\n- 被调用者: []\n\n4. 函数名: xt_compat_check_entry_offsets\n- 参数: [struct compat_arpt_entry *e, unsigned int target_offset, unsigned int next_offset]\n- 调用者: [check_compat_entry_size_and_hooks]\n- 被调用者: []\n\n5. 函数名: compat_arpt_get_target\n- 参数: [struct compat_arpt_entry *e]\n- 调用者: [check_compat_entry_size_and_hooks]\n- 被调用者: []\n\n6. 函数名: xt_request_find_target\n- 参数: [NFPROTO_ARP, const char *name, u8 revision]\n- 调用者: [check_compat_entry_size_and_hooks]\n- 被调用者: []\n\n7. 函数名: xt_compat_target_offset\n- 参数: [struct xt_target *target]\n- 调用者: [check_compat_entry_size_and_hooks]\n- 被调用者: []\n\n8. 函数名: xt_compat_add_offset\n- 参数: [NFPROTO_ARP, unsigned int offset, unsigned int delta]\n- 调用者: [check_compat_entry_size_and_hooks]\n- 被调用者: []\n\n9. 函数名: module_put\n- 参数: [struct module *module]\n- 调用者: [check_compat_entry_size_and_hooks]\n- 被调用者: []"
  },
  {
    "id": 1046,
    "cwe": "CWE-119",
    "cve": "CVE-2016-4998",
    "purpose": "Code purpose:\"\"\"检查并验证netfilter规则表条目的大小、偏移量和钩子位置，确保其符合安全边界和有效性要求\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证用户提供的offset值，导致可以越界读取内核堆内存数据\"\"\"",
    "functions": "Functions:\n1. 函数名: check_entry_size_and_hooks\n- 参数: [struct arpt_entry *e, struct xt_table_info *newinfo, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, unsigned int valid_hooks]\n- 调用者: 未明确显示（应为调用IPT_SO_SET_REPLACE的相关函数）\n- 被调用者: [arp_checkentry, xt_check_entry_offsets, check_underflow]\n\n2. 函数名: arp_checkentry\n- 参数: [struct arpt_entry *e]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n3. 函数名: xt_check_entry_offsets\n- 参数: [struct arpt_entry *e, unsigned int target_offset, unsigned int next_offset]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n4. 函数名: check_underflow\n- 参数: [struct arpt_entry *e]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n5. 函数名: duprintf\n- 参数: [const char *format, ...]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n6. 函数名: pr_debug\n- 参数: [const char *format, ...]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []"
  },
  {
    "id": 1047,
    "cwe": "CWE-119",
    "cve": "CVE-2016-4998",
    "purpose": "Code purpose:\"\"\"检查ipt_entry结构体的有效性，包括对齐、边界、偏移量和钩子设置，确保网络过滤规则的合法性和安全性\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证用户提供的offset值，导致可以越界读取内核堆内存数据\"\"\"",
    "functions": "Functions:\n1. 函数名: check_entry_size_and_hooks\n- 参数: [struct ipt_entry *e, struct xt_table_info *newinfo, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, unsigned int valid_hooks]\n- 调用者: 未明确（由内核调用）\n- 被调用者: [duprintf, ip_checkentry, xt_check_entry_offsets, check_underflow, pr_debug]\n\n2. 函数名: duprintf\n- 参数: [const char *format, ...]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n3. 函数名: ip_checkentry\n- 参数: [struct ipt_entry *e]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n4. 函数名: xt_check_entry_offsets\n- 参数: [struct ipt_entry *e, unsigned int target_offset, unsigned int next_offset]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n5. 函数名: check_underflow\n- 参数: [struct ipt_entry *e]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n6. 函数名: pr_debug\n- 参数: [const char *format, ...]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []"
  },
  {
    "id": 1048,
    "cwe": "CWE-119",
    "cve": "CVE-2016-4998",
    "purpose": "Code purpose:\"\"\"检查兼容性iptables规则条目的尺寸和钩子位置，确保其不越界且符合格式要求\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理兼容性iptables规则时，未能充分验证用户提供的offset值，导致可以越界读取内核堆内存\"\"\"",
    "functions": "Functions:\n1. 函数名: check_compat_entry_size_and_hooks\n- 参数: [struct compat_ipt_entry *e, struct xt_table_info *newinfo, unsigned int *size, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, const char *name]\n- 调用者: 未明确显示（由内核调用）\n- 被调用者: [duprintf, ip_checkentry, xt_compat_check_entry_offsets, xt_ematch_foreach, compat_find_calc_match, compat_ipt_get_target, xt_request_find_target, xt_compat_target_offset, xt_compat_add_offset, module_put, memset]\n\n2. 函数名: duprintf\n- 参数: [const char *format, ...]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n3. 函数名: ip_checkentry\n- 参数: [struct compat_ipt_entry *e]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n4. 函数名: xt_compat_check_entry_offsets\n- 参数: [struct compat_ipt_entry *e, unsigned int target_offset, unsigned int next_offset]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n5. 函数名: xt_ematch_foreach\n- 参数: [struct xt_entry_match *ematch, struct compat_ipt_entry *e]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n6. 函数名: compat_find_calc_match\n- 参数: [struct xt_entry_match *ematch, const char *name, struct compat_ipt_entry *e, int *off]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n7. 函数名: compat_ipt_get_target\n- 参数: [struct compat_ipt_entry *e]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n8. 函数名: xt_request_find_target\n- 参数: [NFPROTO_IPV4, const char *name, unsigned int revision]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n9. 函数名: xt_compat_target_offset\n- 参数: [struct xt_target *target]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n10. 函数名: xt_compat_add_offset\n- 参数: [AF_INET, unsigned int entry_offset, unsigned int off]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n11. 函数名: module_put\n- 参数: [struct module *module]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n12. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []"
  },
  {
    "id": 1049,
    "cwe": "CWE-119",
    "cve": "CVE-2016-4998",
    "purpose": "Code purpose:\"\"\"检查IP6表条目的大小和钩子位置的有效性，防止越界访问和无效配置\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证用户提供的offset值，导致可以越界读取内核堆内存数据\"\"\"",
    "functions": "Functions:\n1. 函数名: check_entry_size_and_hooks\n- 参数: [struct ip6t_entry *e, struct xt_table_info *newinfo, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, unsigned int valid_hooks]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [ip6_checkentry, xt_check_entry_offsets, check_underflow]\n\n2. 函数名: ip6_checkentry\n- 参数: [struct ip6t_ip6 *]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n3. 函数名: xt_check_entry_offsets\n- 参数: [struct ip6t_entry *, unsigned int, unsigned int]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n4. 函数名: check_underflow\n- 参数: [struct ip6t_entry *]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n5. 函数名: duprintf\n- 参数: [const char *, ...]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n6. 函数名: pr_debug\n- 参数: [const char *, ...]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []"
  },
  {
    "id": 1050,
    "cwe": "CWE-119",
    "cve": "CVE-2016-4998",
    "purpose": "Code purpose:\"\"\"该代码用于检查和处理兼容模式的IPv6防火墙规则条目，验证其大小和偏移量，并设置相应的钩子和下溢点，同时防止越界访问。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"内核在处理IPT_SO_SET_REPLACE套接字选项时，未充分验证用户提供的偏移量，导致可以越界读取内核堆内存数据\"\"\"",
    "functions": "Functions:\n1. 函数名: check_compat_entry_size_and_hooks\n- 参数: [struct compat_ip6t_entry *e, struct xt_table_info *newinfo, unsigned int *size, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, const char *name]\n- 调用者: 未明确显示（由外部调用）\n- 被调用者: [ip6_checkentry, xt_compat_check_entry_offsets, xt_ematch_foreach, compat_find_calc_match, compat_ip6t_get_target, xt_request_find_target, xt_compat_target_offset, xt_compat_add_offset, module_put, memset]\n\n2. 函数名: ip6_checkentry\n- 参数: [struct ip6t_ip6 *]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n3. 函数名: xt_compat_check_entry_offsets\n- 参数: [struct compat_ip6t_entry *, unsigned int, unsigned int]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n4. 函数名: xt_ematch_foreach\n- 参数: [struct xt_entry_match *, struct compat_ip6t_entry *]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n5. 函数名: compat_find_calc_match\n- 参数: [struct xt_entry_match *, const char *, struct ip6t_ip6 *, int *]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n6. 函数名: compat_ip6t_get_target\n- 参数: [struct compat_ip6t_entry *]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n7. 函数名: xt_request_find_target\n- 参数: [NFPROTO_IPV6, char *, unsigned int]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n8. 函数名: xt_compat_target_offset\n- 参数: [struct xt_target *]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n9. 函数名: xt_compat_add_offset\n- 参数: [AF_INET6, unsigned int, unsigned int]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n10. 函数名: module_put\n- 参数: [struct module *]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n11. 函数名: memset\n- 参数: [void *, int, size_t]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []"
  },
  {
    "id": 1055,
    "cwe": "CWE-119",
    "cve": "CVE-2016-5400",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中airspy USB驱动程序的探测功能，用于初始化设备、注册视频设备和控制处理程序，支持SDR(软件定义无线电)设备的连接和操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在airspy_probe函数中，当video_register_device注册失败时，未正确释放已分配的内存和控制句柄，导致内存泄漏\"\"\"",
    "functions": "Functions:\n1. 函数名: airspy_probe\n- 参数: [struct usb_interface *intf, const struct usb_device_id *id]\n- 调用者: 内核USB子系统\n- 被调用者: [kzalloc, dev_err, mutex_init, spin_lock_init, INIT_LIST_HEAD, interface_to_usbdev, airspy_ctrl_msg, dev_info, vb2_queue_init, video_set_drvdata, v4l2_device_register, v4l2_ctrl_handler_init, v4l2_ctrl_new_std, v4l2_ctrl_auto_cluster, v4l2_ctrl_handler_setup, video_register_device, video_device_node_name, v4l2_ctrl_handler_free, v4l2_device_unregister, kfree]\n\n2. 函数名: airspy_ctrl_msg\n- 参数: [struct airspy *s, CMD_BOARD_ID_READ, 0, 0, &u8tmp, 1] / [struct airspy *s, CMD_VERSION_STRING_READ, 0, 0, buf, BUF_SIZE]\n- 调用者: airspy_probe\n- 被调用者: []\n\n3. 函数名: kzalloc\n- 参数: [sizeof(struct airspy), GFP_KERNEL]\n- 调用者: airspy_probe\n- 被调用者: []\n\n4. 函数名: dev_err\n- 参数: [&intf->dev, \"Could not allocate memory for state\\n\"] / [s->dev, \"Could not detect board\\n\"] / [s->dev, \"Could not initialize vb2 queue\\n\"] / [s->dev, \"Failed to register v4l2-device (%d)\\n\", ret] / [s->dev, \"Could not initialize controls\\n\"] / [s->dev, \"Failed to register as video device (%d)\\n\", ret]\n- 调用者: airspy_probe\n- 被调用者: []\n\n5. 函数名: mutex_init\n- 参数: [&s->v4l2_lock] / [&s->vb_queue_lock]\n- 调用者: airspy_probe\n- 被调用者: []\n\n6. 函数名: spin_lock_init\n- 参数: [&s->queued_bufs_lock]\n- 调用者: airspy_probe\n- 被调用者: []\n\n7. 函数名: INIT_LIST_HEAD\n- 参数: [&s->queued_bufs]\n- 调用者: airspy_probe\n- 被调用者: []\n\n8. 函数名: interface_to_usbdev\n- 参数: [intf]\n- 调用者: airspy_probe\n- 被调用者: []\n\n9. 函数名: dev_info\n- 参数: [s->dev, \"Board ID: %02x\\n\", u8tmp] / [s->dev, \"Firmware version: %s\\n\", buf] / [s->dev, \"Registered as %s\\n\", video_device_node_name(&s->vdev)]\n- 调用者: airspy_probe\n- 被调用者: []\n\n10. 函数名: vb2_queue_init\n- 参数: [&s->vb_queue]\n- 调用者: airspy_probe\n- 被调用者: []\n\n11. 函数名: video_set_drvdata\n- 参数: [&s->vdev, s]\n- 调用者: airspy_probe\n- 被调用者: []\n\n12. 函数名: v4l2_device_register\n- 参数: [&intf->dev, &s->v4l2_dev]\n- 调用者: airspy_probe\n- 被调用者: []\n\n13. 函数名: v4l2_ctrl_handler_init\n- 参数: [&s->hdl, 5]\n- 调用者: airspy_probe\n- 被调用者: []\n\n14. 函数名: v4l2_ctrl_new_std\n- 参数: [&s->hdl, &airspy_ctrl_ops, V4L2_CID_RF_TUNER_LNA_GAIN_AUTO, 0, 1, 1, 0] / [&s->hdl, &airspy_ctrl_ops, V4L2_CID_RF_TUNER_LNA_GAIN, 0, 14, 1, 8] / [&s->hdl, &airspy_ctrl_ops, V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO, 0, 1, 1, 0] / [&s->hdl, &airspy_ctrl_ops, V4L2_CID_RF_TUNER_MIXER_GAIN, 0, 15, 1, 8] / [&s->hdl, &airspy_ctrl_ops, V4L2_CID_RF_TUNER_IF_GAIN, 0, 15, 1, 0]\n- 调用者: airspy_probe\n- 被调用者: []\n\n15. 函数名: v4l2_ctrl_auto_cluster\n- 参数: [2, &s->lna_gain_auto, 0, false] / [2, &s->mixer_gain_auto, 0, false]\n- 调用者: airspy_probe\n- 被调用者: []\n\n16. 函数名: v4l2_ctrl_handler_setup\n- 参数: [&s->hdl]\n- 调用者: airspy_probe\n- 被调用者: []\n\n17. 函数名: video_register_device\n- 参数: [&s->vdev, VFL_TYPE_SDR, -1]\n- 调用者: airspy_probe\n- 被调用者: []\n\n18. 函数名: video_device_node_name\n- 参数: [&s->vdev]\n- 调用者: airspy_probe\n- 被调用者: []\n\n19. 函数名: v4l2_ctrl_handler_free\n- 参数: [&s->hdl]\n- 调用者: airspy_probe\n- 被调用者: []\n\n20. 函数名: v4l2_device_unregister\n- 参数: [&s->v4l2_dev]\n- 调用者: airspy_probe\n- 被调用者: []\n\n21. 函数名: kfree\n- 参数: [s]\n- 调用者: airspy_probe\n- 被调用者: []"
  },
  {
    "id": 1056,
    "cwe": "CWE-119",
    "cve": "CVE-2016-5728",
    "purpose": "Code purpose:\"\"\"该代码实现了MIC VOP驱动中vop_ioctl函数的功能，用于处理虚拟设备的各种控制命令，包括添加设备、复制描述符和配置更改等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在vop_ioctl函数中存在对用户空间数据的多次读取（double fetch）而没有适当的同步保护，导致竞态条件下可能访问不一致的数据\"\"\"",
    "functions": "Functions:\n1. 函数名: vop_ioctl\n- 参数: [struct file *f, unsigned int cmd, unsigned long arg]\n- 调用者: 内核IOCTL处理机制\n- 被调用者: [copy_from_user, kzalloc, kfree, mutex_lock, mutex_unlock, vop_virtio_add_device, list_add_tail, vop_vdev_inited, vop_virtio_copy_desc, copy_to_user, vop_virtio_config_change]\n\n2. 函数名: mic_aligned_desc_size\n- 参数: [struct mic_device_desc *dd]\n- 调用者: vop_ioctl\n- 被调用者: []\n\n3. 函数名: mic_desc_size\n- 参数: [struct mic_device_desc *dd]\n- 调用者: vop_ioctl\n- 被调用者: []\n\n4. 函数名: vop_virtio_add_device\n- 参数: [struct vop_vdev *vdev, struct mic_device_desc *dd_config]\n- 调用者: vop_ioctl\n- 被调用者: []\n\n5. 函数名: vop_vdev_inited\n- 参数: [struct vop_vdev *vdev]\n- 调用者: vop_ioctl\n- 被调用者: []\n\n6. 函数名: vop_virtio_copy_desc\n- 参数: [struct vop_vdev *vdev, struct mic_copy_desc *copy]\n- 调用者: vop_ioctl\n- 被调用者: []\n\n7. 函数名: vop_virtio_config_change\n- 参数: [struct vop_vdev *vdev, void *buf]\n- 调用者: vop_ioctl\n- 被调用者: []"
  },
  {
    "id": 1058,
    "cwe": "CWE-119",
    "cve": "CVE-2016-5829",
    "purpose": "Code purpose:\"\"\"处理HID设备的用户空间ioctl请求，包括获取和设置HID设备的使用情况数据\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在HIDIOCGUSAGES或HIDIOCSUSAGES ioctl调用中，未充分验证用户提供的uref_multi->num_values参数，导致堆缓冲区溢出漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: hiddev_ioctl_usage\n- 参数: [struct hiddev *hiddev, unsigned int cmd, void __user *user_arg]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [kmalloc, copy_from_user, hiddev_lookup_report, hiddev_lookup_usage, copy_to_user, kfree]\n\n2. 函数名: hiddev_lookup_report\n- 参数: [struct hid_device *hid, struct hiddev_report_info *rinfo]\n- 调用者: hiddev_ioctl_usage\n- 被调用者: 未显示（可能为内核内部函数）\n\n3. 函数名: hiddev_lookup_usage\n- 参数: [struct hid_device *hid, struct hiddev_usage_ref *uref]\n- 调用者: hiddev_ioctl_usage\n- 被调用者: 未显示（可能为内核内部函数）\n\n4. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: hiddev_ioctl_usage\n- 被调用者: 未显示（内核内存分配函数）\n\n5. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: hiddev_ioctl_usage\n- 被调用者: 未显示（内核拷贝函数）\n\n6. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: hiddev_ioctl_usage\n- 被调用者: 未显示（内核拷贝函数）\n\n7. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: hiddev_ioctl_usage\n- 被调用者: 未显示（内核内存释放函数）"
  },
  {
    "id": 1064,
    "cwe": "CWE-119",
    "cve": "CVE-2016-6187",
    "purpose": "Code purpose:\"\"\"该代码用于处理AppArmor安全模块中进程属性的设置，包括权限检查和属性修改，但不正确地处理了缓冲区大小验证，可能导致权限提升漏洞。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"未对用户提供的缓冲区大小进行充分验证，导致可以越界写入空字符\"\"\"",
    "functions": "Functions:\n1. 函数名: apparmor_setprocattr\n- 参数: [struct task_struct *task, char *name, void *value, size_t size]\n- 调用者: 未显示（内核调用）\n- 被调用者: [strim, strsep, skip_spaces, strcmp, aa_setprocattr_changehat, aa_setprocattr_changeprofile, aa_current_profile, aa_audit_msg]\n\n2. 函数名: strim\n- 参数: [char *args]\n- 调用者: apparmor_setprocattr\n- 被调用者: []\n\n3. 函数名: strsep\n- 参数: [char **args, const char *delim]\n- 调用者: apparmor_setprocattr\n- 被调用者: []\n\n4. 函数名: skip_spaces\n- 参数: [char *args]\n- 调用者: apparmor_setprocattr\n- 被调用者: []\n\n5. 函数名: strcmp\n- 参数: [const char *name, const char *command]\n- 调用者: apparmor_setprocattr\n- 被调用者: []\n\n6. 函数名: aa_setprocattr_changehat\n- 参数: [char *args, size_t arg_size, int test]\n- 调用者: apparmor_setprocattr\n- 被调用者: []\n\n7. 函数名: aa_setprocattr_changeprofile\n- 参数: [char *args, int onexec, int test]\n- 调用者: apparmor_setprocattr\n- 被调用者: []\n\n8. 函数名: aa_current_profile\n- 参数: []\n- 调用者: apparmor_setprocattr\n- 被调用者: []\n\n9. 函数名: aa_audit_msg\n- 参数: [int AUDIT_APPARMOR_DENIED, struct common_audit_data *sa, NULL]\n- 调用者: apparmor_setprocattr\n- 被调用者: []"
  },
  {
    "id": 1077,
    "cwe": "CWE-119",
    "cve": "CVE-2016-6516",
    "purpose": "Code purpose:\"\"\"该代码实现了通过ioctl系统调用进行文件去重范围操作的功能，包括从用户空间获取参数、分配内存、执行去重操作并将结果返回用户空间。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对用户空间传入的count值进行锁定或验证，导致在两次获取该值之间可能被恶意修改，造成堆缓冲区溢出漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: ioctl_file_dedupe_range\n- 参数: [file, arg]\n- 调用者: 未明确显示（应为内核IOCTL处理流程）\n- 被调用者: [get_user, memdup_user, vfs_dedupe_file_range, copy_to_user, kfree]\n\n2. 函数名: get_user\n- 参数: [count, &argp->dest_count]\n- 调用者: ioctl_file_dedupe_range\n- 被调用者: []\n\n3. 函数名: memdup_user\n- 参数: [argp, size]\n- 调用者: ioctl_file_dedupe_range\n- 被调用者: []\n\n4. 函数名: vfs_dedupe_file_range\n- 参数: [file, same]\n- 调用者: ioctl_file_dedupe_range\n- 被调用者: []\n\n5. 函数名: copy_to_user\n- 参数: [argp, same, size]\n- 调用者: ioctl_file_dedupe_range\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [same]\n- 调用者: ioctl_file_dedupe_range\n- 被调用者: []"
  },
  {
    "id": 1092,
    "cwe": "CWE-119",
    "cve": "CVE-2016-7042",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中显示/proc/keys文件中的密钥信息，包括密钥序列号、标志位、权限、有效期等属性。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"使用了不正确的缓冲区大小来处理超时数据，导致栈内存损坏\"\"\"",
    "functions": "Functions:\n1. 函数名: proc_keys_show\n- 参数: [struct seq_file *m, void *v]\n- 调用者: 未显示（由内核proc文件系统调用）\n- 被调用者: [rb_entry, current_cred, make_key_ref, search_my_process_keyrings, key_ref_put, key_task_permission, current_kernel_time, rcu_read_lock, memcpy, sprintf, test_bit, seq_printf, atomic_read, from_kuid_munged, from_kgid_munged, seq_putc, rcu_read_unlock]\n\n2. 函数名: rb_entry\n- 参数: [struct rb_node *_p, struct key, serial_node]\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n3. 函数名: current_cred\n- 参数: []\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n4. 函数名: make_key_ref\n- 参数: [struct key *key, int]\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n5. 函数名: search_my_process_keyrings\n- 参数: [struct keyring_search_context *ctx]\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n6. 函数名: key_ref_put\n- 参数: [key_ref_t skey_ref]\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n7. 函数名: key_task_permission\n- 参数: [key_ref_t key_ref, struct cred *cred, int KEY_NEED_VIEW]\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n8. 函数名: current_kernel_time\n- 参数: []\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n9. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n10. 函数名: memcpy\n- 参数: [char *xbuf, char *\"perm\"/\"expd\", size_t 5]\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n11. 函数名: sprintf\n- 参数: [char *xbuf, char *format, unsigned long timo]\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n12. 函数名: test_bit\n- 参数: [int FLAG, unsigned long *&(KEY)->flags]\n- 调用者: proc_keys_show (通过showflag宏)\n- 被调用者: 未显示\n\n13. 函数名: seq_printf\n- 参数: [struct seq_file *m, char *format, ...]\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n14. 函数名: atomic_read\n- 参数: [atomic_t *&key->usage]\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n15. 函数名: from_kuid_munged\n- 参数: [struct user_namespace *seq_user_ns(m), kuid_t key->uid]\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n16. 函数名: from_kgid_munged\n- 参数: [struct user_namespace *seq_user_ns(m), kgid_t key->gid]\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n17. 函数名: seq_putc\n- 参数: [struct seq_file *m, char '\\n']\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n18. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: proc_keys_show\n- 被调用者: 未显示"
  },
  {
    "id": 1108,
    "cwe": "CWE-119",
    "cve": "CVE-2016-7425",
    "purpose": "Code purpose:\"\"\"该代码实现了SCSI适配器控制块与IOP(输入/输出处理器)之间的消息传输功能，包括读写缓冲区、清除缓冲区等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"arcmsr_iop_message_xfer函数在处理ARCMSR_MESSAGE_WRITE_WQBUFFER控制码时，未对用户提供的长度字段(pcmdmessagefld->cmdmessage.Length)进行有效限制，导致可能发生堆缓冲区溢出。\"\"\"",
    "functions": "Functions:\n1. 函数名: arcmsr_iop_message_xfer\n- 参数: [struct AdapterControlBlock *acb, struct scsi_cmnd *cmd]\n- 调用者: 未显示（应为SCSI子系统调用）\n- 被调用者: [scsi_sg_count, scsi_sglist, kmap_atomic, kunmap_atomic, kmalloc, kfree, spin_lock_irqsave, spin_unlock_irqrestore, memcpy, CIRC_CNT_TO_END, CIRC_CNT, arcmsr_get_iop_rqbuffer, arcmsr_Read_iop_rqbuffer_data, arcmsr_write_ioctldata2iop, arcmsr_clear_iop2drv_rqueue_buffer, arcmsr_iop_parking, arcmsr_flush_adapter_cache, pr_info]\n\n2. 函数名: scsi_sg_count\n- 参数: [struct scsi_cmnd *cmd]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n3. 函数名: scsi_sglist\n- 参数: [struct scsi_cmnd *cmd]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n4. 函数名: kmap_atomic\n- 参数: [sg_page(sg)]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n5. 函数名: kunmap_atomic\n- 参数: [buffer - sg->offset]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n6. 函数名: kmalloc\n- 参数: [ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n7. 函数名: kfree\n- 参数: [ver_addr]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n8. 函数名: spin_lock_irqsave\n- 参数: [&acb->rqbuffer_lock, flags], [&acb->wqbuffer_lock, flags]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n9. 函数名: spin_unlock_irqrestore\n- 参数: [&acb->rqbuffer_lock, flags], [&acb->wqbuffer_lock, flags]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n10. 函数名: memcpy\n- 参数: 多种参数组合\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n11. 函数名: CIRC_CNT_TO_END\n- 参数: [head, tail, ARCMSR_MAX_QBUFFER]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n12. 函数名: CIRC_CNT\n- 参数: [head, tail, ARCMSR_MAX_QBUFFER]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n13. 函数名: arcmsr_get_iop_rqbuffer\n- 参数: [acb]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n14. 函数名: arcmsr_Read_iop_rqbuffer_data\n- 参数: [acb, prbuffer]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n15. 函数名: arcmsr_write_ioctldata2iop\n- 参数: [acb]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n16. 函数名: arcmsr_clear_iop2drv_rqueue_buffer\n- 参数: [acb]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n17. 函数名: arcmsr_iop_parking\n- 参数: [acb]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n18. 函数名: arcmsr_flush_adapter_cache\n- 参数: [acb]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n19. 函数名: pr_info\n- 参数: 格式化字符串和参数\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无"
  },
  {
    "id": 1120,
    "cwe": "CWE-119",
    "cve": "CVE-2016-8632",
    "purpose": "Code purpose:\"\"\"处理网络设备事件并更新TIPC（透明进程间通信）承载状态及相关参数\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"未验证最小片段长度与最大数据包大小之间的关系，导致堆缓冲区溢出漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: tipc_l2_device_event\n- 参数: [struct notifier_block *nb, unsigned long evt, void *ptr]\n- 调用者: 未显示（由内核通知链机制调用）\n- 被调用者: [netdev_notifier_info_to_dev, dev_net, rtnl_dereference, netif_carrier_ok, test_and_set_bit_lock, clear_bit_unlock, tipc_reset_bearer, bearer_disable]\n\n2. 函数名: netdev_notifier_info_to_dev\n- 参数: [void *ptr]\n- 调用者: tipc_l2_device_event\n- 被调用者: 未显示\n\n3. 函数名: dev_net\n- 参数: [struct net_device *dev]\n- 调用者: tipc_l2_device_event\n- 被调用者: 未显示\n\n4. 函数名: rtnl_dereference\n- 参数: [dev->tipc_ptr]\n- 调用者: tipc_l2_device_event\n- 被调用者: 未显示\n\n5. 函数名: netif_carrier_ok\n- 参数: [struct net_device *dev]\n- 调用者: tipc_l2_device_event\n- 被调用者: 未显示\n\n6. 函数名: test_and_set_bit_lock\n- 参数: [0, &b->up]\n- 调用者: tipc_l2_device_event\n- 被调用者: 未显示\n\n7. 函数名: clear_bit_unlock\n- 参数: [0, &b->up]\n- 调用者: tipc_l2_device_event\n- 被调用者: 未显示\n\n8. 函数名: tipc_reset_bearer\n- 参数: [struct net *net, struct tipc_bearer *b]\n- 调用者: tipc_l2_device_event\n- 被调用者: 未显示\n\n9. 函数名: bearer_disable\n- 参数: [dev_net(dev), struct tipc_bearer *b]\n- 调用者: tipc_l2_device_event\n- 被调用者: 未显示"
  },
  {
    "id": 1121,
    "cwe": "CWE-119",
    "cve": "CVE-2016-8632",
    "purpose": "Code purpose:\"\"\"将TIPC（透明进程间通信）承载与指定的L2网络设备关联，并配置相关网络参数\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"未验证最小片段长度与最大数据包大小之间的关系，导致堆缓冲区溢出漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: tipc_enable_l2_media\n- 参数: [net, b, attr]\n- 调用者: N/A\n- 被调用者: [strchr, dev_get_by_name, rcu_assign_pointer, memset, memcpy]\n\n2. 函数名: strchr\n- 参数: [(const char *)b->name, ':']\n- 调用者: tipc_enable_l2_media\n- 被调用者: N/A\n\n3. 函数名: dev_get_by_name\n- 参数: [net, driver_name]\n- 调用者: tipc_enable_l2_media\n- 被调用者: N/A\n\n4. 函数名: rcu_assign_pointer\n- 参数: [b->media_ptr, dev]\n- 调用者: tipc_enable_l2_media\n- 被调用者: N/A\n\n5. 函数名: memset\n- 参数: [&b->bcast_addr, 0, sizeof(b->bcast_addr)]\n- 调用者: tipc_enable_l2_media\n- 被调用者: N/A\n\n6. 函数名: memcpy\n- 参数: [b->bcast_addr.value, dev->broadcast, b->media->hwaddr_len]\n- 调用者: tipc_enable_l2_media\n- 被调用者: N/A\n\n7. 函数名: rcu_assign_pointer\n- 参数: [dev->tipc_ptr, b]\n- 调用者: tipc_enable_l2_media\n- 被调用者: N/A"
  },
  {
    "id": 1122,
    "cwe": "CWE-119",
    "cve": "CVE-2016-8632",
    "purpose": "Code purpose:\"\"\"该代码实现了TIPC协议中UDP承载的启用功能，包括配置本地和远程UDP地址、创建UDP套接字以及设置隧道接收回调等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"未验证最小片段长度与最大数据包大小之间的关系，导致堆缓冲区溢出漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: tipc_udp_enable\n- 参数: [struct net *net, struct tipc_bearer *b, struct nlattr *attrs[]]\n- 调用者: (未在代码片段中显示)\n- 被调用者: [kzalloc, INIT_LIST_HEAD, nla_parse_nested, tipc_parse_udp_addr, htons, __ip_dev_find, udp_sock_create, setup_udp_tunnel_sock, memcpy, tipc_udp_is_mcast_addr, enable_mcast, tipc_udp_rcast_add, udp_tunnel_sock_release, kfree]\n\n2. 函数名: tipc_parse_udp_addr\n- 参数: (未完全显示，至少包含 struct nlattr *opts, struct udp_media_addr *addr, int *ifindex)\n- 调用者: tipc_udp_enable\n- 被调用者: (未在代码片段中显示)\n\n3. 函数名: __ip_dev_find\n- 参数: [struct net *net, u32 addr, bool devref]\n- 调用者: tipc_udp_enable\n- 被调用者: (未在代码片段中显示)\n\n4. 函数名: udp_sock_create\n- 参数: [struct net *net, struct udp_port_cfg *cfg, struct socket **sockp]\n- 调用者: tipc_udp_enable\n- 被调用者: (未在代码片段中显示)\n\n5. 函数名: setup_udp_tunnel_sock\n- 参数: [struct net *net, struct socket *sock, struct udp_tunnel_sock_cfg *cfg]\n- 调用者: tipc_udp_enable\n- 被调用者: (未在代码片段中显示)\n\n6. 函数名: tipc_udp_is_mcast_addr\n- 参数: [struct udp_media_addr *addr]\n- 调用者: tipc_udp_enable\n- 被调用者: (未在代码片段中显示)\n\n7. 函数名: enable_mcast\n- 参数: [struct udp_bearer *ub, struct udp_media_addr *remote]\n- 调用者: tipc_udp_enable\n- 被调用者: (未在代码片段中显示)\n\n8. 函数名: tipc_udp_rcast_add\n- 参数: [struct tipc_bearer *b, struct udp_media_addr *addr]\n- 调用者: tipc_udp_enable\n- 被调用者: (未在代码片段中显示)\n\n9. 函数名: udp_tunnel_sock_release\n- 参数: [struct socket *sock]\n- 调用者: tipc_udp_enable\n- 被调用者: (未在代码片段中显示)\n\n10. 函数名: tipc_udp_media_addr_set\n- 参数: [struct tipc_media_addr *addr, struct udp_media_addr *media]\n- 调用者: (未在代码片段中显示，但被tipc_udp_enable调用)\n- 被调用者: (未在代码片段中显示)"
  },
  {
    "id": 1123,
    "cwe": "CWE-119",
    "cve": "CVE-2016-8633",
    "purpose": "Code purpose:\"\"\"处理通过IEEE 1394总线接收的网络数据包，包括完整数据包和分片数据包的组装与转发\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理分片数据包时，由于缺乏对数据包大小和分片偏移量的充分验证，导致可能发生缓冲区溢出或内存损坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: fwnet_incoming_packet\n- 参数: [dev, buf, len, source_node_id, generation, is_broadcast]\n- 调用者: 未显示\n- 被调用者: [fwnet_get_hdr_lf, be32_to_cpu, fwnet_get_hdr_ether_type, dev_alloc_skb, skb_reserve, skb_put, memcpy, fwnet_finish_incoming_packet, ntohl, fwnet_get_hdr_fg_off, fwnet_get_hdr_dgl, fwnet_get_hdr_dg_size, spin_lock_irqsave, fwnet_peer_find_by_node_id, fwnet_pd_find, fwnet_pd_delete, fwnet_pd_new, fwnet_frag_overlap, fwnet_pd_update, fwnet_pd_is_complete, skb_get, spin_unlock_irqrestore]\n\n2. 函数名: fwnet_get_hdr_lf\n- 参数: [hdr]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n3. 函数名: fwnet_get_hdr_ether_type\n- 参数: [hdr]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n4. 函数名: fwnet_get_hdr_fg_off\n- 参数: [hdr]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n5. 函数名: fwnet_get_hdr_dgl\n- 参数: [hdr]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n6. 函数名: fwnet_get_hdr_dg_size\n- 参数: [hdr]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n7. 函数名: fwnet_peer_find_by_node_id\n- 参数: [dev, source_node_id, generation]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n8. 函数名: fwnet_pd_find\n- 参数: [peer, datagram_label]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n9. 函数名: fwnet_pd_delete\n- 参数: [pd]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n10. 函数名: fwnet_pd_new\n- 参数: [net, peer, datagram_label, dg_size, buf, fg_off, len]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n11. 函数名: fwnet_frag_overlap\n- 参数: [pd, fg_off, len]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n12. 函数名: fwnet_pd_update\n- 参数: [peer, pd, buf, fg_off, len]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n13. 函数名: fwnet_pd_is_complete\n- 参数: [pd]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n14. 函数名: fwnet_finish_incoming_packet\n- 参数: [net, skb, source_node_id, is_broadcast, ether_type]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示"
  },
  {
    "id": 1124,
    "cwe": "CWE-119",
    "cve": "CVE-2016-8633",
    "purpose": "Code purpose:\"\"\"处理FireWire网络设备接收的广播数据包，包括解析包头、验证数据并转发有效数据包\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理特定硬件配置下的分段广播数据包时，由于缺乏对数据包长度的充分验证，导致缓冲区溢出漏洞，允许远程攻击者执行任意代码。\"\"\"",
    "functions": "Functions:\n1. 函数名: fwnet_receive_broadcast\n- 参数: [struct fw_iso_context *context, u32 cycle, size_t header_length, void *header, void *data]\n- 调用者: 未显示（由内核事件触发）\n- 被调用者: [be16_to_cpup, spin_lock_irqsave, spin_unlock_irqrestore, be32_to_cpu, fwnet_incoming_packet, fw_iso_context_queue, fw_iso_context_queue_flush, dev_err]\n\n2. 函数名: be16_to_cpup\n- 参数: [__be16 *hdr_ptr]\n- 调用者: fwnet_receive_broadcast\n- 被调用者: []\n\n3. 函数名: spin_lock_irqsave\n- 参数: [&dev->lock, flags]\n- 调用者: fwnet_receive_broadcast\n- 被调用者: []\n\n4. 函数名: spin_unlock_irqrestore\n- 参数: [&dev->lock, flags]\n- 调用者: fwnet_receive_broadcast\n- 被调用者: []\n\n5. 函数名: be32_to_cpu\n- 参数: [buf_ptr[0], buf_ptr[1]]\n- 调用者: fwnet_receive_broadcast\n- 被调用者: []\n\n6. 函数名: fwnet_incoming_packet\n- 参数: [dev, buf_ptr, length, source_node_id, context->card->generation, true]\n- 调用者: fwnet_receive_broadcast\n- 被调用者: []\n\n7. 函数名: fw_iso_context_queue\n- 参数: [dev->broadcast_rcv_context, &packet, &dev->broadcast_rcv_buffer, offset]\n- 调用者: fwnet_receive_broadcast\n- 被调用者: []\n\n8. 函数名: fw_iso_context_queue_flush\n- 参数: [dev->broadcast_rcv_context]\n- 调用者: fwnet_receive_broadcast\n- 被调用者: []\n\n9. 函数名: dev_err\n- 参数: [&dev->netdev->dev, \"requeue failed\\n\"]\n- 调用者: fwnet_receive_broadcast\n- 被调用者: []"
  },
  {
    "id": 1133,
    "cwe": "CWE-119",
    "cve": "CVE-2016-8658",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中Broadcom无线网卡驱动创建和配置AP(接入点)模式的功能，包括处理SSID、安全设置、信道配置等参数。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SSID信息元素时未正确验证长度，导致栈缓冲区溢出漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: brcmf_cfg80211_start_ap\n- 参数: [wiphy, ndev, settings]\n- 调用者: N/A (kernel function)\n- 被调用者: [wiphy_to_cfg, netdev_priv, chandef_to_chanspec, brcmf_dbg, brcmf_fil_cmd_int_get, brcmf_parse_tlvs, memset, memcpy, cpu_to_le32, brcmf_set_mpc, brcmf_configure_arp_nd_offload, brcmf_find_wpaie, brcmf_configure_wpaie, brcmf_configure_opensecurity, brcmf_config_ap_mgmt_ie, brcmf_fil_cmd_int_set, brcmf_fil_iovar_int_set, brcmf_feat_is_enabled, brcmf_fil_iovar_data_set, brcmf_cfg80211_reconfigure_wep, brcmf_fil_cmd_data_set, brcmf_fil_bsscfg_data_set, brcmf_net_setcarrier]\n\n2. 函数名: wiphy_to_cfg\n- 参数: [wiphy]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n3. 函数名: netdev_priv\n- 参数: [ndev]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n4. 函数名: chandef_to_chanspec\n- 参数: [&cfg->d11inf, &settings->chandef]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n5. 函数名: brcmf_dbg\n- 参数: [TRACE, format_string, ...]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n6. 函数名: brcmf_fil_cmd_int_get\n- 参数: [ifp, BRCMF_C_GET_REGULATORY, &ifp->vif->is_11d]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n7. 函数名: brcmf_parse_tlvs\n- 参数: [(u8 *)settings->beacon.tail, settings->beacon.tail_len, WLAN_EID_COUNTRY], [(u8 *)&settings->beacon.head[ie_offset], settings->beacon.head_len - ie_offset, WLAN_EID_SSID], [(u8 *)settings->beacon.tail, settings->beacon.tail_len, WLAN_EID_RSN]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n8. 函数名: memset\n- 参数: [&ssid_le, 0, sizeof(ssid_le)], [&join_params, 0, sizeof(join_params)]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n9. 函数名: memcpy\n- 参数: [ssid_le.SSID, ssid_ie->data, ssid_ie->len], [ssid_le.SSID, settings->ssid, settings->ssid_len], [&join_params.ssid_le, &ssid_le, sizeof(ssid_le)]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n10. 函数名: cpu_to_le32\n- 参数: [ssid_ie->len], [(u32)settings->ssid_len]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n11. 函数名: brcmf_set_mpc\n- 参数: [ifp, 0], [ifp, 1]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n12. 函数名: brcmf_configure_arp_nd_offload\n- 参数: [ifp, false], [ifp, true]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n13. 函数名: brcmf_find_wpaie\n- 参数: [(u8 *)settings->beacon.tail, settings->beacon.tail_len]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n14. 函数名: brcmf_configure_wpaie\n- 参数: [ifp, wpa_ie, false], [ifp, tmp_ie, true]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n15. 函数名: brcmf_configure_opensecurity\n- 参数: [ifp]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n16. 函数名: brcmf_config_ap_mgmt_ie\n- 参数: [ifp->vif, &settings->beacon]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n17. 函数名: brcmf_fil_cmd_int_set\n- 参数: [ifp, BRCMF_C_SET_REGULATORY, is_11d], [ifp, BRCMF_C_SET_BCNPRD, settings->beacon_interval], [ifp, BRCMF_C_SET_DTIMPRD, settings->dtim_period], [ifp, BRCMF_C_DOWN, 1], [ifp, BRCMF_C_SET_INFRA, 1], [ifp, BRCMF_C_SET_AP, 1], [ifp, BRCMF_C_UP, 1]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n18. 函数名: brcmf_fil_iovar_int_set\n- 参数: [ifp, \"apsta\", 0], [ifp, \"mbss\", 1], [ifp, \"chanspec\", chanspec], [ifp, \"closednet\", 1]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n19. 函数名: brcmf_feat_is_enabled\n- 参数: [ifp, BRCMF_FEAT_RSDB], [ifp, BRCMF_FEAT_MBSS]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n20. 函数名: brcmf_cfg80211_reconfigure_wep\n- 参数: [ifp]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n21. 函数名: brcmf_fil_cmd_data_set\n- 参数: [ifp, BRCMF_C_SET_SSID, &join_params, sizeof(join_params)]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n22. 函数名: brcmf_fil_bsscfg_data_set\n- 参数: [ifp, \"ssid\", &ssid_le, sizeof(ssid_le)]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n23. 函数名: brcmf_fil_iovar_data_set\n- 参数: [ifp, \"bss\", &bss_enable, sizeof(bss_enable)]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n24. 函数名: brcmf_net_setcarrier\n- 参数: [ifp, true]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []"
  },
  {
    "id": 1137,
    "cwe": "CWE-119",
    "cve": "CVE-2016-9083",
    "purpose": "Code purpose:\"\"\"该代码实现了VFIO PCI设备的IOCTL接口，用于处理设备信息查询、区域信息获取、中断设置、设备重置等操作，允许用户空间与PCI设备进行交互。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于VFIO_DEVICE_SET_IRQS ioctl调用中缺乏对整数溢出的充分检查，导致本地用户可通过精心构造的参数绕过安全检查，造成内存破坏或其他未明确影响。\"\"\"",
    "functions": "Functions:\n1. 函数名: vfio_pci_ioctl\n- 参数: [device_data, cmd, arg]\n- 调用者: 无（系统调用接口）\n- 被调用者: [copy_from_user, copy_to_user, vfio_pci_get_irq_count, vfio_pci_set_irqs_ioctl, pci_try_reset_function, vfio_pci_for_each_slot_or_bus, vfio_pci_count_devs, vfio_pci_fill_devs, vfio_pci_validate_devs, pci_try_reset_slot, pci_try_reset_bus, msix_sparse_mmap_cap, region_type_cap, vfio_info_cap_shift, memdup_user, kfree, mutex_lock, mutex_unlock, fdget, fdput, vfio_group_get_external_user, vfio_external_user_iommu_id, vfio_group_put_external_user]\n\n2. 函数名: vfio_pci_get_irq_count\n- 参数: [vdev, index]\n- 调用者: vfio_pci_ioctl\n- 被调用者: 无\n\n3. 函数名: vfio_pci_set_irqs_ioctl\n- 参数: [vdev, flags, index, start, count, data]\n- 调用者: vfio_pci_ioctl\n- 被调用者: 无\n\n4. 函数名: vfio_pci_for_each_slot_or_bus\n- 参数: [pdev, func, data, slot]\n- 调用者: vfio_pci_ioctl\n- 被调用者: 无\n\n5. 函数名: vfio_pci_count_devs\n- 参数: [pdev, data]\n- 调用者: vfio_pci_ioctl\n- 被调用者: 无\n\n6. 函数名: vfio_pci_fill_devs\n- 参数: [pdev, data]\n- 调用者: vfio_pci_ioctl\n- 被调用者: 无\n\n7. 函数名: vfio_pci_validate_devs\n- 参数: [pdev, data]\n- 调用者: vfio_pci_ioctl\n- 被调用者: 无\n\n8. 函数名: msix_sparse_mmap_cap\n- 参数: [vdev, caps]\n- 调用者: vfio_pci_ioctl\n- 被调用者: 无\n\n9. 函数名: region_type_cap\n- 参数: [vdev, caps, type, subtype]\n- 调用者: vfio_pci_ioctl\n- 被调用者: 无\n\n10. 函数名: vfio_info_cap_shift\n- 参数: [caps, offset]\n- 调用者: vfio_pci_ioctl\n- 被调用者: 无"
  },
  {
    "id": 1408,
    "cwe": "CWE-119",
    "cve": "CVE-2017-18222",
    "purpose": "Code purpose:\"\"\"获取网络子系统统计信息的数量，根据不同的字符串集类型返回相应的静态统计数量\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"代码未处理ETH_SS_PRIV_FLAGS情况，导致缓冲区溢出和内存损坏\"\"\"",
    "functions": "Functions:\n1. 函数名: hns_ppe_get_sset_count\n- 参数: [stringset]\n- 调用者: 未明确（可能是内核中调用该函数的其他模块）\n- 被调用者: []"
  },
  {
    "id": 1409,
    "cwe": "CWE-119",
    "cve": "CVE-2017-18222",
    "purpose": "Code purpose:\"\"\"获取HNS网络子系统环形统计集的计数，仅处理ETH_SS_STATS情况而忽略其他可能的集合类型\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"代码在处理stringset参数时未考虑ETH_SS_PRIV_FLAGS情况，导致缓冲区溢出和内存损坏漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: hns_rcb_get_ring_sset_count\n- 参数: [stringset]\n- 调用者: 未提供（根据上下文可能由HNS驱动相关代码调用）\n- 被调用者: []"
  },
  {
    "id": 1410,
    "cwe": "CWE-119",
    "cve": "CVE-2017-18222",
    "purpose": "Code purpose:\"\"\"该代码用于获取Hisilicon网络子系统中XGMAC接口的统计信息字符串数量\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"未处理ETH_SS_PRIV_FLAGS情况导致缓冲区溢出和内存损坏\"\"\"",
    "functions": "Functions:\n1. 函数名: hns_xgmac_get_sset_count\n- 参数: [stringset]\n- 调用者: 未明确显示（应为调用ETH_SS_STATS相关功能的代码）\n- 被调用者: [ARRAY_SIZE]"
  },
  {
    "id": 1434,
    "cwe": "CWE-119",
    "cve": "CVE-2017-18379",
    "purpose": "Code purpose:\"\"\"在NVMe over Fabrics目标端驱动中，根据连接ID查找对应的目标队列\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在访问关联队列数组时未对队列ID(qid)进行边界检查，导致可能发生越界访问\"\"\"",
    "functions": "Functions:\n1. 函数名: nvmet_fc_find_target_queue\n- 参数: [tgtport, connection_id]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [nvmet_fc_getassociationid, nvmet_fc_getqueueid, atomic_read, nvmet_fc_tgt_q_get]\n\n2. 函数名: nvmet_fc_getassociationid\n- 参数: [connection_id]\n- 调用者: nvmet_fc_find_target_queue\n- 被调用者: 未明确（可能为内联或宏）\n\n3. 函数名: nvmet_fc_getqueueid\n- 参数: [connection_id]\n- 调用者: nvmet_fc_find_target_queue\n- 被调用者: 未明确（可能为内联或宏）\n\n4. 函数名: atomic_read\n- 参数: [&queue->connected]\n- 调用者: nvmet_fc_find_target_queue\n- 被调用者: 未明确（内核原子操作API）\n\n5. 函数名: nvmet_fc_tgt_q_get\n- 参数: [queue]\n- 调用者: nvmet_fc_find_target_queue\n- 被调用者: 未明确（上下文未提供）"
  },
  {
    "id": 1460,
    "cwe": "CWE-119",
    "cve": "CVE-2017-5547",
    "purpose": "Code purpose:\"\"\"该代码用于从Corsair K90键盘获取宏模式状态并通过sysfs接口返回给用户空间。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"代码在处理USB控制消息时使用了栈分配的缓冲区进行DMA操作，当启用CONFIG_VMAP_STACK配置时可能导致跨虚拟页面的DMA传输，引发系统崩溃或内存破坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: k90_show_macro_mode\n- 参数: [dev, attr, buf]\n- 调用者: 未显示（通常由设备属性系统调用）\n- 被调用者: [to_usb_interface, interface_to_usbdev, usb_control_msg, dev_warn, snprintf]\n\n2. 函数名: to_usb_interface\n- 参数: [dev->parent]\n- 调用者: k90_show_macro_mode\n- 被调用者: 未显示\n\n3. 函数名: interface_to_usbdev\n- 参数: [usbif]\n- 调用者: k90_show_macro_mode\n- 被调用者: 未显示\n\n4. 函数名: usb_control_msg\n- 参数: [usbdev, usb_rcvctrlpipe(usbdev, 0), K90_REQUEST_GET_MODE, USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE, 0, 0, data, 2, USB_CTRL_SET_TIMEOUT]\n- 调用者: k90_show_macro_mode\n- 被调用者: 未显示\n\n5. 函数名: dev_warn\n- 参数: [dev, \"Failed to get K90 initial mode (error %d).\\n\", ret] 和 [dev, \"K90 in unknown mode: %02hhx.\\n\", data[0]]\n- 调用者: k90_show_macro_mode\n- 被调用者: 未显示\n\n6. 函数名: snprintf\n- 参数: [buf, PAGE_SIZE, \"%s\\n\", macro_mode]\n- 调用者: k90_show_macro_mode\n- 被调用者: 未显示\n\n7. 函数名: usb_rcvctrlpipe\n- 参数: [usbdev, 0]\n- 调用者: k90_show_macro_mode (通过usb_control_msg间接调用)\n- 被调用者: 未显示"
  },
  {
    "id": 1461,
    "cwe": "CWE-119",
    "cve": "CVE-2017-5547",
    "purpose": "Code purpose:\"\"\"该代码用于通过USB控制消息获取K90键盘背光亮度状态，并进行有效性检查后返回亮度值\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"内核驱动在处理DMA散射列表时未正确考虑CONFIG_VMAP_STACK配置，导致使用多个虚拟页时可能引发系统崩溃或内存损坏\"\"\"",
    "functions": "Functions:\n1. 函数名: k90_backlight_get\n- 参数: [struct led_classdev *led_cdev]\n- 调用者: 未明确显示（通常由LED子系统调用）\n- 被调用者: [container_of, to_usb_interface, interface_to_usbdev, usb_control_msg, dev_warn]\n\n2. 函数名: container_of\n- 参数: [ptr, type, member]（从调用上下文推断）\n- 调用者: k90_backlight_get\n- 被调用者: []\n\n3. 函数名: to_usb_interface\n- 参数: [struct device *dev]（从调用上下文推断）\n- 调用者: k90_backlight_get\n- 被调用者: []\n\n4. 函数名: interface_to_usbdev\n- 参数: [struct usb_interface *usbif]（从调用上下文推断）\n- 调用者: k90_backlight_get\n- 被调用者: []\n\n5. 函数名: usb_control_msg\n- 参数: [usbdev, usb_rcvctrlpipe(usbdev, 0), K90_REQUEST_STATUS, USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE, 0, 0, data, 8, USB_CTRL_SET_TIMEOUT]\n- 调用者: k90_backlight_get\n- 被调用者: [usb_rcvctrlpipe]\n\n6. 函数名: usb_rcvctrlpipe\n- 参数: [usbdev, 0]（从调用上下文推断）\n- 调用者: usb_control_msg\n- 被调用者: []\n\n7. 函数名: dev_warn\n- 参数: [dev, format_string, ret/data[4]]（从调用上下文推断）\n- 调用者: k90_backlight_get\n- 被调用者: []"
  },
  {
    "id": 1462,
    "cwe": "CWE-119",
    "cve": "CVE-2017-5547",
    "purpose": "Code purpose:\"\"\"该代码用于通过USB控制消息获取K90设备的当前配置文件状态，并将其格式化输出到缓冲区中。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，代码在栈上分配的data数组可能跨越多个虚拟内存页，而usb_control_msg()的DMA操作无法正确处理这种情况，导致系统崩溃或内存损坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: k90_show_current_profile\n- 参数: [struct device *dev, struct device_attribute *attr, char *buf]\n- 调用者: 未显示（通常由设备属性子系统调用）\n- 被调用者: [to_usb_interface, interface_to_usbdev, usb_control_msg, dev_warn, snprintf]\n\n2. 函数名: to_usb_interface\n- 参数: [struct device *dev->parent]\n- 调用者: k90_show_current_profile\n- 被调用者: 未显示\n\n3. 函数名: interface_to_usbdev\n- 参数: [struct usb_interface *usbif]\n- 调用者: k90_show_current_profile\n- 被调用者: 未显示\n\n4. 函数名: usb_control_msg\n- 参数: [struct usb_device *usbdev, usb_rcvctrlpipe(usbdev, 0), K90_REQUEST_STATUS, USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE, 0, 0, data, 8, USB_CTRL_SET_TIMEOUT]\n- 调用者: k90_show_current_profile\n- 被调用者: 未显示\n\n5. 函数名: dev_warn\n- 参数: [struct device *dev, const char *fmt, ret/data[7]]\n- 调用者: k90_show_current_profile\n- 被调用者: 未显示\n\n6. 函数名: snprintf\n- 参数: [char *buf, PAGE_SIZE, \"%d\\n\", current_profile]\n- 调用者: k90_show_current_profile\n- 被调用者: 未显示"
  },
  {
    "id": 1463,
    "cwe": "CWE-119",
    "cve": "CVE-2017-5548",
    "purpose": "Code purpose:\"\"\"该代码用于通过USB控制消息获取并显示ATUSB设备的固件版本和硬件类型信息。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，代码使用栈分配的缓冲区进行DMA操作，而虚拟内存映射的栈可能跨越多个物理页，导致DMA传输时出现内存损坏或系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: atusb_get_and_show_revision\n- 参数: [struct atusb *atusb]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [atusb_control_msg, dev_info]\n\n2. 函数名: atusb_control_msg\n- 参数: [struct atusb *atusb, usb_rcvctrlpipe(usb_dev, 0), ATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0, buffer, 3, 1000]\n- 调用者: atusb_get_and_show_revision\n- 被调用者: 未显示（可能是内核USB接口函数）\n\n3. 函数名: usb_rcvctrlpipe\n- 参数: [usb_dev, 0]\n- 调用者: atusb_get_and_show_revision\n- 被调用者: 未显示（可能是内核USB接口函数）\n\n4. 函数名: dev_info\n- 参数: [&usb_dev->dev, format string, ...]\n- 调用者: atusb_get_and_show_revision\n- 被调用者: 未显示（内核日志函数）"
  },
  {
    "id": 1464,
    "cwe": "CWE-119",
    "cve": "CVE-2017-5548",
    "purpose": "Code purpose:\"\"\"该代码用于通过USB控制消息获取并显示设备的固件构建信息\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，代码在栈上分配的缓冲区build可能跨越多个虚拟内存页，而DMA操作无法正确处理这种跨页情况，导致系统崩溃或内存损坏\"\"\"",
    "functions": "Functions:\n1. 函数名: atusb_get_and_show_build\n- 参数: [struct atusb *atusb]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [atusb_control_msg, dev_info]\n\n2. 函数名: atusb_control_msg\n- 参数: [struct atusb *atusb, usb_rcvctrlpipe(usb_dev, 0), ATUSB_BUILD, ATUSB_REQ_FROM_DEV, 0, 0, build, ATUSB_BUILD_SIZE, 1000]\n- 调用者: atusb_get_and_show_build\n- 被调用者: 未显示（可能是内核USB核心函数）\n\n3. 函数名: usb_rcvctrlpipe\n- 参数: [usb_dev, 0]\n- 调用者: atusb_get_and_show_build\n- 被调用者: 未显示（内核USB核心函数）\n\n4. 函数名: dev_info\n- 参数: [&usb_dev->dev, \"Firmware: build %s\\n\", build]\n- 调用者: atusb_get_and_show_build\n- 被调用者: 未显示（内核打印函数）"
  },
  {
    "id": 1465,
    "cwe": "CWE-119",
    "cve": "CVE-2017-5548",
    "purpose": "Code purpose:\"\"\"该代码用于通过USB控制消息读取ATUSB设备的寄存器值\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，代码使用栈分配的缓冲区进行DMA操作，而栈分配的内存可能跨越多个虚拟页面，导致系统崩溃或内存损坏\"\"\"",
    "functions": "Functions:\n1. 函数名: atusb_read_reg\n- 参数: [struct atusb *atusb, uint8_t reg]\n- 调用者: 未指定\n- 被调用者: [dev_dbg, atusb_control_msg, usb_rcvctrlpipe]\n\n2. 函数名: dev_dbg\n- 参数: [&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg]\n- 调用者: atusb_read_reg\n- 被调用者: 未指定\n\n3. 函数名: atusb_control_msg\n- 参数: [atusb, usb_rcvctrlpipe(usb_dev, 0), ATUSB_REG_READ, ATUSB_REQ_FROM_DEV, 0, reg, &value, 1, 1000]\n- 调用者: atusb_read_reg\n- 被调用者: 未指定\n\n4. 函数名: usb_rcvctrlpipe\n- 参数: [usb_dev, 0]\n- 调用者: atusb_control_msg\n- 被调用者: 未指定"
  },
  {
    "id": 1490,
    "cwe": "CWE-119",
    "cve": "CVE-2017-7187",
    "purpose": "Code purpose:\"\"\"处理SCSI通用设备(sg)的ioctl命令，包括设置/获取超时、DMA模式、包ID等参数，以及执行SCSI命令等功能。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"SG_NEXT_CMD_LEN ioctl调用中未对用户提供的命令大小进行充分验证，导致sg_write函数中出现基于堆栈的缓冲区溢出。\"\"\"",
    "functions": "Functions:\n1. 函数名: sg_ioctl\n- 参数: [struct file *filp, unsigned int cmd_in, unsigned long arg]\n- 调用者: 内核IOCTL处理机制\n- 被调用者: [sg_printk, atomic_read, scsi_block_when_processing_errors, access_ok, sg_new_write, wait_event_interruptible, srp_done, sg_new_read, get_user, put_user, __put_user, sg_res_in_use, sg_remove_scat, sg_build_reserve, max_sectors_bytes, kmalloc, memset, __copy_to_user, kfree, copy_from_user, sg_allow_access, sg_scsi_ioctl, blk_trace_setup, blk_trace_startstop, blk_trace_remove, scsi_ioctl_block_when_processing_errors, scsi_ioctl]\n\n2. 函数名: sg_printk\n- 参数: [int level, Sg_device *sdp, const char *fmt, ...]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n3. 函数名: atomic_read\n- 参数: [atomic_t *v]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n4. 函数名: scsi_block_when_processing_errors\n- 参数: [struct scsi_device *sdev]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n5. 函数名: access_ok\n- 参数: [int type, const void __user *addr, unsigned long size]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n6. 函数名: sg_new_write\n- 参数: [Sg_fd *sfp, struct file *filp, void __user *buf, size_t count, int blocking, int read_only, int sg_io_owned, Sg_request **srpp]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n7. 函数名: wait_event_interruptible\n- 参数: [wait_queue_head_t *q, condition]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n8. 函数名: srp_done\n- 参数: [Sg_fd *sfp, Sg_request *srp]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n9. 函数名: sg_new_read\n- 参数: [Sg_fd *sfp, void __user *buf, size_t count, Sg_request *srp]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n10. 函数名: get_user\n- 参数: [x, ptr]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n11. 函数名: put_user\n- 参数: [x, ptr]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n12. 函数名: __put_user\n- 参数: [x, ptr]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n13. 函数名: sg_res_in_use\n- 参数: [Sg_fd *sfp]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n14. 函数名: sg_remove_scat\n- 参数: [Sg_fd *sfp, Sg_scatter_hold *schp]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n15. 函数名: sg_build_reserve\n- 参数: [Sg_fd *sfp, int size]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n16. 函数名: max_sectors_bytes\n- 参数: [struct request_queue *q]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n17. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n18. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n19. 函数名: __copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n20. 函数名: kfree\n- 参数: [const void *x]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n21. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n22. 函数名: sg_allow_access\n- 参数: [struct file *filp, unsigned char *cmd]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n23. 函数名: sg_scsi_ioctl\n- 参数: [struct request_queue *q, struct gendisk *disk, fmode_t mode, void __user *p]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n24. 函数名: blk_trace_setup\n- 参数: [struct request_queue *q, char *name, dev_t dev, struct block_device *bdev, char *arg]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n25. 函数名: blk_trace_startstop\n- 参数: [struct request_queue *q, int start]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n26. 函数名: blk_trace_remove\n- 参数: [struct request_queue *q]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n27. 函数名: scsi_ioctl_block_when_processing_errors\n- 参数: [struct scsi_device *sdev, int cmd, bool ndelay]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n28. 函数名: scsi_ioctl\n- 参数: [struct scsi_device *sdev, int cmd, void __user *arg]\n- 调用者: sg_ioctl\n- 被调用者: []"
  },
  {
    "id": 1513,
    "cwe": "CWE-119",
    "cve": "CVE-2017-7541",
    "purpose": "Code purpose:\"\"\"处理无线网络管理帧的传输，包括探测响应和动作帧，并返回传输状态\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理NL80211_CMD_FRAME Netlink数据包时，未对用户提供的buf参数进行充分边界检查，导致缓冲区溢出漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: brcmf_cfg80211_mgmt_tx\n- 参数: [wiphy, wdev, params, cookie]\n- 调用者: 未显示（由NL80211_CMD_FRAME Netlink packet触发）\n- 被调用者: [wiphy_to_cfg, ieee80211_is_mgmt, container_of, ieee80211_is_probe_resp, brcmf_vif_set_mgmt_ie, cfg80211_mgmt_tx_status, ieee80211_is_action, kzalloc, memcpy, cpu_to_le32, cpu_to_le16, brcmf_fil_cmd_int_get, ieee80211_frequency_to_channel, le16_to_cpu, brcmf_p2p_send_action_frame, kfree, brcmf_dbg, brcmf_err, brcmf_dbg_hex_dump]\n\n2. 函数名: wiphy_to_cfg\n- 参数: [wiphy]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n3. 函数名: ieee80211_is_mgmt\n- 参数: [mgmt->frame_control]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n4. 函数名: container_of\n- 参数: [wdev, struct brcmf_cfg80211_vif, wdev]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n5. 函数名: ieee80211_is_probe_resp\n- 参数: [mgmt->frame_control]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n6. 函数名: brcmf_vif_set_mgmt_ie\n- 参数: [vif, BRCMF_VNDR_IE_PRBRSP_FLAG, &buf[ie_offset], ie_len]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n7. 函数名: cfg80211_mgmt_tx_status\n- 参数: [wdev, *cookie, buf, len, true/ack, GFP_KERNEL]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n8. 函数名: ieee80211_is_action\n- 参数: [mgmt->frame_control]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n9. 函数名: kzalloc\n- 参数: [sizeof(*af_params), GFP_KERNEL]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n10. 函数名: memcpy\n- 参数: [&action_frame->da[0], &mgmt->da[0], ETH_ALEN], [&af_params->bssid[0], &mgmt->bssid[0], ETH_ALEN], [action_frame->data, &buf[DOT11_MGMT_HDR_LEN], le16_to_cpu(action_frame->len)]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n11. 函数名: cpu_to_le32\n- 参数: [*cookie], [chan_nr]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n12. 函数名: cpu_to_le16\n- 参数: [len - DOT11_MGMT_HDR_LEN]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n13. 函数名: brcmf_fil_cmd_int_get\n- 参数: [vif->ifp, BRCMF_C_GET_CHANNEL, &freq]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n14. 函数名: ieee80211_frequency_to_channel\n- 参数: [freq]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n15. 函数名: le16_to_cpu\n- 参数: [action_frame->len]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n16. 函数名: brcmf_p2p_send_action_frame\n- 参数: [cfg, cfg_to_ndev(cfg), af_params]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n17. 函数名: kfree\n- 参数: [af_params]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n18. 函数名: brcmf_dbg\n- 参数: [TRACE, \"Enter\"], [TRACE, \"Action frame, cookie=%lld, len=%d, freq=%d\\n\", *cookie, le16_to_cpu(action_frame->len), freq], [TRACE, \"Unhandled, fc=%04x!!\\n\", mgmt->frame_control]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n19. 函数名: brcmf_err\n- 参数: [\"Driver only allows MGMT packet type\"], [\"unable to allocate frame\"]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n20. 函数名: brcmf_dbg_hex_dump\n- 参数: [true, buf, len, \"payload, len=%zu\\n\", len]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []"
  },
  {
    "id": 1531,
    "cwe": "CWE-119",
    "cve": "CVE-2017-7895",
    "purpose": "Code purpose:\"\"\"该代码用于解码NFSv3服务器接收到的符号链接创建请求参数，包括文件句柄、文件名、属性和目标路径名的处理\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"代码在处理NFS请求时未充分验证缓冲区边界，导致可能触发指针算术错误或缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: nfs3svc_decode_symlinkargs\n- 参数: [rqstp, p, args]\n- 调用者: 未显示（由NFS服务调用）\n- 被调用者: [decode_fh, decode_filename, decode_sattr3, ntohl, page_address, min_t]\n\n2. 函数名: decode_fh\n- 参数: [p, &args->ffh]\n- 调用者: nfs3svc_decode_symlinkargs\n- 被调用者: []\n\n3. 函数名: decode_filename\n- 参数: [p, &args->fname, &args->flen]\n- 调用者: nfs3svc_decode_symlinkargs\n- 被调用者: []\n\n4. 函数名: decode_sattr3\n- 参数: [p, &args->attrs]\n- 调用者: nfs3svc_decode_symlinkargs\n- 被调用者: []\n\n5. 函数名: ntohl\n- 参数: [*p++]\n- 调用者: nfs3svc_decode_symlinkargs\n- 被调用者: []\n\n6. 函数名: page_address\n- 参数: [*(rqstp->rq_next_page++)]\n- 调用者: nfs3svc_decode_symlinkargs\n- 被调用者: []\n\n7. 函数名: min_t\n- 参数: [unsigned int, rqstp->rq_arg.page_len, PAGE_SIZE]\n- 调用者: nfs3svc_decode_symlinkargs\n- 被调用者: []"
  },
  {
    "id": 1532,
    "cwe": "CWE-119",
    "cve": "CVE-2017-7895",
    "purpose": "Code purpose:\"\"\"该代码用于解码NFSv3服务器写入请求参数，并验证数据长度和缓冲区边界。\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"代码在处理NFS请求时未充分验证输入数据的边界，导致可能发生缓冲区溢出或指针算术错误\"\"\"",
    "functions": "Functions:\n1. 函数名: nfs3svc_decode_writeargs\n- 参数: [struct svc_rqst *rqstp, __be32 *p, struct nfsd3_writeargs *args]\n- 调用者: 未显示（由NFS服务调用）\n- 被调用者: [decode_fh, xdr_decode_hyper, ntohl, page_address]\n\n2. 函数名: decode_fh\n- 参数: [__be32 *p, struct nfsd3_writeargs *args]\n- 调用者: nfs3svc_decode_writeargs\n- 被调用者: 未显示\n\n3. 函数名: xdr_decode_hyper\n- 参数: [__be32 *p, &args->offset]\n- 调用者: nfs3svc_decode_writeargs\n- 被调用者: 未显示\n\n4. 函数名: ntohl\n- 参数: [*p++]\n- 调用者: nfs3svc_decode_writeargs\n- 被调用者: 未显示\n\n5. 函数名: page_address\n- 参数: [rqstp->rq_pages[v]]\n- 调用者: nfs3svc_decode_writeargs\n- 被调用者: 未显示\n\n6. 函数名: svc_max_payload\n- 参数: [rqstp]\n- 调用者: nfs3svc_decode_writeargs\n- 被调用者: 未显示"
  },
  {
    "id": 1533,
    "cwe": "CWE-119",
    "cve": "CVE-2017-7895",
    "purpose": "Code purpose:\"\"\"该代码用于解码NFS服务器接收到的写请求参数，包括文件句柄、偏移量和数据长度等，并进行相关验证处理。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核NFSv2和NFSv3服务器实现中缺少对缓冲区结束的充分检查，导致攻击者可通过精心构造的请求触发指针运算错误\"\"\"",
    "functions": "Functions:\n1. 函数名: nfssvc_decode_writeargs\n- 参数: [struct svc_rqst *rqstp, __be32 *p, struct nfsd_writeargs *args]\n- 调用者: 未明确显示（应为NFS服务处理流程中的调用）\n- 被调用者: [decode_fh, ntohl, page_address]\n\n2. 函数名: decode_fh\n- 参数: [__be32 *p, struct nfsd_writeargs *args->fh]\n- 调用者: nfssvc_decode_writeargs\n- 被调用者: 未明确显示\n\n3. 函数名: ntohl\n- 参数: [__be32 *p]\n- 调用者: nfssvc_decode_writeargs\n- 被调用者: 未明确显示\n\n4. 函数名: page_address\n- 参数: [rqstp->rq_pages[v]]\n- 调用者: nfssvc_decode_writeargs\n- 被调用者: 未明确显示"
  },
  {
    "id": 1535,
    "cwe": "CWE-119",
    "cve": "CVE-2017-8061",
    "purpose": "Code purpose:\"\"\"该代码用于通过USB接口向Cypress USB控制器加载固件，包括停止CPU、写入固件数据和重启CPU的过程。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，内核栈使用虚拟内存映射，而代码未正确处理DMA操作与虚拟内存栈的交互，导致可能使用超过一个虚拟页面的DMA分散列表，引发系统崩溃或内存损坏\"\"\"",
    "functions": "Functions:\n1. 函数名: usb_cypress_load_firmware\n- 参数: [struct usb_device *udev, const struct firmware *fw, int type]\n- 调用者: N/A (top-level function)\n- 被调用者: [kmalloc, usb_cypress_writemem, dvb_usb_get_hexline, kfree]\n\n2. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: usb_cypress_load_firmware\n- 被调用者: N/A\n\n3. 函数名: usb_cypress_writemem\n- 参数: [struct usb_device *udev, u16 addr, u8 *data, u16 len]\n- 调用者: usb_cypress_load_firmware\n- 被调用者: N/A\n\n4. 函数名: dvb_usb_get_hexline\n- 参数: [const struct firmware *fw, struct hexline *hx, int *pos]\n- 调用者: usb_cypress_load_firmware\n- 被调用者: N/A\n\n5. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: usb_cypress_load_firmware\n- 被调用者: N/A\n\n6. 函数名: err\n- 参数: [const char *fmt, ...]\n- 调用者: usb_cypress_load_firmware\n- 被调用者: N/A\n\n7. 函数名: deb_fw\n- 参数: [const char *fmt, ...]\n- 调用者: usb_cypress_load_firmware\n- 被调用者: N/A"
  },
  {
    "id": 1536,
    "cwe": "CWE-119",
    "cve": "CVE-2017-8062",
    "purpose": "Code purpose:\"\"\"该代码实现了DVB USB设备通过I2C总线进行数据传输的功能，包括流控制、远程控制查询和常规I2C读写操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，代码在DMA操作中错误地处理了跨多个虚拟页面的栈缓冲区，导致可能发生系统崩溃或内存损坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: su3000_i2c_transfer\n- 参数: [struct i2c_adapter *adap, struct i2c_msg msg[], int num]\n- 调用者: 未显示（应为I2C子系统调用）\n- 被调用者: [i2c_get_adapdata, mutex_lock_interruptible, dvb_usb_generic_rw, memcpy, mutex_unlock, err, warn]\n\n2. 函数名: i2c_get_adapdata\n- 参数: [struct i2c_adapter *adap]\n- 调用者: su3000_i2c_transfer\n- 被调用者: 未显示\n\n3. 函数名: mutex_lock_interruptible\n- 参数: [&d->i2c_mutex]\n- 调用者: su3000_i2c_transfer\n- 被调用者: 未显示\n\n4. 函数名: dvb_usb_generic_rw\n- 参数: [d, obuf, size1, ibuf, size2, 0]（参数数量可变）\n- 调用者: su3000_i2c_transfer\n- 被调用者: 未显示\n\n5. 函数名: memcpy\n- 参数: [&obuf[3], msg[0].buf, msg[0].len] 或 [&obuf[4], msg[0].buf, msg[0].len] 或 [msg[1].buf, &ibuf[1], msg[1].len]\n- 调用者: su3000_i2c_transfer\n- 被调用者: 未显示\n\n6. 函数名: mutex_unlock\n- 参数: [&d->i2c_mutex]\n- 调用者: su3000_i2c_transfer\n- 被调用者: 未显示\n\n7. 函数名: err\n- 参数: [\"i2c transfer failed.\"]\n- 调用者: su3000_i2c_transfer\n- 被调用者: 未显示\n\n8. 函数名: warn\n- 参数: [\"more than 2 i2c messages at a time is not handled yet.\"]\n- 调用者: su3000_i2c_transfer\n- 被调用者: 未显示"
  },
  {
    "id": 1537,
    "cwe": "CWE-119",
    "cve": "CVE-2017-8062",
    "purpose": "Code purpose:\"\"\"控制DVB USB设备的电源状态并在未初始化时进行重置\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，代码在DMA操作中错误地使用了栈分配的缓冲区，导致可能跨越多个虚拟页面的DMA分散列表引发系统崩溃或内存损坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: su3000_power_ctrl\n- 参数: [struct dvb_usb_device *d, int i]\n- 调用者: 未明确（由DVB USB子系统调用）\n- 被调用者: [dvb_usb_generic_rw, info]\n\n2. 函数名: dvb_usb_generic_rw\n- 参数: [struct dvb_usb_device *d, u8 *obuf, int obuf_len, u8 *ibuf, int ibuf_len, int delay_ms]\n- 调用者: su3000_power_ctrl\n- 被调用者: 未明确（底层USB通信函数）\n\n3. 函数名: info\n- 参数: [const char *fmt, ...]\n- 调用者: su3000_power_ctrl\n- 被调用者: 未明确（内核打印函数）"
  },
  {
    "id": 1538,
    "cwe": "CWE-119",
    "cve": "CVE-2017-8062",
    "purpose": "Code purpose:\"\"\"该代码实现了DVB USB设备的调谐器和解调器前端连接功能，包括设备初始化、I2C通信、模块加载和配置等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"内核在使用CONFIG_VMAP_STACK选项时，未能正确处理DMA scatterlist跨越多个虚拟页面的情况，导致本地用户可能引发系统崩溃或内存破坏\"\"\"",
    "functions": "Functions:\n1. 函数名: tt_s2_4600_frontend_attach\n- 参数: [struct dvb_usb_adapter *adap]\n- 调用者: 未显示\n- 被调用者: [dvb_usb_generic_rw, err, msleep, memset, strlcpy, request_module, i2c_new_device, try_module_get, i2c_unregister_device, m88ds3103_pdata.get_dvb_frontend, m88ds3103_pdata.get_i2c_adapter, dvb_frontend_detach]\n\n2. 函数名: dvb_usb_generic_rw\n- 参数: [struct dvb_usb_device *d, u8 *obuf, int olen, u8 *ibuf, int ilen, int delay]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n3. 函数名: err\n- 参数: [const char *fmt, ...]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n4. 函数名: msleep\n- 参数: [unsigned int msecs]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n5. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n6. 函数名: strlcpy\n- 参数: [char *dest, const char *src, size_t size]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n7. 函数名: request_module\n- 参数: [const char *fmt, ...]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n8. 函数名: i2c_new_device\n- 参数: [struct i2c_adapter *adap, struct i2c_board_info const *info]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n9. 函数名: try_module_get\n- 参数: [struct module *module]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n10. 函数名: i2c_unregister_device\n- 参数: [struct i2c_client *client]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n11. 函数名: m88ds3103_pdata.get_dvb_frontend\n- 参数: [struct i2c_client *client]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n12. 函数名: m88ds3103_pdata.get_i2c_adapter\n- 参数: [struct i2c_client *client]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n13. 函数名: dvb_frontend_detach\n- 参数: [struct dvb_frontend *fe]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n14. 函数名: tt_s2_4600_read_status\n- 参数: 未显示\n- 调用者: 未显示\n- 被调用者: tt_s2_4600_frontend_attach (通过函数指针赋值)"
  },
  {
    "id": 1539,
    "cwe": "CWE-119",
    "cve": "CVE-2017-8063",
    "purpose": "Code purpose:\"\"\"该代码用于处理DVB USB设备的控制消息，包括命令发送和数据读写操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，代码未正确处理虚拟内存页边界，导致DMA操作可能跨越多个虚拟页面，引发系统崩溃或其他未指定影响\"\"\"",
    "functions": "Functions:\n1. 函数名: cxusb_ctrl_msg\n- 参数: [struct dvb_usb_device *d, u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [memcpy, dvb_usb_generic_write, dvb_usb_generic_rw, mutex_lock, mutex_unlock]\n\n2. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: cxusb_ctrl_msg\n- 被调用者: []\n\n3. 函数名: dvb_usb_generic_write\n- 参数: [struct dvb_usb_device *d, u8 *buf, int len]\n- 调用者: cxusb_ctrl_msg\n- 被调用者: []\n\n4. 函数名: dvb_usb_generic_rw\n- 参数: [struct dvb_usb_device *d, u8 *wbuf, int wlen, u8 *rbuf, int rlen, int delay_ms]\n- 调用者: cxusb_ctrl_msg\n- 被调用者: []\n\n5. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: cxusb_ctrl_msg\n- 被调用者: []\n\n6. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: cxusb_ctrl_msg\n- 被调用者: []"
  },
  {
    "id": 1540,
    "cwe": "CWE-119",
    "cve": "CVE-2017-8066",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中GS USB CAN驱动程序的探测功能，用于初始化和配置USB接口的CAN设备。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，代码在DMA操作中错误地处理了多虚拟页面的scatterlist，导致可能的内存损坏或系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: gs_usb_probe\n- 参数: [struct usb_interface *intf, const struct usb_device_id *id]\n- 调用者: USB子系统（当设备匹配时）\n- 被调用者: [usb_control_msg, interface_to_usbdev, dev_err, dev_info, kzalloc, init_usb_anchor, atomic_set, usb_set_intfdata, gs_make_candev, IS_ERR_OR_NULL, PTR_ERR, gs_destroy_candev, usb_kill_anchored_urbs, kfree]\n\n2. 函数名: usb_control_msg\n- 参数: [struct usb_device *dev, unsigned int pipe, __u8 request, __u8 requesttype, __u16 value, __u16 index, void *data, __u16 size, int timeout]\n- 调用者: gs_usb_probe\n- 被调用者: USB核心驱动函数\n\n3. 函数名: interface_to_usbdev\n- 参数: [struct usb_interface *intf]\n- 调用者: gs_usb_probe\n- 被调用者: USB核心驱动函数\n\n4. 函数名: dev_err\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: gs_usb_probe\n- 被调用者: 内核日志系统\n\n5. 函数名: dev_info\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: gs_usb_probe\n- 被调用者: 内核日志系统\n\n6. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: gs_usb_probe\n- 被调用者: 内核内存分配系统\n\n7. 函数名: init_usb_anchor\n- 参数: [struct usb_anchor *anchor]\n- 调用者: gs_usb_probe\n- 被调用者: USB核心驱动函数\n\n8. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: gs_usb_probe\n- 被调用者: 内核原子操作函数\n\n9. 函数名: usb_set_intfdata\n- 参数: [struct usb_interface *intf, void *data]\n- 调用者: gs_usb_probe\n- 被调用者: USB核心驱动函数\n\n10. 函数名: gs_make_candev\n- 参数: [int i, struct usb_interface *intf, struct gs_device_config *dconf]\n- 调用者: gs_usb_probe\n- 被调用者: 未知（驱动特定函数）\n\n11. 函数名: IS_ERR_OR_NULL\n- 参数: [const void *ptr]\n- 调用者: gs_usb_probe\n- 被调用者: 内核错误处理宏\n\n12. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: gs_usb_probe\n- 被调用者: 内核错误处理宏\n\n13. 函数名: gs_destroy_candev\n- 参数: [struct gs_can *dev]\n- 调用者: gs_usb_probe\n- 被调用者: 未知（驱动特定函数）\n\n14. 函数名: usb_kill_anchored_urbs\n- 参数: [struct usb_anchor *anchor]\n- 调用者: gs_usb_probe\n- 被调用者: USB核心驱动函数\n\n15. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: gs_usb_probe\n- 被调用者: 内核内存释放函数"
  },
  {
    "id": 1542,
    "cwe": "CWE-119",
    "cve": "CVE-2017-8068",
    "purpose": "Code purpose:\"\"\"通过USB控制消息设置Pegasus USB网络适配器的寄存器值\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，代码未正确处理跨多个虚拟页面的DMA分散列表，导致可能的内存损坏或系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: set_register\n- 参数: [pegasus_t *pegasus, __u16 indx, __u8 data]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [usb_control_msg, netif_dbg]\n\n2. 函数名: usb_control_msg\n- 参数: [pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0), PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data, indx, &data, 1, 1000]\n- 调用者: set_register\n- 被调用者: 未明确（系统函数）\n\n3. 函数名: netif_dbg\n- 参数: [pegasus, drv, pegasus->net, \"%s returned %d\\n\", __func__, ret]\n- 调用者: set_register\n- 被调用者: 未明确（系统函数）\n\n4. 函数名: usb_sndctrlpipe\n- 参数: [pegasus->usb, 0]\n- 调用者: set_register\n- 被调用者: 未明确（系统函数）"
  },
  {
    "id": 1543,
    "cwe": "CWE-119",
    "cve": "CVE-2017-8068",
    "purpose": "Code purpose:\"\"\"通过USB控制消息从Pegasus设备读取寄存器数据\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，代码未正确处理跨多个虚拟页面的DMA分散列表，导致可能的内存损坏或系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: get_registers\n- 参数: [pegasus_t *pegasus, __u16 indx, __u16 size, void *data]\n- 调用者: 未明确（需查看完整代码）\n- 被调用者: [usb_control_msg, netif_dbg]\n\n2. 函数名: usb_control_msg\n- 参数: [pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0), PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0, indx, data, size, 1000]\n- 调用者: get_registers\n- 被调用者: 未明确（系统API）\n\n3. 函数名: usb_rcvctrlpipe\n- 参数: [pegasus->usb, 0]\n- 调用者: usb_control_msg\n- 被调用者: 未明确（系统API）\n\n4. 函数名: netif_dbg\n- 参数: [pegasus, drv, pegasus->net, \"%s returned %d\\n\", __func__, ret]\n- 调用者: get_registers\n- 被调用者: 未明确（内核API）"
  },
  {
    "id": 1544,
    "cwe": "CWE-119",
    "cve": "CVE-2017-8069",
    "purpose": "Code purpose:\"\"\"通过USB控制消息从设备获取寄存器数据\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，该代码未正确处理跨多个虚拟页面的DMA分散/聚集列表，可能导致系统崩溃或内存损坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: get_registers\n- 参数: [rtl8150_t *dev, u16 indx, u16 size, void *data]\n- 调用者: 未指定\n- 被调用者: [usb_control_msg, usb_rcvctrlpipe]\n\n2. 函数名: usb_control_msg\n- 参数: [dev->udev, usb_rcvctrlpipe(dev->udev, 0), RTL8150_REQ_GET_REGS, RTL8150_REQT_READ, indx, 0, data, size, 500]\n- 调用者: get_registers\n- 被调用者: 未指定\n\n3. 函数名: usb_rcvctrlpipe\n- 参数: [dev->udev, 0]\n- 调用者: get_registers\n- 被调用者: 未指定"
  },
  {
    "id": 1577,
    "cwe": "CWE-119",
    "cve": "CVE-2018-1000199",
    "purpose": "Code purpose:\"\"\"修改用户硬件断点的属性并验证其有效性\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在修改硬件断点属性时未正确验证输入参数，可能导致内存损坏或系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: modify_user_hw_breakpoint\n- 参数: [struct perf_event *bp, struct perf_event_attr *attr]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [perf_event_disable_local, perf_event_disable, validate_hw_breakpoint, perf_event_enable]\n\n2. 函数名: perf_event_disable_local\n- 参数: [struct perf_event *bp]\n- 调用者: modify_user_hw_breakpoint\n- 被调用者: 未明确\n\n3. 函数名: perf_event_disable\n- 参数: [struct perf_event *bp]\n- 调用者: modify_user_hw_breakpoint\n- 被调用者: 未明确\n\n4. 函数名: validate_hw_breakpoint\n- 参数: [struct perf_event *bp]\n- 调用者: modify_user_hw_breakpoint\n- 被调用者: 未明确\n\n5. 函数名: perf_event_enable\n- 参数: [struct perf_event *bp]\n- 调用者: modify_user_hw_breakpoint\n- 被调用者: 未明确"
  },
  {
    "id": 1586,
    "cwe": "CWE-119",
    "cve": "CVE-2018-10124",
    "purpose": "Code purpose:\"\"\"该代码用于向指定进程或进程组发送信号，根据不同的pid参数值执行不同的信号发送逻辑\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当传入的pid参数为INT_MIN时，由于整数溢出导致条件判断失效，可能引发拒绝服务攻击\"\"\"",
    "functions": "Functions:\n1. 函数名: kill_something_info\n- 参数: [sig, info, pid]\n- 调用者: 未指定\n- 被调用者: [kill_pid_info, find_vpid, __kill_pgrp_info, task_pgrp, for_each_process, task_pid_vnr, same_thread_group, group_send_sig_info]\n\n2. 函数名: kill_pid_info\n- 参数: [sig, info, pid]\n- 调用者: kill_something_info\n- 被调用者: 未指定\n\n3. 函数名: find_vpid\n- 参数: [pid]\n- 调用者: kill_something_info\n- 被调用者: 未指定\n\n4. 函数名: __kill_pgrp_info\n- 参数: [sig, info, pgrp]\n- 调用者: kill_something_info\n- 被调用者: 未指定\n\n5. 函数名: task_pgrp\n- 参数: [current]\n- 调用者: kill_something_info\n- 被调用者: 未指定\n\n6. 函数名: for_each_process\n- 参数: [p]\n- 调用者: kill_something_info\n- 被调用者: 未指定\n\n7. 函数名: task_pid_vnr\n- 参数: [p]\n- 调用者: kill_something_info\n- 被调用者: 未指定\n\n8. 函数名: same_thread_group\n- 参数: [p, current]\n- 调用者: kill_something_info\n- 被调用者: 未指定\n\n9. 函数名: group_send_sig_info\n- 参数: [sig, info, p]\n- 调用者: kill_something_info\n- 被调用者: 未指定"
  },
  {
    "id": 1629,
    "cwe": "CWE-119",
    "cve": "CVE-2018-10940",
    "purpose": "Code purpose:\"\"\"该代码用于处理CDROM设备中媒体变更的ioctl请求，检查媒体状态变化并返回结果。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在cdrom_ioctl_media_changed函数中，对参数arg的边界检查不充分，导致可以越界访问info->slots数组，从而读取内核内存\"\"\"",
    "functions": "Functions:\n1. 函数名: cdrom_ioctl_media_changed\n- 参数: [struct cdrom_device_info *cdi, unsigned long arg]\n- 调用者: 未指定（由内核IOCTL调用）\n- 被调用者: [media_changed, kmalloc, cdrom_read_mech_status, kfree]\n\n2. 函数名: media_changed\n- 参数: [struct cdrom_device_info *cdi, int arg]\n- 调用者: cdrom_ioctl_media_changed\n- 被调用者: 未指定\n\n3. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: cdrom_ioctl_media_changed\n- 被调用者: 未指定\n\n4. 函数名: cdrom_read_mech_status\n- 参数: [struct cdrom_device_info *cdi, struct cdrom_changer_info *info]\n- 调用者: cdrom_ioctl_media_changed\n- 被调用者: 未指定\n\n5. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: cdrom_ioctl_media_changed\n- 被调用者: 未指定"
  },
  {
    "id": 1635,
    "cwe": "CWE-119",
    "cve": "CVE-2018-1120",
    "purpose": "Code purpose:\"\"\"该代码用于读取并返回指定进程的命令行参数和环境变量信息，通过访问进程的内存空间来获取这些数据。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于内核在读取/proc/<pid>/cmdline文件时未正确处理FUSE-backed文件的mmap映射，导致攻击者可以通过精心构造的映射使读取操作无限期阻塞，造成拒绝服务。\"\"\"",
    "functions": "Functions:\n1. 函数名: proc_pid_cmdline_read\n- 参数: [struct file *file, char __user *buf, size_t _count, loff_t *pos]\n- 调用者: 内核proc文件系统\n- 被调用者: [get_proc_task, file_inode, get_task_mm, put_task_struct, __get_free_page, down_read, up_read, access_remote_vm, copy_to_user, free_page, mmput, min3, strnlen]\n\n2. 函数名: get_proc_task\n- 参数: [struct inode *inode]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n3. 函数名: file_inode\n- 参数: [struct file *file]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n4. 函数名: get_task_mm\n- 参数: [struct task_struct *task]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n5. 函数名: put_task_struct\n- 参数: [struct task_struct *tsk]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n6. 函数名: __get_free_page\n- 参数: [gfp_t gfp_mask]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n7. 函数名: down_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n8. 函数名: up_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n9. 函数名: access_remote_vm\n- 参数: [struct mm_struct *mm, unsigned long addr, void *buf, size_t len, int gup_flags]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n10. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n11. 函数名: free_page\n- 参数: [unsigned long addr]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n12. 函数名: mmput\n- 参数: [struct mm_struct *mm]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n13. 函数名: min3\n- 参数: [type x, type y, type z]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n14. 函数名: strnlen\n- 参数: [const char *s, size_t count]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []"
  },
  {
    "id": 1636,
    "cwe": "CWE-119",
    "cve": "CVE-2018-1120",
    "purpose": "Code purpose:\"\"\"该代码用于从进程的内存中读取环境变量数据并通过/proc文件系统提供给用户空间程序访问。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于未正确处理FUSE文件系统映射到进程内存环境变量时的访问控制，导致攻击者可以通过恶意构造的FUSE文件造成读取/proc/<pid>/environ时无限阻塞或延迟。\"\"\"",
    "functions": "Functions:\n1. 函数名: environ_read\n- 参数: [struct file *file, char __user *buf, size_t count, loff_t *ppos]\n- 调用者: 内核proc文件系统\n- 被调用者: [__get_free_page, mmget_not_zero, down_read, up_read, access_remote_vm, copy_to_user, mmput, free_page]\n\n2. 函数名: __get_free_page\n- 参数: [GFP_KERNEL]\n- 调用者: environ_read\n- 被调用者: []\n\n3. 函数名: mmget_not_zero\n- 参数: [mm]\n- 调用者: environ_read\n- 被调用者: []\n\n4. 函数名: down_read\n- 参数: [&mm->mmap_sem]\n- 调用者: environ_read\n- 被调用者: []\n\n5. 函数名: up_read\n- 参数: [&mm->mmap_sem]\n- 调用者: environ_read\n- 被调用者: []\n\n6. 函数名: access_remote_vm\n- 参数: [mm, (env_start + src), page, this_len, 0]\n- 调用者: environ_read\n- 被调用者: []\n\n7. 函数名: copy_to_user\n- 参数: [buf, page, retval]\n- 调用者: environ_read\n- 被调用者: []\n\n8. 函数名: mmput\n- 参数: [mm]\n- 调用者: environ_read\n- 被调用者: []\n\n9. 函数名: free_page\n- 参数: [(unsigned long) page]\n- 调用者: environ_read\n- 被调用者: []"
  },
  {
    "id": 1637,
    "cwe": "CWE-119",
    "cve": "CVE-2018-1120",
    "purpose": "Code purpose:\"\"\"检查虚拟内存区域(vma)的访问权限是否符合给定的标志位要求，确保内存访问的安全性\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"内核在处理FUSE-backed文件的mmap映射时，未能正确处理/proc/<pid>/cmdline或/proc/<pid>/environ的读取操作，导致拒绝服务攻击\"\"\"",
    "functions": "Functions:\n1. 函数名: check_vma_flags\n- 参数: [struct vm_area_struct *vma, unsigned long gup_flags]\n- 调用者: 未在代码片段中显示\n- 被调用者: [is_cow_mapping, arch_vma_access_permitted]\n\n2. 函数名: is_cow_mapping\n- 参数: [vm_flags_t vm_flags]\n- 调用者: check_vma_flags\n- 被调用者: 未在代码片段中显示\n\n3. 函数名: arch_vma_access_permitted\n- 参数: [struct vm_area_struct *vma, int write, int execute, int foreign]\n- 调用者: check_vma_flags\n- 被调用者: 未在代码片段中显示"
  },
  {
    "id": 1652,
    "cwe": "CWE-119",
    "cve": "CVE-2018-12233",
    "purpose": "Code purpose:\"\"\"该代码用于处理JFS文件系统中扩展属性的获取操作，包括内存分配、属性读取和大小验证等功能。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在JFS文件系统的ea_get函数中，当处理扩展属性时，kmalloc分配的内存大小计算不正确，导致内存越界访问\"\"\"",
    "functions": "Functions:\n1. 函数名: ea_get\n- 参数: [inode, ea_buf, min_size]\n- 调用者: N/A (系统调用或其它内核函数)\n- 被调用者: [jfs_error, kmalloc, kfree, ea_read, dquot_alloc_block, dbAlloc, get_metapage, dbFree, discard_metapage, read_metapage, ea_release, dquot_free_block]\n\n2. 函数名: jfs_error\n- 参数: [sb, error_message]\n- 调用者: ea_get\n- 被调用者: []\n\n3. 函数名: kmalloc\n- 参数: [size, flags]\n- 调用者: ea_get\n- 被调用者: []\n\n4. 函数名: kfree\n- 参数: [ptr]\n- 调用者: ea_get\n- 被调用者: []\n\n5. 函数名: ea_read\n- 参数: [inode, xattr]\n- 调用者: ea_get\n- 被调用者: []\n\n6. 函数名: dquot_alloc_block\n- 参数: [inode, blocks_needed]\n- 调用者: ea_get\n- 被调用者: []\n\n7. 函数名: dbAlloc\n- 参数: [inode, hint, blocks_needed, blkno]\n- 调用者: ea_get\n- 被调用者: []\n\n8. 函数名: get_metapage\n- 参数: [inode, blkno, size, flag]\n- 调用者: ea_get\n- 被调用者: []\n\n9. 函数名: dbFree\n- 参数: [inode, blkno, blocks_needed]\n- 调用者: ea_get\n- 被调用者: []\n\n10. 函数名: discard_metapage\n- 参数: [mp]\n- 调用者: ea_get\n- 被调用者: []\n\n11. 函数名: read_metapage\n- 参数: [inode, address, length, flag]\n- 调用者: ea_get\n- 被调用者: []\n\n12. 函数名: ea_release\n- 参数: [inode, ea_buf]\n- 调用者: ea_get\n- 被调用者: []\n\n13. 函数名: dquot_free_block\n- 参数: [inode, quota_allocation]\n- 调用者: ea_get\n- 被调用者: []"
  },
  {
    "id": 1686,
    "cwe": "CWE-119",
    "cve": "CVE-2018-14615",
    "purpose": "Code purpose:\"\"\"该代码用于检查F2FS文件系统中inode结构的完整性，验证各种可能损坏的情况并设置需要文件系统检查的标志\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在truncate_inline_inode()函数中处理f2fs镜像卸载时，由于未正确验证长度值可能为负数的情况，导致缓冲区溢出漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: sanity_check_inode\n- 参数: [struct inode *inode, struct page *node_page]\n- 调用者: 未明确显示（通常是文件系统操作相关函数）\n- 被调用者: [le64_to_cpu, set_sbi_flag, f2fs_msg, ino_of_node, nid_of_node, f2fs_sb_has_flexible_inline_xattr, f2fs_has_extra_attr, f2fs_sb_has_extra_attr, F2FS_I, f2fs_is_valid_blkaddr]\n\n2. 函数名: le64_to_cpu\n- 参数: [F2FS_INODE(node_page)->i_blocks]\n- 调用者: sanity_check_inode\n- 被调用者: []\n\n3. 函数名: set_sbi_flag\n- 参数: [struct f2fs_sb_info *sbi, SBI_NEED_FSCK]\n- 调用者: sanity_check_inode\n- 被调用者: []\n\n4. 函数名: f2fs_msg\n- 参数: [sbi->sb, KERN_WARNING, format_string, __func__, inode->i_ino, iblocks/ino_of_node(node_page), nid_of_node(node_page)/...]\n- 调用者: sanity_check_inode\n- 被调用者: []\n\n5. 函数名: ino_of_node\n- 参数: [node_page]\n- 调用者: sanity_check_inode\n- 被调用者: []\n\n6. 函数名: nid_of_node\n- 参数: [node_page]\n- 调用者: sanity_check_inode\n- 被调用者: []\n\n7. 函数名: f2fs_sb_has_flexible_inline_xattr\n- 参数: [sbi->sb]\n- 调用者: sanity_check_inode\n- 被调用者: []\n\n8. 函数名: f2fs_has_extra_attr\n- 参数: [inode]\n- 调用者: sanity_check_inode\n- 被调用者: []\n\n9. 函数名: f2fs_sb_has_extra_attr\n- 参数: [sbi->sb]\n- 调用者: sanity_check_inode\n- 被调用者: []\n\n10. 函数名: F2FS_I\n- 参数: [inode]\n- 调用者: sanity_check_inode\n- 被调用者: []\n\n11. 函数名: f2fs_is_valid_blkaddr\n- 参数: [sbi, ei->blk, DATA_GENERIC] 或 [sbi, ei->blk + ei->len - 1, DATA_GENERIC]\n- 调用者: sanity_check_inode\n- 被调用者: []"
  },
  {
    "id": 1786,
    "cwe": "CWE-119",
    "cve": "CVE-2018-20855",
    "purpose": "Code purpose:\"\"\"在Linux内核中创建和管理InfiniBand队列对(QP)，处理不同类型的QP创建请求和相关属性设置\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在create_qp_common函数中，结构体mlx5_ib_create_qp_resp resp未初始化就被使用，导致栈内存信息泄露到用户空间\"\"\"",
    "functions": "Functions:\n1. 函数名: create_qp_common\n- 参数: [struct mlx5_ib_dev *dev, struct ib_pd *pd, struct ib_qp_init_attr *init_attr, struct ib_udata *udata, struct mlx5_ib_qp *qp]\n- 调用者: N/A (顶层函数)\n- 被调用者: [to_mlx5_st, create_rss_raw_qp_tir, to_mlx5_st, ib_copy_from_udata, get_qp_user_index, tunnel_offload_supported, mlx5_get_flow_namespace, set_rq_size, create_user_qp, create_kernel_qp, kvzalloc, is_sqp, to_mpd, is_connected, mlx5_ib_get_cqe_size, get_rx_type, create_raw_packet_qp, mlx5_core_create_qp, kvfree, get_cqs, mlx5_ib_lock_cqs, mlx5_ib_unlock_cqs, destroy_qp_user, destroy_qp_kernel]\n\n2. 函数名: to_mlx5_st\n- 参数: [enum ib_qp_type qp_type]\n- 调用者: create_qp_common\n- 被调用者: []\n\n3. 函数名: create_rss_raw_qp_tir\n- 参数: [struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp, struct ib_pd *pd, struct ib_qp_init_attr *init_attr, struct ib_udata *udata]\n- 调用者: create_qp_common\n- 被调用者: []\n\n4. 函数名: ib_copy_from_udata\n- 参数: [struct mlx5_ib_create_qp *ucmd, struct ib_udata *udata, size_t len]\n- 调用者: create_qp_common\n- 被调用者: []\n\n5. 函数名: get_qp_user_index\n- 参数: [struct mlx5_ib_ucontext *context, struct mlx5_ib_create_qp *ucmd, size_t udata_inlen, u32 *uidx]\n- 调用者: create_qp_common\n- 被调用者: []\n\n6. 函数名: tunnel_offload_supported\n- 参数: [struct mlx5_core_dev *mdev]\n- 调用者: create_qp_common\n- 被调用者: []\n\n7. 函数名: mlx5_get_flow_namespace\n- 参数: [struct mlx5_core_dev *mdev, enum mlx5_flow_namespace_type type]\n- 调用者: create_qp_common\n- 被调用者: []\n\n8. 函数名: set_rq_size\n- 参数: [struct mlx5_ib_dev *dev, struct ib_qp_cap *cap, bool has_rq, struct mlx5_ib_qp *qp, struct mlx5_ib_create_qp *ucmd]\n- 调用者: create_qp_common\n- 被调用者: []\n\n9. 函数名: create_user_qp\n- 参数: [struct mlx5_ib_dev *dev, struct ib_pd *pd, struct mlx5_ib_qp *qp, struct ib_udata *udata, struct ib_qp_init_attr *init_attr, u32 **in, struct mlx5_ib_create_qp_resp *resp, int *inlen, struct mlx5_ib_qp_base *base]\n- 调用者: create_qp_common\n- 被调用者: []\n\n10. 函数名: create_kernel_qp\n- 参数: [struct mlx5_ib_dev *dev, struct ib_qp_init_attr *init_attr, struct mlx5_ib_qp *qp, u32 **in, int *inlen, struct mlx5_ib_qp_base *base]\n- 调用者: create_qp_common\n- 被调用者: []\n\n11. 函数名: kvzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: create_qp_common\n- 被调用者: []\n\n12. 函数名: is_sqp\n- 参数: [enum ib_qp_type qp_type]\n- 调用者: create_qp_common\n- 被调用者: []\n\n13. 函数名: to_mpd\n- 参数: [struct ib_pd *pd]\n- 调用者: create_qp_common\n- 被调用者: []\n\n14. 函数名: is_connected\n- 参数: [enum ib_qp_type qp_type]\n- 调用者: create_qp_common\n- 被调用者: []\n\n15. 函数名: mlx5_ib_get_cqe_size\n- 参数: [struct mlx5_ib_dev *dev, struct ib_cq *cq]\n- 调用者: create_qp_common\n- 被调用者: []\n\n16. 函数名: get_rx_type\n- 参数: [struct mlx5_ib_qp *qp, struct ib_qp_init_attr *init_attr]\n- 调用者: create_qp_common\n- 被调用者: []\n\n17. 函数名: create_raw_packet_qp\n- 参数: [struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp, u32 *in, int inlen, struct ib_pd *pd]\n- 调用者: create_qp_common\n- 被调用者: []\n\n18. 函数名: mlx5_core_create_qp\n- 参数: [struct mlx5_core_dev *mdev, struct mlx5_core_qp *qp, u32 *in, int inlen]\n- 调用者: create_qp_common\n- 被调用者: []\n\n19. 函数名: kvfree\n- 参数: [const void *addr]\n- 调用者: create_qp_common\n- 被调用者: []\n\n20. 函数名: get_cqs\n- 参数: [enum ib_qp_type qp_type, struct ib_cq *send_cq, struct ib_cq *recv_cq, struct mlx5_ib_cq **send_cq_out, struct mlx5_ib_cq **recv_cq_out]\n- 调用者: create_qp_common\n- 被调用者: []\n\n21. 函数名: mlx5_ib_lock_cqs\n- 参数: [struct mlx5_ib_cq *send_cq, struct mlx5_ib_cq *recv_cq]\n- 调用者: create_qp_common\n- 被调用者: []\n\n22. 函数名: mlx5_ib_unlock_cqs\n- 参数: [struct mlx5_ib_cq *send_cq, struct mlx5_ib_cq *recv_cq]\n- 调用者: create_qp_common\n- 被调用者: []\n\n23. 函数名: destroy_qp_user\n- 参数: [struct mlx5_ib_dev *dev, struct ib_pd *pd, struct mlx5_ib_qp *qp, struct mlx5_ib_qp_base *base]\n- 调用者: create_qp_common\n- 被调用者: []\n\n24. 函数名: destroy_qp_kernel\n- 参数: [struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp]\n- 调用者: create_qp_common\n- 被调用者: []"
  },
  {
    "id": 1839,
    "cwe": "CWE-119",
    "cve": "CVE-2018-5848",
    "purpose": "Code purpose:\"\"\"该代码用于设置无线管理信息元素(IE)，通过分配内存、填充命令结构体并发送给无线模块来实现，但存在长度验证不足导致的缓冲区溢出风险\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确处理'ie_len'参数的无符号整数溢出，导致分配的内存缓冲区可能不足，从而引发缓冲区溢出漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: wmi_set_ie\n- 参数: [struct wil6210_priv *wil, u8 type, u16 ie_len, const void *ie]\n- 调用者: 未明确（外部调用）\n- 被调用者: [kzalloc, cpu_to_le16, memcpy, wmi_send, kfree, wil_err]\n\n2. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: wmi_set_ie\n- 被调用者: []\n\n3. 函数名: cpu_to_le16\n- 参数: [__u16 val]\n- 调用者: wmi_set_ie\n- 被调用者: []\n\n4. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: wmi_set_ie\n- 被调用者: []\n\n5. 函数名: wmi_send\n- 参数: [struct wil6210_priv *wil, u16 cmdid, void *buf, u16 len]\n- 调用者: wmi_set_ie\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: wmi_set_ie\n- 被调用者: []\n\n7. 函数名: wil_err\n- 参数: [struct wil6210_priv *wil, const char *fmt, ...]\n- 调用者: wmi_set_ie\n- 被调用者: []"
  },
  {
    "id": 1847,
    "cwe": "CWE-119",
    "cve": "CVE-2018-7566",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中音序器设备的事件写入功能，处理用户空间传递的音频事件数据并将其加入队列。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理可变长度事件数据时，未能充分验证用户提供的扩展数据长度，导致缓冲区溢出漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_seq_write\n- 参数: [struct file *file, const char __user *buf, size_t count, loff_t *offset]\n- 调用者: 未显示（系统调用或驱动接口）\n- 被调用者: [snd_seq_file_flags, snd_BUG_ON, snd_seq_write_pool_allocated, snd_seq_pool_init, copy_from_user, check_event_type_and_length, snd_seq_ev_is_reserved, snd_seq_ev_is_variable, snd_seq_ev_is_varusr, snd_seq_client_enqueue_event]\n\n2. 函数名: snd_seq_file_flags\n- 参数: [struct file *file]\n- 调用者: snd_seq_write\n- 被调用者: []\n\n3. 函数名: snd_BUG_ON\n- 参数: [!client]\n- 调用者: snd_seq_write\n- 被调用者: []\n\n4. 函数名: snd_seq_write_pool_allocated\n- 参数: [struct snd_seq_client *client]\n- 调用者: snd_seq_write\n- 被调用者: []\n\n5. 函数名: snd_seq_pool_init\n- 参数: [client->pool]\n- 调用者: snd_seq_write\n- 被调用者: []\n\n6. 函数名: copy_from_user\n- 参数: [&event, buf, len]\n- 调用者: snd_seq_write\n- 被调用者: []\n\n7. 函数名: check_event_type_and_length\n- 参数: [&event]\n- 调用者: snd_seq_write\n- 被调用者: []\n\n8. 函数名: snd_seq_ev_is_reserved\n- 参数: [&event]\n- 调用者: snd_seq_write\n- 被调用者: []\n\n9. 函数名: snd_seq_ev_is_variable\n- 参数: [&event]\n- 调用者: snd_seq_write\n- 被调用者: []\n\n10. 函数名: snd_seq_ev_is_varusr\n- 参数: [&event]\n- 调用者: snd_seq_write\n- 被调用者: []\n\n11. 函数名: snd_seq_client_enqueue_event\n- 参数: [client, &event, file, !(file->f_flags & O_NONBLOCK), 0, 0]\n- 调用者: snd_seq_write\n- 被调用者: []"
  },
  {
    "id": 1848,
    "cwe": "CWE-119",
    "cve": "CVE-2018-7740",
    "purpose": "Code purpose:\"\"\"该代码实现了hugetlbfs文件的内存映射功能，处理大页面的映射请求并验证相关参数的有效性\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理大页内存映射时，未充分验证remap_file_pages系统调用中的pgoff参数，导致本地用户可通过特制应用程序触发拒绝服务(BUG)。\"\"\"",
    "functions": "Functions:\n1. 函数名: hugetlbfs_file_mmap\n- 参数: [file, vma]\n- 调用者: 未显示（由内核mmap机制调用）\n- 被调用者: [file_inode, hstate_file, inode_lock, file_accessed, hugetlb_reserve_pages, i_size_write, inode_unlock]\n\n2. 函数名: file_inode\n- 参数: [file]\n- 调用者: hugetlbfs_file_mmap\n- 被调用者: []\n\n3. 函数名: hstate_file\n- 参数: [file]\n- 调用者: hugetlbfs_file_mmap\n- 被调用者: []\n\n4. 函数名: inode_lock\n- 参数: [inode]\n- 调用者: hugetlbfs_file_mmap\n- 被调用者: []\n\n5. 函数名: file_accessed\n- 参数: [file]\n- 调用者: hugetlbfs_file_mmap\n- 被调用者: []\n\n6. 函数名: hugetlb_reserve_pages\n- 参数: [inode, vma->vm_pgoff >> huge_page_order(h), len >> huge_page_shift(h), vma, vma->vm_flags]\n- 调用者: hugetlbfs_file_mmap\n- 被调用者: []\n\n7. 函数名: i_size_write\n- 参数: [inode, len]\n- 调用者: hugetlbfs_file_mmap\n- 被调用者: []\n\n8. 函数名: inode_unlock\n- 参数: [inode]\n- 调用者: hugetlbfs_file_mmap\n- 被调用者: []"
  },
  {
    "id": 1849,
    "cwe": "CWE-119",
    "cve": "CVE-2018-7740",
    "purpose": "Code purpose:\"\"\"该代码用于管理大页内存的预留和分配，处理共享和私有内存映射的预留页数计算和调整，确保有足够的大页内存满足映射需求。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理大页内存映射时，由于对remap_file_pages系统调用的pgoff参数缺乏充分验证，导致当传入过大的偏移值时可能触发内核BUG，造成拒绝服务。\"\"\"",
    "functions": "Functions:\n1. 函数名: hugetlb_reserve_pages\n- 参数: [inode, from, to, vma, vm_flags]\n- 调用者: N/A (系统调用或内核其他部分)\n- 被调用者: [hstate_inode, subpool_inode, region_chg, resv_map_alloc, set_vma_resv_map, set_vma_resv_flags, hugepage_subpool_get_pages, hugetlb_acct_memory, hugepage_subpool_put_pages, region_add, region_abort, is_vma_resv_set, kref_put, resv_map_release]\n\n2. 函数名: hstate_inode\n- 参数: [inode]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n3. 函数名: subpool_inode\n- 参数: [inode]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n4. 函数名: inode_resv_map\n- 参数: [inode]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n5. 函数名: region_chg\n- 参数: [resv_map, from, to]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n6. 函数名: resv_map_alloc\n- 参数: []\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n7. 函数名: set_vma_resv_map\n- 参数: [vma, resv_map]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n8. 函数名: set_vma_resv_flags\n- 参数: [vma, HPAGE_RESV_OWNER]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n9. 函数名: hugepage_subpool_get_pages\n- 参数: [spool, chg]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n10. 函数名: hugetlb_acct_memory\n- 参数: [h, gbl_reserve]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n11. 函数名: hugepage_subpool_put_pages\n- 参数: [spool, chg]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n12. 函数名: region_add\n- 参数: [resv_map, from, to]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n13. 函数名: region_abort\n- 参数: [resv_map, from, to]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n14. 函数名: is_vma_resv_set\n- 参数: [vma, HPAGE_RESV_OWNER]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n15. 函数名: kref_put\n- 参数: [&resv_map->refs, resv_map_release]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: [resv_map_release]\n\n16. 函数名: resv_map_release\n- 参数: []\n- 调用者: kref_put\n- 被调用者: []"
  },
  {
    "id": 1861,
    "cwe": "CWE-119",
    "cve": "CVE-2018-8822",
    "purpose": "Code purpose:\"\"\"该代码用于从NCP服务器读取指定文件的数据到内核缓冲区中\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"未正确验证服务器返回的bytes_read长度，导致memcpy操作可能引发缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: ncp_read_kernel\n- 参数: [struct ncp_server *server, const char *file_id, __u32 offset, __u16 to_read, char *target, int *bytes_read]\n- 调用者: 未指定\n- 被调用者: [ncp_init_request, ncp_add_byte, ncp_add_mem, ncp_add_be32, ncp_add_be16, ncp_request, ncp_reply_be16, ncp_reply_data, memcpy, ncp_unlock_server]\n\n2. 函数名: ncp_init_request\n- 参数: [struct ncp_server *server]\n- 调用者: ncp_read_kernel\n- 被调用者: 未指定\n\n3. 函数名: ncp_add_byte\n- 参数: [struct ncp_server *server, int value]\n- 调用者: ncp_read_kernel\n- 被调用者: 未指定\n\n4. 函数名: ncp_add_mem\n- 参数: [struct ncp_server *server, const char *data, int length]\n- 调用者: ncp_read_kernel\n- 被调用者: 未指定\n\n5. 函数名: ncp_add_be32\n- 参数: [struct ncp_server *server, __u32 value]\n- 调用者: ncp_read_kernel\n- 被调用者: 未指定\n\n6. 函数名: ncp_add_be16\n- 参数: [struct ncp_server *server, __u16 value]\n- 调用者: ncp_read_kernel\n- 被调用者: 未指定\n\n7. 函数名: ncp_request\n- 参数: [struct ncp_server *server, int function]\n- 调用者: ncp_read_kernel\n- 被调用者: 未指定\n\n8. 函数名: ncp_reply_be16\n- 参数: [struct ncp_server *server, int offset]\n- 调用者: ncp_read_kernel\n- 被调用者: 未指定\n\n9. 函数名: ncp_reply_data\n- 参数: [struct ncp_server *server, int offset]\n- 调用者: ncp_read_kernel\n- 被调用者: 未指定\n\n10. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: ncp_read_kernel\n- 被调用者: 未指定\n\n11. 函数名: ncp_unlock_server\n- 参数: [struct ncp_server *server]\n- 调用者: ncp_read_kernel\n- 被调用者: 未指定"
  },
  {
    "id": 1991,
    "cwe": "CWE-119",
    "cve": "CVE-2019-15117",
    "purpose": "Code purpose:\"\"\"该代码用于解析USB音频设备中的混音器单元描述符，获取混音器的通道数，并检查描述符的有效性。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理音频混合单元描述符时，未充分验证描述符长度，导致可能访问超出边界的内存\"\"\"",
    "functions": "Functions:\n1. 函数名: uac_mixer_unit_get_channels\n- 参数: [state, desc]\n- 调用者: 未显示\n- 被调用者: [uac_mixer_unit_bNrChannels, get_cluster_channels_v3, uac3_mixer_unit_wClusterDescrID, uac_mixer_unit_bmControls]\n\n2. 函数名: uac_mixer_unit_bNrChannels\n- 参数: [desc]\n- 调用者: uac_mixer_unit_get_channels\n- 被调用者: []\n\n3. 函数名: get_cluster_channels_v3\n- 参数: [state, uac3_mixer_unit_wClusterDescrID(desc)]\n- 调用者: uac_mixer_unit_get_channels\n- 被调用者: []\n\n4. 函数名: uac3_mixer_unit_wClusterDescrID\n- 参数: [desc]\n- 调用者: uac_mixer_unit_get_channels\n- 被调用者: []\n\n5. 函数名: uac_mixer_unit_bmControls\n- 参数: [desc, state->mixer->protocol]\n- 调用者: uac_mixer_unit_get_channels\n- 被调用者: []"
  },
  {
    "id": 2222,
    "cwe": "CWE-119",
    "cve": "CVE-2019-19602",
    "purpose": "Code purpose:\"\"\"验证FPU寄存器状态是否有效，通过检查当前FPU上下文所有者是否为指定CPU且CPU编号匹配\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于GCC 9编译器下fpu_fpregs_owner_ctx缓存处理不当，导致在多核环境下信号抢占时可能引发内存损坏或未定义行为\"\"\"",
    "functions": "Functions:\n1. 函数名: fpregs_state_valid\n- 参数: [struct fpu *fpu, unsigned int cpu]\n- 调用者: 未明确（上下文缺失）\n- 被调用者: [this_cpu_read_stable]\n\n2. 函数名: this_cpu_read_stable\n- 参数: [fpu_fpregs_owner_ctx]\n- 调用者: fpregs_state_valid\n- 被调用者: 未明确（上下文缺失）"
  },
  {
    "id": 2414,
    "cwe": "CWE-119",
    "cve": "CVE-2020-10757",
    "purpose": "Code purpose:\"\"\"该代码用于在内存管理中移动页表，包括处理大页(PMD)的移动和拆分，以及普通页表的移动操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理DAX大页的mremap操作时，未能正确验证和限制内存页面的移动，导致权限提升漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: move_page_tables\n- 参数: [vma, old_addr, new_vma, new_addr, len, need_rmap_locks]\n- 调用者: 未显示\n- 被调用者: [flush_cache_range, mmu_notifier_range_init, mmu_notifier_invalidate_range_start, cond_resched, get_old_pmd, alloc_new_pmd, is_swap_pmd, pmd_trans_huge, take_rmap_locks, move_huge_pmd, drop_rmap_locks, split_huge_pmd, pmd_trans_unstable, move_normal_pmd, pte_alloc, move_ptes, mmu_notifier_invalidate_range_end]\n\n2. 函数名: flush_cache_range\n- 参数: [vma, old_addr, old_end]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n3. 函数名: mmu_notifier_range_init\n- 参数: [&range, MMU_NOTIFY_UNMAP, 0, vma, vma->vm_mm, old_addr, old_end]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n4. 函数名: mmu_notifier_invalidate_range_start\n- 参数: [&range]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n5. 函数名: cond_resched\n- 参数: []\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n6. 函数名: get_old_pmd\n- 参数: [vma->vm_mm, old_addr]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n7. 函数名: alloc_new_pmd\n- 参数: [vma->vm_mm, vma, new_addr]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n8. 函数名: is_swap_pmd\n- 参数: [*old_pmd]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n9. 函数名: pmd_trans_huge\n- 参数: [*old_pmd]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n10. 函数名: take_rmap_locks\n- 参数: [vma]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n11. 函数名: move_huge_pmd\n- 参数: [vma, old_addr, new_addr, old_end, old_pmd, new_pmd]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n12. 函数名: drop_rmap_locks\n- 参数: [vma]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n13. 函数名: split_huge_pmd\n- 参数: [vma, old_pmd, old_addr]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n14. 函数名: pmd_trans_unstable\n- 参数: [old_pmd]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n15. 函数名: move_normal_pmd\n- 参数: [vma, old_addr, new_addr, old_end, old_pmd, new_pmd]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n16. 函数名: pte_alloc\n- 参数: [new_vma->vm_mm, new_pmd]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n17. 函数名: move_ptes\n- 参数: [vma, old_pmd, old_addr, old_addr + extent, new_vma, new_pmd, new_addr, need_rmap_locks]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n18. 函数名: mmu_notifier_invalidate_range_end\n- 参数: [&range]\n- 调用者: move_page_tables\n- 被调用者: 未显示"
  },
  {
    "id": 2880,
    "cwe": "CWE-119",
    "cve": "CVE-2021-22543",
    "purpose": "Code purpose:\"\"\"该代码用于将虚拟机的宿主虚拟地址(HVA)转换为物理页帧号(PFN)，同时处理可能的内存页错误和权限检查\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"KVM在处理VM_IO|VM_PFNMAP类型的虚拟内存区域时，未能正确实施只读权限检查，导致页面在被释放后仍可被VMM和客户机访问，从而引发内存安全问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: hva_to_pfn_remapped\n- 参数: [vma, addr, async, write_fault, writable, p_pfn]\n- 调用者: 未明确显示（通常是KVM相关调用）\n- 被调用者: [follow_pte, fixup_user_fault, pte_write, pte_pfn, kvm_get_pfn, pte_unmap_unlock]\n\n2. 函数名: follow_pte\n- 参数: [vma->vm_mm, addr, &ptep, &ptl]\n- 调用者: hva_to_pfn_remapped\n- 被调用者: 未显示（可能是底层页表操作函数）\n\n3. 函数名: fixup_user_fault\n- 参数: [current->mm, addr, (write_fault ? FAULT_FLAG_WRITE : 0), &unlocked]\n- 调用者: hva_to_pfn_remapped\n- 被调用者: 未显示（可能是内存管理相关函数）\n\n4. 函数名: pte_write\n- 参数: [*ptep]\n- 调用者: hva_to_pfn_remapped\n- 被调用者: 未显示（页表项检查函数）\n\n5. 函数名: pte_pfn\n- 参数: [*ptep]\n- 调用者: hva_to_pfn_remapped\n- 被调用者: 未显示（页表项转换函数）\n\n6. 函数名: kvm_get_pfn\n- 参数: [pfn]\n- 调用者: hva_to_pfn_remapped\n- 被调用者: 未显示（KVM PFN管理函数）\n\n7. 函数名: pte_unmap_unlock\n- 参数: [ptep, ptl]\n- 调用者: hva_to_pfn_remapped\n- 被调用者: 未显示（页表解锁/取消映射函数）"
  },
  {
    "id": 3025,
    "cwe": "CWE-119",
    "cve": "CVE-2021-3635",
    "purpose": "Code purpose:\"\"\"该代码用于清空netfilter表中的规则、集合、流表和对象，并最终删除整个表\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在nft_flush_table函数中，当处理flowtable时未检查nft_is_active_next状态就直接删除，可能导致空指针引用或无效操作引发系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: nft_flush_table\n- 参数: [ctx]\n- 调用者: 无（顶级函数）\n- 被调用者: [nft_is_active_next, nft_delrule_by_chain, nft_delset, nft_delflowtable, nft_delobj, nft_delchain, nft_deltable]\n\n2. 函数名: nft_is_active_next\n- 参数: [ctx->net, chain/set]\n- 调用者: nft_flush_table\n- 被调用者: 无\n\n3. 函数名: nft_delrule_by_chain\n- 参数: [ctx]\n- 调用者: nft_flush_table\n- 被调用者: 无\n\n4. 函数名: nft_delset\n- 参数: [ctx, set]\n- 调用者: nft_flush_table\n- 被调用者: 无\n\n5. 函数名: nft_delflowtable\n- 参数: [ctx, flowtable]\n- 调用者: nft_flush_table\n- 被调用者: 无\n\n6. 函数名: nft_delobj\n- 参数: [ctx, obj]\n- 调用者: nft_flush_table\n- 被调用者: 无\n\n7. 函数名: nft_delchain\n- 参数: [ctx]\n- 调用者: nft_flush_table\n- 被调用者: 无\n\n8. 函数名: nft_deltable\n- 参数: [ctx]\n- 调用者: nft_flush_table\n- 被调用者: 无"
  },
  {
    "id": 3075,
    "cwe": "CWE-119",
    "cve": "CVE-2021-38201",
    "purpose": "Code purpose:\"\"\"该代码用于设置XDR流中基于页面的数据传输的起始位置和长度，并处理相关的边界检查\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证输入参数base和len的边界，导致在计算pgoff和pgend时可能超出页面边界，造成slab-out-of-bounds访问\"\"\"",
    "functions": "Functions:\n1. 函数名: xdr_set_page_base\n- 参数: [xdr, base, len]\n- 调用者: 未明确显示（由外部调用）\n- 被调用者: [xdr_stream_page_set_pos, page_address]\n\n2. 函数名: xdr_stream_page_set_pos\n- 参数: 未明确显示（应为xdr和base）\n- 调用者: xdr_set_page_base\n- 被调用者: []\n\n3. 函数名: page_address\n- 参数: 未明确显示（应为page指针）\n- 调用者: xdr_set_page_base\n- 被调用者: []"
  },
  {
    "id": 3091,
    "cwe": "CWE-119",
    "cve": "CVE-2021-39633",
    "purpose": "Code purpose:\"\"\"处理GRE协议的数据包卸载功能，根据校验和标志选择不同的分段卸载类型\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理GRE协议卸载操作时，由于对sk_buff内存访问不当，导致可能发生无效内存访问的页面错误\"\"\"",
    "functions": "Functions:\n1. 函数名: gre_handle_offloads\n- 参数: [struct sk_buff *skb, bool csum]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [iptunnel_handle_offloads]\n\n2. 函数名: iptunnel_handle_offloads\n- 参数: [struct sk_buff *skb, int gso_type]\n- 调用者: [gre_handle_offloads]\n- 被调用者: 未明确（可能调用内核网络处理相关函数）"
  },
  {
    "id": 3139,
    "cwe": "CWE-119",
    "cve": "CVE-2021-4157",
    "purpose": "Code purpose:\"\"\"解码NFS文件句柄并验证其大小是否合法，然后将数据复制到目标缓冲区\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在decode_nfs_fh函数中，未对fh->size进行足够严格的边界检查，导致可能发生1或2字节的内存越界写入\"\"\"",
    "functions": "Functions:\n1. 函数名: decode_nfs_fh\n- 参数: [struct xdr_stream *xdr, struct nfs_fh *fh]\n- 调用者: 未明确（由NFS子系统调用）\n- 被调用者: [xdr_inline_decode, be32_to_cpup, printk, memcpy, dprintk]\n\n2. 函数名: xdr_inline_decode\n- 参数: [struct xdr_stream *xdr, int size]\n- 调用者: decode_nfs_fh\n- 被调用者: 未明确（底层XDR解码函数）\n\n3. 函数名: be32_to_cpup\n- 参数: [__be32 *p]\n- 调用者: decode_nfs_fh\n- 被调用者: 未明确（字节序转换函数）\n\n4. 函数名: printk\n- 参数: [KERN_ERR, \"NFS flexfiles: Too big fh received %d\\n\", fh->size]\n- 调用者: decode_nfs_fh\n- 被调用者: 未明确（内核打印函数）\n\n5. 函数名: memcpy\n- 参数: [&fh->data, p, fh->size]\n- 调用者: decode_nfs_fh\n- 被调用者: 未明确（内存拷贝函数）\n\n6. 函数名: dprintk\n- 参数: [\"%s: fh len %d\\n\", __func__, fh->size]\n- 调用者: decode_nfs_fh\n- 被调用者: 未明确（调试打印函数）"
  },
  {
    "id": 3151,
    "cwe": "CWE-119",
    "cve": "CVE-2021-4204",
    "purpose": "Code purpose:\"\"\"该代码用于验证BPF函数参数类型与调用时实际传递的参数类型是否匹配，确保内核安全执行BPF程序\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于对函数参数数量和类型的输入验证不充分，导致在处理BPF函数参数时可能发生越界内存访问\"\"\"",
    "functions": "Functions:\n1. 函数名: btf_check_func_arg_match\n- 参数: [struct bpf_verifier_env *env, const struct btf *btf, u32 func_id, struct bpf_reg_state *regs, bool ptr_to_mem_ok]\n- 调用者: 未明确（由BPF验证器调用）\n- 被调用者: [btf_is_kernel, btf_type_by_id, btf_type_is_func, btf_name_by_offset, btf_type_is_func_proto, btf_type_skip_modifiers, btf_type_is_scalar, btf_type_is_ptr, btf_get_prog_ctx_type, check_ctx_reg, btf_type_is_struct, btf_struct_ids_match, __btf_type_is_scalar_struct, btf_resolve_size, check_mem_reg]\n\n2. 函数名: btf_is_kernel\n- 参数: [const struct btf *btf]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n3. 函数名: btf_type_by_id\n- 参数: [const struct btf *btf, u32 id]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n4. 函数名: btf_type_is_func\n- 参数: [const struct btf_type *t]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n5. 函数名: btf_name_by_offset\n- 参数: [const struct btf *btf, u32 offset]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n6. 函数名: btf_type_is_func_proto\n- 参数: [const struct btf_type *t]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n7. 函数名: btf_type_skip_modifiers\n- 参数: [const struct btf *btf, u32 id, u32 *res_id]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n8. 函数名: btf_type_is_scalar\n- 参数: [const struct btf_type *t]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n9. 函数名: btf_type_is_ptr\n- 参数: [const struct btf_type *t]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n10. 函数名: btf_get_prog_ctx_type\n- 参数: [struct bpf_verifier_log *log, const struct btf *btf, const struct btf_type *t, enum bpf_prog_type prog_type, int arg]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n11. 函数名: check_ctx_reg\n- 参数: [struct bpf_verifier_env *env, const struct bpf_reg_state *reg, int regno]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n12. 函数名: btf_type_is_struct\n- 参数: [const struct btf_type *t]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n13. 函数名: btf_struct_ids_match\n- 参数: [struct bpf_verifier_log *log, const struct btf *btf1, u32 id1, int off1, const struct btf *btf2, u32 id2]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n14. 函数名: __btf_type_is_scalar_struct\n- 参数: [struct bpf_verifier_log *log, const struct btf *btf, const struct btf_type *t, int depth]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n15. 函数名: btf_resolve_size\n- 参数: [const struct btf *btf, const struct btf_type *type, u32 *type_size]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n16. 函数名: check_mem_reg\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *reg, int regno, u32 mem_size]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []"
  },
  {
    "id": 3152,
    "cwe": "CWE-119",
    "cve": "CVE-2021-4204",
    "purpose": "Code purpose:\"\"\"该代码用于验证eBPF程序中的函数调用参数，确保参数类型、内存访问权限和边界检查符合安全要求，防止越界访问和非法操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于对eBPF验证器中helper函数参数的内存访问边界检查不充分，导致存在越界内存访问漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: check_func_arg\n- 参数: [struct bpf_verifier_env *env, u32 arg, struct bpf_call_arg_meta *meta, const struct bpf_func_proto *fn]\n- 调用者: N/A (顶层函数)\n- 被调用者: [check_reg_arg, is_pointer_value, may_access_direct_pkt_data, resolve_map_arg_type, register_is_null, check_reg_type, check_ctx_reg, check_helper_mem_access, process_spin_lock, process_timer_func, check_ptr_alignment, check_map_access, map->ops->map_direct_value_addr, strnchr]\n\n2. 函数名: check_reg_arg\n- 参数: [struct bpf_verifier_env *env, u32 regno, int op]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n3. 函数名: is_pointer_value\n- 参数: [struct bpf_verifier_env *env, u32 regno]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n4. 函数名: may_access_direct_pkt_data\n- 参数: [struct bpf_verifier_env *env, struct bpf_call_arg_meta *meta, enum bpf_access_type type]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n5. 函数名: resolve_map_arg_type\n- 参数: [struct bpf_verifier_env *env, struct bpf_call_arg_meta *meta, enum bpf_arg_type *arg_type]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n6. 函数名: register_is_null\n- 参数: [struct bpf_reg_state *reg]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n7. 函数名: check_reg_type\n- 参数: [struct bpf_verifier_env *env, u32 regno, enum bpf_arg_type arg_type, u32 btf_id]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n8. 函数名: check_ctx_reg\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *reg, u32 regno]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n9. 函数名: check_helper_mem_access\n- 参数: [struct bpf_verifier_env *env, u32 regno, u32 access_size, bool zero_size_allowed, struct bpf_call_arg_meta *meta]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n10. 函数名: process_spin_lock\n- 参数: [struct bpf_verifier_env *env, u32 regno, bool is_lock]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n11. 函数名: process_timer_func\n- 参数: [struct bpf_verifier_env *env, u32 regno, struct bpf_call_arg_meta *meta]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n12. 函数名: check_ptr_alignment\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *reg, int off, int size, bool strict]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n13. 函数名: check_map_access\n- 参数: [struct bpf_verifier_env *env, u32 regno, int off, int size, bool zero_size_allowed]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n14. 函数名: map->ops->map_direct_value_addr\n- 参数: [struct bpf_map *map, u64 *addr, int offset]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n15. 函数名: strnchr\n- 参数: [const char *s, size_t count, int c]\n- 调用者: check_func_arg\n- 被调用者: N/A"
  },
  {
    "id": 3153,
    "cwe": "CWE-119",
    "cve": "CVE-2021-4204",
    "purpose": "Code purpose:\"\"\"该代码用于检查eBPF程序中对内存的各种访问操作是否合法，包括对齐检查、边界检查和权限验证，以防止越界访问或非法操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于对内存访问的边界检查不充分，导致在处理eBPF程序时可以触发越界内存访问漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: check_mem_access\n- 参数: [struct bpf_verifier_env *env, int insn_idx, u32 regno, int off, int bpf_size, enum bpf_access_type t, int value_regno, bool strict_alignment_once]\n- 调用者: N/A\n- 被调用者: [bpf_size_to_bytes, check_ptr_alignment, check_mem_region_access, mark_reg_unknown, check_map_access_type, check_map_access, bpf_map_is_rdonly, bpf_map_direct_read, __mark_reg_known, check_ctx_reg, check_ctx_access, check_stack_access_within_bounds, update_stack_depth, check_stack_read, check_stack_write, check_packet_access, check_flow_keys_access, check_sock_access, check_tp_buffer_access, check_ptr_to_btf_access, check_ptr_to_map_access, check_buffer_access, coerce_reg_to_size]\n\n2. 函数名: bpf_size_to_bytes\n- 参数: [int bpf_size]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n3. 函数名: check_ptr_alignment\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *reg, int off, int size, bool strict_alignment_once]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n4. 函数名: check_mem_region_access\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int size, int reg_size, bool zero_size_allowed]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n5. 函数名: mark_reg_unknown\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *regs, int regno]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n6. 函数名: check_map_access_type\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int size, enum bpf_access_type t]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n7. 函数名: check_map_access\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int size, bool zero_size_allowed]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n8. 函数名: bpf_map_is_rdonly\n- 参数: [struct bpf_map *map]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n9. 函数名: bpf_map_direct_read\n- 参数: [struct bpf_map *map, int map_off, int size, u64 *val]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n10. 函数名: __mark_reg_known\n- 参数: [struct bpf_reg_state *reg, u64 val]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n11. 函数名: check_ctx_reg\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *reg, int regno]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n12. 函数名: check_ctx_access\n- 参数: [struct bpf_verifier_env *env, int insn_idx, int off, int size, enum bpf_access_type t, enum bpf_reg_type *reg_type, struct btf **btf, u32 *btf_id]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n13. 函数名: check_stack_access_within_bounds\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int size, enum bpf_access_type type, enum bpf_access_type t]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n14. 函数名: update_stack_depth\n- 参数: [struct bpf_verifier_env *env, struct bpf_func_state *state, int off]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n15. 函数名: check_stack_read\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int size, int value_regno]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n16. 函数名: check_stack_write\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int size, int value_regno, int insn_idx]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n17. 函数名: check_packet_access\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int size, bool zero_size_allowed]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n18. 函数名: check_flow_keys_access\n- 参数: [struct bpf_verifier_env *env, int off, int size]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n19. 函数名: check_sock_access\n- 参数: [struct bpf_verifier_env *env, int insn_idx, int regno, int off, int size, enum bpf_access_type t]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n20. 函数名: check_tp_buffer_access\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *reg, int regno, int off, int size]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n21. 函数名: check_ptr_to_btf_access\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *regs, int regno, int off, int size, enum bpf_access_type t, int value_regno]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n22. 函数名: check_ptr_to_map_access\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *regs, int regno, int off, int size, enum bpf_access_type t, int value_regno]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n23. 函数名: check_buffer_access\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *reg, int regno, int off, int size, bool zero_size_allowed, const char *buf_info, u32 *max_access]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n24. 函数名: coerce_reg_to_size\n- 参数: [struct bpf_reg_state *reg, int size]\n- 调用者: check_mem_access\n- 被调用者: N/A"
  },
  {
    "id": 3154,
    "cwe": "CWE-119",
    "cve": "CVE-2021-4204",
    "purpose": "Code purpose:\"\"\"该代码用于验证eBPF程序中的LD_ABS/LD_IND指令的合法性，确保对网络数据包的安全访问，防止越界内存访问和引用泄漏等安全问题。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于对BPF_LD_[ABS|IND]指令的输入验证不充分，导致在处理eBPF程序时可能发生越界内存访问\"\"\"",
    "functions": "Functions:\n1. 函数名: check_ld_abs\n- 参数: [env, insn]\n- 调用者: 未明确（由BPF验证器调用）\n- 被调用者: [may_access_skb, resolve_prog_type, verbose, cur_regs, check_reg_arg, check_reference_leak, check_ctx_reg, mark_reg_not_init, mark_reg_unknown]\n\n2. 函数名: may_access_skb\n- 参数: [未明确]\n- 调用者: check_ld_abs\n- 被调用者: []\n\n3. 函数名: resolve_prog_type\n- 参数: [未明确]\n- 调用者: check_ld_abs\n- 被调用者: []\n\n4. 函数名: verbose\n- 参数: [env, message]\n- 调用者: check_ld_abs\n- 被调用者: []\n\n5. 函数名: cur_regs\n- 参数: [env]\n- 调用者: check_ld_abs\n- 被调用者: []\n\n6. 函数名: check_reg_arg\n- 参数: [env, reg, op]\n- 调用者: check_ld_abs\n- 被调用者: []\n\n7. 函数名: check_reference_leak\n- 参数: [env]\n- 调用者: check_ld_abs\n- 被调用者: []\n\n8. 函数名: check_ctx_reg\n- 参数: [env, reg, regno]\n- 调用者: check_ld_abs\n- 被调用者: []\n\n9. 函数名: mark_reg_not_init\n- 参数: [env, regs, reg]\n- 调用者: check_ld_abs\n- 被调用者: []\n\n10. 函数名: mark_reg_unknown\n- 参数: [env, regs, reg]\n- 调用者: check_ld_abs\n- 被调用者: []"
  },
  {
    "id": 3525,
    "cwe": "CWE-119",
    "cve": "CVE-2022-2964",
    "purpose": "Code purpose:\"\"\"处理ASIX AX88179_178A USB以太网设备接收到的网络数据包，包括解析包头、校验CRC、分割数据包等操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理网络数据包时未充分验证hdr_off和pkt_len等参数的边界，导致可能发生越界读写\"\"\"",
    "functions": "Functions:\n1. 函数名: ax88179_rx_fixup\n- 参数: [dev, skb]\n- 调用者: 未明确显示（应为USB网络驱动框架）\n- 被调用者: [skb_trim, get_unaligned_le32, skb_tail_pointer, le32_to_cpus, skb_pull, skb_set_tail_pointer, ax88179_rx_checksum, skb_clone, usbnet_skb_return]\n\n2. 函数名: skb_trim\n- 参数: [skb, len]\n- 调用者: ax88179_rx_fixup\n- 被调用者: []\n\n3. 函数名: get_unaligned_le32\n- 参数: [pointer]\n- 调用者: ax88179_rx_fixup\n- 被调用者: []\n\n4. 函数名: skb_tail_pointer\n- 参数: [skb]\n- 调用者: ax88179_rx_fixup\n- 被调用者: []\n\n5. 函数名: le32_to_cpus\n- 参数: [pkt_hdr]\n- 调用者: ax88179_rx_fixup\n- 被调用者: []\n\n6. 函数名: skb_pull\n- 参数: [skb, len]\n- 调用者: ax88179_rx_fixup\n- 被调用者: []\n\n7. 函数名: skb_set_tail_pointer\n- 参数: [skb, len]\n- 调用者: ax88179_rx_fixup\n- 被调用者: []\n\n8. 函数名: ax88179_rx_checksum\n- 参数: [skb, pkt_hdr]\n- 调用者: ax88179_rx_fixup\n- 被调用者: []\n\n9. 函数名: skb_clone\n- 参数: [skb, GFP_ATOMIC]\n- 调用者: ax88179_rx_fixup\n- 被调用者: []\n\n10. 函数名: usbnet_skb_return\n- 参数: [dev, ax_skb]\n- 调用者: ax88179_rx_fixup\n- 被调用者: []"
  },
  {
    "id": 3599,
    "cwe": "CWE-119",
    "cve": "CVE-2022-3435",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的IPv4处理模块中比较和匹配网络路由配置信息与现有路由信息的差异，以确定是否需要更新路由表。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理多路径路由配置时，由于未充分验证rtnh_attrs返回的指针和attrlen长度，导致可能发生越界读取\"\"\"",
    "functions": "Functions:\n1. 函数名: fib_nh_match\n- 参数: [net, cfg, fi, extack]\n- 调用者: 未显示\n- 被调用者: [fib_info_nh, fib_encap_match, rtnh_ok, rtnh_attrlen, rtnh_attrs, nla_find, fib_gw_from_attr, fib_gw_from_via, nla_len, nla_get_u32, rtnh_next]\n\n2. 函数名: fib_info_nh\n- 参数: 未显示\n- 调用者: fib_nh_match\n- 被调用者: 未显示\n\n3. 函数名: fib_encap_match\n- 参数: [net, cfg->fc_encap_type, cfg->fc_encap, nh, cfg, extack]\n- 调用者: fib_nh_match\n- 被调用者: 未显示\n\n4. 函数名: rtnh_ok\n- 参数: [rtnh, remaining]\n- 调用者: fib_nh_match\n- 被调用者: 未显示\n\n5. 函数名: rtnh_attrlen\n- 参数: [rtnh]\n- 调用者: fib_nh_match\n- 被调用者: 未显示\n\n6. 函数名: rtnh_attrs\n- 参数: [rtnh]\n- 调用者: fib_nh_match\n- 被调用者: 未显示\n\n7. 函数名: nla_find\n- 参数: [attrs, attrlen, RTA_GATEWAY/RTA_VIA/RTA_FLOW]\n- 调用者: fib_nh_match\n- 被调用者: 未显示\n\n8. 函数名: fib_gw_from_attr\n- 参数: [&gw, nla, extack]\n- 调用者: fib_nh_match\n- 被调用者: 未显示\n\n9. 函数名: fib_gw_from_via\n- 参数: [&cfg2, nlav, extack]\n- 调用者: fib_nh_match\n- 被调用者: 未显示\n\n10. 函数名: nla_len\n- 参数: [nla]\n- 调用者: fib_nh_match\n- 被调用者: 未显示\n\n11. 函数名: nla_get_u32\n- 参数: [nla]\n- 调用者: fib_nh_match\n- 被调用者: 未显示\n\n12. 函数名: rtnh_next\n- 参数: [rtnh, &remaining]\n- 调用者: fib_nh_match\n- 被调用者: 未显示"
  },
  {
    "id": 3631,
    "cwe": "CWE-119",
    "cve": "CVE-2022-3541",
    "purpose": "Code purpose:\"\"\"从设备树节点中读取MAC地址并验证其有效性后复制到指定缓冲区\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在检查MAC地址有效性后释放了内存，但在打印无效MAC地址信息时又引用了已释放的内存，导致use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: spl2sw_nvmem_get_mac_address\n- 参数: [dev, np, addrbuf]\n- 调用者: 未指定\n- 被调用者: [of_nvmem_cell_get, nvmem_cell_read, nvmem_cell_put, IS_ERR, kfree, spl2sw_check_mac_vendor_id_and_convert, is_valid_ether_addr, ether_addr_copy]\n\n2. 函数名: of_nvmem_cell_get\n- 参数: [np, \"mac-address\"]\n- 调用者: spl2sw_nvmem_get_mac_address\n- 被调用者: 未指定\n\n3. 函数名: nvmem_cell_read\n- 参数: [cell, &len]\n- 调用者: spl2sw_nvmem_get_mac_address\n- 被调用者: 未指定\n\n4. 函数名: nvmem_cell_put\n- 参数: [cell]\n- 调用者: spl2sw_nvmem_get_mac_address\n- 被调用者: 未指定\n\n5. 函数名: IS_ERR\n- 参数: [cell], [mac]\n- 调用者: spl2sw_nvmem_get_mac_address\n- 被调用者: 未指定\n\n6. 函数名: kfree\n- 参数: [mac]\n- 调用者: spl2sw_nvmem_get_mac_address\n- 被调用者: 未指定\n\n7. 函数名: spl2sw_check_mac_vendor_id_and_convert\n- 参数: [mac]\n- 调用者: spl2sw_nvmem_get_mac_address\n- 被调用者: 未指定\n\n8. 函数名: is_valid_ether_addr\n- 参数: [mac]\n- 调用者: spl2sw_nvmem_get_mac_address\n- 被调用者: 未指定\n\n9. 函数名: ether_addr_copy\n- 参数: [addrbuf, mac]\n- 调用者: spl2sw_nvmem_get_mac_address\n- 被调用者: 未指定"
  },
  {
    "id": 3635,
    "cwe": "CWE-119",
    "cve": "CVE-2022-3545",
    "purpose": "Code purpose:\"\"\"该代码用于管理NFP(Netronome Flow Processor)的CPP(Common Physical Port)区域缓存，处理内存区域的获取、匹配和初始化操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在释放缓存区域后未正确更新相关指针或引用，导致后续操作可能访问已释放的内存区域，造成use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: area_cache_get\n- 参数: [struct nfp_cpp *cpp, u32 id, u64 addr, unsigned long *offset, size_t length]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [nfp_target_cpp, mutex_lock, mutex_unlock, list_empty, list_for_each_entry, list_entry, round_down, nfp_cpp_area_release, nfp_cpp_area_acquire]\n\n2. 函数名: nfp_target_cpp\n- 参数: [u32 id, u64 addr, u32 *id_out, u64 *addr_out, void *imb_cat_table]\n- 调用者: area_cache_get\n- 被调用者: 未明确\n\n3. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: area_cache_get\n- 被调用者: 未明确\n\n4. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: area_cache_get\n- 被调用者: 未明确\n\n5. 函数名: list_empty\n- 参数: [struct list_head *head]\n- 调用者: area_cache_get\n- 被调用者: 未明确\n\n6. 函数名: list_for_each_entry\n- 参数: [struct nfp_cpp_area_cache *cache, struct list_head *head, struct list_head *entry]\n- 调用者: area_cache_get\n- 被调用者: 未明确\n\n7. 函数名: list_entry\n- 参数: [struct list_head *ptr, struct nfp_cpp_area_cache, struct list_head *entry]\n- 调用者: area_cache_get\n- 被调用者: 未明确\n\n8. 函数名: round_down\n- 参数: [u64 addr, size_t size]\n- 调用者: area_cache_get\n- 被调用者: 未明确\n\n9. 函数名: nfp_cpp_area_release\n- 参数: [struct nfp_cpp_area *area]\n- 调用者: area_cache_get\n- 被调用者: 未明确\n\n10. 函数名: nfp_cpp_area_acquire\n- 参数: [struct nfp_cpp_area *area]\n- 调用者: area_cache_get\n- 被调用者: 未明确"
  },
  {
    "id": 3660,
    "cwe": "CWE-119",
    "cve": "CVE-2022-3625",
    "purpose": "Code purpose:\"\"\"该代码片段实现了从devlink中获取参数值的功能，通过调用参数的回调函数get来完成参数查询操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在devlink_param_get函数中未对param指针进行有效性验证，可能导致在param已被释放后仍被访问，造成use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: devlink_param_get\n- 参数: [struct devlink *devlink, const struct devlink_param *param, struct devlink_param_gset_ctx *ctx]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [param->get]\n\n2. 函数名: param->get\n- 参数: [struct devlink *devlink, param->id, struct devlink_param_gset_ctx *ctx]\n- 调用者: devlink_param_get\n- 被调用者: 未明确（由函数指针调用）"
  },
  {
    "id": 3661,
    "cwe": "CWE-119",
    "cve": "CVE-2022-3625",
    "purpose": "Code purpose:\"\"\"该代码片段实现了devlink参数的设置功能，通过调用参数提供的set回调函数来完成参数值的设置操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在devlink_param_set函数中未对参数进行充分验证，导致在调用param->set时可能发生释放后使用(UAF)漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: devlink_param_set\n- 参数: [devlink, param, ctx]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [param->set]"
  },
  {
    "id": 3669,
    "cwe": "CWE-119",
    "cve": "CVE-2022-3636",
    "purpose": "Code purpose:\"\"\"检查网络数据包并根据哈希值在流表中查找或更新对应的流条目\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在释放锁之前未正确验证entry指针的有效性，导致可能访问已释放的内存区域\"\"\"",
    "functions": "Functions:\n1. 函数名: __mtk_ppe_check_skb\n- 参数: [struct mtk_ppe *ppe, struct sk_buff *skb, u16 hash]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [FIELD_GET, eth_hdr, ether_addr_copy, get_unaligned_be16, rhashtable_lookup_fast, __mtk_foe_entry_clear, __mtk_foe_entry_commit, mtk_flow_entry_match, mtk_foe_entry_commit_subflow]\n\n2. 函数名: FIELD_GET\n- 参数: [未明确]\n- 调用者: __mtk_ppe_check_skb\n- 被调用者: []\n\n3. 函数名: eth_hdr\n- 参数: [struct sk_buff *skb]\n- 调用者: __mtk_ppe_check_skb\n- 被调用者: []\n\n4. 函数名: ether_addr_copy\n- 参数: [未明确]\n- 调用者: __mtk_ppe_check_skb\n- 被调用者: []\n\n5. 函数名: get_unaligned_be16\n- 参数: [未明确]\n- 调用者: __mtk_ppe_check_skb\n- 被调用者: []\n\n6. 函数名: rhashtable_lookup_fast\n- 参数: [未明确]\n- 调用者: __mtk_ppe_check_skb\n- 被调用者: []\n\n7. 函数名: __mtk_foe_entry_clear\n- 参数: [struct mtk_ppe *ppe, struct mtk_flow_entry *entry]\n- 调用者: __mtk_ppe_check_skb\n- 被调用者: []\n\n8. 函数名: __mtk_foe_entry_commit\n- 参数: [struct mtk_ppe *ppe, struct mtk_foe_entry *data, u16 hash]\n- 调用者: __mtk_ppe_check_skb\n- 被调用者: []\n\n9. 函数名: mtk_flow_entry_match\n- 参数: [struct mtk_flow_entry *entry, struct mtk_foe_entry *hwe]\n- 调用者: __mtk_ppe_check_skb\n- 被调用者: []\n\n10. 函数名: mtk_foe_entry_commit_subflow\n- 参数: [struct mtk_ppe *ppe, struct mtk_flow_entry *entry, u16 hash]\n- 调用者: __mtk_ppe_check_skb\n- 被调用者: []"
  },
  {
    "id": 3670,
    "cwe": "CWE-119",
    "cve": "CVE-2022-3640",
    "purpose": "Code purpose:\"\"\"处理蓝牙L2CAP协议中的数据通道通信，包括通道管理、数据接收和错误处理\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在蓝牙L2CAP协议处理过程中，当连接被删除时未能正确处理通道引用计数，导致释放后仍可能被使用的use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: l2cap_data_channel\n- 参数: [conn, cid, skb]\n- 调用者: 未显示\n- 被调用者: [l2cap_get_chan_by_scid, a2mp_channel_create, kfree_skb, l2cap_chan_lock, BT_DBG, l2cap_chan_ready, l2cap_ecred_data_rcv, l2cap_data_rcv, BT_ERR, chan->ops->recv, l2cap_chan_unlock, l2cap_chan_put]\n\n2. 函数名: l2cap_get_chan_by_scid\n- 参数: [conn, cid]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示\n\n3. 函数名: a2mp_channel_create\n- 参数: [conn, skb]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示\n\n4. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示\n\n5. 函数名: l2cap_chan_lock\n- 参数: [chan]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示\n\n6. 函数名: BT_DBG\n- 参数: [format string, ...]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示\n\n7. 函数名: l2cap_chan_ready\n- 参数: [chan]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示\n\n8. 函数名: l2cap_ecred_data_rcv\n- 参数: [chan, skb]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示\n\n9. 函数名: l2cap_data_rcv\n- 参数: [chan, skb]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示\n\n10. 函数名: BT_ERR\n- 参数: [format string]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示\n\n11. 函数名: chan->ops->recv\n- 参数: [chan, skb]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示\n\n12. 函数名: l2cap_chan_unlock\n- 参数: [chan]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示\n\n13. 函数名: l2cap_chan_put\n- 参数: [chan]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示"
  },
  {
    "id": 3676,
    "cwe": "CWE-119",
    "cve": "CVE-2022-3649",
    "purpose": "Code purpose:\"\"\"该代码用于在NILFS2文件系统中创建新的inode节点并初始化相关属性\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在nilfs_new_inode函数中，当初始化ACL失败时，错误处理路径可能导致已分配的inode资源被释放后仍被使用，造成use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: nilfs_new_inode\n- 参数: [dir, mode]\n- 调用者: 未指定\n- 被调用者: [new_inode, mapping_set_gfp_mask, mapping_gfp_constraint, nilfs_ifile_create_inode, atomic64_inc, inode_init_owner, current_time, nilfs_bmap_read, nilfs_mask_flags, nilfs_set_inode_flags, nilfs_insert_inode_locked, nilfs_init_acl, clear_nlink, unlock_new_inode, iput, make_bad_inode, ERR_PTR]\n\n2. 函数名: new_inode\n- 参数: [sb]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n3. 函数名: mapping_set_gfp_mask\n- 参数: [inode->i_mapping, mapping_gfp_constraint(...)]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n4. 函数名: mapping_gfp_constraint\n- 参数: [inode->i_mapping, ~__GFP_FS]\n- 调用者: mapping_set_gfp_mask\n- 被调用者: 未指定\n\n5. 函数名: nilfs_ifile_create_inode\n- 参数: [root->ifile, &ino, &ii->i_bh]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n6. 函数名: atomic64_inc\n- 参数: [&root->inodes_count]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n7. 函数名: inode_init_owner\n- 参数: [&init_user_ns, inode, dir, mode]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n8. 函数名: current_time\n- 参数: [inode]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n9. 函数名: nilfs_bmap_read\n- 参数: [ii->i_bmap, NULL]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n10. 函数名: nilfs_mask_flags\n- 参数: [mode, NILFS_I(dir)->i_flags & NILFS_FL_INHERITED]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n11. 函数名: nilfs_set_inode_flags\n- 参数: [inode]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n12. 函数名: nilfs_insert_inode_locked\n- 参数: [inode, root, ino]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n13. 函数名: nilfs_init_acl\n- 参数: [inode, dir]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n14. 函数名: clear_nlink\n- 参数: [inode]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n15. 函数名: unlock_new_inode\n- 参数: [inode]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n16. 函数名: iput\n- 参数: [inode]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n17. 函数名: make_bad_inode\n- 参数: [inode]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n18. 函数名: ERR_PTR\n- 参数: [err]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定"
  },
  {
    "id": 3918,
    "cwe": "CWE-119",
    "cve": "CVE-2023-21264",
    "purpose": "Code purpose:\"\"\"检查页面状态并验证内存访问权限，确保只有允许的内存区域被访问\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"内存访问检查位置不当导致可能访问到hypervisor内存\"\"\"",
    "functions": "Functions:\n1. 函数名: __check_page_state_visitor\n- 参数: [const struct kvm_pgtable_visit_ctx *ctx, enum kvm_pgtable_walk_flags visit]\n- 调用者: 未明确（可能是kvm_pgtable_walk相关函数）\n- 被调用者: [kvm_pte_valid, addr_is_allowed_memory, kvm_pte_to_phys]\n\n2. 函数名: kvm_pte_valid\n- 参数: [ctx->old]\n- 调用者: __check_page_state_visitor\n- 被调用者: []\n\n3. 函数名: addr_is_allowed_memory\n- 参数: [kvm_pte_to_phys(ctx->old)]\n- 调用者: __check_page_state_visitor\n- 被调用者: []\n\n4. 函数名: kvm_pte_to_phys\n- 参数: [ctx->old]\n- 调用者: __check_page_state_visitor\n- 被调用者: []"
  },
  {
    "id": 4303,
    "cwe": "CWE-119",
    "cve": "CVE-2023-6560",
    "purpose": "Code purpose:\"\"\"将用户空间的连续内存区域映射到内核空间，并确保其物理页面的连续性和可访问性\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证用户空间提供的uaddr和size参数，导致在pin_user_pages_fast操作时可能发生越界内存访问\"\"\"",
    "functions": "Functions:\n1. 函数名: __io_uaddr_map\n- 参数: [struct page ***pages, unsigned short *npages, unsigned long uaddr, size_t size]\n- 调用者: 未显示（上下文缺失）\n- 被调用者: [ERR_PTR, kvmalloc_array, pin_user_pages_fast, io_pages_free, PageHighMem, page_to_virt]\n\n2. 函数名: ERR_PTR\n- 参数: [long error]\n- 调用者: __io_uaddr_map\n- 被调用者: 未显示（假设为内核API）\n\n3. 函数名: kvmalloc_array\n- 参数: [size_t n, size_t size, gfp_t flags]\n- 调用者: __io_uaddr_map\n- 被调用者: 未显示（内核内存分配API）\n\n4. 函数名: pin_user_pages_fast\n- 参数: [unsigned long start, unsigned long nr_pages, unsigned int gup_flags, struct page **pages]\n- 调用者: __io_uaddr_map\n- 被调用者: 未显示（内核页管理API）\n\n5. 函数名: io_pages_free\n- 参数: [struct page ***pages, int npages]\n- 调用者: __io_uaddr_map\n- 被调用者: 未显示（上下文缺失）\n\n6. 函数名: PageHighMem\n- 参数: [struct page *page]\n- 调用者: __io_uaddr_map\n- 被调用者: 未显示（内核页管理API）\n\n7. 函数名: page_to_virt\n- 参数: [struct page *page]\n- 调用者: __io_uaddr_map\n- 被调用者: 未显示（内核地址转换API）"
  },
  {
    "id": 63,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3511",
    "purpose": "Code purpose:\"\"\"该代码用于实现内存建议(madvise)功能中的移除操作，通过释放指定内存区域并打洞(punch hole)来优化内存使用，但存在竞争条件漏洞可能导致使用后释放问题。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在释放mmap_sem信号量后执行do_fallocate操作期间，存在竞争条件可能导致内存区域被munmap或close系统调用释放，造成后续使用已释放内存的use-after-free问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: madvise_remove\n- 参数: [struct vm_area_struct *vma, struct vm_area_struct **prev, unsigned long start, unsigned long end]\n- 调用者: sys_madvise\n- 被调用者: [do_fallocate, up_read, down_read]\n\n2. 函数名: do_fallocate\n- 参数: [struct file *file, int mode, loff_t offset, loff_t len]\n- 调用者: madvise_remove\n- 被调用者: []\n\n3. 函数名: up_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: madvise_remove\n- 被调用者: []\n\n4. 函数名: down_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: madvise_remove\n- 被调用者: []"
  },
  {
    "id": 64,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"处理DCCP协议IPv4连接请求，创建新的子socket并设置相关网络参数\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理网络流量时，应用程序设置套接字选项的过程中存在竞争条件，可能导致slab损坏和系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: dccp_v4_request_recv_sock\n- 参数: [sk, skb, req, dst]\n- 调用者: 未显示（通常由网络协议栈调用）\n- 被调用者: [sk_acceptq_is_full, inet_csk_route_req, dccp_create_openreq_child, sk_setup_caps, inet_sk, inet_rsk, ip_hdr, dccp_sync_mss, __inet_inherit_port, sock_put, dst_release, NET_INC_STATS_BH, sock_net, __inet_hash_nolisten]\n\n2. 函数名: sk_acceptq_is_full\n- 参数: [sk]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n3. 函数名: inet_csk_route_req\n- 参数: [sk, req]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n4. 函数名: dccp_create_openreq_child\n- 参数: [sk, req, skb]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n5. 函数名: sk_setup_caps\n- 参数: [newsk, dst]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n6. 函数名: inet_sk\n- 参数: [newsk]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n7. 函数名: inet_rsk\n- 参数: [req]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n8. 函数名: ip_hdr\n- 参数: [skb]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n9. 函数名: dccp_sync_mss\n- 参数: [newsk, dst_mtu(dst)]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n10. 函数名: __inet_inherit_port\n- 参数: [sk, newsk]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n11. 函数名: sock_put\n- 参数: [newsk]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n12. 函数名: dst_release\n- 参数: [dst]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n13. 函数名: NET_INC_STATS_BH\n- 参数: [sock_net(sk), LINUX_MIB_LISTENOVERFLOWS/LINUX_MIB_LISTENDROPS]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n14. 函数名: sock_net\n- 参数: [sk]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n15. 函数名: __inet_hash_nolisten\n- 参数: [newsk, NULL]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []"
  },
  {
    "id": 65,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"实现DCCP协议在IPv4下的客户端连接功能，包括路由查找、端口绑定和连接建立等操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理网络流量时，应用程序设置套接字选项的过程中存在竞态条件，可能导致slab损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: dccp_v4_connect\n- 参数: [struct sock *sk, struct sockaddr *uaddr, int addr_len]\n- 调用者: 无（顶层函数）\n- 被调用者: [inet_sk, dccp_sk, ip_route_connect, IS_ERR, PTR_ERR, ip_rt_put, inet_csk, dccp_set_state, inet_hash_connect, ip_route_newports, sk_setup_caps, secure_dccp_sequence_number, dccp_connect]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n3. 函数名: dccp_sk\n- 参数: [struct sock *sk]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n4. 函数名: ip_route_connect\n- 参数: [struct flowi4 *fl4, __be32 nexthop, __be32 saddr, unsigned int flags, int oif, u8 protocol, __be16 sport, __be16 dport, struct sock *sk, bool can_sleep]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n5. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n6. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n7. 函数名: ip_rt_put\n- 参数: [struct rtable *rt]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n8. 函数名: inet_csk\n- 参数: [struct sock *sk]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n9. 函数名: dccp_set_state\n- 参数: [struct sock *sk, enum dccp_state state]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n10. 函数名: inet_hash_connect\n- 参数: [struct inet_timewait_death_row *death_row, struct sock *sk]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n11. 函数名: ip_route_newports\n- 参数: [struct flowi4 *fl4, struct rtable *rt, __be16 orig_sport, __be16 orig_dport, __be16 sport, __be16 dport, struct sock *sk]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n12. 函数名: sk_setup_caps\n- 参数: [struct sock *sk, struct dst_entry *dst]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n13. 函数名: secure_dccp_sequence_number\n- 参数: [__be32 saddr, __be32 daddr, __be16 sport, __be16 dport]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n14. 函数名: dccp_connect\n- 参数: [struct sock *sk]\n- 调用者: dccp_v4_connect\n- 被调用者: 无"
  },
  {
    "id": 66,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"处理IPv6 DCCP协议的网络请求，创建新的子socket并继承父socket的相关配置，同时处理IPv4到IPv6的地址映射。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理网络流量时，应用程序设置套接字选项的操作与网络数据包处理之间存在竞争条件，导致slab损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: dccp_v6_request_recv_sock\n- 参数: [sk, skb, req, dst]\n- 调用者: 无（顶层函数）\n- 被调用者: [dccp_v4_request_recv_sock, inet6_rsk, inet_sk, inet6_sk, htons, memcpy, ipv6_addr_set_v4mapped, ipv6_addr_copy, inet_csk, dccp_v4_do_rcv, inet6_iif, ipv6_hdr, dccp_sync_mss, sk_acceptq_is_full, memset, fl6_update_dst, security_sk_classify_flow, ip6_dst_lookup_flow, IS_ERR, dccp_create_openreq_child, __ip6_dst_store, skb_clone, kfree_skb, skb_set_owner_r, ipv6_dup_options, sock_kfree_s, dst_mtu, __inet_inherit_port, sock_put, __inet6_hash, dst_release, NET_INC_STATS_BH]\n\n2. 函数名: dccp_v4_request_recv_sock\n- 参数: [sk, skb, req, dst]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n3. 函数名: inet6_rsk\n- 参数: [req]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n4. 函数名: inet_sk\n- 参数: [newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n5. 函数名: inet6_sk\n- 参数: [newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n6. 函数名: htons\n- 参数: [ETH_P_IP]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n7. 函数名: memcpy\n- 参数: [newnp, np, sizeof(struct ipv6_pinfo)]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（标准库函数）\n\n8. 函数名: ipv6_addr_set_v4mapped\n- 参数: [newinet->inet_daddr, &newnp->daddr]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n9. 函数名: ipv6_addr_copy\n- 参数: [&newnp->rcv_saddr, &newnp->saddr]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n10. 函数名: inet_csk\n- 参数: [newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n11. 函数名: dccp_v4_do_rcv\n- 参数: 无（函数指针）\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n12. 函数名: inet6_iif\n- 参数: [skb]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n13. 函数名: ipv6_hdr\n- 参数: [skb]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n14. 函数名: dccp_sync_mss\n- 参数: [newsk, inet_csk(newsk)->icsk_pmtu_cookie]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n15. 函数名: sk_acceptq_is_full\n- 参数: [sk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n16. 函数名: memset\n- 参数: [&fl6, 0, sizeof(fl6)]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（标准库函数）\n\n17. 函数名: fl6_update_dst\n- 参数: [&fl6, opt, &final]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n18. 函数名: security_sk_classify_flow\n- 参数: [sk, flowi6_to_flowi(&fl6)]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n19. 函数名: ip6_dst_lookup_flow\n- 参数: [sk, &fl6, final_p, false]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n20. 函数名: IS_ERR\n- 参数: [dst]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n21. 函数名: dccp_create_openreq_child\n- 参数: [sk, req, skb]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n22. 函数名: __ip6_dst_store\n- 参数: [newsk, dst, NULL, NULL]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n23. 函数名: skb_clone\n- 参数: [ireq6->pktopts, GFP_ATOMIC]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n24. 函数名: kfree_skb\n- 参数: [ireq6->pktopts]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n25. 函数名: skb_set_owner_r\n- 参数: [newnp->pktoptions, newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n26. 函数名: ipv6_dup_options\n- 参数: [newsk, opt]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n27. 函数名: sock_kfree_s\n- 参数: [sk, opt, opt->tot_len]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n28. 函数名: dst_mtu\n- 参数: [dst]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n29. 函数名: __inet_inherit_port\n- 参数: [sk, newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n30. 函数名: sock_put\n- 参数: [newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n31. 函数名: __inet6_hash\n- 参数: [newsk, NULL]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n32. 函数名: dst_release\n- 参数: [dst]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n33. 函数名: NET_INC_STATS_BH\n- 参数: [sock_net(sk), LINUX_MIB_LISTENOVERFLOWS]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）"
  },
  {
    "id": 67,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"重建IP套接字的网络路由信息，处理路由失败情况并返回错误码\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送数据包导致slab损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: inet_sk_rebuild_header\n- 参数: [struct sock *sk]\n- 调用者: 未指定\n- 被调用者: [inet_sk, __sk_dst_check, ip_route_output_ports, sock_net, sk_setup_caps, PTR_ERR, inet_sk_reselect_saddr]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: inet_sk_rebuild_header\n- 被调用者: 未指定\n\n3. 函数名: __sk_dst_check\n- 参数: [struct sock *sk, int cookie]\n- 调用者: inet_sk_rebuild_header\n- 被调用者: 未指定\n\n4. 函数名: ip_route_output_ports\n- 参数: [struct net *net, struct sock *sk, __be32 daddr, __be32 saddr, __be16 dport, __be16 sport, u8 proto, u32 flags, int ifindex]\n- 调用者: inet_sk_rebuild_header\n- 被调用者: 未指定\n\n5. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: inet_sk_rebuild_header\n- 被调用者: 未指定\n\n6. 函数名: sk_setup_caps\n- 参数: [struct sock *sk, struct dst_entry *dst]\n- 调用者: inet_sk_rebuild_header\n- 被调用者: 未指定\n\n7. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: inet_sk_rebuild_header\n- 被调用者: 未指定\n\n8. 函数名: inet_sk_reselect_saddr\n- 参数: [struct sock *sk]\n- 调用者: inet_sk_rebuild_header\n- 被调用者: 未指定"
  },
  {
    "id": 68,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"释放inet套接字资源并检查其状态是否合法\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送数据包导致slab损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: inet_sock_destruct\n- 参数: [struct sock *sk]\n- 调用者: 未显示（通常由内核网络子系统调用）\n- 被调用者: [inet_sk, __skb_queue_purge, sk_mem_reclaim, pr_err, atomic_read, WARN_ON, kfree, dst_release, rcu_dereference_check, sk_refcnt_debug_dec]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: inet_sock_destruct\n- 被调用者: []\n\n3. 函数名: __skb_queue_purge\n- 参数: [&sk->sk_receive_queue, &sk->sk_error_queue]\n- 调用者: inet_sock_destruct\n- 被调用者: []\n\n4. 函数名: sk_mem_reclaim\n- 参数: [struct sock *sk]\n- 调用者: inet_sock_destruct\n- 被调用者: []\n\n5. 函数名: pr_err\n- 参数: [\"Attempt to release TCP socket in state %d %p\", sk->sk_state, sk], [\"Attempt to release alive inet socket %p\", sk]\n- 调用者: inet_sock_destruct\n- 被调用者: []\n\n6. 函数名: atomic_read\n- 参数: [&sk->sk_rmem_alloc, &sk->sk_wmem_alloc]\n- 调用者: WARN_ON (通过inet_sock_destruct间接调用)\n- 被调用者: []\n\n7. 函数名: WARN_ON\n- 参数: [atomic_read(&sk->sk_rmem_alloc), atomic_read(&sk->sk_wmem_alloc), sk->sk_wmem_queued, sk->sk_forward_alloc]\n- 调用者: inet_sock_destruct\n- 被调用者: [atomic_read]\n\n8. 函数名: kfree\n- 参数: [inet->opt]\n- 调用者: inet_sock_destruct\n- 被调用者: []\n\n9. 函数名: dst_release\n- 参数: [rcu_dereference_check(sk->sk_dst_cache, 1)]\n- 调用者: inet_sock_destruct\n- 被调用者: [rcu_dereference_check]\n\n10. 函数名: rcu_dereference_check\n- 参数: [sk->sk_dst_cache, 1]\n- 调用者: dst_release (通过inet_sock_destruct间接调用)\n- 被调用者: []\n\n11. 函数名: sk_refcnt_debug_dec\n- 参数: [struct sock *sk]\n- 调用者: inet_sock_destruct\n- 被调用者: []"
  },
  {
    "id": 69,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"在Linux内核中动态改变套接字的源IP地址并重新建立路由\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可利用此条件导致拒绝服务（slab损坏和系统崩溃）。\"\"\"",
    "functions": "Functions:\n1. 函数名: inet_sk_reselect_saddr\n- 参数: [struct sock *sk]\n- 调用者: 未显示（由内核网络栈调用）\n- 被调用者: [inet_sk, ip_route_connect, IS_ERR, PTR_ERR, sk_setup_caps, printk, __sk_prot_rehash]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: inet_sk_reselect_saddr\n- 被调用者: 未显示（宏或内联函数）\n\n3. 函数名: ip_route_connect\n- 参数: [struct flowi4 *fl4, __be32 daddr, __be32 saddr, int flags, int bound_dev_if, u8 protocol, __be16 sport, __be16 dport, struct sock *sk, bool no_sport]\n- 调用者: inet_sk_reselect_saddr\n- 被调用者: 未显示\n\n4. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: inet_sk_reselect_saddr\n- 被调用者: 未显示（宏）\n\n5. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: inet_sk_reselect_saddr\n- 被调用者: 未显示（宏）\n\n6. 函数名: sk_setup_caps\n- 参数: [struct sock *sk, struct dst_entry *dst]\n- 调用者: inet_sk_reselect_saddr\n- 被调用者: 未显示\n\n7. 函数名: printk\n- 参数: [const char *fmt, ...]\n- 调用者: inet_sk_reselect_saddr\n- 被调用者: 未显示\n\n8. 函数名: __sk_prot_rehash\n- 参数: [struct sock *sk]\n- 调用者: inet_sk_reselect_saddr\n- 被调用者: 未显示"
  },
  {
    "id": 70,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"该代码用于在请求套接字中删除CIPSO选项，处理网络流量时可能存在的竞争条件会导致拒绝服务漏洞\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺乏适当的同步机制，在Linux内核处理网络流量时，远程攻击者可以通过发送数据包与应用程序设置套接字选项的操作产生竞争条件，导致slab损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: cipso_v4_req_delattr\n- 参数: [struct request_sock *req]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [inet_rsk, cipso_v4_delopt]\n\n2. 函数名: inet_rsk\n- 参数: [struct request_sock *req]\n- 调用者: cipso_v4_req_delattr\n- 被调用者: []\n\n3. 函数名: cipso_v4_delopt\n- 参数: [struct ip_options **opt]\n- 调用者: cipso_v4_req_delattr\n- 被调用者: []"
  },
  {
    "id": 71,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"该代码用于从套接字中删除CIPSO选项并调整相关头部长度，处理网络流量时可能存在的竞争条件漏洞\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送数据包导致slab损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: cipso_v4_sock_delattr\n- 参数: [struct sock *sk]\n- 调用者: 未显示\n- 被调用者: [inet_sk, cipso_v4_delopt, inet_csk]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: cipso_v4_sock_delattr\n- 被调用者: 未显示\n\n3. 函数名: cipso_v4_delopt\n- 参数: [&sk_inet->opt]\n- 调用者: cipso_v4_sock_delattr\n- 被调用者: 未显示\n\n4. 函数名: inet_csk\n- 参数: [struct sock *sk]\n- 调用者: cipso_v4_sock_delattr\n- 被调用者: 未显示"
  },
  {
    "id": 72,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"该代码用于获取套接字的CIPSO安全属性，但存在竞态条件漏洞可能导致内核内存损坏\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，可能导致slab损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: cipso_v4_sock_getattr\n- 参数: [sk, secattr]\n- 调用者: 未明确（由内核网络协议栈调用）\n- 被调用者: [inet_sk, cipso_v4_getattr]\n\n2. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: cipso_v4_sock_getattr\n- 被调用者: []\n\n3. 函数名: cipso_v4_getattr\n- 参数: [opt->__data + opt->cipso - sizeof(struct iphdr), secattr]\n- 调用者: cipso_v4_sock_getattr\n- 被调用者: []"
  },
  {
    "id": 73,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"该代码用于为IPv4套接字设置CIPSO安全标签属性，包括生成选项数据、分配内存并更新套接字选项。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，可能导致远程攻击者通过发送数据包造成拒绝服务（slab损坏和系统崩溃）。\"\"\"",
    "functions": "Functions:\n1. 函数名: cipso_v4_sock_setattr\n- 参数: [struct sock *sk, const struct cipso_v4_doi *doi_def, const struct netlbl_lsm_secattr *secattr]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [kmalloc, cipso_v4_genopt, kzalloc, memcpy, kfree, inet_sk, inet_csk, xchg]\n\n2. 函数名: kmalloc\n- 参数: [buf_len, GFP_ATOMIC]\n- 调用者: cipso_v4_sock_setattr\n- 被调用者: []\n\n3. 函数名: cipso_v4_genopt\n- 参数: [buf, buf_len, doi_def, secattr]\n- 调用者: cipso_v4_sock_setattr\n- 被调用者: []\n\n4. 函数名: kzalloc\n- 参数: [sizeof(*opt) + opt_len, GFP_ATOMIC]\n- 调用者: cipso_v4_sock_setattr\n- 被调用者: []\n\n5. 函数名: memcpy\n- 参数: [opt->__data, buf, buf_len]\n- 调用者: cipso_v4_sock_setattr\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [buf]\n- 调用者: cipso_v4_sock_setattr\n- 被调用者: []\n\n7. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: cipso_v4_sock_setattr\n- 被调用者: []\n\n8. 函数名: inet_csk\n- 参数: [sk]\n- 调用者: cipso_v4_sock_setattr\n- 被调用者: []\n\n9. 函数名: xchg\n- 参数: [&sk_inet->opt, opt]\n- 调用者: cipso_v4_sock_setattr\n- 被调用者: []\n\n10. 函数名: kfree\n- 参数: [opt]\n- 调用者: cipso_v4_sock_setattr\n- 被调用者: []"
  },
  {
    "id": 74,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理CIPSO网络标签的安全属性设置，包括内存分配、选项生成和套接字选项设置。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在设置socket选项时存在竞态条件，可能导致内核内存损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: cipso_v4_req_setattr\n- 参数: [struct request_sock *req, const struct cipso_v4_doi *doi_def, const struct netlbl_lsm_secattr *secattr]\n- 调用者: 未明确（由内核网络协议栈调用）\n- 被调用者: [kmalloc, cipso_v4_genopt, kzalloc, memcpy, kfree, inet_rsk, xchg]\n\n2. 函数名: kmalloc\n- 参数: [size_t buf_len, gfp_t GFP_ATOMIC]\n- 调用者: cipso_v4_req_setattr\n- 被调用者: []\n\n3. 函数名: cipso_v4_genopt\n- 参数: [unsigned char *buf, u32 buf_len, const struct cipso_v4_doi *doi_def, const struct netlbl_lsm_secattr *secattr]\n- 调用者: cipso_v4_req_setattr\n- 被调用者: []\n\n4. 函数名: kzalloc\n- 参数: [size_t sizeof(*opt) + opt_len, gfp_t GFP_ATOMIC]\n- 调用者: cipso_v4_req_setattr\n- 被调用者: []\n\n5. 函数名: memcpy\n- 参数: [void *opt->__data, const void *buf, size_t buf_len]\n- 调用者: cipso_v4_req_setattr\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [void *buf / void *opt]\n- 调用者: cipso_v4_req_setattr\n- 被调用者: []\n\n7. 函数名: inet_rsk\n- 参数: [struct request_sock *req]\n- 调用者: cipso_v4_req_setattr\n- 被调用者: []\n\n8. 函数名: xchg\n- 参数: [struct ip_options **req_inet->opt, struct ip_options *opt]\n- 调用者: cipso_v4_req_setattr\n- 被调用者: []"
  },
  {
    "id": 75,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中ICMP协议回复功能，处理接收到的ICMP请求并生成相应回复。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送数据包导致slab损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: icmp_reply\n- 参数: [struct icmp_bxm *icmp_param, struct sk_buff *skb]\n- 调用者: 未显示\n- 被调用者: [ip_options_echo, skb_rtable, dev_net, icmp_xmit_lock, inet_sk, ip_hdr, security_skb_classify_flow, ip_route_output_key, IS_ERR, icmpv4_xrlim_allow, icmp_push_reply, ip_rt_put, icmp_xmit_unlock]\n\n2. 函数名: ip_options_echo\n- 参数: [&icmp_param->replyopts, skb]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n3. 函数名: skb_rtable\n- 参数: [skb]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n4. 函数名: dev_net\n- 参数: [rt->dst.dev]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n5. 函数名: icmp_xmit_lock\n- 参数: [net]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n6. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n7. 函数名: ip_hdr\n- 参数: [skb]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n8. 函数名: security_skb_classify_flow\n- 参数: [skb, flowi4_to_flowi(&fl4)]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n9. 函数名: ip_route_output_key\n- 参数: [net, &fl4]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n10. 函数名: IS_ERR\n- 参数: [rt]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n11. 函数名: icmpv4_xrlim_allow\n- 参数: [net, rt, icmp_param->data.icmph.type, icmp_param->data.icmph.code]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n12. 函数名: icmp_push_reply\n- 参数: [icmp_param, &ipc, &rt]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n13. 函数名: ip_rt_put\n- 参数: [rt]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n14. 函数名: icmp_xmit_unlock\n- 参数: [sk]\n- 调用者: icmp_reply\n- 被调用者: 未显示"
  },
  {
    "id": 76,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中ICMP协议的错误消息发送功能，用于处理并回复ICMP错误报文。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送特定数据包导致slab损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: icmp_send\n- 参数: [struct sk_buff *skb_in, int type, int code, __be32 info]\n- 调用者: 未显示\n- 被调用者: [dev_net, ip_hdr, skb_rtable, skb_header_pointer, icmp_xmit_lock, dev_get_by_index_rcu, inet_select_addr, ip_options_echo, icmp_route_lookup, icmpv4_xrlim_allow, icmp_push_reply, ip_rt_put, icmp_xmit_unlock]\n\n2. 函数名: dev_net\n- 参数: [struct device *dev]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n3. 函数名: ip_hdr\n- 参数: [const struct sk_buff *skb]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n4. 函数名: skb_rtable\n- 参数: [const struct sk_buff *skb]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n5. 函数名: skb_header_pointer\n- 参数: [const struct sk_buff *skb, int offset, int len, void *buffer]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n6. 函数名: icmp_xmit_lock\n- 参数: [struct net *net]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n7. 函数名: dev_get_by_index_rcu\n- 参数: [struct net *net, int ifindex]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n8. 函数名: inet_select_addr\n- 参数: [struct net_device *dev, __be32 dst, int scope]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n9. 函数名: ip_options_echo\n- 参数: [struct ip_options *dopt, struct sk_buff *skb]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n10. 函数名: icmp_route_lookup\n- 参数: [struct net *net, struct sk_buff *skb_in, struct iphdr *iph, __be32 saddr, u8 tos, int type, int code, struct icmp_bxm *param]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n11. 函数名: icmpv4_xrlim_allow\n- 参数: [struct net *net, struct rtable *rt, int type, int code]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n12. 函数名: icmp_push_reply\n- 参数: [struct icmp_bxm *icmp_param, struct ipcm_cookie *ipc, struct rtable **rt]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n13. 函数名: ip_rt_put\n- 参数: [struct rtable *rt]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n14. 函数名: icmp_xmit_unlock\n- 参数: [struct sock *sk]\n- 调用者: icmp_send\n- 被调用者: 未显示"
  },
  {
    "id": 77,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中实现ICMP消息的路由查找功能，处理ICMP请求的路由选择和反向会话解码。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，可能导致远程攻击者通过发送特定数据包造成slab损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: icmp_route_lookup\n- 参数: [net, skb_in, iph, saddr, tos, type, code, param]\n- 调用者: N/A (顶层函数)\n- 被调用者: [security_skb_classify_flow, __ip_route_output_key, xfrm_lookup, xfrm_decode_session_reverse, inet_addr_type, ip_route_output_key, ip_route_input, dst_release, skb_rtable, ERR_PTR]\n\n2. 函数名: security_skb_classify_flow\n- 参数: [skb_in, flowi4_to_flowi(&fl4)]\n- 调用者: icmp_route_lookup\n- 被调用者: []\n\n3. 函数名: __ip_route_output_key\n- 参数: [net, &fl4]\n- 调用者: icmp_route_lookup\n- 被调用者: []\n\n4. 函数名: xfrm_lookup\n- 参数: [net, &rt->dst, flowi4_to_flowi(&fl4), NULL, 0]\n- 调用者: icmp_route_lookup\n- 被调用者: []\n\n5. 函数名: xfrm_decode_session_reverse\n- 参数: [skb_in, flowi4_to_flowi(&fl4), AF_INET]\n- 调用者: icmp_route_lookup\n- 被调用者: []\n\n6. 函数名: inet_addr_type\n- 参数: [net, fl4.saddr]\n- 调用者: icmp_route_lookup\n- 被调用者: []\n\n7. 函数名: ip_route_output_key\n- 参数: [net, &fl4_2]\n- 调用者: icmp_route_lookup\n- 被调用者: []\n\n8. 函数名: ip_route_input\n- 参数: [skb_in, fl4.daddr, fl4.saddr, RT_TOS(tos), rt2->dst.dev]\n- 调用者: icmp_route_lookup\n- 被调用者: []\n\n9. 函数名: dst_release\n- 参数: [&rt2->dst]\n- 调用者: icmp_route_lookup\n- 被调用者: []\n\n10. 函数名: skb_rtable\n- 参数: [skb_in]\n- 调用者: icmp_route_lookup\n- 被调用者: []\n\n11. 函数名: ERR_PTR\n- 参数: [err]\n- 调用者: icmp_route_lookup\n- 被调用者: []"
  },
  {
    "id": 78,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"该代码用于为传入的连接请求创建并返回一个路由表项，处理网络流量的路由选择\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理网络流量时，应用程序设置套接字选项的操作与网络流量处理之间存在竞争条件，导致slab损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: inet_csk_route_req\n- 参数: [struct sock *sk, const struct request_sock *req]\n- 调用者: 未显示\n- 被调用者: [inet_rsk, flowi4_init_output, sock_net, inet_sk_flowi_flags, security_req_classify_flow, ip_route_output_flow, IS_ERR, ip_rt_put, IP_INC_STATS_BH]\n\n2. 函数名: inet_rsk\n- 参数: [const struct request_sock *req]\n- 调用者: inet_csk_route_req\n- 被调用者: 未显示\n\n3. 函数名: flowi4_init_output\n- 参数: [struct flowi4 *fl4, sk->sk_bound_dev_if, sk->sk_mark, RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE, sk->sk_protocol, inet_sk_flowi_flags(sk), (opt && opt->srr) ? opt->faddr : ireq->rmt_addr, ireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport]\n- 调用者: inet_csk_route_req\n- 被调用者: 未显示\n\n4. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: inet_csk_route_req\n- 被调用者: 未显示\n\n5. 函数名: inet_sk_flowi_flags\n- 参数: [struct sock *sk]\n- 调用者: inet_csk_route_req\n- 被调用者: 未显示\n\n6. 函数名: security_req_classify_flow\n- 参数: [const struct request_sock *req, flowi4_to_flowi(&fl4)]\n- 调用者: inet_csk_route_req\n- 被调用者: 未显示\n\n7. 函数名: ip_route_output_flow\n- 参数: [struct net *net, struct flowi4 *fl4, struct sock *sk]\n- 调用者: inet_csk_route_req\n- 被调用者: 未显示\n\n8. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: inet_csk_route_req\n- 被调用者: 未显示\n\n9. 函数名: ip_rt_put\n- 参数: [struct rtable *rt]\n- 调用者: inet_csk_route_req\n- 被调用者: 未显示\n\n10. 函数名: IP_INC_STATS_BH\n- 参数: [struct net *net, IPSTATS_MIB_OUTNOROUTES]\n- 调用者: inet_csk_route_req\n- 被调用者: 未显示"
  },
  {
    "id": 79,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"构建IP选项并将它们复制到网络数据包中，同时处理源路由、记录路由和时间戳等选项。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送数据包导致slab损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: ip_options_build\n- 参数: [struct sk_buff * skb, struct ip_options * opt, __be32 daddr, struct rtable *rt, int is_frag]\n- 调用者: 未显示（由内核网络栈调用）\n- 被调用者: [memcpy, ip_rt_get_source, getnstimeofday, htonl, memset]\n\n2. 函数名: memcpy\n- 参数: [void * dest, const void * src, size_t n]\n- 调用者: [ip_options_build]\n- 被调用者: []\n\n3. 函数名: ip_rt_get_source\n- 参数: [void * addr, struct rtable *rt]\n- 调用者: [ip_options_build]\n- 被调用者: []\n\n4. 函数名: getnstimeofday\n- 参数: [struct timespec * ts]\n- 调用者: [ip_options_build]\n- 被调用者: []\n\n5. 函数名: htonl\n- 参数: [uint32_t hostlong]\n- 调用者: [ip_options_build]\n- 被调用者: []\n\n6. 函数名: memset\n- 参数: [void * s, int c, size_t n]\n- 调用者: [ip_options_build]\n- 被调用者: []"
  },
  {
    "id": 80,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"分配并初始化一个IP选项结构体，其大小包括基础结构体大小和按4字节对齐的选项长度\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，可能导致远程攻击者通过发送数据包造成slab损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: ip_options_get_alloc\n- 参数: [optlen]\n- 调用者: 未指定（由描述可知可能被IP实现相关代码调用）\n- 被调用者: [kzalloc]"
  },
  {
    "id": 81,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"处理IP选项的回显功能，包括路由记录、时间戳和严格源路由等选项的复制和验证\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送特定数据包导致slab损坏和系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: ip_options_echo\n- 参数: [struct ip_options * dopt, struct sk_buff * skb]\n- 调用者: 未明确（由内核网络协议栈调用）\n- 被调用者: [memset, skb_network_header, skb_rtable, memcpy, inet_addr_type, memcmp, ip_hdr]\n\n2. 函数名: memset\n- 参数: [void * s, int c, size_t n]\n- 调用者: ip_options_echo\n- 被调用者: []\n\n3. 函数名: skb_network_header\n- 参数: [const struct sk_buff * skb]\n- 调用者: ip_options_echo\n- 被调用者: []\n\n4. 函数名: skb_rtable\n- 参数: [const struct sk_buff * skb]\n- 调用者: ip_options_echo\n- 被调用者: []\n\n5. 函数名: memcpy\n- 参数: [void * dest, const void * src, size_t n]\n- 调用者: ip_options_echo\n- 被调用者: []\n\n6. 函数名: inet_addr_type\n- 参数: [struct net * net, __be32 addr]\n- 调用者: ip_options_echo\n- 被调用者: []\n\n7. 函数名: memcmp\n- 参数: [const void * s1, const void * s2, size_t n]\n- 调用者: ip_options_echo\n- 被调用者: []\n\n8. 函数名: ip_hdr\n- 参数: [const struct sk_buff * skb]\n- 调用者: ip_options_echo\n- 被调用者: []\n\n9. 函数名: dev_net\n- 参数: [const struct net_device * dev]\n- 调用者: ip_options_echo\n- 被调用者: []\n\n10. 函数名: skb_dst\n- 参数: [const struct sk_buff * skb]\n- 调用者: ip_options_echo\n- 被调用者: []"
  },
  {
    "id": 82,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"设置IP层的corking选项，包括复制IP选项、计算分片大小并初始化相关结构体，用于网络数据包的处理和传输\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，可能导致远程攻击者通过发送数据包造成slab损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: ip_setup_cork\n- 参数: [struct sock *sk, struct inet_cork *cork, struct ipcm_cookie *ipc, struct rtable **rtp]\n- 调用者: 未指定（由内核网络栈调用）\n- 被调用者: [inet_sk, kmalloc, memcpy, dst_mtu]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: ip_setup_cork\n- 被调用者: 未指定\n\n3. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: ip_setup_cork\n- 被调用者: 未指定\n\n4. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: ip_setup_cork\n- 被调用者: 未指定\n\n5. 函数名: dst_mtu\n- 参数: [const struct dst_entry *dst]\n- 调用者: ip_setup_cork\n- 被调用者: 未指定"
  },
  {
    "id": 83,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"该代码用于处理IP层的回复数据包发送，包括路由选择、选项处理和套接字操作等功能。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，可能导致远程攻击者通过发送特定数据包造成拒绝服务（slab损坏和系统崩溃）。\"\"\"",
    "functions": "Functions:\n1. 函数名: ip_send_reply\n- 参数: [sk, skb, arg, len]\n- 调用者: 未显示\n- 被调用者: [inet_sk, ip_options_echo, flowi4_init_output, security_skb_classify_flow, ip_route_output_key, sock_net, bh_lock_sock, ip_append_data, skb_peek, skb_transport_header, csum_fold, csum_add, ip_push_pending_frames, bh_unlock_sock, ip_rt_put]\n\n2. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n3. 函数名: ip_options_echo\n- 参数: [&replyopts.opt, skb]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n4. 函数名: flowi4_init_output\n- 参数: [&fl4, arg->bound_dev_if, 0, RT_TOS(ip_hdr(skb)->tos), RT_SCOPE_UNIVERSE, sk->sk_protocol, ip_reply_arg_flowi_flags(arg), daddr, rt->rt_spec_dst, tcp_hdr(skb)->source, tcp_hdr(skb)->dest]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n5. 函数名: security_skb_classify_flow\n- 参数: [skb, flowi4_to_flowi(&fl4)]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n6. 函数名: ip_route_output_key\n- 参数: [sock_net(sk), &fl4]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n7. 函数名: sock_net\n- 参数: [sk]\n- 调用者: ip_route_output_key\n- 被调用者: 未显示\n\n8. 函数名: bh_lock_sock\n- 参数: [sk]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n9. 函数名: ip_append_data\n- 参数: [sk, ip_reply_glue_bits, arg->iov->iov_base, len, 0, &ipc, &rt, MSG_DONTWAIT]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n10. 函数名: skb_peek\n- 参数: [&sk->sk_write_queue]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n11. 函数名: skb_transport_header\n- 参数: [skb]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n12. 函数名: csum_fold\n- 参数: [csum_add(skb->csum, arg->csum)]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n13. 函数名: csum_add\n- 参数: [skb->csum, arg->csum]\n- 调用者: csum_fold\n- 被调用者: 未显示\n\n14. 函数名: ip_push_pending_frames\n- 参数: [sk]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n15. 函数名: bh_unlock_sock\n- 参数: [sk]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n16. 函数名: ip_rt_put\n- 参数: [rt]\n- 调用者: ip_send_reply\n- 被调用者: 未显示"
  },
  {
    "id": 84,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中IP数据包的排队和发送功能，包括路由选择、IP头构建和选项处理等网络传输操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，可能导致远程攻击者通过发送特定数据包造成slab损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: ip_queue_xmit\n- 参数: [struct sk_buff *skb]\n- 调用者: N/A (top-level function)\n- 被调用者: [skb_rtable, __sk_dst_check, ip_route_output_ports, sock_net, sk_setup_caps, skb_dst_set_noref, skb_push, skb_reset_network_header, ip_hdr, htons, ip_dont_fragment, ip_select_ttl, ip_options_build, ip_select_ident_more, ip_local_out, rcu_read_unlock, IP_INC_STATS, kfree_skb]\n\n2. 函数名: skb_rtable\n- 参数: [struct sk_buff *skb]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n3. 函数名: __sk_dst_check\n- 参数: [struct sock *sk, int flag]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n4. 函数名: ip_route_output_ports\n- 参数: [sock_net(sk), sk, daddr, inet->inet_saddr, inet->inet_dport, inet->inet_sport, sk->sk_protocol, RT_CONN_FLAGS(sk), sk->sk_bound_dev_if]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n5. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n6. 函数名: sk_setup_caps\n- 参数: [struct sock *sk, &rt->dst]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n7. 函数名: skb_dst_set_noref\n- 参数: [struct sk_buff *skb, &rt->dst]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n8. 函数名: skb_push\n- 参数: [struct sk_buff *skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0)]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n9. 函数名: skb_reset_network_header\n- 参数: [struct sk_buff *skb]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n10. 函数名: ip_hdr\n- 参数: [struct sk_buff *skb]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n11. 函数名: htons\n- 参数: [(4 << 12) | (5 << 8) | (inet->tos & 0xff)]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n12. 函数名: ip_dont_fragment\n- 参数: [struct sock *sk, &rt->dst]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n13. 函数名: ip_select_ttl\n- 参数: [inet, &rt->dst]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n14. 函数名: ip_options_build\n- 参数: [skb, opt, inet->inet_daddr, rt, 0]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n15. 函数名: ip_select_ident_more\n- 参数: [iph, &rt->dst, sk, (skb_shinfo(skb)->gso_segs ?: 1) - 1]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n16. 函数名: ip_local_out\n- 参数: [struct sk_buff *skb]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n17. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n18. 函数名: IP_INC_STATS\n- 参数: [sock_net(sk), IPSTATS_MIB_OUTNOROUTES]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n19. 函数名: kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A"
  },
  {
    "id": 85,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中IP套接字选项的获取功能，处理各种IP相关的socket选项请求并返回相应值。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，可能导致slab损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: do_ip_getsockopt\n- 参数: [struct sock *sk, int level, int optname, char __user *optval, int __user *optlen]\n- 调用者: 未明确显示（通常是内核网络栈调用）\n- 被调用者: [ip_mroute_getsockopt, get_user, lock_sock, memcpy, release_sock, put_user, ip_options_undo, min_t, copy_to_user, sk_dst_get, dst_mtu, dst_release, copy_from_user, ip_mc_msfget, ip_mc_gsfget, put_cmsg]\n\n2. 函数名: ip_mroute_getsockopt\n- 参数: [struct sock *sk, int optname, char __user *optval, int __user *optlen]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（代码片段外）\n\n3. 函数名: get_user\n- 参数: [int len, int __user *optlen]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核宏/函数）\n\n4. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核函数）\n\n5. 函数名: memcpy\n- 参数: [unsigned char *optbuf, struct ip_options *inet->opt, size_t sizeof(struct ip_options)+inet->opt->optlen]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（标准库函数）\n\n6. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核函数）\n\n7. 函数名: put_user\n- 参数: [int value, int __user *optlen] 或 [unsigned char ucval, char __user *optval]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核宏/函数）\n\n8. 函数名: ip_options_undo\n- 参数: [struct ip_options *opt]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核函数）\n\n9. 函数名: min_t\n- 参数: [unsigned int, int len, int opt->optlen] 或 [unsigned int, int len, sizeof(struct in_addr)]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核宏）\n\n10. 函数名: copy_to_user\n- 参数: [char __user *optval, void *src, int len]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核函数）\n\n11. 函数名: sk_dst_get\n- 参数: [struct sock *sk]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核函数）\n\n12. 函数名: dst_mtu\n- 参数: [struct dst_entry *dst]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核函数）\n\n13. 函数名: dst_release\n- 参数: [struct dst_entry *dst]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核函数）\n\n14. 函数名: copy_from_user\n- 参数: [struct ip_msfilter *msf, char __user *optval, size_t IP_MSFILTER_SIZE(0)] 或 [struct group_filter *gsf, char __user *optval, size_t GROUP_FILTER_SIZE(0)]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核函数）\n\n15. 函数名: ip_mc_msfget\n- 参数: [struct sock *sk, struct ip_msfilter *msf, struct ip_msfilter __user *optval, int __user *optlen]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核函数）\n\n16. 函数名: ip_mc_gsfget\n- 参数: [struct sock *sk, struct group_filter *gsf, struct group_filter __user *optval, int __user *optlen]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核函数）\n\n17. 函数名: put_cmsg\n- 参数: [struct msghdr *msg, int SOL_IP, int IP_PKTINFO/IP_TTL, size_t sizeof(info)/sizeof(hlim), void *info/hlim]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核函数）"
  },
  {
    "id": 86,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"处理IP层的套接字选项设置，包括各种IP相关参数的配置和组播功能的实现\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送数据包导致slab损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: do_ip_setsockopt\n- 参数: [struct sock *sk, int level, int optname, char __user *optval, unsigned int optlen]\n- 调用者: 未显示（由内核网络栈调用）\n- 被调用者: [get_user, ip_mroute_setsockopt, lock_sock, ip_options_get_from_user, xchg, kfree, ip_mc_join_group, ip_mc_leave_group, ip_mc_msfilter, ip_mc_source, ip_ra_control, xfrm_user_policy, release_sock, sk_dst_reset, skb_queue_purge, ip_dev_find, dev_get_by_index, dev_put, copy_from_user, kmalloc, kfree]\n\n2. 函数名: ip_mroute_setsockopt\n- 参数: [struct sock *sk, int optname, char __user *optval, unsigned int optlen]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n3. 函数名: ip_options_get_from_user\n- 参数: [struct net *net, struct ip_options **optptr, unsigned char __user *data, int optlen]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n4. 函数名: ip_mc_join_group\n- 参数: [struct sock *sk, struct ip_mreqn *mreq]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n5. 函数名: ip_mc_leave_group\n- 参数: [struct sock *sk, struct ip_mreqn *mreq]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n6. 函数名: ip_mc_msfilter\n- 参数: [struct sock *sk, struct ip_msfilter *msf, int ifindex]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n7. 函数名: ip_mc_source\n- 参数: [int add, int omode, struct sock *sk, struct ip_mreq_source *mreqs, int ifindex]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n8. 函数名: ip_ra_control\n- 参数: [struct sock *sk, int on, void (*destructor)(struct sock *)]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n9. 函数名: xfrm_user_policy\n- 参数: [struct sock *sk, int optname, char __user *optval, unsigned int optlen]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n10. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n11. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n12. 函数名: ip_dev_find\n- 参数: [struct net *net, __be32 addr]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n13. 函数名: dev_get_by_index\n- 参数: [struct net *net, int ifindex]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n14. 函数名: dev_put\n- 参数: [struct net_device *dev]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示"
  },
  {
    "id": 87,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中原始套接字(raw socket)的发送消息功能，处理IP层数据包的构造和发送，包括地址验证、路由查找和数据处理等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，可能导致远程攻击者通过发送数据包造成拒绝服务（slab损坏和系统崩溃）。\"\"\"",
    "functions": "Functions:\n1. 函数名: raw_sendmsg\n- 参数: [struct kiocb *iocb, struct sock *sk, struct msghdr *msg, size_t len]\n- 调用者: 未显示\n- 被调用者: [inet_sk, ip_cmsg_send, sock_net, flowi4_init_output, raw_probe_proto_opt, security_sk_classify_flow, ip_route_output_flow, raw_send_hdrinc, ip_append_data, ip_flush_pending_frames, ip_push_pending_frames, kfree, ip_rt_put, dst_confirm]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n3. 函数名: ip_cmsg_send\n- 参数: [sock_net(sk), msg, &ipc]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n4. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n5. 函数名: flowi4_init_output\n- 参数: [&fl4, ipc.oif, sk->sk_mark, tos, RT_SCOPE_UNIVERSE, inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol, FLOWI_FLAG_CAN_SLEEP, daddr, saddr, 0, 0]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n6. 函数名: raw_probe_proto_opt\n- 参数: [&fl4, msg]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n7. 函数名: security_sk_classify_flow\n- 参数: [sk, flowi4_to_flowi(&fl4)]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n8. 函数名: ip_route_output_flow\n- 参数: [sock_net(sk), &fl4, sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n9. 函数名: raw_send_hdrinc\n- 参数: [sk, msg->msg_iov, len, &rt, msg->msg_flags]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n10. 函数名: ip_append_data\n- 参数: [sk, ip_generic_getfrag, msg->msg_iov, len, 0, &ipc, &rt, msg->msg_flags]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n11. 函数名: ip_flush_pending_frames\n- 参数: [sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n12. 函数名: ip_push_pending_frames\n- 参数: [sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n13. 函数名: kfree\n- 参数: [ipc.opt]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n14. 函数名: ip_rt_put\n- 参数: [rt]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n15. 函数名: dst_confirm\n- 参数: [&rt->dst]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示"
  },
  {
    "id": 88,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"处理TCP SYN cookie验证和连接请求，用于防御SYN flood攻击并建立合法连接\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理网络流量时，应用程序设置套接字选项的操作与IP实现之间存在竞争条件，可能导致slab损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: cookie_v4_check\n- 参数: [sk, skb, opt]\n- 调用者: 未显示\n- 被调用者: [tcp_sk, tcp_hdr, ntohl, tcp_synq_no_recent_overflow, cookie_check, NET_INC_STATS_BH, sock_net, memset, tcp_parse_options, cookie_check_timestamp, inet_reqsk_alloc, ip_hdr, kmalloc, ip_options_echo, kfree, security_inet_conn_request, reqsk_free, flowi4_init_output, security_req_classify_flow, ip_route_output_key, tcp_select_initial_window, get_cookie_sock]\n\n2. 函数名: tcp_sk\n- 参数: [sk]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n3. 函数名: tcp_hdr\n- 参数: [skb]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n4. 函数名: ntohl\n- 参数: [th->ack_seq]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n5. 函数名: tcp_synq_no_recent_overflow\n- 参数: [sk]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n6. 函数名: cookie_check\n- 参数: [skb, cookie]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n7. 函数名: NET_INC_STATS_BH\n- 参数: [sock_net(sk), LINUX_MIB_SYNCOOKIESFAILED/LINUX_MIB_SYNCOOKIESRECV]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n8. 函数名: sock_net\n- 参数: [sk]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n9. 函数名: memset\n- 参数: [&tcp_opt, 0, sizeof(tcp_opt)]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n10. 函数名: tcp_parse_options\n- 参数: [skb, &tcp_opt, &hash_location, 0]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n11. 函数名: cookie_check_timestamp\n- 参数: [&tcp_opt, &ecn_ok]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n12. 函数名: inet_reqsk_alloc\n- 参数: [&tcp_request_sock_ops]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n13. 函数名: ip_hdr\n- 参数: [skb]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n14. 函数名: kmalloc\n- 参数: [opt_size, GFP_ATOMIC]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n15. 函数名: ip_options_echo\n- 参数: [ireq->opt, skb]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n16. 函数名: kfree\n- 参数: [ireq->opt]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n17. 函数名: security_inet_conn_request\n- 参数: [sk, skb, req]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n18. 函数名: reqsk_free\n- 参数: [req]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n19. 函数名: flowi4_init_output\n- 参数: [&fl4, 0, sk->sk_mark, RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE, IPPROTO_TCP, inet_sk_flowi_flags(sk), (opt && opt->srr) ? opt->faddr : ireq->rmt_addr, ireq->loc_addr, th->source, th->dest]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n20. 函数名: security_req_classify_flow\n- 参数: [req, flowi4_to_flowi(&fl4)]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n21. 函数名: ip_route_output_key\n- 参数: [sock_net(sk), &fl4]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n22. 函数名: tcp_select_initial_window\n- 参数: [tcp_full_space(sk), req->mss, &req->rcv_wnd, &req->window_clamp, ireq->wscale_ok, &rcv_wscale, dst_metric(&rt->dst, RTAX_INITRWND)]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n23. 函数名: get_cookie_sock\n- 参数: [sk, skb, req, &rt->dst]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示"
  },
  {
    "id": 89,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"保存并复制传入网络数据包的IP选项，以便后续处理\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送数据包导致slab损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: tcp_v4_save_options\n- 参数: [struct sock *sk, struct sk_buff *skb]\n- 调用者: 未显示（由内核网络协议栈调用）\n- 被调用者: [kmalloc, ip_options_echo, kfree]\n\n2. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: tcp_v4_save_options\n- 被调用者: []\n\n3. 函数名: ip_options_echo\n- 参数: [struct ip_options *dopt, struct sk_buff *skb]\n- 调用者: tcp_v4_save_options\n- 被调用者: []\n\n4. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: tcp_v4_save_options\n- 被调用者: []\n\n5. 函数名: optlength\n- 参数: [struct ip_options *opt]\n- 调用者: tcp_v4_save_options\n- 被调用者: []"
  },
  {
    "id": 90,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"实现TCP/IPv4连接的建立过程，包括路由查找、状态设置和连接初始化\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送数据包导致slab损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: tcp_v4_connect\n- 参数: [struct sock *sk, struct sockaddr *uaddr, int addr_len]\n- 调用者: N/A (系统调用或内核其他模块)\n- 被调用者: [inet_sk, tcp_sk, ip_route_connect, IP_INC_STATS_BH, sock_net, ip_rt_put, rt_get_peer, inet_peer_refcheck, get_seconds, inet_csk, tcp_set_state, inet_hash_connect, ip_route_newports, sk_setup_caps, secure_tcp_sequence_number, tcp_connect]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n3. 函数名: tcp_sk\n- 参数: [struct sock *sk]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n4. 函数名: ip_route_connect\n- 参数: [struct flowi4 *fl4, __be32 nexthop, __be32 saddr, unsigned int flags, int bound_dev_if, u8 protocol, __be16 sport, __be16 dport, struct sock *sk, bool no_sport]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n5. 函数名: IP_INC_STATS_BH\n- 参数: [struct net *net, int field]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n6. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n7. 函数名: ip_rt_put\n- 参数: [struct rtable *rt]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n8. 函数名: rt_get_peer\n- 参数: [struct rtable *rt]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n9. 函数名: inet_peer_refcheck\n- 参数: [struct inet_peer *peer]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n10. 函数名: get_seconds\n- 参数: []\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n11. 函数名: inet_csk\n- 参数: [struct sock *sk]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n12. 函数名: tcp_set_state\n- 参数: [struct sock *sk, int state]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n13. 函数名: inet_hash_connect\n- 参数: [struct inet_timewait_death_row *death_row, struct sock *sk]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n14. 函数名: ip_route_newports\n- 参数: [struct flowi4 *fl4, struct rtable *rt, __be16 orig_sport, __be16 orig_dport, __be16 sport, __be16 dport, struct sock *sk]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n15. 函数名: sk_setup_caps\n- 参数: [struct sock *sk, struct dst_entry *dst]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n16. 函数名: secure_tcp_sequence_number\n- 参数: [__be32 saddr, __be32 daddr, __be16 sport, __be16 dport]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n17. 函数名: tcp_connect\n- 参数: [struct sock *sk]\n- 调用者: tcp_v4_connect\n- 被调用者: []"
  },
  {
    "id": 91,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"处理TCP IPv4连接请求并创建新的子套接字\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理网络流量时，应用程序设置套接字选项的过程中存在竞态条件，可能导致slab损坏和系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: tcp_v4_syn_recv_sock\n- 参数: [sk, skb, req, dst]\n- 调用者: 未显示（由TCP/IP协议栈调用）\n- 被调用者: [sk_acceptq_is_full, inet_csk_route_req, tcp_create_openreq_child, sk_setup_caps, tcp_sk, inet_sk, inet_rsk, ip_hdr, inet_csk, tcp_mtup_init, tcp_sync_mss, dst_mtu, dst_metric_advmss, tcp_initialize_rcv_mss, tcp_v4_md5_do_lookup, kmemdup, tcp_v4_md5_do_add, sk_nocaps_add, __inet_inherit_port, sock_put, dst_release, __inet_hash_nolisten, NET_INC_STATS_BH]\n\n2. 函数名: sk_acceptq_is_full\n- 参数: [sk]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n3. 函数名: inet_csk_route_req\n- 参数: [sk, req]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n4. 函数名: tcp_create_openreq_child\n- 参数: [sk, req, skb]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n5. 函数名: sk_setup_caps\n- 参数: [newsk, dst]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n6. 函数名: tcp_sk\n- 参数: [newsk]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n7. 函数名: inet_sk\n- 参数: [newsk]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n8. 函数名: inet_rsk\n- 参数: [req]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n9. 函数名: ip_hdr\n- 参数: [skb]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n10. 函数名: tcp_mtup_init\n- 参数: [newsk]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n11. 函数名: tcp_sync_mss\n- 参数: [newsk, dst_mtu(dst)]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n12. 函数名: dst_mtu\n- 参数: [dst]\n- 调用者: tcp_sync_mss\n- 被调用者: []\n\n13. 函数名: dst_metric_advmss\n- 参数: [dst]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n14. 函数名: tcp_initialize_rcv_mss\n- 参数: [newsk]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n15. 函数名: tcp_v4_md5_do_lookup\n- 参数: [sk, newinet->inet_daddr]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n16. 函数名: kmemdup\n- 参数: [key->key, key->keylen, GFP_ATOMIC]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n17. 函数名: tcp_v4_md5_do_add\n- 参数: [newsk, newinet->inet_daddr, newkey, key->keylen]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n18. 函数名: sk_nocaps_add\n- 参数: [newsk, NETIF_F_GSO_MASK]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n19. 函数名: __inet_inherit_port\n- 参数: [sk, newsk]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n20. 函数名: sock_put\n- 参数: [newsk]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n21. 函数名: dst_release\n- 参数: [dst]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n22. 函数名: __inet_hash_nolisten\n- 参数: [newsk, NULL]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n23. 函数名: NET_INC_STATS_BH\n- 参数: [sock_net(sk), LINUX_MIB_LISTENOVERFLOWS] 和 [sock_net(sk), LINUX_MIB_LISTENDROPS]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n24. 函数名: sock_net\n- 参数: [sk]\n- 调用者: NET_INC_STATS_BH\n- 被调用者: []"
  },
  {
    "id": 92,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中UDP协议的发送消息功能，包括处理消息地址、路由选择、数据包构建和发送等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在3.0版本前的IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送数据包导致slab损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: udp_sendmsg\n- 参数: [struct kiocb *iocb, struct sock *sk, struct msghdr *msg, size_t len]\n- 调用者: 无（系统调用）\n- 被调用者: [inet_sk, udp_sk, lock_sock, release_sock, sock_tx_timestamp, ip_cmsg_send, sock_net, ip_route_output_flow, security_sk_classify_flow, ip_make_skb, udp_send_skb, ip_append_data, udp_flush_pending_frames, udp_push_pending_frames, ip_rt_put, kfree, dst_confirm]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n3. 函数名: udp_sk\n- 参数: [struct sock *sk]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n4. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n5. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n6. 函数名: sock_tx_timestamp\n- 参数: [struct sock *sk, u32 *tx_flags]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n7. 函数名: ip_cmsg_send\n- 参数: [struct net *net, struct msghdr *msg, struct ipcm_cookie *ipc]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n8. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n9. 函数名: ip_route_output_flow\n- 参数: [struct net *net, struct flowi4 *flp, struct sock *sk]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n10. 函数名: security_sk_classify_flow\n- 参数: [struct sock *sk, struct flowi *fl]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n11. 函数名: ip_make_skb\n- 参数: [struct sock *sk, int (*getfrag)(...), struct iovec *iov, unsigned int len, unsigned int transhdrlen, struct ipcm_cookie *ipc, struct rtable **rtp, unsigned int flags]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n12. 函数名: udp_send_skb\n- 参数: [struct sk_buff *skb, __be32 daddr, __be16 dport]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n13. 函数名: ip_append_data\n- 参数: [struct sock *sk, int (*getfrag)(...), struct iovec *iov, int len, int transhdrlen, struct ipcm_cookie *ipc, struct rtable **rt, unsigned int flags]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n14. 函数名: udp_flush_pending_frames\n- 参数: [struct sock *sk]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n15. 函数名: udp_push_pending_frames\n- 参数: [struct sock *sk]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n16. 函数名: ip_rt_put\n- 参数: [struct rtable *rt]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n17. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n18. 函数名: dst_confirm\n- 参数: [struct dst_entry *dst]\n- 调用者: udp_sendmsg\n- 被调用者: 无"
  },
  {
    "id": 93,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"处理IPv6 TCP连接的同步接收套接字创建，包括IPv4映射地址的处理和套接字选项的继承\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送数据包导致slab损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: tcp_v6_syn_recv_sock\n- 参数: [sk, skb, req, dst]\n- 调用者: 未显示（由内核TCP/IP协议栈调用）\n- 被调用者: [tcp_v4_syn_recv_sock, inet6_sk, inet_sk, tcp_sk, memcpy, ipv6_addr_set_v4mapped, ipv6_addr_copy, inet_csk, tcp_v4_do_rcv, tcp_sync_mss, inet6_rsk, sk_acceptq_is_full, inet6_csk_route_req, tcp_create_openreq_child, __ip6_dst_store, skb_clone, kfree_skb, skb_set_owner_r, ipv6_dup_options, sock_kfree_s, tcp_mtup_init, dst_mtu, dst_metric_advmss, tcp_initialize_rcv_mss, tcp_v6_md5_do_lookup, kmemdup, tcp_v6_md5_do_add, __inet_inherit_port, sock_put, __inet6_hash, NET_INC_STATS_BH, dst_release]\n\n2. 函数名: tcp_v4_syn_recv_sock\n- 参数: [sk, skb, req, dst]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n3. 函数名: inet6_sk\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n4. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n5. 函数名: tcp_sk\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n6. 函数名: memcpy\n- 参数: [dest, src, n]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n7. 函数名: ipv6_addr_set_v4mapped\n- 参数: [addr, v4mapped]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n8. 函数名: ipv6_addr_copy\n- 参数: [dst, src]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n9. 函数名: inet_csk\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n10. 函数名: tcp_v4_do_rcv\n- 参数: [sk, skb]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n11. 函数名: tcp_sync_mss\n- 参数: [sk, pmtu]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n12. 函数名: inet6_rsk\n- 参数: [req]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n13. 函数名: sk_acceptq_is_full\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n14. 函数名: inet6_csk_route_req\n- 参数: [sk, req]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n15. 函数名: tcp_create_openreq_child\n- 参数: [sk, req, skb]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n16. 函数名: __ip6_dst_store\n- 参数: [sk, dst, saddr, daddr]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n17. 函数名: skb_clone\n- 参数: [skb, gfp_mask]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n18. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n19. 函数名: skb_set_owner_r\n- 参数: [skb, sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n20. 函数名: ipv6_dup_options\n- 参数: [sk, opt]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n21. 函数名: sock_kfree_s\n- 参数: [sk, mem, size]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n22. 函数名: tcp_mtup_init\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n23. 函数名: dst_mtu\n- 参数: [dst]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n24. 函数名: dst_metric_advmss\n- 参数: [dst]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n25. 函数名: tcp_initialize_rcv_mss\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n26. 函数名: tcp_v6_md5_do_lookup\n- 参数: [sk, addr]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n27. 函数名: kmemdup\n- 参数: [src, len, gfp]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n28. 函数名: tcp_v6_md5_do_add\n- 参数: [sk, addr, newkey, keylen]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n29. 函数名: __inet_inherit_port\n- 参数: [sk, newsk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n30. 函数名: sock_put\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n31. 函数名: __inet6_hash\n- 参数: [sk, NULL]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n32. 函数名: NET_INC_STATS_BH\n- 参数: [sock_net(sk), LINUX_MIB_LISTENOVERFLOWS/LINUX_MIB_LISTENDROPS]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n33. 函数名: dst_release\n- 参数: [dst]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示"
  },
  {
    "id": 94,
    "cwe": "CWE-362",
    "cve": "CVE-2012-3552",
    "purpose": "Code purpose:\"\"\"该代码实现了L2TP/IP协议中发送消息的功能，包括处理目标地址、分配套接字缓冲区、填充数据并通过IP层发送数据包。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，可能导致远程攻击者通过发送数据包造成slab损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: l2tp_ip_sendmsg\n- 参数: [struct kiocb *iocb, struct sock *sk, struct msghdr *msg, size_t len]\n- 调用者: 未显示（内核网络栈调用）\n- 被调用者: [l2tp_ip_sk, inet_sk, sock_flag, sock_wmalloc, skb_reserve, skb_reset_network_header, skb_reset_transport_header, skb_put, memcpy_fromiovec, kfree_skb, __sk_dst_check, ip_route_output_ports, sk_setup_caps, dst_clone, skb_dst_set, ip_queue_xmit, IP_INC_STATS]\n\n2. 函数名: l2tp_ip_sk\n- 参数: [struct sock *sk]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n3. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n4. 函数名: sock_flag\n- 参数: [struct sock *sk, int flag]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n5. 函数名: sock_wmalloc\n- 参数: [struct sock *sk, int size, int force, gfp_t priority]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n6. 函数名: skb_reserve\n- 参数: [struct sk_buff *skb, int len]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n7. 函数名: skb_reset_network_header\n- 参数: [struct sk_buff *skb]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n8. 函数名: skb_reset_transport_header\n- 参数: [struct sk_buff *skb]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n9. 函数名: skb_put\n- 参数: [struct sk_buff *skb, unsigned int len]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n10. 函数名: memcpy_fromiovec\n- 参数: [void *kdata, struct iovec *iov, int len]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n11. 函数名: kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n12. 函数名: __sk_dst_check\n- 参数: [struct sock *sk, u32 cookie]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n13. 函数名: ip_route_output_ports\n- 参数: [struct net *net, struct sock *sk, __be32 daddr, __be32 saddr, __be16 dport, __be16 sport, u8 proto, u32 flags, int oif]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n14. 函数名: sk_setup_caps\n- 参数: [struct sock *sk, struct dst_entry *dst]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n15. 函数名: dst_clone\n- 参数: [struct dst_entry *dst]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n16. 函数名: skb_dst_set\n- 参数: [struct sk_buff *skb, struct dst_entry *dst]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n17. 函数名: ip_queue_xmit\n- 参数: [struct sk_buff *skb]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n18. 函数名: IP_INC_STATS\n- 参数: [struct net *net, int field]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []"
  },
  {
    "id": 106,
    "cwe": "CWE-362",
    "cve": "CVE-2012-4508",
    "purpose": "Code purpose:\"\"\"该代码用于处理ext4文件系统中扩展区间的分割操作，确保文件数据在修改时能正确维护扩展的分配和初始化状态\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确标记未初始化的extent，导致在竞争条件下可以读取已删除文件的敏感信息\"\"\"",
    "functions": "Functions:\n1. 函数名: ext4_split_extent\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_ext_path *path, struct ext4_map_blocks *map, int split_flag, int flags]\n- 调用者: N/A\n- 被调用者: [ext_depth, le32_to_cpu, ext4_ext_get_actual_len, ext4_ext_is_uninitialized, ext4_split_extent_at, ext4_ext_drop_refs, ext4_ext_find_extent, IS_ERR, PTR_ERR, ext4_ext_show_leaf]\n\n2. 函数名: ext_depth\n- 参数: [struct inode *inode]\n- 调用者: ext4_split_extent\n- 被调用者: N/A\n\n3. 函数名: le32_to_cpu\n- 参数: [__le32]\n- 调用者: ext4_split_extent\n- 被调用者: N/A\n\n4. 函数名: ext4_ext_get_actual_len\n- 参数: [struct ext4_extent *ex]\n- 调用者: ext4_split_extent\n- 被调用者: N/A\n\n5. 函数名: ext4_ext_is_uninitialized\n- 参数: [struct ext4_extent *ex]\n- 调用者: ext4_split_extent\n- 被调用者: N/A\n\n6. 函数名: ext4_split_extent_at\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_ext_path *path, ext4_lblk_t lblk, int split_flag, int flags]\n- 调用者: ext4_split_extent\n- 被调用者: N/A\n\n7. 函数名: ext4_ext_drop_refs\n- 参数: [struct ext4_ext_path *path]\n- 调用者: ext4_split_extent\n- 被调用者: N/A\n\n8. 函数名: ext4_ext_find_extent\n- 参数: [struct inode *inode, ext4_lblk_t lblk, struct ext4_ext_path *path]\n- 调用者: ext4_split_extent\n- 被调用者: N/A\n\n9. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: ext4_split_extent\n- 被调用者: N/A\n\n10. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: ext4_split_extent\n- 被调用者: N/A\n\n11. 函数名: ext4_ext_show_leaf\n- 参数: [struct inode *inode, struct ext4_ext_path *path]\n- 调用者: ext4_split_extent\n- 被调用者: N/A"
  },
  {
    "id": 107,
    "cwe": "CWE-362",
    "cve": "CVE-2012-4508",
    "purpose": "Code purpose:\"\"\"该代码用于在ext4文件系统中处理文件扩展的分割操作，包括标记未初始化状态、合并扩展块以及在错误情况下恢复原始扩展长度。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4文件系统中处理extent分割时，未能正确标记未初始化的extent，导致竞态条件下可能泄露已删除文件的敏感信息\"\"\"",
    "functions": "Functions:\n1. 函数名: ext4_split_extent_at\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_ext_path *path, ext4_lblk_t split, int split_flag, int flags]\n- 调用者: N/A (top-level function)\n- 被调用者: [ext4_ext_show_leaf, ext_depth, ext4_ext_get_actual_len, ext4_ext_get_access, ext4_ext_mark_uninitialized, ext4_ext_mark_initialized, ext4_ext_try_to_merge, ext4_ext_dirty, memcpy, ext4_ext_insert_extent, ext4_ext_zeroout]\n\n2. 函数名: ext4_ext_show_leaf\n- 参数: [struct inode *inode, struct ext4_ext_path *path]\n- 调用者: ext4_split_extent_at\n- 被调用者: []\n\n3. 函数名: ext_depth\n- 参数: [struct inode *inode]\n- 调用者: ext4_split_extent_at\n- 被调用者: []\n\n4. 函数名: ext4_ext_get_actual_len\n- 参数: [struct ext4_extent *ex]\n- 调用者: ext4_split_extent_at\n- 被调用者: []\n\n5. 函数名: ext4_ext_get_access\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_ext_path *path]\n- 调用者: ext4_split_extent_at\n- 被调用者: []\n\n6. 函数名: ext4_ext_mark_uninitialized\n- 参数: [struct ext4_extent *ex]\n- 调用者: ext4_split_extent_at\n- 被调用者: []\n\n7. 函数名: ext4_ext_mark_initialized\n- 参数: [struct ext4_extent *ex]\n- 调用者: ext4_split_extent_at\n- 被调用者: []\n\n8. 函数名: ext4_ext_try_to_merge\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_ext_path *path, struct ext4_extent *ex]\n- 调用者: ext4_split_extent_at\n- 被调用者: []\n\n9. 函数名: ext4_ext_dirty\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_ext_path *path]\n- 调用者: ext4_split_extent_at\n- 被调用者: []\n\n10. 函数名: ext4_ext_insert_extent\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_ext_path *path, struct ext4_extent *newex, int flags]\n- 调用者: ext4_split_extent_at\n- 被调用者: []\n\n11. 函数名: ext4_ext_zeroout\n- 参数: [struct inode *inode, struct ext4_extent *orig_ex]\n- 调用者: ext4_split_extent_at\n- 被调用者: []"
  },
  {
    "id": 108,
    "cwe": "CWE-362",
    "cve": "CVE-2012-4508",
    "purpose": "Code purpose:\"\"\"处理ext4文件系统中未初始化区间的分配、转换和映射操作，包括处理预IO、转换已填充区间为写入状态以及缓冲IO等情况\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在ext4文件系统中处理未初始化extent时存在竞态条件，未能正确标记已删除文件的extent为未初始化状态，导致本地用户可读取敏感信息\"\"\"",
    "functions": "Functions:\n1. 函数名: ext4_ext_handle_uninitialized_extents\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_map_blocks *map, struct ext4_ext_path *path, int flags, unsigned int allocated, ext4_fsblk_t newblock]\n- 调用者: N/A (顶层函数)\n- 被调用者: [ext4_inode_aio, ext_debug, ext4_ext_show_leaf, trace_ext4_ext_handle_uninitialized_extents, ext4_split_unwritten_extents, ext4_set_io_unwritten_flag, ext4_set_inode_state, ext4_should_dioread_nolock, ext4_convert_unwritten_extents_endio, ext4_update_inode_fsync_trans, check_eofblocks_fl, ext4_ext_convert_to_initialized, unmap_underlying_metadata_blocks, get_reserved_cluster_alloc, ext4_da_update_reserve_space, ext4_ext_drop_refs, kfree]\n\n2. 函数名: ext4_inode_aio\n- 参数: [struct inode *inode]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n3. 函数名: ext_debug\n- 参数: [const char *fmt, ...]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n4. 函数名: ext4_ext_show_leaf\n- 参数: [struct inode *inode, struct ext4_ext_path *path]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n5. 函数名: trace_ext4_ext_handle_uninitialized_extents\n- 参数: [struct inode *inode, struct ext4_map_blocks *map, unsigned int allocated, ext4_fsblk_t newblock]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n6. 函数名: ext4_split_unwritten_extents\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_map_blocks *map, struct ext4_ext_path *path, int flags]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n7. 函数名: ext4_set_io_unwritten_flag\n- 参数: [struct inode *inode, ext4_io_end_t *io]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n8. 函数名: ext4_set_inode_state\n- 参数: [struct inode *inode, unsigned int state]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n9. 函数名: ext4_should_dioread_nolock\n- 参数: [struct inode *inode]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n10. 函数名: ext4_convert_unwritten_extents_endio\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_ext_path *path]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n11. 函数名: ext4_update_inode_fsync_trans\n- 参数: [handle_t *handle, struct inode *inode, int update_tx]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n12. 函数名: check_eofblocks_fl\n- 参数: [handle_t *handle, struct inode *inode, ext4_lblk_t lblk, struct ext4_ext_path *path, unsigned int len]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n13. 函数名: ext4_ext_convert_to_initialized\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_map_blocks *map, struct ext4_ext_path *path]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n14. 函数名: unmap_underlying_metadata_blocks\n- 参数: [struct block_device *bdev, sector_t block, unsigned int count]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n15. 函数名: get_reserved_cluster_alloc\n- 参数: [struct inode *inode, ext4_lblk_t lblk, unsigned int len]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n16. 函数名: ext4_da_update_reserve_space\n- 参数: [struct inode *inode, int reserved_clusters, int used_clusters]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n17. 函数名: ext4_ext_drop_refs\n- 参数: [struct ext4_ext_path *path]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n18. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A"
  },
  {
    "id": 109,
    "cwe": "CWE-362",
    "cve": "CVE-2012-4508",
    "purpose": "Code purpose:\"\"\"处理未初始化extent的分割操作，确保在文件大小范围内正确标记和转换extent状态\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确标记未初始化的extent，导致在竞争条件下可以读取已删除文件的敏感信息\"\"\"",
    "functions": "Functions:\n1. 函数名: ext4_split_unwritten_extents\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_map_blocks *map, struct ext4_ext_path *path, int flags]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [ext_depth, le32_to_cpu, ext4_ext_get_actual_len, ext4_split_extent]\n\n2. 函数名: ext_depth\n- 参数: [struct inode *inode]\n- 调用者: ext4_split_unwritten_extents\n- 被调用者: 未显示\n\n3. 函数名: le32_to_cpu\n- 参数: [未显示（参数应为32位小端值）]\n- 调用者: ext4_split_unwritten_extents\n- 被调用者: 未显示\n\n4. 函数名: ext4_ext_get_actual_len\n- 参数: [struct ext4_extent *ex]\n- 调用者: ext4_split_unwritten_extents\n- 被调用者: 未显示\n\n5. 函数名: ext4_split_extent\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_ext_path *path, struct ext4_map_blocks *map, int split_flag, int flags]\n- 调用者: ext4_split_unwritten_extents\n- 被调用者: 未显示"
  },
  {
    "id": 162,
    "cwe": "CWE-362",
    "cve": "CVE-2013-0871",
    "purpose": "Code purpose:\"\"\"实现Linux内核中ptrace系统调用的功能，用于进程间调试和控制，包括读取/写入内存、获取/设置寄存器、控制子进程执行等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核ptrace功能中存在竞争条件，允许本地用户通过精心构造的PTRACE_SETREGS系统调用在进程跟踪期间获取特权。\"\"\"",
    "functions": "Functions:\n1. 函数名: ptrace_request\n- 参数: [struct task_struct *child, long request, unsigned long addr, unsigned long data]\n- 调用者: 无（系统调用入口）\n- 被调用者: [generic_ptrace_peekdata, generic_ptrace_pokedata, ptrace_setoptions, put_user, ptrace_getsiginfo, copy_siginfo_to_user, copy_from_user, ptrace_setsiginfo, lock_task_sighand, task_set_jobctl_pending, signal_wake_up, unlock_task_sighand, ptrace_detach, get_task_mm, mmput, ptrace_resume, access_ok, __get_user, ptrace_regset, __put_user]\n\n2. 函数名: generic_ptrace_peekdata\n- 参数: [struct task_struct *child, unsigned long addr, unsigned long data]\n- 调用者: ptrace_request\n- 被调用者: []\n\n3. 函数名: generic_ptrace_pokedata\n- 参数: [struct task_struct *child, unsigned long addr, unsigned long data]\n- 调用者: ptrace_request\n- 被调用者: []\n\n4. 函数名: ptrace_setoptions\n- 参数: [struct task_struct *child, unsigned long data]\n- 调用者: ptrace_request\n- 被调用者: []\n\n5. 函数名: put_user\n- 参数: [unsigned long x, unsigned long __user *ptr]\n- 调用者: ptrace_request\n- 被调用者: []\n\n6. 函数名: ptrace_getsiginfo\n- 参数: [struct task_struct *child, siginfo_t *siginfo]\n- 调用者: ptrace_request\n- 被调用者: []\n\n7. 函数名: copy_siginfo_to_user\n- 参数: [void __user *datavp, siginfo_t *siginfo]\n- 调用者: ptrace_request\n- 被调用者: []\n\n8. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: ptrace_request\n- 被调用者: []\n\n9. 函数名: ptrace_setsiginfo\n- 参数: [struct task_struct *child, siginfo_t *siginfo]\n- 调用者: ptrace_request\n- 被调用者: []\n\n10. 函数名: lock_task_sighand\n- 参数: [struct task_struct *tsk, unsigned long *flags]\n- 调用者: ptrace_request\n- 被调用者: []\n\n11. 函数名: task_set_jobctl_pending\n- 参数: [struct task_struct *task, unsigned int mask]\n- 调用者: ptrace_request\n- 被调用者: []\n\n12. 函数名: signal_wake_up\n- 参数: [struct task_struct *t, bool resume]\n- 调用者: ptrace_request\n- 被调用者: []\n\n13. 函数名: unlock_task_sighand\n- 参数: [struct task_struct *tsk, unsigned long *flags]\n- 调用者: ptrace_request\n- 被调用者: []\n\n14. 函数名: ptrace_detach\n- 参数: [struct task_struct *child, unsigned long data]\n- 调用者: ptrace_request\n- 被调用者: []\n\n15. 函数名: get_task_mm\n- 参数: [struct task_struct *task]\n- 调用者: ptrace_request\n- 被调用者: []\n\n16. 函数名: mmput\n- 参数: [struct mm_struct *mm]\n- 调用者: ptrace_request\n- 被调用者: []\n\n17. 函数名: ptrace_resume\n- 参数: [struct task_struct *child, long request, unsigned long data]\n- 调用者: ptrace_request\n- 被调用者: []\n\n18. 函数名: access_ok\n- 参数: [int type, const void __user *addr, unsigned long size]\n- 调用者: ptrace_request\n- 被调用者: []\n\n19. 函数名: __get_user\n- 参数: [x, ptr]\n- 调用者: ptrace_request\n- 被调用者: []\n\n20. 函数名: ptrace_regset\n- 参数: [struct task_struct *child, int request, unsigned int addr, struct iovec *kiov]\n- 调用者: ptrace_request\n- 被调用者: []\n\n21. 函数名: __put_user\n- 参数: [x, ptr]\n- 调用者: ptrace_request\n- 被调用者: []"
  },
  {
    "id": 163,
    "cwe": "CWE-362",
    "cve": "CVE-2013-0871",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理进程跟踪(ptrace)的解除链接操作，包括清理跟踪状态、恢复父进程关系和处理任务停止信号。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在ptrace_unlink函数中存在竞争条件，当PTRACE_SETREGS系统调用在特定时机执行时，可能导致权限提升漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: __ptrace_unlink\n- 参数: [struct task_struct *child]\n- 调用者: 未明确显示（通常是内核中的ptrace相关函数）\n- 被调用者: [BUG_ON, list_del_init, spin_lock, task_clear_jobctl_pending, task_clear_jobctl_trapping, spin_unlock, signal_wake_up]\n\n2. 函数名: BUG_ON\n- 参数: [!child->ptrace]\n- 调用者: __ptrace_unlink\n- 被调用者: []\n\n3. 函数名: list_del_init\n- 参数: [&child->ptrace_entry]\n- 调用者: __ptrace_unlink\n- 被调用者: []\n\n4. 函数名: spin_lock\n- 参数: [&child->sighand->siglock]\n- 调用者: __ptrace_unlink\n- 被调用者: []\n\n5. 函数名: task_clear_jobctl_pending\n- 参数: [child, JOBCTL_TRAP_MASK]\n- 调用者: __ptrace_unlink\n- 被调用者: []\n\n6. 函数名: task_clear_jobctl_trapping\n- 参数: [child]\n- 调用者: __ptrace_unlink\n- 被调用者: []\n\n7. 函数名: spin_unlock\n- 参数: [&child->sighand->siglock]\n- 调用者: __ptrace_unlink\n- 被调用者: []\n\n8. 函数名: signal_wake_up\n- 参数: [child, task_is_traced(child)]\n- 调用者: __ptrace_unlink\n- 被调用者: []\n\n9. 函数名: task_is_traced\n- 参数: [child]\n- 调用者: signal_wake_up\n- 被调用者: []"
  },
  {
    "id": 164,
    "cwe": "CWE-362",
    "cve": "CVE-2013-0871",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中ptrace系统调用的附加(attach)功能，用于允许一个进程跟踪和控制另一个进程的执行状态。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核ptrace功能中存在竞争条件，允许本地用户通过精心构造的PTRACE_SETREGS系统调用在进程跟踪过程中获取特权。\"\"\"",
    "functions": "Functions:\n1. 函数名: ptrace_attach\n- 参数: [struct task_struct *task, long request, unsigned long addr, unsigned long flags]\n- 调用者: N/A (kernel-level function)\n- 被调用者: [audit_ptrace, same_thread_group, mutex_lock_interruptible, __ptrace_may_access, ns_capable, __ptrace_link, send_sig_info, task_is_stopped, task_set_jobctl_pending, signal_wake_up, wait_on_bit, proc_ptrace_connector]\n\n2. 函数名: audit_ptrace\n- 参数: [struct task_struct *task]\n- 调用者: ptrace_attach\n- 被调用者: []\n\n3. 函数名: same_thread_group\n- 参数: [struct task_struct *task, struct task_struct *current]\n- 调用者: ptrace_attach\n- 被调用者: []\n\n4. 函数名: mutex_lock_interruptible\n- 参数: [struct mutex *task->signal->cred_guard_mutex]\n- 调用者: ptrace_attach\n- 被调用者: []\n\n5. 函数名: __ptrace_may_access\n- 参数: [struct task_struct *task, PTRACE_MODE_ATTACH]\n- 调用者: ptrace_attach\n- 被调用者: []\n\n6. 函数名: ns_capable\n- 参数: [__task_cred(task)->user_ns, CAP_SYS_PTRACE]\n- 调用者: ptrace_attach\n- 被调用者: []\n\n7. 函数名: __ptrace_link\n- 参数: [struct task_struct *task, struct task_struct *current]\n- 调用者: ptrace_attach\n- 被调用者: []\n\n8. 函数名: send_sig_info\n- 参数: [SIGSTOP, SEND_SIG_FORCED, task]\n- 调用者: ptrace_attach\n- 被调用者: []\n\n9. 函数名: task_is_stopped\n- 参数: [struct task_struct *task]\n- 调用者: ptrace_attach\n- 被调用者: []\n\n10. 函数名: task_set_jobctl_pending\n- 参数: [struct task_struct *task, JOBCTL_TRAP_STOP | JOBCTL_TRAPPING]\n- 调用者: ptrace_attach\n- 被调用者: []\n\n11. 函数名: signal_wake_up\n- 参数: [struct task_struct *task, 1]\n- 调用者: ptrace_attach\n- 被调用者: []\n\n12. 函数名: wait_on_bit\n- 参数: [&task->jobctl, JOBCTL_TRAPPING_BIT, ptrace_trapping_sleep_fn, TASK_UNINTERRUPTIBLE]\n- 调用者: ptrace_attach\n- 被调用者: []\n\n13. 函数名: proc_ptrace_connector\n- 参数: [struct task_struct *task, PTRACE_ATTACH]\n- 调用者: ptrace_attach\n- 被调用者: []"
  },
  {
    "id": 165,
    "cwe": "CWE-362",
    "cve": "CVE-2013-0871",
    "purpose": "Code purpose:\"\"\"该代码用于在ptrace调试过程中处理被调试进程的陷阱通知，通过设置任务控制标志和唤醒信号来实现调试器与被调试进程间的同步\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在ptrace功能中存在竞争条件，允许本地用户通过精心设计的PTRACE_SETREGS系统调用在错误时机修改寄存器状态，从而提升权限\"\"\"",
    "functions": "Functions:\n1. 函数名: ptrace_trap_notify\n- 参数: [struct task_struct *t]\n- 调用者: 不适用（未在代码片段中显示）\n- 被调用者: [WARN_ON_ONCE, assert_spin_locked, task_set_jobctl_pending, signal_wake_up]\n\n2. 函数名: WARN_ON_ONCE\n- 参数: [! (t->ptrace & PT_SEIZED)]\n- 调用者: ptrace_trap_notify\n- 被调用者: []\n\n3. 函数名: assert_spin_locked\n- 参数: [&t->sighand->siglock]\n- 调用者: ptrace_trap_notify\n- 被调用者: []\n\n4. 函数名: task_set_jobctl_pending\n- 参数: [t, JOBCTL_TRAP_NOTIFY]\n- 调用者: ptrace_trap_notify\n- 被调用者: []\n\n5. 函数名: signal_wake_up\n- 参数: [t, t->jobctl & JOBCTL_LISTENING]\n- 调用者: ptrace_trap_notify\n- 被调用者: []"
  },
  {
    "id": 184,
    "cwe": "CWE-362",
    "cve": "CVE-2013-1792",
    "purpose": "Code purpose:\"\"\"该代码用于为Linux系统中的用户安装UID特定的密钥环和会话密钥环，以管理用户的密钥权限和会话安全。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在多线程环境下，install_user_keyrings函数未正确处理用户密钥环的并发创建和访问，导致竞态条件下可能发生空指针解引用\"\"\"",
    "functions": "Functions:\n1. 函数名: install_user_keyrings\n- 参数: []\n- 调用者: \n- 被调用者: [current_cred, from_kuid, kenter, kleave, mutex_lock, sprintf, find_keyring_by_name, keyring_alloc, IS_ERR, PTR_ERR, key_link, key_put, mutex_unlock]\n\n2. 函数名: current_cred\n- 参数: []\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n3. 函数名: from_kuid\n- 参数: [cred->user_ns, user->uid]\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n4. 函数名: kenter\n- 参数: [\"%p{%u}\", user, uid]\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n5. 函数名: kleave\n- 参数: [\" = 0 [exist]\"] 和 [\" = %d\", ret]\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n6. 函数名: mutex_lock\n- 参数: [&key_user_keyring_mutex]\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n7. 函数名: sprintf\n- 参数: [buf, \"_uid.%u\", uid] 和 [buf, \"_uid_ses.%u\", uid]\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n8. 函数名: find_keyring_by_name\n- 参数: [buf, true]\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n9. 函数名: keyring_alloc\n- 参数: [buf, user->uid, INVALID_GID, cred, user_keyring_perm, KEY_ALLOC_IN_QUOTA, NULL]\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n10. 函数名: IS_ERR\n- 参数: [uid_keyring] 和 [session_keyring]\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n11. 函数名: PTR_ERR\n- 参数: [uid_keyring] 和 [session_keyring]\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n12. 函数名: key_link\n- 参数: [session_keyring, uid_keyring]\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n13. 函数名: key_put\n- 参数: [session_keyring] 和 [uid_keyring]\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n14. 函数名: mutex_unlock\n- 参数: [&key_user_keyring_mutex]\n- 调用者: install_user_keyrings\n- 被调用者: []"
  },
  {
    "id": 206,
    "cwe": "CWE-362",
    "cve": "CVE-2013-1935",
    "purpose": "Code purpose:\"\"\"该代码实现了KVM虚拟化环境中虚拟机控制块(VCpu)进入客户机模式的处理流程，包括请求处理、MMU重载、模式切换、中断处理以及退出处理等功能。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在禁用中断的时间窗口内未正确处理PV EOI特性，导致guest OS用户可通过copy_to_user调用造成host OS崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: vcpu_enter_guest\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: N/A\n- 被调用者: [irqchip_in_kernel, kvm_check_request, kvm_mmu_unload, __kvm_migrate_timers, kvm_write_guest_time, kvm_mmu_sync_roots, kvm_x86_ops->tlb_flush, kvm_x86_ops->fpu_deactivate, kvm_mmu_reload, preempt_disable, kvm_x86_ops->prepare_guest_switch, kvm_load_guest_fpu, kvm_load_guest_xcr0, atomic_set, smp_wmb, local_irq_disable, atomic_read, need_resched, signal_pending, kvm_make_request, local_irq_enable, preempt_enable, inject_pending_event, kvm_x86_ops->enable_nmi_window, kvm_cpu_has_interrupt, kvm_x86_ops->enable_irq_window, kvm_lapic_enabled, update_cr8_intercept, kvm_lapic_sync_to_vapic, srcu_read_unlock, kvm_guest_enter, set_debugreg, trace_kvm_entry, kvm_x86_ops->run, hw_breakpoint_active, hw_breakpoint_restore, kvm_get_msr, barrier, kvm_guest_exit, srcu_read_lock, profile_hit, kvm_lapic_sync_from_vapic, kvm_x86_ops->handle_exit, kvm_rip_read]\n\n2. 函数名: irqchip_in_kernel\n- 参数: [struct kvm *kvm]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n3. 函数名: kvm_check_request\n- 参数: [int req, struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n4. 函数名: kvm_mmu_unload\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n5. 函数名: __kvm_migrate_timers\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n6. 函数名: kvm_write_guest_time\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n7. 函数名: kvm_mmu_sync_roots\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n8. 函数名: kvm_mmu_reload\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n9. 函数名: kvm_make_request\n- 参数: [int req, struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n10. 函数名: inject_pending_event\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n11. 函数名: kvm_cpu_has_interrupt\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n12. 函数名: update_cr8_intercept\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n13. 函数名: kvm_lapic_sync_to_vapic\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n14. 函数名: kvm_lapic_sync_from_vapic\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n15. 函数名: kvm_rip_read\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A"
  },
  {
    "id": 277,
    "cwe": "CWE-362",
    "cve": "CVE-2013-3302",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中通过SMB协议发送请求到服务器，处理数据分片发送和错误恢复\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在smb_send_rqst函数中处理重新连接事件时存在竞态条件，可能导致空指针解引用\"\"\"",
    "functions": "Functions:\n1. 函数名: smb_send_rqst\n- 参数: [struct TCP_Server_Info *server, struct smb_rqst *rqst]\n- 调用者: N/A (top-level function)\n- 被调用者: [get_rfc1002_length, dump_smb, kernel_setsockopt, smb_send_kvec, cifs_rqst_page_to_kvec, kunmap]\n\n2. 函数名: get_rfc1002_length\n- 参数: [iov[0].iov_base]\n- 调用者: smb_send_rqst\n- 被调用者: N/A\n\n3. 函数名: dump_smb\n- 参数: [iov[0].iov_base, iov[0].iov_len]\n- 调用者: smb_send_rqst\n- 被调用者: N/A\n\n4. 函数名: kernel_setsockopt\n- 参数: [ssocket, SOL_TCP, TCP_CORK, (char *)&val, sizeof(val)]\n- 调用者: smb_send_rqst\n- 被调用者: N/A\n\n5. 函数名: smb_send_kvec\n- 参数: [server, iov, n_vec, &sent] and [server, &p_iov, 1, &sent]\n- 调用者: smb_send_rqst\n- 被调用者: N/A\n\n6. 函数名: cifs_rqst_page_to_kvec\n- 参数: [rqst, i, &p_iov]\n- 调用者: smb_send_rqst\n- 被调用者: N/A\n\n7. 函数名: kunmap\n- 参数: [rqst->rq_pages[i]]\n- 调用者: smb_send_rqst\n- 被调用者: N/A"
  },
  {
    "id": 278,
    "cwe": "CWE-362",
    "cve": "CVE-2013-3302",
    "purpose": "Code purpose:\"\"\"该代码实现了SMB协议中通过TCP套接字发送数据块的功能，包括处理阻塞/非阻塞发送、重试机制和错误处理。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在重新连接事件中，由于竞争条件导致ssocket指针可能被置为NULL，从而引发空指针解引用问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: smb_send_kvec\n- 参数: [struct TCP_Server_Info *server, struct kvec *iov, size_t n_vec, size_t *sent]\n- 调用者: 未明确显示（可能是smb_send_rqst等上层函数）\n- 被调用者: [kernel_sendmsg, msleep]\n\n2. 函数名: kernel_sendmsg\n- 参数: [struct socket *ssocket, struct msghdr *smb_msg, struct kvec *iov, size_t n_vec, unsigned int remaining]\n- 调用者: smb_send_kvec\n- 被调用者: 未显示（内核底层函数）\n\n3. 函数名: msleep\n- 参数: [unsigned int msecs]\n- 调用者: smb_send_kvec\n- 被调用者: 未显示（内核调度函数）\n\n4. 函数名: WARN_ON_ONCE\n- 参数: [bool condition]\n- 调用者: smb_send_kvec\n- 被调用者: 未显示（内核调试宏）\n\n5. 函数名: cERROR\n- 参数: [int level, const char *format, ...]\n- 调用者: smb_send_kvec\n- 被调用者: 未显示（日志记录函数）"
  },
  {
    "id": 355,
    "cwe": "CWE-362",
    "cve": "CVE-2013-7026",
    "purpose": "Code purpose:\"\"\"该代码用于销毁共享内存段，包括资源计数调整、内存解锁和文件引用释放等操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在共享内存操作中存在竞态条件，当使用shmctl IPC_RMID操作与其他shm系统调用同时执行时，可能导致use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: shm_destroy\n- 参数: [ns, shp]\n- 调用者: 未显示\n- 被调用者: [shm_rmid, shm_unlock, is_file_hugepages, shmem_lock, user_shm_unlock, file_inode, fput, ipc_rcu_putref, shm_rcu_free]\n\n2. 函数名: shm_rmid\n- 参数: [ns, shp]\n- 调用者: shm_destroy\n- 被调用者: 未显示\n\n3. 函数名: shm_unlock\n- 参数: [shp]\n- 调用者: shm_destroy\n- 被调用者: 未显示\n\n4. 函数名: is_file_hugepages\n- 参数: [shp->shm_file]\n- 调用者: shm_destroy\n- 被调用者: 未显示\n\n5. 函数名: shmem_lock\n- 参数: [shp->shm_file, 0, shp->mlock_user]\n- 调用者: shm_destroy\n- 被调用者: 未显示\n\n6. 函数名: user_shm_unlock\n- 参数: [file_inode(shp->shm_file)->i_size, shp->mlock_user]\n- 调用者: shm_destroy\n- 被调用者: 未显示\n\n7. 函数名: file_inode\n- 参数: [shp->shm_file]\n- 调用者: user_shm_unlock\n- 被调用者: 未显示\n\n8. 函数名: fput\n- 参数: [shp->shm_file]\n- 调用者: shm_destroy\n- 被调用者: 未显示\n\n9. 函数名: ipc_rcu_putref\n- 参数: [shp, shm_rcu_free]\n- 调用者: shm_destroy\n- 被调用者: [shm_rcu_free]\n\n10. 函数名: shm_rcu_free\n- 参数: 未显示\n- 调用者: ipc_rcu_putref\n- 被调用者: 未显示"
  },
  {
    "id": 356,
    "cwe": "CWE-362",
    "cve": "CVE-2013-7026",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中对共享内存区域的控制操作，包括查询状态、设置属性、锁定/解锁以及删除等功能的系统调用处理。\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核的共享内存控制(shmctl)实现中，存在多个竞态条件，当本地用户在使用IPC_RMID操作删除共享内存段的同时并发执行其他shm系统调用时，会导致释放后使用(use-after-free)问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: SYSCALL_DEFINE3(shmctl)\n- 参数: [int shmid, int cmd, struct shmid_ds __user *buf]\n- 调用者: 系统调用\n- 被调用者: [ipc_parse_version, shmctl_nolock, shmctl_down, shm_obtain_object_check, audit_ipc_obj, security_shm_shmctl, ipc_lock_object, ns_capable, current_euid, uid_eq, rlimit, is_file_hugepages, shmem_lock, get_file, ipc_unlock_object, shmem_unlock_mapping, fput]\n\n2. 函数名: ipc_parse_version\n- 参数: [int *cmd]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n3. 函数名: shmctl_nolock\n- 参数: [struct ipc_namespace *ns, int shmid, int cmd, int version, struct shmid_ds __user *buf]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n4. 函数名: shmctl_down\n- 参数: [struct ipc_namespace *ns, int shmid, int cmd, struct shmid_ds __user *buf, int version]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n5. 函数名: shm_obtain_object_check\n- 参数: [struct ipc_namespace *ns, int shmid]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n6. 函数名: audit_ipc_obj\n- 参数: [struct kern_ipc_perm *perm]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n7. 函数名: security_shm_shmctl\n- 参数: [struct shmid_kernel *shp, int cmd]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n8. 函数名: ipc_lock_object\n- 参数: [struct kern_ipc_perm *perm]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n9. 函数名: ns_capable\n- 参数: [struct user_namespace *user_ns, int cap]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n10. 函数名: current_euid\n- 参数: []\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n11. 函数名: uid_eq\n- 参数: [kuid_t left, kuid_t right]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n12. 函数名: rlimit\n- 参数: [int limit]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n13. 函数名: is_file_hugepages\n- 参数: [struct file *file]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n14. 函数名: shmem_lock\n- 参数: [struct file *file, int lock, struct user_struct *user]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n15. 函数名: get_file\n- 参数: [struct file *file]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n16. 函数名: ipc_unlock_object\n- 参数: [struct kern_ipc_perm *perm]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n17. 函数名: shmem_unlock_mapping\n- 参数: [struct address_space *mapping]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n18. 函数名: fput\n- 参数: [struct file *file]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []"
  },
  {
    "id": 357,
    "cwe": "CWE-362",
    "cve": "CVE-2013-7026",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中共享内存(SHM)的附加(shmat)功能，允许进程将共享内存段附加到其地址空间，并处理相关的权限检查、内存映射和并发访问控制。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在shmctl IPC_RMID操作与其他共享内存系统调用并发时存在竞争条件，导致使用已释放的内存引发拒绝服务或潜在的其他影响\"\"\"",
    "functions": "Functions:\n1. 函数名: do_shmat\n- 参数: [shmid, shmaddr, shmflg, raddr, shmlba]\n- 调用者: N/A (系统调用)\n- 被调用者: [shm_obtain_object_check, ipcperms, security_shm_shmat, ipc_lock_object, path_get, i_size_read, ipc_unlock_object, kzalloc, path_put, alloc_file, kfree, get_ipc_ns, security_mmap_file, down_write, find_vma_intersection, do_mmap_pgoff, up_write, mm_populate, fput, shm_lock, shm_may_destroy, shm_destroy, shm_unlock]\n\n2. 函数名: shm_obtain_object_check\n- 参数: [ns, shmid]\n- 调用者: do_shmat\n- 被调用者: []\n\n3. 函数名: ipcperms\n- 参数: [ns, shm_perm, acc_mode]\n- 调用者: do_shmat\n- 被调用者: []\n\n4. 函数名: security_shm_shmat\n- 参数: [shp, shmaddr, shmflg]\n- 调用者: do_shmat\n- 被调用者: []\n\n5. 函数名: ipc_lock_object\n- 参数: [shm_perm]\n- 调用者: do_shmat\n- 被调用者: []\n\n6. 函数名: path_get\n- 参数: [path]\n- 调用者: do_shmat\n- 被调用者: []\n\n7. 函数名: i_size_read\n- 参数: [dentry->d_inode]\n- 调用者: do_shmat\n- 被调用者: []\n\n8. 函数名: ipc_unlock_object\n- 参数: [shm_perm]\n- 调用者: do_shmat\n- 被调用者: []\n\n9. 函数名: kzalloc\n- 参数: [sizeof(*sfd), GFP_KERNEL]\n- 调用者: do_shmat\n- 被调用者: []\n\n10. 函数名: path_put\n- 参数: [path]\n- 调用者: do_shmat\n- 被调用者: []\n\n11. 函数名: alloc_file\n- 参数: [path, f_mode, shm_file_operations_huge/shm_file_operations]\n- 调用者: do_shmat\n- 被调用者: []\n\n12. 函数名: kfree\n- 参数: [sfd]\n- 调用者: do_shmat\n- 被调用者: []\n\n13. 函数名: get_ipc_ns\n- 参数: [ns]\n- 调用者: do_shmat\n- 被调用者: []\n\n14. 函数名: security_mmap_file\n- 参数: [file, prot, flags]\n- 调用者: do_shmat\n- 被调用者: []\n\n15. 函数名: down_write\n- 参数: [current->mm->mmap_sem]\n- 调用者: do_shmat\n- 被调用者: []\n\n16. 函数名: find_vma_intersection\n- 参数: [current->mm, addr, addr + size]\n- 调用者: do_shmat\n- 被调用者: []\n\n17. 函数名: do_mmap_pgoff\n- 参数: [file, addr, size, prot, flags, 0, populate]\n- 调用者: do_shmat\n- 被调用者: []\n\n18. 函数名: up_write\n- 参数: [current->mm->mmap_sem]\n- 调用者: do_shmat\n- 被调用者: []\n\n19. 函数名: mm_populate\n- 参数: [addr, populate]\n- 调用者: do_shmat\n- 被调用者: []\n\n20. 函数名: fput\n- 参数: [file]\n- 调用者: do_shmat\n- 被调用者: []\n\n21. 函数名: shm_lock\n- 参数: [ns, shmid]\n- 调用者: do_shmat\n- 被调用者: []\n\n22. 函数名: shm_may_destroy\n- 参数: [ns, shp]\n- 调用者: do_shmat\n- 被调用者: []\n\n23. 函数名: shm_destroy\n- 参数: [ns, shp]\n- 调用者: do_shmat\n- 被调用者: []\n\n24. 函数名: shm_unlock\n- 参数: [shp]\n- 调用者: do_shmat\n- 被调用者: []"
  },
  {
    "id": 428,
    "cwe": "CWE-362",
    "cve": "CVE-2014-0100",
    "purpose": "Code purpose:\"\"\"该代码用于在网络碎片重组过程中管理碎片队列，通过哈希表查找或创建新的队列项，并处理并发访问时的竞争条件\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在inet_frag_intern函数中存在竞争条件，当系统CPU负载高时，攻击者通过发送大量分片ICMP Echo请求包可能导致使用后释放错误\"\"\"",
    "functions": "Functions:\n1. 函数名: inet_frag_intern\n- 参数: [struct netns_frags *nf, struct inet_frag_queue *qp_in, struct inet_frags *f, void *arg]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [atomic_inc, mod_timer, hlist_add_head, inet_frag_put, inet_frag_lru_add, read_lock, read_unlock, spin_lock, spin_unlock]\n\n2. 函数名: atomic_inc\n- 参数: [atomic_t *v]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n3. 函数名: mod_timer\n- 参数: [struct timer_list *timer, unsigned long expires]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n4. 函数名: hlist_add_head\n- 参数: [struct hlist_node *n, struct hlist_head *h]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n5. 函数名: inet_frag_put\n- 参数: [struct inet_frag_queue *q, struct inet_frags *f]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n6. 函数名: inet_frag_lru_add\n- 参数: [struct netns_frags *nf, struct inet_frag_queue *q]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n7. 函数名: read_lock\n- 参数: [rwlock_t *lock]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n8. 函数名: read_unlock\n- 参数: [rwlock_t *lock]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n9. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n10. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: inet_frag_intern\n- 被调用者: []"
  },
  {
    "id": 461,
    "cwe": "CWE-362",
    "cve": "CVE-2014-0196",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中tty设备的写入功能，处理来自用户空间的数据写入操作，包括作业控制检查、字符回显处理和输出缓冲管理。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核n_tty_write函数在处理'LECHO & !OPOST'情况时未能正确管理tty驱动访问，导致竞争条件可能引发内存破坏或权限提升\"\"\"",
    "functions": "Functions:\n1. 函数名: n_tty_write\n- 参数: [tty, file, buf, nr]\n- 调用者: 未明确（通常是tty子系统调用）\n- 被调用者: [L_TOSTOP, redirected_tty_write, tty_check_change, down_read, process_echoes, add_wait_queue, set_current_state, signal_pending, tty_hung_up_p, O_OPOST, process_output_block, process_output, flush_chars, write, up_read, schedule, __set_current_state, remove_wait_queue, set_bit]\n\n2. 函数名: L_TOSTOP\n- 参数: [tty]\n- 调用者: n_tty_write\n- 被调用者: []\n\n3. 函数名: redirected_tty_write\n- 参数: 未明确（通过file->f_op->write调用）\n- 调用者: n_tty_write\n- 被调用者: []\n\n4. 函数名: tty_check_change\n- 参数: [tty]\n- 调用者: n_tty_write\n- 被调用者: []\n\n5. 函数名: down_read\n- 参数: [&tty->termios_rwsem]\n- 调用者: n_tty_write\n- 被调用者: []\n\n6. 函数名: process_echoes\n- 参数: [tty]\n- 调用者: n_tty_write\n- 被调用者: []\n\n7. 函数名: add_wait_queue\n- 参数: [&tty->write_wait, &wait]\n- 调用者: n_tty_write\n- 被调用者: []\n\n8. 函数名: set_current_state\n- 参数: [TASK_INTERRUPTIBLE]\n- 调用者: n_tty_write\n- 被调用者: []\n\n9. 函数名: signal_pending\n- 参数: [current]\n- 调用者: n_tty_write\n- 被调用者: []\n\n10. 函数名: tty_hung_up_p\n- 参数: [file]\n- 调用者: n_tty_write\n- 被调用者: []\n\n11. 函数名: O_OPOST\n- 参数: [tty]\n- 调用者: n_tty_write\n- 被调用者: []\n\n12. 函数名: process_output_block\n- 参数: [tty, b, nr]\n- 调用者: n_tty_write\n- 被调用者: []\n\n13. 函数名: process_output\n- 参数: [c, tty]\n- 调用者: n_tty_write\n- 被调用者: []\n\n14. 函数名: flush_chars\n- 参数: [tty]\n- 调用者: n_tty_write\n- 被调用者: []\n\n15. 函数名: write\n- 参数: [tty, b, nr]\n- 调用者: n_tty_write\n- 被调用者: []\n\n16. 函数名: up_read\n- 参数: [&tty->termios_rwsem]\n- 调用者: n_tty_write\n- 被调用者: []\n\n17. 函数名: schedule\n- 参数: []\n- 调用者: n_tty_write\n- 被调用者: []\n\n18. 函数名: __set_current_state\n- 参数: [TASK_RUNNING]\n- 调用者: n_tty_write\n- 被调用者: []\n\n19. 函数名: remove_wait_queue\n- 参数: [&tty->write_wait, &wait]\n- 调用者: n_tty_write\n- 被调用者: []\n\n20. 函数名: set_bit\n- 参数: [TTY_DO_WRITE_WAKEUP, &tty->flags]\n- 调用者: n_tty_write\n- 被调用者: []"
  },
  {
    "id": 491,
    "cwe": "CWE-362",
    "cve": "CVE-2014-2672",
    "purpose": "Code purpose:\"\"\"该代码用于在无线网络传输中处理聚合帧的休眠状态，通过遍历传输标识列表来管理调度状态和缓冲数据，并在适当时解除调度和清理列表项\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在ath_tx_aggr_sleep函数中对共享资源（tid->list和ac->list）的访问缺乏足够的同步保护，导致在多线程环境下可能发生竞态条件，从而引发系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: ath_tx_aggr_sleep\n- 参数: [sta, sc, an]\n- 调用者: N/A\n- 被调用者: [ath_txq_lock, ath_tid_has_buffered, list_del, ath_txq_unlock, ieee80211_sta_set_buffered]\n\n2. 函数名: ath_txq_lock\n- 参数: [sc, txq]\n- 调用者: ath_tx_aggr_sleep\n- 被调用者: N/A\n\n3. 函数名: ath_tid_has_buffered\n- 参数: [tid]\n- 调用者: ath_tx_aggr_sleep\n- 被调用者: N/A\n\n4. 函数名: list_del\n- 参数: [&tid->list]\n- 调用者: ath_tx_aggr_sleep\n- 被调用者: N/A\n\n5. 函数名: list_del\n- 参数: [&ac->list]\n- 调用者: ath_tx_aggr_sleep\n- 被调用者: N/A\n\n6. 函数名: ath_txq_unlock\n- 参数: [sc, txq]\n- 调用者: ath_tx_aggr_sleep\n- 被调用者: N/A\n\n7. 函数名: ieee80211_sta_set_buffered\n- 参数: [sta, tidno, buffered]\n- 调用者: ath_tx_aggr_sleep\n- 被调用者: N/A"
  },
  {
    "id": 494,
    "cwe": "CWE-362",
    "cve": "CVE-2014-2706",
    "purpose": "Code purpose:\"\"\"分配并初始化一个无线网络站点(STA)的信息结构体，包括内存分配、状态设置和统计信息初始化等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"竞争条件漏洞源于内核mac80211子系统中对WLAN_STA_PS_STA(节能模式)状态的处理不当，导致远程攻击者可通过特制网络流量触发系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: sta_info_alloc\n- 参数: [struct ieee80211_sub_if_data *sdata, const u8 *addr, gfp_t gfp]\n- 调用者: 未显示\n- 被调用者: [kzalloc, rcu_read_lock, rcu_dereference, kzalloc, rcu_read_unlock, kcalloc, spin_lock_init, INIT_WORK, mutex_init, init_timer, memcpy, jiffies, do_posix_clock_monotonic_gettime, ewma_init, sta_prepare_rate_control, skb_queue_head_init, cpu_to_le16, sta_dbg, kfree]\n\n2. 函数名: sta_unblock\n- 参数: 未显示\n- 调用者: INIT_WORK\n- 被调用者: 未显示\n\n3. 函数名: ieee80211_ba_session_work\n- 参数: 未显示\n- 调用者: INIT_WORK\n- 被调用者: 未显示\n\n4. 函数名: sta_rx_agg_session_timer_expired\n- 参数: 未显示\n- 调用者: 未显示（仅在注释中提到）\n- 被调用者: 未显示\n\n5. 函数名: sta_prepare_rate_control\n- 参数: [struct ieee80211_local *local, struct sta_info *sta, gfp_t gfp]\n- 调用者: sta_info_alloc\n- 被调用者: 未显示\n\n6. 函数名: sta_dbg\n- 参数: [struct ieee80211_sub_if_data *sdata, const char *fmt, ...]\n- 调用者: sta_info_alloc\n- 被调用者: 未显示"
  },
  {
    "id": 495,
    "cwe": "CWE-362",
    "cve": "CVE-2014-2706",
    "purpose": "Code purpose:\"\"\"该代码用于处理无线客户端从省电模式唤醒时的数据帧传输和状态更新，包括将缓冲的帧发送给客户端并更新其电源管理状态。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在sta_info.c和tx.c中处理WLAN_STA_PS_STA状态(节能模式)时存在竞态条件，远程攻击者可通过网络流量不当交互导致系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: ieee80211_sta_ps_deliver_wakeup\n- 参数: [struct sta_info *sta]\n- 调用者: 未显示\n- 被调用者: [clear_sta_flag, BUILD_BUG_ON, drv_sta_notify, skb_queue_head_init, skb_queue_len, spin_lock_irqsave, skb_queue_splice_tail_init, spin_unlock_irqrestore, ieee80211_add_pending_skbs_fn, ieee80211_smps_is_restrictive, sta_info_tx_streams, ht_dbg, ieee80211_send_smps_action, sta_info_recalc_tim, ps_dbg]\n\n2. 函数名: clear_sta_flag\n- 参数: [struct sta_info *sta, WLAN_STA_SP]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n3. 函数名: BUILD_BUG_ON\n- 参数: [BITS_TO_LONGS(IEEE80211_NUM_TIDS) > 1]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n4. 函数名: drv_sta_notify\n- 参数: [local, sdata, STA_NOTIFY_AWAKE, &sta->sta]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n5. 函数名: skb_queue_head_init\n- 参数: [&pending]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n6. 函数名: skb_queue_len\n- 参数: [&pending], [&pending]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n7. 函数名: spin_lock_irqsave\n- 参数: [&sta->tx_filtered[ac].lock, flags], [&sta->ps_tx_buf[ac].lock, flags]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n8. 函数名: skb_queue_splice_tail_init\n- 参数: [&sta->tx_filtered[ac], &pending], [&sta->ps_tx_buf[ac], &pending]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n9. 函数名: spin_unlock_irqrestore\n- 参数: [&sta->tx_filtered[ac].lock, flags], [&sta->ps_tx_buf[ac].lock, flags]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n10. 函数名: ieee80211_add_pending_skbs_fn\n- 参数: [local, &pending, clear_sta_ps_flags, sta]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n11. 函数名: ieee80211_smps_is_restrictive\n- 参数: [sta->known_smps_mode, sdata->smps_mode]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n12. 函数名: sta_info_tx_streams\n- 参数: [sta]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n13. 函数名: ht_dbg\n- 参数: [sdata, \"%pM just woke up and MIMO capable - update SMPS\\n\", sta->sta.addr]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n14. 函数名: ieee80211_send_smps_action\n- 参数: [sdata, sdata->bss->req_smps, sta->sta.addr, sdata->vif.bss_conf.bssid]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n15. 函数名: sta_info_recalc_tim\n- 参数: [sta]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n16. 函数名: ps_dbg\n- 参数: [sdata, \"STA %pM aid %d sending %d filtered/%d PS frames since STA not sleeping anymore\\n\", sta->sta.addr, sta->sta.aid, filtered, buffered]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示"
  },
  {
    "id": 496,
    "cwe": "CWE-362",
    "cve": "CVE-2014-2706",
    "purpose": "Code purpose:\"\"\"处理无线网络单播数据帧在电源节省模式下的缓冲和传输\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核mac80211子系统中存在竞态条件，当网络流量与WLAN_STA_PS_STA(节能模式)状态异常交互时，导致系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: ieee80211_tx_h_unicast_ps_buf\n- 参数: [struct ieee80211_tx_data *tx]\n- 调用者: 未显示\n- 被调用者: [test_sta_flag, skb_get_queue_mapping, ps_dbg, purge_old_ps_buffers, skb_queue_len, skb_dequeue, ieee80211_free_txskb, timer_pending, mod_timer, round_jiffies, sta_info_recalc_tim]\n\n2. 函数名: test_sta_flag\n- 参数: [struct sta_info *sta, int flag]\n- 调用者: ieee80211_tx_h_unicast_ps_buf\n- 被调用者: 未显示\n\n3. 函数名: skb_get_queue_mapping\n- 参数: [struct sk_buff *skb]\n- 调用者: ieee80211_tx_h_unicast_ps_buf\n- 被调用者: 未显示\n\n4. 函数名: ps_dbg\n- 参数: [struct ieee80211_sub_if_data *sdata, const char *fmt, ...]\n- 调用者: ieee80211_tx_h_unicast_ps_buf\n- 被调用者: 未显示\n\n5. 函数名: purge_old_ps_buffers\n- 参数: [struct ieee80211_local *local]\n- 调用者: ieee80211_tx_h_unicast_ps_buf\n- 被调用者: 未显示\n\n6. 函数名: skb_queue_len\n- 参数: [struct sk_buff_head *list]\n- 调用者: ieee80211_tx_h_unicast_ps_buf\n- 被调用者: 未显示\n\n7. 函数名: skb_dequeue\n- 参数: [struct sk_buff_head *list]\n- 调用者: ieee80211_tx_h_unicast_ps_buf\n- 被调用者: 未显示\n\n8. 函数名: ieee80211_free_txskb\n- 参数: [struct ieee80211_hw *hw, struct sk_buff *skb]\n- 调用者: ieee80211_tx_h_unicast_ps_buf\n- 被调用者: 未显示\n\n9. 函数名: timer_pending\n- 参数: [const struct timer_list *timer]\n- 调用者: ieee80211_tx_h_unicast_ps_buf\n- 被调用者: 未显示\n\n10. 函数名: mod_timer\n- 参数: [struct timer_list *timer, unsigned long expires]\n- 调用者: ieee80211_tx_h_unicast_ps_buf\n- 被调用者: 未显示\n\n11. 函数名: round_jiffies\n- 参数: [unsigned long j]\n- 调用者: ieee80211_tx_h_unicast_ps_buf\n- 被调用者: 未显示\n\n12. 函数名: sta_info_recalc_tim\n- 参数: [struct sta_info *sta]\n- 调用者: ieee80211_tx_h_unicast_ps_buf\n- 被调用者: 未显示"
  },
  {
    "id": 528,
    "cwe": "CWE-362",
    "cve": "CVE-2014-3611",
    "purpose": "Code purpose:\"\"\"在KVM虚拟化环境中迁移PIT(可编程间隔定时器)定时器时处理定时器的取消和重新启动\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于__kvm_migrate_pit_timer函数中缺乏适当的锁机制，导致在PIT定时器迁移过程中存在竞争条件，可能造成主机系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: __kvm_migrate_pit_timer\n- 参数: [vcpu]\n- 调用者: 未明确（由KVM子系统调用）\n- 被调用者: [kvm_vcpu_is_bsp, hrtimer_cancel, hrtimer_start_expires]\n\n2. 函数名: kvm_vcpu_is_bsp\n- 参数: [vcpu]\n- 调用者: __kvm_migrate_pit_timer\n- 被调用者: []\n\n3. 函数名: hrtimer_cancel\n- 参数: [timer]\n- 调用者: __kvm_migrate_pit_timer\n- 被调用者: []\n\n4. 函数名: hrtimer_start_expires\n- 参数: [timer, HRTIMER_MODE_ABS]\n- 调用者: __kvm_migrate_pit_timer\n- 被调用者: []"
  },
  {
    "id": 549,
    "cwe": "CWE-362",
    "cve": "CVE-2014-3940",
    "purpose": "Code purpose:\"\"\"该代码用于处理hugetlb页面的队列操作，包括检查节点设置、迁移条件判断以及隔离大页面的功能\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理hugetlb大页迁移时未正确考虑并发访问情况，导致在numa_maps读取操作期间可能触发竞争条件，造成内存损坏或系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: queue_pages_hugetlb_pmd_range\n- 参数: [vma, pmd, nodes, flags, private]\n- 调用者: 未明确（可能是NUMA内存策略相关调用）\n- 被调用者: [huge_pte_lock, hstate_vma, pte_page, huge_ptep_get, page_to_nid, node_isset, page_mapcount, isolate_huge_page, spin_unlock]\n\n2. 函数名: huge_pte_lock\n- 参数: [hstate_vma(vma), vma->vm_mm, (pte_t *)pmd]\n- 调用者: queue_pages_hugetlb_pmd_range\n- 被调用者: []\n\n3. 函数名: hstate_vma\n- 参数: [vma]\n- 调用者: queue_pages_hugetlb_pmd_range\n- 被调用者: []\n\n4. 函数名: pte_page\n- 参数: [huge_ptep_get((pte_t *)pmd)]\n- 调用者: queue_pages_hugetlb_pmd_range\n- 被调用者: []\n\n5. 函数名: huge_ptep_get\n- 参数: [(pte_t *)pmd]\n- 调用者: queue_pages_hugetlb_pmd_range\n- 被调用者: []\n\n6. 函数名: page_to_nid\n- 参数: [page]\n- 调用者: queue_pages_hugetlb_pmd_range\n- 被调用者: []\n\n7. 函数名: node_isset\n- 参数: [nid, *nodes]\n- 调用者: queue_pages_hugetlb_pmd_range\n- 被调用者: []\n\n8. 函数名: page_mapcount\n- 参数: [page]\n- 调用者: queue_pages_hugetlb_pmd_range\n- 被调用者: []\n\n9. 函数名: isolate_huge_page\n- 参数: [page, private]\n- 调用者: queue_pages_hugetlb_pmd_range\n- 被调用者: []\n\n10. 函数名: spin_unlock\n- 参数: [ptl]\n- 调用者: queue_pages_hugetlb_pmd_range\n- 被调用者: []"
  },
  {
    "id": 563,
    "cwe": "CWE-362",
    "cve": "CVE-2014-4652",
    "purpose": "Code purpose:\"\"\"将用户元素数据从内核空间复制到用户空间的控制元素值中\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺少对用户空间元素数据访问的同步保护，导致竞态条件下内核敏感信息可能被泄露\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_ctl_elem_user_get\n- 参数: [struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol]\n- 调用者: 未明确（由ALSA控制接口调用）\n- 被调用者: [memcpy]"
  },
  {
    "id": 564,
    "cwe": "CWE-362",
    "cve": "CVE-2014-4652",
    "purpose": "Code purpose:\"\"\"该代码片段实现了ALSA控制接口中用户空间元素值的更新功能，通过比较并复制控制元素值来更新内核中的对应数据。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺少适当的同步机制，snd_ctl_elem_user_put函数在处理TLV数据时存在竞态条件，导致本地用户可能通过/dev/snd/controlCX访问获取内核敏感信息\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_ctl_elem_user_put\n- 参数: [struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol]\n- 调用者: 未明确（由ALSA控制接口调用）\n- 被调用者: [memcmp, memcpy]\n\n2. 函数名: memcmp\n- 参数: [const void *s1, const void *s2, size_t n]\n- 调用者: snd_ctl_elem_user_put\n- 被调用者: []\n\n3. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: snd_ctl_elem_user_put\n- 被调用者: []"
  },
  {
    "id": 565,
    "cwe": "CWE-362",
    "cve": "CVE-2014-4652",
    "purpose": "Code purpose:\"\"\"处理ALSA控制元素的TLV(Type-Length-Value)数据，包括从用户空间复制数据到内核空间以及反向操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺少对共享资源ue->tlv_data和ue->tlv_data_size的同步保护，导致竞争条件可能使内核敏感信息泄露。\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_ctl_elem_user_tlv\n- 参数: [struct snd_kcontrol *kcontrol, int op_flag, unsigned int size, unsigned int __user *tlv]\n- 调用者: 未明确（由内核调用）\n- 被调用者: [memdup_user, IS_ERR, PTR_ERR, memcmp, kfree, copy_to_user]\n\n2. 函数名: memdup_user\n- 参数: [unsigned int __user *tlv, unsigned int size]\n- 调用者: snd_ctl_elem_user_tlv\n- 被调用者: []\n\n3. 函数名: IS_ERR\n- 参数: [void *new_data]\n- 调用者: snd_ctl_elem_user_tlv\n- 被调用者: []\n\n4. 函数名: PTR_ERR\n- 参数: [void *new_data]\n- 调用者: snd_ctl_elem_user_tlv\n- 被调用者: []\n\n5. 函数名: memcmp\n- 参数: [ue->tlv_data, new_data, size]\n- 调用者: snd_ctl_elem_user_tlv\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [ue->tlv_data]\n- 调用者: snd_ctl_elem_user_tlv\n- 被调用者: []\n\n7. 函数名: copy_to_user\n- 参数: [tlv, ue->tlv_data, ue->tlv_data_size]\n- 调用者: snd_ctl_elem_user_tlv\n- 被调用者: []"
  },
  {
    "id": 566,
    "cwe": "CWE-362",
    "cve": "CVE-2014-4652",
    "purpose": "Code purpose:\"\"\"该代码用于创建并初始化一个声卡设备结构体，包括分配内存、设置属性、创建控制接口等操作，最终返回声卡对象供系统使用。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于ALSA控制实现中的tlv处理功能存在竞态条件，本地用户可通过访问/dev/snd/controlCX利用该条件获取内核内存中的敏感信息\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_card_new\n- 参数: [struct device *parent, int idx, const char *xid, struct module *module, int extra_size, struct snd_card **card_ret]\n- 调用者: N/A (顶级函数)\n- 被调用者: [kzalloc, strlcpy, mutex_lock, get_slot_from_bitmask, test_bit, mutex_unlock, dev_err, kfree, set_bit, device_initialize, kobject_set_name, snd_ctl_create, snd_info_card_create, snd_device_free_all, put_device]\n\n2. 函数名: get_slot_from_bitmask\n- 参数: [int idx, module_slot_match/check_empty_slot, struct module *module]\n- 调用者: snd_card_new\n- 被调用者: N/A (假设是内部实现)\n\n3. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: snd_card_new\n- 被调用者: N/A (内核内存分配函数)\n\n4. 函数名: strlcpy\n- 参数: [char *dest, const char *src, size_t size]\n- 调用者: snd_card_new\n- 被调用者: N/A (字符串操作函数)\n\n5. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: snd_card_new\n- 被调用者: N/A (同步原语)\n\n6. 函数名: test_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: snd_card_new\n- 被调用者: N/A (位操作函数)\n\n7. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: snd_card_new\n- 被调用者: N/A (同步原语)\n\n8. 函数名: dev_err\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: snd_card_new\n- 被调用者: N/A (日志打印函数)\n\n9. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: snd_card_new\n- 被调用者: N/A (内存释放函数)\n\n10. 函数名: set_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: snd_card_new\n- 被调用者: N/A (位操作函数)\n\n11. 函数名: device_initialize\n- 参数: [struct device *dev]\n- 调用者: snd_card_new\n- 被调用者: N/A (设备初始化函数)\n\n12. 函数名: kobject_set_name\n- 参数: [struct kobject *kobj, const char *fmt, ...]\n- 调用者: snd_card_new\n- 被调用者: N/A (内核对象命名函数)\n\n13. 函数名: snd_ctl_create\n- 参数: [struct snd_card *card]\n- 调用者: snd_card_new\n- 被调用者: N/A (假设是ALSA控制接口创建函数)\n\n14. 函数名: snd_info_card_create\n- 参数: [struct snd_card *card]\n- 调用者: snd_card_new\n- 被调用者: N/A (假设是ALSA信息创建函数)\n\n15. 函数名: snd_device_free_all\n- 参数: [struct snd_card *card]\n- 调用者: snd_card_new\n- 被调用者: N/A (假设是ALSA设备释放函数)\n\n16. 函数名: put_device\n- 参数: [struct device *dev]\n- 调用者: snd_card_new\n- 被调用者: N/A (设备引用计数减少函数)"
  },
  {
    "id": 598,
    "cwe": "CWE-362",
    "cve": "CVE-2014-7842",
    "purpose": "Code purpose:\"\"\"处理KVM虚拟化环境中指令模拟失败的情况，包括统计失败次数、设置退出原因和错误码，并向客户机队列异常\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理模拟失败时存在竞态条件，允许恶意客户机通过MMIO或PIO事务触发用户空间模拟错误报告，导致拒绝服务。\"\"\"",
    "functions": "Functions:\n1. 函数名: handle_emulation_failure\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: 未明确显示（由KVM虚拟化模块调用）\n- 被调用者: [is_guest_mode, trace_kvm_emulate_insn_failed, kvm_queue_exception]\n\n2. 函数名: is_guest_mode\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: handle_emulation_failure\n- 被调用者: []\n\n3. 函数名: trace_kvm_emulate_insn_failed\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: handle_emulation_failure\n- 被调用者: []\n\n4. 函数名: kvm_queue_exception\n- 参数: [struct kvm_vcpu *vcpu, UD_VECTOR]\n- 调用者: handle_emulation_failure\n- 被调用者: []"
  },
  {
    "id": 601,
    "cwe": "CWE-362",
    "cve": "CVE-2014-8086",
    "purpose": "Code purpose:\"\"\"该代码实现了ext4文件系统中文件写入操作的迭代处理，包括处理直接I/O、追加写入、文件大小限制检查等功能，并处理了相关的并发控制和同步问题。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4_file_write_iter函数中，由于对O_DIRECT标志的检查和修改缺乏适当的同步机制，导致在并发执行写操作和fcntl F_SETFL操作时可能引发竞态条件，造成文件不可用。\"\"\"",
    "functions": "Functions:\n1. 函数名: ext4_file_write_iter\n- 参数: [struct kiocb *iocb, struct iov_iter *from]\n- 调用者: N/A (kernel-level function)\n- 被调用者: [file_inode, ext4_test_inode_flag, is_sync_kiocb, ext4_unaligned_aio, ext4_aio_mutex, mutex_lock, ext4_unwritten_wait, i_size_read, EXT4_SB, mutex_unlock, iov_iter_truncate, blk_start_plug, ext4_should_dioread_nolock, ext4_map_blocks, __generic_file_write_iter, generic_write_sync, blk_finish_plug]\n\n2. 函数名: file_inode\n- 参数: [struct file *file]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n3. 函数名: ext4_test_inode_flag\n- 参数: [struct inode *inode, int flag]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n4. 函数名: is_sync_kiocb\n- 参数: [struct kiocb *iocb]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n5. 函数名: ext4_unaligned_aio\n- 参数: [struct inode *inode, struct iov_iter *from, loff_t pos]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n6. 函数名: ext4_aio_mutex\n- 参数: [struct inode *inode]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n7. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n8. 函数名: ext4_unwritten_wait\n- 参数: [struct inode *inode]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n9. 函数名: i_size_read\n- 参数: [struct inode *inode]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n10. 函数名: EXT4_SB\n- 参数: [struct super_block *sb]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n11. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n12. 函数名: iov_iter_truncate\n- 参数: [struct iov_iter *i, size_t count]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n13. 函数名: blk_start_plug\n- 参数: [struct blk_plug *plug]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n14. 函数名: ext4_should_dioread_nolock\n- 参数: [struct inode *inode]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n15. 函数名: ext4_map_blocks\n- 参数: [NULL, struct inode *inode, struct ext4_map_blocks *map, int flags]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n16. 函数名: __generic_file_write_iter\n- 参数: [struct kiocb *iocb, struct iov_iter *from]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n17. 函数名: generic_write_sync\n- 参数: [struct file *file, loff_t pos, ssize_t count]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n18. 函数名: blk_finish_plug\n- 参数: [struct blk_plug *plug]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A"
  },
  {
    "id": 683,
    "cwe": "CWE-362",
    "cve": "CVE-2014-9529",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中安全地回收和销毁不再使用的密钥结构，处理相关的用户配额和引用计数，并释放相关内存资源。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在key_gc_unused_keys函数处理密钥垃圾回收时，存在竞态条件，导致本地用户可通过keyctl命令在密钥结构成员被垃圾回收期间访问它，从而引发内存损坏或系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: key_gc_unused_keys\n- 参数: [struct list_head *keys]\n- 调用者: 未明确（由内核调用）\n- 被调用者: [list_entry, list_del, kdebug, key_check, security_key_free, test_bit, spin_lock, spin_unlock, atomic_dec, key_user_put, key->type->destroy, kfree, kmem_cache_free]\n\n2. 函数名: list_entry\n- 参数: [keys->next, struct key, graveyard_link]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n3. 函数名: list_del\n- 参数: [&key->graveyard_link]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n4. 函数名: kdebug\n- 参数: [\"- %u\", key->serial]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n5. 函数名: key_check\n- 参数: [key]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n6. 函数名: security_key_free\n- 参数: [key]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n7. 函数名: test_bit\n- 参数: [KEY_FLAG_IN_QUOTA, &key->flags]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n8. 函数名: spin_lock\n- 参数: [&key->user->lock]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n9. 函数名: spin_unlock\n- 参数: [&key->user->lock]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n10. 函数名: atomic_dec\n- 参数: [&key->user->nkeys]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n11. 函数名: key_user_put\n- 参数: [key->user]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n12. 函数名: key->type->destroy\n- 参数: [key]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n13. 函数名: kfree\n- 参数: [key->description]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n14. 函数名: kmem_cache_free\n- 参数: [key_jar, key]\n- 调用者: key_gc_unused_keys\n- 被调用者: []"
  },
  {
    "id": 688,
    "cwe": "CWE-362",
    "cve": "CVE-2014-9710",
    "purpose": "Code purpose:\"\"\"该代码实现了Btrfs文件系统中搜索树节点槽位的功能，处理了节点锁定、路径管理以及在插入或删除操作时的树结构调整。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中Btrfs实现未确保可见xattr状态与请求替换的一致性，导致本地用户可通过文件系统操作绕过ACL设置，存在竞争条件或替换失败后的权限提升漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: btrfs_search_slot\n- 参数: [trans, root, key, p, ins_len, cow]\n- 调用者: N/A (顶层函数)\n- 被调用者: [WARN_ON, BUG_ON, extent_buffer_get, btrfs_tree_read_lock, btrfs_root_node, btrfs_read_lock_root_node, btrfs_tree_read_unlock, free_extent_buffer, btrfs_lock_root_node, should_cow_block, btrfs_release_path, btrfs_set_path_blocking, btrfs_cow_block, btrfs_clear_path_blocking, btrfs_tree_unlock_rw, key_search, setup_nodes_for_search, unlock_up, read_block_for_search, btrfs_try_tree_write_lock, btrfs_tree_lock, btrfs_try_tree_read_lock, btrfs_tree_read_lock, btrfs_leaf_free_space, split_leaf]\n\n2. 函数名: WARN_ON\n- 参数: [condition]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n3. 函数名: BUG_ON\n- 参数: [condition]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n4. 函数名: extent_buffer_get\n- 参数: [b]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n5. 函数名: btrfs_tree_read_lock\n- 参数: [b]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n6. 函数名: btrfs_root_node\n- 参数: [root]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n7. 函数名: btrfs_read_lock_root_node\n- 参数: [root]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n8. 函数名: btrfs_tree_read_unlock\n- 参数: [b]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n9. 函数名: free_extent_buffer\n- 参数: [b]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n10. 函数名: btrfs_lock_root_node\n- 参数: [root]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n11. 函数名: should_cow_block\n- 参数: [trans, root, b]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n12. 函数名: btrfs_release_path\n- 参数: [p]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n13. 函数名: btrfs_set_path_blocking\n- 参数: [p]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n14. 函数名: btrfs_cow_block\n- 参数: [trans, root, b, p->nodes[level + 1], p->slots[level + 1], &b]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n15. 函数名: btrfs_clear_path_blocking\n- 参数: [p, NULL, 0] or [p, b, BTRFS_WRITE_LOCK] or [p, b, BTRFS_READ_LOCK]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n16. 函数名: btrfs_tree_unlock_rw\n- 参数: [p->nodes[u], p->locks[u]]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n17. 函数名: key_search\n- 参数: [b, key, level, &prev_cmp, &slot]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n18. 函数名: setup_nodes_for_search\n- 参数: [trans, root, p, b, level, ins_len, &write_lock_level]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n19. 函数名: unlock_up\n- 参数: [p, level, lowest_unlock, min_write_lock_level, &write_lock_level]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n20. 函数名: read_block_for_search\n- 参数: [trans, root, p, &b, level, slot, key, 0]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n21. 函数名: btrfs_try_tree_write_lock\n- 参数: [b]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n22. 函数名: btrfs_tree_lock\n- 参数: [b]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n23. 函数名: btrfs_try_tree_read_lock\n- 参数: [b]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n24. 函数名: btrfs_tree_read_lock\n- 参数: [b]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n25. 函数名: btrfs_leaf_free_space\n- 参数: [root, b]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n26. 函数名: split_leaf\n- 参数: [trans, root, key, p, ins_len, ret == 0]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A"
  },
  {
    "id": 689,
    "cwe": "CWE-362",
    "cve": "CVE-2014-9710",
    "purpose": "Code purpose:\"\"\"在Btrfs文件系统中匹配指定名称的目录项\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中Btrfs实现未确保可见的xattr状态与请求的替换操作保持一致，存在竞争条件或替换失败后的不一致状态，导致本地用户可绕过ACL设置获取权限\"\"\"",
    "functions": "Functions:\n1. 函数名: btrfs_match_dir_item_name\n- 参数: [struct btrfs_root *root, struct btrfs_path *path, const char *name, int name_len]\n- 调用者: N/A\n- 被调用者: [verify_dir_item, btrfs_item_size_nr, btrfs_dir_name_len, btrfs_dir_data_len, memcmp_extent_buffer]\n\n2. 函数名: verify_dir_item\n- 参数: [struct btrfs_root *root, struct extent_buffer *leaf, struct btrfs_dir_item *dir_item]\n- 调用者: btrfs_match_dir_item_name\n- 被调用者: N/A\n\n3. 函数名: btrfs_item_size_nr\n- 参数: [struct extent_buffer *leaf, int slot]\n- 调用者: btrfs_match_dir_item_name\n- 被调用者: N/A\n\n4. 函数名: btrfs_dir_name_len\n- 参数: [struct extent_buffer *leaf, struct btrfs_dir_item *dir_item]\n- 调用者: btrfs_match_dir_item_name\n- 被调用者: N/A\n\n5. 函数名: btrfs_dir_data_len\n- 参数: [struct extent_buffer *leaf, struct btrfs_dir_item *dir_item]\n- 调用者: btrfs_match_dir_item_name\n- 被调用者: N/A\n\n6. 函数名: memcmp_extent_buffer\n- 参数: [struct extent_buffer *eb, const void *ptr, unsigned long start, unsigned long len]\n- 调用者: btrfs_match_dir_item_name\n- 被调用者: N/A"
  },
  {
    "id": 690,
    "cwe": "CWE-362",
    "cve": "CVE-2014-9710",
    "purpose": "Code purpose:\"\"\"该代码实现了Btrfs文件系统中扩展属性(xattr)的设置功能，包括创建、替换和删除操作，并处理相关错误情况。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Btrfs在替换xattr属性时存在竞态条件，未能确保可见的xattr状态与请求的替换操作保持一致性，导致本地用户可以在替换操作的时间窗口内绕过ACL设置或利用替换失败的情况获取权限。\"\"\"",
    "functions": "Functions:\n1. 函数名: do_setxattr\n- 参数: [struct btrfs_trans_handle *trans, struct inode *inode, const char *name, const void *value, size_t size, int flags]\n- 调用者: 未显示\n- 被调用者: [btrfs_alloc_path, btrfs_lookup_xattr, btrfs_delete_one_dir_name, btrfs_release_path, btrfs_insert_xattr_item, btrfs_free_path]\n\n2. 函数名: btrfs_alloc_path\n- 参数: []\n- 调用者: do_setxattr\n- 被调用者: 未显示\n\n3. 函数名: btrfs_lookup_xattr\n- 参数: [struct btrfs_trans_handle *trans, struct btrfs_root *root, struct btrfs_path *path, u64 ino, const char *name, int name_len, int mod]\n- 调用者: do_setxattr\n- 被调用者: 未显示\n\n4. 函数名: btrfs_delete_one_dir_name\n- 参数: [struct btrfs_trans_handle *trans, struct btrfs_root *root, struct btrfs_path *path, struct btrfs_dir_item *di]\n- 调用者: do_setxattr\n- 被调用者: 未显示\n\n5. 函数名: btrfs_release_path\n- 参数: [struct btrfs_path *path]\n- 调用者: do_setxattr\n- 被调用者: 未显示\n\n6. 函数名: btrfs_insert_xattr_item\n- 参数: [struct btrfs_trans_handle *trans, struct btrfs_root *root, struct btrfs_path *path, u64 ino, const char *name, int name_len, const void *data, int data_len]\n- 调用者: do_setxattr\n- 被调用者: 未显示\n\n7. 函数名: btrfs_free_path\n- 参数: [struct btrfs_path *path]\n- 调用者: do_setxattr\n- 被调用者: 未显示"
  },
  {
    "id": 711,
    "cwe": "CWE-362",
    "cve": "CVE-2014-9914",
    "purpose": "Code purpose:\"\"\"该代码用于在IPv4 UDP套接字释放时处理路由缓存更新，确保数据包能正确路由到目标地址\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在多线程环境下对IPv4 UDP套接字内部数据结构访问时，由于缺乏适当的锁定机制导致竞态条件，可能引发释放后重用问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: ip4_datagram_release_cb\n- 参数: [struct sock *sk]\n- 调用者: 未明确显示（由内核调用）\n- 被调用者: [inet_sk, __sk_dst_get, __sk_dst_check, rcu_read_lock, rcu_dereference, ip_route_output_ports, sock_net, IS_ERR, __sk_dst_set, rcu_read_unlock]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: []\n\n3. 函数名: __sk_dst_get\n- 参数: [struct sock *sk]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: []\n\n4. 函数名: __sk_dst_check\n- 参数: [struct sock *sk, int 0]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: []\n\n5. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: ip4_datagram_release_cb\n- 被调用者: []\n\n6. 函数名: rcu_dereference\n- 参数: [inet->inet_opt]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: []\n\n7. 函数名: ip_route_output_ports\n- 参数: [sock_net(sk), &fl4, sk, daddr, inet->inet_saddr, inet->inet_dport, inet->inet_sport, sk->sk_protocol, RT_CONN_FLAGS(sk), sk->sk_bound_dev_if]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: []\n\n8. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: []\n\n9. 函数名: IS_ERR\n- 参数: [rt]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: []\n\n10. 函数名: __sk_dst_set\n- 参数: [struct sock *sk, &rt->dst]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: []\n\n11. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: ip4_datagram_release_cb\n- 被调用者: []"
  },
  {
    "id": 732,
    "cwe": "CWE-362",
    "cve": "CVE-2015-1420",
    "purpose": "Code purpose:\"\"\"该代码用于根据文件句柄获取对应的文件路径，并进行权限检查和内存分配等操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在验证handle_bytes大小后未重新检查其值，导致竞争条件下攻击者可以修改该值从而绕过内存访问限制\"\"\"",
    "functions": "Functions:\n1. 函数名: handle_to_path\n- 参数: [mountdirfd, ufh, path]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [capable, copy_from_user, kmalloc, do_handle_to_path, kfree]\n\n2. 函数名: capable\n- 参数: [CAP_DAC_READ_SEARCH]\n- 调用者: handle_to_path\n- 被调用者: 未明确（内核能力检查函数）\n\n3. 函数名: copy_from_user\n- 参数: [&f_handle, ufh, sizeof(struct file_handle)] 和 [handle, ufh, sizeof(struct file_handle) + f_handle.handle_bytes]\n- 调用者: handle_to_path\n- 被调用者: 未明确（内核内存复制函数）\n\n4. 函数名: kmalloc\n- 参数: [sizeof(struct file_handle) + f_handle.handle_bytes, GFP_KERNEL]\n- 调用者: handle_to_path\n- 被调用者: 未明确（内核内存分配函数）\n\n5. 函数名: do_handle_to_path\n- 参数: [mountdirfd, handle, path]\n- 调用者: handle_to_path\n- 被调用者: 未明确（内核路径处理函数）\n\n6. 函数名: kfree\n- 参数: [handle]\n- 调用者: handle_to_path\n- 被调用者: 未明确（内核内存释放函数）"
  },
  {
    "id": 749,
    "cwe": "CWE-362",
    "cve": "CVE-2015-3212",
    "purpose": "Code purpose:\"\"\"将SCTP套接字从旧套接字迁移到新套接字，包括复制选项、绑定信息、接收队列和关联状态等\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多线程环境下对共享数据结构(如bind_hash链表)的访问缺乏适当的同步保护，导致并发操作可能引发链表损坏，造成系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: sctp_sock_migrate\n- 参数: [struct sock *oldsk, struct sock *newsk, struct sctp_association *assoc, sctp_socket_type_t type]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [sctp_sk, sock_net, inet_sk_copy_descendant, sk_add_bind_node, sctp_bind_addr_dup, sctp_skb_for_each, __skb_unlink, __skb_queue_tail, sctp_skb_set_owner_r_frag, sctp_clear_pd, lock_sock_nested, sctp_assoc_migrate, sctp_state, sctp_style, release_sock]\n\n2. 函数名: sctp_sk\n- 参数: [struct sock *sk]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n3. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n4. 函数名: inet_sk_copy_descendant\n- 参数: [struct sock *newsk, struct sock *oldsk]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n5. 函数名: sk_add_bind_node\n- 参数: [struct sock *sk, struct list_head *list]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n6. 函数名: sctp_bind_addr_dup\n- 参数: [struct sctp_bind_addr *dest, struct sctp_bind_addr *src, gfp_t gfp]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n7. 函数名: sctp_skb_for_each\n- 参数: [struct sk_buff *skb, struct sk_buff_head *list, struct sk_buff *tmp]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n8. 函数名: __skb_unlink\n- 参数: [struct sk_buff *skb, struct sk_buff_head *list]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n9. 函数名: __skb_queue_tail\n- 参数: [struct sk_buff_head *list, struct sk_buff *skb]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n10. 函数名: sctp_skb_set_owner_r_frag\n- 参数: [struct sk_buff *skb, struct sock *sk]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n11. 函数名: sctp_clear_pd\n- 参数: [struct sock *sk, struct sctp_association *asoc]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n12. 函数名: lock_sock_nested\n- 参数: [struct sock *sk, int subclass]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n13. 函数名: sctp_assoc_migrate\n- 参数: [struct sctp_association *assoc, struct sock *newsk]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n14. 函数名: sctp_state\n- 参数: [struct sctp_association *asoc, sctp_state_t state]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n15. 函数名: sctp_style\n- 参数: [struct sock *sk, sctp_socket_type_t style]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n16. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_sock_migrate\n- 被调用者: []"
  },
  {
    "id": 750,
    "cwe": "CWE-362",
    "cve": "CVE-2015-3212",
    "purpose": "Code purpose:\"\"\"初始化SCTP套接字的相关参数和结构，为后续的SCTP协议通信做准备\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在sctp_init_sock函数中缺乏适当的同步机制，导致在多线程环境下快速连续调用系统调用时可能引发竞态条件，造成链表损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: sctp_init_sock\n- 参数: [struct sock *sk]\n- 调用者: 未显示（通常由内核网络栈调用）\n- 被调用者: [sock_net, sctp_sk, sctp_endpoint_new, atomic_set, skb_queue_head_init, local_bh_disable, percpu_counter_inc, sock_prot_inuse_add, list_add_tail, local_bh_enable]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n3. 函数名: sctp_sk\n- 参数: [struct sock *sk]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n4. 函数名: sctp_endpoint_new\n- 参数: [struct sock *sk, GFP_KERNEL]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n5. 函数名: atomic_set\n- 参数: [&sp->pd_mode, 0]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n6. 函数名: skb_queue_head_init\n- 参数: [&sp->pd_lobby]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n7. 函数名: local_bh_disable\n- 参数: []\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n8. 函数名: percpu_counter_inc\n- 参数: [&sctp_sockets_allocated]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n9. 函数名: sock_prot_inuse_add\n- 参数: [net, sk->sk_prot, 1]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n10. 函数名: list_add_tail\n- 参数: [&sp->auto_asconf_list, &net->sctp.auto_asconf_splist]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n11. 函数名: local_bh_enable\n- 参数: []\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n12. 函数名: sctp_get_pf_specific\n- 参数: [sk->sk_family]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n13. 函数名: sctp_destruct_sock\n- 参数: []\n- 调用者: sctp_init_sock (通过赋值给sk->sk_destruct)\n- 被调用者: []"
  },
  {
    "id": 751,
    "cwe": "CWE-362",
    "cve": "CVE-2015-3212",
    "purpose": "Code purpose:\"\"\"该代码用于设置SCTP套接字的自动ASCONF(Address Configuration Change)功能，允许或禁止自动地址配置更改。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺乏适当的同步机制，在多线程环境下快速连续调用setsockopt相关系统调用时，会导致对auto_asconf_list的并发访问，引发链表损坏和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: sctp_setsockopt_auto_asconf\n- 参数: [struct sock *sk, char __user *optval, unsigned int optlen]\n- 调用者: 未指定（由系统调用触发）\n- 被调用者: [sctp_sk, sctp_is_ep_boundall, get_user, list_del, list_add_tail, sock_net]\n\n2. 函数名: sctp_sk\n- 参数: [struct sock *sk]\n- 调用者: sctp_setsockopt_auto_asconf\n- 被调用者: []\n\n3. 函数名: sctp_is_ep_boundall\n- 参数: [struct sock *sk]\n- 调用者: sctp_setsockopt_auto_asconf\n- 被调用者: []\n\n4. 函数名: get_user\n- 参数: [int val, int __user *optval]\n- 调用者: sctp_setsockopt_auto_asconf\n- 被调用者: []\n\n5. 函数名: list_del\n- 参数: [&sp->auto_asconf_list]\n- 调用者: sctp_setsockopt_auto_asconf\n- 被调用者: []\n\n6. 函数名: list_add_tail\n- 参数: [&sp->auto_asconf_list, &sock_net(sk)->sctp.auto_asconf_splist]\n- 调用者: sctp_setsockopt_auto_asconf\n- 被调用者: []\n\n7. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sctp_setsockopt_auto_asconf\n- 被调用者: []"
  },
  {
    "id": 752,
    "cwe": "CWE-362",
    "cve": "CVE-2015-3212",
    "purpose": "Code purpose:\"\"\"该代码实现了SCTP协议的socket关闭功能，包括清理接收队列、终止关联(association)以及处理TCP风格的socket关闭等待等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核的SCTP实现中，由于缺乏适当的锁保护，当多个系统调用快速连续操作socket时，会导致关联列表(list corruption)被破坏，引发竞争条件问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: sctp_close\n- 参数: [struct sock *sk, long timeout]\n- 调用者: 无（系统调用）\n- 被调用者: [sock_net, lock_sock, sctp_sk, sctp_queue_purge_ulpevents, list_for_each_safe, list_entry, sctp_style, sctp_state, sctp_unhash_established, sctp_association_free, skb_queue_empty, sock_flag, sctp_make_abort_user, sctp_primitive_ABORT, sctp_primitive_SHUTDOWN, sctp_wait_for_close, release_sock, local_bh_disable, bh_lock_sock, sock_hold, sk_common_release, bh_unlock_sock, local_bh_enable, sock_put, SCTP_DBG_OBJCNT_DEC]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n3. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n4. 函数名: sctp_sk\n- 参数: [struct sock *sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n5. 函数名: sctp_queue_purge_ulpevents\n- 参数: [&sk->sk_receive_queue], [&sctp_sk(sk)->pd_lobby]\n- 调用者: sctp_close\n- 被调用者: 无\n\n6. 函数名: list_for_each_safe\n- 参数: [pos, temp, &ep->asocs]\n- 调用者: sctp_close\n- 被调用者: 无\n\n7. 函数名: list_entry\n- 参数: [pos, struct sctp_association, asocs]\n- 调用者: sctp_close\n- 被调用者: 无\n\n8. 函数名: sctp_style\n- 参数: [sk, TCP]\n- 调用者: sctp_close\n- 被调用者: 无\n\n9. 函数名: sctp_state\n- 参数: [asoc, CLOSED]\n- 调用者: sctp_close\n- 被调用者: 无\n\n10. 函数名: sctp_unhash_established\n- 参数: [asoc]\n- 调用者: sctp_close\n- 被调用者: 无\n\n11. 函数名: sctp_association_free\n- 参数: [asoc]\n- 调用者: sctp_close\n- 被调用者: 无\n\n12. 函数名: skb_queue_empty\n- 参数: [&asoc->ulpq.lobby], [&asoc->ulpq.reasm]\n- 调用者: sctp_close\n- 被调用者: 无\n\n13. 函数名: sock_flag\n- 参数: [sk, SOCK_LINGER]\n- 调用者: sctp_close\n- 被调用者: 无\n\n14. 函数名: sctp_make_abort_user\n- 参数: [asoc, NULL, 0]\n- 调用者: sctp_close\n- 被调用者: 无\n\n15. 函数名: sctp_primitive_ABORT\n- 参数: [net, asoc, chunk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n16. 函数名: sctp_primitive_SHUTDOWN\n- 参数: [net, asoc, NULL]\n- 调用者: sctp_close\n- 被调用者: 无\n\n17. 函数名: sctp_wait_for_close\n- 参数: [sk, timeout]\n- 调用者: sctp_close\n- 被调用者: 无\n\n18. 函数名: release_sock\n- 参数: [sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n19. 函数名: local_bh_disable\n- 参数: 无\n- 调用者: sctp_close\n- 被调用者: 无\n\n20. 函数名: bh_lock_sock\n- 参数: [sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n21. 函数名: sock_hold\n- 参数: [sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n22. 函数名: sk_common_release\n- 参数: [sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n23. 函数名: bh_unlock_sock\n- 参数: [sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n24. 函数名: local_bh_enable\n- 参数: 无\n- 调用者: sctp_close\n- 被调用者: 无\n\n25. 函数名: sock_put\n- 参数: [sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n26. 函数名: SCTP_DBG_OBJCNT_DEC\n- 参数: [sock]\n- 调用者: sctp_close\n- 被调用者: 无"
  },
  {
    "id": 758,
    "cwe": "CWE-362",
    "cve": "CVE-2015-3339",
    "purpose": "Code purpose:\"\"\"该代码用于准备执行二进制程序时的权限凭证，包括处理setuid/setgid权限，确保程序以正确的用户/组权限运行\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在文件所有权被更改为root但setuid位尚未被清除的竞态条件窗口期，攻击者可执行setuid程序以提升权限\"\"\"",
    "functions": "Functions:\n1. 函数名: prepare_binprm\n- 参数: [struct linux_binprm *bprm]\n- 调用者: N/A (顶级函数)\n- 被调用者: [file_inode, current_euid, current_egid, kuid_has_mapping, kgid_has_mapping, security_bprm_set_creds, memset, kernel_read]\n\n2. 函数名: file_inode\n- 参数: [struct file *file]\n- 调用者: prepare_binprm\n- 被调用者: N/A\n\n3. 函数名: current_euid\n- 参数: []\n- 调用者: prepare_binprm\n- 被调用者: N/A\n\n4. 函数名: current_egid\n- 参数: []\n- 调用者: prepare_binprm\n- 被调用者: N/A\n\n5. 函数名: kuid_has_mapping\n- 参数: [struct user_namespace *ns, kuid_t uid]\n- 调用者: prepare_binprm\n- 被调用者: N/A\n\n6. 函数名: kgid_has_mapping\n- 参数: [struct user_namespace *ns, kgid_t gid]\n- 调用者: prepare_binprm\n- 被调用者: N/A\n\n7. 函数名: security_bprm_set_creds\n- 参数: [struct linux_binprm *bprm]\n- 调用者: prepare_binprm\n- 被调用者: N/A\n\n8. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: prepare_binprm\n- 被调用者: N/A\n\n9. 函数名: kernel_read\n- 参数: [struct file *file, loff_t offset, char *addr, unsigned long count]\n- 调用者: prepare_binprm\n- 被调用者: N/A"
  },
  {
    "id": 764,
    "cwe": "CWE-362",
    "cve": "CVE-2015-4170",
    "purpose": "Code purpose:\"\"\"该代码实现了一个原子比较交换操作，用于在信号量计数更新时检查并防止竞态条件。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于ldsem_cmpxchg函数中的竞态条件，当新tty线程在旧tty线程关闭期间建立时，会导致ldsem_down_read和ldsem_down_write死锁。\"\"\"",
    "functions": "Functions:\n1. 函数名: ldsem_cmpxchg\n- 参数: [old, new, sem]\n- 调用者: 未提供（代码片段中未显示）\n- 被调用者: [atomic_long_cmpxchg]"
  },
  {
    "id": 786,
    "cwe": "CWE-362",
    "cve": "CVE-2015-7550",
    "purpose": "Code purpose:\"\"\"该代码用于读取指定密钥的内容并返回给用户空间，同时进行权限验证和并发控制\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于keyctl_read_key函数在读取key时未正确处理信号量，导致在keyctl_revoke和keyctl_read并发调用时可能引发竞态条件，造成空指针解引用或系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: keyctl_read_key\n- 参数: [key_serial_t keyid, char __user *buffer, size_t buflen]\n- 调用者: 未指定\n- 被调用者: [lookup_user_key, key_ref_to_ptr, key_permission, is_key_possessed, key_validate, down_read, up_read, key_put]\n\n2. 函数名: lookup_user_key\n- 参数: [key_serial_t keyid, int create, int update]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定\n\n3. 函数名: key_ref_to_ptr\n- 参数: [key_ref_t key_ref]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定\n\n4. 函数名: key_permission\n- 参数: [key_ref_t key_ref, key_perm_t perm]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定\n\n5. 函数名: is_key_possessed\n- 参数: [key_ref_t key_ref]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定\n\n6. 函数名: key_validate\n- 参数: [struct key *key]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定\n\n7. 函数名: down_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定\n\n8. 函数名: up_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定\n\n9. 函数名: key_put\n- 参数: [struct key *key]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定"
  },
  {
    "id": 788,
    "cwe": "CWE-362",
    "cve": "CVE-2015-7613",
    "purpose": "Code purpose:\"\"\"在Linux内核中创建并初始化一个新的消息队列IPC对象\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPC对象实现中存在竞态条件，导致ipc_addid调用时对未初始化数据的uid和gid进行比较，可能被本地用户利用来提升权限\"\"\"",
    "functions": "Functions:\n1. 函数名: newque\n- 参数: [ns, params]\n- 调用者: 未显示\n- 被调用者: [ipc_rcu_alloc, ipc_rcu_putref, ipc_rcu_free, security_msg_queue_alloc, ipc_addid, msg_rcu_free, get_seconds, INIT_LIST_HEAD, ipc_unlock_object, rcu_read_unlock]\n\n2. 函数名: ipc_rcu_alloc\n- 参数: [sizeof(*msq)]\n- 调用者: newque\n- 被调用者: 未显示\n\n3. 函数名: ipc_rcu_putref\n- 参数: [msq, ipc_rcu_free]\n- 调用者: newque\n- 被调用者: 未显示\n\n4. 函数名: ipc_rcu_free\n- 参数: 未显示\n- 调用者: newque (通过ipc_rcu_putref)\n- 被调用者: 未显示\n\n5. 函数名: security_msg_queue_alloc\n- 参数: [msq]\n- 调用者: newque\n- 被调用者: 未显示\n\n6. 函数名: ipc_addid\n- 参数: [&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni]\n- 调用者: newque\n- 被调用者: 未显示\n\n7. 函数名: msg_rcu_free\n- 参数: 未显示\n- 调用者: newque (通过ipc_rcu_putref)\n- 被调用者: 未显示\n\n8. 函数名: get_seconds\n- 参数: []\n- 调用者: newque\n- 被调用者: 未显示\n\n9. 函数名: INIT_LIST_HEAD\n- 参数: [&msq->q_messages], [&msq->q_receivers], [&msq->q_senders]\n- 调用者: newque\n- 被调用者: 未显示\n\n10. 函数名: ipc_unlock_object\n- 参数: [&msq->q_perm]\n- 调用者: newque\n- 被调用者: 未显示\n\n11. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: newque\n- 被调用者: 未显示"
  },
  {
    "id": 789,
    "cwe": "CWE-362",
    "cve": "CVE-2015-7613",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中创建和管理System V共享内存段的功能，包括内存大小验证、权限设置和资源分配等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPC对象实现中存在竞态条件，导致ipc_addid调用时对未初始化数据的uid和gid进行比较，可能被本地用户利用来提升权限\"\"\"",
    "functions": "Functions:\n1. 函数名: newseg\n- 参数: [ns, params]\n- 调用者: N/A (top-level function)\n- 被调用者: [ipc_rcu_alloc, security_shm_alloc, ipc_rcu_putref, hstate_sizelog, huge_page_size, hugetlb_file_setup, shmem_kernel_file_setup, ipc_addid, task_tgid_vnr, get_seconds, file_inode, ipc_unlock_object, rcu_read_unlock, is_file_hugepages, user_shm_unlock, fput, shm_rcu_free]\n\n2. 函数名: ipc_rcu_alloc\n- 参数: [sizeof(*shp)]\n- 调用者: newseg\n- 被调用者: []\n\n3. 函数名: security_shm_alloc\n- 参数: [shp]\n- 调用者: newseg\n- 被调用者: []\n\n4. 函数名: ipc_rcu_putref\n- 参数: [shp, ipc_rcu_free]\n- 调用者: newseg\n- 被调用者: []\n\n5. 函数名: hstate_sizelog\n- 参数: [(shmflg >> SHM_HUGE_SHIFT) & SHM_HUGE_MASK]\n- 调用者: newseg\n- 被调用者: []\n\n6. 函数名: huge_page_size\n- 参数: [hs]\n- 调用者: newseg\n- 被调用者: []\n\n7. 函数名: hugetlb_file_setup\n- 参数: [name, hugesize, acctflag, &shp->mlock_user, HUGETLB_SHMFS_INODE, (shmflg >> SHM_HUGE_SHIFT) & SHM_HUGE_MASK]\n- 调用者: newseg\n- 被调用者: []\n\n8. 函数名: shmem_kernel_file_setup\n- 参数: [name, size, acctflag]\n- 调用者: newseg\n- 被调用者: []\n\n9. 函数名: ipc_addid\n- 参数: [&shm_ids(ns), &shp->shm_perm, ns->shm_ctlmni]\n- 调用者: newseg\n- 被调用者: []\n\n10. 函数名: task_tgid_vnr\n- 参数: [current]\n- 调用者: newseg\n- 被调用者: []\n\n11. 函数名: get_seconds\n- 参数: []\n- 调用者: newseg\n- 被调用者: []\n\n12. 函数名: file_inode\n- 参数: [file]\n- 调用者: newseg\n- 被调用者: []\n\n13. 函数名: ipc_unlock_object\n- 参数: [&shp->shm_perm]\n- 调用者: newseg\n- 被调用者: []\n\n14. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: newseg\n- 被调用者: []\n\n15. 函数名: is_file_hugepages\n- 参数: [file]\n- 调用者: newseg\n- 被调用者: []\n\n16. 函数名: user_shm_unlock\n- 参数: [size, shp->mlock_user]\n- 调用者: newseg\n- 被调用者: []\n\n17. 函数名: fput\n- 参数: [file]\n- 调用者: newseg\n- 被调用者: []\n\n18. 函数名: shm_rcu_free\n- 参数: []\n- 调用者: newseg (via ipc_rcu_putref)\n- 被调用者: []"
  },
  {
    "id": 790,
    "cwe": "CWE-362",
    "cve": "CVE-2015-7613",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中为IPC(进程间通信)对象分配ID并初始化权限信息，包括UID和GID的设置\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"竞态条件下，ipc_addid函数在未初始化数据的情况下进行uid和gid的比较，导致本地用户可能提升权限\"\"\"",
    "functions": "Functions:\n1. 函数名: ipc_addid\n- 参数: [struct ipc_ids *ids, struct kern_ipc_perm *new, int size]\n- 调用者: 未指定\n- 被调用者: [idr_preload, spin_lock_init, rcu_read_lock, spin_lock, idr_alloc, idr_preload_end, spin_unlock, rcu_read_unlock, current_euid_egid, ipcid_to_idx, ipcid_to_seqx, ipc_buildid]\n\n2. 函数名: idr_preload\n- 参数: [GFP_KERNEL]\n- 调用者: ipc_addid\n- 被调用者: 未指定\n\n3. 函数名: spin_lock_init\n- 参数: [&new->lock]\n- 调用者: ipc_addid\n- 被调用者: 未指定\n\n4. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: ipc_addid\n- 被调用者: 未指定\n\n5. 函数名: spin_lock\n- 参数: [&new->lock]\n- 调用者: ipc_addid\n- 被调用者: 未指定\n\n6. 函数名: idr_alloc\n- 参数: [&ids->ipcs_idr, new, (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0, GFP_NOWAIT]\n- 调用者: ipc_addid\n- 被调用者: 未指定\n\n7. 函数名: idr_preload_end\n- 参数: []\n- 调用者: ipc_addid\n- 被调用者: 未指定\n\n8. 函数名: spin_unlock\n- 参数: [&new->lock]\n- 调用者: ipc_addid\n- 被调用者: 未指定\n\n9. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: ipc_addid\n- 被调用者: 未指定\n\n10. 函数名: current_euid_egid\n- 参数: [&euid, &egid]\n- 调用者: ipc_addid\n- 被调用者: 未指定\n\n11. 函数名: ipcid_to_idx\n- 参数: [next_id]\n- 调用者: ipc_addid\n- 被调用者: 未指定\n\n12. 函数名: ipcid_to_seqx\n- 参数: [next_id]\n- 调用者: ipc_addid\n- 被调用者: 未指定\n\n13. 函数名: ipc_buildid\n- 参数: [id, new->seq]\n- 调用者: ipc_addid\n- 被调用者: 未指定"
  },
  {
    "id": 796,
    "cwe": "CWE-362",
    "cve": "CVE-2015-7990",
    "purpose": "Code purpose:\"\"\"创建和管理RDS(Reliable Datagram Sockets)连接，包括处理本地和远程地址的连接查找、分配和初始化，并处理可能的竞争条件\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在创建RDS连接时未正确处理并发情况下的竞态条件，导致未正确绑定的socket可能引发空指针解引用\"\"\"",
    "functions": "Functions:\n1. 函数名: __rds_conn_create\n- 参数: [net, laddr, faddr, trans, gfp, is_outgoing]\n- 调用者: 未显示（应为外部调用）\n- 被调用者: [rds_conn_bucket, rds_conn_lookup, rds_trans_get_preferred, rds_trans_put, trans->conn_alloc, trans->conn_free, rds_cong_get_maps, kmem_cache_zalloc, kmem_cache_free, rds_conn_net_set, rds_cong_add_conn, INIT_HLIST_NODE, spin_lock_init, init_waitqueue_head, INIT_LIST_HEAD, atomic_set, INIT_DELAYED_WORK, INIT_WORK, mutex_init, spin_lock_irqsave, spin_unlock_irqrestore, hlist_add_head_rcu]\n\n2. 函数名: rds_conn_bucket\n- 参数: [laddr, faddr]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n3. 函数名: rds_conn_lookup\n- 参数: [net, head, laddr, faddr, trans]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n4. 函数名: rds_trans_get_preferred\n- 参数: [net, faddr]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n5. 函数名: rds_trans_put\n- 参数: [loop_trans]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n6. 函数名: trans->conn_alloc\n- 参数: [conn, gfp]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n7. 函数名: trans->conn_free\n- 参数: [conn->c_transport_data]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n8. 函数名: rds_cong_get_maps\n- 参数: [conn]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n9. 函数名: kmem_cache_zalloc\n- 参数: [rds_conn_slab, gfp]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n10. 函数名: kmem_cache_free\n- 参数: [rds_conn_slab, conn]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n11. 函数名: rds_conn_net_set\n- 参数: [conn, net]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n12. 函数名: rds_cong_add_conn\n- 参数: [conn]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n13. 函数名: INIT_HLIST_NODE\n- 参数: [&conn->c_hash_node]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n14. 函数名: spin_lock_init\n- 参数: [&conn->c_lock]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n15. 函数名: init_waitqueue_head\n- 参数: [&conn->c_waitq]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n16. 函数名: INIT_LIST_HEAD\n- 参数: [&conn->c_send_queue, &conn->c_retrans]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n17. 函数名: atomic_set\n- 参数: [&conn->c_state, RDS_CONN_DOWN]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n18. 函数名: INIT_DELAYED_WORK\n- 参数: [&conn->c_send_w, rds_send_worker], [&conn->c_recv_w, rds_recv_worker], [&conn->c_conn_w, rds_connect_worker]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n19. 函数名: INIT_WORK\n- 参数: [&conn->c_down_w, rds_shutdown_worker]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n20. 函数名: mutex_init\n- 参数: [&conn->c_cm_lock]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n21. 函数名: spin_lock_irqsave\n- 参数: [&rds_conn_lock, flags]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n22. 函数名: spin_unlock_irqrestore\n- 参数: [&rds_conn_lock, flags]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n23. 函数名: hlist_add_head_rcu\n- 参数: [&conn->c_hash_node, head]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示"
  },
  {
    "id": 797,
    "cwe": "CWE-362",
    "cve": "CVE-2015-7990",
    "purpose": "Code purpose:\"\"\"该代码实现了RDS(Reliable Datagram Sockets)协议中发送消息的功能，处理用户空间的消息发送请求，包括地址验证、连接管理、消息分配和传输等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于rds_sendmsg函数在未正确绑定套接字的情况下存在竞态条件，导致可能发生空指针解引用和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: rds_sendmsg\n- 参数: [struct socket *sock, struct msghdr *msg, size_t payload_len]\n- 调用者: 无（系统调用）\n- 被调用者: [rds_sk_to_rs, sock_sndtimeo, rds_rm_size, rds_message_alloc, ceil, rds_message_alloc_sgs, rds_message_copy_from_user, rds_conn_create_outgoing, sock_net, rds_cmsg_send, rds_conn_connect_if_down, rds_cong_wait, rds_send_queue_rm, rds_stats_inc, wait_event_interruptible_timeout, sk_sleep, rds_send_xmit, queue_delayed_work, rds_message_put, rds_rdma_unuse, rds_rdma_cookie_key]\n\n2. 函数名: rds_sk_to_rs\n- 参数: [struct sock *sk]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n3. 函数名: sock_sndtimeo\n- 参数: [struct sock *sk, int nonblock]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n4. 函数名: rds_rm_size\n- 参数: [struct msghdr *msg, size_t payload_len]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n5. 函数名: rds_message_alloc\n- 参数: [int ret, GFP_KERNEL]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n6. 函数名: ceil\n- 参数: [payload_len, PAGE_SIZE]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n7. 函数名: rds_message_alloc_sgs\n- 参数: [struct rds_message *rm, ceil(payload_len, PAGE_SIZE)]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n8. 函数名: rds_message_copy_from_user\n- 参数: [struct rds_message *rm, &msg->msg_iter]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n9. 函数名: rds_conn_create_outgoing\n- 参数: [sock_net(sock->sk), rs->rs_bound_addr, daddr, rs->rs_transport, sock->sk->sk_allocation]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n10. 函数名: sock_net\n- 参数: [sock->sk]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n11. 函数名: rds_cmsg_send\n- 参数: [rs, rm, msg, &allocated_mr]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n12. 函数名: rds_conn_connect_if_down\n- 参数: [conn]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n13. 函数名: rds_cong_wait\n- 参数: [conn->c_fcong, dport, nonblock, rs]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n14. 函数名: rds_send_queue_rm\n- 参数: [rs, conn, rm, rs->rs_bound_port, dport, &queued]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n15. 函数名: rds_stats_inc\n- 参数: [s_send_queue_full]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n16. 函数名: wait_event_interruptible_timeout\n- 参数: [*sk_sleep(sk), rds_send_queue_rm(rs, conn, rm, rs->rs_bound_port, dport, &queued), timeo]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n17. 函数名: sk_sleep\n- 参数: [sk]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n18. 函数名: rds_send_xmit\n- 参数: [conn]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n19. 函数名: queue_delayed_work\n- 参数: [rds_wq, &conn->c_send_w, 1]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n20. 函数名: rds_message_put\n- 参数: [rm]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n21. 函数名: rds_rdma_unuse\n- 参数: [rs, rds_rdma_cookie_key(rm->m_rdma_cookie), 1]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n22. 函数名: rds_rdma_cookie_key\n- 参数: [rm->m_rdma_cookie]\n- 调用者: rds_sendmsg\n- 被调用者: 无"
  },
  {
    "id": 840,
    "cwe": "CWE-362",
    "cve": "CVE-2015-8767",
    "purpose": "Code purpose:\"\"\"该代码用于处理SCTP协议中T3重传定时器到期事件，包括检查socket状态、执行状态机处理以及释放相关资源。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中sctp_generate_t3_rtx_event函数未正确处理锁与socket之间的关系，导致在特定条件下可能引发死锁\"\"\"",
    "functions": "Functions:\n1. 函数名: sctp_generate_t3_rtx_event\n- 参数: [unsigned long peer]\n- 调用者: N/A (top-level function)\n- 被调用者: [sock_net, bh_lock_sock, sock_owned_by_user, pr_debug, mod_timer, sctp_transport_hold, sctp_do_sm, bh_unlock_sock, sctp_transport_put]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_t3_rtx_event\n- 被调用者: []\n\n3. 函数名: bh_lock_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_t3_rtx_event\n- 被调用者: []\n\n4. 函数名: sock_owned_by_user\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_t3_rtx_event\n- 被调用者: []\n\n5. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: sctp_generate_t3_rtx_event\n- 被调用者: []\n\n6. 函数名: mod_timer\n- 参数: [struct timer_list *timer, unsigned long expires]\n- 调用者: sctp_generate_t3_rtx_event\n- 被调用者: []\n\n7. 函数名: sctp_transport_hold\n- 参数: [struct sctp_transport *transport]\n- 调用者: sctp_generate_t3_rtx_event\n- 被调用者: []\n\n8. 函数名: sctp_do_sm\n- 参数: [struct net *net, sctp_event_t event_type, sctp_subtype_t subtype, int state, struct sctp_endpoint *ep, struct sctp_association *asoc, void *event_arg, gfp_t gfp]\n- 调用者: sctp_generate_t3_rtx_event\n- 被调用者: []\n\n9. 函数名: bh_unlock_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_t3_rtx_event\n- 被调用者: []\n\n10. 函数名: sctp_transport_put\n- 参数: [struct sctp_transport *transport]\n- 调用者: sctp_generate_t3_rtx_event\n- 被调用者: []"
  },
  {
    "id": 841,
    "cwe": "CWE-362",
    "cve": "CVE-2015-8767",
    "purpose": "Code purpose:\"\"\"处理SCTP协议中ICMP协议不可达事件，包括锁管理和定时器重试机制\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确处理锁与socket之间的关系，在sock_owned_by_user检查后仍可能发生竞争条件，导致死锁\"\"\"",
    "functions": "Functions:\n1. 函数名: sctp_generate_proto_unreach_event\n- 参数: [unsigned long data]\n- 调用者: 未显示（由定时器或其他上下文调用）\n- 被调用者: [sock_net, bh_lock_sock, sock_owned_by_user, pr_debug, mod_timer, sctp_association_hold, sctp_do_sm, bh_unlock_sock, sctp_association_put]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_proto_unreach_event\n- 被调用者: []\n\n3. 函数名: bh_lock_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_proto_unreach_event\n- 被调用者: []\n\n4. 函数名: sock_owned_by_user\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_proto_unreach_event\n- 被调用者: []\n\n5. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: sctp_generate_proto_unreach_event\n- 被调用者: []\n\n6. 函数名: mod_timer\n- 参数: [struct timer_list *timer, unsigned long expires]\n- 调用者: sctp_generate_proto_unreach_event\n- 被调用者: []\n\n7. 函数名: sctp_association_hold\n- 参数: [struct sctp_association *asoc]\n- 调用者: sctp_generate_proto_unreach_event\n- 被调用者: []\n\n8. 函数名: sctp_do_sm\n- 参数: [struct net *net, enum sctp_event_type event_type, union sctp_subtype subtype, enum sctp_state state, struct sctp_endpoint *ep, struct sctp_association *asoc, void *event_arg, gfp_t gfp]\n- 调用者: sctp_generate_proto_unreach_event\n- 被调用者: []\n\n9. 函数名: bh_unlock_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_proto_unreach_event\n- 被调用者: []\n\n10. 函数名: sctp_association_put\n- 参数: [struct sctp_association *asoc]\n- 调用者: sctp_generate_proto_unreach_event\n- 被调用者: []"
  },
  {
    "id": 842,
    "cwe": "CWE-362",
    "cve": "CVE-2015-8767",
    "purpose": "Code purpose:\"\"\"该代码用于处理SCTP协议关联中的超时事件，包括锁定套接字、检查关联状态、执行状态机处理以及释放资源等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在SCTP协议实现中，未能正确处理锁与socket之间的关系，导致在特定情况下(如sctp_accept调用)可能引发死锁\"\"\"",
    "functions": "Functions:\n1. 函数名: sctp_generate_timeout_event\n- 参数: [struct sctp_association *asoc, sctp_event_timeout_t timeout_type]\n- 调用者: 未显示（由定时器或事件触发）\n- 被调用者: [sock_net, bh_lock_sock, sock_owned_by_user, pr_debug, mod_timer, sctp_association_hold, sctp_do_sm, bh_unlock_sock, sctp_association_put]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_timeout_event\n- 被调用者: []\n\n3. 函数名: bh_lock_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_timeout_event\n- 被调用者: []\n\n4. 函数名: sock_owned_by_user\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_timeout_event\n- 被调用者: []\n\n5. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: sctp_generate_timeout_event\n- 被调用者: []\n\n6. 函数名: mod_timer\n- 参数: [struct timer_list *timer, unsigned long expires]\n- 调用者: sctp_generate_timeout_event\n- 被调用者: []\n\n7. 函数名: sctp_association_hold\n- 参数: [struct sctp_association *asoc]\n- 调用者: sctp_generate_timeout_event\n- 被调用者: []\n\n8. 函数名: sctp_do_sm\n- 参数: [struct net *net, sctp_event_t event_type, sctp_subtype_t subtype, int state, struct sctp_endpoint *ep, struct sctp_association *asoc, void *event_arg, gfp_t gfp]\n- 调用者: sctp_generate_timeout_event\n- 被调用者: []\n\n9. 函数名: bh_unlock_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_timeout_event\n- 被调用者: []\n\n10. 函数名: sctp_association_put\n- 参数: [struct sctp_association *asoc]\n- 调用者: sctp_generate_timeout_event\n- 被调用者: []"
  },
  {
    "id": 843,
    "cwe": "CWE-362",
    "cve": "CVE-2015-8767",
    "purpose": "Code purpose:\"\"\"该代码用于处理SCTP协议中的心跳事件，包括心跳超时检测和关联状态管理，但存在锁与socket关系管理不当的问题\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在4.3之前版本中，SCTP协议实现未能正确处理锁与套接字之间的关系，导致本地用户可通过特制的sctp_accept调用造成死锁\"\"\"",
    "functions": "Functions:\n1. 函数名: sctp_generate_heartbeat_event\n- 参数: [unsigned long data]\n- 调用者: N/A (timer callback)\n- 被调用者: [sock_net, bh_lock_sock, sock_owned_by_user, pr_debug, mod_timer, sctp_transport_hold, sctp_do_sm, bh_unlock_sock, sctp_transport_put]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_heartbeat_event\n- 被调用者: []\n\n3. 函数名: bh_lock_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_heartbeat_event\n- 被调用者: []\n\n4. 函数名: sock_owned_by_user\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_heartbeat_event\n- 被调用者: []\n\n5. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: sctp_generate_heartbeat_event\n- 被调用者: []\n\n6. 函数名: mod_timer\n- 参数: [struct timer_list *timer, unsigned long expires]\n- 调用者: sctp_generate_heartbeat_event\n- 被调用者: []\n\n7. 函数名: sctp_transport_hold\n- 参数: [struct sctp_transport *transport]\n- 调用者: sctp_generate_heartbeat_event\n- 被调用者: []\n\n8. 函数名: sctp_do_sm\n- 参数: [struct net *net, sctp_event_t event_type, sctp_subtype_t subtype, int state, struct sctp_endpoint *ep, struct sctp_association *asoc, void *event_arg, gfp_t gfp]\n- 调用者: sctp_generate_heartbeat_event\n- 被调用者: []\n\n9. 函数名: bh_unlock_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_heartbeat_event\n- 被调用者: []\n\n10. 函数名: sctp_transport_put\n- 参数: [struct sctp_transport *transport]\n- 调用者: sctp_generate_heartbeat_event\n- 被调用者: []"
  },
  {
    "id": 850,
    "cwe": "CWE-362",
    "cve": "CVE-2015-8839",
    "purpose": "Code purpose:\"\"\"该代码实现了ext4文件系统中对文件指定范围进行清零操作的功能，包括处理未对齐的边缘、预分配空间、转换未写入的块以及更新inode信息等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于ext4_zero_range函数在处理文件空洞和页面错误时存在未同步的竞争条件，导致本地用户可能写入其他用户文件的关联页面，造成磁盘损坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: ext4_zero_range\n- 参数: [file, offset, len, mode]\n- 调用者: N/A (系统调用或文件操作接口)\n- 被调用者: [file_inode, trace_ext4_zero_range, ext4_should_journal_data, ext4_force_commit, mapping_tagged, filemap_write_and_wait_range, round_up, round_down, ext4_test_inode_flag, i_size_read, inode_newsize_ok, ext4_alloc_file_blocks, truncate_pagecache_range, ext4_current_time, ext4_inode_block_unlocked_dio, inode_dio_wait, ext4_ext_index_trans_blocks, ext4_journal_start, ext4_std_error, ext4_update_inode_size, ext4_set_inode_flag, ext4_mark_inode_dirty, ext4_zero_partial_blocks, ext4_handle_sync, ext4_journal_stop, ext4_inode_resume_unlocked_dio, mutex_unlock]\n\n2. 函数名: file_inode\n- 参数: [file]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n3. 函数名: trace_ext4_zero_range\n- 参数: [inode, offset, len, mode]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n4. 函数名: ext4_should_journal_data\n- 参数: [inode]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n5. 函数名: ext4_force_commit\n- 参数: [inode->i_sb]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n6. 函数名: mapping_tagged\n- 参数: [mapping, PAGECACHE_TAG_DIRTY]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n7. 函数名: filemap_write_and_wait_range\n- 参数: [mapping, offset, offset + len - 1]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n8. 函数名: round_up\n- 参数: [offset, 1 << blkbits]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n9. 函数名: round_down\n- 参数: [offset + len, 1 << blkbits]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n10. 函数名: ext4_test_inode_flag\n- 参数: [inode, EXT4_INODE_EXTENTS]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n11. 函数名: i_size_read\n- 参数: [inode]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n12. 函数名: inode_newsize_ok\n- 参数: [inode, new_size]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n13. 函数名: ext4_alloc_file_blocks\n- 参数: [file, lblk, max_blocks, new_size, flags, mode]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n14. 函数名: truncate_pagecache_range\n- 参数: [inode, start, end - 1]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n15. 函数名: ext4_current_time\n- 参数: [inode]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n16. 函数名: ext4_inode_block_unlocked_dio\n- 参数: [inode]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n17. 函数名: inode_dio_wait\n- 参数: [inode]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n18. 函数名: ext4_ext_index_trans_blocks\n- 参数: [inode, 2]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n19. 函数名: ext4_journal_start\n- 参数: [inode, EXT4_HT_MISC, credits]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n20. 函数名: ext4_std_error\n- 参数: [inode->i_sb, ret]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n21. 函数名: ext4_update_inode_size\n- 参数: [inode, new_size]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n22. 函数名: ext4_set_inode_flag\n- 参数: [inode, EXT4_INODE_EOFBLOCKS]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n23. 函数名: ext4_mark_inode_dirty\n- 参数: [handle, inode]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n24. 函数名: ext4_zero_partial_blocks\n- 参数: [handle, inode, offset, len]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n25. 函数名: ext4_handle_sync\n- 参数: [handle]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n26. 函数名: ext4_journal_stop\n- 参数: [handle]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n27. 函数名: ext4_inode_resume_unlocked_dio\n- 参数: [inode]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n28. 函数名: mutex_unlock\n- 参数: [&inode->i_mutex]\n- 调用者: ext4_zero_range\n- 被调用者: N/A"
  },
  {
    "id": 851,
    "cwe": "CWE-362",
    "cve": "CVE-2015-8839",
    "purpose": "Code purpose:\"\"\"该代码实现了ext4文件系统中折叠范围(fcollapse)的功能，用于将文件指定范围内的数据块移除并将后续数据前移，从而减少文件大小。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"内核ext4文件系统在处理空洞打孔和页面错误时存在未同步的竞争条件，导致不同用户的文件页面可能被错误写入，造成磁盘损坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: ext4_collapse_range\n- 参数: [struct inode *inode, loff_t offset, loff_t len]\n- 调用者: N/A\n- 被调用者: [ext4_test_inode_flag, ext4_force_commit, filemap_write_and_wait_range, mutex_lock, i_size_read, truncate_pagecache, ext4_inode_block_unlocked_dio, inode_dio_wait, ext4_writepage_trans_blocks, ext4_journal_start, ext4_discard_preallocations, ext4_es_remove_extent, ext4_ext_remove_space, ext4_ext_shift_extents, i_size_write, ext4_handle_sync, ext4_current_time, ext4_mark_inode_dirty, ext4_journal_stop, ext4_inode_resume_unlocked_dio, mutex_unlock]\n\n2. 函数名: ext4_test_inode_flag\n- 参数: [struct inode *inode, int flag]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n3. 函数名: ext4_force_commit\n- 参数: [struct super_block *sb]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n4. 函数名: filemap_write_and_wait_range\n- 参数: [struct address_space *mapping, loff_t start, loff_t end]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n5. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n6. 函数名: i_size_read\n- 参数: [struct inode *inode]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n7. 函数名: truncate_pagecache\n- 参数: [struct inode *inode, loff_t newsize]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n8. 函数名: ext4_inode_block_unlocked_dio\n- 参数: [struct inode *inode]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n9. 函数名: inode_dio_wait\n- 参数: [struct inode *inode]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n10. 函数名: ext4_writepage_trans_blocks\n- 参数: [struct inode *inode]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n11. 函数名: ext4_journal_start\n- 参数: [struct inode *inode, int type, int nblocks]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n12. 函数名: ext4_discard_preallocations\n- 参数: [struct inode *inode]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n13. 函数名: ext4_es_remove_extent\n- 参数: [struct inode *inode, ext4_lblk_t lblk, ext4_lblk_t len]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n14. 函数名: ext4_ext_remove_space\n- 参数: [struct inode *inode, ext4_lblk_t start, ext4_lblk_t end]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n15. 函数名: ext4_ext_shift_extents\n- 参数: [struct inode *inode, handle_t *handle, ext4_lblk_t start, ext4_lblk_t shift, enum SHIFT_DIRECTION direction]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n16. 函数名: i_size_write\n- 参数: [struct inode *inode, loff_t newsize]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n17. 函数名: ext4_handle_sync\n- 参数: [handle_t *handle]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n18. 函数名: ext4_current_time\n- 参数: [struct inode *inode]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n19. 函数名: ext4_mark_inode_dirty\n- 参数: [handle_t *handle, struct inode *inode]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n20. 函数名: ext4_journal_stop\n- 参数: [handle_t *handle]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n21. 函数名: ext4_inode_resume_unlocked_dio\n- 参数: [struct inode *inode]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n22. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A"
  },
  {
    "id": 852,
    "cwe": "CWE-362",
    "cve": "CVE-2015-8839",
    "purpose": "Code purpose:\"\"\"该代码实现了ext4文件系统中插入范围(insert range)的功能，用于在文件中插入空白空间而不覆盖现有数据，同时处理相关的文件系统操作和同步问题。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于ext4文件系统在处理空洞打孔和页面错误时存在未同步的竞争条件，导致本地用户可能写入其他用户文件关联的页面，造成磁盘损坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: ext4_insert_range\n- 参数: [struct inode *inode, loff_t offset, loff_t len]\n- 调用者: N/A (top-level function)\n- 被调用者: [ext4_test_inode_flag, ext4_force_commit, filemap_write_and_wait_range, mutex_lock, i_size_read, truncate_pagecache, ext4_inode_block_unlocked_dio, inode_dio_wait, ext4_writepage_trans_blocks, ext4_journal_start, ext4_current_time, ext4_mark_inode_dirty, down_write, ext4_discard_preallocations, ext4_find_extent, ext_depth, ext4_ext_get_actual_len, ext4_ext_is_unwritten, ext4_split_extent_at, ext4_ext_drop_refs, kfree, ext4_es_remove_extent, ext4_ext_shift_extents, ext4_handle_sync, ext4_journal_stop, ext4_inode_resume_unlocked_dio, mutex_unlock]\n\n2. 函数名: ext4_test_inode_flag\n- 参数: [struct inode *inode, int flag]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n3. 函数名: ext4_force_commit\n- 参数: [struct super_block *sb]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n4. 函数名: filemap_write_and_wait_range\n- 参数: [struct address_space *mapping, loff_t start, loff_t end]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n5. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n6. 函数名: i_size_read\n- 参数: [struct inode *inode]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n7. 函数名: truncate_pagecache\n- 参数: [struct inode *inode, loff_t new]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n8. 函数名: ext4_inode_block_unlocked_dio\n- 参数: [struct inode *inode]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n9. 函数名: inode_dio_wait\n- 参数: [struct inode *inode]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n10. 函数名: ext4_writepage_trans_blocks\n- 参数: [struct inode *inode]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n11. 函数名: ext4_journal_start\n- 参数: [struct inode *inode, int type, int nblocks]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n12. 函数名: ext4_current_time\n- 参数: [struct inode *inode]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n13. 函数名: ext4_mark_inode_dirty\n- 参数: [handle_t *handle, struct inode *inode]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n14. 函数名: down_write\n- 参数: [struct rw_semaphore *sem]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n15. 函数名: ext4_discard_preallocations\n- 参数: [struct inode *inode]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n16. 函数名: ext4_find_extent\n- 参数: [struct inode *inode, ext4_lblk_t block, struct ext4_ext_path **path, int flags]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n17. 函数名: ext_depth\n- 参数: [struct inode *inode]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n18. 函数名: ext4_ext_get_actual_len\n- 参数: [struct ext4_extent *extent]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n19. 函数名: ext4_ext_is_unwritten\n- 参数: [struct ext4_extent *extent]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n20. 函数名: ext4_split_extent_at\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_ext_path **path, ext4_lblk_t split, int split_flag, int flags]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n21. 函数名: ext4_ext_drop_refs\n- 参数: [struct ext4_ext_path *path]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n22. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n23. 函数名: ext4_es_remove_extent\n- 参数: [struct inode *inode, ext4_lblk_t lblk, ext4_lblk_t len]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n24. 函数名: ext4_ext_shift_extents\n- 参数: [struct inode *inode, handle_t *handle, ext4_lblk_t start, ext4_lblk_t len, int mode]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n25. 函数名: ext4_handle_sync\n- 参数: [handle_t *handle]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n26. 函数名: ext4_journal_stop\n- 参数: [handle_t *handle]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n27. 函数名: ext4_inode_resume_unlocked_dio\n- 参数: [struct inode *inode]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n28. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: ext4_insert_range\n- 被调用者: N/A"
  },
  {
    "id": 853,
    "cwe": "CWE-362",
    "cve": "CVE-2015-8839",
    "purpose": "Code purpose:\"\"\"处理ext4文件系统中DAX(Direct Access)模式下的页面错误，包括写入时的日志记录和块分配操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于ext4文件系统在处理写操作和页错误时存在未同步的竞争条件，导致不同用户的文件页面可能被错误写入，从而引发磁盘损坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: ext4_dax_fault\n- 参数: [vma, vmf]\n- 调用者: 未显示\n- 被调用者: [file_inode, sb_start_pagefault, file_update_time, ext4_journal_start_sb, IS_ERR, __dax_fault, ext4_journal_stop, sb_end_pagefault]\n\n2. 函数名: file_inode\n- 参数: [vma->vm_file]\n- 调用者: ext4_dax_fault\n- 被调用者: 未显示\n\n3. 函数名: sb_start_pagefault\n- 参数: [sb]\n- 调用者: ext4_dax_fault\n- 被调用者: 未显示\n\n4. 函数名: file_update_time\n- 参数: [vma->vm_file]\n- 调用者: ext4_dax_fault\n- 被调用者: 未显示\n\n5. 函数名: ext4_journal_start_sb\n- 参数: [sb, EXT4_HT_WRITE_PAGE, EXT4_DATA_TRANS_BLOCKS(sb)]\n- 调用者: ext4_dax_fault\n- 被调用者: 未显示\n\n6. 函数名: IS_ERR\n- 参数: [handle]\n- 调用者: ext4_dax_fault\n- 被调用者: 未显示\n\n7. 函数名: __dax_fault\n- 参数: [vma, vmf, ext4_get_block_dax, ext4_end_io_unwritten]\n- 调用者: ext4_dax_fault\n- 被调用者: 未显示\n\n8. 函数名: ext4_journal_stop\n- 参数: [handle]\n- 调用者: ext4_dax_fault\n- 被调用者: 未显示\n\n9. 函数名: sb_end_pagefault\n- 参数: [sb]\n- 调用者: ext4_dax_fault\n- 被调用者: 未显示"
  },
  {
    "id": 854,
    "cwe": "CWE-362",
    "cve": "CVE-2015-8839",
    "purpose": "Code purpose:\"\"\"该代码实现了ext4文件系统中DAX(Direct Access)模式下处理写时复制(COW)页面错误的mkwrite操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于ext4文件系统在处理写操作时存在竞争条件，导致不同用户的文件页面在未同步的洞打孔和页面错误处理后被错误写入，从而引发磁盘损坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: ext4_dax_mkwrite\n- 参数: [vma, vmf]\n- 调用者: 未显示\n- 被调用者: [dax_mkwrite, ext4_get_block_dax, ext4_end_io_unwritten]\n\n2. 函数名: dax_mkwrite\n- 参数: [vma, vmf, ext4_get_block_dax, ext4_end_io_unwritten]\n- 调用者: ext4_dax_mkwrite\n- 被调用者: 未显示\n\n3. 函数名: ext4_get_block_dax\n- 参数: 未显示\n- 调用者: dax_mkwrite\n- 被调用者: 未显示\n\n4. 函数名: ext4_end_io_unwritten\n- 参数: 未显示\n- 调用者: dax_mkwrite\n- 被调用者: 未显示"
  },
  {
    "id": 855,
    "cwe": "CWE-362",
    "cve": "CVE-2015-8839",
    "purpose": "Code purpose:\"\"\"处理ext4文件系统中DAX(直接访问)模式下的大页(PMD)页面错误，包括写入时的日志记录和块分配\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4文件系统中，由于未正确处理页面错误和空洞打孔操作之间的竞争条件，导致本地用户可能通过写入与不同用户文件关联的页面造成磁盘损坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: ext4_dax_pmd_fault\n- 参数: [struct vm_area_struct *vma, unsigned long addr, pmd_t *pmd, unsigned int flags]\n- 调用者: 未指定\n- 被调用者: [file_inode, sb_start_pagefault, file_update_time, ext4_journal_start_sb, ext4_chunk_trans_blocks, IS_ERR, __dax_pmd_fault, ext4_get_block_dax, ext4_end_io_unwritten, ext4_journal_stop, sb_end_pagefault]\n\n2. 函数名: file_inode\n- 参数: [struct file *file]\n- 调用者: ext4_dax_pmd_fault\n- 被调用者: 未指定\n\n3. 函数名: sb_start_pagefault\n- 参数: [struct super_block *sb]\n- 调用者: ext4_dax_pmd_fault\n- 被调用者: 未指定\n\n4. 函数名: file_update_time\n- 参数: [struct file *file]\n- 调用者: ext4_dax_pmd_fault\n- 被调用者: 未指定\n\n5. 函数名: ext4_journal_start_sb\n- 参数: [struct super_block *sb, int type, int nblocks]\n- 调用者: ext4_dax_pmd_fault\n- 被调用者: 未指定\n\n6. 函数名: ext4_chunk_trans_blocks\n- 参数: [struct inode *inode, int nrblocks]\n- 调用者: ext4_dax_pmd_fault\n- 被调用者: 未指定\n\n7. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: ext4_dax_pmd_fault\n- 被调用者: 未指定\n\n8. 函数名: __dax_pmd_fault\n- 参数: [struct vm_area_struct *vma, unsigned long addr, pmd_t *pmd, unsigned int flags, get_block_t get_block, dax_iodone_t complete_unwritten]\n- 调用者: ext4_dax_pmd_fault\n- 被调用者: 未指定\n\n9. 函数名: ext4_get_block_dax\n- 参数: 未指定\n- 调用者: ext4_dax_pmd_fault (通过参数传递)\n- 被调用者: 未指定\n\n10. 函数名: ext4_end_io_unwritten\n- 参数: 未指定\n- 调用者: ext4_dax_pmd_fault (通过参数传递)\n- 被调用者: 未指定\n\n11. 函数名: ext4_journal_stop\n- 参数: [handle_t *handle]\n- 调用者: ext4_dax_pmd_fault\n- 被调用者: 未指定\n\n12. 函数名: sb_end_pagefault\n- 参数: [struct super_block *sb]\n- 调用者: ext4_dax_pmd_fault\n- 被调用者: 未指定"
  },
  {
    "id": 856,
    "cwe": "CWE-362",
    "cve": "CVE-2015-8839",
    "purpose": "Code purpose:\"\"\"该代码实现了ext4文件系统中打孔(hole punching)功能，用于在文件中创建空洞，释放指定偏移量和长度的磁盘空间。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4文件系统中，由于未正确处理hole punching操作与页面错误处理之间的同步问题，导致不同用户的文件写入操作可能发生竞争条件，从而引发磁盘损坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: ext4_punch_hole\n- 参数: [inode, offset, length]\n- 调用者: N/A (top-level function)\n- 被调用者: [S_ISREG, trace_ext4_punch_hole, filemap_write_and_wait_range, mutex_lock, ext4_inode_attach_jinode, round_up, round_down, truncate_pagecache_range, ext4_inode_block_unlocked_dio, inode_dio_wait, ext4_test_inode_flag, ext4_writepage_trans_blocks, ext4_blocks_for_truncate, ext4_journal_start, ext4_zero_partial_blocks, ext4_journal_stop, ext4_std_error, ext4_discard_preallocations, ext4_es_remove_extent, ext4_ext_remove_space, ext4_ind_remove_space, ext4_handle_sync, ext4_current_time, ext4_mark_inode_dirty, ext4_inode_resume_unlocked_dio, mutex_unlock]\n\n2. 函数名: S_ISREG\n- 参数: [inode->i_mode]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n3. 函数名: trace_ext4_punch_hole\n- 参数: [inode, offset, length, 0]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n4. 函数名: filemap_write_and_wait_range\n- 参数: [mapping, offset, offset + length - 1]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n5. 函数名: mutex_lock\n- 参数: [&inode->i_mutex]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n6. 函数名: ext4_inode_attach_jinode\n- 参数: [inode]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n7. 函数名: round_up\n- 参数: [offset, sb->s_blocksize]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n8. 函数名: round_down\n- 参数: [(offset + length), sb->s_blocksize]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n9. 函数名: truncate_pagecache_range\n- 参数: [inode, first_block_offset, last_block_offset]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n10. 函数名: ext4_inode_block_unlocked_dio\n- 参数: [inode]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n11. 函数名: inode_dio_wait\n- 参数: [inode]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n12. 函数名: ext4_test_inode_flag\n- 参数: [inode, EXT4_INODE_EXTENTS]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n13. 函数名: ext4_writepage_trans_blocks\n- 参数: [inode]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n14. 函数名: ext4_blocks_for_truncate\n- 参数: [inode]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n15. 函数名: ext4_journal_start\n- 参数: [inode, EXT4_HT_TRUNCATE, credits]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n16. 函数名: ext4_zero_partial_blocks\n- 参数: [handle, inode, offset, length]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n17. 函数名: ext4_journal_stop\n- 参数: [handle]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n18. 函数名: ext4_std_error\n- 参数: [sb, ret]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n19. 函数名: ext4_discard_preallocations\n- 参数: [inode]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n20. 函数名: ext4_es_remove_extent\n- 参数: [inode, first_block, stop_block - first_block]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n21. 函数名: ext4_ext_remove_space\n- 参数: [inode, first_block, stop_block - 1]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n22. 函数名: ext4_ind_remove_space\n- 参数: [handle, inode, first_block, stop_block]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n23. 函数名: ext4_handle_sync\n- 参数: [handle]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n24. 函数名: ext4_current_time\n- 参数: [inode]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n25. 函数名: ext4_mark_inode_dirty\n- 参数: [handle, inode]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n26. 函数名: ext4_inode_resume_unlocked_dio\n- 参数: [inode]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n27. 函数名: mutex_unlock\n- 参数: [&inode->i_mutex]\n- 调用者: ext4_punch_hole\n- 被调用者: []"
  },
  {
    "id": 857,
    "cwe": "CWE-362",
    "cve": "CVE-2015-8839",
    "purpose": "Code purpose:\"\"\"该代码实现了ext4文件系统中文件属性修改的功能，包括权限、所有者、文件大小等属性的变更处理，并涉及磁盘空间管理和日志记录等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核ext4文件系统中存在未同步的页错误处理和空洞打孔操作，导致不同用户的文件页面写入竞争条件，可能引发磁盘损坏\"\"\"",
    "functions": "Functions:\n1. 函数名: ext4_setattr\n- 参数: [struct dentry *dentry, struct iattr *attr]\n- 调用者: N/A (kernel-level function)\n- 被调用者: [d_inode, inode_change_ok, is_quota_modification, dquot_initialize, uid_eq, gid_eq, ext4_journal_start, PTR_ERR, dquot_transfer, ext4_journal_stop, ext4_mark_inode_dirty, ext4_test_inode_flag, ext4_should_order_data, ext4_begin_ordered_truncate, ext4_orphan_add, ext4_current_time, down_write, up_write, i_size_write, ext4_orphan_del, pagecache_isize_extended, ext4_should_journal_data, ext4_inode_block_unlocked_dio, inode_dio_wait, ext4_inode_resume_unlocked_dio, ext4_wait_for_tail_page_commit, truncate_pagecache, ext4_truncate, setattr_copy, mark_inode_dirty, posix_acl_chmod, ext4_std_error]\n\n2. 函数名: d_inode\n- 参数: [struct dentry *dentry]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n3. 函数名: inode_change_ok\n- 参数: [struct inode *inode, struct iattr *attr]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n4. 函数名: is_quota_modification\n- 参数: [struct inode *inode, struct iattr *attr]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n5. 函数名: dquot_initialize\n- 参数: [struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n6. 函数名: uid_eq\n- 参数: [kuid_t left, kuid_t right]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n7. 函数名: gid_eq\n- 参数: [kgid_t left, kgid_t right]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n8. 函数名: ext4_journal_start\n- 参数: [struct inode *inode, int type, int nblocks]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n9. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n10. 函数名: dquot_transfer\n- 参数: [struct inode *inode, struct iattr *attr]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n11. 函数名: ext4_journal_stop\n- 参数: [handle_t *handle]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n12. 函数名: ext4_mark_inode_dirty\n- 参数: [handle_t *handle, struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n13. 函数名: ext4_test_inode_flag\n- 参数: [struct inode *inode, int flag]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n14. 函数名: ext4_should_order_data\n- 参数: [struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n15. 函数名: ext4_begin_ordered_truncate\n- 参数: [struct inode *inode, loff_t new_size]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n16. 函数名: ext4_orphan_add\n- 参数: [handle_t *handle, struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n17. 函数名: ext4_current_time\n- 参数: [struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n18. 函数名: down_write\n- 参数: [struct rw_semaphore *sem]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n19. 函数名: up_write\n- 参数: [struct rw_semaphore *sem]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n20. 函数名: i_size_write\n- 参数: [struct inode *inode, loff_t i_size]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n21. 函数名: ext4_orphan_del\n- 参数: [handle_t *handle, struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n22. 函数名: pagecache_isize_extended\n- 参数: [struct inode *inode, loff_t from, loff_t to]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n23. 函数名: ext4_should_journal_data\n- 参数: [struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n24. 函数名: ext4_inode_block_unlocked_dio\n- 参数: [struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n25. 函数名: inode_dio_wait\n- 参数: [struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n26. 函数名: ext4_inode_resume_unlocked_dio\n- 参数: [struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n27. 函数名: ext4_wait_for_tail_page_commit\n- 参数: [struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n28. 函数名: truncate_pagecache\n- 参数: [struct inode *inode, loff_t new]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n29. 函数名: ext4_truncate\n- 参数: [struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n30. 函数名: setattr_copy\n- 参数: [struct inode *inode, const struct iattr *attr]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n31. 函数名: mark_inode_dirty\n- 参数: [struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n32. 函数名: posix_acl_chmod\n- 参数: [struct inode *inode, umode_t mode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n33. 函数名: ext4_std_error\n- 参数: [struct super_block *sb, int error]\n- 调用者: ext4_setattr\n- 被调用者: N/A"
  },
  {
    "id": 858,
    "cwe": "CWE-362",
    "cve": "CVE-2015-8839",
    "purpose": "Code purpose:\"\"\"处理ext4文件系统中页面写入请求，确保在页面写入时正确处理文件大小变化和缓冲区映射，防止数据损坏。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于ext4文件系统在处理页面写入和空洞打孔操作时存在竞争条件，导致不同用户的文件页面可能被错误写入，造成磁盘数据损坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: ext4_page_mkwrite\n- 参数: [struct vm_area_struct *vma, struct vm_fault *vmf]\n- 调用者: N/A (内核调用)\n- 被调用者: [sb_start_pagefault, file_update_time, test_opt, ext4_should_journal_data, ext4_nonda_switch, block_page_mkwrite, ext4_should_retry_alloc, i_size_read, page_has_buffers, ext4_walk_page_buffers, wait_for_stable_page, ext4_should_dioread_nolock, ext4_journal_start, ext4_writepage_trans_blocks, ext4_set_inode_state, ext4_journal_stop, block_page_mkwrite_return, sb_end_pagefault]\n\n2. 函数名: sb_start_pagefault\n- 参数: [struct super_block *sb]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n3. 函数名: file_update_time\n- 参数: [struct file *file]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n4. 函数名: test_opt\n- 参数: [struct super_block *sb, int opt]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n5. 函数名: ext4_should_journal_data\n- 参数: [struct inode *inode]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n6. 函数名: ext4_nonda_switch\n- 参数: [struct super_block *sb]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n7. 函数名: block_page_mkwrite\n- 参数: [struct vm_area_struct *vma, struct vm_fault *vmf, get_block_t *get_block]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n8. 函数名: ext4_should_retry_alloc\n- 参数: [struct super_block *sb, int *retries]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n9. 函数名: i_size_read\n- 参数: [struct inode *inode]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n10. 函数名: page_has_buffers\n- 参数: [struct page *page]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n11. 函数名: ext4_walk_page_buffers\n- 参数: [handle_t *handle, struct buffer_head *head, unsigned from, unsigned to, int *partial, int (*fn)(handle_t *, struct buffer_head *, int))]\n- 调用者: ext4_page_mkwrite\n- 被调用者: [ext4_bh_unmapped, do_journal_get_write_access]\n\n12. 函数名: wait_for_stable_page\n- 参数: [struct page *page]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n13. 函数名: ext4_should_dioread_nolock\n- 参数: [struct inode *inode]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n14. 函数名: ext4_journal_start\n- 参数: [struct inode *inode, int type, int nblocks]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n15. 函数名: ext4_writepage_trans_blocks\n- 参数: [struct inode *inode]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n16. 函数名: ext4_set_inode_state\n- 参数: [struct inode *inode, unsigned int state]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n17. 函数名: ext4_journal_stop\n- 参数: [handle_t *handle]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n18. 函数名: block_page_mkwrite_return\n- 参数: [int ret]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n19. 函数名: sb_end_pagefault\n- 参数: [struct super_block *sb]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n20. 函数名: ext4_bh_unmapped\n- 参数: [handle_t *handle, struct buffer_head *bh, int flags]\n- 调用者: ext4_walk_page_buffers\n- 被调用者: []\n\n21. 函数名: do_journal_get_write_access\n- 参数: [handle_t *handle, struct buffer_head *bh, int flags]\n- 调用者: ext4_walk_page_buffers\n- 被调用者: []"
  },
  {
    "id": 859,
    "cwe": "CWE-362",
    "cve": "CVE-2015-8839",
    "purpose": "Code purpose:\"\"\"初始化ext4文件系统中inode信息结构体的各个成员，包括孤儿链表、读写信号量和虚拟文件系统inode\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核ext4文件系统中存在竞争条件，允许本地用户通过未同步的空洞打孔和页面错误处理操作，写入与其他用户文件关联的页面，导致磁盘损坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: init_once\n- 参数: [void *foo]\n- 调用者: 不适用（静态函数，通常由内核初始化机制调用）\n- 被调用者: [INIT_LIST_HEAD, init_rwsem, inode_init_once]\n\n2. 函数名: INIT_LIST_HEAD\n- 参数: [&ei->i_orphan]\n- 调用者: init_once\n- 被调用者: []\n\n3. 函数名: init_rwsem\n- 参数: [&ei->xattr_sem]\n- 调用者: init_once\n- 被调用者: []\n\n4. 函数名: init_rwsem\n- 参数: [&ei->i_data_sem]\n- 调用者: init_once\n- 被调用者: []\n\n5. 函数名: inode_init_once\n- 参数: [&ei->vfs_inode]\n- 调用者: init_once\n- 被调用者: []"
  },
  {
    "id": 860,
    "cwe": "CWE-362",
    "cve": "CVE-2015-8839",
    "purpose": "Code purpose:\"\"\"在ext4文件系统中处理写入失败时截断文件以防止数据损坏\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"内核ext4文件系统实现中存在多个竞态条件，导致不同用户的文件页面在未同步的洞打孔和页面错误处理后被错误写入，从而引发磁盘损坏\"\"\"",
    "functions": "Functions:\n1. 函数名: ext4_truncate_failed_write\n- 参数: [struct inode *inode]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [truncate_inode_pages, ext4_truncate]\n\n2. 函数名: truncate_inode_pages\n- 参数: [inode->i_mapping, inode->i_size]\n- 调用者: ext4_truncate_failed_write\n- 被调用者: 未明确（可能为内核内部函数）\n\n3. 函数名: ext4_truncate\n- 参数: [struct inode *inode]\n- 调用者: ext4_truncate_failed_write\n- 被调用者: 未明确（可能为内核内部函数）"
  },
  {
    "id": 871,
    "cwe": "CWE-362",
    "cve": "CVE-2015-8963",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的性能事件子系统中添加软件事件，处理事件采样和周期设置，并将事件添加到哈希表中进行管理。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在CPU热插拔操作期间，对swevent数据结构的处理不当导致竞态条件，可能引发权限提升或拒绝服务\"\"\"",
    "functions": "Functions:\n1. 函数名: perf_swevent_add\n- 参数: [event, flags]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [this_cpu_ptr, is_sampling_event, perf_swevent_set_period, find_swevent_head, WARN_ON_ONCE, hlist_add_head_rcu, perf_event_update_userpage]\n\n2. 函数名: this_cpu_ptr\n- 参数: [&swevent_htable]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n3. 函数名: is_sampling_event\n- 参数: [event]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n4. 函数名: perf_swevent_set_period\n- 参数: [event]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n5. 函数名: find_swevent_head\n- 参数: [swhash, event]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n6. 函数名: WARN_ON_ONCE\n- 参数: [swhash->online]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n7. 函数名: hlist_add_head_rcu\n- 参数: [&event->hlist_entry, head]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n8. 函数名: perf_event_update_userpage\n- 参数: [event]\n- 调用者: perf_swevent_add\n- 被调用者: []"
  },
  {
    "id": 872,
    "cwe": "CWE-362",
    "cve": "CVE-2015-8963",
    "purpose": "Code purpose:\"\"\"在CPU初始化时设置软件事件哈希表，并在引用计数大于0时分配新的软件事件链表\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在CPU热插拔操作期间，由于对swevent数据结构的处理不当导致竞态条件，可能引发权限提升或拒绝服务(use-after-free)漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: perf_event_init_cpu\n- 参数: [cpu]\n- 调用者: 未显示（通常由CPU热插拔相关代码调用）\n- 被调用者: [mutex_lock, kzalloc_node, WARN_ON, rcu_assign_pointer, mutex_unlock, cpu_to_node]\n\n2. 函数名: mutex_lock\n- 参数: [&swhash->hlist_mutex]\n- 调用者: perf_event_init_cpu\n- 被调用者: []\n\n3. 函数名: kzalloc_node\n- 参数: [sizeof(*hlist), GFP_KERNEL, cpu_to_node(cpu)]\n- 调用者: perf_event_init_cpu\n- 被调用者: []\n\n4. 函数名: WARN_ON\n- 参数: [!hlist]\n- 调用者: perf_event_init_cpu\n- 被调用者: []\n\n5. 函数名: rcu_assign_pointer\n- 参数: [swhash->swevent_hlist, hlist]\n- 调用者: perf_event_init_cpu\n- 被调用者: []\n\n6. 函数名: mutex_unlock\n- 参数: [&swhash->hlist_mutex]\n- 调用者: perf_event_init_cpu\n- 被调用者: []\n\n7. 函数名: cpu_to_node\n- 参数: [cpu]\n- 调用者: perf_event_init_cpu\n- 被调用者: []"
  },
  {
    "id": 873,
    "cwe": "CWE-362",
    "cve": "CVE-2015-8963",
    "purpose": "Code purpose:\"\"\"该代码用于在多核环境下安全地获取和引用指定CPU上的软件事件哈希表，并在需要时分配内存初始化新的哈希表条目。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在CPU热拔插操作期间，由于对swevent数据结构的处理不当，导致竞态条件可能引发权限提升或拒绝服务(use-after-free)漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: swevent_hlist_get_cpu\n- 参数: [struct perf_event *event, int cpu]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [swevent_hlist_deref, cpu_online, kzalloc, rcu_assign_pointer, mutex_lock, mutex_unlock]\n\n2. 函数名: swevent_hlist_deref\n- 参数: [struct swevent_htable *swhash]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: 未明确\n\n3. 函数名: cpu_online\n- 参数: [int cpu]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: 未明确\n\n4. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: 未明确\n\n5. 函数名: rcu_assign_pointer\n- 参数: [struct swevent_hlist *hlist]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: 未明确\n\n6. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: 未明确\n\n7. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: 未明确"
  },
  {
    "id": 881,
    "cwe": "CWE-362",
    "cve": "CVE-2015-9016",
    "purpose": "Code purpose:\"\"\"处理块设备队列中的刷新请求完成后的清理工作，包括释放资源、推进等待请求到下一阶段，并防止队列停滞\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在blk_mq_tag_to_rq中存在竞态条件，当请求已被blk_mq_complete_request释放后仍可能被使用，导致释放后重用漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: flush_end_io\n- 参数: [struct request *flush_rq, int error]\n- 调用者: 未明确显示（通常由块设备层调用）\n- 被调用者: [blk_get_flush_queue, spin_lock_irqsave, elv_completed_request, blk_flush_cur_seq, blk_flush_complete_seq, blk_run_queue_async, spin_unlock_irqrestore]\n\n2. 函数名: blk_get_flush_queue\n- 参数: [struct request_queue *q, struct blk_mq_ctx *ctx]\n- 调用者: flush_end_io\n- 被调用者: []\n\n3. 函数名: spin_lock_irqsave\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: flush_end_io\n- 被调用者: []\n\n4. 函数名: elv_completed_request\n- 参数: [struct request_queue *q, struct request *rq]\n- 调用者: flush_end_io\n- 被调用者: []\n\n5. 函数名: blk_flush_cur_seq\n- 参数: [struct request *rq]\n- 调用者: flush_end_io\n- 被调用者: []\n\n6. 函数名: blk_flush_complete_seq\n- 参数: [struct request *rq, struct blk_flush_queue *fq, unsigned int seq, int error]\n- 调用者: flush_end_io\n- 被调用者: []\n\n7. 函数名: blk_run_queue_async\n- 参数: [struct request_queue *q]\n- 调用者: flush_end_io\n- 被调用者: []\n\n8. 函数名: spin_unlock_irqrestore\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: flush_end_io\n- 被调用者: []"
  },
  {
    "id": 882,
    "cwe": "CWE-362",
    "cve": "CVE-2015-9016",
    "purpose": "Code purpose:\"\"\"该代码用于管理块设备队列中的刷新请求，处理刷新操作的并发控制和资源分配，确保数据一致性。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于blk_mq_tag_to_rq中存在竞态条件，当请求已被blk_mq_complete_request释放后仍可能被访问，导致释放后重用漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: blk_kick_flush\n- 参数: [struct request_queue *q, struct blk_flush_queue *fq]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [list_first_entry, blk_rq_init, blk_flush_queue_rq]\n\n2. 函数名: list_first_entry\n- 参数: [pending, struct request, flush.list]\n- 调用者: blk_kick_flush\n- 被调用者: []\n\n3. 函数名: blk_rq_init\n- 参数: [q, flush_rq]\n- 调用者: blk_kick_flush\n- 被调用者: []\n\n4. 函数名: blk_flush_queue_rq\n- 参数: [flush_rq, false]\n- 调用者: blk_kick_flush\n- 被调用者: []\n\n5. 函数名: time_before\n- 参数: [jiffies, fq->flush_pending_since + FLUSH_PENDING_TIMEOUT]\n- 调用者: blk_kick_flush\n- 被调用者: []\n\n6. 函数名: flush_end_io\n- 参数: 未明确（作为回调函数指针赋值）\n- 调用者: 未明确（通过flush_rq->end_io调用）\n- 被调用者: []"
  },
  {
    "id": 883,
    "cwe": "CWE-362",
    "cve": "CVE-2015-9016",
    "purpose": "Code purpose:\"\"\"遍历块设备多队列标签中的请求并执行回调函数\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在blk_mq_tag_to_rq函数中存在竞态条件，当请求已被blk_mq_complete_request释放后仍可能被访问，导致释放后使用(UAF)漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: bt_for_each\n- 参数: [struct blk_mq_hw_ctx *hctx, struct blk_mq_bitmap_tags *bt, unsigned int off, busy_iter_fn *fn, void *data, bool reserved]\n- 调用者: N/A\n- 被调用者: [find_first_bit, find_next_bit, blk_mq_tag_to_rq]\n\n2. 函数名: find_first_bit\n- 参数: [&bm->word, bm->depth]\n- 调用者: bt_for_each\n- 被调用者: N/A\n\n3. 函数名: find_next_bit\n- 参数: [&bm->word, bm->depth, bit + 1]\n- 调用者: bt_for_each\n- 被调用者: N/A\n\n4. 函数名: blk_mq_tag_to_rq\n- 参数: [hctx->tags, off + bit]\n- 调用者: bt_for_each\n- 被调用者: N/A\n\n5. 函数名: fn\n- 参数: [hctx, rq, data, reserved]\n- 调用者: bt_for_each\n- 被调用者: N/A"
  },
  {
    "id": 884,
    "cwe": "CWE-362",
    "cve": "CVE-2015-9016",
    "purpose": "Code purpose:\"\"\"遍历块设备多队列标签中的请求并执行回调函数\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在blk_mq_tag_to_rq函数中存在竞态条件，当请求已被blk_mq_complete_request释放后仍可能被访问，导致释放后使用漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: bt_tags_for_each\n- 参数: [struct blk_mq_tags *tags, struct blk_mq_bitmap_tags *bt, unsigned int off, busy_tag_iter_fn *fn, void *data, bool reserved]\n- 调用者: 未显示\n- 被调用者: [find_first_bit, find_next_bit, blk_mq_tag_to_rq, fn]\n\n2. 函数名: find_first_bit\n- 参数: [&bm->word, bm->depth]\n- 调用者: bt_tags_for_each\n- 被调用者: 未显示\n\n3. 函数名: find_next_bit\n- 参数: [&bm->word, bm->depth, bit + 1]\n- 调用者: bt_tags_for_each\n- 被调用者: 未显示\n\n4. 函数名: blk_mq_tag_to_rq\n- 参数: [tags, off + bit]\n- 调用者: bt_tags_for_each\n- 被调用者: 未显示\n\n5. 函数名: fn\n- 参数: [rq, data, reserved]\n- 调用者: bt_tags_for_each\n- 被调用者: 未显示"
  },
  {
    "id": 885,
    "cwe": "CWE-362",
    "cve": "CVE-2015-9016",
    "purpose": "Code purpose:\"\"\"该代码用于根据标签从块多队列标签系统中获取对应的请求结构体，并处理刷新请求的特殊情况\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于blk_mq_tag_to_rq函数在访问已被blk_mq_complete_request释放的请求结构体时存在竞态条件，导致使用后释放漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: blk_mq_tag_to_rq\n- 参数: [struct blk_mq_tags *tags, unsigned int tag]\n- 调用者: 未指定\n- 被调用者: [blk_get_flush_queue, is_flush_request]\n\n2. 函数名: blk_get_flush_queue\n- 参数: [struct request_queue *q, struct blk_mq_hw_ctx *hctx]\n- 调用者: blk_mq_tag_to_rq\n- 被调用者: 未指定\n\n3. 函数名: is_flush_request\n- 参数: [struct request *rq, struct blk_flush_queue *fq, unsigned int tag]\n- 调用者: blk_mq_tag_to_rq\n- 被调用者: 未指定"
  },
  {
    "id": 888,
    "cwe": "CWE-362",
    "cve": "CVE-2016-0723",
    "purpose": "Code purpose:\"\"\"处理终端设备的输入输出控制命令(ioctl)，包括设置和获取终端参数、控制终端行为等功能\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在TIOCSETD和TIOCGETD ioctl调用之间存在竞争条件，导致内核内存信息泄露或使用后释放的系统崩溃漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: tty_ioctl\n- 参数: [struct file *file, unsigned int cmd, unsigned long arg]\n- 调用者: N/A\n- 被调用者: [file_tty, tty_paranoia_check, tty_pair_get_tty, tty_check_change, tty_wait_until_sent, signal_pending, tiocsti, tiocgwinsz, tiocswinsz, tioccons, fionbio, put_user, no_tty, tiocsctty, tiocgpgrp, tiocspgrp, tiocgsid, tiocsetd, tty_vhangup, new_encode_dev, tty_devnum, send_break, tty_tiocmget, tty_tiocmset, tty_tiocgicount, tty_buffer_flush, tty_warn_deprecated_flags, tty_ldisc_ref_wait, tty_ldisc_deref]\n\n2. 函数名: file_tty\n- 参数: [struct file *file]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n3. 函数名: tty_paranoia_check\n- 参数: [struct tty_struct *tty, struct inode *inode, const char *routine]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n4. 函数名: tty_pair_get_tty\n- 参数: [struct tty_struct *tty]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n5. 函数名: tty_check_change\n- 参数: [struct tty_struct *tty]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n6. 函数名: tty_wait_until_sent\n- 参数: [struct tty_struct *tty, long timeout]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n7. 函数名: signal_pending\n- 参数: [struct task_struct *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n8. 函数名: tiocsti\n- 参数: [struct tty_struct *tty, void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n9. 函数名: tiocgwinsz\n- 参数: [struct tty_struct *real_tty, void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n10. 函数名: tiocswinsz\n- 参数: [struct tty_struct *real_tty, void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n11. 函数名: tioccons\n- 参数: [struct file *file]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n12. 函数名: fionbio\n- 参数: [struct file *file, void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n13. 函数名: put_user\n- 参数: [type x, type __user *ptr]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n14. 函数名: no_tty\n- 参数: []\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n15. 函数名: tiocsctty\n- 参数: [struct tty_struct *real_tty, struct file *file, unsigned long arg]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n16. 函数名: tiocgpgrp\n- 参数: [struct tty_struct *tty, struct tty_struct *real_tty, void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n17. 函数名: tiocspgrp\n- 参数: [struct tty_struct *tty, struct tty_struct *real_tty, void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n18. 函数名: tiocgsid\n- 参数: [struct tty_struct *tty, struct tty_struct *real_tty, void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n19. 函数名: tiocsetd\n- 参数: [struct tty_struct *tty, void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n20. 函数名: tty_vhangup\n- 参数: [struct tty_struct *tty]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n21. 函数名: new_encode_dev\n- 参数: [dev_t dev]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n22. 函数名: tty_devnum\n- 参数: [struct tty_struct *tty]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n23. 函数名: send_break\n- 参数: [struct tty_struct *tty, unsigned int duration]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n24. 函数名: tty_tiocmget\n- 参数: [struct tty_struct *tty, void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n25. 函数名: tty_tiocmset\n- 参数: [struct tty_struct *tty, unsigned int cmd, void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n26. 函数名: tty_tiocgicount\n- 参数: [struct tty_struct *tty, void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n27. 函数名: tty_buffer_flush\n- 参数: [struct tty_struct *tty, struct tty_ldisc *ld]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n28. 函数名: tty_warn_deprecated_flags\n- 参数: [void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n29. 函数名: tty_ldisc_ref_wait\n- 参数: [struct tty_struct *tty]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n30. 函数名: tty_ldisc_deref\n- 参数: [struct tty_ldisc *ld]\n- 调用者: tty_ioctl\n- 被调用者: N/A"
  },
  {
    "id": 898,
    "cwe": "CWE-362",
    "cve": "CVE-2016-10200",
    "purpose": "Code purpose:\"\"\"实现L2TPv3 IP封装功能中的socket绑定操作，包括地址验证、状态检查和绑定表管理\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在检查SOCK_ZAPPED状态和实际绑定操作之间存在竞争条件，导致多个bind系统调用可能绕过状态检查，引发权限提升或拒绝服务漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: l2tp_ip_bind\n- 参数: [sk, uaddr, addr_len]\n- 调用者: 未显示（系统调用）\n- 被调用者: [inet_sk, sock_net, sock_flag, __l2tp_ip_bind_lookup, read_lock_bh, read_unlock_bh, lock_sock, inet_addr_type, sk_dst_reset, l2tp_ip_sk, write_lock_bh, sk_add_bind_node, sk_del_node_init, write_unlock_bh, sock_reset_flag, release_sock]\n\n2. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n3. 函数名: sock_net\n- 参数: [sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n4. 函数名: sock_flag\n- 参数: [sk, SOCK_ZAPPED]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n5. 函数名: __l2tp_ip_bind_lookup\n- 参数: [net, addr->l2tp_addr.s_addr, sk->sk_bound_dev_if, addr->l2tp_conn_id]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n6. 函数名: read_lock_bh\n- 参数: [&l2tp_ip_lock]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n7. 函数名: read_unlock_bh\n- 参数: [&l2tp_ip_lock]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n8. 函数名: lock_sock\n- 参数: [sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n9. 函数名: inet_addr_type\n- 参数: [net, addr->l2tp_addr.s_addr]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n10. 函数名: sk_dst_reset\n- 参数: [sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n11. 函数名: l2tp_ip_sk\n- 参数: [sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n12. 函数名: write_lock_bh\n- 参数: [&l2tp_ip_lock]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n13. 函数名: sk_add_bind_node\n- 参数: [sk, &l2tp_ip_bind_table]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n14. 函数名: sk_del_node_init\n- 参数: [sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n15. 函数名: write_unlock_bh\n- 参数: [&l2tp_ip_lock]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n16. 函数名: sock_reset_flag\n- 参数: [sk, SOCK_ZAPPED]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n17. 函数名: release_sock\n- 参数: [sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []"
  },
  {
    "id": 899,
    "cwe": "CWE-362",
    "cve": "CVE-2016-10200",
    "purpose": "Code purpose:\"\"\"该代码实现了L2TPv3协议在IPv6环境下的socket绑定功能，包括地址类型检查、绑定状态验证和地址归属确认等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多次bind系统调用时未能正确检查SOCK_ZAPPED状态，导致竞争条件可能引发权限提升或拒绝服务(use-after-free)。\"\"\"",
    "functions": "Functions:\n1. 函数名: l2tp_ip6_bind\n- 参数: [sk, uaddr, addr_len]\n- 调用者: 未显示（应为系统调用或其他内核模块）\n- 被调用者: [inet_sk, inet6_sk, sock_net, ipv6_addr_type, __l2tp_ip6_bind_lookup, lock_sock, rcu_read_lock, dev_get_by_index_rcu, ipv6_chk_addr, rcu_read_unlock, sk_add_bind_node, sk_del_node_init, sock_reset_flag, release_sock, read_unlock_bh, write_lock_bh, write_unlock_bh]\n\n2. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n3. 函数名: inet6_sk\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n4. 函数名: sock_net\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n5. 函数名: ipv6_addr_type\n- 参数: [&addr->l2tp_addr]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n6. 函数名: __l2tp_ip6_bind_lookup\n- 参数: [net, &addr->l2tp_addr, sk->sk_bound_dev_if, addr->l2tp_conn_id]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n7. 函数名: lock_sock\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n8. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n9. 函数名: dev_get_by_index_rcu\n- 参数: [sock_net(sk), sk->sk_bound_dev_if]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n10. 函数名: ipv6_chk_addr\n- 参数: [sock_net(sk), &addr->l2tp_addr, dev, 0]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n11. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n12. 函数名: sk_add_bind_node\n- 参数: [sk, &l2tp_ip6_bind_table]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n13. 函数名: sk_del_node_init\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n14. 函数名: sock_reset_flag\n- 参数: [sk, SOCK_ZAPPED]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n15. 函数名: release_sock\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n16. 函数名: read_unlock_bh\n- 参数: [&l2tp_ip6_lock]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n17. 函数名: write_lock_bh\n- 参数: [&l2tp_ip6_lock]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n18. 函数名: write_unlock_bh\n- 参数: [&l2tp_ip6_lock]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []"
  },
  {
    "id": 905,
    "cwe": "CWE-362",
    "cve": "CVE-2016-10741",
    "purpose": "Code purpose:\"\"\"处理XFS文件系统中获取数据块的操作，包括直接I/O和内存映射I/O，并管理相关的块映射和分配\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核XFS文件系统中处理直接I/O和内存映射I/O时存在竞争条件，当遇到空洞(hole)时使用BUG_ON而非I/O错误处理导致系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: __xfs_get_blocks\n- 参数: [struct inode *inode, sector_t iblock, struct buffer_head *bh_result, int create, bool direct, bool dax_fault]\n- 调用者: N/A (kernel internal function)\n- 被调用者: [XFS_I, xfs_ilock_data_map_shared, xfs_is_reflink_inode, xfs_reflink_find_cow_mapping, xfs_bmapi_read, xfs_reflink_trim_irec_to_next_cow, xfs_ilock_demote, xfs_iomap_write_direct, xfs_iunlock, xfs_bounce_unaligned_dio_write, xfs_map_buffer, xfs_map_direct, xfs_find_bdev_for_inode]\n\n2. 函数名: XFS_I\n- 参数: [struct inode *inode]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n3. 函数名: xfs_ilock_data_map_shared\n- 参数: [struct xfs_inode *ip]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n4. 函数名: xfs_is_reflink_inode\n- 参数: [struct xfs_inode *ip]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n5. 函数名: xfs_reflink_find_cow_mapping\n- 参数: [struct xfs_inode *ip, xfs_off_t offset, struct xfs_bmbt_irec *imap, bool *need_alloc]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n6. 函数名: xfs_bmapi_read\n- 参数: [struct xfs_inode *ip, xfs_fileoff_t bno, xfs_filblks_t len, struct xfs_bmbt_irec *mval, int *nmap, int flags]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n7. 函数名: xfs_reflink_trim_irec_to_next_cow\n- 参数: [struct xfs_inode *ip, xfs_fileoff_t offset_fsb, struct xfs_bmbt_irec *imap]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n8. 函数名: xfs_ilock_demote\n- 参数: [struct xfs_inode *ip, int lock_flags]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n9. 函数名: xfs_iomap_write_direct\n- 参数: [struct xfs_inode *ip, xfs_off_t offset, size_t count, struct xfs_bmbt_irec *imap, int *nimaps]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n10. 函数名: xfs_iunlock\n- 参数: [struct xfs_inode *ip, int lock_flags]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n11. 函数名: xfs_bounce_unaligned_dio_write\n- 参数: [struct xfs_inode *ip, xfs_fileoff_t offset_fsb, struct xfs_bmbt_irec *imap]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n12. 函数名: xfs_map_buffer\n- 参数: [struct inode *inode, struct buffer_head *bh_result, struct xfs_bmbt_irec *imap, xfs_off_t offset]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n13. 函数名: xfs_map_direct\n- 参数: [struct inode *inode, struct buffer_head *bh_result, struct xfs_bmbt_irec *imap, xfs_off_t offset, bool is_cow]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n14. 函数名: xfs_find_bdev_for_inode\n- 参数: [struct inode *inode]\n- 调用者: __xfs_get_blocks\n- 被调用者: []"
  },
  {
    "id": 909,
    "cwe": "CWE-362",
    "cve": "CVE-2016-10906",
    "purpose": "Code purpose:\"\"\"该代码实现了ARC EMAC网络设备驱动中的数据包发送功能，包括数据包填充、DMA映射、环形缓冲区管理和传输状态更新等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于arc_emac_tx和arc_emac_tx_clean函数之间的竞争条件导致释放后使用漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: arc_emac_tx\n- 参数: [struct sk_buff *skb, struct net_device *ndev]\n- 调用者: 未显示（通常由网络子系统调用）\n- 被调用者: [skb_padto, max_t, arc_emac_tx_avail, netif_stop_queue, netdev_err, dma_map_single, dma_mapping_error, dev_kfree_skb, dma_unmap_addr_set, dma_unmap_len_set, cpu_to_le32, wmb, skb_tx_timestamp, smp_mb, netif_start_queue, arc_reg_set]\n\n2. 函数名: skb_padto\n- 参数: [struct sk_buff *skb, int len]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n3. 函数名: max_t\n- 参数: [type, unsigned int, unsigned int]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n4. 函数名: arc_emac_tx_avail\n- 参数: [struct arc_emac_priv *priv]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n5. 函数名: netif_stop_queue\n- 参数: [struct net_device *dev]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n6. 函数名: netdev_err\n- 参数: [const struct net_device *dev, const char *fmt, ...]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n7. 函数名: dma_map_single\n- 参数: [struct device *dev, void *ptr, size_t size, enum dma_data_direction dir]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n8. 函数名: dma_mapping_error\n- 参数: [struct device *dev, dma_addr_t dma_addr]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n9. 函数名: dev_kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n10. 函数名: dma_unmap_addr_set\n- 参数: [struct buffer *buf, dma_addr_t addr, dma_addr_t val]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n11. 函数名: dma_unmap_len_set\n- 参数: [struct buffer *buf, size_t len, size_t val]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n12. 函数名: cpu_to_le32\n- 参数: [__u32 val]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n13. 函数名: wmb\n- 参数: []\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n14. 函数名: skb_tx_timestamp\n- 参数: [struct sk_buff *skb]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n15. 函数名: smp_mb\n- 参数: []\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n16. 函数名: netif_start_queue\n- 参数: [struct net_device *dev]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n17. 函数名: arc_reg_set\n- 参数: [struct arc_emac_priv *priv, int reg, u32 value]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示"
  },
  {
    "id": 910,
    "cwe": "CWE-362",
    "cve": "CVE-2016-10906",
    "purpose": "Code purpose:\"\"\"该代码用于清理网络设备发送缓冲区中的已完成传输的数据包，并更新相关统计信息。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于arc_emac_tx和arc_emac_tx_clean函数之间的竞争条件导致释放后使用漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: arc_emac_tx_clean\n- 参数: [struct net_device *ndev]\n- 调用者: 未明确显示（通常由网络子系统调用）\n- 被调用者: [le32_to_cpu, dma_unmap_single, dev_kfree_skb_irq, smp_mb, netif_queue_stopped, arc_emac_tx_avail, netif_wake_queue]\n\n2. 函数名: le32_to_cpu\n- 参数: [unsigned int info]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n3. 函数名: dma_unmap_single\n- 参数: [&ndev->dev, dma_unmap_addr(tx_buff, addr), dma_unmap_len(tx_buff, len), DMA_TO_DEVICE]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n4. 函数名: dev_kfree_skb_irq\n- 参数: [struct sk_buff *skb]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n5. 函数名: smp_mb\n- 参数: []\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n6. 函数名: netif_queue_stopped\n- 参数: [struct net_device *ndev]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n7. 函数名: arc_emac_tx_avail\n- 参数: [struct arc_emac_priv *priv]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n8. 函数名: netif_wake_queue\n- 参数: [struct net_device *ndev]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []"
  },
  {
    "id": 916,
    "cwe": "CWE-362",
    "cve": "CVE-2016-2069",
    "purpose": "Code purpose:\"\"\"在进程切换时处理内存管理单元(MMU)状态，包括页表加载、TLB刷新和LDT加载等操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在多核环境下，由于TLB状态管理和页表切换存在竞态条件，导致不同CPU可能同时访问同一分页结构，从而引发权限提升漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: switch_mm\n- 参数: [prev, next, tsk]\n- 调用者: 未显示（通常是进程调度相关代码）\n- 被调用者: [smp_processor_id, this_cpu_write, cpumask_set_cpu, load_cr3, trace_tlb_flush, cpumask_clear_cpu, load_mm_cr4, load_mm_ldt, this_cpu_read, cpumask_test_cpu]\n\n2. 函数名: smp_processor_id\n- 参数: []\n- 调用者: switch_mm\n- 被调用者: []\n\n3. 函数名: this_cpu_write\n- 参数: [cpu_tlbstate.state, TLBSTATE_OK] 和 [cpu_tlbstate.active_mm, next]\n- 调用者: switch_mm\n- 被调用者: []\n\n4. 函数名: cpumask_set_cpu\n- 参数: [cpu, mm_cpumask(next)]\n- 调用者: switch_mm\n- 被调用者: []\n\n5. 函数名: load_cr3\n- 参数: [next->pgd]\n- 调用者: switch_mm\n- 被调用者: []\n\n6. 函数名: trace_tlb_flush\n- 参数: [TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL]\n- 调用者: switch_mm\n- 被调用者: []\n\n7. 函数名: cpumask_clear_cpu\n- 参数: [cpu, mm_cpumask(prev)]\n- 调用者: switch_mm\n- 被调用者: []\n\n8. 函数名: load_mm_cr4\n- 参数: [next]\n- 调用者: switch_mm\n- 被调用者: []\n\n9. 函数名: load_mm_ldt\n- 参数: [next]\n- 调用者: switch_mm\n- 被调用者: []\n\n10. 函数名: this_cpu_read\n- 参数: [cpu_tlbstate.active_mm]\n- 调用者: switch_mm\n- 被调用者: []\n\n11. 函数名: cpumask_test_cpu\n- 参数: [cpu, mm_cpumask(next)]\n- 调用者: switch_mm\n- 被调用者: []"
  },
  {
    "id": 917,
    "cwe": "CWE-362",
    "cve": "CVE-2016-2069",
    "purpose": "Code purpose:\"\"\"在多核系统中刷新当前任务的TLB(Translation Lookaside Buffer)条目，包括本地CPU和其他CPU上的相关条目\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在多核环境下，由于缺乏对CPU间TLB刷新操作的同步保护，导致竞争条件可能被利用来提升权限\"\"\"",
    "functions": "Functions:\n1. 函数名: flush_tlb_current_task\n- 参数: []\n- 调用者: N/A\n- 被调用者: [preempt_disable, count_vm_tlb_event, local_flush_tlb, trace_tlb_flush, cpumask_any_but, smp_processor_id, flush_tlb_others, preempt_enable]\n\n2. 函数名: preempt_disable\n- 参数: []\n- 调用者: flush_tlb_current_task\n- 被调用者: []\n\n3. 函数名: count_vm_tlb_event\n- 参数: [NR_TLB_LOCAL_FLUSH_ALL]\n- 调用者: flush_tlb_current_task\n- 被调用者: []\n\n4. 函数名: local_flush_tlb\n- 参数: []\n- 调用者: flush_tlb_current_task\n- 被调用者: []\n\n5. 函数名: trace_tlb_flush\n- 参数: [TLB_LOCAL_SHOOTDOWN, TLB_FLUSH_ALL]\n- 调用者: flush_tlb_current_task\n- 被调用者: []\n\n6. 函数名: cpumask_any_but\n- 参数: [mm_cpumask(mm), smp_processor_id()]\n- 调用者: flush_tlb_current_task\n- 被调用者: []\n\n7. 函数名: smp_processor_id\n- 参数: []\n- 调用者: cpumask_any_but\n- 被调用者: []\n\n8. 函数名: flush_tlb_others\n- 参数: [mm_cpumask(mm), mm, 0UL, TLB_FLUSH_ALL]\n- 调用者: flush_tlb_current_task\n- 被调用者: []\n\n9. 函数名: preempt_enable\n- 参数: []\n- 调用者: flush_tlb_current_task\n- 被调用者: []\n\n10. 函数名: mm_cpumask\n- 参数: [mm]\n- 调用者: cpumask_any_but, flush_tlb_others\n- 被调用者: []"
  },
  {
    "id": 918,
    "cwe": "CWE-362",
    "cve": "CVE-2016-2069",
    "purpose": "Code purpose:\"\"\"在多核系统中刷新指定虚拟内存页的TLB条目，确保内存访问一致性\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多CPU环境下缺乏足够的同步机制，导致不同CPU可能同时访问页表结构，产生竞争条件漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: flush_tlb_page\n- 参数: [vma, start]\n- 调用者: N/A\n- 被调用者: [preempt_disable, __flush_tlb_one, leave_mm, smp_processor_id, cpumask_any_but, mm_cpumask, nr_cpu_ids, flush_tlb_others, preempt_enable]\n\n2. 函数名: preempt_disable\n- 参数: []\n- 调用者: flush_tlb_page\n- 被调用者: []\n\n3. 函数名: __flush_tlb_one\n- 参数: [start]\n- 调用者: flush_tlb_page\n- 被调用者: []\n\n4. 函数名: leave_mm\n- 参数: [smp_processor_id()]\n- 调用者: flush_tlb_page\n- 被调用者: []\n\n5. 函数名: smp_processor_id\n- 参数: []\n- 调用者: flush_tlb_page, leave_mm\n- 被调用者: []\n\n6. 函数名: cpumask_any_but\n- 参数: [mm_cpumask(mm), smp_processor_id()]\n- 调用者: flush_tlb_page\n- 被调用者: []\n\n7. 函数名: mm_cpumask\n- 参数: [mm]\n- 调用者: flush_tlb_page, cpumask_any_but\n- 被调用者: []\n\n8. 函数名: flush_tlb_others\n- 参数: [mm_cpumask(mm), mm, start, 0UL]\n- 调用者: flush_tlb_page\n- 被调用者: []\n\n9. 函数名: preempt_enable\n- 参数: []\n- 调用者: flush_tlb_page\n- 被调用者: []"
  },
  {
    "id": 919,
    "cwe": "CWE-362",
    "cve": "CVE-2016-2069",
    "purpose": "Code purpose:\"\"\"该代码用于在多核系统中刷新指定内存地址范围的TLB(Translation Lookaside Buffer)条目，以保持内存一致性。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多CPU环境下缺乏适当的同步机制，导致不同CPU可能同时访问和修改页表结构，从而引发竞争条件漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: flush_tlb_mm_range\n- 参数: [struct mm_struct *mm, unsigned long start, unsigned long end, unsigned long vmflag]\n- 调用者: 未明确（系统调用或其他内核代码）\n- 被调用者: [preempt_disable, leave_mm, count_vm_tlb_event, local_flush_tlb, __flush_tlb_single, trace_tlb_flush, cpumask_any_but, flush_tlb_others, preempt_enable]\n\n2. 函数名: preempt_disable\n- 参数: []\n- 调用者: flush_tlb_mm_range\n- 被调用者: []\n\n3. 函数名: leave_mm\n- 参数: [smp_processor_id()]\n- 调用者: flush_tlb_mm_range\n- 被调用者: []\n\n4. 函数名: count_vm_tlb_event\n- 参数: [NR_TLB_LOCAL_FLUSH_ALL] 或 [NR_TLB_LOCAL_FLUSH_ONE]\n- 调用者: flush_tlb_mm_range\n- 被调用者: []\n\n5. 函数名: local_flush_tlb\n- 参数: []\n- 调用者: flush_tlb_mm_range\n- 被调用者: []\n\n6. 函数名: __flush_tlb_single\n- 参数: [addr]\n- 调用者: flush_tlb_mm_range\n- 被调用者: []\n\n7. 函数名: trace_tlb_flush\n- 参数: [TLB_LOCAL_MM_SHOOTDOWN, base_pages_to_flush]\n- 调用者: flush_tlb_mm_range\n- 被调用者: []\n\n8. 函数名: cpumask_any_but\n- 参数: [mm_cpumask(mm), smp_processor_id()]\n- 调用者: flush_tlb_mm_range\n- 被调用者: []\n\n9. 函数名: flush_tlb_others\n- 参数: [mm_cpumask(mm), mm, start, end]\n- 调用者: flush_tlb_mm_range\n- 被调用者: []\n\n10. 函数名: preempt_enable\n- 参数: []\n- 调用者: flush_tlb_mm_range\n- 被调用者: []\n\n11. 函数名: smp_processor_id\n- 参数: []\n- 调用者: leave_mm, cpumask_any_but\n- 被调用者: []\n\n12. 函数名: mm_cpumask\n- 参数: [mm]\n- 调用者: cpumask_any_but, flush_tlb_others\n- 被调用者: []"
  },
  {
    "id": 934,
    "cwe": "CWE-362",
    "cve": "CVE-2016-2544",
    "purpose": "Code purpose:\"\"\"该代码用于删除音频序列队列并释放相关资源，包括停止定时器、等待访问锁释放、删除优先级队列和定时器，最后释放队列内存。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在queue_delete函数中存在竞态条件，当ioctl调用在释放资源和使用锁同步之间发生时，会导致use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: queue_delete\n- 参数: [struct snd_seq_queue *q]\n- 调用者: 未显示\n- 被调用者: [snd_seq_timer_stop, snd_seq_timer_close, snd_use_lock_sync, snd_seq_prioq_delete, snd_seq_timer_delete, kfree]\n\n2. 函数名: snd_seq_timer_stop\n- 参数: [q->timer]\n- 调用者: queue_delete\n- 被调用者: 未显示\n\n3. 函数名: snd_seq_timer_close\n- 参数: [q]\n- 调用者: queue_delete\n- 被调用者: 未显示\n\n4. 函数名: snd_use_lock_sync\n- 参数: [&q->use_lock]\n- 调用者: queue_delete\n- 被调用者: 未显示\n\n5. 函数名: snd_seq_prioq_delete\n- 参数: [&q->tickq]\n- 调用者: queue_delete\n- 被调用者: 未显示\n\n6. 函数名: snd_seq_prioq_delete\n- 参数: [&q->timeq]\n- 调用者: queue_delete\n- 被调用者: 未显示\n\n7. 函数名: snd_seq_timer_delete\n- 参数: [&q->timer]\n- 调用者: queue_delete\n- 被调用者: 未显示\n\n8. 函数名: kfree\n- 参数: [q]\n- 调用者: queue_delete\n- 被调用者: 未显示"
  },
  {
    "id": 935,
    "cwe": "CWE-362",
    "cve": "CVE-2016-2545",
    "purpose": "Code purpose:\"\"\"处理音频定时器中断事件，管理定时器实例列表并执行相应的回调函数\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在snd_timer_interrupt函数中处理定时器中断时，未能正确维护active_list和ack_list等链表结构，导致在多线程环境下可能发生竞态条件，造成链表损坏或系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_timer_interrupt\n- 参数: [timer, ticks_left]\n- 调用者: 未显示（通常是内核中断处理程序）\n- 被调用者: [snd_timer_reschedule, list_for_each_entry_safe, list_for_each_entry, list_del, list_add_tail, list_empty, list_del_init, tasklet_schedule]\n\n2. 函数名: snd_timer_reschedule\n- 参数: [timer, timer->sticks]\n- 调用者: snd_timer_interrupt\n- 被调用者: 未显示\n\n3. 函数名: list_for_each_entry_safe\n- 参数: [ti, tmp, &timer->active_list_head, active_list]\n- 调用者: snd_timer_interrupt\n- 被调用者: 未显示\n\n4. 函数名: list_for_each_entry\n- 参数: [ts, &ti->slave_active_head, active_list]\n- 调用者: snd_timer_interrupt\n- 被调用者: 未显示\n\n5. 函数名: list_del\n- 参数: [&ti->active_list]\n- 调用者: snd_timer_interrupt\n- 被调用者: 未显示\n\n6. 函数名: list_add_tail\n- 参数: [&ti->ack_list, ack_list_head], [&ts->ack_list, ack_list_head]\n- 调用者: snd_timer_interrupt\n- 被调用者: 未显示\n\n7. 函数名: list_empty\n- 参数: [&ti->ack_list], [&timer->ack_list_head], [&timer->sack_list_head]\n- 调用者: snd_timer_interrupt\n- 被调用者: 未显示\n\n8. 函数名: list_del_init\n- 参数: [p]\n- 调用者: snd_timer_interrupt\n- 被调用者: 未显示\n\n9. 函数名: tasklet_schedule\n- 参数: [&timer->task_queue]\n- 调用者: snd_timer_interrupt\n- 被调用者: 未显示"
  },
  {
    "id": 936,
    "cwe": "CWE-362",
    "cve": "CVE-2016-2546",
    "purpose": "Code purpose:\"\"\"该代码用于处理用户空间对音频定时器的选择请求，包括打开定时器、分配队列内存以及设置回调函数等功能。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"使用了不正确的互斥锁类型导致竞态条件，可能引发释放后使用和系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_timer_user_tselect\n- 参数: [struct file *file, struct snd_timer_select __user *_tselect]\n- 调用者: 未显示（应为ioctl调用）\n- 被调用者: [mutex_lock, snd_timer_close, copy_from_user, sprintf, snd_timer_open, kfree, kmalloc, mutex_unlock]\n\n2. 函数名: mutex_lock\n- 参数: [&tu->tread_sem]\n- 调用者: snd_timer_user_tselect\n- 被调用者: []\n\n3. 函数名: snd_timer_close\n- 参数: [tu->timeri]\n- 调用者: snd_timer_user_tselect\n- 被调用者: []\n\n4. 函数名: copy_from_user\n- 参数: [&tselect, _tselect, sizeof(tselect)]\n- 调用者: snd_timer_user_tselect\n- 被调用者: []\n\n5. 函数名: sprintf\n- 参数: [str, \"application %i\", current->pid]\n- 调用者: snd_timer_user_tselect\n- 被调用者: []\n\n6. 函数名: snd_timer_open\n- 参数: [&tu->timeri, str, &tselect.id, current->pid]\n- 调用者: snd_timer_user_tselect\n- 被调用者: []\n\n7. 函数名: kfree\n- 参数: [tu->queue], [tu->tqueue]\n- 调用者: snd_timer_user_tselect\n- 被调用者: []\n\n8. 函数名: kmalloc\n- 参数: [tu->queue_size * sizeof(struct snd_timer_tread), GFP_KERNEL], [tu->queue_size * sizeof(struct snd_timer_read), GFP_KERNEL]\n- 调用者: snd_timer_user_tselect\n- 被调用者: []\n\n9. 函数名: mutex_unlock\n- 参数: [&tu->tread_sem]\n- 调用者: snd_timer_user_tselect\n- 被调用者: []"
  },
  {
    "id": 937,
    "cwe": "CWE-362",
    "cve": "CVE-2016-2546",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中声音定时器的用户空间ioctl接口，用于处理各种定时器控制命令。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"使用了不正确的互斥锁类型导致竞态条件，可能引发释放后使用和系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_timer_user_ioctl\n- 参数: [struct file *file, unsigned int cmd, unsigned long arg]\n- 调用者: 内核IOCTL处理机制\n- 被调用者: [put_user, snd_timer_user_next_device, mutex_lock, mutex_unlock, get_user, snd_timer_user_ginfo, snd_timer_user_gparams, snd_timer_user_gstatus, snd_timer_user_tselect, snd_timer_user_info, snd_timer_user_params, snd_timer_user_status, snd_timer_user_start, snd_timer_user_stop, snd_timer_user_continue, snd_timer_user_pause]\n\n2. 函数名: snd_timer_user_next_device\n- 参数: [void __user *argp]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []\n\n3. 函数名: snd_timer_user_ginfo\n- 参数: [struct file *file, void __user *argp]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []\n\n4. 函数名: snd_timer_user_gparams\n- 参数: [struct file *file, void __user *argp]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []\n\n5. 函数名: snd_timer_user_gstatus\n- 参数: [struct file *file, void __user *argp]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []\n\n6. 函数名: snd_timer_user_tselect\n- 参数: [struct file *file, void __user *argp]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []\n\n7. 函数名: snd_timer_user_info\n- 参数: [struct file *file, void __user *argp]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []\n\n8. 函数名: snd_timer_user_params\n- 参数: [struct file *file, void __user *argp]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []\n\n9. 函数名: snd_timer_user_status\n- 参数: [struct file *file, void __user *argp]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []\n\n10. 函数名: snd_timer_user_start\n- 参数: [struct file *file]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []\n\n11. 函数名: snd_timer_user_stop\n- 参数: [struct file *file]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []\n\n12. 函数名: snd_timer_user_continue\n- 参数: [struct file *file]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []\n\n13. 函数名: snd_timer_user_pause\n- 参数: [struct file *file]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []"
  },
  {
    "id": 938,
    "cwe": "CWE-362",
    "cve": "CVE-2016-2546",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中声音定时器设备的用户空间打开操作，包括初始化定时器用户数据结构、分配内存和设置相关同步机制。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"使用了不正确的互斥锁类型导致竞态条件，可能引发释放后使用和系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_timer_user_open\n- 参数: [struct inode *inode, struct file *file]\n- 调用者: 未显示（通常由文件操作结构体调用）\n- 被调用者: [nonseekable_open, kzalloc, spin_lock_init, init_waitqueue_head, mutex_init, kmalloc, kfree]\n\n2. 函数名: nonseekable_open\n- 参数: [struct inode *inode, struct file *file]\n- 调用者: snd_timer_user_open\n- 被调用者: []\n\n3. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: snd_timer_user_open\n- 被调用者: []\n\n4. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: snd_timer_user_open\n- 被调用者: []\n\n5. 函数名: init_waitqueue_head\n- 参数: [wait_queue_head_t *q]\n- 调用者: snd_timer_user_open\n- 被调用者: []\n\n6. 函数名: mutex_init\n- 参数: [struct mutex *lock]\n- 调用者: snd_timer_user_open\n- 被调用者: []\n\n7. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: snd_timer_user_open\n- 被调用者: []\n\n8. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: snd_timer_user_open\n- 被调用者: []"
  },
  {
    "id": 939,
    "cwe": "CWE-362",
    "cve": "CVE-2016-2546",
    "purpose": "Code purpose:\"\"\"释放与定时器用户相关的资源，包括关闭定时器并释放分配的内存\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"使用了不正确的互斥锁类型导致竞态条件，可能引发释放后重用和系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_timer_user_release\n- 参数: [struct inode *inode, struct file *file]\n- 调用者: 内核文件操作接口\n- 被调用者: [snd_timer_close, kfree]\n\n2. 函数名: snd_timer_close\n- 参数: [struct snd_timer_instance *timeri]\n- 调用者: snd_timer_user_release\n- 被调用者: []\n\n3. 函数名: kfree\n- 参数: [void *obj]\n- 调用者: snd_timer_user_release\n- 被调用者: []"
  },
  {
    "id": 940,
    "cwe": "CWE-362",
    "cve": "CVE-2016-2547",
    "purpose": "Code purpose:\"\"\"检查并管理主定时器实例与其从属定时器实例之间的关联关系，包括将符合条件的从属定时器移动到主定时器的列表中并更新其状态\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"未考虑从属定时器实例的锁定机制导致竞态条件，可能引发释放后使用和系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_timer_check_master\n- 参数: [struct snd_timer_instance *master]\n- 调用者: 未明确显示（通常是外部调用）\n- 被调用者: [list_for_each_entry_safe, list_move_tail, spin_lock_irq, spin_unlock_irq, list_add_tail]\n\n2. 函数名: list_for_each_entry_safe\n- 参数: [slave, tmp, &snd_timer_slave_list, open_list]\n- 调用者: snd_timer_check_master\n- 被调用者: []\n\n3. 函数名: list_move_tail\n- 参数: [&slave->open_list, &master->slave_list_head]\n- 调用者: snd_timer_check_master\n- 被调用者: []\n\n4. 函数名: spin_lock_irq\n- 参数: [&slave_active_lock]\n- 调用者: snd_timer_check_master\n- 被调用者: []\n\n5. 函数名: spin_unlock_irq\n- 参数: [&slave_active_lock]\n- 调用者: snd_timer_check_master\n- 被调用者: []\n\n6. 函数名: list_add_tail\n- 参数: [&slave->active_list, &master->slave_active_head]\n- 调用者: snd_timer_check_master\n- 被调用者: []"
  },
  {
    "id": 941,
    "cwe": "CWE-362",
    "cve": "CVE-2016-2547",
    "purpose": "Code purpose:\"\"\"启动从属定时器实例并将其添加到主定时器的活动列表中\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"该代码在处理从属定时器实例时未充分考虑竞态条件，导致在锁定机制上存在缺陷，可能引发使用后释放和系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_timer_start_slave\n- 参数: [struct snd_timer_instance *timeri]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [spin_lock_irqsave, spin_unlock_irqrestore, list_add_tail]"
  },
  {
    "id": 942,
    "cwe": "CWE-362",
    "cve": "CVE-2016-2547",
    "purpose": "Code purpose:\"\"\"该代码用于停止一个定时器实例，处理主定时器和从定时器的不同情况，并确保正确的同步和资源释放。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"代码在处理从属定时器实例时未正确考虑锁定机制，导致竞态条件和释放后使用问题\"\"\"",
    "functions": "Functions:\n1. 函数名: _snd_timer_stop\n- 参数: [struct snd_timer_instance *timeri, int keep_flag, int event]\n- 调用者: 未明确显示（通常由外部IOCTL调用）\n- 被调用者: [spin_lock_irqsave, spin_unlock_irqrestore, list_del_init, snd_timer_reschedule, snd_timer_notify1]\n\n2. 函数名: spin_lock_irqsave\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: _snd_timer_stop\n- 被调用者: []\n\n3. 函数名: spin_unlock_irqrestore\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: _snd_timer_stop\n- 被调用者: []\n\n4. 函数名: list_del_init\n- 参数: [struct list_head *entry]\n- 调用者: _snd_timer_stop\n- 被调用者: []\n\n5. 函数名: snd_timer_reschedule\n- 参数: [struct snd_timer *timer, int ticks]\n- 调用者: _snd_timer_stop\n- 被调用者: []\n\n6. 函数名: snd_timer_notify1\n- 参数: [struct snd_timer_instance *timeri, int event]\n- 调用者: _snd_timer_stop\n- 被调用者: []\n\n7. 函数名: timer->hw.stop\n- 参数: [struct snd_timer *timer]\n- 调用者: _snd_timer_stop\n- 被调用者: []\n\n8. 函数名: timer->hw.start\n- 参数: [struct snd_timer *timer]\n- 调用者: _snd_timer_stop\n- 被调用者: []"
  },
  {
    "id": 943,
    "cwe": "CWE-362",
    "cve": "CVE-2016-2547",
    "purpose": "Code purpose:\"\"\"该代码用于处理Linux内核中声音定时器的关闭操作，包括主定时器和从定时器的资源释放和同步处理。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理从属定时器实例时，代码未正确考虑并发情况下的锁保护机制，导致竞态条件和释放后使用漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_timer_close\n- 参数: [struct snd_timer_instance *timeri]\n- 调用者: 未明确（通常是外部调用）\n- 被调用者: [snd_BUG_ON, snd_timer_stop, spin_lock_irq, spin_unlock_irq, udelay, mutex_lock, list_del, mutex_unlock, _snd_timer_stop, list_move_tail, list_for_each_entry_safe, module_put, kfree]\n\n2. 函数名: snd_BUG_ON\n- 参数: [condition]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n3. 函数名: snd_timer_stop\n- 参数: [struct snd_timer_instance *timeri]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n4. 函数名: spin_lock_irq\n- 参数: [spinlock_t *lock]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n5. 函数名: spin_unlock_irq\n- 参数: [spinlock_t *lock]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n6. 函数名: udelay\n- 参数: [unsigned long usecs]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n7. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n8. 函数名: list_del\n- 参数: [struct list_head *entry]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n9. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n10. 函数名: _snd_timer_stop\n- 参数: [struct snd_timer_instance *timeri, int event, int resolution]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n11. 函数名: list_move_tail\n- 参数: [struct list_head *list, struct list_head *head]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n12. 函数名: list_for_each_entry_safe\n- 参数: [pos, n, head, member]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n13. 函数名: module_put\n- 参数: [struct module *module]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n14. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: snd_timer_close\n- 被调用者: []"
  },
  {
    "id": 1051,
    "cwe": "CWE-362",
    "cve": "CVE-2016-5195",
    "purpose": "Code purpose:\"\"\"处理内存页错误，包括处理写时复制(COW)情况，并返回相应的错误码或状态\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理写时复制(COW)时存在竞态条件，允许本地用户通过利用对只读内存映射的错误处理来提升权限。\"\"\"",
    "functions": "Functions:\n1. 函数名: faultin_page\n- 参数: [struct task_struct *tsk, struct vm_area_struct *vma, unsigned long address, unsigned int *flags, int *nonblocking]\n- 调用者: 未明确（通常是内核中处理内存页错误的调用链）\n- 被调用者: [handle_mm_fault, stack_guard_page_start, stack_guard_page_end]\n\n2. 函数名: handle_mm_fault\n- 参数: [struct vm_area_struct *vma, unsigned long address, unsigned int fault_flags]\n- 调用者: faultin_page\n- 被调用者: 未明确（内核内存管理相关函数）\n\n3. 函数名: stack_guard_page_start\n- 参数: [struct vm_area_struct *vma, unsigned long address]\n- 调用者: faultin_page\n- 被调用者: 未明确\n\n4. 函数名: stack_guard_page_end\n- 参数: [struct vm_area_struct *vma, unsigned long address]\n- 调用者: faultin_page\n- 被调用者: 未明确"
  },
  {
    "id": 1052,
    "cwe": "CWE-362",
    "cve": "CVE-2016-5195",
    "purpose": "Code purpose:\"\"\"该代码用于处理虚拟内存区域中的页表项跟踪和页面获取操作，包括处理写时复制(COW)场景、页面迁移和设备映射等特殊情况。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理写时复制(COW)时存在竞态条件，允许本地用户通过利用对只读内存映射的错误处理来提升权限\"\"\"",
    "functions": "Functions:\n1. 函数名: follow_page_pte\n- 参数: [vma, address, pmd, flags]\n- 调用者: N/A\n- 被调用者: [pmd_bad, no_page_table, pte_offset_map_lock, pte_present, pte_none, pte_to_swp_entry, is_migration_entry, pte_unmap_unlock, migration_entry_wait, pte_write, vm_normal_page, pte_devmap, get_dev_pagemap, pte_page, follow_pfn_pte, PageTransCompound, get_page, split_huge_page, put_page, put_dev_pagemap, pte_dirty, PageDirty, set_page_dirty, mark_page_accessed, trylock_page, lru_add_drain, mlock_vma_page, unlock_page]\n\n2. 函数名: pmd_bad\n- 参数: [pmd]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n3. 函数名: no_page_table\n- 参数: [vma, flags]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n4. 函数名: pte_offset_map_lock\n- 参数: [mm, pmd, address, ptl]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n5. 函数名: pte_present\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n6. 函数名: pte_none\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n7. 函数名: pte_to_swp_entry\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n8. 函数名: is_migration_entry\n- 参数: [entry]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n9. 函数名: pte_unmap_unlock\n- 参数: [ptep, ptl]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n10. 函数名: migration_entry_wait\n- 参数: [mm, pmd, address]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n11. 函数名: pte_write\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n12. 函数名: vm_normal_page\n- 参数: [vma, address, pte]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n13. 函数名: pte_devmap\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n14. 函数名: get_dev_pagemap\n- 参数: [pte_pfn(pte), NULL]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n15. 函数名: pte_page\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n16. 函数名: follow_pfn_pte\n- 参数: [vma, address, ptep, flags]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n17. 函数名: PageTransCompound\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n18. 函数名: get_page\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n19. 函数名: split_huge_page\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n20. 函数名: put_page\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n21. 函数名: put_dev_pagemap\n- 参数: [pgmap]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n22. 函数名: pte_dirty\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n23. 函数名: PageDirty\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n24. 函数名: set_page_dirty\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n25. 函数名: mark_page_accessed\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n26. 函数名: trylock_page\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n27. 函数名: lru_add_drain\n- 参数: []\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n28. 函数名: mlock_vma_page\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n29. 函数名: unlock_page\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: N/A"
  },
  {
    "id": 1059,
    "cwe": "CWE-362",
    "cve": "CVE-2016-6130",
    "purpose": "Code purpose:\"\"\"该代码用于通过ioctl系统调用处理用户空间传递的SCCB(系统控制块)数据，包括验证、拷贝和执行相关命令，并将结果返回用户空间。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在验证sccb长度后未锁定内存，导致攻击者可以在两次fetch之间修改长度值，造成内核信息泄露的双取漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: sclp_ctl_ioctl_sccb\n- 参数: [void __user *user_area]\n- 调用者: 未显示（由系统调用触发）\n- 被调用者: [copy_from_user, sclp_ctl_cmdw_supported, get_zeroed_page, u64_to_uptr, sclp_sync_request, copy_to_user, free_page]\n\n2. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: sclp_ctl_ioctl_sccb\n- 被调用者: []\n\n3. 函数名: sclp_ctl_cmdw_supported\n- 参数: [unsigned int cmdw]\n- 调用者: sclp_ctl_ioctl_sccb\n- 被调用者: []\n\n4. 函数名: get_zeroed_page\n- 参数: [gfp_t gfp_mask]\n- 调用者: sclp_ctl_ioctl_sccb\n- 被调用者: []\n\n5. 函数名: u64_to_uptr\n- 参数: [u64 x]\n- 调用者: sclp_ctl_ioctl_sccb\n- 被调用者: []\n\n6. 函数名: sclp_sync_request\n- 参数: [unsigned int cmdw, struct sccb_header *sccb]\n- 调用者: sclp_ctl_ioctl_sccb\n- 被调用者: []\n\n7. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: sclp_ctl_ioctl_sccb\n- 被调用者: []\n\n8. 函数名: free_page\n- 参数: [unsigned long addr]\n- 调用者: sclp_ctl_ioctl_sccb\n- 被调用者: []"
  },
  {
    "id": 1060,
    "cwe": "CWE-362",
    "cve": "CVE-2016-6136",
    "purpose": "Code purpose:\"\"\"记录执行execve系统调用时的参数信息用于审计\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在audit_log_execve_info函数中存在竞态条件，用户可以在内核两次获取字符串之间修改字符串内容，导致绕过字符集限制或破坏系统调用审计\"\"\"",
    "functions": "Functions:\n1. 函数名: audit_log_execve_info\n- 参数: [struct audit_context *context, struct audit_buffer **ab]\n- 调用者: 未显示\n- 被调用者: [audit_log_format, kmalloc, audit_panic, audit_log_single_execve_arg, kfree]\n\n2. 函数名: audit_log_format\n- 参数: [struct audit_buffer **ab, const char *fmt, ...]\n- 调用者: audit_log_execve_info\n- 被调用者: 未显示\n\n3. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: audit_log_execve_info\n- 被调用者: 未显示\n\n4. 函数名: audit_panic\n- 参数: [const char *message]\n- 调用者: audit_log_execve_info\n- 被调用者: 未显示\n\n5. 函数名: audit_log_single_execve_arg\n- 参数: [struct audit_context *context, struct audit_buffer **ab, int i, size_t *len_sent, const char __user *p, char *buf]\n- 调用者: audit_log_execve_info\n- 被调用者: 未显示\n\n6. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: audit_log_execve_info\n- 被调用者: 未显示"
  },
  {
    "id": 1061,
    "cwe": "CWE-362",
    "cve": "CVE-2016-6156",
    "purpose": "Code purpose:\"\"\"该代码实现了通过ioctl接口与Chrome OS嵌入式控制器(EC)进行命令交互的功能，包括从用户空间获取命令、执行命令并将结果返回给用户空间。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在检查用户空间数据大小后未保持数据一致性，导致竞争条件下可修改大小值造成越界访问\"\"\"",
    "functions": "Functions:\n1. 函数名: ec_device_ioctl_xcmd\n- 参数: [struct cros_ec_dev *ec, void __user *arg]\n- 调用者: 未明确（应为ioctl处理函数）\n- 被调用者: [copy_from_user, kmalloc, cros_ec_cmd_xfer, copy_to_user, kfree]\n\n2. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: ec_device_ioctl_xcmd\n- 被调用者: []\n\n3. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: ec_device_ioctl_xcmd\n- 被调用者: []\n\n4. 函数名: cros_ec_cmd_xfer\n- 参数: [struct cros_ec_dev *ec, struct cros_ec_command *cmd]\n- 调用者: ec_device_ioctl_xcmd\n- 被调用者: []\n\n5. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: ec_device_ioctl_xcmd\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: ec_device_ioctl_xcmd\n- 被调用者: []"
  },
  {
    "id": 1076,
    "cwe": "CWE-362",
    "cve": "CVE-2016-6480",
    "purpose": "Code purpose:\"\"\"该代码实现了通过ioctl接口发送FIB(光纤接口块)到AACRAID设备的功能，包括内存分配、数据拷贝和命令处理等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在检查用户提供的size值和后续使用该值之间存在竞争条件，攻击者可以在检查后修改size值，导致越界访问或系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: ioctl_send_fib\n- 参数: [struct aac_dev * dev, void __user *arg]\n- 调用者: 未指定（由外部调用）\n- 被调用者: [aac_fib_alloc, copy_from_user, aac_fib_free, le16_to_cpu, pci_alloc_consistent, memset, memcpy, aac_adapter_interrupt, cpu_to_le16, aac_fib_send, aac_fib_complete, copy_to_user, pci_free_consistent]\n\n2. 函数名: aac_fib_alloc\n- 参数: [struct aac_dev * dev]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n3. 函数名: copy_from_user\n- 参数: [void *kfib, void __user *arg, sizeof(struct aac_fibhdr)]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n4. 函数名: aac_fib_free\n- 参数: [struct fib *fibptr]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n5. 函数名: le16_to_cpu\n- 参数: [kfib->header.Size, kfib->header.SenderSize]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n6. 函数名: pci_alloc_consistent\n- 参数: [dev->pdev, size, &daddr]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n7. 函数名: memset\n- 参数: [((char *)kfib) + dev->max_fib_size, 0, size - dev->max_fib_size]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n8. 函数名: memcpy\n- 参数: [kfib, hw_fib, dev->max_fib_size]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n9. 函数名: aac_adapter_interrupt\n- 参数: [dev]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n10. 函数名: cpu_to_le16\n- 参数: [TakeABreakPt, kfib->header.Command]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n11. 函数名: aac_fib_send\n- 参数: [le16_to_cpu(kfib->header.Command), fibptr, le16_to_cpu(kfib->header.Size), FsaNormal, 1, 1, NULL, NULL]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n12. 函数名: aac_fib_complete\n- 参数: [fibptr]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n13. 函数名: copy_to_user\n- 参数: [arg, (void *)kfib, size]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n14. 函数名: pci_free_consistent\n- 参数: [dev->pdev, size, kfib, fibptr->hw_fib_pa]\n- 调用者: ioctl_send_fib\n- 被调用者: []"
  },
  {
    "id": 1077,
    "cwe": "CWE-362",
    "cve": "CVE-2016-6516",
    "purpose": "Code purpose:\"\"\"该代码实现了通过ioctl系统调用进行文件去重范围操作的功能，包括从用户空间获取参数、分配内存、执行去重操作并将结果返回用户空间。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在获取用户空间参数count后未进行同步验证，导致在后续操作中可能因竞争条件而使用被修改的count值，造成堆缓冲区溢出。\"\"\"",
    "functions": "Functions:\n1. 函数名: ioctl_file_dedupe_range\n- 参数: [struct file *file, void __user *arg]\n- 调用者: 未指定（由内核IOCTL调用）\n- 被调用者: [get_user, memdup_user, vfs_dedupe_file_range, copy_to_user, kfree]\n\n2. 函数名: get_user\n- 参数: [u16 count, &argp->dest_count]\n- 调用者: ioctl_file_dedupe_range\n- 被调用者: []\n\n3. 函数名: memdup_user\n- 参数: [argp, size]\n- 调用者: ioctl_file_dedupe_range\n- 被调用者: []\n\n4. 函数名: vfs_dedupe_file_range\n- 参数: [file, same]\n- 调用者: ioctl_file_dedupe_range\n- 被调用者: []\n\n5. 函数名: copy_to_user\n- 参数: [argp, same, size]\n- 调用者: ioctl_file_dedupe_range\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [same]\n- 调用者: ioctl_file_dedupe_range\n- 被调用者: []"
  },
  {
    "id": 1110,
    "cwe": "CWE-362",
    "cve": "CVE-2016-7911",
    "purpose": "Code purpose:\"\"\"获取指定任务的I/O优先级值，包括安全检查并返回默认或任务特定的I/O优先级\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺乏适当的同步机制，在检查p->io_context和使用p->io_context->ioprio之间存在竞态条件，可能导致use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: get_task_ioprio\n- 参数: [struct task_struct *p]\n- 调用者: 未明确显示（由系统调用ioprio_get触发）\n- 被调用者: [security_task_getioprio, IOPRIO_PRIO_VALUE]\n\n2. 函数名: security_task_getioprio\n- 参数: [struct task_struct *p]\n- 调用者: get_task_ioprio\n- 被调用者: []\n\n3. 函数名: IOPRIO_PRIO_VALUE\n- 参数: [IOPRIO_CLASS_NONE, IOPRIO_NORM]\n- 调用者: get_task_ioprio\n- 被调用者: []"
  },
  {
    "id": 1114,
    "cwe": "CWE-362",
    "cve": "CVE-2016-7916",
    "purpose": "Code purpose:\"\"\"该代码用于读取进程的环境变量信息并通过/proc文件系统提供给用户空间，存在竞争条件漏洞可能导致内核敏感信息泄露\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在进程设置期间，环境变量复制未完成时，environ_read函数存在竞态条件，导致本地用户可能通过读取/proc/*/environ文件获取内核内存中的敏感信息。\"\"\"",
    "functions": "Functions:\n1. 函数名: environ_read\n- 参数: [struct file *file, char __user *buf, size_t count, loff_t *ppos]\n- 调用者: 未显示（由文件系统调用触发）\n- 被调用者: [__get_free_page, atomic_inc_not_zero, down_read, up_read, access_remote_vm, copy_to_user, mmput, free_page]\n\n2. 函数名: __get_free_page\n- 参数: [GFP_TEMPORARY]\n- 调用者: environ_read\n- 被调用者: []\n\n3. 函数名: atomic_inc_not_zero\n- 参数: [&mm->mm_users]\n- 调用者: environ_read\n- 被调用者: []\n\n4. 函数名: down_read\n- 参数: [&mm->mmap_sem]\n- 调用者: environ_read\n- 被调用者: []\n\n5. 函数名: up_read\n- 参数: [&mm->mmap_sem]\n- 调用者: environ_read\n- 被调用者: []\n\n6. 函数名: access_remote_vm\n- 参数: [mm, (env_start + src), page, this_len, 0]\n- 调用者: environ_read\n- 被调用者: []\n\n7. 函数名: copy_to_user\n- 参数: [buf, page, retval]\n- 调用者: environ_read\n- 被调用者: []\n\n8. 函数名: mmput\n- 参数: [mm]\n- 调用者: environ_read\n- 被调用者: []\n\n9. 函数名: free_page\n- 参数: [(unsigned long) page]\n- 调用者: environ_read\n- 被调用者: []"
  },
  {
    "id": 1131,
    "cwe": "CWE-362",
    "cve": "CVE-2016-8655",
    "purpose": "Code purpose:\"\"\"该代码用于设置和管理Linux内核中AF_PACKET套接字的环形缓冲区，处理数据包的接收和发送环形缓冲区的配置和切换操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在修改socket版本时存在竞态条件，导致在packet_set_ring和packet_setsockopt函数之间可能发生use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: packet_set_ring\n- 参数: [struct sock *sk, union tpacket_req_u *req_u, int closing, int tx_ring]\n- 调用者: N/A (系统调用或内核其他部分)\n- 被调用者: [packet_read_pending, alloc_pg_vec, init_prb_bdqc, lock_sock, __unregister_prot_hook, synchronize_net, mutex_lock, spin_lock_bh, spin_unlock_bh, mutex_unlock, register_prot_hook, release_sock, free_pg_vec, prb_shutdown_retire_blk_timer, skb_queue_purge]\n\n2. 函数名: packet_read_pending\n- 参数: [struct packet_ring_buffer *rb]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n3. 函数名: alloc_pg_vec\n- 参数: [struct tpacket_req *req, int order]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n4. 函数名: init_prb_bdqc\n- 参数: [struct packet_sock *po, struct packet_ring_buffer *rb, struct pgv *pg_vec, union tpacket_req_u *req_u]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n5. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n6. 函数名: __unregister_prot_hook\n- 参数: [struct sock *sk, bool sync]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n7. 函数名: synchronize_net\n- 参数: []\n- 调用者: packet_set_ring\n- 被调用者: []\n\n8. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n9. 函数名: spin_lock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n10. 函数名: spin_unlock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n11. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n12. 函数名: register_prot_hook\n- 参数: [struct sock *sk]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n13. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n14. 函数名: free_pg_vec\n- 参数: [struct pgv *pg_vec, int order, int tp_block_nr]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n15. 函数名: prb_shutdown_retire_blk_timer\n- 参数: [struct packet_sock *po, struct sk_buff_head *rb_queue]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n16. 函数名: skb_queue_purge\n- 参数: [struct sk_buff_head *list]\n- 调用者: packet_set_ring\n- 被调用者: []"
  },
  {
    "id": 1132,
    "cwe": "CWE-362",
    "cve": "CVE-2016-8655",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中AF_PACKET套接字的选项设置功能，包括成员管理、环形缓冲区配置、版本控制等网络包处理相关操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中的packet_setsockopt函数存在竞态条件漏洞，当本地用户利用CAP_NET_RAW能力更改socket版本时，可能导致use-after-free问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: packet_setsockopt\n- 参数: [struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen]\n- 调用者: 未显示（系统调用）\n- 被调用者: [pkt_sk, memset, copy_from_user, packet_mc_add, packet_mc_drop, packet_set_ring, fanout_add, fanout_set_data]\n\n2. 函数名: pkt_sk\n- 参数: [struct sock *sk]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n3. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n4. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n5. 函数名: packet_mc_add\n- 参数: [struct sock *sk, struct packet_mreq_max *mreq]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n6. 函数名: packet_mc_drop\n- 参数: [struct sock *sk, struct packet_mreq_max *mreq]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n7. 函数名: packet_set_ring\n- 参数: [struct sock *sk, union tpacket_req_u *req_u, int closing, int tx_ring]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n8. 函数名: fanout_add\n- 参数: [struct sock *sk, int val, int val_high]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n9. 函数名: fanout_set_data\n- 参数: [struct packet_sock *po, char __user *optval, unsigned int optlen]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示"
  },
  {
    "id": 1168,
    "cwe": "CWE-362",
    "cve": "CVE-2016-9794",
    "purpose": "Code purpose:\"\"\"该代码用于处理音频PCM子流周期中断事件，更新硬件指针状态并触发定时器中断，同时通知异步I/O事件\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于snd_pcm_period_elapsed函数中存在竞态条件，当处理SNDRV_PCM_TRIGGER_START命令时可能导致use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_pcm_period_elapsed\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: 未显示\n- 被调用者: [PCM_RUNTIME_CHECK, snd_pcm_stream_lock_irqsave, snd_pcm_running, snd_pcm_update_hw_ptr0, snd_timer_interrupt, snd_pcm_stream_unlock_irqrestore, kill_fasync]\n\n2. 函数名: PCM_RUNTIME_CHECK\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n3. 函数名: snd_pcm_stream_lock_irqsave\n- 参数: [struct snd_pcm_substream *substream, unsigned long flags]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n4. 函数名: snd_pcm_running\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n5. 函数名: snd_pcm_update_hw_ptr0\n- 参数: [struct snd_pcm_substream *substream, int in_interrupt]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n6. 函数名: snd_timer_interrupt\n- 参数: [struct snd_timer *timer, int ticks]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n7. 函数名: snd_pcm_stream_unlock_irqrestore\n- 参数: [struct snd_pcm_substream *substream, unsigned long flags]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n8. 函数名: kill_fasync\n- 参数: [struct fasync_struct **fp, int sig, int band]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []"
  },
  {
    "id": 1169,
    "cwe": "CWE-362",
    "cve": "CVE-2016-9806",
    "purpose": "Code purpose:\"\"\"该代码用于处理netlink套接字的数据转储(dump)操作，包括分配缓冲区、执行转储回调、发送结果等，但存在竞争条件可能导致双重释放漏洞。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于netlink_dump函数中存在竞态条件，当新的dump操作过早开始时会导致双重释放问题\"\"\"",
    "functions": "Functions:\n1. 函数名: netlink_dump\n- 参数: [struct sock *sk]\n- 调用者: 未明确显示（应为内核中调用netlink_dump的代码）\n- 被调用者: [nlk_sk, mutex_lock, atomic_read, max_t, alloc_skb, skb_reserve, skb_tailroom, netlink_skb_set_owner_r, cb->dump, mutex_unlock, sk_filter, kfree_skb, __netlink_sendskb, nlmsg_put_answer, nl_dump_check_consistent, nlmsg_data, memcpy, cb->done, module_put, consume_skb]\n\n2. 函数名: nlk_sk\n- 参数: [struct sock *sk]\n- 调用者: netlink_dump\n- 被调用者: []\n\n3. 函数名: mutex_lock\n- 参数: [nlk->cb_mutex]\n- 调用者: netlink_dump\n- 被调用者: []\n\n4. 函数名: atomic_read\n- 参数: [&sk->sk_rmem_alloc]\n- 调用者: netlink_dump\n- 被调用者: []\n\n5. 函数名: max_t\n- 参数: [int, cb->min_dump_alloc, NLMSG_GOODSIZE]\n- 调用者: netlink_dump\n- 被调用者: []\n\n6. 函数名: alloc_skb\n- 参数: [alloc_size, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY], [alloc_size, GFP_KERNEL]\n- 调用者: netlink_dump\n- 被调用者: []\n\n7. 函数名: skb_reserve\n- 参数: [skb, skb_tailroom(skb) - alloc_size]\n- 调用者: netlink_dump\n- 被调用者: []\n\n8. 函数名: skb_tailroom\n- 参数: [skb]\n- 调用者: netlink_dump\n- 被调用者: []\n\n9. 函数名: netlink_skb_set_owner_r\n- 参数: [skb, sk]\n- 调用者: netlink_dump\n- 被调用者: []\n\n10. 函数名: cb->dump\n- 参数: [skb, cb]\n- 调用者: netlink_dump\n- 被调用者: []\n\n11. 函数名: mutex_unlock\n- 参数: [nlk->cb_mutex]\n- 调用者: netlink_dump\n- 被调用者: []\n\n12. 函数名: sk_filter\n- 参数: [sk, skb]\n- 调用者: netlink_dump\n- 被调用者: []\n\n13. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: netlink_dump\n- 被调用者: []\n\n14. 函数名: __netlink_sendskb\n- 参数: [sk, skb]\n- 调用者: netlink_dump\n- 被调用者: []\n\n15. 函数名: nlmsg_put_answer\n- 参数: [skb, cb, NLMSG_DONE, sizeof(len), NLM_F_MULTI]\n- 调用者: netlink_dump\n- 被调用者: []\n\n16. 函数名: nl_dump_check_consistent\n- 参数: [cb, nlh]\n- 调用者: netlink_dump\n- 被调用者: []\n\n17. 函数名: nlmsg_data\n- 参数: [nlh]\n- 调用者: netlink_dump\n- 被调用者: []\n\n18. 函数名: memcpy\n- 参数: [nlmsg_data(nlh), &len, sizeof(len)]\n- 调用者: netlink_dump\n- 被调用者: []\n\n19. 函数名: cb->done\n- 参数: [cb]\n- 调用者: netlink_dump\n- 被调用者: []\n\n20. 函数名: module_put\n- 参数: [cb->module]\n- 调用者: netlink_dump\n- 被调用者: []\n\n21. 函数名: consume_skb\n- 参数: [cb->skb]\n- 调用者: netlink_dump\n- 被调用者: []"
  },
  {
    "id": 1181,
    "cwe": "CWE-362",
    "cve": "CVE-2017-1000112",
    "purpose": "Code purpose:\"\"\"该代码用于处理IP数据包的构建和分段，支持UFO(Unfragmented Offload)和非UFO路径的数据追加，确保数据在网络传输中正确分片和重组。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在UFO到非UFO路径切换时，由于负值计算导致内存越界写入\"\"\"",
    "functions": "Functions:\n1. 函数名: __ip_append_data\n- 参数: [sk, fl4, queue, cork, pfrag, getfrag, from, length, transhdrlen, flags]\n- 调用者: 未显示\n- 被调用者: [inet_sk, skb_peek_tail, ip_local_error, ip_ufo_append_data, sock_alloc_send_skb, refcount_read, sock_wmalloc, skb_reserve, skb_shinfo, skb_put, skb_set_network_header, skb_copy_and_csum_bits, csum_sub, pskb_trim_unique, getfrag, kfree_skb, __skb_queue_tail, skb_put, sk_page_frag_refill, skb_can_coalesce, __skb_fill_page_desc, get_page, page_address, skb_frag_size_add, refcount_add, IP_INC_STATS]\n\n2. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n3. 函数名: skb_peek_tail\n- 参数: [queue]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n4. 函数名: ip_local_error\n- 参数: [sk, EMSGSIZE, fl4->daddr, inet->inet_dport, mtu - (opt ? opt->optlen : 0)]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n5. 函数名: ip_ufo_append_data\n- 参数: [sk, queue, getfrag, from, length, hh_len, fragheaderlen, transhdrlen, maxfraglen, flags]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n6. 函数名: sock_alloc_send_skb\n- 参数: [sk, alloclen + hh_len + 15, (flags & MSG_DONTWAIT), &err]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n7. 函数名: refcount_read\n- 参数: [&sk->sk_wmem_alloc]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n8. 函数名: sock_wmalloc\n- 参数: [sk, alloclen + hh_len + 15, 1, sk->sk_allocation]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n9. 函数名: skb_reserve\n- 参数: [skb, hh_len]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n10. 函数名: skb_shinfo\n- 参数: [skb]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n11. 函数名: skb_put\n- 参数: [skb, fraglen + exthdrlen]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n12. 函数名: skb_set_network_header\n- 参数: [skb, exthdrlen]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n13. 函数名: skb_copy_and_csum_bits\n- 参数: [skb_prev, maxfraglen, data + transhdrlen, fraggap, 0]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n14. 函数名: csum_sub\n- 参数: [skb_prev->csum, skb->csum]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n15. 函数名: pskb_trim_unique\n- 参数: [skb_prev, maxfraglen]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n16. 函数名: getfrag\n- 参数: [from, data + transhdrlen, offset, copy, fraggap, skb]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n17. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n18. 函数名: __skb_queue_tail\n- 参数: [queue, skb]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n19. 函数名: sk_page_frag_refill\n- 参数: [sk, pfrag]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n20. 函数名: skb_can_coalesce\n- 参数: [skb, i, pfrag->page, pfrag->offset]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n21. 函数名: __skb_fill_page_desc\n- 参数: [skb, i, pfrag->page, pfrag->offset, 0]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n22. 函数名: get_page\n- 参数: [pfrag->page]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n23. 函数名: page_address\n- 参数: [pfrag->page]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n24. 函数名: skb_frag_size_add\n- 参数: [&skb_shinfo(skb)->frags[i - 1], copy]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n25. 函数名: refcount_add\n- 参数: [copy, &sk->sk_wmem_alloc]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n26. 函数名: IP_INC_STATS\n- 参数: [sock_net(sk), IPSTATS_MIB_OUTDISCARDS]\n- 调用者: __ip_append_data\n- 被调用者: 未显示"
  },
  {
    "id": 1182,
    "cwe": "CWE-362",
    "cve": "CVE-2017-1000112",
    "purpose": "Code purpose:\"\"\"处理IP数据包的分片和组装，支持UFO(Unfragmented Offload)和非UFO路径的数据追加\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当UFO路径切换到非UFO路径时，由于数据包长度计算错误导致负值，进而引发内存越界写入\"\"\"",
    "functions": "Functions:\n1. 函数名: ip_append_page\n- 参数: [sk, fl4, page, offset, size, flags]\n- 调用者: N/A\n- 被调用者: [inet_sk, ip_sk_ignore_df, ip_local_error, skb_peek_tail, skb_shinfo, skb_is_gso, sock_wmalloc, skb_copy_and_csum_bits, csum_sub, pskb_trim_unique, __skb_queue_tail, skb_append_pagefrags, csum_page, csum_block_add, sock_net, IP_INC_STATS]\n\n2. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n3. 函数名: ip_sk_ignore_df\n- 参数: [sk]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n4. 函数名: ip_local_error\n- 参数: [sk, EMSGSIZE, fl4->daddr, inet->inet_dport, mtu - (opt ? opt->optlen : 0)]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n5. 函数名: skb_peek_tail\n- 参数: [&sk->sk_write_queue]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n6. 函数名: skb_shinfo\n- 参数: [skb]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n7. 函数名: skb_is_gso\n- 参数: [skb]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n8. 函数名: sock_wmalloc\n- 参数: [sk, alloclen, 1, sk->sk_allocation]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n9. 函数名: skb_copy_and_csum_bits\n- 参数: [skb_prev, maxfraglen, skb_transport_header(skb), fraggap, 0]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n10. 函数名: csum_sub\n- 参数: [skb_prev->csum, skb->csum]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n11. 函数名: pskb_trim_unique\n- 参数: [skb_prev, maxfraglen]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n12. 函数名: __skb_queue_tail\n- 参数: [&sk->sk_write_queue, skb]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n13. 函数名: skb_append_pagefrags\n- 参数: [skb, page, offset, len]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n14. 函数名: csum_page\n- 参数: [page, offset, len]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n15. 函数名: csum_block_add\n- 参数: [skb->csum, csum, skb->len]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n16. 函数名: sock_net\n- 参数: [sk]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n17. 函数名: IP_INC_STATS\n- 参数: [sock_net(sk), IPSTATS_MIB_OUTDISCARDS]\n- 调用者: ip_append_page\n- 被调用者: N/A"
  },
  {
    "id": 1183,
    "cwe": "CWE-362",
    "cve": "CVE-2017-1000112",
    "purpose": "Code purpose:\"\"\"该代码实现了UDP数据包的构建和发送功能，包括UDP头部的创建、校验和计算以及通过IP层发送数据包\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于UFO到非UFO路径切换时未正确处理数据包长度，导致负值计算引发内存越界写入\"\"\"",
    "functions": "Functions:\n1. 函数名: udp_send_skb\n- 参数: [skb, fl4]\n- 调用者: 未明确（应为上层UDP发送函数）\n- 被调用者: [udp_hdr, htons, udplite_csum, udp4_hwcsum, udp_csum, csum_tcpudp_magic, ip_send_skb, sock_net, UDP_INC_STATS]\n\n2. 函数名: udp_hdr\n- 参数: [skb]\n- 调用者: udp_send_skb\n- 被调用者: []\n\n3. 函数名: htons\n- 参数: [len]\n- 调用者: udp_send_skb\n- 被调用者: []\n\n4. 函数名: udplite_csum\n- 参数: [skb]\n- 调用者: udp_send_skb\n- 被调用者: []\n\n5. 函数名: udp4_hwcsum\n- 参数: [skb, fl4->saddr, fl4->daddr]\n- 调用者: udp_send_skb\n- 被调用者: []\n\n6. 函数名: udp_csum\n- 参数: [skb]\n- 调用者: udp_send_skb\n- 被调用者: []\n\n7. 函数名: csum_tcpudp_magic\n- 参数: [fl4->saddr, fl4->daddr, len, sk->sk_protocol, csum]\n- 调用者: udp_send_skb\n- 被调用者: []\n\n8. 函数名: ip_send_skb\n- 参数: [sock_net(sk), skb]\n- 调用者: udp_send_skb\n- 被调用者: []\n\n9. 函数名: sock_net\n- 参数: [sk]\n- 调用者: udp_send_skb\n- 被调用者: []\n\n10. 函数名: UDP_INC_STATS\n- 参数: [sock_net(sk), UDP_MIB_SNDBUFERRORS/UDP_MIB_OUTDATAGRAMS, is_udplite]\n- 调用者: udp_send_skb\n- 被调用者: []"
  },
  {
    "id": 1184,
    "cwe": "CWE-362",
    "cve": "CVE-2017-1000112",
    "purpose": "Code purpose:\"\"\"处理IPv6数据包的构建和分片，包括UFO(Unfragmentable Option)路径和非UFO路径的数据追加和内存管理\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当UFO路径切换到非UFO路径时，由于数据包长度超过MTU导致负值计算，进而引发内存越界写入\"\"\"",
    "functions": "Functions:\n1. 函数名: __ip6_append_data\n- 参数: [sk, fl6, queue, cork, v6_cork, pfrag, getfrag, from, length, transhdrlen, flags, ipc6, sockc]\n- 调用者: 未显示（由内核网络栈调用）\n- 被调用者: [ipv6_local_rxpmtu, ipv6_local_error, sock_tx_timestamp, ip6_ufo_append_data, ip6_append_data_mtu, sock_alloc_send_skb, sock_wmalloc, skb_copy_and_csum_bits, pskb_trim_unique, __skb_queue_tail, sk_page_frag_refill, skb_can_coalesce, __skb_fill_page_desc]\n\n2. 函数名: ipv6_local_rxpmtu\n- 参数: [sk, fl6, mtu]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n3. 函数名: ipv6_local_error\n- 参数: [sk, EMSGSIZE, fl6, mtu]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n4. 函数名: sock_tx_timestamp\n- 参数: [sk, sockc->tsflags, &tx_flags]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n5. 函数名: ip6_ufo_append_data\n- 参数: [sk, queue, getfrag, from, length, hh_len, fragheaderlen, exthdrlen, transhdrlen, mtu, flags, fl6]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n6. 函数名: ip6_append_data_mtu\n- 参数: [&mtu, &maxfraglen, fragheaderlen, skb, rt, orig_mtu]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n7. 函数名: sock_alloc_send_skb\n- 参数: [sk, alloclen + hh_len, (flags & MSG_DONTWAIT), &err]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n8. 函数名: sock_wmalloc\n- 参数: [sk, alloclen + hh_len, 1, sk->sk_allocation]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n9. 函数名: skb_copy_and_csum_bits\n- 参数: [skb_prev, maxfraglen, data + transhdrlen, fraggap, 0]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n10. 函数名: pskb_trim_unique\n- 参数: [skb_prev, maxfraglen]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n11. 函数名: __skb_queue_tail\n- 参数: [queue, skb]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n12. 函数名: sk_page_frag_refill\n- 参数: [sk, pfrag]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n13. 函数名: skb_can_coalesce\n- 参数: [skb, i, pfrag->page, pfrag->offset]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n14. 函数名: __skb_fill_page_desc\n- 参数: [skb, i, pfrag->page, pfrag->offset, 0]\n- 调用者: __ip6_append_data\n- 被调用者: []"
  },
  {
    "id": 1238,
    "cwe": "CWE-362",
    "cve": "CVE-2017-1000405",
    "purpose": "Code purpose:\"\"\"该代码片段实现了通过虚拟内存区域和页表项跟踪设备映射页面的功能，包括权限检查、页面获取和引用计数管理。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在THP实现中，touch_pmd()函数错误地使用了pmd_mkdirty()，使得通过get_user_pages()访问的pmd会被标记为脏页，绕过了COW机制，导致只读大页可被覆盖。\"\"\"",
    "functions": "Functions:\n1. 函数名: follow_devmap_pud\n- 参数: [struct vm_area_struct *vma, unsigned long addr, pud_t *pud, int flags]\n- 调用者: 未明确（由内核调用）\n- 被调用者: [pud_pfn, pud_write, pud_present, pud_devmap, touch_pud, get_dev_pagemap, pfn_to_page, get_page, put_dev_pagemap, ERR_PTR]\n\n2. 函数名: pud_pfn\n- 参数: [pud_t *pud]\n- 调用者: follow_devmap_pud\n- 被调用者: []\n\n3. 函数名: pud_write\n- 参数: [pud_t *pud]\n- 调用者: follow_devmap_pud\n- 被调用者: []\n\n4. 函数名: pud_present\n- 参数: [pud_t *pud]\n- 调用者: follow_devmap_pud\n- 被调用者: []\n\n5. 函数名: pud_devmap\n- 参数: [pud_t *pud]\n- 调用者: follow_devmap_pud\n- 被调用者: []\n\n6. 函数名: touch_pud\n- 参数: [struct vm_area_struct *vma, unsigned long addr, pud_t *pud]\n- 调用者: follow_devmap_pud\n- 被调用者: []\n\n7. 函数名: get_dev_pagemap\n- 参数: [unsigned long pfn, NULL]\n- 调用者: follow_devmap_pud\n- 被调用者: []\n\n8. 函数名: pfn_to_page\n- 参数: [unsigned long pfn]\n- 调用者: follow_devmap_pud\n- 被调用者: []\n\n9. 函数名: get_page\n- 参数: [struct page *page]\n- 调用者: follow_devmap_pud\n- 被调用者: []\n\n10. 函数名: put_dev_pagemap\n- 参数: [struct dev_pagemap *pgmap]\n- 调用者: follow_devmap_pud\n- 被调用者: []\n\n11. 函数名: ERR_PTR\n- 参数: [long error]\n- 调用者: follow_devmap_pud\n- 被调用者: []"
  },
  {
    "id": 1239,
    "cwe": "CWE-362",
    "cve": "CVE-2017-1000405",
    "purpose": "Code purpose:\"\"\"该代码用于处理设备映射的大页(THP)的页表项(PMD)跟随操作，包括权限检查、脏页标记和页面引用管理\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在THP实现中，touch_pmd()函数被get_user_pages()调用时会使pmd变为dirty状态，绕过了COW机制，导致可以覆盖只读大页。\"\"\"",
    "functions": "Functions:\n1. 函数名: follow_devmap_pmd\n- 参数: [struct vm_area_struct *vma, unsigned long addr, pmd_t *pmd, int flags]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [assert_spin_locked, pmd_lockptr, pmd_pfn, WARN_ONCE, pmd_write, pmd_present, pmd_devmap, touch_pmd, get_dev_pagemap, pfn_to_page, get_page, put_dev_pagemap]\n\n2. 函数名: assert_spin_locked\n- 参数: [spinlock_t *lock]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n3. 函数名: pmd_lockptr\n- 参数: [struct mm_struct *mm, pmd_t *pmd]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n4. 函数名: pmd_pfn\n- 参数: [pmd_t pmd]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n5. 函数名: WARN_ONCE\n- 参数: [bool condition, const char *format]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n6. 函数名: pmd_write\n- 参数: [pmd_t pmd]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n7. 函数名: pmd_present\n- 参数: [pmd_t pmd]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n8. 函数名: pmd_devmap\n- 参数: [pmd_t pmd]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n9. 函数名: touch_pmd\n- 参数: [struct vm_area_struct *vma, unsigned long addr, pmd_t *pmd]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n10. 函数名: get_dev_pagemap\n- 参数: [unsigned long pfn, struct dev_pagemap **pgmap]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n11. 函数名: pfn_to_page\n- 参数: [unsigned long pfn]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n12. 函数名: get_page\n- 参数: [struct page *page]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n13. 函数名: put_dev_pagemap\n- 参数: [struct dev_pagemap *pgmap]\n- 调用者: follow_devmap_pmd\n- 被调用者: []"
  },
  {
    "id": 1240,
    "cwe": "CWE-362",
    "cve": "CVE-2017-1000405",
    "purpose": "Code purpose:\"\"\"该代码用于处理透明大页(THP)的页表项(pmd)跟踪操作，包括权限检查、NUMA提示、内存锁定(mlock)以及获取页面引用等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在THP实现中，touch_pmd()函数被get_user_pages()调用时会使pmd变为dirty状态，绕过了can_follow_write_pmd()的COW检查逻辑，导致可以覆盖只读大页。\"\"\"",
    "functions": "Functions:\n1. 函数名: follow_trans_huge_pmd\n- 参数: [vma, addr, pmd, flags]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [assert_spin_locked, can_follow_write_pmd, is_huge_zero_pmd, pmd_protnone, pmd_page, touch_pmd, PageAnon, compound_mapcount, PageDoubleMap, trylock_page, lru_add_drain, mlock_vma_page, unlock_page, get_page]\n\n2. 函数名: assert_spin_locked\n- 参数: [pmd_lockptr(mm, pmd)]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n3. 函数名: can_follow_write_pmd\n- 参数: [*pmd, flags]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n4. 函数名: is_huge_zero_pmd\n- 参数: [*pmd]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n5. 函数名: pmd_protnone\n- 参数: [*pmd]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n6. 函数名: pmd_page\n- 参数: [*pmd]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n7. 函数名: touch_pmd\n- 参数: [vma, addr, pmd]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n8. 函数名: PageAnon\n- 参数: [page]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n9. 函数名: compound_mapcount\n- 参数: [page]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n10. 函数名: PageDoubleMap\n- 参数: [page]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n11. 函数名: trylock_page\n- 参数: [page]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n12. 函数名: lru_add_drain\n- 参数: []\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n13. 函数名: mlock_vma_page\n- 参数: [page]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n14. 函数名: unlock_page\n- 参数: [page]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n15. 函数名: get_page\n- 参数: [page]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []"
  },
  {
    "id": 1254,
    "cwe": "CWE-362",
    "cve": "CVE-2017-12146",
    "purpose": "Code purpose:\"\"\"该代码用于处理设备驱动覆盖的存储操作，允许通过用户空间输入来设置或清除平台设备的driver_override属性。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中driver_override实现存在竞态条件漏洞，允许本地用户通过读写操作间的竞争条件利用不同覆盖值来提升权限\"\"\"",
    "functions": "Functions:\n1. 函数名: driver_override_store\n- 参数: [dev, attr, buf, count]\n- 调用者: 未明确显示（通常由设备属性操作调用）\n- 被调用者: [to_platform_device, kstrndup, strchr, strlen, kfree]\n\n2. 函数名: to_platform_device\n- 参数: [dev]\n- 调用者: driver_override_store\n- 被调用者: []\n\n3. 函数名: kstrndup\n- 参数: [buf, count, GFP_KERNEL]\n- 调用者: driver_override_store\n- 被调用者: []\n\n4. 函数名: strchr\n- 参数: [driver_override, '\\n']\n- 调用者: driver_override_store\n- 被调用者: []\n\n5. 函数名: strlen\n- 参数: [driver_override]\n- 调用者: driver_override_store\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [driver_override] 和 [old]\n- 调用者: driver_override_store\n- 被调用者: []"
  },
  {
    "id": 1255,
    "cwe": "CWE-362",
    "cve": "CVE-2017-12146",
    "purpose": "Code purpose:\"\"\"该代码用于显示平台设备(platform device)的driver_override属性值到用户提供的缓冲区中\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中driver_override的实现存在竞态条件漏洞，允许本地用户通过读写操作间的竞争来提升权限\"\"\"",
    "functions": "Functions:\n1. 函数名: driver_override_show\n- 参数: [struct device *dev, struct device_attribute *attr, char *buf]\n- 调用者: 未明确显示（通常由设备属性子系统调用）\n- 被调用者: [to_platform_device, sprintf]\n\n2. 函数名: to_platform_device\n- 参数: [struct device *dev]\n- 调用者: driver_override_show\n- 被调用者: []\n\n3. 函数名: sprintf\n- 参数: [char *buf, const char *format, ...]\n- 调用者: driver_override_show\n- 被调用者: []"
  },
  {
    "id": 1299,
    "cwe": "CWE-362",
    "cve": "CVE-2017-15129",
    "purpose": "Code purpose:\"\"\"通过ID查找并获取对应的网络命名空间引用，但不充分检查引用计数可能导致释放后使用漏洞\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"函数get_net_ns_by_id()在找到peer网络后未检查net::count值，导致可能发生use-after-free和内存损坏\"\"\"",
    "functions": "Functions:\n1. 函数名: get_net_ns_by_id\n- 参数: [net, id]\n- 调用者: 不适用（未在代码片段中显示）\n- 被调用者: [rcu_read_lock, spin_lock_bh, idr_find, get_net, spin_unlock_bh, rcu_read_unlock]\n\n2. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: get_net_ns_by_id\n- 被调用者: []\n\n3. 函数名: spin_lock_bh\n- 参数: [&net->nsid_lock]\n- 调用者: get_net_ns_by_id\n- 被调用者: []\n\n4. 函数名: idr_find\n- 参数: [&net->netns_ids, id]\n- 调用者: get_net_ns_by_id\n- 被调用者: []\n\n5. 函数名: get_net\n- 参数: [peer]\n- 调用者: get_net_ns_by_id\n- 被调用者: []\n\n6. 函数名: spin_unlock_bh\n- 参数: [&net->nsid_lock]\n- 调用者: get_net_ns_by_id\n- 被调用者: []\n\n7. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: get_net_ns_by_id\n- 被调用者: []"
  },
  {
    "id": 1300,
    "cwe": "CWE-362",
    "cve": "CVE-2017-15265",
    "purpose": "Code purpose:\"\"\"该代码用于在ALSA子系统中创建序列端口，处理用户空间和内核空间客户端的端口创建请求，并设置相应的端口属性和回调函数。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于ALSA子系统中创建端口时存在竞态条件，导致在ioctl调用过程中可能发生use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_seq_ioctl_create_port\n- 参数: [struct snd_seq_client *client, void *arg]\n- 调用者: 未指定（由ioctl调用触发）\n- 被调用者: [snd_seq_create_port, snd_seq_delete_port, snd_seq_set_port_info, snd_seq_system_client_ev_port_start]\n\n2. 函数名: snd_seq_create_port\n- 参数: [struct snd_seq_client *client, int port]\n- 调用者: snd_seq_ioctl_create_port\n- 被调用者: 未指定\n\n3. 函数名: snd_seq_delete_port\n- 参数: [struct snd_seq_client *client, int port]\n- 调用者: snd_seq_ioctl_create_port\n- 被调用者: 未指定\n\n4. 函数名: snd_seq_set_port_info\n- 参数: [struct snd_seq_client_port *port, struct snd_seq_port_info *info]\n- 调用者: snd_seq_ioctl_create_port\n- 被调用者: 未指定\n\n5. 函数名: snd_seq_system_client_ev_port_start\n- 参数: [int client, int port]\n- 调用者: snd_seq_ioctl_create_port\n- 被调用者: 未指定"
  },
  {
    "id": 1301,
    "cwe": "CWE-362",
    "cve": "CVE-2017-15265",
    "purpose": "Code purpose:\"\"\"创建一个新的ALSA序列端口并初始化其相关数据结构\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在ALSA子系统中对端口列表的操作缺乏适当的同步保护，导致在并发ioctl调用时可能发生竞态条件，造成use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_seq_create_port\n- 参数: [struct snd_seq_client *client, int port]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [snd_BUG_ON, pr_warn, kzalloc, sprintf, snd_use_lock_init, port_subs_info_init, mutex_lock, write_lock_irqsave, list_for_each_entry, list_add_tail, write_unlock_irqrestore, mutex_unlock]\n\n2. 函数名: snd_BUG_ON\n- 参数: [!client]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n3. 函数名: pr_warn\n- 参数: [\"ALSA: seq: too many ports for client %d\\n\", client->number]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n4. 函数名: kzalloc\n- 参数: [sizeof(*new_port), GFP_KERNEL]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n5. 函数名: sprintf\n- 参数: [new_port->name, \"port-%d\", num]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n6. 函数名: snd_use_lock_init\n- 参数: [&new_port->use_lock]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n7. 函数名: port_subs_info_init\n- 参数: [&new_port->c_src]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n8. 函数名: port_subs_info_init\n- 参数: [&new_port->c_dest]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n9. 函数名: mutex_lock\n- 参数: [&client->ports_mutex]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n10. 函数名: write_lock_irqsave\n- 参数: [&client->ports_lock, flags]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n11. 函数名: list_for_each_entry\n- 参数: [p, &client->ports_list_head, list]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n12. 函数名: list_add_tail\n- 参数: [&new_port->list, &p->list]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n13. 函数名: write_unlock_irqrestore\n- 参数: [&client->ports_lock, flags]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n14. 函数名: mutex_unlock\n- 参数: [&client->ports_mutex]\n- 调用者: snd_seq_create_port\n- 被调用者: []"
  },
  {
    "id": 1366,
    "cwe": "CWE-362",
    "cve": "CVE-2017-17712",
    "purpose": "Code purpose:\"\"\"处理原始套接字发送消息的请求，包括地址验证、路由查找和数据发送等功能\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中的raw_sendmsg()函数存在竞争条件，导致inet->hdrincl状态不一致，从而引发未初始化的栈指针使用，允许本地用户执行代码并提升权限。\"\"\"",
    "functions": "Functions:\n1. 函数名: raw_sendmsg\n- 参数: [struct sock *sk, struct msghdr *msg, size_t len]\n- 调用者: 未显示\n- 被调用者: [inet_sk, sock_net, ip_cmsg_send, kfree, rcu_read_lock, rcu_dereference, memcpy, rcu_read_unlock, get_rtconn_flags, ipv4_is_multicast, flowi4_init_output, raw_probe_proto_opt, security_sk_classify_flow, ip_route_output_flow, sock_flag, raw_send_hdrinc, sock_tx_timestamp, lock_sock, ip_append_data, ip_flush_pending_frames, ip_push_pending_frames, release_sock, ip_rt_put, dst_confirm_neigh]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n3. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n4. 函数名: ip_cmsg_send\n- 参数: [struct sock *sk, struct msghdr *msg, struct ipcm_cookie *ipc, bool false]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n5. 函数名: kfree\n- 参数: [void *ptr]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n6. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n7. 函数名: rcu_dereference\n- 参数: [struct ip_options_rcu *inet_opt]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n8. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n9. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n10. 函数名: get_rtconn_flags\n- 参数: [struct ipcm_cookie *ipc, struct sock *sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n11. 函数名: ipv4_is_multicast\n- 参数: [__be32 addr]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n12. 函数名: flowi4_init_output\n- 参数: [struct flowi4 *fl4, int oif, __u32 mark, __u8 tos, __u8 scope, __u8 proto, __u8 flags, __be32 daddr, __be32 saddr, __be16 sport, __be16 dport, kuid_t uid]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n13. 函数名: raw_probe_proto_opt\n- 参数: [struct raw_frag_vec *rfv, struct flowi4 *fl4]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n14. 函数名: security_sk_classify_flow\n- 参数: [struct sock *sk, struct flowi *fl]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n15. 函数名: ip_route_output_flow\n- 参数: [struct net *net, struct flowi4 *flp, struct sock *sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n16. 函数名: sock_flag\n- 参数: [struct sock *sk, enum sock_flags flag]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n17. 函数名: raw_send_hdrinc\n- 参数: [struct sock *sk, struct flowi4 *fl4, struct msghdr *msg, size_t len, struct rtable **rtp, unsigned int flags, struct sockcm_cookie *sockc]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n18. 函数名: sock_tx_timestamp\n- 参数: [struct sock *sk, __u16 tsflags, __u8 *tx_flags]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n19. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n20. 函数名: ip_append_data\n- 参数: [struct sock *sk, struct flowi4 *fl4, int (*getfrag)(void *from, char *to, int offset, int len, int odd, struct sk_buff *skb), void *from, int length, int transhdrlen, struct ipcm_cookie *ipc, struct rtable **rtp, unsigned int flags]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n21. 函数名: ip_flush_pending_frames\n- 参数: [struct sock *sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n22. 函数名: ip_push_pending_frames\n- 参数: [struct sock *sk, struct flowi4 *fl4]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n23. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n24. 函数名: ip_rt_put\n- 参数: [struct rtable *rt]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n25. 函数名: dst_confirm_neigh\n- 参数: [struct dst_entry *dst, const void *daddr]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示"
  },
  {
    "id": 1411,
    "cwe": "CWE-362",
    "cve": "CVE-2017-18224",
    "purpose": "Code purpose:\"\"\"该代码实现了OCFS2文件系统中直接I/O(DIRECT I/O)操作的功能，包括处理内联数据、追加写入检查以及根据读写操作选择不同的块获取方法。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在DIRECT模式读取操作中，由于未使用信号量保护对extent树的访问，导致存在竞争条件，可能被本地用户利用修改e_cpos字段造成拒绝服务。\"\"\"",
    "functions": "Functions:\n1. 函数名: ocfs2_direct_IO\n- 参数: [struct kiocb *iocb, struct iov_iter *iter]\n- 调用者: 未显示（由文件系统调用）\n- 被调用者: [OCFS2_I, i_size_read, ocfs2_supports_append_dio, iov_iter_rw, ocfs2_get_block, ocfs2_dio_get_block, __blockdev_direct_IO]\n\n2. 函数名: OCFS2_I\n- 参数: [struct inode *inode]\n- 调用者: ocfs2_direct_IO\n- 被调用者: []\n\n3. 函数名: i_size_read\n- 参数: [struct inode *inode]\n- 调用者: ocfs2_direct_IO\n- 被调用者: []\n\n4. 函数名: ocfs2_supports_append_dio\n- 参数: [struct ocfs2_super *osb]\n- 调用者: ocfs2_direct_IO\n- 被调用者: []\n\n5. 函数名: iov_iter_rw\n- 参数: [struct iov_iter *iter]\n- 调用者: ocfs2_direct_IO\n- 被调用者: []\n\n6. 函数名: ocfs2_get_block\n- 参数: 未显示（函数指针）\n- 调用者: ocfs2_direct_IO\n- 被调用者: []\n\n7. 函数名: ocfs2_dio_get_block\n- 参数: 未显示（函数指针）\n- 调用者: ocfs2_direct_IO\n- 被调用者: []\n\n8. 函数名: __blockdev_direct_IO\n- 参数: [struct kiocb *iocb, struct inode *inode, struct block_device *bdev, struct iov_iter *iter, get_block_t *get_block, dio_iodone_t *end_io, dio_submit_t *submit_io, int flags]\n- 调用者: ocfs2_direct_IO\n- 被调用者: []\n\n9. 函数名: ocfs2_dio_end_io\n- 参数: 未显示（函数指针）\n- 调用者: __blockdev_direct_IO\n- 被调用者: []"
  },
  {
    "id": 1425,
    "cwe": "CWE-362",
    "cve": "CVE-2017-18249",
    "purpose": "Code purpose:\"\"\"该代码用于在F2FS文件系统中添加空闲节点ID到空闲列表，并处理相关的并发控制和内存管理\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在多线程并发环境下，未对nid分配进行适当的同步保护，导致竞争条件可能引发拒绝服务或其他未定义行为\"\"\"",
    "functions": "Functions:\n1. 函数名: add_free_nid\n- 参数: [struct f2fs_sb_info *sbi, nid_t nid, bool build]\n- 调用者: 未指定\n- 被调用者: [__lookup_nat_cache, get_nat_flag, nat_get_blkaddr, f2fs_kmem_cache_alloc, radix_tree_preload, kmem_cache_free, __insert_nid_to_list, spin_lock, spin_unlock, radix_tree_preload_end]\n\n2. 函数名: __lookup_nat_cache\n- 参数: [struct f2fs_nm_info *nm_i, nid_t nid]\n- 调用者: add_free_nid\n- 被调用者: 未指定\n\n3. 函数名: get_nat_flag\n- 参数: [struct nat_entry *ne, IS_CHECKPOINTED]\n- 调用者: add_free_nid\n- 被调用者: 未指定\n\n4. 函数名: nat_get_blkaddr\n- 参数: [struct nat_entry *ne]\n- 调用者: add_free_nid\n- 被调用者: 未指定\n\n5. 函数名: f2fs_kmem_cache_alloc\n- 参数: [free_nid_slab, GFP_NOFS]\n- 调用者: add_free_nid\n- 被调用者: 未指定\n\n6. 函数名: radix_tree_preload\n- 参数: [GFP_NOFS]\n- 调用者: add_free_nid\n- 被调用者: 未指定\n\n7. 函数名: kmem_cache_free\n- 参数: [free_nid_slab, struct free_nid *i]\n- 调用者: add_free_nid\n- 被调用者: 未指定\n\n8. 函数名: __insert_nid_to_list\n- 参数: [struct f2fs_sb_info *sbi, struct free_nid *i, FREE_NID_LIST, bool true]\n- 调用者: add_free_nid\n- 被调用者: 未指定\n\n9. 函数名: spin_lock\n- 参数: [&nm_i->nid_list_lock]\n- 调用者: add_free_nid\n- 被调用者: 未指定\n\n10. 函数名: spin_unlock\n- 参数: [&nm_i->nid_list_lock]\n- 调用者: add_free_nid\n- 被调用者: 未指定\n\n11. 函数名: radix_tree_preload_end\n- 参数: []\n- 调用者: add_free_nid\n- 被调用者: 未指定"
  },
  {
    "id": 1477,
    "cwe": "CWE-362",
    "cve": "CVE-2017-6001",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中的perf_event_open系统调用，用于创建和管理性能监控事件，支持硬件和软件事件的配置、分组及上下文切换等功能。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在将软件事件组移动到硬件上下文时存在竞态条件，导致本地用户可以通过并发调用perf_event_open系统调用来提升权限。\"\"\"",
    "functions": "Functions:\n1. 函数名: SYSCALL_DEFINE5(perf_event_open)\n- 参数: [struct perf_event_attr __user *attr_uptr, pid_t pid, int cpu, int group_fd, unsigned long flags]\n- 调用者: 系统调用\n- 被调用者: [perf_copy_attr, perf_paranoid_kernel, capable, get_unused_fd_flags, perf_fget_light, find_lively_task_by_vpid, mutex_lock_interruptible, ptrace_may_access, perf_event_alloc, perf_event_set_clock, find_get_context, perf_event_set_output, anon_inode_getfile, mutex_lock_double, mutex_lock, perf_event_validate_size, exclusive_event_installable, perf_remove_from_context, synchronize_rcu, perf_event__state_init, perf_install_in_context, perf_event__header_size, perf_event__id_header_size, perf_unpin_context, mutex_unlock, put_task_struct, put_online_cpus, list_add_tail, fdput, fd_install, fput, perf_unpin_context, put_ctx, free_event, put_unused_fd]\n\n2. 函数名: perf_copy_attr\n- 参数: [struct perf_event_attr __user *uattr, struct perf_event_attr *attr]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n3. 函数名: perf_paranoid_kernel\n- 参数: []\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n4. 函数名: capable\n- 参数: [int cap]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n5. 函数名: get_unused_fd_flags\n- 参数: [int flags]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n6. 函数名: perf_fget_light\n- 参数: [int fd, struct fd *fget]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n7. 函数名: find_lively_task_by_vpid\n- 参数: [pid_t vpid]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n8. 函数名: mutex_lock_interruptible\n- 参数: [struct mutex *lock]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n9. 函数名: ptrace_may_access\n- 参数: [struct task_struct *task, unsigned int mode]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n10. 函数名: perf_event_alloc\n- 参数: [struct perf_event_attr *attr, int cpu, struct task_struct *task, struct perf_event *group_leader, perf_overflow_handler_t overflow_handler, void *context, int cgroup_fd]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n11. 函数名: perf_event_set_clock\n- 参数: [struct perf_event *event, clockid_t clockid]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n12. 函数名: find_get_context\n- 参数: [struct pmu *pmu, struct task_struct *task, struct perf_event *event]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n13. 函数名: perf_event_set_output\n- 参数: [struct perf_event *event, struct perf_event *output_event]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n14. 函数名: anon_inode_getfile\n- 参数: [const char *name, const struct file_operations *fops, void *priv, int flags]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n15. 函数名: mutex_lock_double\n- 参数: [struct mutex *lock1, struct mutex *lock2]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n16. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n17. 函数名: perf_event_validate_size\n- 参数: [struct perf_event *event]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n18. 函数名: exclusive_event_installable\n- 参数: [struct perf_event *event, struct perf_event_context *ctx]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n19. 函数名: perf_remove_from_context\n- 参数: [struct perf_event *event, unsigned long flags]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n20. 函数名: synchronize_rcu\n- 参数: []\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n21. 函数名: perf_event__state_init\n- 参数: [struct perf_event *event]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n22. 函数名: perf_install_in_context\n- 参数: [struct perf_event_context *ctx, struct perf_event *event, int cpu]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n23. 函数名: perf_event__header_size\n- 参数: [struct perf_event *event]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n24. 函数名: perf_event__id_header_size\n- 参数: [struct perf_event *event]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n25. 函数名: perf_unpin_context\n- 参数: [struct perf_event_context *ctx]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n26. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n27. 函数名: put_task_struct\n- 参数: [struct task_struct *t]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n28. 函数名: put_online_cpus\n- 参数: []\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n29. 函数名: list_add_tail\n- 参数: [struct list_head *new, struct list_head *head]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n30. 函数名: fdput\n- 参数: [struct fd fd]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n31. 函数名: fd_install\n- 参数: [int fd, struct file *file]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n32. 函数名: fput\n- 参数: [struct file *file]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n33. 函数名: put_ctx\n- 参数: [struct perf_event_context *ctx]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n34. 函数名: free_event\n- 参数: [struct perf_event *event]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n35. 函数名: put_unused_fd\n- 参数: [int fd]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []"
  },
  {
    "id": 1482,
    "cwe": "CWE-362",
    "cve": "CVE-2017-6346",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中PACKET_FANOUT套接字选项的功能，用于将多个套接字绑定到一个fanout组以实现数据包的多线程处理。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多线程环境下对fanout_list的访问缺乏足够的同步保护，导致竞争条件可能引发use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: fanout_add\n- 参数: [struct sock *sk, u16 id, u16 type_flags]\n- 调用者: 未显示（应为系统调用处理函数）\n- 被调用者: [pkt_sk, kzalloc, atomic_long_set, mutex_lock, list_for_each_entry, read_pnet, sock_net, write_pnet, spin_lock_init, atomic_set, fanout_init_data, dev_add_pack, list_add, atomic_read, __dev_remove_pack, atomic_inc, __fanout_link, mutex_unlock, kfree]\n\n2. 函数名: pkt_sk\n- 参数: [struct sock *sk]\n- 调用者: fanout_add\n- 被调用者: []\n\n3. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: fanout_add\n- 被调用者: []\n\n4. 函数名: atomic_long_set\n- 参数: [atomic_long_t *v, long i]\n- 调用者: fanout_add\n- 被调用者: []\n\n5. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: fanout_add\n- 被调用者: []\n\n6. 函数名: list_for_each_entry\n- 参数: [type *pos, struct list_head *head, member]\n- 调用者: fanout_add\n- 被调用者: []\n\n7. 函数名: read_pnet\n- 参数: [possible_net_t *net]\n- 调用者: fanout_add\n- 被调用者: []\n\n8. 函数名: sock_net\n- 参数: [const struct sock *sk]\n- 调用者: fanout_add\n- 被调用者: []\n\n9. 函数名: write_pnet\n- 参数: [possible_net_t *net, struct net *net]\n- 调用者: fanout_add\n- 被调用者: []\n\n10. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: fanout_add\n- 被调用者: []\n\n11. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: fanout_add\n- 被调用者: []\n\n12. 函数名: fanout_init_data\n- 参数: [struct packet_fanout *f]\n- 调用者: fanout_add\n- 被调用者: []\n\n13. 函数名: dev_add_pack\n- 参数: [struct packet_type *pt]\n- 调用者: fanout_add\n- 被调用者: []\n\n14. 函数名: list_add\n- 参数: [struct list_head *new, struct list_head *head]\n- 调用者: fanout_add\n- 被调用者: []\n\n15. 函数名: atomic_read\n- 参数: [const atomic_t *v]\n- 调用者: fanout_add\n- 被调用者: []\n\n16. 函数名: __dev_remove_pack\n- 参数: [struct packet_type *pt]\n- 调用者: fanout_add\n- 被调用者: []\n\n17. 函数名: atomic_inc\n- 参数: [atomic_t *v]\n- 调用者: fanout_add\n- 被调用者: []\n\n18. 函数名: __fanout_link\n- 参数: [struct sock *sk, struct packet_sock *po]\n- 调用者: fanout_add\n- 被调用者: []\n\n19. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: fanout_add\n- 被调用者: []\n\n20. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: fanout_add\n- 被调用者: []"
  },
  {
    "id": 1483,
    "cwe": "CWE-362",
    "cve": "CVE-2017-6346",
    "purpose": "Code purpose:\"\"\"管理PACKET_FANOUT套接字组的引用计数和资源释放，处理多线程环境下的竞争条件问题\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多线程环境下对fanout结构的引用计数和释放操作存在竞争条件，导致可能发生use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: fanout_release\n- 参数: [struct sock *sk]\n- 调用者: 未明确显示（由系统调用触发）\n- 被调用者: [pkt_sk, mutex_lock, atomic_dec_and_test, list_del, dev_remove_pack, fanout_release_data, kfree, mutex_unlock, kfree_rcu]\n\n2. 函数名: pkt_sk\n- 参数: [struct sock *sk]\n- 调用者: fanout_release\n- 被调用者: []\n\n3. 函数名: mutex_lock\n- 参数: [&fanout_mutex]\n- 调用者: fanout_release\n- 被调用者: []\n\n4. 函数名: atomic_dec_and_test\n- 参数: [&f->sk_ref]\n- 调用者: fanout_release\n- 被调用者: []\n\n5. 函数名: list_del\n- 参数: [&f->list]\n- 调用者: fanout_release\n- 被调用者: []\n\n6. 函数名: dev_remove_pack\n- 参数: [&f->prot_hook]\n- 调用者: fanout_release\n- 被调用者: []\n\n7. 函数名: fanout_release_data\n- 参数: [f]\n- 调用者: fanout_release\n- 被调用者: []\n\n8. 函数名: kfree\n- 参数: [f]\n- 调用者: fanout_release\n- 被调用者: []\n\n9. 函数名: mutex_unlock\n- 参数: [&fanout_mutex]\n- 调用者: fanout_release\n- 被调用者: []\n\n10. 函数名: kfree_rcu\n- 参数: [po->rollover, rcu]\n- 调用者: fanout_release\n- 被调用者: []"
  },
  {
    "id": 1487,
    "cwe": "CWE-362",
    "cve": "CVE-2017-6874",
    "purpose": "Code purpose:\"\"\"该代码用于在原子计数器减至零时安全释放ucounts结构体，但存在竞态条件可能导致释放后使用问题\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于原子递减操作和链表删除操作之间存在竞争条件，导致在并发场景下可能出现引用计数错误和释放后使用的问题\"\"\"",
    "functions": "Functions:\n1. 函数名: put_ucounts\n- 参数: [struct ucounts *ucounts]\n- 调用者: 未明确（由系统调用触发）\n- 被调用者: [atomic_dec_and_test, spin_lock_irqsave, hlist_del_init, spin_unlock_irqrestore, kfree]\n\n2. 函数名: atomic_dec_and_test\n- 参数: [&ucounts->count]\n- 调用者: put_ucounts\n- 被调用者: []\n\n3. 函数名: spin_lock_irqsave\n- 参数: [&ucounts_lock, flags]\n- 调用者: put_ucounts\n- 被调用者: []\n\n4. 函数名: hlist_del_init\n- 参数: [&ucounts->node]\n- 调用者: put_ucounts\n- 被调用者: []\n\n5. 函数名: spin_unlock_irqrestore\n- 参数: [&ucounts_lock, flags]\n- 调用者: put_ucounts\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [ucounts]\n- 调用者: put_ucounts\n- 被调用者: []"
  },
  {
    "id": 1488,
    "cwe": "CWE-362",
    "cve": "CVE-2017-6874",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中管理用户命名空间的引用计数，通过哈希表查找或创建ucounts结构体来跟踪特定用户命名空间和用户ID的使用情况。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在释放锁后重新获取锁的过程中存在竞争条件，导致可能发生use-after-free错误。\"\"\"",
    "functions": "Functions:\n1. 函数名: get_ucounts\n- 参数: [struct user_namespace *ns, kuid_t uid]\n- 调用者: 未指定\n- 被调用者: [ucounts_hashentry, find_ucounts, spin_lock_irq, spin_unlock_irq, kzalloc, kfree, atomic_set, hlist_add_head, atomic_add_unless]\n\n2. 函数名: ucounts_hashentry\n- 参数: [struct user_namespace *ns, kuid_t uid]\n- 调用者: get_ucounts\n- 被调用者: 未指定\n\n3. 函数名: find_ucounts\n- 参数: [struct user_namespace *ns, kuid_t uid, struct hlist_head *hashent]\n- 调用者: get_ucounts\n- 被调用者: 未指定\n\n4. 函数名: spin_lock_irq\n- 参数: [spinlock_t *lock]\n- 调用者: get_ucounts\n- 被调用者: 未指定\n\n5. 函数名: spin_unlock_irq\n- 参数: [spinlock_t *lock]\n- 调用者: get_ucounts\n- 被调用者: 未指定\n\n6. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: get_ucounts\n- 被调用者: 未指定\n\n7. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: get_ucounts\n- 被调用者: 未指定\n\n8. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: get_ucounts\n- 被调用者: 未指定\n\n9. 函数名: hlist_add_head\n- 参数: [struct hlist_node *n, struct hlist_head *h]\n- 调用者: get_ucounts\n- 被调用者: 未指定\n\n10. 函数名: atomic_add_unless\n- 参数: [atomic_t *v, int a, int u]\n- 调用者: get_ucounts\n- 被调用者: 未指定"
  },
  {
    "id": 1510,
    "cwe": "CWE-362",
    "cve": "CVE-2017-7533",
    "purpose": "Code purpose:\"\"\"该代码实现了debugfs文件系统中重命名文件或目录的功能，包括检查源目录和目标目录的有效性、处理重命名操作以及相关的文件系统通知。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于fsnotify实现中存在竞态条件，当inotify_handle_event和vfs_rename函数同时执行时，可能导致内存损坏或权限提升。\"\"\"",
    "functions": "Functions:\n1. 函数名: debugfs_rename\n- 参数: [struct dentry *old_dir, struct dentry *old_dentry, struct dentry *new_dir, const char *new_name]\n- 调用者: N/A (top-level function)\n- 被调用者: [lock_rename, d_really_is_negative, d_mountpoint, lookup_one_len, IS_ERR, d_really_is_positive, fsnotify_oldname_init, simple_rename, fsnotify_oldname_free, d_move, fsnotify_move, unlock_rename, dput]\n\n2. 函数名: lock_rename\n- 参数: [struct dentry *new_dir, struct dentry *old_dir]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n3. 函数名: d_really_is_negative\n- 参数: [struct dentry *dentry]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n4. 函数名: d_mountpoint\n- 参数: [struct dentry *dentry]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n5. 函数名: lookup_one_len\n- 参数: [const char *name, struct dentry *base, int len]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n6. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n7. 函数名: d_really_is_positive\n- 参数: [struct dentry *dentry]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n8. 函数名: fsnotify_oldname_init\n- 参数: [const char *name]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n9. 函数名: simple_rename\n- 参数: [struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry, unsigned int flags]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n10. 函数名: fsnotify_oldname_free\n- 参数: [const char *old_name]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n11. 函数名: d_move\n- 参数: [struct dentry *old_dentry, struct dentry *new_dentry]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n12. 函数名: fsnotify_move\n- 参数: [struct inode *old_dir, struct inode *new_dir, const char *old_name, int is_dir, struct inode *target, struct dentry *moved]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n13. 函数名: unlock_rename\n- 参数: [struct dentry *new_dir, struct dentry *old_dir]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n14. 函数名: dput\n- 参数: [struct dentry *dentry]\n- 调用者: debugfs_rename\n- 被调用者: []"
  },
  {
    "id": 1511,
    "cwe": "CWE-362",
    "cve": "CVE-2017-7533",
    "purpose": "Code purpose:\"\"\"实现文件系统重命名操作，包括权限检查、目录处理、文件系统通知和并发控制等功能\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中fsnotify实现存在竞态条件，当inotify_handle_event和vfs_rename函数同时执行时，可能导致内存损坏或权限提升。\"\"\"",
    "functions": "Functions:\n1. 函数名: vfs_rename\n- 参数: [struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry, struct inode **delegated_inode, unsigned int flags]\n- 调用者: N/A (系统调用)\n- 被调用者: [may_delete, may_create, inode_permission, security_inode_rename, fsnotify_oldname_init, dget, lock_two_nondirectories, inode_lock, is_local_mountpoint, try_break_deleg, shrink_dcache_parent, dont_mount, detach_mounts, d_move, d_exchange, inode_unlock, dput, fsnotify_move, fsnotify_oldname_free]\n\n2. 函数名: may_delete\n- 参数: [struct inode *dir, struct dentry *victim, int is_dir]\n- 调用者: vfs_rename\n- 被调用者: []\n\n3. 函数名: may_create\n- 参数: [struct inode *dir, struct dentry *dentry]\n- 调用者: vfs_rename\n- 被调用者: []\n\n4. 函数名: inode_permission\n- 参数: [struct inode *inode, int mask]\n- 调用者: vfs_rename\n- 被调用者: []\n\n5. 函数名: security_inode_rename\n- 参数: [struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry, unsigned int flags]\n- 调用者: vfs_rename\n- 被调用者: []\n\n6. 函数名: fsnotify_oldname_init\n- 参数: [const char *name]\n- 调用者: vfs_rename\n- 被调用者: []\n\n7. 函数名: dget\n- 参数: [struct dentry *dentry]\n- 调用者: vfs_rename\n- 被调用者: []\n\n8. 函数名: lock_two_nondirectories\n- 参数: [struct inode *inode1, struct inode *inode2]\n- 调用者: vfs_rename\n- 被调用者: []\n\n9. 函数名: inode_lock\n- 参数: [struct inode *inode]\n- 调用者: vfs_rename\n- 被调用者: []\n\n10. 函数名: is_local_mountpoint\n- 参数: [struct dentry *dentry]\n- 调用者: vfs_rename\n- 被调用者: []\n\n11. 函数名: try_break_deleg\n- 参数: [struct inode *inode, struct inode **delegated_inode]\n- 调用者: vfs_rename\n- 被调用者: []\n\n12. 函数名: shrink_dcache_parent\n- 参数: [struct dentry *parent]\n- 调用者: vfs_rename\n- 被调用者: []\n\n13. 函数名: dont_mount\n- 参数: [struct dentry *dentry]\n- 调用者: vfs_rename\n- 被调用者: []\n\n14. 函数名: detach_mounts\n- 参数: [struct dentry *dentry]\n- 调用者: vfs_rename\n- 被调用者: []\n\n15. 函数名: d_move\n- 参数: [struct dentry *old_dentry, struct dentry *new_dentry]\n- 调用者: vfs_rename\n- 被调用者: []\n\n16. 函数名: d_exchange\n- 参数: [struct dentry *old_dentry, struct dentry *new_dentry]\n- 调用者: vfs_rename\n- 被调用者: []\n\n17. 函数名: inode_unlock\n- 参数: [struct inode *inode]\n- 调用者: vfs_rename\n- 被调用者: []\n\n18. 函数名: dput\n- 参数: [struct dentry *dentry]\n- 调用者: vfs_rename\n- 被调用者: []\n\n19. 函数名: fsnotify_move\n- 参数: [struct inode *old_dir, struct inode *new_dir, const char *old_name, int is_dir, struct inode *target, struct dentry *moved]\n- 调用者: vfs_rename\n- 被调用者: []\n\n20. 函数名: fsnotify_oldname_free\n- 参数: [const unsigned char *old_name]\n- 调用者: vfs_rename\n- 被调用者: []"
  },
  {
    "id": 1512,
    "cwe": "CWE-362",
    "cve": "CVE-2017-7533",
    "purpose": "Code purpose:\"\"\"监控文件系统事件并通知父目录，处理来自子目录的事件通知\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于fsnotify_parent函数在处理文件系统通知时存在竞态条件，当inotify_handle_event和vfs_rename函数同时执行时可能导致内存损坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: __fsnotify_parent\n- 参数: [const struct path *path, struct dentry *dentry, __u32 mask]\n- 调用者: N/A\n- 被调用者: [dget_parent, fsnotify_inode_watches_children, __fsnotify_update_child_dentry_flags, fsnotify, dput]\n\n2. 函数名: dget_parent\n- 参数: [struct dentry *dentry]\n- 调用者: __fsnotify_parent\n- 被调用者: N/A\n\n3. 函数名: fsnotify_inode_watches_children\n- 参数: [struct inode *p_inode]\n- 调用者: __fsnotify_parent\n- 被调用者: N/A\n\n4. 函数名: __fsnotify_update_child_dentry_flags\n- 参数: [struct inode *p_inode]\n- 调用者: __fsnotify_parent\n- 被调用者: N/A\n\n5. 函数名: fsnotify\n- 参数: [struct inode *p_inode, __u32 mask, const struct path *path, enum fsnotify_event_type type, const char *name, u32 cookie]\n- 调用者: __fsnotify_parent\n- 被调用者: N/A\n\n6. 函数名: dput\n- 参数: [struct dentry *parent]\n- 调用者: __fsnotify_parent\n- 被调用者: N/A"
  },
  {
    "id": 1573,
    "cwe": "CWE-362",
    "cve": "CVE-2018-1000004",
    "purpose": "Code purpose:\"\"\"处理ALSA音序器的IOCTL命令，包括从用户空间复制数据、执行相应操作以及将结果返回给用户空间\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于Linux内核声音子系统中存在竞态条件，导致在处理序列IOCTL操作时可能引发死锁和拒绝服务\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_seq_ioctl\n- 参数: [struct file *file, unsigned int cmd, unsigned long arg]\n- 调用者: 未指定（由内核IOCTL机制调用）\n- 被调用者: [copy_from_user, copy_to_user, handler->func]\n\n2. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: snd_seq_ioctl\n- 被调用者: []\n\n3. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: snd_seq_ioctl\n- 被调用者: []\n\n4. 函数名: handler->func\n- 参数: [struct snd_seq_client *client, union {...} *buf]\n- 调用者: snd_seq_ioctl\n- 被调用者: []\n\n5. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: snd_seq_ioctl\n- 被调用者: []"
  },
  {
    "id": 1574,
    "cwe": "CWE-362",
    "cve": "CVE-2018-1000004",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核声音子系统中创建并初始化一个新的序列客户端，管理客户端资源分配和并发访问\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在客户端表操作时未正确处理自旋锁和资源释放的顺序，导致可能发生竞争条件从而引发死锁\"\"\"",
    "functions": "Functions:\n1. 函数名: seq_create_client1\n- 参数: [client_index, poolsize]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [kzalloc, kfree, snd_seq_pool_new, snd_seq_pool_delete, snd_use_lock_init, rwlock_init, mutex_init, INIT_LIST_HEAD, spin_lock_irqsave, spin_unlock_irqrestore]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*client), GFP_KERNEL]\n- 调用者: seq_create_client1\n- 被调用者: 未明确（内核内存分配函数）\n\n3. 函数名: kfree\n- 参数: [client]\n- 调用者: seq_create_client1\n- 被调用者: 未明确（内核内存释放函数）\n\n4. 函数名: snd_seq_pool_new\n- 参数: [poolsize]\n- 调用者: seq_create_client1\n- 被调用者: 未明确\n\n5. 函数名: snd_seq_pool_delete\n- 参数: [&client->pool]\n- 调用者: seq_create_client1\n- 被调用者: 未明确\n\n6. 函数名: snd_use_lock_init\n- 参数: [&client->use_lock]\n- 调用者: seq_create_client1\n- 被调用者: 未明确\n\n7. 函数名: rwlock_init\n- 参数: [&client->ports_lock]\n- 调用者: seq_create_client1\n- 被调用者: 未明确\n\n8. 函数名: mutex_init\n- 参数: [&client->ports_mutex]\n- 调用者: seq_create_client1\n- 被调用者: 未明确\n\n9. 函数名: INIT_LIST_HEAD\n- 参数: [&client->ports_list_head]\n- 调用者: seq_create_client1\n- 被调用者: 未明确\n\n10. 函数名: spin_lock_irqsave\n- 参数: [&clients_lock, flags]\n- 调用者: seq_create_client1\n- 被调用者: 未明确\n\n11. 函数名: spin_unlock_irqrestore\n- 参数: [&clients_lock, flags]\n- 调用者: seq_create_client1\n- 被调用者: 未明确"
  },
  {
    "id": 1649,
    "cwe": "CWE-362",
    "cve": "CVE-2018-12232",
    "purpose": "Code purpose:\"\"\"该代码用于设置socket文件属性，包括修改socket所属用户的UID，但在处理过程中存在竞态条件漏洞。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于fchownat操作未增加文件描述符引用计数，导致在并发执行close操作时可能将socket置为NULL，从而引发空指针解引用\"\"\"",
    "functions": "Functions:\n1. 函数名: sockfs_setattr\n- 参数: [struct dentry *dentry, struct iattr *iattr]\n- 调用者: 未明确（通常由文件系统操作调用）\n- 被调用者: [simple_setattr, SOCKET_I, d_inode]\n\n2. 函数名: simple_setattr\n- 参数: [struct dentry *dentry, struct iattr *iattr]\n- 调用者: sockfs_setattr\n- 被调用者: 未明确\n\n3. 函数名: SOCKET_I\n- 参数: [struct inode *inode]\n- 调用者: sockfs_setattr\n- 被调用者: 未明确\n\n4. 函数名: d_inode\n- 参数: [struct dentry *dentry]\n- 调用者: sockfs_setattr\n- 被调用者: 未明确"
  },
  {
    "id": 1650,
    "cwe": "CWE-362",
    "cve": "CVE-2018-12232",
    "purpose": "Code purpose:\"\"\"释放与inode关联的socket资源并关闭文件\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"fchownat操作未增加文件描述符引用计数，导致close操作在fchownat执行期间将socket置为NULL，引发空指针解引用\"\"\"",
    "functions": "Functions:\n1. 函数名: sock_close\n- 参数: [struct inode *inode, struct file *filp]\n- 调用者: 未明确（通常是文件操作关闭时的回调）\n- 被调用者: [SOCKET_I, sock_release]\n\n2. 函数名: SOCKET_I\n- 参数: [struct inode *inode]\n- 调用者: sock_close\n- 被调用者: []\n\n3. 函数名: sock_release\n- 参数: [socket结构体指针（由SOCKET_I返回）]\n- 调用者: sock_close\n- 被调用者: []"
  },
  {
    "id": 1651,
    "cwe": "CWE-362",
    "cve": "CVE-2018-12232",
    "purpose": "Code purpose:\"\"\"释放socket资源并处理相关清理操作，包括调用release函数、释放模块引用计数、检查fasync列表以及处理inode和文件描述符\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"fchownat未增加文件描述符引用计数导致与close并发操作时可能引发空指针解引用\"\"\"",
    "functions": "Functions:\n1. 函数名: sock_release\n- 参数: [struct socket *sock]\n- 调用者: 未明确（通常是socket关闭相关操作）\n- 被调用者: [sock->ops->release, module_put, rcu_dereference_protected, pr_err, iput]\n\n2. 函数名: sock->ops->release\n- 参数: [struct socket *sock]\n- 调用者: sock_release\n- 被调用者: 未明确（由具体socket操作实现决定）\n\n3. 函数名: module_put\n- 参数: [struct module *owner]\n- 调用者: sock_release\n- 被调用者: 未明确（内核模块相关函数）\n\n4. 函数名: rcu_dereference_protected\n- 参数: [sock->wq, 1]\n- 调用者: sock_release\n- 被调用者: 未明确（RCU相关函数）\n\n5. 函数名: pr_err\n- 参数: [\"%s: fasync list not empty!\\n\", __func__]\n- 调用者: sock_release\n- 被调用者: 未明确（内核打印函数）\n\n6. 函数名: iput\n- 参数: [SOCK_INODE(sock)]\n- 调用者: sock_release\n- 被调用者: 未明确（inode相关函数）"
  },
  {
    "id": 1653,
    "cwe": "CWE-362",
    "cve": "CVE-2018-12633",
    "purpose": "Code purpose:\"\"\"处理虚拟设备(VirtualBox Guest Additions)的IOCTL请求，包括验证请求头、分配缓冲区、数据拷贝和核心IOCTL操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于代码两次从用户空间读取相同数据且未加锁保护，导致恶意用户可利用竞争条件在两次读取之间篡改关键变量，造成双重获取漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: vbg_misc_device_ioctl\n- 参数: [struct file *filp, unsigned int req, unsigned long arg]\n- 调用者: 内核IOCTL处理机制\n- 被调用者: [copy_from_user, max, vbg_req_alloc, kmalloc, memset, vbg_core_ioctl, vbg_debug, copy_to_user, vbg_req_free, kfree]\n\n2. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: vbg_misc_device_ioctl\n- 被调用者: []\n\n3. 函数名: max\n- 参数: [long x, long y]\n- 调用者: vbg_misc_device_ioctl\n- 被调用者: []\n\n4. 函数名: vbg_req_alloc\n- 参数: [size_t size, int type]\n- 调用者: vbg_misc_device_ioctl\n- 被调用者: []\n\n5. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: vbg_misc_device_ioctl\n- 被调用者: []\n\n6. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: vbg_misc_device_ioctl\n- 被调用者: []\n\n7. 函数名: vbg_core_ioctl\n- 参数: [struct vbg_session *session, unsigned int req, void *buf]\n- 调用者: vbg_misc_device_ioctl\n- 被调用者: []\n\n8. 函数名: vbg_debug\n- 参数: [const char *fmt, ...]\n- 调用者: vbg_misc_device_ioctl\n- 被调用者: []\n\n9. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: vbg_misc_device_ioctl\n- 被调用者: []\n\n10. 函数名: vbg_req_free\n- 参数: [void *buf, size_t size]\n- 调用者: vbg_misc_device_ioctl\n- 被调用者: []\n\n11. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: vbg_misc_device_ioctl\n- 被调用者: []"
  },
  {
    "id": 1728,
    "cwe": "CWE-362",
    "cve": "CVE-2018-17972",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中通过proc文件系统展示指定进程的内核栈调用跟踪信息\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"该函数未对调用者权限进行充分验证，允许非root用户检查任意任务的内核堆栈，导致竞争条件下的堆栈展开可能泄露内核堆栈内容\"\"\"",
    "functions": "Functions:\n1. 函数名: proc_pid_stack\n- 参数: [struct seq_file *m, struct pid_namespace *ns, struct pid *pid, struct task_struct *task]\n- 调用者: N/A\n- 被调用者: [kmalloc_array, lock_trace, save_stack_trace_tsk, seq_printf, unlock_trace, kfree]\n\n2. 函数名: kmalloc_array\n- 参数: [MAX_STACK_TRACE_DEPTH, sizeof(*entries), GFP_KERNEL]\n- 调用者: proc_pid_stack\n- 被调用者: N/A\n\n3. 函数名: lock_trace\n- 参数: [struct task_struct *task]\n- 调用者: proc_pid_stack\n- 被调用者: N/A\n\n4. 函数名: save_stack_trace_tsk\n- 参数: [struct task_struct *task, struct stack_trace *trace]\n- 调用者: proc_pid_stack\n- 被调用者: N/A\n\n5. 函数名: seq_printf\n- 参数: [struct seq_file *m, \"[<0>] %pB\\n\", (void *)entries[i]]\n- 调用者: proc_pid_stack\n- 被调用者: N/A\n\n6. 函数名: unlock_trace\n- 参数: [struct task_struct *task]\n- 调用者: proc_pid_stack\n- 被调用者: N/A\n\n7. 函数名: kfree\n- 参数: [entries]\n- 调用者: proc_pid_stack\n- 被调用者: N/A"
  },
  {
    "id": 1739,
    "cwe": "CWE-362",
    "cve": "CVE-2018-18559",
    "purpose": "Code purpose:\"\"\"该代码实现了AF_PACKET套接字的绑定功能，处理网络设备与协议的绑定关系，并管理相关的资源引用计数。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多线程环境下对AF_PACKET套接字的fanout_add和bind操作存在竞争条件，导致未正确处理解注册和重新注册操作，从而引发use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: packet_do_bind\n- 参数: [sk, name, ifindex, proto]\n- 调用者: 未明确（应为外部调用）\n- 被调用者: [pkt_sk, lock_sock, spin_lock, rcu_read_lock, dev_get_by_name_rcu, dev_get_by_index_rcu, dev_hold, __unregister_prot_hook, dev_get_by_index_rcu, dev_put, packet_cached_dev_reset, packet_cached_dev_assign, register_prot_hook, rcu_read_unlock, spin_unlock, release_sock]\n\n2. 函数名: pkt_sk\n- 参数: [sk]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n3. 函数名: lock_sock\n- 参数: [sk]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n4. 函数名: spin_lock\n- 参数: [&po->bind_lock]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n5. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: packet_do_bind\n- 被调用者: []\n\n6. 函数名: dev_get_by_name_rcu\n- 参数: [sock_net(sk), name]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n7. 函数名: dev_get_by_index_rcu\n- 参数: [sock_net(sk), ifindex]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n8. 函数名: dev_hold\n- 参数: [dev]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n9. 函数名: __unregister_prot_hook\n- 参数: [sk, true]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n10. 函数名: dev_put\n- 参数: [dev_curr]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n11. 函数名: packet_cached_dev_reset\n- 参数: [po]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n12. 函数名: packet_cached_dev_assign\n- 参数: [po, dev]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n13. 函数名: register_prot_hook\n- 参数: [sk]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n14. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: packet_do_bind\n- 被调用者: []\n\n15. 函数名: spin_unlock\n- 参数: [&po->bind_lock]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n16. 函数名: release_sock\n- 参数: [sk]\n- 调用者: packet_do_bind\n- 被调用者: []"
  },
  {
    "id": 1782,
    "cwe": "CWE-362",
    "cve": "CVE-2018-20836",
    "purpose": "Code purpose:\"\"\"该代码用于处理SAS任务超时情况，在任务未完成时将其标记为已中止，并通过完成机制通知等待的进程。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于smp_task_timedout()和smp_task_done()之间存在竞争条件，导致在任务状态检查和处理完成时可能发生use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: smp_task_timedout\n- 参数: [struct timer_list *t]\n- 调用者: 内核定时器子系统\n- 被调用者: [from_timer, spin_lock_irqsave, spin_unlock_irqrestore, complete]\n\n2. 函数名: from_timer\n- 参数: [slow, t, timer]\n- 调用者: smp_task_timedout\n- 被调用者: []\n\n3. 函数名: spin_lock_irqsave\n- 参数: [&task->task_state_lock, flags]\n- 调用者: smp_task_timedout\n- 被调用者: []\n\n4. 函数名: spin_unlock_irqrestore\n- 参数: [&task->task_state_lock, flags]\n- 调用者: smp_task_timedout\n- 被调用者: []\n\n5. 函数名: complete\n- 参数: [&task->slow_task->completion]\n- 调用者: smp_task_timedout\n- 被调用者: []"
  },
  {
    "id": 1783,
    "cwe": "CWE-362",
    "cve": "CVE-2018-20836",
    "purpose": "Code purpose:\"\"\"在SAS扩展器驱动中处理慢速任务的完成，包括取消定时器和通知任务完成\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于smp_task_done()和smp_task_timedout()之间存在竞争条件，导致在定时器未被成功删除时可能发生释放后使用(UAF)问题\"\"\"",
    "functions": "Functions:\n1. 函数名: smp_task_done\n- 参数: [struct sas_task *task]\n- 调用者: 未明确（由系统或外部调用）\n- 被调用者: [del_timer, complete]\n\n2. 函数名: del_timer\n- 参数: [&task->slow_task->timer]\n- 调用者: smp_task_done\n- 被调用者: []\n\n3. 函数名: complete\n- 参数: [&task->slow_task->completion]\n- 调用者: smp_task_done\n- 被调用者: []"
  },
  {
    "id": 1821,
    "cwe": "CWE-362",
    "cve": "CVE-2018-5344",
    "purpose": "Code purpose:\"\"\"该代码用于管理loop设备的释放操作，包括处理引用计数、自动清除模式下的设备清理以及保持绑定状态时的队列刷新。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于lo_release函数中的互斥锁管理不当，导致在竞态条件下可能发生use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: lo_release\n- 参数: [disk, mode]\n- 调用者: 未明确显示（通常由块设备子系统调用）\n- 被调用者: [atomic_dec_return, mutex_lock, loop_clr_fd, blk_mq_freeze_queue, blk_mq_unfreeze_queue, mutex_unlock]\n\n2. 函数名: atomic_dec_return\n- 参数: [&lo->lo_refcnt]\n- 调用者: lo_release\n- 被调用者: []\n\n3. 函数名: mutex_lock\n- 参数: [&lo->lo_ctl_mutex]\n- 调用者: lo_release\n- 被调用者: []\n\n4. 函数名: loop_clr_fd\n- 参数: [lo]\n- 调用者: lo_release\n- 被调用者: []\n\n5. 函数名: blk_mq_freeze_queue\n- 参数: [lo->lo_queue]\n- 调用者: lo_release\n- 被调用者: []\n\n6. 函数名: blk_mq_unfreeze_queue\n- 参数: [lo->lo_queue]\n- 调用者: lo_release\n- 被调用者: []\n\n7. 函数名: mutex_unlock\n- 参数: [&lo->lo_ctl_mutex]\n- 调用者: lo_release\n- 被调用者: []"
  },
  {
    "id": 1829,
    "cwe": "CWE-362",
    "cve": "CVE-2018-5814",
    "purpose": "Code purpose:\"\"\"该代码用于处理USB设备的探测(probe)过程，包括设备验证、资源分配和端口声明，是Linux内核中USB/IP功能的一部分。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核处理USB over IP设备的probe、disconnect和rebind操作时存在多个竞态条件，导致可能发生释放后使用或空指针解引用漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: stub_probe\n- 参数: [struct usb_device *udev]\n- 调用者: 未被显示（由USB驱动框架调用）\n- 被调用者: [dev_name, get_busid_priv, dev_dbg, dev_info, strcmp, stub_device_alloc, dev_set_drvdata, usb_hub_claim_port, stub_add_files, usb_hub_release_port, usb_put_dev, stub_device_free]\n\n2. 函数名: dev_name\n- 参数: [struct device *dev]\n- 调用者: stub_probe\n- 被调用者: []\n\n3. 函数名: get_busid_priv\n- 参数: [const char *udev_busid]\n- 调用者: stub_probe\n- 被调用者: []\n\n4. 函数名: dev_dbg\n- 参数: [struct device *dev, const char *fmt, ...]\n- 调用者: stub_probe\n- 被调用者: []\n\n5. 函数名: dev_info\n- 参数: [struct device *dev, const char *fmt, ...]\n- 调用者: stub_probe\n- 被调用者: []\n\n6. 函数名: strcmp\n- 参数: [const char *s1, const char *s2]\n- 调用者: stub_probe\n- 被调用者: []\n\n7. 函数名: stub_device_alloc\n- 参数: [struct usb_device *udev]\n- 调用者: stub_probe\n- 被调用者: []\n\n8. 函数名: dev_set_drvdata\n- 参数: [struct device *dev, void *data]\n- 调用者: stub_probe\n- 被调用者: []\n\n9. 函数名: usb_hub_claim_port\n- 参数: [struct usb_device *hdev, unsigned port1, struct usb_dev_state *owner]\n- 调用者: stub_probe\n- 被调用者: []\n\n10. 函数名: stub_add_files\n- 参数: [struct device *dev]\n- 调用者: stub_probe\n- 被调用者: []\n\n11. 函数名: usb_hub_release_port\n- 参数: [struct usb_device *hdev, unsigned port1, struct usb_dev_state *owner]\n- 调用者: stub_probe\n- 被调用者: []\n\n12. 函数名: usb_put_dev\n- 参数: [struct usb_device *udev]\n- 调用者: stub_probe\n- 被调用者: []\n\n13. 函数名: stub_device_free\n- 参数: [struct stub_device *sdev]\n- 调用者: stub_probe\n- 被调用者: []"
  },
  {
    "id": 1830,
    "cwe": "CWE-362",
    "cve": "CVE-2018-5814",
    "purpose": "Code purpose:\"\"\"处理USB/IP设备的断开连接操作，包括释放资源、关闭连接和清理设备状态\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核处理USB over IP设备的探测、断开和重新绑定时，存在多个竞态条件，导致可能发生释放后使用或空指针解引用漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: stub_disconnect\n- 参数: [struct usb_device *udev]\n- 调用者: 未显示\n- 被调用者: [dev_name, get_busid_priv, dev_get_drvdata, dev_set_drvdata, stub_remove_files, usb_hub_release_port, usbip_in_eh, shutdown_busid, usb_put_dev, stub_device_free]\n\n2. 函数名: dev_name\n- 参数: [&udev->dev]\n- 调用者: stub_disconnect\n- 被调用者: 未显示\n\n3. 函数名: get_busid_priv\n- 参数: [udev_busid]\n- 调用者: stub_disconnect\n- 被调用者: 未显示\n\n4. 函数名: dev_get_drvdata\n- 参数: [&udev->dev]\n- 调用者: stub_disconnect\n- 被调用者: 未显示\n\n5. 函数名: dev_set_drvdata\n- 参数: [&udev->dev, NULL]\n- 调用者: stub_disconnect\n- 被调用者: 未显示\n\n6. 函数名: stub_remove_files\n- 参数: [&udev->dev]\n- 调用者: stub_disconnect\n- 被调用者: 未显示\n\n7. 函数名: usb_hub_release_port\n- 参数: [udev->parent, udev->portnum, (struct usb_dev_state *) udev]\n- 调用者: stub_disconnect\n- 被调用者: 未显示\n\n8. 函数名: usbip_in_eh\n- 参数: [current]\n- 调用者: stub_disconnect\n- 被调用者: 未显示\n\n9. 函数名: shutdown_busid\n- 参数: [busid_priv]\n- 调用者: stub_disconnect\n- 被调用者: 未显示\n\n10. 函数名: usb_put_dev\n- 参数: [sdev->udev]\n- 调用者: stub_disconnect\n- 被调用者: 未显示\n\n11. 函数名: stub_device_free\n- 参数: [sdev]\n- 调用者: stub_disconnect\n- 被调用者: 未显示"
  },
  {
    "id": 1831,
    "cwe": "CWE-362",
    "cve": "CVE-2018-5814",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理USB over IP设备的busid匹配删除操作，包括状态检查和清理工作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在USB over IP处理过程中，由于缺乏对busid_table_lock锁的适当保护，导致多个线程在并发访问busid_table时可能引发竞态条件，从而造成使用后释放或空指针解引用漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: del_match_busid\n- 参数: [char *busid]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [get_busid_idx, memset, spin_lock, spin_unlock]\n\n2. 函数名: get_busid_idx\n- 参数: [char *busid]\n- 调用者: del_match_busid\n- 被调用者: 未明确（上下文未提供）\n\n3. 函数名: spin_lock\n- 参数: [&busid_table_lock]\n- 调用者: del_match_busid\n- 被调用者: 未明确（上下文未提供）\n\n4. 函数名: spin_unlock\n- 参数: [&busid_table_lock]\n- 调用者: del_match_busid\n- 被调用者: 未明确（上下文未提供）\n\n5. 函数名: memset\n- 参数: [busid_table[idx].name, 0, BUSID_SIZE]\n- 调用者: del_match_busid\n- 被调用者: 未明确（上下文未提供）"
  },
  {
    "id": 1832,
    "cwe": "CWE-362",
    "cve": "CVE-2018-5814",
    "purpose": "Code purpose:\"\"\"该代码用于显示总线ID表中所有非空名称的总线ID，并将它们格式化为字符串输出到缓冲区\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确处理多线程竞争条件，导致在访问busid_table时可能发生竞态条件，从而引发使用后释放或空指针解引用漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: match_busid_show\n- 参数: [struct device_driver *drv, char *buf]\n- 调用者: 未明确显示（通常由设备驱动框架调用）\n- 被调用者: [spin_lock, spin_unlock, sprintf]\n\n2. 函数名: spin_lock\n- 参数: [&busid_table_lock]\n- 调用者: match_busid_show\n- 被调用者: []\n\n3. 函数名: spin_unlock\n- 参数: [&busid_table_lock]\n- 调用者: match_busid_show\n- 被调用者: []\n\n4. 函数名: sprintf\n- 参数: [out, \"%s \", busid_table[i].name] 和 [out, \"\\n\"]\n- 调用者: match_busid_show\n- 被调用者: []"
  },
  {
    "id": 1833,
    "cwe": "CWE-362",
    "cve": "CVE-2018-5814",
    "purpose": "Code purpose:\"\"\"通过总线ID获取对应的总线私有数据结构，并在操作期间使用自旋锁保护共享资源\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在获取总线ID私有结构时未正确处理竞态条件，导致在锁释放后可能发生引用已释放内存或空指针解引用的情况\"\"\"",
    "functions": "Functions:\n1. 函数名: get_busid_priv\n- 参数: [busid]\n- 调用者: 未明确（上下文不足）\n- 被调用者: [spin_lock, get_busid_idx, spin_unlock]\n\n2. 函数名: spin_lock\n- 参数: [&busid_table_lock]\n- 调用者: get_busid_priv\n- 被调用者: 未明确（内核内部函数）\n\n3. 函数名: get_busid_idx\n- 参数: [busid]\n- 调用者: get_busid_priv\n- 被调用者: 未明确（上下文不足）\n\n4. 函数名: spin_unlock\n- 参数: [&busid_table_lock]\n- 调用者: get_busid_priv\n- 被调用者: 未明确（内核内部函数）"
  },
  {
    "id": 1834,
    "cwe": "CWE-362",
    "cve": "CVE-2018-5814",
    "purpose": "Code purpose:\"\"\"在USB/IP主机模式下处理设备重新绑定的操作，包括更新设备状态和执行重新绑定\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在USB over IP处理probe、disconnect和rebind操作时存在多个竞态条件，导致可能发生use-after-free或空指针解引用漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: stub_device_rebind\n- 参数: []\n- 调用者: N/A (static function, called externally but caller not shown in snippet)\n- 被调用者: [do_rebind]\n\n2. 函数名: do_rebind\n- 参数: [busid_table[i].name, busid_priv]\n- 调用者: stub_device_rebind\n- 被调用者: [] (not shown in snippet)"
  },
  {
    "id": 1835,
    "cwe": "CWE-362",
    "cve": "CVE-2018-5814",
    "purpose": "Code purpose:\"\"\"初始化USB over IP总线ID表并设置自旋锁\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确处理USB over IP设备在多线程环境下的探测、断开和重新绑定操作的竞争条件，导致可能发生释放后使用或空指针解引用漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: init_busid_table\n- 参数: []\n- 调用者: 未显示（上下文不足）\n- 被调用者: [memset, spin_lock_init]\n\n2. 函数名: memset\n- 参数: [busid_table, 0, sizeof(busid_table)]\n- 调用者: init_busid_table\n- 被调用者: []\n\n3. 函数名: spin_lock_init\n- 参数: [&busid_table_lock]\n- 调用者: init_busid_table\n- 被调用者: []"
  },
  {
    "id": 1836,
    "cwe": "CWE-362",
    "cve": "CVE-2018-5814",
    "purpose": "Code purpose:\"\"\"处理USB over IP设备的重新绑定操作，包括验证输入、标记设备状态、执行重新绑定以及从总线ID表中删除设备\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在USB over IP处理probe、disconnect和rebind操作时存在竞态条件，导致可能发生use-after-free或空指针解引用漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: rebind_store\n- 参数: [struct device_driver *dev, const char *buf, size_t count]\n- 调用者: 未明确（通常由设备驱动框架调用）\n- 被调用者: [strnlen, get_busid_priv, do_rebind, del_match_busid]\n\n2. 函数名: strnlen\n- 参数: [const char *buf, size_t BUSID_SIZE]\n- 调用者: rebind_store\n- 被调用者: []\n\n3. 函数名: get_busid_priv\n- 参数: [const char *buf]\n- 调用者: rebind_store\n- 被调用者: []\n\n4. 函数名: do_rebind\n- 参数: [char *buf, struct bus_id_priv *bid]\n- 调用者: rebind_store\n- 被调用者: []\n\n5. 函数名: del_match_busid\n- 参数: [char *buf]\n- 调用者: rebind_store\n- 被调用者: []"
  },
  {
    "id": 1837,
    "cwe": "CWE-362",
    "cve": "CVE-2018-5814",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中管理USB over IP设备的busid表，实现busid的添加和状态管理功能\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在USB over IP处理过程中存在竞态条件，导致在探测、断开和重新绑定操作时可能引发使用后释放或空指针解引用问题\"\"\"",
    "functions": "Functions:\n1. 函数名: add_match_busid\n- 参数: [char *busid]\n- 调用者: 未明确（上下文不足）\n- 被调用者: [get_busid_idx, strlcpy]\n\n2. 函数名: get_busid_idx\n- 参数: [char *busid]（根据调用上下文推断）\n- 调用者: add_match_busid\n- 被调用者: 未明确（上下文不足）\n\n3. 函数名: strlcpy\n- 参数: [char *dest, const char *src, size_t size]（标准库函数参数）\n- 调用者: add_match_busid\n- 被调用者: 无（标准库函数）\n\n4. 函数名: spin_lock\n- 参数: [spinlock_t *lock]（标准内核函数参数）\n- 调用者: add_match_busid\n- 被调用者: 无（内核API）\n\n5. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]（标准内核函数参数）\n- 调用者: add_match_busid\n- 被调用者: 无（内核API）"
  },
  {
    "id": 1838,
    "cwe": "CWE-362",
    "cve": "CVE-2018-5814",
    "purpose": "Code purpose:\"\"\"在总线ID表中查找与给定总线ID匹配的索引\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在处理USB over IP设备的探测、断开和重新绑定时存在竞态条件，导致在并发操作时可能发生使用后释放或空指针解引用漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: get_busid_idx\n- 参数: [const char *busid]\n- 调用者: 未提供（上下文不足）\n- 被调用者: [strncmp]"
  },
  {
    "id": 1840,
    "cwe": "CWE-362",
    "cve": "CVE-2018-5873",
    "purpose": "Code purpose:\"\"\"该代码用于获取命名空间文件的路径，处理命名空间文件系统的挂载点和目录项，并管理相关资源的引用计数。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在访问文件时存在竞态条件，导致在__ns_get_path函数中可能发生释放后使用(UAF)的情况。\"\"\"",
    "functions": "Functions:\n1. 函数名: __ns_get_path\n- 参数: [struct path *path, struct ns_common *ns]\n- 调用者: N/A\n- 被调用者: [atomic_long_read, lockref_get_not_dead, mntget, new_inode_pseudo, current_time, d_alloc_pseudo, iput, d_instantiate, atomic_long_cmpxchg, d_delete, dput, cpu_relax]\n\n2. 函数名: atomic_long_read\n- 参数: [&ns->stashed]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n3. 函数名: lockref_get_not_dead\n- 参数: [&dentry->d_lockref]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n4. 函数名: mntget\n- 参数: [mnt]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n5. 函数名: new_inode_pseudo\n- 参数: [mnt->mnt_sb]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n6. 函数名: current_time\n- 参数: [inode]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n7. 函数名: d_alloc_pseudo\n- 参数: [mnt->mnt_sb, &qname]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n8. 函数名: iput\n- 参数: [inode]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n9. 函数名: d_instantiate\n- 参数: [dentry, inode]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n10. 函数名: atomic_long_cmpxchg\n- 参数: [&ns->stashed, 0, (unsigned long)dentry]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n11. 函数名: d_delete\n- 参数: [dentry]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n12. 函数名: dput\n- 参数: [dentry]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n13. 函数名: cpu_relax\n- 参数: []\n- 调用者: __ns_get_path\n- 被调用者: N/A"
  },
  {
    "id": 1847,
    "cwe": "CWE-362",
    "cve": "CVE-2018-7566",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中音序器设备(/dev/snd/seq)的事件写入功能，处理用户空间传递的MIDI事件数据并将其加入客户端队列。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证用户提供的输入数据长度，导致在SNDRV_SEQ_IOCTL_SET_CLIENT_POOL ioctl操作中可能发生缓冲区溢出\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_seq_write\n- 参数: [struct file *file, const char __user *buf, size_t count, loff_t *offset]\n- 调用者: 无（系统调用接口）\n- 被调用者: [snd_seq_file_flags, snd_BUG_ON, snd_seq_write_pool_allocated, snd_seq_pool_init, copy_from_user, check_event_type_and_length, snd_seq_ev_is_reserved, snd_seq_ev_is_variable, snd_seq_ev_is_varusr, snd_seq_client_enqueue_event]\n\n2. 函数名: snd_seq_file_flags\n- 参数: [struct file *file]\n- 调用者: snd_seq_write\n- 被调用者: 无\n\n3. 函数名: snd_BUG_ON\n- 参数: [!client]\n- 调用者: snd_seq_write\n- 被调用者: 无\n\n4. 函数名: snd_seq_write_pool_allocated\n- 参数: [struct snd_seq_client *client]\n- 调用者: snd_seq_write\n- 被调用者: 无\n\n5. 函数名: snd_seq_pool_init\n- 参数: [client->pool]\n- 调用者: snd_seq_write\n- 被调用者: 无\n\n6. 函数名: copy_from_user\n- 参数: [&event, buf, len]\n- 调用者: snd_seq_write\n- 被调用者: 无\n\n7. 函数名: check_event_type_and_length\n- 参数: [&event]\n- 调用者: snd_seq_write\n- 被调用者: 无\n\n8. 函数名: snd_seq_ev_is_reserved\n- 参数: [&event]\n- 调用者: snd_seq_write\n- 被调用者: 无\n\n9. 函数名: snd_seq_ev_is_variable\n- 参数: [&event]\n- 调用者: snd_seq_write\n- 被调用者: 无\n\n10. 函数名: snd_seq_ev_is_varusr\n- 参数: [&event]\n- 调用者: snd_seq_write\n- 被调用者: 无\n\n11. 函数名: snd_seq_client_enqueue_event\n- 参数: [client, &event, file, !(file->f_flags & O_NONBLOCK), 0, 0]\n- 调用者: snd_seq_write\n- 被调用者: 无"
  },
  {
    "id": 1855,
    "cwe": "CWE-362",
    "cve": "CVE-2018-7995",
    "purpose": "Code purpose:\"\"\"该代码用于在存储整数值后重启机器检查异常(MCE)功能，但存在竞态条件漏洞可能导致拒绝服务\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于store_int_with_restart函数中存在竞态条件，当本地用户以root权限写入check_interval文件时可能导致拒绝服务(系统崩溃)。\"\"\"",
    "functions": "Functions:\n1. 函数名: store_int_with_restart\n- 参数: [struct device *s, struct device_attribute *attr, const char *buf, size_t size]\n- 调用者: 未明确（由系统调用触发）\n- 被调用者: [device_store_int, mce_restart]\n\n2. 函数名: device_store_int\n- 参数: [struct device *s, struct device_attribute *attr, const char *buf, size_t size]\n- 调用者: store_int_with_restart\n- 被调用者: 未明确\n\n3. 函数名: mce_restart\n- 参数: []\n- 调用者: store_int_with_restart\n- 被调用者: 未明确"
  },
  {
    "id": 1856,
    "cwe": "CWE-362",
    "cve": "CVE-2018-7995",
    "purpose": "Code purpose:\"\"\"该代码用于设置和切换CMCI(Corrected Machine Check Interrupt)的启用或禁用状态，通过系统调用接口修改配置并同步到所有CPU核心。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在修改CMCI(Corrected Machine Check Interrupt)状态时存在竞态条件，导致本地用户可能通过写入/sys文件系统触发拒绝服务(panic)。\"\"\"",
    "functions": "Functions:\n1. 函数名: set_cmci_disabled\n- 参数: [struct device *s, struct device_attribute *attr, const char *buf, size_t size]\n- 调用者: 未明确（由设备属性文件操作触发）\n- 被调用者: [kstrtou64, on_each_cpu, mce_disable_cmci, mce_enable_ce]\n\n2. 函数名: kstrtou64\n- 参数: [const char *buf, 0, u64 *new]\n- 调用者: set_cmci_disabled\n- 被调用者: 未明确（内核函数）\n\n3. 函数名: on_each_cpu\n- 参数: [mce_disable_cmci, NULL, 1] 或 [mce_enable_ce, NULL, 1]\n- 调用者: set_cmci_disabled\n- 被调用者: [mce_disable_cmci, mce_enable_ce]\n\n4. 函数名: mce_disable_cmci\n- 参数: [NULL]\n- 调用者: on_each_cpu\n- 被调用者: 未明确\n\n5. 函数名: mce_enable_ce\n- 参数: [NULL]\n- 调用者: on_each_cpu\n- 被调用者: 未明确"
  },
  {
    "id": 1857,
    "cwe": "CWE-362",
    "cve": "CVE-2018-7995",
    "purpose": "Code purpose:\"\"\"该代码用于设置是否忽略CPU的可纠正错误(CE)功能，通过sysfs接口允许root用户动态启用或禁用CE相关特性\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在修改mca_cfg.ignore_ce标志时缺乏适当的同步机制，导致竞争条件可能引发系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: set_ignore_ce\n- 参数: [s, attr, buf, size]\n- 调用者: 未明确（通常由sysfs调用）\n- 被调用者: [kstrtou64, mce_timer_delete_all, on_each_cpu, mce_disable_cmci, mce_enable_ce]\n\n2. 函数名: kstrtou64\n- 参数: [buf, 0, &new]\n- 调用者: set_ignore_ce\n- 被调用者: 无（内核基础函数）\n\n3. 函数名: mce_timer_delete_all\n- 参数: []\n- 调用者: set_ignore_ce\n- 被调用者: 无\n\n4. 函数名: on_each_cpu\n- 参数: [mce_disable_cmci, NULL, 1] 或 [mce_enable_ce, (void *)1, 1]\n- 调用者: set_ignore_ce\n- 被调用者: [mce_disable_cmci, mce_enable_ce]\n\n5. 函数名: mce_disable_cmci\n- 参数: [NULL]\n- 调用者: on_each_cpu\n- 被调用者: 无\n\n6. 函数名: mce_enable_ce\n- 参数: [(void *)1]\n- 调用者: on_each_cpu\n- 被调用者: 无"
  },
  {
    "id": 1862,
    "cwe": "CWE-362",
    "cve": "CVE-2018-8897",
    "purpose": "Code purpose:\"\"\"处理x86架构下的int3断点中断，包括动态ftrace、kgdb调试、kprobes探测等多种情况的处理\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"操作系统内核在处理MOV SS或POP SS指令后的调试异常时，未能正确处理异常延迟传递的情况，导致在特权级别切换时出现意外的调试异常处理顺序。\"\"\"",
    "functions": "Functions:\n1. 函数名: do_int3\n- 参数: [struct pt_regs *regs, long error_code]\n- 调用者: 未显示（中断处理入口）\n- 被调用者: [atomic_read, ftrace_int3_handler, poke_int3_handler, ist_enter, rcu_is_watching, RCU_LOCKDEP_WARN, kgdb_ll_trap, kprobe_int3_handler, notify_die, debug_stack_usage_inc, cond_local_irq_enable, do_trap, cond_local_irq_disable, debug_stack_usage_dec, ist_exit]\n\n2. 函数名: ftrace_int3_handler\n- 参数: [struct pt_regs *regs]\n- 调用者: do_int3\n- 被调用者: 未显示\n\n3. 函数名: poke_int3_handler\n- 参数: [struct pt_regs *regs]\n- 调用者: do_int3\n- 被调用者: 未显示\n\n4. 函数名: ist_enter\n- 参数: [struct pt_regs *regs]\n- 调用者: do_int3\n- 被调用者: 未显示\n\n5. 函数名: rcu_is_watching\n- 参数: []\n- 调用者: do_int3\n- 被调用者: 未显示\n\n6. 函数名: RCU_LOCKDEP_WARN\n- 参数: [!rcu_is_watching(), \"entry code didn't wake RCU\"]\n- 调用者: do_int3\n- 被调用者: 未显示\n\n7. 函数名: kgdb_ll_trap\n- 参数: [DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP, SIGTRAP]\n- 调用者: do_int3\n- 被调用者: 未显示\n\n8. 函数名: kprobe_int3_handler\n- 参数: [struct pt_regs *regs]\n- 调用者: do_int3\n- 被调用者: 未显示\n\n9. 函数名: notify_die\n- 参数: [DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP, SIGTRAP]\n- 调用者: do_int3\n- 被调用者: 未显示\n\n10. 函数名: debug_stack_usage_inc\n- 参数: []\n- 调用者: do_int3\n- 被调用者: 未显示\n\n11. 函数名: cond_local_irq_enable\n- 参数: [struct pt_regs *regs]\n- 调用者: do_int3\n- 被调用者: 未显示\n\n12. 函数名: do_trap\n- 参数: [X86_TRAP_BP, SIGTRAP, \"int3\", regs, error_code, NULL]\n- 调用者: do_int3\n- 被调用者: 未显示\n\n13. 函数名: cond_local_irq_disable\n- 参数: [struct pt_regs *regs]\n- 调用者: do_int3\n- 被调用者: 未显示\n\n14. 函数名: debug_stack_usage_dec\n- 参数: []\n- 调用者: do_int3\n- 被调用者: 未显示\n\n15. 函数名: ist_exit\n- 参数: [struct pt_regs *regs]\n- 调用者: do_int3\n- 被调用者: 未显示"
  },
  {
    "id": 1935,
    "cwe": "CWE-362",
    "cve": "CVE-2019-11815",
    "purpose": "Code purpose:\"\"\"该代码用于在网络命名空间清理时停止RDS-TCP监听并销毁相关连接，但存在竞态条件导致释放后使用漏洞\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在清理网络命名空间时，由于缺乏适当的同步机制，导致竞态条件下可能发生对已释放内存的访问，形成use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: rds_tcp_kill_sock\n- 参数: [net]\n- 调用者: N/A\n- 被调用者: [net_generic, rds_tcp_listen_stop, read_pnet, list_has_conn, list_move_tail, list_del, spin_lock_irq, spin_unlock_irq, list_for_each_entry_safe, rds_conn_destroy]\n\n2. 函数名: net_generic\n- 参数: [net, rds_tcp_netid]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n3. 函数名: rds_tcp_listen_stop\n- 参数: [lsock, &rtn->rds_tcp_accept_w]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n4. 函数名: read_pnet\n- 参数: [&tc->t_cpath->cp_conn->c_net]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n5. 函数名: list_has_conn\n- 参数: [&tmp_list, tc->t_cpath->cp_conn]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n6. 函数名: list_move_tail\n- 参数: [&tc->t_tcp_node, &tmp_list]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n7. 函数名: list_del\n- 参数: [&tc->t_tcp_node]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n8. 函数名: spin_lock_irq\n- 参数: [&rds_tcp_conn_lock]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n9. 函数名: spin_unlock_irq\n- 参数: [&rds_tcp_conn_lock]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n10. 函数名: list_for_each_entry_safe\n- 参数: [tc, _tc, &rds_tcp_conn_list, t_tcp_node]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n11. 函数名: rds_conn_destroy\n- 参数: [tc->t_cpath->cp_conn]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A"
  },
  {
    "id": 1957,
    "cwe": "CWE-362",
    "cve": "CVE-2019-13233",
    "purpose": "Code purpose:\"\"\"获取指定段寄存器的段限制值，考虑段描述符的粒度标志位并进行相应计算\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于modify_ldt()和#BR异常处理之间存在竞争条件，导致对LDT条目的访问出现释放后使用(UAF)问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: get_seg_limit\n- 参数: [struct pt_regs *regs, int seg_reg_idx]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [get_segment_selector, user_64bit_mode, v8086_mode, get_desc, get_desc_limit]\n\n2. 函数名: get_segment_selector\n- 参数: [struct pt_regs *regs, int seg_reg_idx]\n- 调用者: get_seg_limit\n- 被调用者: 未明确\n\n3. 函数名: user_64bit_mode\n- 参数: [struct pt_regs *regs]\n- 调用者: get_seg_limit\n- 被调用者: 未明确\n\n4. 函数名: v8086_mode\n- 参数: [struct pt_regs *regs]\n- 调用者: get_seg_limit\n- 被调用者: 未明确\n\n5. 函数名: get_desc\n- 参数: [short sel]\n- 调用者: get_seg_limit\n- 被调用者: 未明确\n\n6. 函数名: get_desc_limit\n- 参数: [struct desc_struct *desc]\n- 调用者: get_seg_limit\n- 被调用者: 未明确"
  },
  {
    "id": 1958,
    "cwe": "CWE-362",
    "cve": "CVE-2019-13233",
    "purpose": "Code purpose:\"\"\"该代码用于获取x86架构下代码段的相关参数，包括地址大小和操作数大小，并处理不同模式下的段描述符设置。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于modify_ldt()和#BR异常处理之间存在竞争条件，导致对LDT条目的访问出现释放后使用(UAF)问题\"\"\"",
    "functions": "Functions:\n1. 函数名: insn_get_code_seg_params\n- 参数: [struct pt_regs *regs]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [v8086_mode, get_segment_selector, get_desc]\n\n2. 函数名: v8086_mode\n- 参数: [struct pt_regs *regs]\n- 调用者: insn_get_code_seg_params\n- 被调用者: []\n\n3. 函数名: get_segment_selector\n- 参数: [struct pt_regs *regs, INAT_SEG_REG_CS]\n- 调用者: insn_get_code_seg_params\n- 被调用者: []\n\n4. 函数名: get_desc\n- 参数: [short sel]\n- 调用者: insn_get_code_seg_params\n- 被调用者: []"
  },
  {
    "id": 1959,
    "cwe": "CWE-362",
    "cve": "CVE-2019-13233",
    "purpose": "Code purpose:\"\"\"获取指定段寄存器的基地址，处理不同模式下的段选择子并返回对应的基地址\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于modify_ldt()和#BR异常处理之间存在竞争条件，导致对LDT条目的访问出现释放后使用问题\"\"\"",
    "functions": "Functions:\n1. 函数名: insn_get_seg_base\n- 参数: [struct pt_regs *regs, int seg_reg_idx]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [get_segment_selector, v8086_mode, user_64bit_mode, rdmsrl, get_desc, get_desc_base]\n\n2. 函数名: get_segment_selector\n- 参数: [struct pt_regs *regs, int seg_reg_idx]\n- 调用者: insn_get_seg_base\n- 被调用者: 未明确\n\n3. 函数名: v8086_mode\n- 参数: [struct pt_regs *regs]\n- 调用者: insn_get_seg_base\n- 被调用者: 未明确\n\n4. 函数名: user_64bit_mode\n- 参数: [struct pt_regs *regs]\n- 调用者: insn_get_seg_base\n- 被调用者: 未明确\n\n5. 函数名: rdmsrl\n- 参数: [MSR_FS_BASE/MSR_KERNEL_GS_BASE, unsigned long base]\n- 调用者: insn_get_seg_base\n- 被调用者: 未明确\n\n6. 函数名: get_desc\n- 参数: [short sel]\n- 调用者: insn_get_seg_base\n- 被调用者: 未明确\n\n7. 函数名: get_desc_base\n- 参数: [struct desc_struct *desc]\n- 调用者: insn_get_seg_base\n- 被调用者: 未明确"
  },
  {
    "id": 2091,
    "cwe": "CWE-362",
    "cve": "CVE-2019-18683",
    "purpose": "Code purpose:\"\"\"停止视频捕获流并释放相关资源，处理多个流类型的活动缓冲区，确保在停止所有流后关闭控制线程。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在停止视频流生成时存在多个竞态条件，由于vivid_stop_generating_vid_cap()等函数中错误的互斥锁使用导致使用后释放漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: vivid_stop_generating_vid_cap\n- 参数: [struct vivid_dev *dev, bool *pstreaming]\n- 调用者: 未显示\n- 被调用者: [list_empty, list_entry, list_del, v4l2_ctrl_request_complete, vb2_buffer_done, dprintk, vivid_grab_controls, mutex_unlock, kthread_stop, mutex_lock]\n\n2. 函数名: dprintk\n- 参数: [struct vivid_dev *dev, int level, const char *fmt, ...]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示\n\n3. 函数名: list_empty\n- 参数: [struct list_head *list]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示\n\n4. 函数名: list_entry\n- 参数: [struct list_head *ptr, type, member]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示\n\n5. 函数名: list_del\n- 参数: [struct list_head *entry]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示\n\n6. 函数名: v4l2_ctrl_request_complete\n- 参数: [struct v4l2_ctrl_handler *hdl, struct v4l2_ctrl_handler *parent]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示\n\n7. 函数名: vb2_buffer_done\n- 参数: [struct vb2_buffer *vb, enum vb2_buffer_state state]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示\n\n8. 函数名: vivid_grab_controls\n- 参数: [struct vivid_dev *dev, bool grab]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示\n\n9. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示\n\n10. 函数名: kthread_stop\n- 参数: [struct task_struct *k]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示\n\n11. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示"
  },
  {
    "id": 2092,
    "cwe": "CWE-362",
    "cve": "CVE-2019-18683",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中V4L2子系统vivid驱动程序的视频捕获线程功能，负责管理视频流捕获过程中的帧计数、时间计算和缓冲区同步等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在视频流停止过程中存在多个竞态条件，由于vivid_stop_generating_vid_cap()等函数及其对应的kthreads中错误的互斥锁使用导致使用后释放漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: vivid_thread_vid_cap\n- 参数: [data]\n- 调用者: 未被显示（通常由kthread_create或类似函数调用）\n- 被调用者: [dprintk, set_freezable, ktime_get_ns, vivid_cap_update_frame_period, try_to_freeze, kthread_should_stop, mutex_lock, vivid_thread_vid_cap_tick, mutex_unlock, schedule_timeout_interruptible]\n\n2. 函数名: dprintk\n- 参数: [dev, 1, format_string]\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n3. 函数名: set_freezable\n- 参数: []\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n4. 函数名: ktime_get_ns\n- 参数: []\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n5. 函数名: vivid_cap_update_frame_period\n- 参数: [dev]\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n6. 函数名: try_to_freeze\n- 参数: []\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n7. 函数名: kthread_should_stop\n- 参数: []\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n8. 函数名: mutex_lock\n- 参数: [&dev->mutex]\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n9. 函数名: vivid_thread_vid_cap_tick\n- 参数: [dev, dropped_bufs]\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n10. 函数名: mutex_unlock\n- 参数: [&dev->mutex]\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n11. 函数名: schedule_timeout_interruptible\n- 参数: [wait_jiffies ? wait_jiffies : 1]\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n12. 函数名: do_div\n- 参数: [buffers_since_start, HZ * numerator]\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []"
  },
  {
    "id": 2093,
    "cwe": "CWE-362",
    "cve": "CVE-2019-18683",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中V4L2子系统vivid驱动视频输出线程的功能，负责管理视频流的帧同步和时间计算，但存在竞争条件导致可能的使用后释放漏洞。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在视频输出线程中存在竞态条件，由于错误的互斥锁使用导致在停止流媒体时可能发生use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: vivid_thread_vid_out\n- 参数: [data]\n- 调用者: 未知（由内核线程调用）\n- 被调用者: [dprintk, set_freezable, try_to_freeze, kthread_should_stop, mutex_lock, mutex_unlock, vivid_thread_vid_out_tick, do_div, schedule_timeout_interruptible]\n\n2. 函数名: dprintk\n- 参数: [dev, 1, format_string]\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n3. 函数名: set_freezable\n- 参数: []\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n4. 函数名: try_to_freeze\n- 参数: []\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n5. 函数名: kthread_should_stop\n- 参数: []\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n6. 函数名: mutex_lock\n- 参数: [&dev->mutex]\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n7. 函数名: mutex_unlock\n- 参数: [&dev->mutex]\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n8. 函数名: vivid_thread_vid_out_tick\n- 参数: [dev]\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n9. 函数名: do_div\n- 参数: [buffers_since_start, HZ * numerator]\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n10. 函数名: schedule_timeout_interruptible\n- 参数: [wait_jiffies ? wait_jiffies : 1]\n- 调用者: vivid_thread_vid_out\n- 被调用者: []"
  },
  {
    "id": 2094,
    "cwe": "CWE-362",
    "cve": "CVE-2019-18683",
    "purpose": "Code purpose:\"\"\"停止视频输出流并释放相关资源，处理不同流类型的缓冲区清理工作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在停止视频流生成时存在多个竞态条件，由于错误的互斥锁锁定机制导致可能发生释放后使用(UAF)漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: vivid_stop_generating_vid_out\n- 参数: [dev, pstreaming]\n- 调用者: 未明确显示（应为外部调用）\n- 被调用者: [dprintk, list_empty, list_entry, list_del, v4l2_ctrl_request_complete, vb2_buffer_done, vivid_grab_controls, mutex_unlock, kthread_stop, mutex_lock]\n\n2. 函数名: dprintk\n- 参数: [dev, level, format, ...]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n3. 函数名: list_empty\n- 参数: [list_head]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n4. 函数名: list_entry\n- 参数: [ptr, type, member]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n5. 函数名: list_del\n- 参数: [entry]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n6. 函数名: v4l2_ctrl_request_complete\n- 参数: [req, hdl]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n7. 函数名: vb2_buffer_done\n- 参数: [vb, state]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n8. 函数名: vivid_grab_controls\n- 参数: [dev, grab]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n9. 函数名: mutex_unlock\n- 参数: [lock]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n10. 函数名: kthread_stop\n- 参数: [kthread]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n11. 函数名: mutex_lock\n- 参数: [lock]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []"
  },
  {
    "id": 2095,
    "cwe": "CWE-362",
    "cve": "CVE-2019-18683",
    "purpose": "Code purpose:\"\"\"停止SDR捕获流并清理相关资源，包括处理活动缓冲区列表和控制线程的关闭\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在停止流媒体时存在竞态条件，由于错误的互斥锁锁定机制导致可能发生释放后使用漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: sdr_cap_stop_streaming\n- 参数: [struct vb2_queue *vq]\n- 调用者: 未明确（由V4L2子系统调用）\n- 被调用者: [vb2_get_drv_priv, list_empty, list_entry, list_del, v4l2_ctrl_request_complete, vb2_buffer_done, mutex_unlock, kthread_stop, mutex_lock]\n\n2. 函数名: vb2_get_drv_priv\n- 参数: [struct vb2_queue *vq]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n3. 函数名: list_empty\n- 参数: [&dev->sdr_cap_active]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n4. 函数名: list_entry\n- 参数: [dev->sdr_cap_active.next, struct vivid_buffer, list]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n5. 函数名: list_del\n- 参数: [&buf->list]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n6. 函数名: v4l2_ctrl_request_complete\n- 参数: [buf->vb.vb2_buf.req_obj.req, &dev->ctrl_hdl_sdr_cap]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n7. 函数名: vb2_buffer_done\n- 参数: [&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n8. 函数名: mutex_unlock\n- 参数: [&dev->mutex]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n9. 函数名: kthread_stop\n- 参数: [dev->kthread_sdr_cap]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n10. 函数名: mutex_lock\n- 参数: [&dev->mutex]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []"
  },
  {
    "id": 2096,
    "cwe": "CWE-362",
    "cve": "CVE-2019-18683",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中V4L2子系统vivid驱动程序的SDR捕获线程功能，用于处理软件定义无线电(SDR)的数据流捕获，包括时间计算、缓冲区管理和序列同步等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在vivid驱动程序的流停止过程中存在多个竞态条件，由于vivid_stop_generating_vid_cap()等函数及其对应的kthread中错误的互斥锁使用导致使用后释放问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: vivid_thread_sdr_cap\n- 参数: [data]\n- 调用者: 未知（由内核线程调用）\n- 被调用者: [dprintk, set_freezable, try_to_freeze, kthread_should_stop, mutex_lock, mutex_unlock, vivid_thread_sdr_cap_tick, do_div, schedule_timeout_interruptible]\n\n2. 函数名: dprintk\n- 参数: [dev, 1, format_string]\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n3. 函数名: set_freezable\n- 参数: []\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n4. 函数名: try_to_freeze\n- 参数: []\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n5. 函数名: kthread_should_stop\n- 参数: []\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n6. 函数名: mutex_lock\n- 参数: [&dev->mutex]\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n7. 函数名: mutex_unlock\n- 参数: [&dev->mutex]\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n8. 函数名: vivid_thread_sdr_cap_tick\n- 参数: [dev]\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n9. 函数名: do_div\n- 参数: [buffers_since_start, HZ * SDR_CAP_SAMPLES_PER_BUF]\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n10. 函数名: schedule_timeout_interruptible\n- 参数: [wait_jiffies ? wait_jiffies : 1]\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []"
  },
  {
    "id": 2219,
    "cwe": "CWE-362",
    "cve": "CVE-2019-19537",
    "purpose": "Code purpose:\"\"\"该代码用于注销USB设备的字符设备驱动，释放分配的次设备号并销毁相关设备节点和类结构。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核USB字符设备驱动层中存在竞态条件漏洞，恶意USB设备可在usb_deregister_dev函数执行期间通过竞争条件操作已被释放的minor号资源。\"\"\"",
    "functions": "Functions:\n1. 函数名: usb_deregister_dev\n- 参数: [struct usb_interface *intf, struct usb_class_driver *class_driver]\n- 调用者: 未明确显示（通常由USB设备驱动相关代码调用）\n- 被调用者: [dev_dbg, down_write, up_write, device_destroy, destroy_usb_class]\n\n2. 函数名: dev_dbg\n- 参数: [&intf->dev, \"removing %d minor\\n\", intf->minor]\n- 调用者: usb_deregister_dev\n- 被调用者: []\n\n3. 函数名: down_write\n- 参数: [&minor_rwsem]\n- 调用者: usb_deregister_dev\n- 被调用者: []\n\n4. 函数名: up_write\n- 参数: [&minor_rwsem]\n- 调用者: usb_deregister_dev\n- 被调用者: []\n\n5. 函数名: device_destroy\n- 参数: [usb_class->class, MKDEV(USB_MAJOR, intf->minor)]\n- 调用者: usb_deregister_dev\n- 被调用者: []\n\n6. 函数名: destroy_usb_class\n- 参数: []\n- 调用者: usb_deregister_dev\n- 被调用者: []"
  },
  {
    "id": 2220,
    "cwe": "CWE-362",
    "cve": "CVE-2019-19537",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中注册USB设备并分配次设备号，管理USB字符设备驱动层的设备接口\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在USB字符设备驱动层中存在竞争条件，恶意USB设备可能利用minor号分配时的同步不足导致安全问题\"\"\"",
    "functions": "Functions:\n1. 函数名: usb_register_dev\n- 参数: [struct usb_interface *intf, struct usb_class_driver *class_driver]\n- 调用者: N/A (top-level function)\n- 被调用者: [mutex_lock, init_usb_class, mutex_unlock, dev_dbg, down_write, up_write, snprintf, device_create, kbasename, IS_ERR, PTR_ERR]\n\n2. 函数名: mutex_lock\n- 参数: [&init_usb_class_mutex]\n- 调用者: usb_register_dev\n- 被调用者: []\n\n3. 函数名: init_usb_class\n- 参数: []\n- 调用者: usb_register_dev\n- 被调用者: []\n\n4. 函数名: mutex_unlock\n- 参数: [&init_usb_class_mutex]\n- 调用者: usb_register_dev\n- 被调用者: []\n\n5. 函数名: dev_dbg\n- 参数: [&intf->dev, \"looking for a minor, starting at %d\\n\", minor_base]\n- 调用者: usb_register_dev\n- 被调用者: []\n\n6. 函数名: down_write\n- 参数: [&minor_rwsem]\n- 调用者: usb_register_dev\n- 被调用者: []\n\n7. 函数名: up_write\n- 参数: [&minor_rwsem]\n- 调用者: usb_register_dev\n- 被调用者: []\n\n8. 函数名: snprintf\n- 参数: [name, sizeof(name), class_driver->name, minor - minor_base]\n- 调用者: usb_register_dev\n- 被调用者: []\n\n9. 函数名: device_create\n- 参数: [usb_class->class, &intf->dev, MKDEV(USB_MAJOR, minor), class_driver, \"%s\", kbasename(name)]\n- 调用者: usb_register_dev\n- 被调用者: []\n\n10. 函数名: kbasename\n- 参数: [name]\n- 调用者: usb_register_dev\n- 被调用者: []\n\n11. 函数名: IS_ERR\n- 参数: [intf->usb_dev]\n- 调用者: usb_register_dev\n- 被调用者: []\n\n12. 函数名: PTR_ERR\n- 参数: [intf->usb_dev]\n- 调用者: usb_register_dev\n- 被调用者: []"
  },
  {
    "id": 2294,
    "cwe": "CWE-362",
    "cve": "CVE-2019-2213",
    "purpose": "Code purpose:\"\"\"释放binder事务结构体并处理相关资源，包括解除buffer关联、释放修复项和内存空间\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在释放binder_transaction结构体时存在竞态条件，导致可能在其他线程仍访问该结构体时被释放，从而引发use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: binder_free_transaction\n- 参数: [struct binder_transaction *t]\n- 调用者: 未指定\n- 被调用者: [binder_free_txn_fixups, kfree, binder_stats_deleted]\n\n2. 函数名: binder_free_txn_fixups\n- 参数: [struct binder_transaction *t]\n- 调用者: binder_free_transaction\n- 被调用者: 未指定\n\n3. 函数名: kfree\n- 参数: [void *ptr] (此处为 struct binder_transaction *t)\n- 调用者: binder_free_transaction\n- 被调用者: 未指定\n\n4. 函数名: binder_stats_deleted\n- 参数: [BINDER_STAT_TRANSACTION]\n- 调用者: binder_free_transaction\n- 被调用者: 未指定"
  },
  {
    "id": 2295,
    "cwe": "CWE-362",
    "cve": "CVE-2019-2213",
    "purpose": "Code purpose:\"\"\"释放Binder进程间通信中的缓冲区资源并处理相关事务的清理工作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于竞态条件导致在释放binder事务缓冲区时可能发生use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: binder_free_buf\n- 参数: [proc, buffer]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [binder_node_inner_lock, BUG_ON, binder_dequeue_work_head_ilocked, binder_enqueue_work_ilocked, binder_wakeup_proc_ilocked, binder_node_inner_unlock, trace_binder_transaction_buffer_release, binder_transaction_buffer_release, binder_alloc_free_buf]\n\n2. 函数名: binder_node_inner_lock\n- 参数: [buf_node]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n3. 函数名: BUG_ON\n- 参数: [condition]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n4. 函数名: binder_dequeue_work_head_ilocked\n- 参数: [&buf_node->async_todo]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n5. 函数名: binder_enqueue_work_ilocked\n- 参数: [w, &proc->todo]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n6. 函数名: binder_wakeup_proc_ilocked\n- 参数: [proc]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n7. 函数名: binder_node_inner_unlock\n- 参数: [buf_node]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n8. 函数名: trace_binder_transaction_buffer_release\n- 参数: [buffer]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n9. 函数名: binder_transaction_buffer_release\n- 参数: [proc, buffer, 0, false]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n10. 函数名: binder_alloc_free_buf\n- 参数: [&proc->alloc, buffer]\n- 调用者: binder_free_buf\n- 被调用者: []"
  },
  {
    "id": 2306,
    "cwe": "CWE-362",
    "cve": "CVE-2019-3016",
    "purpose": "Code purpose:\"\"\"在启用PV TLB的KVM虚拟机中，设置虚拟CPU的抢占状态并将其写入客户机内存\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于KVM客户机中PV TLB启用时缺乏适当的同步机制，导致一个进程可以读取同一客户机中另一个进程的内存内容\"\"\"",
    "functions": "Functions:\n1. 函数名: kvm_steal_time_set_preempted\n- 参数: [vcpu]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [kvm_write_guest_offset_cached]\n\n2. 函数名: kvm_write_guest_offset_cached\n- 参数: [vcpu->kvm, &vcpu->arch.st.stime, &vcpu->arch.st.steal.preempted, offsetof(struct kvm_steal_time, preempted), sizeof(vcpu->arch.st.steal.preempted)]\n- 调用者: kvm_steal_time_set_preempted\n- 被调用者: 未明确（可能是底层KVM函数）"
  },
  {
    "id": 2341,
    "cwe": "CWE-362",
    "cve": "CVE-2019-6133",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中进程复制(fork)的核心功能copy_process，负责创建新进程并设置其各种属性和资源\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于fork()操作的非原子性，导致进程启动时间保护机制被绕过，使得授权决策被错误地缓存，且缺乏对用户ID的检查\"\"\"",
    "functions": "Functions:\n1. 函数名: copy_process\n- 参数: [clone_flags, stack_start, stack_size, child_tidptr, pid, trace, tls, node]\n- 调用者: N/A (kernel fork operation)\n- 被调用者: [ERR_PTR, dup_task_struct, ftrace_graph_init_task, rt_mutex_init_task, copy_creds, delayacct_tsk_init, init_sigpending, posix_cpu_timers_init, ktime_get_ns, ktime_get_boot_ns, audit_set_context, cgroup_fork, mpol_dup, sched_fork, perf_event_init_task, audit_alloc, shm_init_task, security_task_alloc, copy_semundo, copy_files, copy_fs, copy_sighand, copy_signal, copy_mm, copy_namespaces, copy_io, copy_thread_tls, stackleak_task_init, alloc_pid, user_disable_single_step, clear_tsk_thread_flag, clear_all_latency_tracing, pid_nr, cgroup_threadgroup_change_begin, cgroup_can_fork, klp_copy_process, copy_seccomp, rseq_fork, ptrace_init_task, init_task_pid, is_child_reaper, tty_kref_get, attach_pid, __this_cpu_inc, task_join_group_stop, hlist_del_init, syscall_tracepoint_update, proc_fork_connector, cgroup_post_fork, perf_event_fork, trace_task_newtask, uprobe_copy_process, free_pid, exit_thread, exit_io_context, exit_task_namespaces, mmput, free_signal_struct, __cleanup_sighand, exit_fs, exit_files, exit_sem, security_task_free, audit_free, perf_event_free_task, lockdep_free_task, mpol_put, delayacct_tsk_free, atomic_dec, exit_creds, put_task_stack, free_task]\n\n2. 函数名: dup_task_struct\n- 参数: [current, node]\n- 调用者: copy_process\n- 被调用者: N/A\n\n3. 函数名: ftrace_graph_init_task\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n4. 函数名: rt_mutex_init_task\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n5. 函数名: copy_creds\n- 参数: [p, clone_flags]\n- 调用者: copy_process\n- 被调用者: N/A\n\n6. 函数名: delayacct_tsk_init\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n7. 函数名: init_sigpending\n- 参数: [&p->pending]\n- 调用者: copy_process\n- 被调用者: N/A\n\n8. 函数名: posix_cpu_timers_init\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n9. 函数名: ktime_get_ns\n- 参数: []\n- 调用者: copy_process\n- 被调用者: N/A\n\n10. 函数名: ktime_get_boot_ns\n- 参数: []\n- 调用者: copy_process\n- 被调用者: N/A\n\n11. 函数名: audit_set_context\n- 参数: [p, NULL]\n- 调用者: copy_process\n- 被调用者: N/A\n\n12. 函数名: cgroup_fork\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n13. 函数名: mpol_dup\n- 参数: [p->mempolicy]\n- 调用者: copy_process\n- 被调用者: N/A\n\n14. 函数名: sched_fork\n- 参数: [clone_flags, p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n15. 函数名: perf_event_init_task\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n16. 函数名: audit_alloc\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n17. 函数名: shm_init_task\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n18. 函数名: security_task_alloc\n- 参数: [p, clone_flags]\n- 调用者: copy_process\n- 被调用者: N/A\n\n19. 函数名: copy_semundo\n- 参数: [clone_flags, p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n20. 函数名: copy_files\n- 参数: [clone_flags, p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n21. 函数名: copy_fs\n- 参数: [clone_flags, p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n22. 函数名: copy_sighand\n- 参数: [clone_flags, p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n23. 函数名: copy_signal\n- 参数: [clone_flags, p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n24. 函数名: copy_mm\n- 参数: [clone_flags, p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n25. 函数名: copy_namespaces\n- 参数: [clone_flags, p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n26. 函数名: copy_io\n- 参数: [clone_flags, p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n27. 函数名: copy_thread_tls\n- 参数: [clone_flags, stack_start, stack_size, p, tls]\n- 调用者: copy_process\n- 被调用者: N/A\n\n28. 函数名: stackleak_task_init\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n29. 函数名: alloc_pid\n- 参数: [p->nsproxy->pid_ns_for_children]\n- 调用者: copy_process\n- 被调用者: N/A\n\n30. 函数名: user_disable_single_step\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n31. 函数名: clear_tsk_thread_flag\n- 参数: [p, TIF_SYSCALL_TRACE]\n- 调用者: copy_process\n- 被调用者: N/A\n\n32. 函数名: clear_all_latency_tracing\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n33. 函数名: pid_nr\n- 参数: [pid]\n- 调用者: copy_process\n- 被调用者: N/A\n\n34. 函数名: cgroup_threadgroup_change_begin\n- 参数: [current]\n- 调用者: copy_process\n- 被调用者: N/A\n\n35. 函数名: cgroup_can_fork\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n36. 函数名: klp_copy_process\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n37. 函数名: copy_seccomp\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n38. 函数名: rseq_fork\n- 参数: [p, clone_flags]\n- 调用者: copy_process\n- 被调用者: N/A\n\n39. 函数名: ptrace_init_task\n- 参数: [p, (clone_flags & CLONE_PTRACE) || trace]\n- 调用者: copy_process\n- 被调用者: N/A\n\n40. 函数名: init_task_pid\n- 参数: [p, PIDTYPE_PID, pid]\n- 调用者: copy_process\n- 被调用者: N/A\n\n41. 函数名: is_child_reaper\n- 参数: [pid]\n- 调用者: copy_process\n- 被调用者: N/A\n\n42. 函数名: tty_kref_get\n- 参数: [current->signal->tty]\n- 调用者: copy_process\n- 被调用者: N/A\n\n43. 函数名: attach_pid\n- 参数: [p, PIDTYPE_TGID]\n- 调用者: copy_process\n- 被调用者: N/A\n\n44. 函数名: __this_cpu_inc\n- 参数: [process_counts]\n- 调用者: copy_process\n- 被调用者: N/A\n\n45. 函数名: task_join_group_stop\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n46. 函数名: hlist_del_init\n- 参数: [&delayed.node]\n- 调用者: copy_process\n- 被调用者: N/A\n\n47. 函数名: syscall_tracepoint_update\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n48. 函数名: proc_fork_connector\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n49. 函数名: cgroup_post_fork\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n50. 函数名: perf_event_fork\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n51. 函数名: trace_task_newtask\n- 参数: [p, clone_flags]\n- 调用者: copy_process\n- 被调用者: N/A\n\n52. 函数名: uprobe_copy_process\n- 参数: [p, clone_flags]\n- 调用者: copy_process\n- 被调用者: N/A\n\n53. 函数名: free_pid\n- 参数: [pid]\n- 调用者: copy_process\n- 被调用者: N/A\n\n54. 函数名: exit_thread\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n55. 函数名: exit_io_context\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n56. 函数名: exit_task_namespaces\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n57. 函数名: mmput\n- 参数: [p->mm]\n- 调用者: copy_process\n- 被调用者: N/A\n\n58. 函数名: free_signal_struct\n- 参数: [p->signal]\n- 调用者: copy_process\n- 被调用者: N/A\n\n59. 函数名: __cleanup_sighand\n- 参数: [p->sighand]\n- 调用者: copy_process\n- 被调用者: N/A\n\n60. 函数名: exit_fs\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n61. 函数名: exit_files\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n62. 函数名: exit_sem\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n63. 函数名: security_task_free\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n64. 函数名: audit_free\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n65. 函数名: perf_event_free_task\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n66. 函数名: lockdep_free_task\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n67. 函数名: mpol_put\n- 参数: [p->mempolicy]\n- 调用者: copy_process\n- 被调用者: N/A\n\n68. 函数名: delayacct_tsk_free\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n69. 函数名: atomic_dec\n- 参数: [&p->cred->user->processes]\n- 调用者: copy_process\n- 被调用者: N/A\n\n70. 函数名: exit_creds\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n71. 函数名: put_task_stack\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n72. 函数名: free_task\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A"
  },
  {
    "id": 2342,
    "cwe": "CWE-362",
    "cve": "CVE-2019-6974",
    "purpose": "Code purpose:\"\"\"该代码用于在KVM虚拟化环境中创建并管理虚拟设备，处理设备创建、初始化和文件描述符分配等操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于存在竞态条件导致引用计数处理不当，从而引发释放后使用漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: kvm_ioctl_create_device\n- 参数: [struct kvm *kvm, struct kvm_create_device *cd]\n- 调用者: 未显示（由KVM子系统调用）\n- 被调用者: [kzalloc, mutex_lock, mutex_unlock, kfree, list_add, anon_inode_getfd, list_del, ops->create, ops->init, ops->destroy, kvm_get_kvm]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*dev), GFP_KERNEL]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: 内核内存分配函数\n\n3. 函数名: mutex_lock\n- 参数: [&kvm->lock]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: 内核互斥锁函数\n\n4. 函数名: mutex_unlock\n- 参数: [&kvm->lock]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: 内核互斥锁函数\n\n5. 函数名: kfree\n- 参数: [dev]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: 内核内存释放函数\n\n6. 函数名: list_add\n- 参数: [&dev->vm_node, &kvm->devices]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: 内核链表函数\n\n7. 函数名: anon_inode_getfd\n- 参数: [ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: 内核匿名inode函数\n\n8. 函数名: list_del\n- 参数: [&dev->vm_node]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: 内核链表函数\n\n9. 函数名: kvm_get_kvm\n- 参数: [kvm]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: KVM引用计数函数"
  },
  {
    "id": 2372,
    "cwe": "CWE-362",
    "cve": "CVE-2020-0030",
    "purpose": "Code purpose:\"\"\"释放Binder线程资源并处理相关事务，包括清理线程的事务栈、发送失败回复以及减少临时引用计数。\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在binder_thread_release函数中存在竞态条件，导致线程释放后仍可能被访问，造成use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: binder_thread_release\n- 参数: [struct binder_proc *proc, struct binder_thread *thread]\n- 调用者: 未指定\n- 被调用者: [binder_inner_proc_lock, atomic_inc, rb_erase, spin_lock, binder_debug, spin_unlock, wake_up_poll, binder_inner_proc_unlock, binder_send_failed_reply, binder_release_work, binder_thread_dec_tmpref]\n\n2. 函数名: binder_inner_proc_lock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_thread_release\n- 被调用者: 未指定\n\n3. 函数名: atomic_inc\n- 参数: [atomic_t *v]\n- 调用者: binder_thread_release\n- 被调用者: 未指定\n\n4. 函数名: rb_erase\n- 参数: [struct rb_node *node, struct rb_root *root]\n- 调用者: binder_thread_release\n- 被调用者: 未指定\n\n5. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: binder_thread_release\n- 被调用者: 未指定\n\n6. 函数名: binder_debug\n- 参数: [unsigned int mask, const char *fmt, ...]\n- 调用者: binder_thread_release\n- 被调用者: 未指定\n\n7. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: binder_thread_release\n- 被调用者: 未指定\n\n8. 函数名: wake_up_poll\n- 参数: [wait_queue_head_t *wq_head, unsigned int key]\n- 调用者: binder_thread_release\n- 被调用者: 未指定\n\n9. 函数名: binder_inner_proc_unlock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_thread_release\n- 被调用者: 未指定\n\n10. 函数名: binder_send_failed_reply\n- 参数: [struct binder_transaction *t, uint32_t error_code]\n- 调用者: binder_thread_release\n- 被调用者: 未指定\n\n11. 函数名: binder_release_work\n- 参数: [struct binder_proc *proc, struct list_head *list]\n- 调用者: binder_thread_release\n- 被调用者: 未指定\n\n12. 函数名: binder_thread_dec_tmpref\n- 参数: [struct binder_thread *thread]\n- 调用者: binder_thread_release\n- 被调用者: 未指定"
  },
  {
    "id": 2374,
    "cwe": "CWE-362",
    "cve": "CVE-2020-0066",
    "purpose": "Code purpose:\"\"\"该代码实现了netlink套接字的数据转储功能，处理网络链接消息的接收和发送，包括内存分配、消息处理和回调机制。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于netlink驱动中存在竞态条件，导致可能发生越界写入漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: netlink_dump\n- 参数: [struct sock *sk]\n- 调用者: 未显示\n- 被调用者: [nlk_sk, mutex_lock, max_t, netlink_rx_is_mmaped, atomic_read, netlink_alloc_skb, skb_reserve, netlink_skb_set_owner_r, cb->dump, mutex_unlock, sk_filter, kfree_skb, __netlink_sendskb, nlmsg_put_answer, nl_dump_check_consistent, memcpy, cb->done, module_put, consume_skb]\n\n2. 函数名: nlk_sk\n- 参数: [struct sock *sk]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n3. 函数名: mutex_lock\n- 参数: [nlk->cb_mutex]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n4. 函数名: max_t\n- 参数: [int, cb->min_dump_alloc, NLMSG_GOODSIZE]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n5. 函数名: netlink_rx_is_mmaped\n- 参数: [struct sock *sk]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n6. 函数名: atomic_read\n- 参数: [&sk->sk_rmem_alloc]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n7. 函数名: netlink_alloc_skb\n- 参数: [struct sock *sk, nlk->max_recvmsg_len, nlk->portid, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY] 和 [struct sock *sk, alloc_size, nlk->portid, GFP_KERNEL]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n8. 函数名: skb_reserve\n- 参数: [skb, skb_tailroom(skb) - nlk->max_recvmsg_len]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n9. 函数名: netlink_skb_set_owner_r\n- 参数: [skb, sk]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n10. 函数名: cb->dump\n- 参数: [skb, cb]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n11. 函数名: mutex_unlock\n- 参数: [nlk->cb_mutex]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n12. 函数名: sk_filter\n- 参数: [sk, skb]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n13. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n14. 函数名: __netlink_sendskb\n- 参数: [sk, skb]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n15. 函数名: nlmsg_put_answer\n- 参数: [skb, cb, NLMSG_DONE, sizeof(len), NLM_F_MULTI]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n16. 函数名: nl_dump_check_consistent\n- 参数: [cb, nlh]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n17. 函数名: memcpy\n- 参数: [nlmsg_data(nlh), &len, sizeof(len)]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n18. 函数名: cb->done\n- 参数: [cb]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n19. 函数名: module_put\n- 参数: [cb->module]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n20. 函数名: consume_skb\n- 参数: [cb->skb]\n- 调用者: netlink_dump\n- 被调用者: 未显示"
  },
  {
    "id": 2377,
    "cwe": "CWE-362",
    "cve": "CVE-2020-0305",
    "purpose": "Code purpose:\"\"\"获取字符设备对应的kobject对象并增加模块引用计数，同时处理可能的竞态条件\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在cdev_get函数中存在竞态条件，可能导致模块引用计数管理不当，从而引发use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: cdev_get\n- 参数: [struct cdev *p]\n- 调用者: 未明确（通常是外部调用）\n- 被调用者: [try_module_get, kobject_get, module_put]\n\n2. 函数名: try_module_get\n- 参数: [struct module *owner]\n- 调用者: cdev_get\n- 被调用者: []\n\n3. 函数名: kobject_get\n- 参数: [struct kobject *kobj]\n- 调用者: cdev_get\n- 被调用者: []\n\n4. 函数名: module_put\n- 参数: [struct module *owner]\n- 调用者: cdev_get\n- 被调用者: []"
  },
  {
    "id": 2436,
    "cwe": "CWE-362",
    "cve": "CVE-2020-11884",
    "purpose": "Code purpose:\"\"\"该代码片段用于在s390平台上启用用户空间访问的内核功能，同时处理地址空间控制寄存器的切换操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于enable_sacf_uaccess函数未能防止并发页表升级导致的竞争条件，可能引发代码执行或系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: enable_sacf_uaccess\n- 参数: []\n- 调用者: 未明确（由系统调用或内核其他部分调用）\n- 被调用者: [__ctl_store, __ctl_load, set_cpu_flag]\n\n2. 函数名: __ctl_store\n- 参数: [cr, 1, 1] 和 [cr, 7, 7]\n- 调用者: enable_sacf_uaccess\n- 被调用者: []\n\n3. 函数名: __ctl_load\n- 参数: [S390_lowcore.kernel_asce, 1, 1] 和 [asce, 7, 7]\n- 调用者: enable_sacf_uaccess\n- 被调用者: []\n\n4. 函数名: set_cpu_flag\n- 参数: [CIF_ASCE_PRIMARY] 和 [CIF_ASCE_SECONDARY]\n- 调用者: enable_sacf_uaccess\n- 被调用者: []"
  },
  {
    "id": 2437,
    "cwe": "CWE-362",
    "cve": "CVE-2020-11884",
    "purpose": "Code purpose:\"\"\"在s390平台上处理内存管理单元(MMU)的页表升级操作，并刷新TLB缓存\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于s390平台上的Linux内核在并发页面表升级时缺乏适当的保护机制，导致存在竞争条件漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: __crst_table_upgrade\n- 参数: [arg]\n- 调用者: 未明确（可能是内核其他模块或并发操作）\n- 被调用者: [set_user_asce, __tlb_flush_local]\n\n2. 函数名: set_user_asce\n- 参数: [mm]\n- 调用者: __crst_table_upgrade\n- 被调用者: 未明确\n\n3. 函数名: __tlb_flush_local\n- 参数: []\n- 调用者: __crst_table_upgrade\n- 被调用者: 未明确"
  },
  {
    "id": 2438,
    "cwe": "CWE-362",
    "cve": "CVE-2020-12114",
    "purpose": "Code purpose:\"\"\"该代码用于解除文件系统挂载点的关联并释放相关资源\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于detach_mnt函数中未正确处理挂载点引用计数器的并发访问，导致竞争条件下引用计数器可能被破坏\"\"\"",
    "functions": "Functions:\n1. 函数名: detach_mnt\n- 参数: [struct mount *mnt, struct path *old_path]\n- 调用者: 未提供（上下文缺失）\n- 被调用者: [put_mountpoint, unhash_mnt]\n\n2. 函数名: unhash_mnt\n- 参数: [struct mount *mnt]（根据上下文推断）\n- 调用者: detach_mnt\n- 被调用者: 未提供（上下文缺失）\n\n3. 函数名: put_mountpoint\n- 参数: [未提供]（根据上下文推断应接收unhash_mnt的返回值）\n- 调用者: detach_mnt\n- 被调用者: 未提供（上下文缺失）"
  },
  {
    "id": 2439,
    "cwe": "CWE-362",
    "cve": "CVE-2020-12114",
    "purpose": "Code purpose:\"\"\"该代码用于在卸载挂载点时释放相关资源并减少引用计数\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在drop_mountpoint函数中存在竞态条件，导致挂载点引用计数器被错误修改，可能引发拒绝服务(系统崩溃)。\"\"\"",
    "functions": "Functions:\n1. 函数名: drop_mountpoint\n- 参数: [struct fs_pin *p]\n- 调用者: 未明确（上下文不足）\n- 被调用者: [container_of, dput, pin_remove, mntput]\n\n2. 函数名: container_of\n- 参数: [p, struct mount, mnt_umount]（推断）\n- 调用者: drop_mountpoint\n- 被调用者: 无（宏函数）\n\n3. 函数名: dput\n- 参数: [m->mnt_ex_mountpoint]\n- 调用者: drop_mountpoint\n- 被调用者: 无（上下文不足）\n\n4. 函数名: pin_remove\n- 参数: [p]\n- 调用者: drop_mountpoint\n- 被调用者: 无（上下文不足）\n\n5. 函数名: mntput\n- 参数: [&m->mnt]\n- 调用者: drop_mountpoint\n- 被调用者: 无（上下文不足）"
  },
  {
    "id": 2440,
    "cwe": "CWE-362",
    "cve": "CVE-2020-12114",
    "purpose": "Code purpose:\"\"\"该代码用于获取或创建指定目录项的挂载点结构，并管理挂载点引用计数以防止竞争条件。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在竞争条件下未能正确管理挂载点引用计数器，导致本地用户可能通过破坏挂载点引用计数器引发拒绝服务(panic)。\"\"\"",
    "functions": "Functions:\n1. 函数名: get_mountpoint\n- 参数: [struct dentry *dentry]\n- 调用者: 未明确（通常是内核中处理挂载点的相关函数）\n- 被调用者: [d_mountpoint, d_unlinked, ERR_PTR, lookup_mountpoint, read_seqlock_excl, read_sequnlock_excl, kmalloc, d_set_mounted, hlist_add_head, INIT_HLIST_HEAD, kfree]\n\n2. 函数名: d_mountpoint\n- 参数: [struct dentry *dentry]\n- 调用者: get_mountpoint\n- 被调用者: []\n\n3. 函数名: d_unlinked\n- 参数: [struct dentry *dentry]\n- 调用者: get_mountpoint\n- 被调用者: []\n\n4. 函数名: ERR_PTR\n- 参数: [long error]\n- 调用者: get_mountpoint\n- 被调用者: []\n\n5. 函数名: lookup_mountpoint\n- 参数: [struct dentry *dentry]\n- 调用者: get_mountpoint\n- 被调用者: []\n\n6. 函数名: read_seqlock_excl\n- 参数: [seqlock_t *sl]\n- 调用者: get_mountpoint\n- 被调用者: []\n\n7. 函数名: read_sequnlock_excl\n- 参数: [seqlock_t *sl]\n- 调用者: get_mountpoint\n- 被调用者: []\n\n8. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: get_mountpoint\n- 被调用者: []\n\n9. 函数名: d_set_mounted\n- 参数: [struct dentry *dentry]\n- 调用者: get_mountpoint\n- 被调用者: []\n\n10. 函数名: hlist_add_head\n- 参数: [struct hlist_node *n, struct hlist_head *h]\n- 调用者: get_mountpoint\n- 被调用者: []\n\n11. 函数名: INIT_HLIST_HEAD\n- 参数: [struct hlist_head *h]\n- 调用者: get_mountpoint\n- 被调用者: []\n\n12. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: get_mountpoint\n- 被调用者: []"
  },
  {
    "id": 2441,
    "cwe": "CWE-362",
    "cve": "CVE-2020-12114",
    "purpose": "Code purpose:\"\"\"设置挂载点并更新相关挂载结构的引用计数\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺少对mountpoint引用计数器的适当同步保护，导致在竞争条件下可能被破坏，引发拒绝服务\"\"\"",
    "functions": "Functions:\n1. 函数名: mnt_set_mountpoint\n- 参数: [struct mount *mnt, struct mountpoint *mp, struct mount *child_mnt]\n- 调用者: 未指定（由内核其他部分调用）\n- 被调用者: [dget, mnt_add_count, hlist_add_head]\n\n2. 函数名: dget\n- 参数: [struct dentry *dentry]\n- 调用者: mnt_set_mountpoint\n- 被调用者: 未指定\n\n3. 函数名: mnt_add_count\n- 参数: [struct mount *mnt, int count]\n- 调用者: mnt_set_mountpoint\n- 被调用者: 未指定\n\n4. 函数名: hlist_add_head\n- 参数: [struct hlist_node *n, struct hlist_head *h]\n- 调用者: mnt_set_mountpoint\n- 被调用者: 未指定"
  },
  {
    "id": 2442,
    "cwe": "CWE-362",
    "cve": "CVE-2020-12114",
    "purpose": "Code purpose:\"\"\"该代码用于安全地减少挂载点的引用计数并在引用计数归零时清理挂载点资源，防止竞争条件下的引用计数器损坏。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在mount引用计数器递减操作中存在竞态条件，导致本地用户可能通过pivot_root操作破坏挂载点引用计数器，引发拒绝服务\"\"\"",
    "functions": "Functions:\n1. 函数名: mntput_no_expire\n- 参数: [struct mount *mnt]\n- 调用者: 未明确（外部调用）\n- 被调用者: [READ_ONCE, mnt_add_count, rcu_read_lock, rcu_read_unlock, lock_mount_hash, smp_mb, mnt_get_count, unlock_mount_hash, list_del, list_empty, list_for_each_entry_safe, umount_mnt, init_task_work, task_work_add, llist_add, schedule_delayed_work, cleanup_mnt]\n\n2. 函数名: mnt_add_count\n- 参数: [struct mount *mnt, int value]\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n3. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n4. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n5. 函数名: lock_mount_hash\n- 参数: []\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n6. 函数名: smp_mb\n- 参数: []\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n7. 函数名: mnt_get_count\n- 参数: [struct mount *mnt]\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n8. 函数名: unlock_mount_hash\n- 参数: []\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n9. 函数名: list_del\n- 参数: [struct list_head *entry]\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n10. 函数名: list_empty\n- 参数: [const struct list_head *head]\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n11. 函数名: list_for_each_entry_safe\n- 参数: [struct mount *p, struct mount *tmp, struct list_head *head, struct list_head *mnt_child]\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n12. 函数名: umount_mnt\n- 参数: [struct mount *p]\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n13. 函数名: init_task_work\n- 参数: [struct task_work *task_work, task_work_func_t func]\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n14. 函数名: task_work_add\n- 参数: [struct task_struct *task, struct task_work *task_work, bool notify]\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n15. 函数名: llist_add\n- 参数: [struct llist_node *new, struct llist_head *head]\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n16. 函数名: schedule_delayed_work\n- 参数: [struct delayed_work *dwork, unsigned long delay]\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n17. 函数名: cleanup_mnt\n- 参数: [struct mount *mnt]\n- 调用者: mntput_no_expire\n- 被调用者: 未明确"
  },
  {
    "id": 2443,
    "cwe": "CWE-362",
    "cve": "CVE-2020-12114",
    "purpose": "Code purpose:\"\"\"处理文件系统卸载操作，保存旧的挂载点信息并释放相关资源\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在umount_mnt函数中存在竞态条件，未能正确处理挂载点引用计数器的同步问题，导致本地用户可能通过破坏挂载点引用计数器引发拒绝服务(panic)。\"\"\"",
    "functions": "Functions:\n1. 函数名: umount_mnt\n- 参数: [struct mount *mnt]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [put_mountpoint, unhash_mnt]\n\n2. 函数名: put_mountpoint\n- 参数: [未明确（上下文未提供）]\n- 调用者: umount_mnt\n- 被调用者: []\n\n3. 函数名: unhash_mnt\n- 参数: [struct mount *mnt]\n- 调用者: umount_mnt\n- 被调用者: []"
  },
  {
    "id": 2444,
    "cwe": "CWE-362",
    "cve": "CVE-2020-12114",
    "purpose": "Code purpose:\"\"\"减少挂载点引用计数并在计数归零时清理相关资源\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于mountpoint引用计数器在竞态条件下被错误递减，导致可能被提前释放，从而引发系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: put_mountpoint\n- 参数: [struct mountpoint *mp]\n- 调用者: 未明确显示（通常是内核中处理挂载点的相关函数）\n- 被调用者: [hlist_empty, spin_lock, spin_unlock, hlist_del, kfree]\n\n2. 函数名: hlist_empty\n- 参数: [&mp->m_list]\n- 调用者: put_mountpoint\n- 被调用者: []\n\n3. 函数名: spin_lock\n- 参数: [&dentry->d_lock]\n- 调用者: put_mountpoint\n- 被调用者: []\n\n4. 函数名: spin_unlock\n- 参数: [&dentry->d_lock]\n- 调用者: put_mountpoint\n- 被调用者: []\n\n5. 函数名: hlist_del\n- 参数: [&mp->m_hash]\n- 调用者: put_mountpoint\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [mp]\n- 调用者: put_mountpoint\n- 被调用者: []"
  },
  {
    "id": 2445,
    "cwe": "CWE-362",
    "cve": "CVE-2020-12114",
    "purpose": "Code purpose:\"\"\"该代码用于在解除命名空间锁时处理未挂载的挂载点列表，确保在释放锁后安全地清理相关资源。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在释放命名空间锁后未正确处理挂载点引用计数器的同步问题，导致竞争条件下可能引发引用计数器损坏\"\"\"",
    "functions": "Functions:\n1. 函数名: namespace_unlock\n- 参数: []\n- 调用者: \n- 被调用者: [hlist_move_list, up_write, hlist_empty, synchronize_rcu_expedited, group_pin_kill]\n\n2. 函数名: hlist_move_list\n- 参数: [&unmounted, &head]\n- 调用者: namespace_unlock\n- 被调用者: []\n\n3. 函数名: up_write\n- 参数: [&namespace_sem]\n- 调用者: namespace_unlock\n- 被调用者: []\n\n4. 函数名: hlist_empty\n- 参数: [&head]\n- 调用者: namespace_unlock\n- 被调用者: []\n\n5. 函数名: synchronize_rcu_expedited\n- 参数: []\n- 调用者: namespace_unlock\n- 被调用者: []\n\n6. 函数名: group_pin_kill\n- 参数: [&head]\n- 调用者: namespace_unlock\n- 被调用者: []"
  },
  {
    "id": 2446,
    "cwe": "CWE-362",
    "cve": "CVE-2020-12114",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中安全地更改挂载点的父挂载和挂载点位置，同时管理相关引用计数。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在修改挂载点时未能正确处理挂载点引用计数器的竞态条件，导致本地用户可能通过竞争操作使引用计数器损坏，从而引发拒绝服务。\"\"\"",
    "functions": "Functions:\n1. 函数名: mnt_change_mountpoint\n- 参数: [struct mount *parent, struct mountpoint *mp, struct mount *mnt]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [list_del_init, hlist_del_init, hlist_del_init_rcu, attach_mnt, put_mountpoint, spin_lock, spin_unlock, mnt_add_count]\n\n2. 函数名: list_del_init\n- 参数: [&mnt->mnt_child]\n- 调用者: mnt_change_mountpoint\n- 被调用者: []\n\n3. 函数名: hlist_del_init\n- 参数: [&mnt->mnt_mp_list]\n- 调用者: mnt_change_mountpoint\n- 被调用者: []\n\n4. 函数名: hlist_del_init_rcu\n- 参数: [&mnt->mnt_hash]\n- 调用者: mnt_change_mountpoint\n- 被调用者: []\n\n5. 函数名: attach_mnt\n- 参数: [mnt, parent, mp]\n- 调用者: mnt_change_mountpoint\n- 被调用者: []\n\n6. 函数名: put_mountpoint\n- 参数: [old_mp]\n- 调用者: mnt_change_mountpoint\n- 被调用者: []\n\n7. 函数名: spin_lock\n- 参数: [&old_mountpoint->d_lock]\n- 调用者: mnt_change_mountpoint\n- 被调用者: []\n\n8. 函数名: spin_unlock\n- 参数: [&old_mountpoint->d_lock]\n- 调用者: mnt_change_mountpoint\n- 被调用者: []\n\n9. 函数名: mnt_add_count\n- 参数: [old_parent, -1]\n- 调用者: mnt_change_mountpoint\n- 被调用者: []"
  },
  {
    "id": 2472,
    "cwe": "CWE-362",
    "cve": "CVE-2020-12652",
    "purpose": "Code purpose:\"\"\"该代码实现了兼容模式下MPT控制命令的ioctl操作处理，包括参数验证、适配器锁定和命令执行等功能。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在ioctl操作期间持有不正确的锁导致竞态条件，即存在'双重获取'漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: compat_mpt_command\n- 参数: [struct file *filp, unsigned int cmd, unsigned long arg]\n- 调用者: 未明确（可能是系统调用或上层IOCTL处理函数）\n- 被调用者: [copy_from_user, mpt_verify_adapter, mptctl_syscall_down, printk, dctlprintk, mptctl_do_mpt_command, mutex_unlock]\n\n2. 函数名: copy_from_user\n- 参数: [&karg32, (char __user *)arg, sizeof(karg32)]\n- 调用者: compat_mpt_command\n- 被调用者: []\n\n3. 函数名: mpt_verify_adapter\n- 参数: [iocnumX, &iocp]\n- 调用者: compat_mpt_command\n- 被调用者: []\n\n4. 函数名: mptctl_syscall_down\n- 参数: [iocp, nonblock]\n- 调用者: compat_mpt_command\n- 被调用者: []\n\n5. 函数名: printk\n- 参数: [KERN_DEBUG MYNAM \"::compat_mpt_command @%d - ioc%d not found!\\n\", __LINE__, iocnumX]\n- 调用者: compat_mpt_command\n- 被调用者: []\n\n6. 函数名: dctlprintk\n- 参数: [iocp, printk(MYIOC_s_DEBUG_FMT \"compat_mpt_command() called\\n\", iocp->name)]\n- 调用者: compat_mpt_command\n- 被调用者: [printk]\n\n7. 函数名: mptctl_do_mpt_command\n- 参数: [karg, &uarg->MF]\n- 调用者: compat_mpt_command\n- 被调用者: []\n\n8. 函数名: mutex_unlock\n- 参数: [&iocp->ioctl_cmds.mutex]\n- 调用者: compat_mpt_command\n- 被调用者: []"
  },
  {
    "id": 2473,
    "cwe": "CWE-362",
    "cve": "CVE-2020-12652",
    "purpose": "Code purpose:\"\"\"处理来自用户空间的ioctl请求，执行与MPT适配器相关的各种控制操作，包括信息查询、事件处理和固件管理等。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在ioctl操作期间持有错误的锁导致竞态条件，造成双重获取漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: __mptctl_ioctl\n- 参数: [struct file *file, unsigned int cmd, unsigned long arg]\n- 调用者: 未显示（应为内核ioctl调用）\n- 被调用者: [copy_from_user, mpt_verify_adapter, mptctl_getiocinfo, mptctl_gettargetinfo, mptctl_readtest, mptctl_eventquery, mptctl_eventenable, mptctl_eventreport, mptctl_replace_fw, mptctl_syscall_down, mptctl_fw_download, mptctl_mpt_command, mptctl_do_reset, mptctl_hp_hostinfo, mptctl_hp_targetinfo, mutex_unlock]\n\n2. 函数名: copy_from_user\n- 参数: [&khdr, uhdr, sizeof(khdr)]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n3. 函数名: mpt_verify_adapter\n- 参数: [iocnumX, &iocp]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n4. 函数名: mptctl_getiocinfo\n- 参数: [arg, _IOC_SIZE(cmd)]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n5. 函数名: mptctl_gettargetinfo\n- 参数: [arg]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n6. 函数名: mptctl_readtest\n- 参数: [arg]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n7. 函数名: mptctl_eventquery\n- 参数: [arg]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n8. 函数名: mptctl_eventenable\n- 参数: [arg]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n9. 函数名: mptctl_eventreport\n- 参数: [arg]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n10. 函数名: mptctl_replace_fw\n- 参数: [arg]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n11. 函数名: mptctl_syscall_down\n- 参数: [iocp, nonblock]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n12. 函数名: mptctl_fw_download\n- 参数: [arg]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n13. 函数名: mptctl_mpt_command\n- 参数: [arg]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n14. 函数名: mptctl_do_reset\n- 参数: [arg]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n15. 函数名: mptctl_hp_hostinfo\n- 参数: [arg, _IOC_SIZE(cmd)]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n16. 函数名: mptctl_hp_targetinfo\n- 参数: [arg]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n17. 函数名: mutex_unlock\n- 参数: [&iocp->ioctl_cmds.mutex]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无"
  },
  {
    "id": 2474,
    "cwe": "CWE-362",
    "cve": "CVE-2020-12652",
    "purpose": "Code purpose:\"\"\"处理兼容模式下MPT控制器固件下载的ioctl请求，包括验证适配器、获取用户空间数据并执行固件下载操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在ioctl操作期间持有不正确的锁导致竞态条件，造成'双重获取'漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: compat_mptfwxfer_ioctl\n- 参数: [struct file *filp, unsigned int cmd, unsigned long arg]\n- 调用者: 未显示（由系统调用触发）\n- 被调用者: [copy_from_user, mpt_verify_adapter, mptctl_syscall_down, dctlprintk, compat_ptr, mptctl_do_fw_download, mutex_unlock]\n\n2. 函数名: copy_from_user\n- 参数: [&kfw32, (char __user *)arg, sizeof(kfw32)]\n- 调用者: compat_mptfwxfer_ioctl\n- 被调用者: []\n\n3. 函数名: mpt_verify_adapter\n- 参数: [iocnumX, &iocp]\n- 调用者: compat_mptfwxfer_ioctl\n- 被调用者: []\n\n4. 函数名: mptctl_syscall_down\n- 参数: [iocp, nonblock]\n- 调用者: compat_mptfwxfer_ioctl\n- 被调用者: []\n\n5. 函数名: dctlprintk\n- 参数: [iocp, printk(MYIOC_s_DEBUG_FMT \"compat_mptfwxfer_ioctl() called\", iocp->name)]\n- 调用者: compat_mptfwxfer_ioctl\n- 被调用者: [printk]\n\n6. 函数名: printk\n- 参数: [MYIOC_s_DEBUG_FMT \"compat_mptfwxfer_ioctl() called\", iocp->name]\n- 调用者: dctlprintk\n- 被调用者: []\n\n7. 函数名: compat_ptr\n- 参数: [kfw32.bufp]\n- 调用者: compat_mptfwxfer_ioctl\n- 被调用者: []\n\n8. 函数名: mptctl_do_fw_download\n- 参数: [kfw.iocnum, kfw.bufp, kfw.fwlen]\n- 调用者: compat_mptfwxfer_ioctl\n- 被调用者: []\n\n9. 函数名: mutex_unlock\n- 参数: [&iocp->ioctl_cmds.mutex]\n- 调用者: compat_mptfwxfer_ioctl\n- 被调用者: []"
  },
  {
    "id": 2540,
    "cwe": "CWE-362",
    "cve": "CVE-2020-14416",
    "purpose": "Code purpose:\"\"\"该代码片段实现了slcan线路规程的关闭功能，包括断开tty连接、清理网络设备注册等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在slcan_close函数中存在竞态条件，当处理tty->disc_data时未充分保护，可能导致在释放资源后仍被访问，造成use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: slcan_close\n- 参数: [struct tty_struct *tty]\n- 调用者: 未明确显示（通常由TTY子系统调用）\n- 被调用者: [spin_lock_bh, spin_unlock_bh, flush_work, unregister_netdev]\n\n2. 函数名: spin_lock_bh\n- 参数: [&sl->lock]\n- 调用者: slcan_close\n- 被调用者: []\n\n3. 函数名: spin_unlock_bh\n- 参数: [&sl->lock]\n- 调用者: slcan_close\n- 被调用者: []\n\n4. 函数名: flush_work\n- 参数: [&sl->tx_work]\n- 调用者: slcan_close\n- 被调用者: []\n\n5. 函数名: unregister_netdev\n- 参数: [sl->dev]\n- 调用者: slcan_close\n- 被调用者: []"
  },
  {
    "id": 2541,
    "cwe": "CWE-362",
    "cve": "CVE-2020-14416",
    "purpose": "Code purpose:\"\"\"在Linux内核中调度slcan设备的传输工作队列任务\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在slcan_write_wakeup函数中未对tty->disc_data进行同步保护，导致竞态条件下可能发生use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: slcan_write_wakeup\n- 参数: [struct tty_struct *tty]\n- 调用者: 未明确（通常由TTY子系统调用）\n- 被调用者: [schedule_work]\n\n2. 函数名: schedule_work\n- 参数: [&sl->tx_work]\n- 调用者: slcan_write_wakeup\n- 被调用者: 未明确（内核工作队列机制）"
  },
  {
    "id": 2586,
    "cwe": "CWE-362",
    "cve": "CVE-2020-25285",
    "purpose": "Code purpose:\"\"\"该代码用于处理hugetlb（大页内存）的超量提交设置，通过proc文件系统接口允许读取或修改超量提交的大页数量\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在hugetlb_overcommit_handler函数中处理sysctl操作时存在竞态条件，多个处理器同时访问和修改h->nr_overcommit_huge_pages变量时缺乏足够的同步保护，导致内存损坏或空指针解引用等问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: hugetlb_overcommit_handler\n- 参数: [struct ctl_table *table, int write, void *buffer, size_t *length, loff_t *ppos]\n- 调用者: 未明确显示（通常由内核sysctl处理机制调用）\n- 被调用者: [hugepages_supported, hstate_is_gigantic, proc_doulongvec_minmax]\n\n2. 函数名: hugepages_supported\n- 参数: []\n- 调用者: hugetlb_overcommit_handler\n- 被调用者: []\n\n3. 函数名: hstate_is_gigantic\n- 参数: [struct hstate *h]\n- 调用者: hugetlb_overcommit_handler\n- 被调用者: []\n\n4. 函数名: proc_doulongvec_minmax\n- 参数: [struct ctl_table *table, int write, void *buffer, size_t *length, loff_t *ppos]\n- 调用者: hugetlb_overcommit_handler\n- 被调用者: []"
  },
  {
    "id": 2587,
    "cwe": "CWE-362",
    "cve": "CVE-2020-25285",
    "purpose": "Code purpose:\"\"\"该代码用于处理hugetlb系统控制参数的读写操作，包括设置最大大页数量并确保操作符合内存策略。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于hugetlb_sysctl_handler_common函数在处理sysctl操作时存在竞态条件，多个处理器同时访问和修改共享数据(tmp变量)导致内存损坏或空指针解引用。\"\"\"",
    "functions": "Functions:\n1. 函数名: hugetlb_sysctl_handler_common\n- 参数: [obey_mempolicy, table, write, buffer, length, ppos]\n- 调用者: 未明确（应为内核sysctl处理框架）\n- 被调用者: [hugepages_supported, proc_doulongvec_minmax, __nr_hugepages_store_common]\n\n2. 函数名: hugepages_supported\n- 参数: []\n- 调用者: hugetlb_sysctl_handler_common\n- 被调用者: []\n\n3. 函数名: proc_doulongvec_minmax\n- 参数: [table, write, buffer, length, ppos]\n- 调用者: hugetlb_sysctl_handler_common\n- 被调用者: []\n\n4. 函数名: __nr_hugepages_store_common\n- 参数: [obey_mempolicy, h, NUMA_NO_NODE, tmp, *length]\n- 调用者: hugetlb_sysctl_handler_common\n- 被调用者: []"
  },
  {
    "id": 2611,
    "cwe": "CWE-362",
    "cve": "CVE-2020-27067",
    "purpose": "Code purpose:\"\"\"该代码片段用于在L2TP以太网设备取消初始化时，从网络设备列表中删除私有数据并释放设备引用。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在l2tp_eth_dev_uninit函数中存在竞态条件，导致在释放设备资源后可能仍被访问，造成use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: l2tp_eth_dev_uninit\n- 参数: [struct net_device *dev]\n- 调用者: 未显示（由系统调用）\n- 被调用者: [netdev_priv, l2tp_eth_pernet, dev_net, spin_lock, list_del_init, spin_unlock, dev_put]\n\n2. 函数名: netdev_priv\n- 参数: [struct net_device *dev]\n- 调用者: l2tp_eth_dev_uninit\n- 被调用者: 未显示\n\n3. 函数名: l2tp_eth_pernet\n- 参数: [struct net *net]\n- 调用者: l2tp_eth_dev_uninit\n- 被调用者: 未显示\n\n4. 函数名: dev_net\n- 参数: [struct net_device *dev]\n- 调用者: l2tp_eth_dev_uninit\n- 被调用者: 未显示\n\n5. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: l2tp_eth_dev_uninit\n- 被调用者: 未显示\n\n6. 函数名: list_del_init\n- 参数: [struct list_head *entry]\n- 调用者: l2tp_eth_dev_uninit\n- 被调用者: 未显示\n\n7. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: l2tp_eth_dev_uninit\n- 被调用者: 未显示\n\n8. 函数名: dev_put\n- 参数: [struct net_device *dev]\n- 调用者: l2tp_eth_dev_uninit\n- 被调用者: 未显示"
  },
  {
    "id": 2612,
    "cwe": "CWE-362",
    "cve": "CVE-2020-27067",
    "purpose": "Code purpose:\"\"\"创建一个L2TP以太网会话并初始化相关网络设备\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于l2tp_eth_create函数中存在竞态条件，可能导致会话资源在使用后被释放，造成use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: l2tp_eth_create\n- 参数: [struct net *net, struct l2tp_tunnel *tunnel, u32 session_id, u32 peer_session_id, struct l2tp_session_cfg *cfg]\n- 调用者: 未显示\n- 被调用者: [strlcpy, strcpy, l2tp_session_create, alloc_netdev, dev_net_set, l2tp_eth_adjust_mtu, netdev_priv, INIT_LIST_HEAD, l2tp_session_priv, register_netdev, __module_get, dev_hold, l2tp_eth_pernet, spin_lock, list_add, spin_unlock, free_netdev, l2tp_session_delete]\n\n2. 函数名: l2tp_session_create\n- 参数: [size_t priv_size, struct l2tp_tunnel *tunnel, u32 session_id, u32 peer_session_id, struct l2tp_session_cfg *cfg]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n3. 函数名: alloc_netdev\n- 参数: [int sizeof_priv, const char *name, unsigned char name_assign_type, void (*setup)(struct net_device *)]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n4. 函数名: dev_net_set\n- 参数: [struct net_device *dev, struct net *net]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n5. 函数名: l2tp_eth_adjust_mtu\n- 参数: [struct l2tp_tunnel *tunnel, struct l2tp_session *session, struct net_device *dev]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n6. 函数名: netdev_priv\n- 参数: [const struct net_device *dev]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n7. 函数名: INIT_LIST_HEAD\n- 参数: [struct list_head *list]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n8. 函数名: l2tp_session_priv\n- 参数: [struct l2tp_session *session]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n9. 函数名: register_netdev\n- 参数: [struct net_device *dev]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n10. 函数名: __module_get\n- 参数: [struct module *module]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n11. 函数名: dev_hold\n- 参数: [struct net_device *dev]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n12. 函数名: l2tp_eth_pernet\n- 参数: [struct net *net]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n13. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n14. 函数名: list_add\n- 参数: [struct list_head *new, struct list_head *head]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n15. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n16. 函数名: free_netdev\n- 参数: [struct net_device *dev]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n17. 函数名: l2tp_session_delete\n- 参数: [struct l2tp_session *session]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示"
  },
  {
    "id": 2613,
    "cwe": "CWE-362",
    "cve": "CVE-2020-27067",
    "purpose": "Code purpose:\"\"\"初始化L2TP以太网伪线支持，注册网络操作和网络命名空间设备\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于l2tp子系统中存在竞争条件，导致在注销操作后仍可能被使用，从而引发释放后使用漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: l2tp_eth_init\n- 参数: [void]\n- 调用者: __init\n- 被调用者: [l2tp_nl_register_ops, register_pernet_device, l2tp_nl_unregister_ops]\n\n2. 函数名: l2tp_nl_register_ops\n- 参数: [L2TP_PWTYPE_ETH, &l2tp_eth_nl_cmd_ops]\n- 调用者: l2tp_eth_init\n- 被调用者: []\n\n3. 函数名: register_pernet_device\n- 参数: [&l2tp_eth_net_ops]\n- 调用者: l2tp_eth_init\n- 被调用者: []\n\n4. 函数名: l2tp_nl_unregister_ops\n- 参数: [L2TP_PWTYPE_ETH]\n- 调用者: l2tp_eth_init\n- 被调用者: []"
  },
  {
    "id": 2614,
    "cwe": "CWE-362",
    "cve": "CVE-2020-27067",
    "purpose": "Code purpose:\"\"\"注销L2TP以太网模块时，卸载网络命名空间操作并取消注册L2TP网络层操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于l2tp子系统中存在竞态条件导致的使用后释放问题\"\"\"",
    "functions": "Functions:\n1. 函数名: l2tp_eth_exit\n- 参数: [void]\n- 调用者: __exit\n- 被调用者: [unregister_pernet_device, l2tp_nl_unregister_ops]\n\n2. 函数名: unregister_pernet_device\n- 参数: [&l2tp_eth_net_ops]\n- 调用者: l2tp_eth_exit\n- 被调用者: []\n\n3. 函数名: l2tp_nl_unregister_ops\n- 参数: [L2TP_PWTYPE_ETH]\n- 调用者: l2tp_eth_exit\n- 被调用者: []"
  },
  {
    "id": 2621,
    "cwe": "CWE-362",
    "cve": "CVE-2020-27675",
    "purpose": "Code purpose:\"\"\"该代码用于根据事件通道号(evtchn)获取对应的中断号(irq)，并进行边界和空指针检查\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环中存在竞态条件，允许在事件处理期间移除事件通道，导致可能发生释放后使用或空指针解引用\"\"\"",
    "functions": "Functions:\n1. 函数名: get_evtchn_to_irq\n- 参数: [evtchn_port_t evtchn]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [xen_evtchn_max_channels]\n\n2. 函数名: xen_evtchn_max_channels\n- 参数: []\n- 调用者: [get_evtchn_to_irq]\n- 被调用者: 未明确"
  },
  {
    "id": 2622,
    "cwe": "CWE-362",
    "cve": "CVE-2020-27675",
    "purpose": "Code purpose:\"\"\"清除事件通道到中断号映射表中指定行的所有列的值\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环中存在竞态条件，允许在事件处理过程中移除事件通道，导致可能发生释放后使用或空指针解引用问题\"\"\"",
    "functions": "Functions:\n1. 函数名: clear_evtchn_to_irq_row\n- 参数: [row]\n- 调用者: 未提供（代码片段中未显示）\n- 被调用者: []"
  },
  {
    "id": 2623,
    "cwe": "CWE-362",
    "cve": "CVE-2020-27675",
    "purpose": "Code purpose:\"\"\"该代码用于在Xen虚拟化环境中释放中断请求(IRQ)资源，包括从链表中删除中断信息、释放内存以及处理传统中断描述符。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环中存在竞态条件，允许在事件处理过程中删除事件通道，导致可能发生释放后使用或空指针解引用\"\"\"",
    "functions": "Functions:\n1. 函数名: xen_free_irq\n- 参数: [unsigned irq]\n- 调用者: 未显示\n- 被调用者: [info_for_irq, WARN_ON, list_del, set_info_for_irq, kfree, nr_legacy_irqs, irq_free_desc]\n\n2. 函数名: info_for_irq\n- 参数: [unsigned irq]\n- 调用者: xen_free_irq\n- 被调用者: 未显示\n\n3. 函数名: WARN_ON\n- 参数: [condition]\n- 调用者: xen_free_irq\n- 被调用者: 未显示\n\n4. 函数名: list_del\n- 参数: [struct list_head *entry]\n- 调用者: xen_free_irq\n- 被调用者: 未显示\n\n5. 函数名: set_info_for_irq\n- 参数: [unsigned irq, struct irq_info *info]\n- 调用者: xen_free_irq\n- 被调用者: 未显示\n\n6. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: xen_free_irq\n- 被调用者: 未显示\n\n7. 函数名: nr_legacy_irqs\n- 参数: []\n- 调用者: xen_free_irq\n- 被调用者: 未显示\n\n8. 函数名: irq_free_desc\n- 参数: [unsigned int irq]\n- 调用者: xen_free_irq\n- 被调用者: 未显示"
  },
  {
    "id": 2624,
    "cwe": "CWE-362",
    "cve": "CVE-2020-27675",
    "purpose": "Code purpose:\"\"\"将Xen事件通道(evtchn)映射到对应的中断号(irq)\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环中存在竞态条件，允许在事件处理过程中删除事件通道，导致可能发生释放后使用或空指针解引用\"\"\"",
    "functions": "Functions:\n1. 函数名: set_evtchn_to_irq\n- 参数: [evtchn_port_t evtchn, unsigned int irq]\n- 调用者: 未提供\n- 被调用者: [xen_evtchn_max_channels, EVTCHN_ROW, EVTCHN_COL, get_zeroed_page, clear_evtchn_to_irq_row]\n\n2. 函数名: xen_evtchn_max_channels\n- 参数: []\n- 调用者: set_evtchn_to_irq\n- 被调用者: 未提供\n\n3. 函数名: EVTCHN_ROW\n- 参数: [evtchn_port_t evtchn]\n- 调用者: set_evtchn_to_irq\n- 被调用者: 未提供\n\n4. 函数名: EVTCHN_COL\n- 参数: [evtchn_port_t evtchn]\n- 调用者: set_evtchn_to_irq\n- 被调用者: 未提供\n\n5. 函数名: get_zeroed_page\n- 参数: [GFP_KERNEL]\n- 调用者: set_evtchn_to_irq\n- 被调用者: 未提供\n\n6. 函数名: clear_evtchn_to_irq_row\n- 参数: [unsigned row]\n- 调用者: set_evtchn_to_irq\n- 被调用者: 未提供"
  },
  {
    "id": 2625,
    "cwe": "CWE-362",
    "cve": "CVE-2020-27675",
    "purpose": "Code purpose:\"\"\"处理Xen事件通道的上调调用，循环检查并处理挂起的事件\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环中允许移除事件通道，导致竞态条件可能引发释放后使用或空指针解引用\"\"\"",
    "functions": "Functions:\n1. 函数名: __xen_evtchn_do_upcall\n- 参数: []\n- 调用者: N/A\n- 被调用者: [__this_cpu_read, smp_processor_id, xen_evtchn_handle_events, BUG_ON, virt_rmb]\n\n2. 函数名: __this_cpu_read\n- 参数: [xen_vcpu]\n- 调用者: __xen_evtchn_do_upcall\n- 被调用者: []\n\n3. 函数名: smp_processor_id\n- 参数: []\n- 调用者: __xen_evtchn_do_upcall\n- 被调用者: []\n\n4. 函数名: xen_evtchn_handle_events\n- 参数: [cpu]\n- 调用者: __xen_evtchn_do_upcall\n- 被调用者: []\n\n5. 函数名: BUG_ON\n- 参数: [!irqs_disabled()]\n- 调用者: __xen_evtchn_do_upcall\n- 被调用者: []\n\n6. 函数名: virt_rmb\n- 参数: []\n- 调用者: __xen_evtchn_do_upcall\n- 被调用者: []"
  },
  {
    "id": 2626,
    "cwe": "CWE-362",
    "cve": "CVE-2020-27675",
    "purpose": "Code purpose:\"\"\"该代码用于根据给定的IRQ号获取对应的事件通道(evtchn)，并进行有效性检查\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环中存在竞态条件，允许在事件处理过程中移除事件通道，导致可能发生释放后使用或空指针解引用问题\"\"\"",
    "functions": "Functions:\n1. 函数名: evtchn_from_irq\n- 参数: [unsigned irq]\n- 调用者: 未在代码片段中显示\n- 被调用者: [WARN, info_for_irq]\n\n2. 函数名: WARN\n- 参数: [irq >= nr_irqs, \"Invalid irq %d!\\n\", irq]\n- 调用者: evtchn_from_irq\n- 被调用者: 未在代码片段中显示\n\n3. 函数名: info_for_irq\n- 参数: [irq]\n- 调用者: evtchn_from_irq\n- 被调用者: 未在代码片段中显示"
  },
  {
    "id": 2637,
    "cwe": "CWE-362",
    "cve": "CVE-2020-27825",
    "purpose": "Code purpose:\"\"\"在多CPU环境下安全重置指定CPU的环形缓冲区，防止并行操作导致的数据竞争问题\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在多CPU并行环境下，trace_open和cpu缓冲区resize操作存在竞争条件，导致use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: ring_buffer_reset_cpu\n- 参数: [struct trace_buffer *buffer, int cpu]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [cpumask_test_cpu, atomic_inc, synchronize_rcu, reset_disabled_cpu_buffer, atomic_dec]\n\n2. 函数名: cpumask_test_cpu\n- 参数: [int cpu, buffer->cpumask]\n- 调用者: ring_buffer_reset_cpu\n- 被调用者: []\n\n3. 函数名: atomic_inc\n- 参数: [&cpu_buffer->resize_disabled, &cpu_buffer->record_disabled]\n- 调用者: ring_buffer_reset_cpu\n- 被调用者: []\n\n4. 函数名: synchronize_rcu\n- 参数: []\n- 调用者: ring_buffer_reset_cpu\n- 被调用者: []\n\n5. 函数名: reset_disabled_cpu_buffer\n- 参数: [struct ring_buffer_per_cpu *cpu_buffer]\n- 调用者: ring_buffer_reset_cpu\n- 被调用者: []\n\n6. 函数名: atomic_dec\n- 参数: [&cpu_buffer->record_disabled, &cpu_buffer->resize_disabled]\n- 调用者: ring_buffer_reset_cpu\n- 被调用者: []"
  },
  {
    "id": 2638,
    "cwe": "CWE-362",
    "cve": "CVE-2020-27825",
    "purpose": "Code purpose:\"\"\"该代码用于重置在线CPU的环形缓冲区，通过禁用记录和调整大小操作来确保缓冲区重置的安全性\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在多CPU并行环境下，trace_open和缓冲区resize操作之间存在竞争条件，导致use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: ring_buffer_reset_online_cpus\n- 参数: [struct trace_buffer *buffer]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [for_each_online_buffer_cpu, atomic_inc, synchronize_rcu, reset_disabled_cpu_buffer, atomic_dec]\n\n2. 函数名: for_each_online_buffer_cpu\n- 参数: [struct trace_buffer *buffer, int cpu]\n- 调用者: ring_buffer_reset_online_cpus\n- 被调用者: 未明确（可能是宏或内联函数）\n\n3. 函数名: atomic_inc\n- 参数: [atomic_t *v]（根据上下文推断）\n- 调用者: ring_buffer_reset_online_cpus\n- 被调用者: 未明确（原子操作函数）\n\n4. 函数名: synchronize_rcu\n- 参数: []\n- 调用者: ring_buffer_reset_online_cpus\n- 被调用者: 未明确（RCU同步函数）\n\n5. 函数名: reset_disabled_cpu_buffer\n- 参数: [struct ring_buffer_per_cpu *cpu_buffer]\n- 调用者: ring_buffer_reset_online_cpus\n- 被调用者: 未明确（上下文未提供）\n\n6. 函数名: atomic_dec\n- 参数: [atomic_t *v]（根据上下文推断）\n- 调用者: ring_buffer_reset_online_cpus\n- 被调用者: 未明确（原子操作函数）"
  },
  {
    "id": 2662,
    "cwe": "CWE-362",
    "cve": "CVE-2020-29368",
    "purpose": "Code purpose:\"\"\"该代码用于处理大页(THP)的分裂操作，确保在分裂过程中正确处理内存映射通知和锁机制，但存在竞态条件可能导致意外的写权限授予问题。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于THP mapcount检查中存在竞态条件，导致写时复制实现可能授予非预期的写访问权限\"\"\"",
    "functions": "Functions:\n1. 函数名: __split_huge_pmd\n- 参数: [vma, pmd, address, freeze, page]\n- 调用者: 未显示\n- 被调用者: [mmu_notifier_range_init, mmu_notifier_invalidate_range_start, pmd_lock, pmd_page, pmd_trans_huge, PageMlocked, clear_page_mlock, pmd_devmap, is_pmd_migration_entry, __split_huge_pmd_locked, spin_unlock, mmu_notifier_invalidate_range_only_end]\n\n2. 函数名: mmu_notifier_range_init\n- 参数: [range, MMU_NOTIFY_CLEAR, 0, vma, vma->vm_mm, address & HPAGE_PMD_MASK, (address & HPAGE_PMD_MASK) + HPAGE_PMD_SIZE]\n- 调用者: __split_huge_pmd\n- 被调用者: 无\n\n3. 函数名: mmu_notifier_invalidate_range_start\n- 参数: [range]\n- 调用者: __split_huge_pmd\n- 被调用者: 无\n\n4. 函数名: pmd_lock\n- 参数: [vma->vm_mm, pmd]\n- 调用者: __split_huge_pmd\n- 被调用者: 无\n\n5. 函数名: pmd_page\n- 参数: [*pmd]\n- 调用者: __split_huge_pmd\n- 被调用者: 无\n\n6. 函数名: pmd_trans_huge\n- 参数: [*pmd]\n- 调用者: __split_huge_pmd\n- 被调用者: 无\n\n7. 函数名: PageMlocked\n- 参数: [page]\n- 调用者: __split_huge_pmd\n- 被调用者: 无\n\n8. 函数名: clear_page_mlock\n- 参数: [page]\n- 调用者: __split_huge_pmd\n- 被调用者: 无\n\n9. 函数名: pmd_devmap\n- 参数: [*pmd]\n- 调用者: __split_huge_pmd\n- 被调用者: 无\n\n10. 函数名: is_pmd_migration_entry\n- 参数: [*pmd]\n- 调用者: __split_huge_pmd\n- 被调用者: 无\n\n11. 函数名: __split_huge_pmd_locked\n- 参数: [vma, pmd, range.start, freeze]\n- 调用者: __split_huge_pmd\n- 被调用者: 无\n\n12. 函数名: spin_unlock\n- 参数: [ptl]\n- 调用者: __split_huge_pmd\n- 被调用者: 无\n\n13. 函数名: mmu_notifier_invalidate_range_only_end\n- 参数: [range]\n- 调用者: __split_huge_pmd\n- 被调用者: 无"
  },
  {
    "id": 2663,
    "cwe": "CWE-362",
    "cve": "CVE-2020-29369",
    "purpose": "Code purpose:\"\"\"该代码用于在内存映射解除时，安全地分离并更新虚拟内存区域(VMA)结构，确保内存管理的正确性。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中mm/mmap.c存在竞争条件，特定扩展函数(expand_downwards和expand_upwards)与munmap调用的页表释放操作之间未正确同步\"\"\"",
    "functions": "Functions:\n1. 函数名: detach_vmas_to_be_unmapped\n- 参数: [struct mm_struct *mm, struct vm_area_struct *vma, struct vm_area_struct *prev, unsigned long end]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [vma_rb_erase, vma_gap_update, vmacache_invalidate, vm_end_gap]\n\n2. 函数名: vma_rb_erase\n- 参数: [struct vm_area_struct *vma, &mm->mm_rb]\n- 调用者: detach_vmas_to_be_unmapped\n- 被调用者: 未显示\n\n3. 函数名: vma_gap_update\n- 参数: [struct vm_area_struct *vma]\n- 调用者: detach_vmas_to_be_unmapped\n- 被调用者: 未显示\n\n4. 函数名: vmacache_invalidate\n- 参数: [struct mm_struct *mm]\n- 调用者: detach_vmas_to_be_unmapped\n- 被调用者: 未显示\n\n5. 函数名: vm_end_gap\n- 参数: [struct vm_area_struct *prev]\n- 调用者: detach_vmas_to_be_unmapped\n- 被调用者: 未显示"
  },
  {
    "id": 2664,
    "cwe": "CWE-362",
    "cve": "CVE-2020-29369",
    "purpose": "Code purpose:\"\"\"该代码用于实现Linux内核中内存映射区域的解除映射(munmap)功能，处理虚拟内存区域的拆分、解锁和释放操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核中，expand_downwards和expand_upwards函数与munmap调用中的页表释放操作之间存在竞争条件，导致内存管理异常。\"\"\"",
    "functions": "Functions:\n1. 函数名: __do_munmap\n- 参数: [struct mm_struct *mm, unsigned long start, size_t len, struct list_head *uf, bool downgrade]\n- 调用者: 未明确（通常是系统调用munmap或其他内存管理函数）\n- 被调用者: [find_vma, __split_vma, userfaultfd_unmap_prep, munlock_vma_pages_all, detach_vmas_to_be_unmapped, mmap_write_downgrade, unmap_region, remove_vma_list]\n\n2. 函数名: find_vma\n- 参数: [struct mm_struct *mm, unsigned long addr]\n- 调用者: __do_munmap\n- 被调用者: []\n\n3. 函数名: __split_vma\n- 参数: [struct mm_struct *mm, struct vm_area_struct *vma, unsigned long addr, int new_below]\n- 调用者: __do_munmap\n- 被调用者: []\n\n4. 函数名: userfaultfd_unmap_prep\n- 参数: [struct vm_area_struct *vma, unsigned long start, unsigned long end, struct list_head *uf]\n- 调用者: __do_munmap\n- 被调用者: []\n\n5. 函数名: munlock_vma_pages_all\n- 参数: [struct vm_area_struct *vma]\n- 调用者: __do_munmap\n- 被调用者: []\n\n6. 函数名: detach_vmas_to_be_unmapped\n- 参数: [struct mm_struct *mm, struct vm_area_struct *vma, struct vm_area_struct *prev, unsigned long end]\n- 调用者: __do_munmap\n- 被调用者: []\n\n7. 函数名: mmap_write_downgrade\n- 参数: [struct mm_struct *mm]\n- 调用者: __do_munmap\n- 被调用者: []\n\n8. 函数名: unmap_region\n- 参数: [struct mm_struct *mm, struct vm_area_struct *vma, struct vm_area_struct *prev, unsigned long start, unsigned long end]\n- 调用者: __do_munmap\n- 被调用者: []\n\n9. 函数名: remove_vma_list\n- 参数: [struct mm_struct *mm, struct vm_area_struct *vma]\n- 调用者: __do_munmap\n- 被调用者: []\n\n10. 函数名: arch_unmap\n- 参数: [struct mm_struct *mm, unsigned long start, unsigned long end]\n- 调用者: __do_munmap\n- 被调用者: []"
  },
  {
    "id": 2665,
    "cwe": "CWE-362",
    "cve": "CVE-2020-29370",
    "purpose": "Code purpose:\"\"\"该代码用于从指定的内存缓存中批量分配对象，处理快速路径和慢速路径的内存分配，并确保在多核环境下的线程安全\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在慢路径处理中未正确增加事务ID(TID)，导致并发操作时可能出现竞争条件\"\"\"",
    "functions": "Functions:\n1. 函数名: kmem_cache_alloc_bulk\n- 参数: [struct kmem_cache *s, gfp_t flags, size_t size, void **p]\n- 调用者: N/A\n- 被调用者: [slab_pre_alloc_hook, local_irq_disable, this_cpu_ptr, ___slab_alloc, get_freepointer, maybe_wipe_obj_freeptr, next_tid, local_irq_enable, slab_want_init_on_alloc, memset, slab_post_alloc_hook, __kmem_cache_free_bulk]\n\n2. 函数名: slab_pre_alloc_hook\n- 参数: [struct kmem_cache *s, gfp_t flags]\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A\n\n3. 函数名: local_irq_disable\n- 参数: []\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A\n\n4. 函数名: this_cpu_ptr\n- 参数: [s->cpu_slab]\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A\n\n5. 函数名: ___slab_alloc\n- 参数: [s, flags, NUMA_NO_NODE, _RET_IP_, c]\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A\n\n6. 函数名: get_freepointer\n- 参数: [s, object]\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A\n\n7. 函数名: maybe_wipe_obj_freeptr\n- 参数: [s, p[i]]\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A\n\n8. 函数名: next_tid\n- 参数: [c->tid]\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A\n\n9. 函数名: local_irq_enable\n- 参数: []\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A\n\n10. 函数名: slab_want_init_on_alloc\n- 参数: [flags, s]\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A\n\n11. 函数名: memset\n- 参数: [p[j], 0, s->object_size]\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A\n\n12. 函数名: slab_post_alloc_hook\n- 参数: [s, flags, size, p]\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A\n\n13. 函数名: __kmem_cache_free_bulk\n- 参数: [s, i, p]\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A"
  },
  {
    "id": 2667,
    "cwe": "CWE-362",
    "cve": "CVE-2020-29372",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中的madvise系统调用功能，用于向内核提供内存使用建议，优化内存管理行为。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中do_madvise函数存在竞争条件，当与coredump操作同时进行IORING_OP_MADVISE操作时，由于缺乏适当的同步机制导致漏洞产生。\"\"\"",
    "functions": "Functions:\n1. 函数名: do_madvise\n- 参数: [unsigned long start, size_t len_in, int behavior]\n- 调用者: N/A (系统调用或内核其他部分)\n- 被调用者: [madvise_behavior_valid, madvise_inject_error, madvise_need_mmap_write, down_write_killable, down_read, find_vma_prev, blk_start_plug, madvise_vma, find_vma, blk_finish_plug, up_write, up_read]\n\n2. 函数名: madvise_behavior_valid\n- 参数: [int behavior]\n- 调用者: do_madvise\n- 被调用者: []\n\n3. 函数名: madvise_inject_error\n- 参数: [int behavior, unsigned long start, unsigned long end]\n- 调用者: do_madvise\n- 被调用者: []\n\n4. 函数名: madvise_need_mmap_write\n- 参数: [int behavior]\n- 调用者: do_madvise\n- 被调用者: []\n\n5. 函数名: down_write_killable\n- 参数: [struct rw_semaphore *sem]\n- 调用者: do_madvise\n- 被调用者: []\n\n6. 函数名: down_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: do_madvise\n- 被调用者: []\n\n7. 函数名: find_vma_prev\n- 参数: [struct mm_struct *mm, unsigned long addr, struct vm_area_struct **pprev]\n- 调用者: do_madvise\n- 被调用者: []\n\n8. 函数名: blk_start_plug\n- 参数: [struct blk_plug *plug]\n- 调用者: do_madvise\n- 被调用者: []\n\n9. 函数名: madvise_vma\n- 参数: [struct vm_area_struct *vma, struct vm_area_struct **prev, unsigned long start, unsigned long end, int behavior]\n- 调用者: do_madvise\n- 被调用者: []\n\n10. 函数名: find_vma\n- 参数: [struct mm_struct *mm, unsigned long addr]\n- 调用者: do_madvise\n- 被调用者: []\n\n11. 函数名: blk_finish_plug\n- 参数: [struct blk_plug *plug]\n- 调用者: do_madvise\n- 被调用者: []\n\n12. 函数名: up_write\n- 参数: [struct rw_semaphore *sem]\n- 调用者: do_madvise\n- 被调用者: []\n\n13. 函数名: up_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: do_madvise\n- 被调用者: []"
  },
  {
    "id": 2670,
    "cwe": "CWE-362",
    "cve": "CVE-2020-29374",
    "purpose": "Code purpose:\"\"\"该代码用于处理用户空间指针到内核页面的映射，包括获取页面、处理写时复制情况以及管理页面活动状态\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当处理写时复制(COW)页面时，get_user_pages实现未能正确处理读操作的语义，导致可能意外授予写访问权限\"\"\"",
    "functions": "Functions:\n1. 函数名: i915_gem_userptr_get_pages\n- 参数: [struct drm_i915_gem_object *obj]\n- 调用者: N/A\n- 被调用者: [IS_ERR, PTR_ERR, kvmalloc_array, __get_user_pages_fast, i915_gem_object_is_readonly, ERR_PTR, __i915_gem_userptr_get_pages_schedule, __i915_gem_userptr_alloc_pages, __i915_gem_userptr_set_active, release_pages, kvfree, PTR_ERR_OR_ZERO]\n\n2. 函数名: __get_user_pages_fast\n- 参数: [obj->userptr.ptr, num_pages, !i915_gem_object_is_readonly(obj), pvec]\n- 调用者: i915_gem_userptr_get_pages\n- 被调用者: N/A\n\n3. 函数名: i915_gem_object_is_readonly\n- 参数: [obj]\n- 调用者: i915_gem_userptr_get_pages\n- 被调用者: N/A\n\n4. 函数名: __i915_gem_userptr_get_pages_schedule\n- 参数: [obj]\n- 调用者: i915_gem_userptr_get_pages\n- 被调用者: N/A\n\n5. 函数名: __i915_gem_userptr_alloc_pages\n- 参数: [obj, pvec, num_pages]\n- 调用者: i915_gem_userptr_get_pages\n- 被调用者: N/A\n\n6. 函数名: __i915_gem_userptr_set_active\n- 参数: [obj, true]\n- 调用者: i915_gem_userptr_get_pages\n- 被调用者: N/A\n\n7. 函数名: release_pages\n- 参数: [pvec, pinned]\n- 调用者: i915_gem_userptr_get_pages\n- 被调用者: N/A\n\n8. 函数名: kvfree\n- 参数: [pvec]\n- 调用者: i915_gem_userptr_get_pages\n- 被调用者: N/A"
  },
  {
    "id": 2671,
    "cwe": "CWE-362",
    "cve": "CVE-2020-29374",
    "purpose": "Code purpose:\"\"\"该代码实现了获取用户空间页面的功能，用于处理用户空间内存页面的映射和访问权限控制\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当处理写时复制(COW)页面时，get_user_pages实现未能正确处理读操作的语义，导致可能授予非预期的写访问权限\"\"\"",
    "functions": "Functions:\n1. 函数名: __get_user_pages\n- 参数: [tsk, mm, start, nr_pages, gup_flags, pages, vmas, locked]\n- 调用者: N/A (static函数，调用者未在代码片段中显示)\n- 被调用者: [untagged_addr, find_extend_vma, in_gate_area, get_gate_page, check_vma_flags, is_vm_hugetlb_page, follow_hugetlb_page, fatal_signal_pending, cond_resched, follow_page_mask, faultin_page, flush_anon_page, flush_dcache_page, put_dev_pagemap]\n\n2. 函数名: untagged_addr\n- 参数: [start]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n3. 函数名: find_extend_vma\n- 参数: [mm, start]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n4. 函数名: in_gate_area\n- 参数: [mm, start]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n5. 函数名: get_gate_page\n- 参数: [mm, start & PAGE_MASK, gup_flags, vma, pages ? &pages[i] : NULL]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n6. 函数名: check_vma_flags\n- 参数: [vma, gup_flags]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n7. 函数名: is_vm_hugetlb_page\n- 参数: [vma]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n8. 函数名: follow_hugetlb_page\n- 参数: [mm, vma, pages, vmas, start, nr_pages, i, gup_flags, locked]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n9. 函数名: fatal_signal_pending\n- 参数: [current]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n10. 函数名: cond_resched\n- 参数: []\n- 调用者: __get_user_pages\n- 被调用者: []\n\n11. 函数名: follow_page_mask\n- 参数: [vma, start, foll_flags, ctx]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n12. 函数名: faultin_page\n- 参数: [tsk, vma, start, foll_flags, locked]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n13. 函数名: flush_anon_page\n- 参数: [vma, page, start]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n14. 函数名: flush_dcache_page\n- 参数: [page]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n15. 函数名: put_dev_pagemap\n- 参数: [ctx.pgmap]\n- 调用者: __get_user_pages\n- 被调用者: []"
  },
  {
    "id": 2672,
    "cwe": "CWE-362",
    "cve": "CVE-2020-29374",
    "purpose": "Code purpose:\"\"\"检查是否可以跟随写页表项(PTE)，考虑写权限、强制获取标志和写时复制(COW)情况下的脏页标志\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核的get_user_pages实现中，当处理写时复制(COW)页面时，未能正确处理读操作的语义，导致可能意外授予写访问权限。\"\"\"",
    "functions": "Functions:\n1. 函数名: can_follow_write_pte\n- 参数: [pte_t pte, unsigned int flags]\n- 调用者: 未明确（应为get_user_pages相关调用链）\n- 被调用者: [pte_write, pte_dirty]\n\n2. 函数名: pte_write\n- 参数: [pte_t pte]\n- 调用者: can_follow_write_pte\n- 被调用者: []\n\n3. 函数名: pte_dirty\n- 参数: [pte_t pte]\n- 调用者: can_follow_write_pte\n- 被调用者: []"
  },
  {
    "id": 2673,
    "cwe": "CWE-362",
    "cve": "CVE-2020-29374",
    "purpose": "Code purpose:\"\"\"快速获取用户空间页面的函数，用于将用户空间的页面固定到内存中并返回页面的引用\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核的get_user_pages实现中，当处理写时复制(COW)页面时，未能正确处理读操作的语义，导致可能意外授予写访问权限。\"\"\"",
    "functions": "Functions:\n1. 函数名: __get_user_pages_fast\n- 参数: [unsigned long start, int nr_pages, int write, struct page **pages]\n- 调用者: 未明确显示（通常是内核中需要快速获取用户页面的代码）\n- 被调用者: [untagged_addr, access_ok, local_irq_save, gup_pgd_range, local_irq_restore]\n\n2. 函数名: untagged_addr\n- 参数: [unsigned long start]\n- 调用者: __get_user_pages_fast\n- 被调用者: []\n\n3. 函数名: access_ok\n- 参数: [void __user *start, unsigned long len]\n- 调用者: __get_user_pages_fast\n- 被调用者: []\n\n4. 函数名: local_irq_save\n- 参数: [unsigned long flags]\n- 调用者: __get_user_pages_fast\n- 被调用者: []\n\n5. 函数名: gup_pgd_range\n- 参数: [unsigned long start, unsigned long end, unsigned int gup_flags, struct page **pages, int *nr_pinned]\n- 调用者: __get_user_pages_fast\n- 被调用者: []\n\n6. 函数名: local_irq_restore\n- 参数: [unsigned long flags]\n- 调用者: __get_user_pages_fast\n- 被调用者: []\n\n7. 函数名: gup_fast_permitted\n- 参数: [unsigned long start, unsigned long end]\n- 调用者: 未直接显示（通过IS_ENABLED宏条件调用）\n- 被调用者: []"
  },
  {
    "id": 2674,
    "cwe": "CWE-362",
    "cve": "CVE-2020-29374",
    "purpose": "Code purpose:\"\"\"该代码用于快速获取用户空间页面的物理页框，支持写时复制(COW)场景下的页面获取\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当处理写时复制(COW)页面时，get_user_pages实现未能正确处理读操作的语义，导致可能授予非预期的写访问权限\"\"\"",
    "functions": "Functions:\n1. 函数名: internal_get_user_pages_fast\n- 参数: [start, nr_pages, gup_flags, pages]\n- 调用者: 未明确（可能是外部调用）\n- 被调用者: [untagged_addr, access_ok, gup_fast_permitted, local_irq_disable, gup_pgd_range, local_irq_enable, __gup_longterm_unlocked]\n\n2. 函数名: untagged_addr\n- 参数: [start]\n- 调用者: internal_get_user_pages_fast\n- 被调用者: []\n\n3. 函数名: access_ok\n- 参数: [(void __user *)start, len]\n- 调用者: internal_get_user_pages_fast\n- 被调用者: []\n\n4. 函数名: gup_fast_permitted\n- 参数: [start, end]\n- 调用者: internal_get_user_pages_fast\n- 被调用者: []\n\n5. 函数名: local_irq_disable\n- 参数: []\n- 调用者: internal_get_user_pages_fast\n- 被调用者: []\n\n6. 函数名: gup_pgd_range\n- 参数: [addr, end, gup_flags, pages, &nr_pinned]\n- 调用者: internal_get_user_pages_fast\n- 被调用者: []\n\n7. 函数名: local_irq_enable\n- 参数: []\n- 调用者: internal_get_user_pages_fast\n- 被调用者: []\n\n8. 函数名: __gup_longterm_unlocked\n- 参数: [start, nr_pages - nr_pinned, gup_flags, pages]\n- 调用者: internal_get_user_pages_fast\n- 被调用者: []"
  },
  {
    "id": 2675,
    "cwe": "CWE-362",
    "cve": "CVE-2020-29374",
    "purpose": "Code purpose:\"\"\"判断是否可以跟随写入PMD（页中间目录）条目，考虑写权限、强制访问和写时复制标志\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在实现get_user_pages时，对写时复制页面的读操作语义考虑不周，导致可能授予非预期的写访问权限\"\"\"",
    "functions": "Functions:\n1. 函数名: can_follow_write_pmd\n- 参数: [pmd_t pmd, unsigned int flags]\n- 调用者: 未提供（根据上下文推测可能是get_user_pages相关函数）\n- 被调用者: [pmd_write, pmd_dirty]\n\n2. 函数名: pmd_write\n- 参数: [pmd_t pmd]\n- 调用者: can_follow_write_pmd\n- 被调用者: []\n\n3. 函数名: pmd_dirty\n- 参数: [pmd_t pmd]\n- 调用者: can_follow_write_pmd\n- 被调用者: []"
  },
  {
    "id": 2763,
    "cwe": "CWE-362",
    "cve": "CVE-2020-36557",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中安装控制台终端，处理终端分配、端口安装及终端属性设置等操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在VT_DISALLOCATE ioctl操作与tty设备关闭/打开之间存在竞争条件，导致对已释放的vc_data结构体的访问，引发use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: con_install\n- 参数: [driver, tty]\n- 调用者: 未明确（应为tty子系统调用）\n- 被调用者: [console_lock, vc_allocate, tty_port_install, console_unlock]\n\n2. 函数名: console_lock\n- 参数: []\n- 调用者: con_install\n- 被调用者: []\n\n3. 函数名: vc_allocate\n- 参数: [currcons]\n- 调用者: con_install\n- 被调用者: []\n\n4. 函数名: tty_port_install\n- 参数: [&vc->port, driver, tty]\n- 调用者: con_install\n- 被调用者: []\n\n5. 函数名: console_unlock\n- 参数: []\n- 调用者: con_install\n- 被调用者: []"
  },
  {
    "id": 2764,
    "cwe": "CWE-362",
    "cve": "CVE-2020-36557",
    "purpose": "Code purpose:\"\"\"管理虚拟控制台(VT)的分配和初始化，包括内存分配、数据结构初始化和系统通知等操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在VT_DISALLOCATE ioctl操作与tty设备关闭/打开之间存在竞态条件，导致内核在释放虚拟控制台资源后可能被错误地继续访问\"\"\"",
    "functions": "Functions:\n1. 函数名: vc_allocate\n- 参数: [unsigned int currcons]\n- 调用者: 未显示\n- 被调用者: [WARN_CONSOLE_UNLOCKED, kzalloc, tty_port_init, INIT_WORK, visual_init, con_set_default_unimap, kzalloc, vc_init, vcs_make_sysfs, atomic_notifier_call_chain, visual_deinit, kfree]\n\n2. 函数名: WARN_CONSOLE_UNLOCKED\n- 参数: []\n- 调用者: vc_allocate\n- 被调用者: []\n\n3. 函数名: kzalloc\n- 参数: [sizeof(struct vc_data), GFP_KERNEL] 和 [vc->vc_screenbuf_size, GFP_KERNEL]\n- 调用者: vc_allocate\n- 被调用者: []\n\n4. 函数名: tty_port_init\n- 参数: [&vc->port]\n- 调用者: vc_allocate\n- 被调用者: []\n\n5. 函数名: INIT_WORK\n- 参数: [&vc_cons[currcons].SAK_work, vc_SAK]\n- 调用者: vc_allocate\n- 被调用者: []\n\n6. 函数名: visual_init\n- 参数: [vc, currcons, 1]\n- 调用者: vc_allocate\n- 被调用者: []\n\n7. 函数名: con_set_default_unimap\n- 参数: [vc]\n- 调用者: vc_allocate\n- 被调用者: []\n\n8. 函数名: vc_init\n- 参数: [vc, vc->vc_rows, vc->vc_cols, 1]\n- 调用者: vc_allocate\n- 被调用者: []\n\n9. 函数名: vcs_make_sysfs\n- 参数: [currcons]\n- 调用者: vc_allocate\n- 被调用者: []\n\n10. 函数名: atomic_notifier_call_chain\n- 参数: [&vt_notifier_list, VT_ALLOCATE, &param]\n- 调用者: vc_allocate\n- 被调用者: []\n\n11. 函数名: visual_deinit\n- 参数: [vc]\n- 调用者: vc_allocate\n- 被调用者: []\n\n12. 函数名: kfree\n- 参数: [vc]\n- 调用者: vc_allocate\n- 被调用者: []"
  },
  {
    "id": 2765,
    "cwe": "CWE-362",
    "cve": "CVE-2020-36557",
    "purpose": "Code purpose:\"\"\"该代码用于释放指定的虚拟控制台资源，包括检查控制台是否繁忙、解除分配以及清理相关数据结构。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在VT_DISALLOCATE ioctl操作与tty设备关闭/打开之间存在竞态条件，导致在释放vc结构后可能被错误地继续使用\"\"\"",
    "functions": "Functions:\n1. 函数名: vt_disallocate\n- 参数: [unsigned int vc_num]\n- 调用者: 不适用（由外部调用）\n- 被调用者: [console_lock, vt_busy, vc_deallocate, console_unlock, tty_port_destroy, kfree]\n\n2. 函数名: console_lock\n- 参数: []\n- 调用者: vt_disallocate\n- 被调用者: []\n\n3. 函数名: vt_busy\n- 参数: [unsigned int vc_num]\n- 调用者: vt_disallocate\n- 被调用者: []\n\n4. 函数名: vc_deallocate\n- 参数: [unsigned int vc_num]\n- 调用者: vt_disallocate\n- 被调用者: []\n\n5. 函数名: console_unlock\n- 参数: []\n- 调用者: vt_disallocate\n- 被调用者: []\n\n6. 函数名: tty_port_destroy\n- 参数: [&vc->port]\n- 调用者: vt_disallocate\n- 被调用者: []\n\n7. 函数名: kfree\n- 参数: [vc]\n- 调用者: vt_disallocate\n- 被调用者: []"
  },
  {
    "id": 2766,
    "cwe": "CWE-362",
    "cve": "CVE-2020-36557",
    "purpose": "Code purpose:\"\"\"该代码用于释放所有未使用的虚拟控制台资源，包括销毁端口和释放内存\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在释放虚拟终端(vc)资源时，由于缺少适当的同步机制，导致在VT_DISALLOCATE ioctl操作与tty设备的关闭/打开之间存在竞争条件，可能引发释放后重用(UAF)问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: vt_disallocate_all\n- 参数: []\n- 调用者: N/A\n- 被调用者: [console_lock, vt_busy, vc_deallocate, console_unlock, tty_port_destroy, kfree]\n\n2. 函数名: console_lock\n- 参数: []\n- 调用者: vt_disallocate_all\n- 被调用者: []\n\n3. 函数名: vt_busy\n- 参数: [i]\n- 调用者: vt_disallocate_all\n- 被调用者: []\n\n4. 函数名: vc_deallocate\n- 参数: [i]\n- 调用者: vt_disallocate_all\n- 被调用者: []\n\n5. 函数名: console_unlock\n- 参数: []\n- 调用者: vt_disallocate_all\n- 被调用者: []\n\n6. 函数名: tty_port_destroy\n- 参数: [&vc[i]->port]\n- 调用者: vt_disallocate_all\n- 被调用者: []\n\n7. 函数名: kfree\n- 参数: [vc[i]]\n- 调用者: vt_disallocate_all\n- 被调用者: []"
  },
  {
    "id": 2767,
    "cwe": "CWE-362",
    "cve": "CVE-2020-36558",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中虚拟终端(VT)的多种控制功能，包括终端模式设置、字体操作、屏幕大小调整、信号处理等，通过ioctl系统调用提供用户空间与虚拟终端设备的交互接口。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"VT_RESIZEX操作在处理虚拟终端控制台时存在竞态条件，可能导致对空指针的解引用和一般保护错误。\"\"\"",
    "functions": "Functions:\n1. 函数名: vt_ioctl\n- 参数: [struct tty_struct *tty, unsigned int cmd, unsigned long arg]\n- 调用者: N/A (kernel-level function)\n- 被调用者: [vc_cons_allocated, tioclinux, kd_mksound, msecs_to_jiffies, put_user, ksys_ioperm, copy_from_user, kbd_rate, copy_to_user, vt_do_kdskbmode, tty_ldisc_flush, vt_do_kdgkbmode, vt_do_kdskbmeta, vt_do_kdgkbmeta, vt_do_kbkeycode_ioctl, vt_do_kdsk_ioctl, vt_do_kdgkb_ioctl, vt_do_diacrit, vt_do_kdskled, valid_signal, put_pid, get_pid, task_pid, vc_allocate, set_console, vt_waitactive, complete_change_console, vt_disallocate, vt_disallocate_all, vc_resize, con_font_op, con_set_cmap, con_get_cmap, do_fontx_ioctl, con_set_default_unimap, con_set_trans_old, con_get_trans_old, con_set_trans_new, con_get_trans_new, con_clear_unimap, do_unimap_ioctl, vt_event_wait_ioctl]\n\n2. 函数名: tioclinux\n- 参数: [struct tty_struct *tty, unsigned long arg]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n3. 函数名: kd_mksound\n- 参数: [unsigned long arg, int ticks]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n4. 函数名: msecs_to_jiffies\n- 参数: [unsigned int msecs]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n5. 函数名: put_user\n- 参数: [type val, type __user *ptr]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n6. 函数名: ksys_ioperm\n- 参数: [unsigned long from, unsigned long num, int turn_on]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n7. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n8. 函数名: kbd_rate\n- 参数: [struct kbd_repeat *kbrep]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n9. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n10. 函数名: vt_do_kdskbmode\n- 参数: [unsigned int console, unsigned int arg]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n11. 函数名: tty_ldisc_flush\n- 参数: [struct tty_struct *tty]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n12. 函数名: vt_do_kdgkbmode\n- 参数: [unsigned int console]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n13. 函数名: vt_do_kdskbmeta\n- 参数: [unsigned int console, unsigned int arg]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n14. 函数名: vt_do_kdgkbmeta\n- 参数: [unsigned int console]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n15. 函数名: vt_do_kbkeycode_ioctl\n- 参数: [unsigned int cmd, void __user *up, int perm]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n16. 函数名: vt_do_kdsk_ioctl\n- 参数: [unsigned int cmd, void __user *up, int perm, unsigned int console]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n17. 函数名: vt_do_kdgkb_ioctl\n- 参数: [unsigned int cmd, void __user *up, int perm]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n18. 函数名: vt_do_diacrit\n- 参数: [unsigned int cmd, void __user *up, int perm]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n19. 函数名: vt_do_kdskled\n- 参数: [unsigned int console, unsigned int cmd, unsigned long arg, int perm]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n20. 函数名: valid_signal\n- 参数: [unsigned long sig]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n21. 函数名: put_pid\n- 参数: [struct pid *pid]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n22. 函数名: get_pid\n- 参数: [struct pid *pid]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n23. 函数名: task_pid\n- 参数: [struct task_struct *task]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n24. 函数名: vc_allocate\n- 参数: [unsigned int console]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n25. 函数名: set_console\n- 参数: [int nr]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n26. 函数名: vt_waitactive\n- 参数: [int arg]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n27. 函数名: complete_change_console\n- 参数: [struct vc_data *vc]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n28. 函数名: vt_disallocate\n- 参数: [int arg]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n29. 函数名: vt_disallocate_all\n- 参数: []\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n30. 函数名: vc_resize\n- 参数: [struct vc_data *vc, unsigned int cols, unsigned int rows]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n31. 函数名: con_font_op\n- 参数: [struct vc_data *vc, struct console_font_op *op]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n32. 函数名: con_set_cmap\n- 参数: [unsigned char __user *arg]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n33. 函数名: con_get_cmap\n- 参数: [unsigned char __user *arg]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n34. 函数名: do_fontx_ioctl\n- 参数: [unsigned int cmd, void __user *up, int perm, struct console_font_op *op]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n35. 函数名: con_set_default_unimap\n- 参数: [struct vc_data *vc]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n36. 函数名: con_set_trans_old\n- 参数: [unsigned char __user *arg]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n37. 函数名: con_get_trans_old\n- 参数: [unsigned char __user *arg]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n38. 函数名: con_set_trans_new\n- 参数: [unsigned short __user *arg]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n39. 函数名: con_get_trans_new\n- 参数: [unsigned short __user *arg]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n40. 函数名: con_clear_unimap\n- 参数: [struct vc_data *vc]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n41. 函数名: do_unimap_ioctl\n- 参数: [unsigned int cmd, void __user *up, int perm, struct vc_data *vc]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n42. 函数名: vt_event_wait_ioctl\n- 参数: [struct vt_event __user *event]\n- 调用者: vt_ioctl\n- 被调用者: N/A"
  },
  {
    "id": 2830,
    "cwe": "CWE-362",
    "cve": "CVE-2021-0920",
    "purpose": "Code purpose:\"\"\"该代码实现了Unix域套接字流式数据的读取功能，处理接收队列中的数据包并将内容复制到用户空间\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在unix_stream_read_generic函数中存在竞态条件，导致在释放skb后可能被并发访问，造成use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: unix_stream_read_generic\n- 参数: [struct unix_stream_read_state *state, bool freezable]\n- 调用者: N/A (顶层函数)\n- 被调用者: [unix_sk, sock_rcvlowat, sock_rcvtimeo, memset, mutex_lock, sk_peek_offset, unix_state_lock, sock_error, mutex_unlock, unix_stream_data_wait, signal_pending, sock_intr_errno, scm_destroy, unix_skb_len, skb_peek_next, unix_skb_scm_eq, scm_set_cred, unix_set_secdata, DECLARE_SOCKADDR, unix_copy_addr, min_t, skb_get, consume_skb, sk_peek_offset_bwd, scm_stat_del, unix_detach_fds, skb_unlink, scm_fp_dup, sk_peek_offset_fwd, scm_recv]\n\n2. 函数名: unix_sk\n- 参数: [struct sock *sk]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n3. 函数名: sock_rcvlowat\n- 参数: [struct sock *sk, int flags, size_t size]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n4. 函数名: sock_rcvtimeo\n- 参数: [struct sock *sk, int noblock]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n5. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n6. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n7. 函数名: sk_peek_offset\n- 参数: [struct sock *sk, int flags]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n8. 函数名: unix_state_lock\n- 参数: [struct sock *sk]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n9. 函数名: sock_error\n- 参数: [struct sock *sk]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n10. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n11. 函数名: unix_stream_data_wait\n- 参数: [struct sock *sk, long timeo, struct sk_buff *last, unsigned int last_len, bool freezable]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n12. 函数名: signal_pending\n- 参数: [struct task_struct *p]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n13. 函数名: sock_intr_errno\n- 参数: [long timeo]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n14. 函数名: scm_destroy\n- 参数: [struct scm_cookie *scm]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n15. 函数名: unix_skb_len\n- 参数: [struct sk_buff *skb]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n16. 函数名: skb_peek_next\n- 参数: [struct sk_buff *skb, struct sk_buff_head *list]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n17. 函数名: unix_skb_scm_eq\n- 参数: [struct sk_buff *skb, struct scm_cookie *scm]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n18. 函数名: scm_set_cred\n- 参数: [struct scm_cookie *scm, pid_t pid, kuid_t uid, kgid_t gid]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n19. 函数名: unix_set_secdata\n- 参数: [struct scm_cookie *scm, struct sk_buff *skb]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n20. 函数名: unix_copy_addr\n- 参数: [struct msghdr *msg, struct sock *sk]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n21. 函数名: min_t\n- 参数: [type, x, y]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n22. 函数名: skb_get\n- 参数: [struct sk_buff *skb]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n23. 函数名: consume_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n24. 函数名: sk_peek_offset_bwd\n- 参数: [struct sock *sk, int len]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n25. 函数名: scm_stat_del\n- 参数: [struct sock *sk, struct sk_buff *skb]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n26. 函数名: unix_detach_fds\n- 参数: [struct scm_cookie *scm, struct sk_buff *skb]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n27. 函数名: skb_unlink\n- 参数: [struct sk_buff *skb, struct sk_buff_head *list]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n28. 函数名: scm_fp_dup\n- 参数: [struct scm_fp_list *fp]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n29. 函数名: sk_peek_offset_fwd\n- 参数: [struct sock *sk, int len]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n30. 函数名: scm_recv\n- 参数: [struct socket *sock, struct msghdr *msg, struct scm_cookie *scm, int flags]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A"
  },
  {
    "id": 2831,
    "cwe": "CWE-362",
    "cve": "CVE-2021-0920",
    "purpose": "Code purpose:\"\"\"该代码实现了Unix域数据报套接字的接收消息功能，包括处理消息队列、数据拷贝、控制消息传递以及文件描述符的传递等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在unix_dgram_recvmsg函数中存在竞态条件，导致在释放skb后仍可能被访问，造成use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: unix_dgram_recvmsg\n- 参数: [struct socket *sock, struct msghdr *msg, size_t size, int flags]\n- 调用者: 外部调用\n- 被调用者: [unix_sk, sock_rcvtimeo, mutex_lock, sk_peek_offset, __skb_try_recv_datagram, scm_stat_del, mutex_unlock, __skb_wait_for_more_packets, unix_state_lock, unix_state_unlock, wake_up_interruptible_sync_poll, unix_copy_addr, skb_copy_datagram_msg, __sock_recv_timestamp, scm_set_cred, unix_set_secdata, unix_detach_fds, sk_peek_offset_bwd, sk_peek_offset_fwd, scm_fp_dup, scm_recv, skb_free_datagram]\n\n2. 函数名: unix_sk\n- 参数: [struct sock *sk]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n3. 函数名: sock_rcvtimeo\n- 参数: [struct sock *sk, int flags]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n4. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n5. 函数名: sk_peek_offset\n- 参数: [struct sock *sk, int flags]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n6. 函数名: __skb_try_recv_datagram\n- 参数: [struct sock *sk, struct sk_buff_head *queue, int flags, int *peek_offset, int *err, struct sk_buff **last]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n7. 函数名: scm_stat_del\n- 参数: [struct sock *sk, struct sk_buff *skb]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n8. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n9. 函数名: __skb_wait_for_more_packets\n- 参数: [struct sock *sk, struct sk_buff_head *queue, int *err, long *timeo, struct sk_buff *last]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n10. 函数名: unix_state_lock\n- 参数: [struct sock *sk]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n11. 函数名: unix_state_unlock\n- 参数: [struct sock *sk]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n12. 函数名: wake_up_interruptible_sync_poll\n- 参数: [wait_queue_head_t *wq_head, unsigned int mode]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n13. 函数名: unix_copy_addr\n- 参数: [struct msghdr *msg, struct sock *sk]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n14. 函数名: skb_copy_datagram_msg\n- 参数: [struct sk_buff *skb, int offset, struct msghdr *msg, int size]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n15. 函数名: __sock_recv_timestamp\n- 参数: [struct msghdr *msg, struct sock *sk, struct sk_buff *skb]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n16. 函数名: scm_set_cred\n- 参数: [struct scm_cookie *scm, pid_t pid, kuid_t uid, kgid_t gid]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n17. 函数名: unix_set_secdata\n- 参数: [struct scm_cookie *scm, struct sk_buff *skb]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n18. 函数名: unix_detach_fds\n- 参数: [struct scm_cookie *scm, struct sk_buff *skb]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n19. 函数名: sk_peek_offset_bwd\n- 参数: [struct sock *sk, int len]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n20. 函数名: sk_peek_offset_fwd\n- 参数: [struct sock *sk, int len]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n21. 函数名: scm_fp_dup\n- 参数: [struct scm_fp_list *fpl]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n22. 函数名: scm_recv\n- 参数: [struct socket *sock, struct msghdr *msg, struct scm_cookie *scm, int flags]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n23. 函数名: skb_free_datagram\n- 参数: [struct sock *sk, struct sk_buff *skb]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []"
  },
  {
    "id": 2861,
    "cwe": "CWE-362",
    "cve": "CVE-2021-20261",
    "purpose": "Code purpose:\"\"\"该代码用于处理软盘驱动器的格式化请求，包括参数验证和格式化操作执行，并存在竞争条件漏洞\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于Linux内核软盘控制器驱动程序中存在竞争条件，当多个进程同时访问floppy设备时可能导致未预期的行为。\"\"\"",
    "functions": "Functions:\n1. 函数名: do_format\n- 参数: [drive, tmp_format_req]\n- 调用者: 未显示（外部调用）\n- 被调用者: [lock_fdc, set_floppy, process_fd_request, wait_til_done]\n\n2. 函数名: lock_fdc\n- 参数: [drive, true]\n- 调用者: do_format\n- 被调用者: 未显示\n\n3. 函数名: set_floppy\n- 参数: [drive]\n- 调用者: do_format\n- 被调用者: 未显示\n\n4. 函数名: process_fd_request\n- 参数: []\n- 调用者: do_format\n- 被调用者: 未显示\n\n5. 函数名: wait_til_done\n- 参数: [redo_format, true]\n- 调用者: do_format\n- 被调用者: 未显示"
  },
  {
    "id": 2862,
    "cwe": "CWE-362",
    "cve": "CVE-2021-20261",
    "purpose": "Code purpose:\"\"\"检查软盘驱动器状态并返回媒体变更事件\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于Linux内核软盘驱动控制器中存在竞态条件，当检查磁盘状态时未正确同步对共享资源(UDRS->flags)的访问，导致可能发生条件竞争。\"\"\"",
    "functions": "Functions:\n1. 函数名: floppy_check_events\n- 参数: [struct gendisk *disk, unsigned int clearing]\n- 调用者: 未明确（通常是内核其他模块调用）\n- 被调用者: [test_bit, time_after, lock_fdc, poll_drive, process_fd_request, drive_no_geom]\n\n2. 函数名: test_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: floppy_check_events\n- 被调用者: []\n\n3. 函数名: time_after\n- 参数: [unsigned long a, unsigned long b]\n- 调用者: floppy_check_events\n- 被调用者: []\n\n4. 函数名: lock_fdc\n- 参数: [int drive, bool interruptible]\n- 调用者: floppy_check_events\n- 被调用者: []\n\n5. 函数名: poll_drive\n- 参数: [bool interruptible, int flag]\n- 调用者: floppy_check_events\n- 被调用者: []\n\n6. 函数名: process_fd_request\n- 参数: []\n- 调用者: floppy_check_events\n- 被调用者: []\n\n7. 函数名: drive_no_geom\n- 参数: [int drive]\n- 调用者: floppy_check_events\n- 被调用者: []"
  },
  {
    "id": 2863,
    "cwe": "CWE-362",
    "cve": "CVE-2021-20261",
    "purpose": "Code purpose:\"\"\"该代码用于实现软盘驱动器控制器的用户重置功能，包括锁定控制器、处理重置请求和执行后续操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在floppy磁盘驱动控制器驱动程序中存在竞态条件，当设备权限被修改时可能导致未授权的访问或操作\"\"\"",
    "functions": "Functions:\n1. 函数名: user_reset_fdc\n- 参数: [drive, arg, interruptible]\n- 调用者: 未明确（外部调用）\n- 被调用者: [lock_fdc, wait_til_done, process_fd_request]\n\n2. 函数名: lock_fdc\n- 参数: [drive, interruptible]\n- 调用者: user_reset_fdc\n- 被调用者: 未明确\n\n3. 函数名: wait_til_done\n- 参数: [reset_fdc, interruptible]\n- 调用者: user_reset_fdc\n- 被调用者: 未明确\n\n4. 函数名: process_fd_request\n- 参数: []\n- 调用者: user_reset_fdc\n- 被调用者: 未明确\n\n5. 函数名: reset_fdc\n- 参数: 未明确（作为回调函数传递给wait_til_done）\n- 调用者: wait_til_done（间接）\n- 被调用者: 未明确"
  },
  {
    "id": 2864,
    "cwe": "CWE-362",
    "cve": "CVE-2021-20261",
    "purpose": "Code purpose:\"\"\"获取指定软盘驱动器的几何结构信息，并根据类型参数返回对应的结构体指针\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于Linux内核软盘控制器驱动中存在的竞态条件问题，在获取软盘几何参数时未正确处理并发访问，可能导致数据竞争。\"\"\"",
    "functions": "Functions:\n1. 函数名: get_floppy_geometry\n- 参数: [drive, type, g]\n- 调用者: 未指定\n- 被调用者: [lock_fdc, poll_drive, process_fd_request]\n\n2. 函数名: lock_fdc\n- 参数: [drive, false]\n- 调用者: get_floppy_geometry\n- 被调用者: 未指定\n\n3. 函数名: poll_drive\n- 参数: [false, 0]\n- 调用者: get_floppy_geometry\n- 被调用者: 未指定\n\n4. 函数名: process_fd_request\n- 参数: []\n- 调用者: get_floppy_geometry\n- 被调用者: 未指定"
  },
  {
    "id": 2865,
    "cwe": "CWE-362",
    "cve": "CVE-2021-20261",
    "purpose": "Code purpose:\"\"\"该代码用于重新验证和更新软盘驱动器的状态，包括处理磁盘变更、几何信息检测和请求处理等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于floppy_revalidate函数中存在竞态条件，多个线程可能同时访问和修改共享资源UDRS->flags等状态，导致数据不一致或意外行为。\"\"\"",
    "functions": "Functions:\n1. 函数名: floppy_revalidate\n- 参数: [struct gendisk *disk]\n- 调用者: 未显示（由内核调用）\n- 被调用者: [test_bit, WARN, atomic_read, lock_fdc, process_fd_request, clear_bit, __floppy_read_block_0, poll_drive, set_capacity]\n\n2. 函数名: test_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: floppy_revalidate\n- 被调用者: []\n\n3. 函数名: WARN\n- 参数: [int condition, const char *fmt, ...]\n- 调用者: floppy_revalidate\n- 被调用者: []\n\n4. 函数名: atomic_read\n- 参数: [atomic_t *v]\n- 调用者: floppy_revalidate\n- 被调用者: []\n\n5. 函数名: lock_fdc\n- 参数: [int drive, bool interruptible]\n- 调用者: floppy_revalidate\n- 被调用者: []\n\n6. 函数名: process_fd_request\n- 参数: []\n- 调用者: floppy_revalidate\n- 被调用者: []\n\n7. 函数名: clear_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: floppy_revalidate\n- 被调用者: []\n\n8. 函数名: __floppy_read_block_0\n- 参数: [struct block_device *bdev, int drive]\n- 调用者: floppy_revalidate\n- 被调用者: []\n\n9. 函数名: poll_drive\n- 参数: [bool interruptible, int flag]\n- 调用者: floppy_revalidate\n- 被调用者: []\n\n10. 函数名: set_capacity\n- 参数: [struct gendisk *disk, sector_t size]\n- 调用者: floppy_revalidate\n- 被调用者: []\n\n11. 函数名: drive_no_geom\n- 参数: [int drive]\n- 调用者: floppy_revalidate\n- 被调用者: []"
  },
  {
    "id": 2877,
    "cwe": "CWE-362",
    "cve": "CVE-2021-20321",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核OverlayFS子系统中文件重命名的功能，处理不同目录间的文件移动和重命名操作，包括处理白名单、目录合并等特殊情况。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核OverlayFS子系统中存在竞态条件漏洞，当用户以特定方式执行重命名操作时，可能导致系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: ovl_rename\n- 参数: [mnt_userns, olddir, old, newdir, new, flags]\n- 调用者: N/A (kernel function)\n- 被调用者: [ovl_can_move, ovl_pure_upper, ovl_check_empty_dir, ovl_lower_positive, ovl_dentry_is_whiteout, ovl_want_write, ovl_copy_up, ovl_nlink_start, ovl_override_creds, ovl_clear_empty, ovl_dentry_upper, ovl_type_origin, ovl_set_impure, lock_rename, lookup_one_len, ovl_matches_upper, ovl_dentry_is_opaque, ovl_is_whiteout, ovl_type_merge_or_lower, ovl_set_redirect, ovl_type_merge, ovl_set_opaque_xerr, ovl_do_rename, ovl_cleanup, clear_nlink, ovl_drop_nlink, ovl_dir_modified, ovl_copyattr, dput, unlock_rename, revert_creds, ovl_nlink_end, ovl_drop_write, ovl_cache_free]\n\n2. 函数名: ovl_can_move\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n3. 函数名: ovl_pure_upper\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n4. 函数名: ovl_check_empty_dir\n- 参数: [dentry, list]\n- 调用者: ovl_rename\n- 被调用者: []\n\n5. 函数名: ovl_lower_positive\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n6. 函数名: ovl_dentry_is_whiteout\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n7. 函数名: ovl_want_write\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n8. 函数名: ovl_copy_up\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n9. 函数名: ovl_nlink_start\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n10. 函数名: ovl_override_creds\n- 参数: [sb]\n- 调用者: ovl_rename\n- 被调用者: []\n\n11. 函数名: ovl_clear_empty\n- 参数: [dentry, list]\n- 调用者: ovl_rename\n- 被调用者: []\n\n12. 函数名: ovl_dentry_upper\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n13. 函数名: ovl_type_origin\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n14. 函数名: ovl_set_impure\n- 参数: [dentry, upper]\n- 调用者: ovl_rename\n- 被调用者: []\n\n15. 函数名: lock_rename\n- 参数: [new_upperdir, old_upperdir]\n- 调用者: ovl_rename\n- 被调用者: []\n\n16. 函数名: lookup_one_len\n- 参数: [name, base, len]\n- 调用者: ovl_rename\n- 被调用者: []\n\n17. 函数名: ovl_matches_upper\n- 参数: [dentry, upper]\n- 调用者: ovl_rename\n- 被调用者: []\n\n18. 函数名: ovl_dentry_is_opaque\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n19. 函数名: ovl_is_whiteout\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n20. 函数名: ovl_type_merge_or_lower\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n21. 函数名: ovl_set_redirect\n- 参数: [dentry, samedir]\n- 调用者: ovl_rename\n- 被调用者: []\n\n22. 函数名: ovl_type_merge\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n23. 函数名: ovl_set_opaque_xerr\n- 参数: [dentry, upper, err]\n- 调用者: ovl_rename\n- 被调用者: []\n\n24. 函数名: ovl_do_rename\n- 参数: [old_dir, old_dentry, new_dir, new_dentry, flags]\n- 调用者: ovl_rename\n- 被调用者: []\n\n25. 函数名: ovl_cleanup\n- 参数: [dir, dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n26. 函数名: clear_nlink\n- 参数: [inode]\n- 调用者: ovl_rename\n- 被调用者: []\n\n27. 函数名: ovl_drop_nlink\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n28. 函数名: ovl_dir_modified\n- 参数: [dentry, origin]\n- 调用者: ovl_rename\n- 被调用者: []\n\n29. 函数名: ovl_copyattr\n- 参数: [inode, inode]\n- 调用者: ovl_rename\n- 被调用者: []\n\n30. 函数名: dput\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n31. 函数名: unlock_rename\n- 参数: [new_upperdir, old_upperdir]\n- 调用者: ovl_rename\n- 被调用者: []\n\n32. 函数名: revert_creds\n- 参数: [old_cred]\n- 调用者: ovl_rename\n- 被调用者: []\n\n33. 函数名: ovl_nlink_end\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n34. 函数名: ovl_drop_write\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n35. 函数名: ovl_cache_free\n- 参数: [list]\n- 调用者: ovl_rename\n- 被调用者: []"
  },
  {
    "id": 2887,
    "cwe": "CWE-362",
    "cve": "CVE-2021-23133",
    "purpose": "Code purpose:\"\"\"释放SCTP套接字资源并处理自动配置列表的清理工作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在sctp_destroy_sock函数中，当处理auto_asconf_list列表时未获取addr_wq_lock锁，导致竞态条件可能被利用进行权限提升\"\"\"",
    "functions": "Functions:\n1. 函数名: sctp_destroy_sock\n- 参数: [struct sock *sk]\n- 调用者: 未明确显示（通常是内核中销毁socket的调用链）\n- 被调用者: [sctp_sk, sctp_endpoint_free, local_bh_disable, sk_sockets_allocated_dec, sock_prot_inuse_add, sock_net, local_bh_enable]\n\n2. 函数名: sctp_sk\n- 参数: [struct sock *sk]\n- 调用者: sctp_destroy_sock\n- 被调用者: []\n\n3. 函数名: sctp_endpoint_free\n- 参数: [struct sctp_endpoint *ep]\n- 调用者: sctp_destroy_sock\n- 被调用者: []\n\n4. 函数名: local_bh_disable\n- 参数: []\n- 调用者: sctp_destroy_sock\n- 被调用者: []\n\n5. 函数名: sk_sockets_allocated_dec\n- 参数: [struct sock *sk]\n- 调用者: sctp_destroy_sock\n- 被调用者: []\n\n6. 函数名: sock_prot_inuse_add\n- 参数: [struct net *net, struct proto *prot, int val]\n- 调用者: sctp_destroy_sock\n- 被调用者: []\n\n7. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sctp_destroy_sock\n- 被调用者: []\n\n8. 函数名: local_bh_enable\n- 参数: []\n- 调用者: sctp_destroy_sock\n- 被调用者: []\n\n9. 函数名: list_del\n- 参数: [struct list_head *entry]\n- 调用者: sctp_destroy_sock\n- 被调用者: []\n\n10. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: sctp_destroy_sock\n- 被调用者: []"
  },
  {
    "id": 2888,
    "cwe": "CWE-362",
    "cve": "CVE-2021-23133",
    "purpose": "Code purpose:\"\"\"初始化SCTP套接字并设置相关参数，包括默认发送参数、关联参数、事件订阅等，同时处理自动配置列表的并发访问问题\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在SCTP套接字销毁时未正确获取addr_wq_lock锁的情况下修改auto_asconf_splist链表，导致竞态条件可能被利用进行权限提升\"\"\"",
    "functions": "Functions:\n1. 函数名: sctp_init_sock\n- 参数: [struct sock *sk]\n- 调用者: 未显示（通常由socket创建流程调用）\n- 被调用者: [sock_net, sctp_sk, pr_debug, htons, sctp_endpoint_new, sctp_get_pf_specific, atomic_set, skb_queue_head_init, local_bh_disable, sk_sockets_allocated_inc, sock_prot_inuse_add, spin_lock, list_add_tail, spin_unlock, local_bh_enable]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n3. 函数名: sctp_sk\n- 参数: [struct sock *sk]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n4. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n5. 函数名: htons\n- 参数: [uint16_t hostshort]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n6. 函数名: sctp_endpoint_new\n- 参数: [struct sock *sk, gfp_t gfp]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n7. 函数名: sctp_get_pf_specific\n- 参数: [int family]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n8. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n9. 函数名: skb_queue_head_init\n- 参数: [struct sk_buff_head *list]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n10. 函数名: local_bh_disable\n- 参数: []\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n11. 函数名: sk_sockets_allocated_inc\n- 参数: [struct sock *sk]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n12. 函数名: sock_prot_inuse_add\n- 参数: [struct net *net, struct proto *prot, int val]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n13. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n14. 函数名: list_add_tail\n- 参数: [struct list_head *new, struct list_head *head]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n15. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n16. 函数名: local_bh_enable\n- 参数: []\n- 调用者: sctp_init_sock\n- 被调用者: []"
  },
  {
    "id": 2889,
    "cwe": "CWE-362",
    "cve": "CVE-2021-23133",
    "purpose": "Code purpose:\"\"\"该代码实现了SCTP套接字的关闭功能，包括清理接收队列、处理关联状态以及释放相关资源，但存在竞争条件漏洞可能导致权限提升。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在调用sctp_destroy_sock时未正确获取addr_wq_lock锁，导致auto_asconf_splist列表元素在无锁保护情况下被移除，引发竞争条件漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: sctp_close\n- 参数: [struct sock *sk, long timeout]\n- 调用者: 无（系统调用或内核其他部分）\n- 被调用者: [sock_net, lock_sock_nested, inet_sk_set_state, sctp_sk, sctp_queue_purge_ulpevents, list_for_each_safe, list_entry, sctp_style, sctp_state, sctp_association_free, skb_queue_empty, sock_flag, sctp_make_abort_user, sctp_primitive_ABORT, sctp_primitive_SHUTDOWN, sctp_wait_for_close, release_sock, spin_lock_bh, bh_lock_sock_nested, sock_hold, sk_common_release, bh_unlock_sock, spin_unlock_bh, sock_put]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n3. 函数名: lock_sock_nested\n- 参数: [struct sock *sk, int subclass]\n- 调用者: sctp_close\n- 被调用者: 无\n\n4. 函数名: inet_sk_set_state\n- 参数: [struct sock *sk, int state]\n- 调用者: sctp_close\n- 被调用者: 无\n\n5. 函数名: sctp_sk\n- 参数: [struct sock *sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n6. 函数名: sctp_queue_purge_ulpevents\n- 参数: [struct sk_buff_head *list]\n- 调用者: sctp_close\n- 被调用者: 无\n\n7. 函数名: list_for_each_safe\n- 参数: [struct list_head *pos, struct list_head *temp, struct list_head *head]\n- 调用者: sctp_close\n- 被调用者: 无\n\n8. 函数名: list_entry\n- 参数: [struct list_head *ptr, type, member]\n- 调用者: sctp_close\n- 被调用者: 无\n\n9. 函数名: sctp_style\n- 参数: [struct sock *sk, int style]\n- 调用者: sctp_close\n- 被调用者: 无\n\n10. 函数名: sctp_state\n- 参数: [struct sctp_association *asoc, int state]\n- 调用者: sctp_close\n- 被调用者: 无\n\n11. 函数名: sctp_association_free\n- 参数: [struct sctp_association *asoc]\n- 调用者: sctp_close\n- 被调用者: 无\n\n12. 函数名: skb_queue_empty\n- 参数: [struct sk_buff_head *list]\n- 调用者: sctp_close\n- 被调用者: 无\n\n13. 函数名: sock_flag\n- 参数: [struct sock *sk, int flag]\n- 调用者: sctp_close\n- 被调用者: 无\n\n14. 函数名: sctp_make_abort_user\n- 参数: [struct sctp_association *asoc, void *payload, size_t paylen]\n- 调用者: sctp_close\n- 被调用者: 无\n\n15. 函数名: sctp_primitive_ABORT\n- 参数: [struct net *net, struct sctp_association *asoc, struct sctp_chunk *chunk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n16. 函数名: sctp_primitive_SHUTDOWN\n- 参数: [struct net *net, struct sctp_association *asoc, struct sctp_chunk *chunk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n17. 函数名: sctp_wait_for_close\n- 参数: [struct sock *sk, long timeout]\n- 调用者: sctp_close\n- 被调用者: 无\n\n18. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n19. 函数名: spin_lock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: sctp_close\n- 被调用者: 无\n\n20. 函数名: bh_lock_sock_nested\n- 参数: [struct sock *sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n21. 函数名: sock_hold\n- 参数: [struct sock *sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n22. 函数名: sk_common_release\n- 参数: [struct sock *sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n23. 函数名: bh_unlock_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n24. 函数名: spin_unlock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: sctp_close\n- 被调用者: 无\n\n25. 函数名: sock_put\n- 参数: [struct sock *sk]\n- 调用者: sctp_close\n- 被调用者: 无"
  },
  {
    "id": 2939,
    "cwe": "CWE-362",
    "cve": "CVE-2021-28964",
    "purpose": "Code purpose:\"\"\"该代码用于在Btrfs文件系统中获取旧的根节点，处理树修改日志以支持时间序列查询，但存在竞态条件漏洞可能导致拒绝服务。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在克隆操作前未对extent buffer进行适当的锁定，导致竞态条件可能引发拒绝服务(BUG)。\"\"\"",
    "functions": "Functions:\n1. 函数名: get_old_root\n- 参数: [struct btrfs_root *root, u64 time_seq]\n- 调用者: N/A\n- 被调用者: [btrfs_read_lock_root_node, __tree_mod_log_oldest_root, btrfs_header_level, tree_mod_log_search, btrfs_tree_read_unlock, free_extent_buffer, read_tree_block, WARN_ON, IS_ERR, extent_buffer_uptodate, btrfs_warn, btrfs_clone_extent_buffer, btrfs_header_owner, alloc_dummy_extent_buffer, btrfs_set_header_bytenr, btrfs_set_header_backref_rev, btrfs_set_header_owner, btrfs_set_header_level, btrfs_set_header_generation, btrfs_set_buffer_lockdep_class, btrfs_tree_read_lock, __tree_mod_log_rewind, btrfs_header_nritems, BTRFS_NODEPTRS_PER_BLOCK]\n\n2. 函数名: btrfs_read_lock_root_node\n- 参数: [struct btrfs_root *root]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n3. 函数名: __tree_mod_log_oldest_root\n- 参数: [struct extent_buffer *eb_root, u64 time_seq]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n4. 函数名: btrfs_header_level\n- 参数: [struct extent_buffer *eb]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n5. 函数名: tree_mod_log_search\n- 参数: [struct btrfs_fs_info *fs_info, u64 logical, u64 time_seq]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n6. 函数名: btrfs_tree_read_unlock\n- 参数: [struct extent_buffer *eb]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n7. 函数名: free_extent_buffer\n- 参数: [struct extent_buffer *eb]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n8. 函数名: read_tree_block\n- 参数: [struct btrfs_fs_info *fs_info, u64 logical, u64 objectid, u64 parent_transid, int level, struct btrfs_key *first_key]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n9. 函数名: WARN_ON\n- 参数: [condition]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n10. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n11. 函数名: extent_buffer_uptodate\n- 参数: [struct extent_buffer *eb]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n12. 函数名: btrfs_warn\n- 参数: [struct btrfs_fs_info *fs_info, const char *fmt, ...]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n13. 函数名: btrfs_clone_extent_buffer\n- 参数: [struct extent_buffer *src]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n14. 函数名: btrfs_header_owner\n- 参数: [struct extent_buffer *eb]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n15. 函数名: alloc_dummy_extent_buffer\n- 参数: [struct btrfs_fs_info *fs_info, u64 start]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n16. 函数名: btrfs_set_header_bytenr\n- 参数: [struct extent_buffer *eb, u64 bytenr]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n17. 函数名: btrfs_set_header_backref_rev\n- 参数: [struct extent_buffer *eb, int rev]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n18. 函数名: btrfs_set_header_owner\n- 参数: [struct extent_buffer *eb, u64 owner]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n19. 函数名: btrfs_set_header_level\n- 参数: [struct extent_buffer *eb, int level]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n20. 函数名: btrfs_set_header_generation\n- 参数: [struct extent_buffer *eb, u64 generation]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n21. 函数名: btrfs_set_buffer_lockdep_class\n- 参数: [u64 owner, struct extent_buffer *eb, int level]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n22. 函数名: btrfs_tree_read_lock\n- 参数: [struct extent_buffer *eb]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n23. 函数名: __tree_mod_log_rewind\n- 参数: [struct btrfs_fs_info *fs_info, struct extent_buffer *eb, u64 time_seq, struct tree_mod_elem *tm]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n24. 函数名: btrfs_header_nritems\n- 参数: [struct extent_buffer *eb]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n25. 函数名: BTRFS_NODEPTRS_PER_BLOCK\n- 参数: [struct btrfs_fs_info *fs_info]\n- 调用者: get_old_root\n- 被调用者: N/A"
  },
  {
    "id": 2947,
    "cwe": "CWE-362",
    "cve": "CVE-2021-29265",
    "purpose": "Code purpose:\"\"\"该代码用于管理USB/IP stub设备的socket连接状态，包括建立和断开连接，并处理相关的状态转换和资源分配。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在stub-up过程中对本地和共享状态的更新存在竞态条件，导致可能引发拒绝服务(GPF)漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: usbip_sockfd_store\n- 参数: [dev, attr, buf, count]\n- 调用者: 未显示（由设备属性子系统调用）\n- 被调用者: [dev_get_drvdata, dev_err, sscanf, dev_info, spin_lock_irq, sockfd_lookup, sockfd_put, spin_unlock_irq, kthread_get_run, usbip_event_add]\n\n2. 函数名: dev_get_drvdata\n- 参数: [dev]\n- 调用者: usbip_sockfd_store\n- 被调用者: []\n\n3. 函数名: dev_err\n- 参数: [dev, format_string]\n- 调用者: usbip_sockfd_store\n- 被调用者: []\n\n4. 函数名: sscanf\n- 参数: [buf, format_string, sockfd]\n- 调用者: usbip_sockfd_store\n- 被调用者: []\n\n5. 函数名: dev_info\n- 参数: [dev, format_string]\n- 调用者: usbip_sockfd_store\n- 被调用者: []\n\n6. 函数名: spin_lock_irq\n- 参数: [&sdev->ud.lock]\n- 调用者: usbip_sockfd_store\n- 被调用者: []\n\n7. 函数名: sockfd_lookup\n- 参数: [sockfd, &err]\n- 调用者: usbip_sockfd_store\n- 被调用者: []\n\n8. 函数名: sockfd_put\n- 参数: [socket]\n- 调用者: usbip_sockfd_store\n- 被调用者: []\n\n9. 函数名: spin_unlock_irq\n- 参数: [&sdev->ud.lock]\n- 调用者: usbip_sockfd_store\n- 被调用者: []\n\n10. 函数名: kthread_get_run\n- 参数: [stub_rx_loop/stub_tx_loop, &sdev->ud, \"stub_rx\"/\"stub_tx\"]\n- 调用者: usbip_sockfd_store\n- 被调用者: []\n\n11. 函数名: usbip_event_add\n- 参数: [&sdev->ud, SDEV_EVENT_DOWN]\n- 调用者: usbip_sockfd_store\n- 被调用者: []"
  },
  {
    "id": 2965,
    "cwe": "CWE-362",
    "cve": "CVE-2021-32399",
    "purpose": "Code purpose:\"\"\"该代码用于在HCI控制器上同步执行请求操作，包括加锁、执行请求和解锁过程，确保对HCI控制器的串行访问。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在HCI控制器移除过程中存在竞争条件，导致在检查HCI_UP标志位和实际执行请求之间可能发生状态变化\"\"\"",
    "functions": "Functions:\n1. 函数名: hci_req_sync\n- 参数: [hdev, req, opt, timeout, hci_status]\n- 调用者: 未显示\n- 被调用者: [test_bit, hci_req_sync_lock, __hci_req_sync, hci_req_sync_unlock]\n\n2. 函数名: test_bit\n- 参数: [HCI_UP, &hdev->flags]\n- 调用者: hci_req_sync\n- 被调用者: 未显示\n\n3. 函数名: hci_req_sync_lock\n- 参数: [hdev]\n- 调用者: hci_req_sync\n- 被调用者: 未显示\n\n4. 函数名: __hci_req_sync\n- 参数: [hdev, req, opt, timeout, hci_status]\n- 调用者: hci_req_sync\n- 被调用者: 未显示\n\n5. 函数名: hci_req_sync_unlock\n- 参数: [hdev]\n- 调用者: hci_req_sync\n- 被调用者: 未显示"
  },
  {
    "id": 2980,
    "cwe": "CWE-362",
    "cve": "CVE-2021-3348",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的NBD(网络块设备)驱动中添加一个新的socket连接，处理设备设置过程中的并发控制和资源分配\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在设备设置过程中存在竞态条件，导致在I/O请求处理时可能发生use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: nbd_add_socket\n- 参数: [struct nbd_device *nbd, unsigned long arg, bool netlink]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [nbd_get_socket, dev_err, kzalloc, krealloc, kfree, mutex_init, atomic_inc, sockfd_put]\n\n2. 函数名: nbd_get_socket\n- 参数: [struct nbd_device *nbd, unsigned long arg, int *err]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确（代码片段中未显示）\n\n3. 函数名: dev_err\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确（标准内核函数）\n\n4. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确（标准内核函数）\n\n5. 函数名: krealloc\n- 参数: [const void *p, size_t new_size, gfp_t flags]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确（标准内核函数）\n\n6. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确（标准内核函数）\n\n7. 函数名: mutex_init\n- 参数: [struct mutex *lock]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确（标准内核函数）\n\n8. 函数名: atomic_inc\n- 参数: [atomic_t *v]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确（标准内核函数）\n\n9. 函数名: sockfd_put\n- 参数: [struct socket *sock]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确（标准内核函数）"
  },
  {
    "id": 3019,
    "cwe": "CWE-362",
    "cve": "CVE-2021-3573",
    "purpose": "Code purpose:\"\"\"处理HCI设备事件并管理相关套接字连接，包括监控事件发送、设备状态变更通知和套接字分离操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于hci_sock_dev_event函数在处理设备注销事件时存在竞态条件，导致在释放hdev设备后仍可能被其他操作引用，造成释放后使用漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: hci_sock_dev_event\n- 参数: [struct hci_dev *hdev, int event]\n- 调用者: 未显示\n- 被调用者: [atomic_read, create_monitor_event, hci_send_to_channel, kfree_skb, hci_si_event, read_lock, sk_for_each, bh_lock_sock_nested, hci_pi, sk->sk_state_change, hci_dev_put, bh_unlock_sock, read_unlock]\n\n2. 函数名: atomic_read\n- 参数: [&monitor_promisc]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n3. 函数名: create_monitor_event\n- 参数: [hdev, event]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n4. 函数名: hci_send_to_channel\n- 参数: [HCI_CHANNEL_MONITOR, skb, HCI_SOCK_TRUSTED, NULL]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n5. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n6. 函数名: hci_si_event\n- 参数: [NULL, HCI_EV_SI_DEVICE, sizeof(ev), &ev]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n7. 函数名: read_lock\n- 参数: [&hci_sk_list.lock]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n8. 函数名: sk_for_each\n- 参数: [sk, &hci_sk_list.head]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n9. 函数名: bh_lock_sock_nested\n- 参数: [sk]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n10. 函数名: hci_pi\n- 参数: [sk]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n11. 函数名: sk->sk_state_change\n- 参数: [sk]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n12. 函数名: hci_dev_put\n- 参数: [hdev]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n13. 函数名: bh_unlock_sock\n- 参数: [sk]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n14. 函数名: read_unlock\n- 参数: [&hci_sk_list.lock]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示"
  },
  {
    "id": 3021,
    "cwe": "CWE-362",
    "cve": "CVE-2021-3609",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中CAN BCM网络协议的socket释放功能，包括移除相关操作、定时器、取消注册等清理工作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中CAN BCM网络协议存在竞态条件漏洞，当本地攻击者利用bcm_release函数中的锁机制缺陷时，可导致内存损坏、系统崩溃或权限提升\"\"\"",
    "functions": "Functions:\n1. 函数名: bcm_release\n- 参数: [struct socket *sock]\n- 调用者: 无（系统调用或内核其他部分调用）\n- 被调用者: [sock_net, bcm_sk, spin_lock, spin_unlock, schedule_timeout_uninterruptible, list_del, lock_sock, list_for_each_entry_safe, bcm_remove_op, dev_get_by_index, bcm_rx_unreg, dev_put, can_rx_unregister, remove_proc_entry, sock_orphan, release_sock, sock_put]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: bcm_release\n- 被调用者: 无\n\n3. 函数名: bcm_sk\n- 参数: [struct sock *sk]\n- 调用者: bcm_release\n- 被调用者: 无\n\n4. 函数名: spin_lock\n- 参数: [&bcm_notifier_lock]\n- 调用者: bcm_release\n- 被调用者: 无\n\n5. 函数名: spin_unlock\n- 参数: [&bcm_notifier_lock]\n- 调用者: bcm_release\n- 被调用者: 无\n\n6. 函数名: schedule_timeout_uninterruptible\n- 参数: [1]\n- 调用者: bcm_release\n- 被调用者: 无\n\n7. 函数名: list_del\n- 参数: [&bo->notifier]\n- 调用者: bcm_release\n- 被调用者: 无\n\n8. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: bcm_release\n- 被调用者: 无\n\n9. 函数名: list_for_each_entry_safe\n- 参数: [op, next, &bo->tx_ops, list]\n- 调用者: bcm_release\n- 被调用者: 无\n\n10. 函数名: bcm_remove_op\n- 参数: [struct bcm_op *op]\n- 调用者: bcm_release\n- 被调用者: 无\n\n11. 函数名: dev_get_by_index\n- 参数: [net, op->ifindex]\n- 调用者: bcm_release\n- 被调用者: 无\n\n12. 函数名: bcm_rx_unreg\n- 参数: [dev, op]\n- 调用者: bcm_release\n- 被调用者: 无\n\n13. 函数名: dev_put\n- 参数: [dev]\n- 调用者: bcm_release\n- 被调用者: 无\n\n14. 函数名: can_rx_unregister\n- 参数: [net, NULL, op->can_id, REGMASK(op->can_id), bcm_rx_handler, op]\n- 调用者: bcm_release\n- 被调用者: 无\n\n15. 函数名: remove_proc_entry\n- 参数: [bo->procname, net->can.bcmproc_dir]\n- 调用者: bcm_release\n- 被调用者: 无\n\n16. 函数名: sock_orphan\n- 参数: [sk]\n- 调用者: bcm_release\n- 被调用者: 无\n\n17. 函数名: release_sock\n- 参数: [sk]\n- 调用者: bcm_release\n- 被调用者: 无\n\n18. 函数名: sock_put\n- 参数: [sk]\n- 调用者: bcm_release\n- 被调用者: 无"
  },
  {
    "id": 3022,
    "cwe": "CWE-362",
    "cve": "CVE-2021-3609",
    "purpose": "Code purpose:\"\"\"该代码用于在CAN BCM协议中删除与指定条件匹配的接收操作，包括取消相关网络设备的注册和清理操作资源。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在删除CAN BCM协议中的接收操作时存在竞态条件，导致本地攻击者可能利用此条件破坏内存、使系统崩溃或提升权限\"\"\"",
    "functions": "Functions:\n1. 函数名: bcm_delete_rx_op\n- 参数: [ops, mh, ifindex]\n- 调用者: 未显示在代码片段中\n- 被调用者: [dev_get_by_index, bcm_rx_unreg, dev_put, can_rx_unregister, list_del, bcm_remove_op]\n\n2. 函数名: dev_get_by_index\n- 参数: [sock_net(op->sk), op->ifindex]\n- 调用者: bcm_delete_rx_op\n- 被调用者: 未显示在代码片段中\n\n3. 函数名: bcm_rx_unreg\n- 参数: [dev, op]\n- 调用者: bcm_delete_rx_op\n- 被调用者: 未显示在代码片段中\n\n4. 函数名: dev_put\n- 参数: [dev]\n- 调用者: bcm_delete_rx_op\n- 被调用者: 未显示在代码片段中\n\n5. 函数名: can_rx_unregister\n- 参数: [sock_net(op->sk), NULL, op->can_id, REGMASK(op->can_id), bcm_rx_handler, op]\n- 调用者: bcm_delete_rx_op\n- 被调用者: 未显示在代码片段中\n\n6. 函数名: list_del\n- 参数: [&op->list]\n- 调用者: bcm_delete_rx_op\n- 被调用者: 未显示在代码片段中\n\n7. 函数名: bcm_remove_op\n- 参数: [op]\n- 调用者: bcm_delete_rx_op\n- 被调用者: 未显示在代码片段中"
  },
  {
    "id": 3026,
    "cwe": "CWE-362",
    "cve": "CVE-2021-3640",
    "purpose": "Code purpose:\"\"\"该代码实现了蓝牙HCI子系统中SCO socket的消息发送功能，处理连接状态检查并发送数据帧。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在sco_sock_sendmsg()函数中存在竞态条件，当sco_conn_del()与sco_sock_sendmsg()同时被调用时，可能导致释放后使用(UAF)的内存错误。\"\"\"",
    "functions": "Functions:\n1. 函数名: sco_sock_sendmsg\n- 参数: [sock, msg, len]\n- 调用者: 未明确显示（由内核调用）\n- 被调用者: [sock_error, lock_sock, sco_send_frame, release_sock]\n\n2. 函数名: sock_error\n- 参数: [sk]\n- 调用者: sco_sock_sendmsg\n- 被调用者: []\n\n3. 函数名: lock_sock\n- 参数: [sk]\n- 调用者: sco_sock_sendmsg\n- 被调用者: []\n\n4. 函数名: sco_send_frame\n- 参数: [sk, msg, len]\n- 调用者: sco_sock_sendmsg\n- 被调用者: []\n\n5. 函数名: release_sock\n- 参数: [sk]\n- 调用者: sco_sock_sendmsg\n- 被调用者: []"
  },
  {
    "id": 3053,
    "cwe": "CWE-362",
    "cve": "CVE-2021-3752",
    "purpose": "Code purpose:\"\"\"在蓝牙子系统中处理L2CAP通道关闭时释放相关socket资源\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于蓝牙子系统中存在竞态条件，当用户同时调用连接和断开套接字操作时，会导致释放后重用(use-after-free)漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: l2cap_sock_close_cb\n- 参数: [struct l2cap_chan *chan]\n- 调用者: 未明确（由Linux内核蓝牙子系统调用）\n- 被调用者: [l2cap_sock_kill]\n\n2. 函数名: l2cap_sock_kill\n- 参数: [struct sock *sk]\n- 调用者: l2cap_sock_close_cb\n- 被调用者: []"
  },
  {
    "id": 3054,
    "cwe": "CWE-362",
    "cve": "CVE-2021-3752",
    "purpose": "Code purpose:\"\"\"在蓝牙子系统中处理L2CAP套接字销毁时的资源清理工作，包括释放通道和清空接收/发送队列\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于Linux内核蓝牙子系统中存在竞态条件，当用户同时调用socket连接和断开操作时会导致释放后使用漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: l2cap_sock_destruct\n- 参数: [struct sock *sk]\n- 调用者: 不适用（通常由内核调用）\n- 被调用者: [l2cap_pi, BT_DBG, l2cap_chan_put, kfree_skb, skb_queue_purge]\n\n2. 函数名: l2cap_pi\n- 参数: [struct sock *sk]\n- 调用者: l2cap_sock_destruct\n- 被调用者: []\n\n3. 函数名: BT_DBG\n- 参数: [\"sk %p\", sk]\n- 调用者: l2cap_sock_destruct\n- 被调用者: []\n\n4. 函数名: l2cap_chan_put\n- 参数: [l2cap_pi(sk)->chan]\n- 调用者: l2cap_sock_destruct\n- 被调用者: []\n\n5. 函数名: kfree_skb\n- 参数: [l2cap_pi(sk)->rx_busy_skb]\n- 调用者: l2cap_sock_destruct\n- 被调用者: []\n\n6. 函数名: skb_queue_purge\n- 参数: [&sk->sk_receive_queue, &sk->sk_write_queue]\n- 调用者: l2cap_sock_destruct\n- 被调用者: []"
  },
  {
    "id": 3055,
    "cwe": "CWE-362",
    "cve": "CVE-2021-3752",
    "purpose": "Code purpose:\"\"\"处理L2CAP通道的关闭和清理操作，包括监听和非监听状态的套接字，确保资源正确释放并避免竞态条件。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在蓝牙子系统的套接字拆卸回调函数中存在竞态条件，当用户同时调用连接和断开操作时可能导致释放后使用漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: l2cap_sock_teardown_cb\n- 参数: [struct l2cap_chan *chan, int err]\n- 调用者: 未明确显示（由蓝牙子系统调用）\n- 被调用者: [lock_sock_nested, bt_sk, l2cap_sock_cleanup_listen, bt_accept_unlink, release_sock, sock_set_flag]\n\n2. 函数名: lock_sock_nested\n- 参数: [struct sock *sk, int subclass]\n- 调用者: l2cap_sock_teardown_cb\n- 被调用者: []\n\n3. 函数名: bt_sk\n- 参数: [struct sock *sk]\n- 调用者: l2cap_sock_teardown_cb\n- 被调用者: []\n\n4. 函数名: l2cap_sock_cleanup_listen\n- 参数: [struct sock *sk]\n- 调用者: l2cap_sock_teardown_cb\n- 被调用者: []\n\n5. 函数名: bt_accept_unlink\n- 参数: [struct sock *sk]\n- 调用者: l2cap_sock_teardown_cb\n- 被调用者: []\n\n6. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: l2cap_sock_teardown_cb\n- 被调用者: []\n\n7. 函数名: sock_set_flag\n- 参数: [struct sock *sk, enum sock_flags flag]\n- 调用者: l2cap_sock_teardown_cb\n- 被调用者: []"
  },
  {
    "id": 3093,
    "cwe": "CWE-362",
    "cve": "CVE-2021-39648",
    "purpose": "Code purpose:\"\"\"该代码片段用于显示USB gadget驱动程序中UDC（USB Device Controller）的名称，可能因竞态条件导致内核堆内存信息泄露。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于存在竞态条件，在读取udc_name时可能导致内核堆内存信息泄露\"\"\"",
    "functions": "Functions:\n1. 函数名: gadget_dev_desc_UDC_show\n- 参数: [struct config_item *item, char *page]\n- 调用者: 未明确（由configfs子系统调用）\n- 被调用者: [to_gadget_info, sprintf]\n\n2. 函数名: to_gadget_info\n- 参数: [struct config_item *item]\n- 调用者: gadget_dev_desc_UDC_show\n- 被调用者: []\n\n3. 函数名: sprintf\n- 参数: [char *page, const char *format, char *udc_name]\n- 调用者: gadget_dev_desc_UDC_show\n- 被调用者: []"
  },
  {
    "id": 3099,
    "cwe": "CWE-362",
    "cve": "CVE-2021-39686",
    "purpose": "Code purpose:\"\"\"释放binder进程资源并处理相关设备引用计数\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于竞态条件导致在多个binder.c函数中可能向SELinux传递错误的域，造成本地权限提升漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: binder_free_proc\n- 参数: [struct binder_proc *proc]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [container_of, refcount_dec_and_test, kfree, binder_alloc_deferred_release, put_task_struct, binder_stats_deleted]\n\n2. 函数名: container_of\n- 参数: [proc->context, struct binder_device, context]\n- 调用者: binder_free_proc\n- 被调用者: 未明确（通常是宏或内联函数）\n\n3. 函数名: refcount_dec_and_test\n- 参数: [&device->ref]\n- 调用者: binder_free_proc\n- 被调用者: 未明确（通常是原子操作函数）\n\n4. 函数名: kfree\n- 参数: [proc->context->name], [device]\n- 调用者: binder_free_proc\n- 被调用者: 未明确（内核内存释放函数）\n\n5. 函数名: binder_alloc_deferred_release\n- 参数: [&proc->alloc]\n- 调用者: binder_free_proc\n- 被调用者: 未明确（上下文未提供）\n\n6. 函数名: put_task_struct\n- 参数: [proc->tsk]\n- 调用者: binder_free_proc\n- 被调用者: 未明确（内核任务结构释放函数）\n\n7. 函数名: binder_stats_deleted\n- 参数: [BINDER_STAT_PROC]\n- 调用者: binder_free_proc\n- 被调用者: 未明确（上下文未提供）"
  },
  {
    "id": 3100,
    "cwe": "CWE-362",
    "cve": "CVE-2021-39686",
    "purpose": "Code purpose:\"\"\"处理Android Binder进程间通信(IPC)中的事务传输，包括事务的创建、处理、错误检查和安全上下文管理等核心功能\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于竞态条件导致在多个binder.c函数中可能向SELinux表示错误的域，从而引发本地权限提升漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: binder_transaction\n- 参数: [struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply, binder_size_t extra_buffers_size]\n- 调用者: N/A (top-level function)\n- 被调用者: [binder_transaction_log_add, atomic_inc_return, strscpy, binder_inner_proc_lock, binder_inner_proc_unlock, binder_user_error, binder_set_nice, binder_get_txn_from_and_acq_inner, binder_proc_lock, binder_get_ref_olocked, binder_get_node_refs_for_txn, binder_proc_unlock, mutex_lock, mutex_unlock, security_binder_transaction, list_first_entry_or_null, spin_lock, spin_unlock, atomic_inc, kzalloc, binder_stats_created, spin_lock_init, binder_debug, task_euid, task_nice, security_task_getsecid_obj, security_secid_to_secctx, ALIGN, security_release_secctx, trace_binder_transaction, binder_alloc_new_buf, IS_ERR, PTR_ERR, binder_alloc_copy_to_buffer, binder_alloc_copy_user_to_buffer, IS_ALIGNED, binder_get_object, binder_translate_binder, binder_translate_handle, binder_translate_fd, binder_validate_ptr, binder_validate_fixup, binder_translate_fd_array, binder_fixup_parent, binder_enqueue_thread_work, binder_pop_transaction_ilocked, binder_enqueue_thread_work_ilocked, wake_up_interruptible_sync, binder_free_transaction, binder_enqueue_deferred_thread_work_ilocked, binder_proc_transaction, binder_pop_transaction_ilocked, binder_thread_dec_tmpref, binder_proc_dec_tmpref, binder_dec_node_tmpref, smp_wmb, WRITE_ONCE, binder_dequeue_work, binder_free_txn_fixups, trace_binder_transaction_failed_buffer_release, binder_transaction_buffer_release, binder_alloc_free_buf, kfree, binder_stats_deleted, binder_txn_latency_free, binder_dec_node, binder_send_failed_reply]\n\n2. 函数名: binder_transaction_log_add\n- 参数: [struct binder_transaction_log *log]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n3. 函数名: atomic_inc_return\n- 参数: [atomic_t *v]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n4. 函数名: strscpy\n- 参数: [char *dest, const char *src, size_t count]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n5. 函数名: binder_inner_proc_lock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n6. 函数名: binder_inner_proc_unlock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n7. 函数名: binder_user_error\n- 参数: [const char *fmt, ...]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n8. 函数名: binder_set_nice\n- 参数: [long nice]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n9. 函数名: binder_get_txn_from_and_acq_inner\n- 参数: [struct binder_transaction *t]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n10. 函数名: binder_proc_lock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n11. 函数名: binder_get_ref_olocked\n- 参数: [struct binder_proc *proc, uint32_t desc, bool strong]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n12. 函数名: binder_get_node_refs_for_txn\n- 参数: [struct binder_node *node, struct binder_proc **procp, uint32_t *error]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n13. 函数名: binder_proc_unlock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n14. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n15. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n16. 函数名: security_binder_transaction\n- 参数: [struct task_struct *from, struct task_struct *to]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n17. 函数名: list_first_entry_or_null\n- 参数: [struct list_head *head, size_t offset, typeof(*ptr)]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n18. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n19. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n20. 函数名: atomic_inc\n- 参数: [atomic_t *v]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n21. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n22. 函数名: binder_stats_created\n- 参数: [enum binder_stat_types type]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n23. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n24. 函数名: binder_debug\n- 参数: [unsigned int mask, const char *format, ...]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n25. 函数名: task_euid\n- 参数: [struct task_struct *task]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n26. 函数名: task_nice\n- 参数: [struct task_struct *task]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n27. 函数名: security_task_getsecid_obj\n- 参数: [struct task_struct *task, u32 *secid]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n28. 函数名: security_secid_to_secctx\n- 参数: [u32 secid, char **secdata, u32 *seclen]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n29. 函数名: security_release_secctx\n- 参数: [char *secdata, u32 seclen]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n30. 函数名: trace_binder_transaction\n- 参数: [int reply, struct binder_transaction *t, struct binder_node *target_node]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n31. 函数名: binder_alloc_new_buf\n- 参数: [struct binder_alloc *alloc, size_t data_size, size_t offsets_size, size_t extra_buffers_size, int is_async, pid_t pid]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n32. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n33. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n34. 函数名: binder_alloc_copy_to_buffer\n- 参数: [struct binder_alloc *alloc, struct binder_buffer *buffer, binder_size_t buffer_offset, const void *src, size_t bytes]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n35. 函数名: binder_alloc_copy_user_to_buffer\n- 参数: [struct binder_alloc *alloc, struct binder_buffer *buffer, binder_size_t buffer_offset, const void __user *from, size_t bytes]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n36. 函数名: binder_get_object\n- 参数: [struct binder_proc *proc, struct binder_buffer *buffer, binder_size_t offset, struct binder_object *object]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n37. 函数名: binder_translate_binder\n- 参数: [struct flat_binder_object *fp, struct binder_transaction *t, struct binder_thread *thread]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n38. 函数名: binder_translate_handle\n- 参数: [struct flat_binder_object *fp, struct binder_transaction *t, struct binder_thread *thread]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n39. 函数名: binder_translate_fd\n- 参数: [int fd, binder_size_t fd_offset, struct binder_transaction *t, struct binder_thread *thread, struct binder_transaction *in_reply_to]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n40. 函数名: binder_validate_ptr\n- 参数: [struct binder_proc *proc, struct binder_buffer *buffer, struct binder_object *object, binder_size_t ptr, binder_size_t off_start_offset, binder_size_t *offp, size_t num_valid]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n41. 函数名: binder_validate_fixup\n- 参数: [struct binder_proc *proc, struct binder_buffer *buffer, binder_size_t off_start_offset, binder_size_t object_offset, binder_size_t fixup_offset, binder_size_t last_obj_offset, binder_size_t last_min_offset]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n42. 函数名: binder_translate_fd_array\n- 参数: [struct binder_fd_array_object *fda, struct binder_buffer_object *parent, struct binder_transaction *t, struct binder_thread *thread, struct binder_transaction *in_reply_to]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n43. 函数名: binder_fixup_parent\n- 参数: [struct binder_transaction *t, struct binder_thread *thread, struct binder_buffer_object *bp, binder_size_t off_start_offset, size_t num_valid, binder_size_t last_fixup_obj_off, binder_size_t last_fixup_min_off]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n44. 函数名: binder_enqueue_thread_work\n- 参数: [struct binder_thread *thread, struct binder_work *work]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n45. 函数名: binder_pop_transaction_ilocked\n- 参数: [struct binder_thread *thread, struct binder_transaction *t]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n46. 函数名: binder_enqueue_thread_work_ilocked\n- 参数: [struct binder_thread *thread, struct binder_work *work]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n47. 函数名: wake_up_interruptible_sync\n- 参数: [wait_queue_head_t *q]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n48. 函数名: binder_free_transaction\n- 参数: [struct binder_transaction *t]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n49. 函数名: binder_enqueue_deferred_thread_work_ilocked\n- 参数: [struct binder_thread *thread, struct binder_work *work]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n50. 函数名: binder_proc_transaction\n- 参数: [struct binder_transaction *t, struct binder_proc *target_proc, struct binder_thread *target_thread]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n51. 函数名: binder_thread_dec_tmpref\n- 参数: [struct binder_thread *thread]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n52. 函数名: binder_proc_dec_tmpref\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n53. 函数名: binder_dec_node_tmpref\n- 参数: [struct binder_node *node]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n54. 函数名: binder_dequeue_work\n- 参数: [struct binder_proc *proc, struct binder_work *work]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n55. 函数名: binder_free_txn_fixups\n- 参数: [struct binder_transaction *t]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n56. 函数名: binder_transaction_buffer_release\n- 参数: [struct binder_proc *proc, struct binder_buffer *buffer, binder_size_t off_end_offset, bool is_failure]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n57. 函数名: binder_alloc_free_buf\n- 参数: [struct binder_alloc *alloc, struct binder_buffer *buffer]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n58. 函数名: binder_dec_node\n- 参数: [struct binder_node *node, int strong, int internal]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n59. 函数名: binder_send_failed_reply\n- 参数: [struct binder_transaction *t, uint32_t error_code]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n60. 函数名: binder_txn_latency_free\n- 参数: [struct binder_transaction *t]\n- 调用者: binder_transaction\n- 被调用者: N/A"
  },
  {
    "id": 3101,
    "cwe": "CWE-362",
    "cve": "CVE-2021-39686",
    "purpose": "Code purpose:\"\"\"该代码实现了Android Binder驱动中的open操作，用于创建并初始化一个新的Binder进程上下文，并将其添加到全局进程列表中，同时处理相关的debugfs和binderfs文件系统条目创建。\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于竞态条件导致在多个binder.c函数中可能向SELinux表示错误的域\"\"\"",
    "functions": "Functions:\n1. 函数名: binder_open\n- 参数: [struct inode *nodp, struct file *filp]\n- 调用者: 未显示（通常由文件系统操作调用）\n- 被调用者: [kzalloc, spin_lock_init, get_task_struct, INIT_LIST_HEAD, init_waitqueue_head, task_nice, is_binderfs_device, container_of, refcount_inc, binder_alloc_init, binder_stats_created, mutex_lock, hlist_for_each_entry, hlist_add_head, mutex_unlock, snprintf, debugfs_create_file, binderfs_create_file, pr_warn]\n\n2. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: binder_open\n- 被调用者: []\n\n3. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: binder_open\n- 被调用者: []\n\n4. 函数名: get_task_struct\n- 参数: [struct task_struct *t]\n- 调用者: binder_open\n- 被调用者: []\n\n5. 函数名: INIT_LIST_HEAD\n- 参数: [struct list_head *list]\n- 调用者: binder_open\n- 被调用者: []\n\n6. 函数名: init_waitqueue_head\n- 参数: [wait_queue_head_t *q]\n- 调用者: binder_open\n- 被调用者: []\n\n7. 函数名: task_nice\n- 参数: [struct task_struct *p]\n- 调用者: binder_open\n- 被调用者: []\n\n8. 函数名: is_binderfs_device\n- 参数: [struct inode *nodp]\n- 调用者: binder_open\n- 被调用者: []\n\n9. 函数名: container_of\n- 参数: [void *ptr, type, member]\n- 调用者: binder_open\n- 被调用者: []\n\n10. 函数名: refcount_inc\n- 参数: [refcount_t *r]\n- 调用者: binder_open\n- 被调用者: []\n\n11. 函数名: binder_alloc_init\n- 参数: [struct binder_alloc *alloc]\n- 调用者: binder_open\n- 被调用者: []\n\n12. 函数名: binder_stats_created\n- 参数: [enum binder_stat_types type]\n- 调用者: binder_open\n- 被调用者: []\n\n13. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: binder_open\n- 被调用者: []\n\n14. 函数名: hlist_for_each_entry\n- 参数: [type *pos, struct hlist_head *head, member]\n- 调用者: binder_open\n- 被调用者: []\n\n15. 函数名: hlist_add_head\n- 参数: [struct hlist_node *n, struct hlist_head *h]\n- 调用者: binder_open\n- 被调用者: []\n\n16. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: binder_open\n- 被调用者: []\n\n17. 函数名: snprintf\n- 参数: [char *str, size_t size, const char *format, ...]\n- 调用者: binder_open\n- 被调用者: []\n\n18. 函数名: debugfs_create_file\n- 参数: [const char *name, umode_t mode, struct dentry *parent, void *data, const struct file_operations *fops]\n- 调用者: binder_open\n- 被调用者: []\n\n19. 函数名: binderfs_create_file\n- 参数: [struct dentry *dir, const char *name, const struct file_operations *fops, void *data]\n- 调用者: binder_open\n- 被调用者: []\n\n20. 函数名: pr_warn\n- 参数: [const char *fmt, ...]\n- 调用者: binder_open\n- 被调用者: []"
  },
  {
    "id": 3103,
    "cwe": "CWE-362",
    "cve": "CVE-2021-39713",
    "purpose": "Code purpose:\"\"\"该代码用于处理网络流量控制中的过滤器获取请求，包括验证参数、查找指定过滤器链和过滤器，并返回结果或错误信息。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在并发环境下未正确管理tcf_chain引用计数，导致竞争条件下可能释放仍在使用的资源\"\"\"",
    "functions": "Functions:\n1. 函数名: tc_get_tfilter\n- 参数: [struct sk_buff *skb, struct nlmsghdr *n, struct netlink_ext_ack *extack]\n- 调用者: 未显示\n- 被调用者: [nlmsg_parse, nlmsg_data, tcf_block_find, nla_get_u32, tcf_chain_get, tcf_chain_tp_find, nla_strcmp, tp->ops->get, tfilter_notify, tcf_chain_put]\n\n2. 函数名: nlmsg_parse\n- 参数: [struct nlmsghdr *n, int sizeof_t, struct nlattr *tca[], int TCA_MAX, NULL, struct netlink_ext_ack *extack]\n- 调用者: tc_get_tfilter\n- 被调用者: 未显示\n\n3. 函数名: nlmsg_data\n- 参数: [struct nlmsghdr *n]\n- 调用者: tc_get_tfilter\n- 被调用者: 未显示\n\n4. 函数名: tcf_block_find\n- 参数: [struct net *net, struct Qdisc **q, u32 *parent, unsigned long *cl, int tcm_ifindex, int tcm_block_index, struct netlink_ext_ack *extack]\n- 调用者: tc_get_tfilter\n- 被调用者: 未显示\n\n5. 函数名: nla_get_u32\n- 参数: [struct nlattr *tca[TCA_CHAIN]]\n- 调用者: tc_get_tfilter\n- 被调用者: 未显示\n\n6. 函数名: tcf_chain_get\n- 参数: [struct tcf_block *block, u32 chain_index, bool false]\n- 调用者: tc_get_tfilter\n- 被调用者: 未显示\n\n7. 函数名: tcf_chain_tp_find\n- 参数: [struct tcf_chain *chain, struct tcf_chain_info *chain_info, u32 protocol, u32 prio, bool false]\n- 调用者: tc_get_tfilter\n- 被调用者: 未显示\n\n8. 函数名: nla_strcmp\n- 参数: [struct nlattr *tca[TCA_KIND], char *tp->ops->kind]\n- 调用者: tc_get_tfilter\n- 被调用者: 未显示\n\n9. 函数名: tp->ops->get\n- 参数: [struct tcf_proto *tp, u32 t->tcm_handle]\n- 调用者: tc_get_tfilter\n- 被调用者: 未显示\n\n10. 函数名: tfilter_notify\n- 参数: [struct net *net, struct sk_buff *skb, struct nlmsghdr *n, struct tcf_proto *tp, struct tcf_block *block, struct Qdisc *q, u32 parent, void *fh, int RTM_NEWTFILTER, bool true]\n- 调用者: tc_get_tfilter\n- 被调用者: 未显示\n\n11. 函数名: tcf_chain_put\n- 参数: [struct tcf_chain *chain]\n- 调用者: tc_get_tfilter\n- 被调用者: 未显示"
  },
  {
    "id": 3104,
    "cwe": "CWE-362",
    "cve": "CVE-2021-39713",
    "purpose": "Code purpose:\"\"\"该代码用于在网络设备中查找和验证指定的流量控制块(tcf_block)，并根据不同的条件(如接口索引、父级Qdisc等)返回相应的块或错误信息。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于代码中缺少对并发访问共享资源(block)的适当保护，导致存在竞争条件漏洞(CWE-362)。\"\"\"",
    "functions": "Functions:\n1. 函数名: tcf_block_find\n- 参数: [net, q, parent, cl, ifindex, block_index, extack]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [tcf_block_lookup, __dev_get_by_index, qdisc_lookup, cops->find, cops->tcf_block, tcf_block_shared, NL_SET_ERR_MSG, ERR_PTR]\n\n2. 函数名: tcf_block_lookup\n- 参数: [net, block_index]\n- 调用者: tcf_block_find\n- 被调用者: 未明确\n\n3. 函数名: __dev_get_by_index\n- 参数: [net, ifindex]\n- 调用者: tcf_block_find\n- 被调用者: 未明确\n\n4. 函数名: qdisc_lookup\n- 参数: [dev, TC_H_MAJ(*parent)]\n- 调用者: tcf_block_find\n- 被调用者: 未明确\n\n5. 函数名: cops->find\n- 参数: [*q, *parent]\n- 调用者: tcf_block_find\n- 被调用者: 未明确\n\n6. 函数名: cops->tcf_block\n- 参数: [*q, *cl, extack]\n- 调用者: tcf_block_find\n- 被调用者: 未明确\n\n7. 函数名: tcf_block_shared\n- 参数: [block]\n- 调用者: tcf_block_find\n- 被调用者: 未明确\n\n8. 函数名: NL_SET_ERR_MSG\n- 参数: [extack, \"error message\"]\n- 调用者: tcf_block_find\n- 被调用者: 未明确\n\n9. 函数名: ERR_PTR\n- 参数: [error_code]\n- 调用者: tcf_block_find\n- 被调用者: 未明确"
  },
  {
    "id": 3105,
    "cwe": "CWE-362",
    "cve": "CVE-2021-39713",
    "purpose": "Code purpose:\"\"\"该代码实现了通过Netlink消息删除网络流量控制过滤器的功能，包括查找、验证和删除指定的过滤器链或单个过滤器。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在tc_del_tfilter函数中，当处理过滤器删除操作时，未能正确验证和处理并发情况下的资源访问，导致存在竞争条件漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: tc_del_tfilter\n- 参数: [struct sk_buff *skb, struct nlmsghdr *n, struct netlink_ext_ack *extack]\n- 调用者: (未显示)\n- 被调用者: [sock_net, netlink_ns_capable, nlmsg_parse, nlmsg_data, tcf_block_find, nla_get_u32, tcf_chain_get, tfilter_notify_chain, tcf_chain_flush, tcf_chain_tp_find, nla_strcmp, tp->ops->get, tcf_chain_tp_remove, tfilter_notify, tcf_proto_destroy, tfilter_del_notify, tcf_chain_put]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n3. 函数名: netlink_ns_capable\n- 参数: [struct sk_buff *skb, struct user_namespace *ns, int cap]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n4. 函数名: nlmsg_parse\n- 参数: [struct nlmsghdr *nlh, int hdrlen, struct nlattr *tb[], int maxtype, const struct nla_policy *policy, struct netlink_ext_ack *extack]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n5. 函数名: nlmsg_data\n- 参数: [struct nlmsghdr *nlh]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n6. 函数名: tcf_block_find\n- 参数: [struct net *net, struct Qdisc **q, u32 *parent, unsigned long *cl, int ifindex, u32 block_index, struct netlink_ext_ack *extack]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n7. 函数名: nla_get_u32\n- 参数: [const struct nlattr *nla]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n8. 函数名: tcf_chain_get\n- 参数: [struct tcf_block *block, u32 chain_index, bool create]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n9. 函数名: tfilter_notify_chain\n- 参数: [struct net *net, struct sk_buff *oskb, struct tcf_block *block, struct Qdisc *q, u32 parent, struct nlmsghdr *n, struct tcf_chain *chain, int event]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n10. 函数名: tcf_chain_flush\n- 参数: [struct tcf_chain *chain]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n11. 函数名: tcf_chain_tp_find\n- 参数: [struct tcf_chain *chain, struct tcf_chain_info *chain_info, u32 protocol, u32 prio, bool prio_allocate]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n12. 函数名: nla_strcmp\n- 参数: [const struct nlattr *nla, const char *str]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n13. 函数名: tp->ops->get\n- 参数: [struct tcf_proto *tp, u32 handle]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n14. 函数名: tcf_chain_tp_remove\n- 参数: [struct tcf_chain *chain, struct tcf_chain_info *chain_info, struct tcf_proto *tp]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n15. 函数名: tfilter_notify\n- 参数: [struct net *net, struct sk_buff *oskb, struct nlmsghdr *n, struct tcf_proto *tp, struct tcf_block *block, struct Qdisc *q, u32 parent, void *fh, int event, bool unicast]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n16. 函数名: tcf_proto_destroy\n- 参数: [struct tcf_proto *tp, struct netlink_ext_ack *extack]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n17. 函数名: tfilter_del_notify\n- 参数: [struct net *net, struct sk_buff *oskb, struct nlmsghdr *n, struct tcf_proto *tp, struct tcf_block *block, struct Qdisc *q, u32 parent, void *fh, bool unicast, bool *last, struct netlink_ext_ack *extack]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n18. 函数名: tcf_chain_put\n- 参数: [struct tcf_chain *chain]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)"
  },
  {
    "id": 3106,
    "cwe": "CWE-362",
    "cve": "CVE-2021-39713",
    "purpose": "Code purpose:\"\"\"处理网络流量控制中新过滤器的创建和修改请求\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于代码中存在竞争条件，当多个线程同时访问和修改共享资源时，可能导致资源管理不当或状态不一致\"\"\"",
    "functions": "Functions:\n1. 函数名: tc_new_tfilter\n- 参数: [struct sk_buff *skb, struct nlmsghdr *n, struct netlink_ext_ack *extack]\n- 调用者: 未显示\n- 被调用者: [sock_net, netlink_ns_capable, nlmsg_parse, nlmsg_data, tcf_block_find, nla_get_u32, tcf_chain_get, tcf_chain_tp_find, tcf_auto_prio, tcf_chain_tp_prev, tcf_proto_create, nla_strcmp, tp->ops->get, tp->ops->change, tcf_chain_tp_insert, tfilter_notify, tcf_proto_destroy, tcf_chain_put]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n3. 函数名: netlink_ns_capable\n- 参数: [struct sk_buff *skb, struct user_namespace *ns, int cap]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n4. 函数名: nlmsg_parse\n- 参数: [struct nlmsghdr *nlh, int hdrlen, struct nlattr *tb[], int maxtype, const struct nla_policy *policy, struct netlink_ext_ack *extack]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n5. 函数名: nlmsg_data\n- 参数: [struct nlmsghdr *nlh]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n6. 函数名: tcf_block_find\n- 参数: [struct net *net, struct Qdisc **q, u32 *parent, unsigned long *cl, int ifindex, u32 block_index, struct netlink_ext_ack *extack]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n7. 函数名: nla_get_u32\n- 参数: [const struct nlattr *nla]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n8. 函数名: tcf_chain_get\n- 参数: [struct tcf_block *block, u32 chain_index, bool create]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n9. 函数名: tcf_chain_tp_find\n- 参数: [struct tcf_chain *chain, struct tcf_chain_info *chain_info, u32 protocol, u32 prio, bool prio_allocate]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n10. 函数名: tcf_auto_prio\n- 参数: [struct tcf_proto *tp]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n11. 函数名: tcf_chain_tp_prev\n- 参数: [struct tcf_chain_info *chain_info]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n12. 函数名: tcf_proto_create\n- 参数: [const char *kind, u32 protocol, u32 prio, struct tcf_chain *chain, struct netlink_ext_ack *extack]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n13. 函数名: nla_strcmp\n- 参数: [const struct nlattr *nla, const char *str]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n14. 函数名: tp->ops->get\n- 参数: [struct tcf_proto *tp, u32 handle]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n15. 函数名: tp->ops->change\n- 参数: [struct net *net, struct sk_buff *skb, struct tcf_proto *tp, unsigned long base, u32 handle, struct nlattr **tca, void **fh, bool rtnl_held, struct netlink_ext_ack *extack]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n16. 函数名: tcf_chain_tp_insert\n- 参数: [struct tcf_chain *chain, struct tcf_chain_info *chain_info, struct tcf_proto *tp]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n17. 函数名: tfilter_notify\n- 参数: [struct net *net, struct sk_buff *oskb, struct nlmsghdr *n, struct tcf_proto *tp, struct tcf_block *block, struct Qdisc *q, u32 parent, void *fh, int event, bool rtnl_held]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n18. 函数名: tcf_proto_destroy\n- 参数: [struct tcf_proto *tp, bool rtnl_held]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n19. 函数名: tcf_chain_put\n- 参数: [struct tcf_chain *chain]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示"
  },
  {
    "id": 3107,
    "cwe": "CWE-362",
    "cve": "CVE-2021-39713",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中流量控制链的管理功能，包括创建、删除和查询链，并处理相关的网络控制消息。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于在处理TC(流量控制)链时，未能正确管理链的引用计数，导致存在竞争条件可能引发释放后使用(UAF)问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: tc_ctl_chain\n- 参数: [skb, n, extack]\n- 调用者: 无（顶级函数）\n- 被调用者: [sock_net, nlmsg_parse, nlmsg_data, tcf_block_find, nla_get_u32, tcf_chain_lookup, tcf_chain_held_by_acts_only, tcf_chain_hold, tcf_chain_create, tc_chain_tmplt_add, tc_chain_notify, tfilter_notify_chain, tcf_chain_flush, tcf_chain_put_explicitly_created, tcf_chain_put]\n\n2. 函数名: sock_net\n- 参数: [sk]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n3. 函数名: nlmsg_parse\n- 参数: [n, sizeof(*t), tca, TCA_MAX, NULL, extack]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n4. 函数名: nlmsg_data\n- 参数: [n]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n5. 函数名: tcf_block_find\n- 参数: [net, &q, &parent, &cl, t->tcm_ifindex, t->tcm_block_index, extack]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n6. 函数名: nla_get_u32\n- 参数: [tca[TCA_CHAIN]]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n7. 函数名: tcf_chain_lookup\n- 参数: [block, chain_index]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n8. 函数名: tcf_chain_held_by_acts_only\n- 参数: [chain]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n9. 函数名: tcf_chain_hold\n- 参数: [chain]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n10. 函数名: tcf_chain_create\n- 参数: [block, chain_index]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n11. 函数名: tc_chain_tmplt_add\n- 参数: [chain, net, tca, extack]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n12. 函数名: tc_chain_notify\n- 参数: [chain, NULL, 0, NLM_F_CREATE | NLM_F_EXCL, RTM_NEWCHAIN, false]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n13. 函数名: tfilter_notify_chain\n- 参数: [net, skb, block, q, parent, n, chain, RTM_DELTFILTER]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n14. 函数名: tcf_chain_flush\n- 参数: [chain]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n15. 函数名: tcf_chain_put_explicitly_created\n- 参数: [chain]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n16. 函数名: tcf_chain_put\n- 参数: [chain]\n- 调用者: tc_ctl_chain\n- 被调用者: 无"
  },
  {
    "id": 3127,
    "cwe": "CWE-362",
    "cve": "CVE-2021-40490",
    "purpose": "Code purpose:\"\"\"该代码用于处理ext4文件系统中内联数据的写入操作，包括获取inode位置、写入数据、更新页面状态等，并确保数据一致性。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4_write_inline_data_end函数中存在竞态条件，当处理内联数据写入时未充分保护共享资源，导致并发访问时可能出现数据不一致问题\"\"\"",
    "functions": "Functions:\n1. 函数名: ext4_write_inline_data_end\n- 参数: [inode, pos, len, copied, page]\n- 调用者: N/A (top-level function)\n- 被调用者: [PageUptodate, ext4_get_inode_loc, ext4_std_error, ext4_write_lock_xattr, ext4_has_inline_data, kmap_atomic, ext4_write_inline_data, kunmap_atomic, SetPageUptodate, ClearPageDirty, ext4_write_unlock_xattr, brelse, mark_inode_dirty]\n\n2. 函数名: PageUptodate\n- 参数: [page]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n3. 函数名: ext4_get_inode_loc\n- 参数: [inode, iloc]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n4. 函数名: ext4_std_error\n- 参数: [sb, ret]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n5. 函数名: ext4_write_lock_xattr\n- 参数: [inode, no_expand]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n6. 函数名: ext4_has_inline_data\n- 参数: [inode]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n7. 函数名: kmap_atomic\n- 参数: [page]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n8. 函数名: ext4_write_inline_data\n- 参数: [inode, iloc, kaddr, pos, len]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n9. 函数名: kunmap_atomic\n- 参数: [kaddr]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n10. 函数名: SetPageUptodate\n- 参数: [page]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n11. 函数名: ClearPageDirty\n- 参数: [page]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n12. 函数名: ext4_write_unlock_xattr\n- 参数: [inode, no_expand]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n13. 函数名: brelse\n- 参数: [iloc.bh]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n14. 函数名: mark_inode_dirty\n- 参数: [inode]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []"
  },
  {
    "id": 3128,
    "cwe": "CWE-362",
    "cve": "CVE-2021-4083",
    "purpose": "Code purpose:\"\"\"在RCU保护下通过文件描述符查找并获取文件结构体引用\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核的Unix域套接字文件处理器的垃圾回收机制中，当用户同时调用close()和fget()时可能触发竞态条件，导致读取已释放的内存。\"\"\"",
    "functions": "Functions:\n1. 函数名: __fget_files\n- 参数: [struct files_struct *files, unsigned int fd, fmode_t mask, unsigned int refs]\n- 调用者: 未明确（通常由文件描述符相关操作调用）\n- 被调用者: [files_lookup_fd_rcu, get_file_rcu_many]\n\n2. 函数名: files_lookup_fd_rcu\n- 参数: [struct files_struct *files, unsigned int fd]\n- 调用者: __fget_files\n- 被调用者: []\n\n3. 函数名: get_file_rcu_many\n- 参数: [struct file *file, unsigned int refs]\n- 调用者: __fget_files\n- 被调用者: []"
  },
  {
    "id": 3145,
    "cwe": "CWE-362",
    "cve": "CVE-2021-4202",
    "purpose": "Code purpose:\"\"\"该代码用于管理NFC控制器接口(NCI)的请求，确保在设备可用时串行化处理请求并设置超时机制\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在设备被移除时，nci_request函数未能正确处理数据竞争条件，导致释放后使用漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: nci_request\n- 参数: [struct nci_dev *ndev, void (*req)(struct nci_dev *ndev, const void *opt), const void *opt, __u32 timeout]\n- 调用者: 未明确（外部调用）\n- 被调用者: [test_bit, mutex_lock, __nci_request, mutex_unlock]\n\n2. 函数名: req\n- 参数: [struct nci_dev *ndev, const void *opt]\n- 调用者: __nci_request\n- 被调用者: 未明确（回调函数）\n\n3. 函数名: test_bit\n- 参数: [NCI_UP, &ndev->flags]\n- 调用者: nci_request\n- 被调用者: 未明确（外部函数）\n\n4. 函数名: mutex_lock\n- 参数: [&ndev->req_lock]\n- 调用者: nci_request\n- 被调用者: 未明确（外部函数）\n\n5. 函数名: __nci_request\n- 参数: [struct nci_dev *ndev, void (*req)(struct nci_dev *ndev, const void *opt), const void *opt, __u32 timeout]\n- 调用者: nci_request\n- 被调用者: [req]\n\n6. 函数名: mutex_unlock\n- 参数: [&ndev->req_lock]\n- 调用者: nci_request\n- 被调用者: 未明确（外部函数）"
  },
  {
    "id": 3146,
    "cwe": "CWE-362",
    "cve": "CVE-2021-4203",
    "purpose": "Code purpose:\"\"\"该代码实现了获取套接字选项值的功能，处理不同类型的套接字选项请求并返回相应的值给用户空间。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于SO_PEERCRED和SO_PEERGROUPS选项在处理时与listen()和connect()操作存在竞争条件，导致在获取对端凭证信息时可能发生use-after-free读取漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: sock_getsockopt\n- 参数: [struct socket *sock, int level, int optname, char __user *optval, int __user *optlen]\n- 调用者: 未明确（系统调用或其他内核函数）\n- 被调用者: [get_user, memset, sock_flag, xchg, sock_get_timeout, copy_to_user, cred_to_ucred, put_user, groups_to_user, security_socket_getpeersec_stream, sock_getbindtodevice, sk_get_filter, bpf_tell_extensions, sk_get_meminfo, sock_gen_cookie, sock_net]\n\n2. 函数名: get_user\n- 参数: [len, optlen]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n3. 函数名: memset\n- 参数: [&v, 0, sizeof(v)]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n4. 函数名: sock_flag\n- 参数: [sk, SOCK_DBG/SOCK_LOCALROUTE/SOCK_BROADCAST/SOCK_KEEPOPEN/SOCK_URGINLINE/SOCK_LINGER/SOCK_RCVTSTAMP/SOCK_TSTAMP_NEW/SOCK_RCVTSTAMPNS/SOCK_RXQ_OVFL/SOCK_WIFI_STATUS/SOCK_NOFCS/SOCK_FILTER_LOCKED/SOCK_SELECT_ERR_QUEUE/SOCK_ZEROCOPY]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n5. 函数名: xchg\n- 参数: [&sk->sk_err_soft, 0]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n6. 函数名: sock_get_timeout\n- 参数: [sk->sk_rcvtimeo/sk->sk_sndtimeo, &v, SO_RCVTIMEO_OLD/SO_SNDTIMEO_OLD == optname]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n7. 函数名: copy_to_user\n- 参数: [optval, &peercred/address/meminfo/&v, len]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n8. 函数名: cred_to_ucred\n- 参数: [sk->sk_peer_pid, sk->sk_peer_cred, &peercred]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n9. 函数名: put_user\n- 参数: [len, optlen]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n10. 函数名: groups_to_user\n- 参数: [(gid_t __user *)optval, sk->sk_peer_cred->group_info]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n11. 函数名: security_socket_getpeersec_stream\n- 参数: [sock, optval, optlen, len]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n12. 函数名: sock_getbindtodevice\n- 参数: [sk, optval, optlen, len]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n13. 函数名: sk_get_filter\n- 参数: [sk, (struct sock_filter __user *)optval, len]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n14. 函数名: bpf_tell_extensions\n- 参数: []\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n15. 函数名: sk_get_meminfo\n- 参数: [sk, meminfo]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n16. 函数名: sock_gen_cookie\n- 参数: [sk]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n17. 函数名: sock_net\n- 参数: [sk]\n- 调用者: sock_getsockopt\n- 被调用者: []"
  },
  {
    "id": 3147,
    "cwe": "CWE-362",
    "cve": "CVE-2021-4203",
    "purpose": "Code purpose:\"\"\"该代码实现了套接字销毁时的资源清理功能，包括释放过滤器、时间戳、BPF存储、内存分配、页面碎片、对等凭证等资源，并处理潜在的竞态条件问题。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于SO_PEERCRED和SO_PEERGROUPS在listen()和connect()操作中存在竞态条件，导致在sock_getsockopt()中可能发生释放后使用(UAF)的问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: __sk_destruct\n- 参数: [head]\n- 调用者: 未明确显示（通常由RCU机制调用）\n- 被调用者: [container_of, sk->sk_destruct, rcu_dereference_check, refcount_read, sk_filter_uncharge, RCU_INIT_POINTER, sock_disable_timestamp, bpf_sk_storage_free, atomic_read, pr_debug, put_page, put_cred, put_pid, put_net, sk_prot_free, sock_net]\n\n2. 函数名: container_of\n- 参数: [head, struct sock, sk_rcu]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n3. 函数名: sk->sk_destruct\n- 参数: [sk]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n4. 函数名: rcu_dereference_check\n- 参数: [sk->sk_filter, refcount_read(&sk->sk_wmem_alloc) == 0]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n5. 函数名: refcount_read\n- 参数: [&sk->sk_wmem_alloc]\n- 调用者: __sk_destruct (通过rcu_dereference_check)\n- 被调用者: []\n\n6. 函数名: sk_filter_uncharge\n- 参数: [sk, filter]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n7. 函数名: RCU_INIT_POINTER\n- 参数: [sk->sk_filter, NULL]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n8. 函数名: sock_disable_timestamp\n- 参数: [sk, SK_FLAGS_TIMESTAMP]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n9. 函数名: bpf_sk_storage_free\n- 参数: [sk]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n10. 函数名: atomic_read\n- 参数: [&sk->sk_omem_alloc]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n11. 函数名: pr_debug\n- 参数: [\"%s: optmem leakage (%d bytes) detected\\n\", __func__, atomic_read(&sk->sk_omem_alloc)]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n12. 函数名: put_page\n- 参数: [sk->sk_frag.page]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n13. 函数名: put_cred\n- 参数: [sk->sk_peer_cred]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n14. 函数名: put_pid\n- 参数: [sk->sk_peer_pid]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n15. 函数名: put_net\n- 参数: [sock_net(sk)]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n16. 函数名: sock_net\n- 参数: [sk]\n- 调用者: __sk_destruct (通过put_net)\n- 被调用者: []\n\n17. 函数名: sk_prot_free\n- 参数: [sk->sk_prot_creator, sk]\n- 调用者: __sk_destruct\n- 被调用者: []"
  },
  {
    "id": 3148,
    "cwe": "CWE-362",
    "cve": "CVE-2021-4203",
    "purpose": "Code purpose:\"\"\"初始化socket数据结构并设置相关参数和回调函数\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于SO_PEERCRED和SO_PEERGROUPS选项在sock_getsockopt()中与listen()和connect()存在竞态条件，导致内核信息泄露或系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: sock_init_data\n- 参数: [struct socket *sock, struct sock *sk]\n- 调用者: 未显示\n- 被调用者: [sk_init_common, timer_setup, sk_set_socket, sock_set_flag, RCU_INIT_POINTER, SOCK_INODE, make_kuid, sock_net, rwlock_init, lockdep_set_class_and_name, refcount_set, atomic_set, sk_rx_queue_clear, WRITE_ONCE, smp_wmb]\n\n2. 函数名: sk_init_common\n- 参数: [struct sock *sk]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n3. 函数名: timer_setup\n- 参数: [&sk->sk_timer, NULL, 0]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n4. 函数名: sk_set_socket\n- 参数: [struct sock *sk, struct socket *sock]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n5. 函数名: sock_set_flag\n- 参数: [struct sock *sk, SOCK_ZAPPED]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n6. 函数名: RCU_INIT_POINTER\n- 参数: [sk->sk_wq, &sock->wq], [sk->sk_wq, NULL]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n7. 函数名: SOCK_INODE\n- 参数: [sock]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n8. 函数名: make_kuid\n- 参数: [sock_net(sk)->user_ns, 0]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n9. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n10. 函数名: rwlock_init\n- 参数: [&sk->sk_callback_lock]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n11. 函数名: lockdep_set_class_and_name\n- 参数: [&sk->sk_callback_lock, af_kern_callback_keys + sk->sk_family, af_family_kern_clock_key_strings[sk->sk_family]], [&sk->sk_callback_lock, af_callback_keys + sk->sk_family, af_family_clock_key_strings[sk->sk_family]]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n12. 函数名: refcount_set\n- 参数: [&sk->sk_refcnt, 1]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n13. 函数名: atomic_set\n- 参数: [&sk->sk_drops, 0]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n14. 函数名: sk_rx_queue_clear\n- 参数: [struct sock *sk]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n15. 函数名: WRITE_ONCE\n- 参数: [sk->sk_pacing_shift, 10]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n16. 函数名: smp_wmb\n- 参数: []\n- 调用者: sock_init_data\n- 被调用者: 未显示"
  },
  {
    "id": 3149,
    "cwe": "CWE-362",
    "cve": "CVE-2021-4203",
    "purpose": "Code purpose:\"\"\"复制对端套接字的进程凭证信息\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在SO_PEERCRED和SO_PEERGROUPS操作与listen()/connect()之间存在竞争条件，导致对sk_peer_pid和sk_peer_cred的引用计数管理不当，可能引发释放后使用问题\"\"\"",
    "functions": "Functions:\n1. 函数名: copy_peercred\n- 参数: [sk, peersk]\n- 调用者: 未指定\n- 被调用者: [put_pid, put_cred, get_pid, get_cred]\n\n2. 函数名: put_pid\n- 参数: [sk->sk_peer_pid]\n- 调用者: copy_peercred\n- 被调用者: 未指定\n\n3. 函数名: put_cred\n- 参数: [sk->sk_peer_cred]\n- 调用者: copy_peercred\n- 被调用者: 未指定\n\n4. 函数名: get_pid\n- 参数: [peersk->sk_peer_pid]\n- 调用者: copy_peercred\n- 被调用者: 未指定\n\n5. 函数名: get_cred\n- 参数: [peersk->sk_peer_cred]\n- 调用者: copy_peercred\n- 被调用者: 未指定"
  },
  {
    "id": 3150,
    "cwe": "CWE-362",
    "cve": "CVE-2021-4203",
    "purpose": "Code purpose:\"\"\"初始化套接字的对等进程凭证信息，包括进程ID和凭证\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于SO_PEERCRED和SO_PEERGROUPS选项在sock_getsockopt()中与listen()/connect()存在竞态条件，导致对已释放的sk_peer_cred和sk_peer_pid进行读取，引发use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: init_peercred\n- 参数: [struct sock *sk]\n- 调用者: 不适用（从代码片段无法确定）\n- 被调用者: [put_pid, put_cred, get_pid, task_tgid, get_current_cred]\n\n2. 函数名: put_pid\n- 参数: [struct pid *]\n- 调用者: init_peercred\n- 被调用者: 不适用（从代码片段无法确定）\n\n3. 函数名: put_cred\n- 参数: [const struct cred *]\n- 调用者: init_peercred\n- 被调用者: 不适用（从代码片段无法确定）\n\n4. 函数名: get_pid\n- 参数: [struct pid *]\n- 调用者: init_peercred\n- 被调用者: 不适用（从代码片段无法确定）\n\n5. 函数名: task_tgid\n- 参数: [struct task_struct *]\n- 调用者: init_peercred\n- 被调用者: 不适用（从代码片段无法确定）\n\n6. 函数名: get_current_cred\n- 参数: []\n- 调用者: init_peercred\n- 被调用者: 不适用（从代码片段无法确定）"
  },
  {
    "id": 3167,
    "cwe": "CWE-362",
    "cve": "CVE-2021-44733",
    "purpose": "Code purpose:\"\"\"释放共享内存对象，根据标志位选择通过dma_buf_put减少引用计数或直接调用tee_shm_release释放内存\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于tee_shm_get_from_id函数中存在竞态条件，导致在释放共享内存对象时可能发生释放后使用(UAF)问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: tee_shm_free\n- 参数: [struct tee_shm *shm]\n- 调用者: 未明确（可能是外部调用）\n- 被调用者: [dma_buf_put, tee_shm_release]\n\n2. 函数名: dma_buf_put\n- 参数: [shm->dmabuf]\n- 调用者: tee_shm_free\n- 被调用者: 未明确（可能是内核函数）\n\n3. 函数名: tee_shm_release\n- 参数: [shm]\n- 调用者: tee_shm_free\n- 被调用者: 未明确（可能是内部函数）"
  },
  {
    "id": 3168,
    "cwe": "CWE-362",
    "cve": "CVE-2021-44733",
    "purpose": "Code purpose:\"\"\"通过ID从TEE上下文中获取共享内存对象并处理相关引用计数\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在tee_shm_get_from_id函数中存在竞态条件，当尝试释放共享内存对象时可能导致使用后释放漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: tee_shm_get_from_id\n- 参数: [struct tee_context *ctx, int id]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [ERR_PTR, idr_find, mutex_lock, mutex_unlock, get_dma_buf]\n\n2. 函数名: ERR_PTR\n- 参数: [long error]\n- 调用者: tee_shm_get_from_id\n- 被调用者: 未明确\n\n3. 函数名: idr_find\n- 参数: [struct idr *idr, int id]\n- 调用者: tee_shm_get_from_id\n- 被调用者: 未明确\n\n4. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: tee_shm_get_from_id\n- 被调用者: 未明确\n\n5. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: tee_shm_get_from_id\n- 被调用者: 未明确\n\n6. 函数名: get_dma_buf\n- 参数: [struct dma_buf *dmabuf]\n- 调用者: tee_shm_get_from_id\n- 被调用者: 未明确"
  },
  {
    "id": 3169,
    "cwe": "CWE-362",
    "cve": "CVE-2021-44733",
    "purpose": "Code purpose:\"\"\"该代码实现了在TEE子系统中注册共享内存对象的功能，包括内存页的固定、ID分配和DMA缓冲区导出等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于tee_shm_get_from_id函数中存在竞态条件，导致在释放共享内存对象时可能发生释放后使用(UAF)问题\"\"\"",
    "functions": "Functions:\n1. 函数名: tee_shm_register\n- 参数: [struct tee_context *ctx, unsigned long addr, size_t length, u32 flags]\n- 调用者: 未指定\n- 被调用者: [tee_device_get, tee_device_put, teedev_ctx_get, kzalloc, untagged_addr, rounddown, roundup, kcalloc, pin_user_pages_fast, get_kernel_pages, kfree, mutex_lock, idr_alloc, mutex_unlock, ERR_PTR, ERR_CAST, release_registered_pages, teedev_ctx_put]\n\n2. 函数名: tee_device_get\n- 参数: [struct tee_device *teedev]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n3. 函数名: tee_device_put\n- 参数: [struct tee_device *teedev]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n4. 函数名: teedev_ctx_get\n- 参数: [struct tee_context *ctx]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n5. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n6. 函数名: untagged_addr\n- 参数: [unsigned long addr]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n7. 函数名: rounddown\n- 参数: [unsigned long addr, unsigned long size]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n8. 函数名: roundup\n- 参数: [unsigned long addr, unsigned long size]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n9. 函数名: kcalloc\n- 参数: [size_t n, size_t size, gfp_t flags]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n10. 函数名: pin_user_pages_fast\n- 参数: [unsigned long start, int nr_pages, unsigned int gup_flags, struct page **pages]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n11. 函数名: get_kernel_pages\n- 参数: [struct kvec *kiov, int nr_pages, int write, struct page **pages]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n12. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n13. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n14. 函数名: idr_alloc\n- 参数: [struct idr *idr, void *ptr, int start, int end, gfp_t gfp_mask]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n15. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n16. 函数名: ERR_PTR\n- 参数: [long error]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n17. 函数名: ERR_CAST\n- 参数: [void *ptr]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n18. 函数名: release_registered_pages\n- 参数: [struct tee_shm *shm]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n19. 函数名: teedev_ctx_put\n- 参数: [struct tee_context *ctx]\n- 调用者: tee_shm_register\n- 被调用者: 未指定"
  },
  {
    "id": 3170,
    "cwe": "CWE-362",
    "cve": "CVE-2021-44733",
    "purpose": "Code purpose:\"\"\"释放共享内存对象时处理DMA缓冲区的引用计数\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于tee_shm_get_from_id函数中存在竞态条件，导致在释放共享内存对象时可能发生释放后使用的问题\"\"\"",
    "functions": "Functions:\n1. 函数名: tee_shm_put\n- 参数: [struct tee_shm *shm]\n- 调用者: 未提供（上下文缺失）\n- 被调用者: [dma_buf_put]\n\n2. 函数名: dma_buf_put\n- 参数: [shm->dmabuf]\n- 调用者: tee_shm_put\n- 被调用者: 未提供（上下文缺失）"
  },
  {
    "id": 3171,
    "cwe": "CWE-362",
    "cve": "CVE-2021-44733",
    "purpose": "Code purpose:\"\"\"该代码用于在TEE子系统中分配和管理共享内存对象，包括处理不同类型的共享内存标志和资源分配\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在释放共享内存对象时存在竞争条件，导致在tee_shm_get_from_id中可能发生释放后使用(UAF)的问题\"\"\"",
    "functions": "Functions:\n1. 函数名: tee_shm_alloc\n- 参数: [struct tee_context *ctx, size_t size, u32 flags]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [dev_err, ERR_PTR, tee_device_get, kzalloc, poolm->ops->alloc, DEFINE_DMA_BUF_EXPORT_INFO, mutex_lock, idr_alloc, mutex_unlock, dma_buf_export, ERR_CAST, teedev_ctx_get, idr_remove, poolm->ops->free, kfree, tee_device_put]\n\n2. 函数名: dev_err\n- 参数: [teedev->dev.parent, \"only mapped allocations supported\\n\"] 或 [teedev->dev.parent, \"invalid shm flags 0x%x\", flags]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（内核日志函数）\n\n3. 函数名: ERR_PTR\n- 参数: [-EINVAL] 或 [-ENOMEM] 或 [rc] 或 [shm->id]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（内核错误处理宏）\n\n4. 函数名: tee_device_get\n- 参数: [teedev]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（外部函数）\n\n5. 函数名: kzalloc\n- 参数: [sizeof(*shm), GFP_KERNEL]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（内核内存分配函数）\n\n6. 函数名: poolm->ops->alloc\n- 参数: [poolm, shm, size]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（函数指针调用）\n\n7. 函数名: DEFINE_DMA_BUF_EXPORT_INFO\n- 参数: [exp_info]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（宏定义）\n\n8. 函数名: mutex_lock\n- 参数: [&teedev->mutex]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（内核互斥锁函数）\n\n9. 函数名: idr_alloc\n- 参数: [&teedev->idr, shm, 1, 0, GFP_KERNEL]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（内核ID分配函数）\n\n10. 函数名: mutex_unlock\n- 参数: [&teedev->mutex]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（内核互斥锁函数）\n\n11. 函数名: dma_buf_export\n- 参数: [&exp_info]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（DMA缓冲区导出函数）\n\n12. 函数名: ERR_CAST\n- 参数: [shm->dmabuf]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（内核错误处理宏）\n\n13. 函数名: teedev_ctx_get\n- 参数: [ctx]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（外部函数）\n\n14. 函数名: idr_remove\n- 参数: [&teedev->idr, shm->id]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（内核ID移除函数）\n\n15. 函数名: poolm->ops->free\n- 参数: [poolm, shm]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（函数指针调用）\n\n16. 函数名: kfree\n- 参数: [shm]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（内核内存释放函数）\n\n17. 函数名: tee_device_put\n- 参数: [teedev]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（外部函数）"
  },
  {
    "id": 3172,
    "cwe": "CWE-362",
    "cve": "CVE-2021-44733",
    "purpose": "Code purpose:\"\"\"该代码用于获取共享内存对象的文件描述符，并在失败时释放相关资源\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于tee_shm_get_fd函数在处理共享内存对象时存在竞态条件，导致在释放共享内存对象时可能发生use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: tee_shm_get_fd\n- 参数: [struct tee_shm *shm]\n- 调用者: 未指定\n- 被调用者: [get_dma_buf, dma_buf_fd, dma_buf_put]\n\n2. 函数名: get_dma_buf\n- 参数: [shm->dmabuf]\n- 调用者: tee_shm_get_fd\n- 被调用者: 未指定\n\n3. 函数名: dma_buf_fd\n- 参数: [shm->dmabuf, O_CLOEXEC]\n- 调用者: tee_shm_get_fd\n- 被调用者: 未指定\n\n4. 函数名: dma_buf_put\n- 参数: [shm->dmabuf]\n- 调用者: tee_shm_get_fd\n- 被调用者: 未指定"
  },
  {
    "id": 3242,
    "cwe": "CWE-362",
    "cve": "CVE-2022-1048",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核声音子系统中处理PCM子流的附加操作，包括资源分配、状态管理和并发控制\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在ALSA PCM子系统中存在并发调用hw_params和hw_free等ioctl操作时的竞态条件，导致释放后重用(UAF)漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_pcm_attach_substream\n- 参数: [struct snd_pcm *pcm, int stream, struct file *file, struct snd_pcm_substream **rsubstream]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [snd_ctl_get_preferred_subdevice, kzalloc, alloc_pages_exact, free_pages_exact, kfree, memset, init_waitqueue_head, get_pid, task_pid]\n\n2. 函数名: snd_ctl_get_preferred_subdevice\n- 参数: [struct snd_card *card, SND_CTL_SUBDEV_PCM]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: 未明确（可能由内核提供）\n\n3. 函数名: kzalloc\n- 参数: [sizeof(*runtime), GFP_KERNEL]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: 未明确（内核内存分配函数）\n\n4. 函数名: alloc_pages_exact\n- 参数: [size, GFP_KERNEL]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: 未明确（内核内存分配函数）\n\n5. 函数名: free_pages_exact\n- 参数: [runtime->status, PAGE_ALIGN(sizeof(struct snd_pcm_mmap_status))]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: 未明确（内核内存释放函数）\n\n6. 函数名: kfree\n- 参数: [runtime]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: 未明确（内核内存释放函数）\n\n7. 函数名: memset\n- 参数: [runtime->status, 0, size]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: 未明确（标准库函数）\n\n8. 函数名: init_waitqueue_head\n- 参数: [&runtime->sleep]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: 未明确（内核函数）\n\n9. 函数名: get_pid\n- 参数: [task_pid(current)]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: 未明确（内核函数）\n\n10. 函数名: task_pid\n- 参数: [current]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: 未明确（内核函数）"
  },
  {
    "id": 3243,
    "cwe": "CWE-362",
    "cve": "CVE-2022-1048",
    "purpose": "Code purpose:\"\"\"释放PCM子流相关资源并处理并发访问问题\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在释放PCM子流资源时未正确处理并发访问，导致存在释放后使用(UAF)漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_pcm_detach_substream\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: 未指定\n- 被调用者: [PCM_RUNTIME_CHECK, free_pages_exact, kfree, spin_lock_irq, spin_unlock_irq, put_pid]\n\n2. 函数名: PCM_RUNTIME_CHECK\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_detach_substream\n- 被调用者: 未指定\n\n3. 函数名: free_pages_exact\n- 参数: [runtime->status, PAGE_ALIGN(sizeof(struct snd_pcm_mmap_status))]\n- 调用者: snd_pcm_detach_substream\n- 被调用者: 未指定\n\n4. 函数名: free_pages_exact\n- 参数: [runtime->control, PAGE_ALIGN(sizeof(struct snd_pcm_mmap_control))]\n- 调用者: snd_pcm_detach_substream\n- 被调用者: 未指定\n\n5. 函数名: kfree\n- 参数: [runtime->hw_constraints.rules]\n- 调用者: snd_pcm_detach_substream\n- 被调用者: 未指定\n\n6. 函数名: spin_lock_irq\n- 参数: [&substream->timer->lock]\n- 调用者: snd_pcm_detach_substream\n- 被调用者: 未指定\n\n7. 函数名: spin_unlock_irq\n- 参数: [&substream->timer->lock]\n- 调用者: snd_pcm_detach_substream\n- 被调用者: 未指定\n\n8. 函数名: kfree\n- 参数: [runtime]\n- 调用者: snd_pcm_detach_substream\n- 被调用者: 未指定\n\n9. 函数名: put_pid\n- 参数: [substream->pid]\n- 调用者: snd_pcm_detach_substream\n- 被调用者: 未指定"
  },
  {
    "id": 3244,
    "cwe": "CWE-362",
    "cve": "CVE-2022-1048",
    "purpose": "Code purpose:\"\"\"释放PCM子流的硬件资源并将其状态设置为OPEN\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在ALSA PCM子系统中，由于对PCM hw_params的并发调用处理不当，导致在hw_free ioctl操作时出现竞态条件，可能引发释放后使用问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_pcm_hw_free\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [PCM_RUNTIME_CHECK, snd_pcm_stream_lock_irq, snd_pcm_stream_unlock_irq, atomic_read, do_hw_free, snd_pcm_set_state, cpu_latency_qos_remove_request]\n\n2. 函数名: PCM_RUNTIME_CHECK\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_hw_free\n- 被调用者: []\n\n3. 函数名: snd_pcm_stream_lock_irq\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_hw_free\n- 被调用者: []\n\n4. 函数名: snd_pcm_stream_unlock_irq\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_hw_free\n- 被调用者: []\n\n5. 函数名: atomic_read\n- 参数: [&substream->mmap_count]\n- 调用者: snd_pcm_hw_free\n- 被调用者: []\n\n6. 函数名: do_hw_free\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_hw_free\n- 被调用者: []\n\n7. 函数名: snd_pcm_set_state\n- 参数: [struct snd_pcm_substream *substream, SNDRV_PCM_STATE_OPEN]\n- 调用者: snd_pcm_hw_free\n- 被调用者: []\n\n8. 函数名: cpu_latency_qos_remove_request\n- 参数: [&substream->latency_pm_qos_req]\n- 调用者: snd_pcm_hw_free\n- 被调用者: []"
  },
  {
    "id": 3245,
    "cwe": "CWE-362",
    "cve": "CVE-2022-1048",
    "purpose": "Code purpose:\"\"\"该代码用于处理PCM子流的硬件参数设置，包括参数验证、缓冲区分配、状态转换和资源管理，是Linux内核声音子系统的一部分。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核声音子系统中，PCM hw_params的并发调用导致竞态条件，引发释放后使用漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_pcm_hw_params\n- 参数: [substream, params]\n- 调用者: 外部调用\n- 被调用者: [PCM_RUNTIME_CHECK, snd_pcm_stream_lock_irq, snd_pcm_stream_unlock_irq, atomic_read, snd_pcm_sync_stop, snd_pcm_hw_refine, snd_pcm_hw_params_choose, fixup_unreferenced_params, snd_pcm_lib_malloc_pages, params_buffer_bytes, params_access, params_format, params_subformat, params_channels, params_rate, params_period_size, params_periods, params_buffer_size, snd_pcm_format_physical_width, PAGE_ALIGN, memset, snd_pcm_timer_resolution_change, snd_pcm_set_state, cpu_latency_qos_request_active, cpu_latency_qos_remove_request, period_to_usecs, cpu_latency_qos_add_request, snd_pcm_lib_free_pages]\n\n2. 函数名: PCM_RUNTIME_CHECK\n- 参数: [substream]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n3. 函数名: snd_pcm_stream_lock_irq\n- 参数: [substream]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n4. 函数名: snd_pcm_stream_unlock_irq\n- 参数: [substream]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n5. 函数名: atomic_read\n- 参数: [&substream->mmap_count]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n6. 函数名: snd_pcm_sync_stop\n- 参数: [substream, true]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n7. 函数名: snd_pcm_hw_refine\n- 参数: [substream, params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n8. 函数名: snd_pcm_hw_params_choose\n- 参数: [substream, params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n9. 函数名: fixup_unreferenced_params\n- 参数: [substream, params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n10. 函数名: snd_pcm_lib_malloc_pages\n- 参数: [substream, params_buffer_bytes(params)]\n- 调用者: snd_pcm_hw_params\n- 被调用者: [params_buffer_bytes]\n\n11. 函数名: params_buffer_bytes\n- 参数: [params]\n- 调用者: snd_pcm_lib_malloc_pages\n- 被调用者: []\n\n12. 函数名: params_access\n- 参数: [params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n13. 函数名: params_format\n- 参数: [params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n14. 函数名: params_subformat\n- 参数: [params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n15. 函数名: params_channels\n- 参数: [params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n16. 函数名: params_rate\n- 参数: [params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n17. 函数名: params_period_size\n- 参数: [params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n18. 函数名: params_periods\n- 参数: [params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n19. 函数名: params_buffer_size\n- 参数: [params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n20. 函数名: snd_pcm_format_physical_width\n- 参数: [runtime->format]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n21. 函数名: PAGE_ALIGN\n- 参数: [size]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n22. 函数名: memset\n- 参数: [runtime->dma_area, 0, size]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n23. 函数名: snd_pcm_timer_resolution_change\n- 参数: [substream]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n24. 函数名: snd_pcm_set_state\n- 参数: [substream, SNDRV_PCM_STATE_SETUP/SNDRV_PCM_STATE_OPEN]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n25. 函数名: cpu_latency_qos_request_active\n- 参数: [&substream->latency_pm_qos_req]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n26. 函数名: cpu_latency_qos_remove_request\n- 参数: [&substream->latency_pm_qos_req]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n27. 函数名: period_to_usecs\n- 参数: [runtime]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n28. 函数名: cpu_latency_qos_add_request\n- 参数: [&substream->latency_pm_qos_req, usecs]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n29. 函数名: snd_pcm_lib_free_pages\n- 参数: [substream]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []"
  },
  {
    "id": 3261,
    "cwe": "CWE-362",
    "cve": "CVE-2022-1462",
    "purpose": "Code purpose:\"\"\"该代码实现了伪终端(pty)的数据写入功能，将数据从一端写入另一端的输入队列，并处理流控制和缓冲区推送。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于竞态条件导致的内存越界读取漏洞，当用户通过特定ioctl操作触发时，可能泄露内存数据或导致系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: pty_write\n- 参数: [tty, buf, c]\n- 调用者: 不适用（由内核调用）\n- 被调用者: [spin_lock_irqsave, tty_insert_flip_string, spin_unlock_irqrestore, tty_flip_buffer_push]\n\n2. 函数名: spin_lock_irqsave\n- 参数: [&to->port->lock, flags]\n- 调用者: pty_write\n- 被调用者: []\n\n3. 函数名: tty_insert_flip_string\n- 参数: [to->port, buf, c]\n- 调用者: pty_write\n- 被调用者: []\n\n4. 函数名: spin_unlock_irqrestore\n- 参数: [&to->port->lock, flags]\n- 调用者: pty_write\n- 被调用者: []\n\n5. 函数名: tty_flip_buffer_push\n- 参数: [to->port]\n- 调用者: pty_write\n- 被调用者: []"
  },
  {
    "id": 3276,
    "cwe": "CWE-362",
    "cve": "CVE-2022-1729",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中perf_event_open系统调用，用于创建和管理性能监控事件，但存在竞争条件漏洞可被利用提升权限\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于perf_event_open()函数中存在竞态条件，未正确同步对任务信号结构的访问，导致非特权用户可利用该条件进行权限提升\"\"\"",
    "functions": "Functions:\n1. 函数名: perf_event_open\n- 参数: [struct perf_event_attr __user *attr_uptr, pid_t pid, int cpu, int group_fd, unsigned long flags]\n- 调用者: 系统调用\n- 被调用者: [security_perf_event_open, perf_copy_attr, perf_allow_kernel, perfmon_capable, perf_fget_light, find_lively_task_by_vpid, perf_event_alloc, perf_event_set_clock, find_get_context, perf_event_set_output, anon_inode_getfile, down_read_interruptible, perf_check_permission, __perf_event_ctx_lock_double, exclusive_event_installable, for_each_sibling_event, perf_remove_from_context, put_ctx, synchronize_rcu, perf_event__state_init, perf_install_in_context, get_ctx, perf_event__header_size, perf_event__id_header_size, perf_unpin_context, perf_event_ctx_unlock, up_read, put_task_struct, fdput, fd_install, put_unused_fd, fput, perf_unpin_context, put_ctx, free_event]\n\n2. 函数名: security_perf_event_open\n- 参数: [struct perf_event_attr *attr, int type]\n- 调用者: perf_event_open\n- 被调用者: []\n\n3. 函数名: perf_copy_attr\n- 参数: [struct perf_event_attr __user *attr_uptr, struct perf_event_attr *attr]\n- 调用者: perf_event_open\n- 被调用者: []\n\n4. 函数名: perf_allow_kernel\n- 参数: [struct perf_event_attr *attr]\n- 调用者: perf_event_open\n- 被调用者: []\n\n5. 函数名: perfmon_capable\n- 参数: []\n- 调用者: perf_event_open\n- 被调用者: []\n\n6. 函数名: perf_fget_light\n- 参数: [int fd, struct fd *f]\n- 调用者: perf_event_open\n- 被调用者: []\n\n7. 函数名: find_lively_task_by_vpid\n- 参数: [pid_t pid]\n- 调用者: perf_event_open\n- 被调用者: []\n\n8. 函数名: perf_event_alloc\n- 参数: [struct perf_event_attr *attr, int cpu, struct task_struct *task, struct perf_event *group_leader, void *overflow_handler, void *context, int cgroup_fd]\n- 调用者: perf_event_open\n- 被调用者: []\n\n9. 函数名: perf_event_set_clock\n- 参数: [struct perf_event *event, clockid_t clockid]\n- 调用者: perf_event_open\n- 被调用者: []\n\n10. 函数名: find_get_context\n- 参数: [struct pmu *pmu, struct task_struct *task, struct perf_event *event]\n- 调用者: perf_event_open\n- 被调用者: []\n\n11. 函数名: perf_event_set_output\n- 参数: [struct perf_event *event, struct perf_event *output_event]\n- 调用者: perf_event_open\n- 被调用者: []\n\n12. 函数名: anon_inode_getfile\n- 参数: [const char *name, const struct file_operations *fops, void *priv, int flags]\n- 调用者: perf_event_open\n- 被调用者: []\n\n13. 函数名: down_read_interruptible\n- 参数: [struct rw_semaphore *sem]\n- 调用者: perf_event_open\n- 被调用者: []\n\n14. 函数名: perf_check_permission\n- 参数: [struct perf_event_attr *attr, struct task_struct *task]\n- 调用者: perf_event_open\n- 被调用者: []\n\n15. 函数名: __perf_event_ctx_lock_double\n- 参数: [struct perf_event *group_leader, struct perf_event_context *ctx]\n- 调用者: perf_event_open\n- 被调用者: []\n\n16. 函数名: exclusive_event_installable\n- 参数: [struct perf_event *event, struct perf_event_context *ctx]\n- 调用者: perf_event_open\n- 被调用者: []\n\n17. 函数名: for_each_sibling_event\n- 参数: [struct perf_event *sibling, struct perf_event *group_leader]\n- 调用者: perf_event_open\n- 被调用者: []\n\n18. 函数名: perf_remove_from_context\n- 参数: [struct perf_event *event, int flags]\n- 调用者: perf_event_open\n- 被调用者: []\n\n19. 函数名: put_ctx\n- 参数: [struct perf_event_context *ctx]\n- 调用者: perf_event_open\n- 被调用者: []\n\n20. 函数名: synchronize_rcu\n- 参数: []\n- 调用者: perf_event_open\n- 被调用者: []\n\n21. 函数名: perf_event__state_init\n- 参数: [struct perf_event *event]\n- 调用者: perf_event_open\n- 被调用者: []\n\n22. 函数名: perf_install_in_context\n- 参数: [struct perf_event_context *ctx, struct perf_event *event, int cpu]\n- 调用者: perf_event_open\n- 被调用者: []\n\n23. 函数名: get_ctx\n- 参数: [struct perf_event_context *ctx]\n- 调用者: perf_event_open\n- 被调用者: []\n\n24. 函数名: perf_event__header_size\n- 参数: [struct perf_event *event]\n- 调用者: perf_event_open\n- 被调用者: []\n\n25. 函数名: perf_event__id_header_size\n- 参数: [struct perf_event *event]\n- 调用者: perf_event_open\n- 被调用者: []\n\n26. 函数名: perf_unpin_context\n- 参数: [struct perf_event_context *ctx]\n- 调用者: perf_event_open\n- 被调用者: []\n\n27. 函数名: perf_event_ctx_unlock\n- 参数: [struct perf_event *group_leader, struct perf_event_context *ctx]\n- 调用者: perf_event_open\n- 被调用者: []\n\n28. 函数名: up_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: perf_event_open\n- 被调用者: []\n\n29. 函数名: put_task_struct\n- 参数: [struct task_struct *t]\n- 调用者: perf_event_open\n- 被调用者: []\n\n30. 函数名: fdput\n- 参数: [struct fd fd]\n- 调用者: perf_event_open\n- 被调用者: []\n\n31. 函数名: fd_install\n- 参数: [int fd, struct file *file]\n- 调用者: perf_event_open\n- 被调用者: []\n\n32. 函数名: put_unused_fd\n- 参数: [int fd]\n- 调用者: perf_event_open\n- 被调用者: []\n\n33. 函数名: fput\n- 参数: [struct file *file]\n- 调用者: perf_event_open\n- 被调用者: []\n\n34. 函数名: free_event\n- 参数: [struct perf_event *event]\n- 调用者: perf_event_open\n- 被调用者: []"
  },
  {
    "id": 3337,
    "cwe": "CWE-362",
    "cve": "CVE-2022-20141",
    "purpose": "Code purpose:\"\"\"检查给定的多播地址和源地址是否在设备的接收列表中，用于IGMP协议处理\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在RCU读取期间未正确加锁保护，导致在多线程环境下可能出现释放后使用(UAF)的情况\"\"\"",
    "functions": "Functions:\n1. 函数名: ip_check_mc_rcu\n- 参数: [struct in_device *in_dev, __be32 mc_addr, __be32 src_addr, u8 proto]\n- 调用者: 未明确（由系统调用）\n- 被调用者: [hash_32, rcu_dereference]\n\n2. 函数名: hash_32\n- 参数: [(__force u32)mc_addr, MC_HASH_SZ_LOG]\n- 调用者: ip_check_mc_rcu\n- 被调用者: []\n\n3. 函数名: rcu_dereference\n- 参数: [in_dev->mc_hash], [mc_hash[hash]], [im->next_hash]\n- 调用者: ip_check_mc_rcu\n- 被调用者: []\n\n4. 函数名: for_each_pmc_rcu\n- 参数: [in_dev, im]\n- 调用者: ip_check_mc_rcu\n- 被调用者: []"
  },
  {
    "id": 3338,
    "cwe": "CWE-362",
    "cve": "CVE-2022-20148",
    "purpose": "Code purpose:\"\"\"该代码实现了F2FS文件系统的超级块初始化、挂载过程，包括内存分配、设备扫描、检查点恢复、元数据读取等核心功能，并处理文件系统挂载时的各种错误情况。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于竞态条件导致的use-after-free漏洞，当多个线程同时访问和释放资源时，缺乏适当的同步机制，造成在资源被释放后仍被使用的情况。\"\"\"",
    "functions": "Functions:\n1. 函数名: f2fs_fill_super\n- 参数: [struct super_block *sb, void *data, int silent]\n- 调用者: N/A\n- 被调用者: [kzalloc, crypto_alloc_shash, sb_set_blocksize, read_raw_super_block, f2fs_chksum, kstrdup, parse_options, f2fs_setup_casefold, f2fs_init_iostat, init_percpu_info, mempool_create_page_pool, f2fs_init_xattr_caches, f2fs_init_page_array_cache, f2fs_iget, f2fs_get_valid_checkpoint, f2fs_scan_devices, f2fs_init_post_read_wq, f2fs_start_ckpt_thread, f2fs_build_segment_manager, f2fs_build_node_manager, f2fs_build_gc_manager, f2fs_build_stats, f2fs_init_compress_inode, f2fs_register_sysfs, f2fs_enable_quotas, f2fs_recover_orphan_inodes, f2fs_recover_fsync_data, f2fs_check_write_pointer, f2fs_disable_checkpoint, f2fs_enable_checkpoint, f2fs_start_gc_thread, f2fs_commit_super, f2fs_join_shrinker, f2fs_tuning_parameters, f2fs_update_time, sync_filesystem, f2fs_truncate_quota_inode_pages, f2fs_quota_off_umount, truncate_inode_pages_final, evict_inodes, f2fs_unregister_sysfs, f2fs_destroy_compress_inode, f2fs_release_ino_entry, f2fs_destroy_stats, f2fs_destroy_node_manager, f2fs_destroy_segment_manager, f2fs_destroy_post_read_wq, f2fs_stop_ckpt_thread, destroy_device_list, make_bad_inode, f2fs_destroy_page_array_cache, f2fs_destroy_xattr_caches, mempool_destroy, destroy_percpu_info, f2fs_destroy_iostat, utf8_unload, fscrypt_free_dummy_policy, shrink_dcache_sb]\n\n2. 函数名: read_raw_super_block\n- 参数: [struct f2fs_sb_info *sbi, struct f2fs_super_block **raw_super, int *valid_super_block, int *recovery]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n3. 函数名: parse_options\n- 参数: [struct super_block *sb, char *options, bool false]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n4. 函数名: f2fs_setup_casefold\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n5. 函数名: f2fs_init_iostat\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n6. 函数名: init_percpu_info\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n7. 函数名: f2fs_init_xattr_caches\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n8. 函数名: f2fs_init_page_array_cache\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n9. 函数名: f2fs_get_valid_checkpoint\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n10. 函数名: f2fs_scan_devices\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n11. 函数名: f2fs_init_post_read_wq\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n12. 函数名: f2fs_start_ckpt_thread\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n13. 函数名: f2fs_build_segment_manager\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n14. 函数名: f2fs_build_node_manager\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n15. 函数名: f2fs_build_gc_manager\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n16. 函数名: f2fs_build_stats\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n17. 函数名: f2fs_init_compress_inode\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n18. 函数名: f2fs_register_sysfs\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n19. 函数名: f2fs_enable_quotas\n- 参数: [struct super_block *sb]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n20. 函数名: f2fs_recover_orphan_inodes\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n21. 函数名: f2fs_recover_fsync_data\n- 参数: [struct f2fs_sb_info *sbi, bool true/false]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n22. 函数名: f2fs_check_write_pointer\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n23. 函数名: f2fs_disable_checkpoint\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n24. 函数名: f2fs_enable_checkpoint\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n25. 函数名: f2fs_start_gc_thread\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n26. 函数名: f2fs_commit_super\n- 参数: [struct f2fs_sb_info *sbi, bool true]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n27. 函数名: f2fs_join_shrinker\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n28. 函数名: f2fs_tuning_parameters\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n29. 函数名: f2fs_update_time\n- 参数: [struct f2fs_sb_info *sbi, CP_TIME/REQ_TIME]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n30. 函数名: f2fs_truncate_quota_inode_pages\n- 参数: [struct super_block *sb]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n31. 函数名: f2fs_quota_off_umount\n- 参数: [struct super_block *sb]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n32. 函数名: f2fs_unregister_sysfs\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n33. 函数名: f2fs_destroy_compress_inode\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n34. 函数名: f2fs_release_ino_entry\n- 参数: [struct f2fs_sb_info *sbi, bool true]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n35. 函数名: f2fs_destroy_stats\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n36. 函数名: f2fs_destroy_node_manager\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n37. 函数名: f2fs_destroy_segment_manager\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n38. 函数名: f2fs_destroy_post_read_wq\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n39. 函数名: f2fs_stop_ckpt_thread\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n40. 函数名: destroy_device_list\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n41. 函数名: f2fs_destroy_page_array_cache\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n42. 函数名: f2fs_destroy_xattr_caches\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n43. 函数名: destroy_percpu_info\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n44. 函数名: f2fs_destroy_iostat\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A"
  },
  {
    "id": 3340,
    "cwe": "CWE-362",
    "cve": "CVE-2022-20154",
    "purpose": "Code purpose:\"\"\"该代码片段实现了SCTP协议的诊断信息转储功能，通过遍历端点(ep)和传输(asoc)哈希表来收集和输出网络连接状态信息。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在lock_sock_nested函数中存在竞态条件导致锁释放后仍被使用，造成释放后重用漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: sctp_diag_dump\n- 参数: [skb, cb, r]\n- 调用者: N/A (顶层函数)\n- 被调用者: [sock_net, netlink_net_capable, sctp_for_each_endpoint, sctp_for_each_transport]\n\n2. 函数名: sock_net\n- 参数: [skb->sk]\n- 调用者: sctp_diag_dump\n- 被调用者: []\n\n3. 函数名: netlink_net_capable\n- 参数: [cb->skb, CAP_NET_ADMIN]\n- 调用者: sctp_diag_dump\n- 被调用者: []\n\n4. 函数名: sctp_for_each_endpoint\n- 参数: [sctp_ep_dump, &commp]\n- 调用者: sctp_diag_dump\n- 被调用者: [sctp_ep_dump]\n\n5. 函数名: sctp_ep_dump\n- 参数: [&commp]\n- 调用者: sctp_for_each_endpoint\n- 被调用者: []\n\n6. 函数名: sctp_for_each_transport\n- 参数: [sctp_sock_filter, sctp_sock_dump, net, &pos, &commp]\n- 调用者: sctp_diag_dump\n- 被调用者: [sctp_sock_filter, sctp_sock_dump]\n\n7. 函数名: sctp_sock_filter\n- 参数: [未明确显示，但由sctp_for_each_transport调用]\n- 调用者: sctp_for_each_transport\n- 被调用者: []\n\n8. 函数名: sctp_sock_dump\n- 参数: [未明确显示，但由sctp_for_each_transport调用]\n- 调用者: sctp_for_each_transport\n- 被调用者: []"
  },
  {
    "id": 3341,
    "cwe": "CWE-362",
    "cve": "CVE-2022-20154",
    "purpose": "Code purpose:\"\"\"增加sctp端点的引用计数以防止其在被使用时被释放\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在lock_sock_nested函数中存在竞态条件，导致引用计数操作时可能发生use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: sctp_endpoint_hold\n- 参数: [struct sctp_endpoint *ep]\n- 调用者: 未提供（需根据完整代码确定）\n- 被调用者: [refcount_inc]\n\n2. 函数名: refcount_inc\n- 参数: [&ep->base.refcnt]\n- 调用者: sctp_endpoint_hold\n- 被调用者: 未提供（需根据完整代码确定）"
  },
  {
    "id": 3342,
    "cwe": "CWE-362",
    "cve": "CVE-2022-20154",
    "purpose": "Code purpose:\"\"\"销毁SCTP端点并释放相关资源\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在销毁SCTP端点时存在竞态条件，导致在释放套接字资源后仍可能被访问，造成释放后重用漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: sctp_endpoint_destroy\n- 参数: [struct sctp_endpoint *ep]\n- 调用者: 未显示\n- 被调用者: [WARN, kfree, sctp_auth_destroy_keys, sctp_auth_free, sctp_inq_free, sctp_bind_addr_free, memset, sctp_put_port, sock_put, SCTP_DBG_OBJCNT_DEC]\n\n2. 函数名: WARN\n- 参数: [1, \"Attempt to destroy undead endpoint %p!\\n\", ep]\n- 调用者: sctp_endpoint_destroy\n- 被调用者: 未显示\n\n3. 函数名: kfree\n- 参数: [ep->digest]\n- 调用者: sctp_endpoint_destroy\n- 被调用者: 未显示\n\n4. 函数名: sctp_auth_destroy_keys\n- 参数: [&ep->endpoint_shared_keys]\n- 调用者: sctp_endpoint_destroy\n- 被调用者: 未显示\n\n5. 函数名: sctp_auth_free\n- 参数: [ep]\n- 调用者: sctp_endpoint_destroy\n- 被调用者: 未显示\n\n6. 函数名: sctp_inq_free\n- 参数: [&ep->base.inqueue]\n- 调用者: sctp_endpoint_destroy\n- 被调用者: 未显示\n\n7. 函数名: sctp_bind_addr_free\n- 参数: [&ep->base.bind_addr]\n- 调用者: sctp_endpoint_destroy\n- 被调用者: 未显示\n\n8. 函数名: memset\n- 参数: [ep->secret_key, 0, sizeof(ep->secret_key)]\n- 调用者: sctp_endpoint_destroy\n- 被调用者: 未显示\n\n9. 函数名: sctp_put_port\n- 参数: [sk]\n- 调用者: sctp_endpoint_destroy\n- 被调用者: 未显示\n\n10. 函数名: sock_put\n- 参数: [sk]\n- 调用者: sctp_endpoint_destroy\n- 被调用者: 未显示\n\n11. 函数名: SCTP_DBG_OBJCNT_DEC\n- 参数: [ep]\n- 调用者: sctp_endpoint_destroy\n- 被调用者: 未显示"
  },
  {
    "id": 3397,
    "cwe": "CWE-362",
    "cve": "CVE-2022-20567",
    "purpose": "Code purpose:\"\"\"该代码片段定义了一个空的pppol2tp会话关闭函数，用于处理L2TP PPP会话的关闭操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于pppol2tp_session_close函数中存在竞态条件导致的释放后使用漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: pppol2tp_session_close\n- 参数: [session]\n- 调用者: 未提供\n- 被调用者: []"
  },
  {
    "id": 3398,
    "cwe": "CWE-362",
    "cve": "CVE-2022-20567",
    "purpose": "Code purpose:\"\"\"该代码实现了PPPoL2TP协议的socket连接功能，包括隧道和会话的创建、绑定和管理，用于建立L2TP VPN连接。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在pppol2tp_connect函数中存在竞态条件，当多个线程同时访问和修改session和tunnel引用计数时可能导致use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: pppol2tp_connect\n- 参数: [struct socket *sock, struct sockaddr *uservaddr, int sockaddr_len, int flags]\n- 调用者: 未显示（由系统调用触发）\n- 被调用者: [lock_sock, pppox_sk, l2tp_tunnel_get, sock_net, l2tp_tunnel_create, l2tp_session_get, l2tp_session_priv, mutex_lock, rcu_dereference_protected, mutex_unlock, l2tp_session_create, pppol2tp_session_init, l2tp_session_inc_refcount, l2tp_session_register, kfree, ppp_register_net_channel, l2tp_session_dec_refcount, l2tp_tunnel_dec_refcount, release_sock]\n\n2. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n3. 函数名: pppox_sk\n- 参数: [struct sock *sk]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n4. 函数名: l2tp_tunnel_get\n- 参数: [struct net *net, u32 tunnel_id]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n5. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n6. 函数名: l2tp_tunnel_create\n- 参数: [struct net *net, int fd, int version, u32 tunnel_id, u32 peer_tunnel_id, struct l2tp_tunnel_cfg *cfg, struct l2tp_tunnel **tunnelp]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n7. 函数名: l2tp_session_get\n- 参数: [struct net *net, struct l2tp_tunnel *tunnel, u32 session_id]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n8. 函数名: l2tp_session_priv\n- 参数: [struct l2tp_session *session]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n9. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n10. 函数名: rcu_dereference_protected\n- 参数: [void *p, int condition]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n11. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n12. 函数名: l2tp_session_create\n- 参数: [int priv_size, struct l2tp_tunnel *tunnel, u32 session_id, u32 peer_session_id, struct l2tp_session_cfg *cfg]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n13. 函数名: pppol2tp_session_init\n- 参数: [struct l2tp_session *session]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n14. 函数名: l2tp_session_inc_refcount\n- 参数: [struct l2tp_session *session]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n15. 函数名: l2tp_session_register\n- 参数: [struct l2tp_session *session, struct l2tp_tunnel *tunnel]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n16. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n17. 函数名: ppp_register_net_channel\n- 参数: [struct net *net, struct ppp_channel *chan]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n18. 函数名: l2tp_session_dec_refcount\n- 参数: [struct l2tp_session *session]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n19. 函数名: l2tp_tunnel_dec_refcount\n- 参数: [struct l2tp_tunnel *tunnel]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n20. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: pppol2tp_connect\n- 被调用者: []"
  },
  {
    "id": 3399,
    "cwe": "CWE-362",
    "cve": "CVE-2022-20567",
    "purpose": "Code purpose:\"\"\"释放PPPoL2TP套接字和相关会话资源，处理套接字状态变更和资源清理\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在pppol2tp_release函数中存在竞态条件，导致在释放会话资源时可能出现use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: pppol2tp_release\n- 参数: [struct socket *sock]\n- 调用者: 未显示（通常由socket关闭操作调用）\n- 被调用者: [lock_sock, sock_flag, pppox_unbind_sock, sock_orphan, pppol2tp_sock_to_session, l2tp_session_delete, l2tp_session_priv, mutex_lock, rcu_dereference_protected, lockdep_is_held, RCU_INIT_POINTER, mutex_unlock, call_rcu, release_sock, sock_put]\n\n2. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n3. 函数名: sock_flag\n- 参数: [struct sock *sk, SOCK_DEAD]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n4. 函数名: pppox_unbind_sock\n- 参数: [struct sock *sk]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n5. 函数名: sock_orphan\n- 参数: [struct sock *sk]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n6. 函数名: pppol2tp_sock_to_session\n- 参数: [struct sock *sk]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n7. 函数名: l2tp_session_delete\n- 参数: [struct l2tp_session *session]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n8. 函数名: l2tp_session_priv\n- 参数: [struct l2tp_session *session]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n9. 函数名: mutex_lock\n- 参数: [&ps->sk_lock]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n10. 函数名: rcu_dereference_protected\n- 参数: [ps->sk, lockdep_is_held(&ps->sk_lock)]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n11. 函数名: lockdep_is_held\n- 参数: [&ps->sk_lock]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n12. 函数名: RCU_INIT_POINTER\n- 参数: [ps->sk, NULL]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n13. 函数名: mutex_unlock\n- 参数: [&ps->sk_lock]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n14. 函数名: call_rcu\n- 参数: [&ps->rcu, pppol2tp_put_sk]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n15. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n16. 函数名: sock_put\n- 参数: [struct sock *sk]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n17. 函数名: pppol2tp_put_sk\n- 参数: 未显示（通过call_rcu调用）\n- 调用者: call_rcu\n- 被调用者: []"
  },
  {
    "id": 3419,
    "cwe": "CWE-362",
    "cve": "CVE-2022-23036",
    "purpose": "Code purpose:\"\"\"结束对外部域授予的内存页面的访问权限，并根据情况释放资源或延迟处理\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"前端在移除后端访问权限时存在竞态条件，后端可能在权限检查后和实际移除前重新映射授权页面，导致后端持续拥有对客户机内存页的访问权限\"\"\"",
    "functions": "Functions:\n1. 函数名: gnttab_end_foreign_access\n- 参数: [grant_ref_t ref, int readonly, unsigned long page]\n- 调用者: 未指定（根据上下文可能是PV设备前端驱动）\n- 被调用者: [gnttab_end_foreign_access_ref, put_free_entry, put_page, virt_to_page, gnttab_add_deferred]\n\n2. 函数名: gnttab_end_foreign_access_ref\n- 参数: [grant_ref_t ref, int readonly]\n- 调用者: gnttab_end_foreign_access\n- 被调用者: 未指定\n\n3. 函数名: put_free_entry\n- 参数: [grant_ref_t ref]\n- 调用者: gnttab_end_foreign_access\n- 被调用者: 未指定\n\n4. 函数名: put_page\n- 参数: [struct page *page]\n- 调用者: gnttab_end_foreign_access\n- 被调用者: 未指定\n\n5. 函数名: virt_to_page\n- 参数: [unsigned long page]\n- 调用者: gnttab_end_foreign_access\n- 被调用者: 未指定\n\n6. 函数名: gnttab_add_deferred\n- 参数: [grant_ref_t ref, int readonly, struct page *page]\n- 调用者: gnttab_end_foreign_access\n- 被调用者: 未指定"
  },
  {
    "id": 3420,
    "cwe": "CWE-362",
    "cve": "CVE-2022-23037",
    "purpose": "Code purpose:\"\"\"该代码用于处理网络前端队列中的传输缓冲区垃圾回收，包括响应处理、资源释放和错误处理等功能。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"前端在移除后端访问权限时存在竞态条件，恶意后端可能在权限检查后和权限移除前重新映射页面，从而保持对内存页的访问权限\"\"\"",
    "functions": "Functions:\n1. 函数名: xennet_tx_buf_gc\n- 参数: [struct netfront_queue *queue]\n- 调用者: 未显示\n- 被调用者: [dev_alert, RING_RESPONSE_PROD_OVERFLOW, RING_COPY_RESPONSE, gnttab_query_foreign_access, gnttab_end_foreign_access_ref, gnttab_release_grant_reference, add_id_to_list, dev_kfree_skb_irq, RING_FINAL_CHECK_FOR_RESPONSES, xennet_maybe_wake_tx]\n\n2. 函数名: dev_alert\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: xennet_tx_buf_gc\n- 被调用者: 未显示\n\n3. 函数名: RING_RESPONSE_PROD_OVERFLOW\n- 参数: [struct netfront_queue *queue, RING_IDX prod]\n- 调用者: xennet_tx_buf_gc\n- 被调用者: 未显示\n\n4. 函数名: RING_COPY_RESPONSE\n- 参数: [struct netfront_queue *queue, RING_IDX cons, struct xen_netif_tx_response *txrsp]\n- 调用者: xennet_tx_buf_gc\n- 被调用者: 未显示\n\n5. 函数名: gnttab_query_foreign_access\n- 参数: [grant_ref_t ref]\n- 调用者: xennet_tx_buf_gc\n- 被调用者: 未显示\n\n6. 函数名: gnttab_end_foreign_access_ref\n- 参数: [grant_ref_t ref, int readonly]\n- 调用者: xennet_tx_buf_gc\n- 被调用者: 未显示\n\n7. 函数名: gnttab_release_grant_reference\n- 参数: [grant_ref_t *head, grant_ref_t ref]\n- 调用者: xennet_tx_buf_gc\n- 被调用者: 未显示\n\n8. 函数名: add_id_to_list\n- 参数: [struct list_head *list, unsigned short *link, unsigned short id]\n- 调用者: xennet_tx_buf_gc\n- 被调用者: 未显示\n\n9. 函数名: dev_kfree_skb_irq\n- 参数: [struct sk_buff *skb]\n- 调用者: xennet_tx_buf_gc\n- 被调用者: 未显示\n\n10. 函数名: RING_FINAL_CHECK_FOR_RESPONSES\n- 参数: [struct netfront_queue *queue, bool *more_to_do]\n- 调用者: xennet_tx_buf_gc\n- 被调用者: 未显示\n\n11. 函数名: xennet_maybe_wake_tx\n- 参数: [struct netfront_queue *queue]\n- 调用者: xennet_tx_buf_gc\n- 被调用者: 未显示"
  },
  {
    "id": 3421,
    "cwe": "CWE-362",
    "cve": "CVE-2022-23039",
    "purpose": "Code purpose:\"\"\"该代码用于在Xen虚拟化环境中分配和管理grant reference，允许前端设备与后端设备共享内存页，但存在竞争条件漏洞可能导致恶意后端保持对内存页的访问权限\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在gntalloc驱动中，前端在移除后端访问权限时存在竞态条件，恶意后端可能在权限检查后但移除前映射授权页面，从而保持对客户机内存页的持续访问。\"\"\"",
    "functions": "Functions:\n1. 函数名: add_grefs\n- 参数: [struct ioctl_gntalloc_alloc_gref *op, uint32_t *gref_ids, struct gntalloc_file_private_data *priv]\n- 调用者: 未显示\n- 被调用者: [kzalloc, list_add_tail, alloc_page, gnttab_grant_foreign_access, xen_page_to_gfn, mutex_lock, list_splice_tail, mutex_unlock, list_for_each_entry_safe, list_del, __del_gref, list_empty]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*gref), GFP_KERNEL]\n- 调用者: add_grefs\n- 被调用者: 未显示\n\n3. 函数名: list_add_tail\n- 参数: [&gref->next_gref, &queue_gref], [&gref->next_file, &queue_file]\n- 调用者: add_grefs\n- 被调用者: 未显示\n\n4. 函数名: alloc_page\n- 参数: [GFP_KERNEL|__GFP_ZERO]\n- 调用者: add_grefs\n- 被调用者: 未显示\n\n5. 函数名: gnttab_grant_foreign_access\n- 参数: [op->domid, xen_page_to_gfn(gref->page), readonly]\n- 调用者: add_grefs\n- 被调用者: 未显示\n\n6. 函数名: xen_page_to_gfn\n- 参数: [gref->page]\n- 调用者: add_grefs\n- 被调用者: 未显示\n\n7. 函数名: mutex_lock\n- 参数: [&gref_mutex]\n- 调用者: add_grefs\n- 被调用者: 未显示\n\n8. 函数名: list_splice_tail\n- 参数: [&queue_gref, &gref_list], [&queue_file, &priv->list], [&queue_gref, &gref_list]\n- 调用者: add_grefs\n- 被调用者: 未显示\n\n9. 函数名: mutex_unlock\n- 参数: [&gref_mutex]\n- 调用者: add_grefs\n- 被调用者: 未显示\n\n10. 函数名: list_for_each_entry_safe\n- 参数: [gref, next, &queue_file, next_file]\n- 调用者: add_grefs\n- 被调用者: 未显示\n\n11. 函数名: list_del\n- 参数: [&gref->next_file]\n- 调用者: add_grefs\n- 被调用者: 未显示\n\n12. 函数名: __del_gref\n- 参数: [gref]\n- 调用者: add_grefs\n- 被调用者: 未显示\n\n13. 函数名: list_empty\n- 参数: [&queue_gref]\n- 调用者: add_grefs\n- 被调用者: 未显示"
  },
  {
    "id": 3422,
    "cwe": "CWE-362",
    "cve": "CVE-2022-23039",
    "purpose": "Code purpose:\"\"\"释放和管理Xen虚拟化环境中前端设备使用的grant reference资源，包括清除通知标志、释放内存页和解除后端访问权限。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在检查grant reference是否仍在使用后，代码假设后续的访问权限移除操作总会成功，但恶意后端可能在此期间映射granted page，导致前端无法真正移除后端的访问权限。\"\"\"",
    "functions": "Functions:\n1. 函数名: __del_gref\n- 参数: [struct gntalloc_gref *gref]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [kmap, kunmap, notify_remote_via_evtchn, evtchn_put, gnttab_query_foreign_access, gnttab_end_foreign_access_ref, gnttab_free_grant_reference, __free_page, kfree]\n\n2. 函数名: kmap\n- 参数: [gref->page]\n- 调用者: __del_gref\n- 被调用者: []\n\n3. 函数名: kunmap\n- 参数: [gref->page]\n- 调用者: __del_gref\n- 被调用者: []\n\n4. 函数名: notify_remote_via_evtchn\n- 参数: [gref->notify.event]\n- 调用者: __del_gref\n- 被调用者: []\n\n5. 函数名: evtchn_put\n- 参数: [gref->notify.event]\n- 调用者: __del_gref\n- 被调用者: []\n\n6. 函数名: gnttab_query_foreign_access\n- 参数: [gref->gref_id]\n- 调用者: __del_gref\n- 被调用者: []\n\n7. 函数名: gnttab_end_foreign_access_ref\n- 参数: [gref->gref_id, 0]\n- 调用者: __del_gref\n- 被调用者: []\n\n8. 函数名: gnttab_free_grant_reference\n- 参数: [gref->gref_id]\n- 调用者: __del_gref\n- 被调用者: []\n\n9. 函数名: __free_page\n- 参数: [gref->page]\n- 调用者: __del_gref\n- 被调用者: []\n\n10. 函数名: kfree\n- 参数: [gref]\n- 调用者: __del_gref\n- 被调用者: []"
  },
  {
    "id": 3423,
    "cwe": "CWE-362",
    "cve": "CVE-2022-23040",
    "purpose": "Code purpose:\"\"\"为Xen虚拟化环境中的前端设备分配并管理共享内存页面的访问权限\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"xenbus驱动在移除共享环缓冲区的授权访问时未检查操作是否成功，导致后端可能在授权访问被移除后仍保持对内存页的访问权限。\"\"\"",
    "functions": "Functions:\n1. 函数名: xenbus_grant_ring\n- 参数: [struct xenbus_device *dev, void *vaddr, unsigned int nr_pages, grant_ref_t *grefs]\n- 调用者: 未指定\n- 被调用者: [is_vmalloc_addr, pfn_to_gfn, vmalloc_to_pfn, virt_to_gfn, gnttab_grant_foreign_access, xenbus_dev_fatal, gnttab_end_foreign_access_ref]\n\n2. 函数名: is_vmalloc_addr\n- 参数: [void *vaddr]\n- 调用者: xenbus_grant_ring\n- 被调用者: 未指定\n\n3. 函数名: pfn_to_gfn\n- 参数: [unsigned long pfn]\n- 调用者: xenbus_grant_ring\n- 被调用者: 未指定\n\n4. 函数名: vmalloc_to_pfn\n- 参数: [void *vaddr]\n- 调用者: xenbus_grant_ring\n- 被调用者: 未指定\n\n5. 函数名: virt_to_gfn\n- 参数: [void *vaddr]\n- 调用者: xenbus_grant_ring\n- 被调用者: 未指定\n\n6. 函数名: gnttab_grant_foreign_access\n- 参数: [domid_t domid, unsigned long gfn, int readonly]\n- 调用者: xenbus_grant_ring\n- 被调用者: 未指定\n\n7. 函数名: xenbus_dev_fatal\n- 参数: [struct xenbus_device *dev, int err, const char *fmt, ...]\n- 调用者: xenbus_grant_ring\n- 被调用者: 未指定\n\n8. 函数名: gnttab_end_foreign_access_ref\n- 参数: [grant_ref_t ref, int readonly]\n- 调用者: xenbus_grant_ring\n- 被调用者: 未指定"
  },
  {
    "id": 3424,
    "cwe": "CWE-362",
    "cve": "CVE-2022-23042",
    "purpose": "Code purpose:\"\"\"处理网络前端队列中的接收数据包，包括响应处理、错误检查、数据填充和缓冲区管理\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"netfront在撤销后端访问权限时未正确处理竞争条件，导致恶意后端可能保持对内存页的访问权限，触发断言失败造成拒绝服务\"\"\"",
    "functions": "Functions:\n1. 函数名: xennet_poll\n- 参数: [struct napi_struct *napi, int budget]\n- 调用者: N/A (内核网络子系统调用)\n- 被调用者: [container_of, dev_alert, RING_RESPONSE_PROD_OVERFLOW, rmb, RING_COPY_RESPONSE, memset, xennet_get_responses, __skb_dequeue, __skb_queue_tail, __skb_queue_head, xennet_set_skb_gso, xennet_set_rx_rsp_cons, skb_frag_off_set, skb_frag_size_set, xennet_fill_frags, xdp_do_flush, __skb_queue_purge, handle_incoming_queue, xennet_alloc_rx_buffers, napi_complete_done, RING_FINAL_CHECK_FOR_RESPONSES, napi_schedule]\n\n2. 函数名: container_of\n- 参数: [ptr, type, member]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n3. 函数名: dev_alert\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n4. 函数名: RING_RESPONSE_PROD_OVERFLOW\n- 参数: [ring, prod]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n5. 函数名: rmb\n- 参数: []\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n6. 函数名: RING_COPY_RESPONSE\n- 参数: [ring, idx, dst]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n7. 函数名: memset\n- 参数: [s, c, n]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n8. 函数名: xennet_get_responses\n- 参数: [struct netfront_queue *queue, struct netfront_rx_info *rinfo, RING_IDX rp, struct sk_buff_head *tmpq, bool *need_xdp_flush]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n9. 函数名: __skb_dequeue\n- 参数: [list]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n10. 函数名: __skb_queue_tail\n- 参数: [list, newsk]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n11. 函数名: __skb_queue_head\n- 参数: [list, newsk]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n12. 函数名: xennet_set_skb_gso\n- 参数: [struct sk_buff *skb, struct xen_netif_extra_info *gso]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n13. 函数名: xennet_set_rx_rsp_cons\n- 参数: [struct netfront_queue *queue, RING_IDX val]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n14. 函数名: skb_frag_off_set\n- 参数: [frag, val]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n15. 函数名: skb_frag_size_set\n- 参数: [frag, val]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n16. 函数名: xennet_fill_frags\n- 参数: [struct netfront_queue *queue, struct sk_buff *skb, struct sk_buff_head *tmpq]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n17. 函数名: xdp_do_flush\n- 参数: []\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n18. 函数名: __skb_queue_purge\n- 参数: [list]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n19. 函数名: handle_incoming_queue\n- 参数: [struct netfront_queue *queue, struct sk_buff_head *rxq]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n20. 函数名: xennet_alloc_rx_buffers\n- 参数: [struct netfront_queue *queue]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n21. 函数名: napi_complete_done\n- 参数: [struct napi_struct *n, int work_done]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n22. 函数名: RING_FINAL_CHECK_FOR_RESPONSES\n- 参数: [ring, more_to_do]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n23. 函数名: napi_schedule\n- 参数: [struct napi_struct *n]\n- 调用者: xennet_poll\n- 被调用者: N/A"
  },
  {
    "id": 3425,
    "cwe": "CWE-362",
    "cve": "CVE-2022-23042",
    "purpose": "Code purpose:\"\"\"处理网络前端队列中的接收响应，包括数据包处理、XDP程序执行和授权引用管理\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"netfront在撤销访问权限时未正确处理竞争条件，导致恶意后端可能保持对内存页的访问，且当撤销失败时会触发BUG_ON()造成拒绝服务\"\"\"",
    "functions": "Functions:\n1. 函数名: xennet_get_responses\n- 参数: [struct netfront_queue *queue, struct netfront_rx_info *rinfo, RING_IDX rp, struct sk_buff_head *list, bool *need_xdp_flush]\n- 调用者: N/A (顶级函数)\n- 被调用者: [xennet_get_rx_skb, xennet_get_rx_ref, xennet_get_extras, dev_warn, xennet_move_rx_slot, gnttab_end_foreign_access_ref, gnttab_release_grant_reference, rcu_read_lock, rcu_dereference, xennet_run_xdp, rcu_read_unlock, __skb_queue_tail, RING_COPY_RESPONSE, xennet_set_rx_rsp_cons]\n\n2. 函数名: xennet_get_rx_skb\n- 参数: [struct netfront_queue *queue, RING_IDX cons]\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n3. 函数名: xennet_get_rx_ref\n- 参数: [struct netfront_queue *queue, RING_IDX cons]\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n4. 函数名: xennet_get_extras\n- 参数: [struct netfront_queue *queue, struct xen_netif_extra_info *extras, RING_IDX rp]\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n5. 函数名: dev_warn\n- 参数: [struct device *dev, const char *fmt, ...]\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n6. 函数名: xennet_move_rx_slot\n- 参数: [struct netfront_queue *queue, struct sk_buff *skb, grant_ref_t ref]\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n7. 函数名: gnttab_end_foreign_access_ref\n- 参数: [grant_ref_t ref, int readonly]\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n8. 函数名: gnttab_release_grant_reference\n- 参数: [grant_ref_t *head, grant_ref_t ref]\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n9. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n10. 函数名: rcu_dereference\n- 参数: [struct bpf_prog *xdp_prog]\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n11. 函数名: xennet_run_xdp\n- 参数: [struct netfront_queue *queue, struct page *page, struct xen_netif_rx_response *rx, struct bpf_prog *xdp_prog, struct xdp_buff *xdp, bool *need_xdp_flush]\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n12. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n13. 函数名: __skb_queue_tail\n- 参数: [struct sk_buff_head *list, struct sk_buff *skb]\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n14. 函数名: RING_COPY_RESPONSE\n- 参数: [struct netfront_queue *queue, RING_IDX cons, struct xen_netif_rx_response *rx_local]\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n15. 函数名: xennet_set_rx_rsp_cons\n- 参数: [struct netfront_queue *queue, RING_IDX cons]\n- 调用者: xennet_get_responses\n- 被调用者: []"
  },
  {
    "id": 3426,
    "cwe": "CWE-362",
    "cve": "CVE-2022-23042",
    "purpose": "Code purpose:\"\"\"为Xen虚拟化环境中的网络前端设备(netfront)设置发送和接收环形缓冲区，并处理相关授权和事件通道的初始化工作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"netfront在撤销后端访问权限时存在竞态条件，未能正确同步释放数据页和撤销授权访问，导致后端可能保持对内存页的访问权限\"\"\"",
    "functions": "Functions:\n1. 函数名: setup_netfront\n- 参数: [struct xenbus_device *dev, struct netfront_queue *queue, unsigned int feature_split_evtchn]\n- 调用者: 未显示\n- 被调用者: [get_zeroed_page, SHARED_RING_INIT, FRONT_RING_INIT, xenbus_grant_ring, setup_netfront_split, setup_netfront_single, gnttab_end_foreign_access_ref, free_page, xenbus_dev_fatal]\n\n2. 函数名: get_zeroed_page\n- 参数: [GFP_NOIO | __GFP_HIGH]\n- 调用者: setup_netfront\n- 被调用者: 未显示\n\n3. 函数名: SHARED_RING_INIT\n- 参数: [txs/rxs]\n- 调用者: setup_netfront\n- 被调用者: 未显示\n\n4. 函数名: FRONT_RING_INIT\n- 参数: [&queue->tx/&queue->rx, txs/rxs, XEN_PAGE_SIZE]\n- 调用者: setup_netfront\n- 被调用者: 未显示\n\n5. 函数名: xenbus_grant_ring\n- 参数: [dev, txs/rxs, 1, &gref]\n- 调用者: setup_netfront\n- 被调用者: 未显示\n\n6. 函数名: setup_netfront_split\n- 参数: [queue]\n- 调用者: setup_netfront\n- 被调用者: 未显示\n\n7. 函数名: setup_netfront_single\n- 参数: [queue]\n- 调用者: setup_netfront\n- 被调用者: 未显示\n\n8. 函数名: gnttab_end_foreign_access_ref\n- 参数: [queue->rx_ring_ref/queue->tx_ring_ref, 0]\n- 调用者: setup_netfront\n- 被调用者: 未显示\n\n9. 函数名: free_page\n- 参数: [(unsigned long)rxs/(unsigned long)txs]\n- 调用者: setup_netfront\n- 被调用者: 未显示\n\n10. 函数名: xenbus_dev_fatal\n- 参数: [dev, err, \"allocating tx/rx ring page\"]\n- 调用者: setup_netfront\n- 被调用者: 未显示"
  },
  {
    "id": 3480,
    "cwe": "CWE-362",
    "cve": "CVE-2022-2590",
    "purpose": "Code purpose:\"\"\"处理内存页错误并管理写时复制(COW)操作，包括设置错误标志、处理错误返回和更新内存映射状态\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核内存子系统在处理私有只读共享内存映射的写时复制(COW)中断时存在竞态条件，导致本地低权限用户可获取对只读内存映射的写入权限\"\"\"",
    "functions": "Functions:\n1. 函数名: faultin_page\n- 参数: [struct vm_area_struct *vma, unsigned long address, unsigned int *flags, bool unshare, int *locked]\n- 调用者: 未明确显示（通常是内存管理相关的调用者）\n- 被调用者: [handle_mm_fault, vm_fault_to_errno, WARN_ON_ONCE]"
  },
  {
    "id": 3481,
    "cwe": "CWE-362",
    "cve": "CVE-2022-2590",
    "purpose": "Code purpose:\"\"\"处理设备映射页面的跟踪操作，包括权限检查、页面获取和引用计数管理\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核内存子系统在处理私有只读共享内存映射的写时复制(COW)破坏时存在竞态条件，导致本地低权限用户可获取对只读内存映射的写入权限。\"\"\"",
    "functions": "Functions:\n1. 函数名: follow_devmap_pmd\n- 参数: [struct vm_area_struct *vma, unsigned long addr, pmd_t *pmd, int flags, struct dev_pagemap **pgmap]\n- 调用者: 未明确（由内核内存管理子系统调用）\n- 被调用者: [pmd_pfn, pmd_lockptr, assert_spin_locked, WARN_ONCE, WARN_ON_ONCE, pmd_write, pmd_present, pmd_devmap, touch_pmd, ERR_PTR, get_dev_pagemap, pfn_to_page, try_grab_page]\n\n2. 函数名: pmd_pfn\n- 参数: [pmd_t *pmd]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n3. 函数名: pmd_lockptr\n- 参数: [struct mm_struct *mm, pmd_t *pmd]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n4. 函数名: assert_spin_locked\n- 参数: [spinlock_t *lock]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n5. 函数名: WARN_ONCE\n- 参数: [bool condition, const char *fmt]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n6. 函数名: WARN_ON_ONCE\n- 参数: [bool condition]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n7. 函数名: pmd_write\n- 参数: [pmd_t *pmd]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n8. 函数名: pmd_present\n- 参数: [pmd_t *pmd]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n9. 函数名: pmd_devmap\n- 参数: [pmd_t *pmd]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n10. 函数名: touch_pmd\n- 参数: [struct vm_area_struct *vma, unsigned long addr, pmd_t *pmd, bool write]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n11. 函数名: ERR_PTR\n- 参数: [long error]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n12. 函数名: get_dev_pagemap\n- 参数: [unsigned long pfn, struct dev_pagemap *pgmap]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n13. 函数名: pfn_to_page\n- 参数: [unsigned long pfn]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n14. 函数名: try_grab_page\n- 参数: [struct page *page, int flags]\n- 调用者: follow_devmap_pmd\n- 被调用者: []"
  },
  {
    "id": 3482,
    "cwe": "CWE-362",
    "cve": "CVE-2022-2590",
    "purpose": "Code purpose:\"\"\"处理对透明大页(THP)的页表项(PMD)的跟踪操作，包括权限检查、NUMA提示处理以及页面的获取\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核内存子系统在处理私有只读共享内存映射的写时复制(COW)破坏时存在竞态条件，导致本地低权限用户可获取对只读内存映射的写入权限\"\"\"",
    "functions": "Functions:\n1. 函数名: follow_trans_huge_pmd\n- 参数: [vma, addr, pmd, flags]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [assert_spin_locked, can_follow_write_pmd, is_huge_zero_pmd, pmd_protnone, pmd_page, pmd_write, gup_must_unshare, try_grab_page, touch_pmd]\n\n2. 函数名: assert_spin_locked\n- 参数: [pmd_lockptr(mm, pmd)]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n3. 函数名: can_follow_write_pmd\n- 参数: [*pmd, flags]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n4. 函数名: is_huge_zero_pmd\n- 参数: [*pmd]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n5. 函数名: pmd_protnone\n- 参数: [*pmd]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n6. 函数名: pmd_page\n- 参数: [*pmd]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n7. 函数名: pmd_write\n- 参数: [*pmd]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n8. 函数名: gup_must_unshare\n- 参数: [flags, page]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n9. 函数名: try_grab_page\n- 参数: [page, flags]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n10. 函数名: touch_pmd\n- 参数: [vma, addr, pmd, flags & FOLL_WRITE]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []"
  },
  {
    "id": 3505,
    "cwe": "CWE-362",
    "cve": "CVE-2022-28796",
    "purpose": "Code purpose:\"\"\"该代码片段用于在Linux内核的jbd2日志系统中实现更新操作的锁定机制，通过屏障计数和等待条件来确保事务处理的同步与互斥。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在jbd2_journal_lock_updates函数中，由于未正确处理事务(transaction_t)的竞争条件，导致在等待更新完成时可能出现use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: jbd2_journal_lock_updates\n- 参数: [journal_t *journal]\n- 调用者: 未指定\n- 被调用者: [jbd2_might_wait_for_commit, atomic_read, write_lock, write_unlock, wait_event, jbd2_journal_wait_updates, mutex_lock]\n\n2. 函数名: jbd2_might_wait_for_commit\n- 参数: [journal_t *journal]\n- 调用者: jbd2_journal_lock_updates\n- 被调用者: 未指定\n\n3. 函数名: atomic_read\n- 参数: [atomic_t *v] (推断为 &journal->j_reserved_credits)\n- 调用者: jbd2_journal_lock_updates\n- 被调用者: 未指定\n\n4. 函数名: write_lock\n- 参数: [rwlock_t *lock] (具体为 &journal->j_state_lock)\n- 调用者: jbd2_journal_lock_updates\n- 被调用者: 未指定\n\n5. 函数名: write_unlock\n- 参数: [rwlock_t *lock] (具体为 &journal->j_state_lock)\n- 调用者: jbd2_journal_lock_updates\n- 被调用者: 未指定\n\n6. 函数名: wait_event\n- 参数: [wait_queue_head_t *q, condition] (具体为 journal->j_wait_reserved 和 atomic_read(&journal->j_reserved_credits) == 0)\n- 调用者: jbd2_journal_lock_updates\n- 被调用者: 未指定\n\n7. 函数名: jbd2_journal_wait_updates\n- 参数: [journal_t *journal]\n- 调用者: jbd2_journal_lock_updates\n- 被调用者: 未指定\n\n8. 函数名: mutex_lock\n- 参数: [struct mutex *lock] (具体为 &journal->j_barrier)\n- 调用者: jbd2_journal_lock_updates\n- 被调用者: 未指定"
  },
  {
    "id": 3506,
    "cwe": "CWE-362",
    "cve": "CVE-2022-28796",
    "purpose": "Code purpose:\"\"\"等待当前正在运行的日志事务完成所有更新操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在释放commit_transaction后，由于竞争条件导致在while循环中仍可能访问已释放的commit_transaction指针，造成use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: jbd2_journal_wait_updates\n- 参数: [journal]\n- 调用者: N/A\n- 被调用者: [atomic_read, spin_lock, DEFINE_WAIT, prepare_to_wait, spin_unlock, write_unlock, schedule, write_lock, finish_wait]\n\n2. 函数名: atomic_read\n- 参数: [&commit_transaction->t_updates]\n- 调用者: jbd2_journal_wait_updates\n- 被调用者: N/A\n\n3. 函数名: spin_lock\n- 参数: [&commit_transaction->t_handle_lock]\n- 调用者: jbd2_journal_wait_updates\n- 被调用者: N/A\n\n4. 函数名: DEFINE_WAIT\n- 参数: [wait]\n- 调用者: jbd2_journal_wait_updates\n- 被调用者: N/A\n\n5. 函数名: prepare_to_wait\n- 参数: [&journal->j_wait_updates, &wait, TASK_UNINTERRUPTIBLE]\n- 调用者: jbd2_journal_wait_updates\n- 被调用者: N/A\n\n6. 函数名: spin_unlock\n- 参数: [&commit_transaction->t_handle_lock]\n- 调用者: jbd2_journal_wait_updates\n- 被调用者: N/A\n\n7. 函数名: write_unlock\n- 参数: [&journal->j_state_lock]\n- 调用者: jbd2_journal_wait_updates\n- 被调用者: N/A\n\n8. 函数名: schedule\n- 参数: []\n- 调用者: jbd2_journal_wait_updates\n- 被调用者: N/A\n\n9. 函数名: write_lock\n- 参数: [&journal->j_state_lock]\n- 调用者: jbd2_journal_wait_updates\n- 被调用者: N/A\n\n10. 函数名: finish_wait\n- 参数: [&journal->j_wait_updates, &wait]\n- 调用者: jbd2_journal_wait_updates\n- 被调用者: N/A"
  },
  {
    "id": 3522,
    "cwe": "CWE-362",
    "cve": "CVE-2022-29582",
    "purpose": "Code purpose:\"\"\"处理io_uring中的超时请求，通过比较事件序列号来决定是否触发超时操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于io_uring超时处理中存在竞态条件，导致在时间序列比较和超时请求处理过程中可能发生use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: io_flush_timeouts\n- 参数: [ctx]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [atomic_read, spin_lock_irq, list_empty, list_first_entry, io_is_timeout_noseq, list_del_init, io_kill_timeout, spin_unlock_irq]\n\n2. 函数名: atomic_read\n- 参数: [&ctx->cq_timeouts]\n- 调用者: io_flush_timeouts\n- 被调用者: []\n\n3. 函数名: spin_lock_irq\n- 参数: [&ctx->timeout_lock]\n- 调用者: io_flush_timeouts\n- 被调用者: []\n\n4. 函数名: list_empty\n- 参数: [&ctx->timeout_list]\n- 调用者: io_flush_timeouts\n- 被调用者: []\n\n5. 函数名: list_first_entry\n- 参数: [&ctx->timeout_list, struct io_kiocb, timeout.list]\n- 调用者: io_flush_timeouts\n- 被调用者: []\n\n6. 函数名: io_is_timeout_noseq\n- 参数: [req]\n- 调用者: io_flush_timeouts\n- 被调用者: []\n\n7. 函数名: list_del_init\n- 参数: [&req->timeout.list]\n- 调用者: io_flush_timeouts\n- 被调用者: []\n\n8. 函数名: io_kill_timeout\n- 参数: [req, 0]\n- 调用者: io_flush_timeouts\n- 被调用者: []\n\n9. 函数名: spin_unlock_irq\n- 参数: [&ctx->timeout_lock]\n- 调用者: io_flush_timeouts\n- 被调用者: []"
  },
  {
    "id": 3523,
    "cwe": "CWE-362",
    "cve": "CVE-2022-29582",
    "purpose": "Code purpose:\"\"\"处理io_uring操作中的超时请求准备，包括参数验证、数据结构初始化和超时计时器设置\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于io_uring超时处理中存在竞态条件，导致在特定情况下可能发生释放后使用(UAF)漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: io_timeout_prep\n- 参数: [struct io_kiocb *req, const struct io_uring_sqe *sqe, bool is_timeout_link]\n- 调用者: 未明确显示（通常是io_uring相关操作调用）\n- 被调用者: [READ_ONCE, hweight32, INIT_LIST_HEAD, WARN_ON_ONCE, req_has_async_data, io_alloc_async_data, get_timespec64, io_translate_timeout_mode, hrtimer_init, io_timeout_get_clock]\n\n2. 函数名: READ_ONCE\n- 参数: [sqe->off, sqe->timeout_flags]\n- 调用者: io_timeout_prep\n- 被调用者: []\n\n3. 函数名: hweight32\n- 参数: [flags & IORING_TIMEOUT_CLOCK_MASK]\n- 调用者: io_timeout_prep\n- 被调用者: []\n\n4. 函数名: INIT_LIST_HEAD\n- 参数: [&req->timeout.list]\n- 调用者: io_timeout_prep\n- 被调用者: []\n\n5. 函数名: WARN_ON_ONCE\n- 参数: [req_has_async_data(req)]\n- 调用者: io_timeout_prep\n- 被调用者: []\n\n6. 函数名: req_has_async_data\n- 参数: [req]\n- 调用者: WARN_ON_ONCE\n- 被调用者: []\n\n7. 函数名: io_alloc_async_data\n- 参数: [req]\n- 调用者: io_timeout_prep\n- 被调用者: []\n\n8. 函数名: get_timespec64\n- 参数: [&data->ts, u64_to_user_ptr(sqe->addr)]\n- 调用者: io_timeout_prep\n- 被调用者: []\n\n9. 函数名: io_translate_timeout_mode\n- 参数: [flags]\n- 调用者: io_timeout_prep\n- 被调用者: []\n\n10. 函数名: hrtimer_init\n- 参数: [&data->timer, io_timeout_get_clock(data), data->mode]\n- 调用者: io_timeout_prep\n- 被调用者: []\n\n11. 函数名: io_timeout_get_clock\n- 参数: [data]\n- 调用者: hrtimer_init\n- 被调用者: []"
  },
  {
    "id": 3524,
    "cwe": "CWE-362",
    "cve": "CVE-2022-2959",
    "purpose": "Code purpose:\"\"\"该代码用于调整管道环形缓冲区的大小，包括分配新缓冲区、复制旧数据以及更新管道状态。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于pipe_resize_ring()函数在处理管道缓冲区时缺少适当的锁机制，导致存在竞争条件漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: pipe_resize_ring\n- 参数: [struct pipe_inode_info *pipe, unsigned int nr_slots]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [pipe_occupancy, kcalloc, memcpy, kfree, wake_up_interruptible]\n\n2. 函数名: pipe_occupancy\n- 参数: [pipe->head, pipe->tail]\n- 调用者: pipe_resize_ring\n- 被调用者: []\n\n3. 函数名: kcalloc\n- 参数: [nr_slots, sizeof(*bufs), GFP_KERNEL_ACCOUNT | __GFP_NOWARN]\n- 调用者: pipe_resize_ring\n- 被调用者: []\n\n4. 函数名: memcpy\n- 参数: [bufs, pipe->bufs + t, n * sizeof(struct pipe_buffer)] 或 [bufs + tsize, pipe->bufs, h * sizeof(struct pipe_buffer)] 或 [bufs, pipe->bufs + t, tsize * sizeof(struct pipe_buffer)]\n- 调用者: pipe_resize_ring\n- 被调用者: []\n\n5. 函数名: kfree\n- 参数: [pipe->bufs]\n- 调用者: pipe_resize_ring\n- 被调用者: []\n\n6. 函数名: wake_up_interruptible\n- 参数: [&pipe->wr_wait]\n- 调用者: pipe_resize_ring\n- 被调用者: []"
  },
  {
    "id": 3542,
    "cwe": "CWE-362",
    "cve": "CVE-2022-3028",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的XFRM子系统中处理PF_KEY套接字的注册请求，包括验证消息类型、更新注册状态、探测算法并广播支持信息。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于xfrm_probe_algs()函数在并发调用时存在竞态条件，可能导致越界写入或内核堆内存泄露\"\"\"",
    "functions": "Functions:\n1. 函数名: pfkey_register\n- 参数: [sk, skb, hdr, ext_hdrs]\n- 调用者: N/A (顶层函数)\n- 被调用者: [pfkey_sk, xfrm_probe_algs, compose_sadb_supported, pfkey_broadcast, sock_net]\n\n2. 函数名: pfkey_sk\n- 参数: [sk]\n- 调用者: pfkey_register\n- 被调用者: []\n\n3. 函数名: xfrm_probe_algs\n- 参数: []\n- 调用者: pfkey_register\n- 被调用者: []\n\n4. 函数名: compose_sadb_supported\n- 参数: [hdr, GFP_KERNEL | __GFP_ZERO]\n- 调用者: pfkey_register\n- 被调用者: []\n\n5. 函数名: pfkey_broadcast\n- 参数: [supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk, sock_net(sk)]\n- 调用者: pfkey_register\n- 被调用者: []\n\n6. 函数名: sock_net\n- 参数: [sk]\n- 调用者: pfkey_register\n- 被调用者: []"
  },
  {
    "id": 3603,
    "cwe": "CWE-362",
    "cve": "CVE-2022-3521",
    "purpose": "Code purpose:\"\"\"该代码实现了KCM (Kernel Connection Multiplexor)套接字释放功能，包括清理写队列、停止传输工作、取消相关psock绑定等操作，确保套接字资源被安全释放。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在kcm_release函数中存在竞态条件，由于对kcm_sock结构的操作缺乏适当的同步保护，导致在释放资源时可能与其他线程（如tx_work）产生竞争。\"\"\"",
    "functions": "Functions:\n1. 函数名: kcm_release\n- 参数: [struct socket *sock]\n- 调用者: 无（系统调用或外部调用）\n- 被调用者: [kcm_sk, sock_orphan, kfree_skb, lock_sock, __skb_queue_purge, release_sock, spin_lock_bh, list_del, spin_unlock_bh, cancel_work_sync, kcm_abort_tx_psock, unreserve_psock, kcm_done]\n\n2. 函数名: kcm_sk\n- 参数: [struct sock *sk]\n- 调用者: kcm_release\n- 被调用者: 无\n\n3. 函数名: sock_orphan\n- 参数: [struct sock *sk]\n- 调用者: kcm_release\n- 被调用者: 无\n\n4. 函数名: kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: kcm_release\n- 被调用者: 无\n\n5. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: kcm_release\n- 被调用者: 无\n\n6. 函数名: __skb_queue_purge\n- 参数: [struct sk_buff_head *list]\n- 调用者: kcm_release\n- 被调用者: 无\n\n7. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: kcm_release\n- 被调用者: 无\n\n8. 函数名: spin_lock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: kcm_release\n- 被调用者: 无\n\n9. 函数名: list_del\n- 参数: [struct list_head *entry]\n- 调用者: kcm_release\n- 被调用者: 无\n\n10. 函数名: spin_unlock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: kcm_release\n- 被调用者: 无\n\n11. 函数名: cancel_work_sync\n- 参数: [struct work_struct *work]\n- 调用者: kcm_release\n- 被调用者: 无\n\n12. 函数名: kcm_abort_tx_psock\n- 参数: [struct kcm_psock *psock, int err, bool wakeup_kcm]\n- 调用者: kcm_release\n- 被调用者: 无\n\n13. 函数名: unreserve_psock\n- 参数: [struct kcm_sock *kcm]\n- 调用者: kcm_release\n- 被调用者: 无\n\n14. 函数名: kcm_done\n- 参数: [struct kcm_sock *kcm]\n- 调用者: kcm_release\n- 被调用者: 无"
  },
  {
    "id": 3636,
    "cwe": "CWE-362",
    "cve": "CVE-2022-3564",
    "purpose": "Code purpose:\"\"\"处理蓝牙L2CAP协议中接收到的数据帧，包括帧的重新组装、序列号验证、错误处理以及状态管理，同时处理可能出现的竞争条件问题。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在蓝牙L2CAP协议处理过程中，当重组SDU数据时存在释放后重用(UAF)问题，导致使用已被释放的内存。\"\"\"",
    "functions": "Functions:\n1. 函数名: l2cap_rx_state_recv\n- 参数: [chan, control, skb, event]\n- 调用者: 未显示\n- 被调用者: [l2cap_classify_txseq, l2cap_pass_to_tx, __next_seq, l2cap_reassemble_sdu, test_and_clear_bit, l2cap_retransmit_all, l2cap_ertm_send, test_bit, l2cap_send_ack, skb_queue_tail, skb_queue_len, clear_bit, l2cap_seq_list_clear, l2cap_send_srej, l2cap_send_disconn_req, __chan_is_moving, l2cap_send_i_or_rr_or_rnr, __set_retrans_timer, set_bit, l2cap_send_rr_or_rnr, __clear_retrans_timer, l2cap_handle_rej, l2cap_handle_srej, kfree_skb]\n\n2. 函数名: l2cap_classify_txseq\n- 参数: [chan, control->txseq]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n3. 函数名: l2cap_pass_to_tx\n- 参数: [chan, control]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n4. 函数名: __next_seq\n- 参数: [chan, control->txseq]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n5. 函数名: l2cap_reassemble_sdu\n- 参数: [chan, skb, control]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n6. 函数名: test_and_clear_bit\n- 参数: [CONN_REJ_ACT, &chan->conn_state]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n7. 函数名: l2cap_retransmit_all\n- 参数: [chan, control]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n8. 函数名: l2cap_ertm_send\n- 参数: [chan]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n9. 函数名: test_bit\n- 参数: [CONN_LOCAL_BUSY, &chan->conn_state]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n10. 函数名: l2cap_send_ack\n- 参数: [chan]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n11. 函数名: skb_queue_tail\n- 参数: [&chan->srej_q, skb]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n12. 函数名: skb_queue_len\n- 参数: [&chan->srej_q]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n13. 函数名: clear_bit\n- 参数: [CONN_SREJ_ACT, &chan->conn_state]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n14. 函数名: l2cap_send_srej\n- 参数: [chan, control->txseq]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n15. 函数名: l2cap_send_disconn_req\n- 参数: [chan, ECONNRESET]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n16. 函数名: __chan_is_moving\n- 参数: [chan]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n17. 函数名: l2cap_send_i_or_rr_or_rnr\n- 参数: [chan]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n18. 函数名: __set_retrans_timer\n- 参数: [chan]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n19. 函数名: set_bit\n- 参数: [CONN_REMOTE_BUSY, &chan->conn_state], [CONN_SEND_FBIT, &chan->conn_state]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n20. 函数名: l2cap_send_rr_or_rnr\n- 参数: [chan, 0]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n21. 函数名: __clear_retrans_timer\n- 参数: [chan]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n22. 函数名: l2cap_handle_rej\n- 参数: [chan, control]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n23. 函数名: l2cap_handle_srej\n- 参数: [chan, control]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n24. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示"
  },
  {
    "id": 3637,
    "cwe": "CWE-362",
    "cve": "CVE-2022-3564",
    "purpose": "Code purpose:\"\"\"该代码片段实现了蓝牙L2CAP协议中接收数据流并进行重组的功能，处理数据包的顺序验证和缓冲区管理。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在释放skb后仍可能通过chan->sdu引用导致use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: l2cap_stream_rx\n- 参数: [chan, control, skb]\n- 调用者: 未显示（外部调用）\n- 被调用者: [l2cap_classify_txseq, l2cap_pass_to_tx, __next_seq, l2cap_reassemble_sdu, kfree_skb]\n\n2. 函数名: l2cap_classify_txseq\n- 参数: [chan, control->txseq]\n- 调用者: l2cap_stream_rx\n- 被调用者: 未显示\n\n3. 函数名: l2cap_pass_to_tx\n- 参数: [chan, control]\n- 调用者: l2cap_stream_rx\n- 被调用者: 未显示\n\n4. 函数名: __next_seq\n- 参数: [chan, chan->buffer_seq]\n- 调用者: l2cap_stream_rx\n- 被调用者: 未显示\n\n5. 函数名: l2cap_reassemble_sdu\n- 参数: [chan, skb, control]\n- 调用者: l2cap_stream_rx\n- 被调用者: 未显示\n\n6. 函数名: kfree_skb\n- 参数: [chan->sdu] 或 [skb]\n- 调用者: l2cap_stream_rx\n- 被调用者: 未显示"
  },
  {
    "id": 3641,
    "cwe": "CWE-362",
    "cve": "CVE-2022-3566",
    "purpose": "Code purpose:\"\"\"该代码实现了TCP套接字选项的获取功能，根据不同的协议级别调用相应的处理函数。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于tcp_getsockopt函数在处理socket选项时未正确同步多线程访问，导致竞争条件(CWE-362)的发生。\"\"\"",
    "functions": "Functions:\n1. 函数名: tcp_getsockopt\n- 参数: [struct sock *sk, int level, int optname, char __user *optval, int __user *optlen]\n- 调用者: 未指定（由内核TCP处理流程调用）\n- 被调用者: [inet_csk, icsk->icsk_af_ops->getsockopt, do_tcp_getsockopt, USER_SOCKPTR]\n\n2. 函数名: inet_csk\n- 参数: [struct sock *sk]\n- 调用者: tcp_getsockopt\n- 被调用者: 未指定（内核内部函数）\n\n3. 函数名: icsk_af_ops->getsockopt\n- 参数: [struct sock *sk, int level, int optname, char __user *optval, int __user *optlen]\n- 调用者: tcp_getsockopt\n- 被调用者: 未指定（函数指针，具体实现取决于协议族）\n\n4. 函数名: do_tcp_getsockopt\n- 参数: [struct sock *sk, int level, int optname, USER_SOCKPTR(optval), USER_SOCKPTR(optlen)]\n- 调用者: tcp_getsockopt\n- 被调用者: 未指定（内核内部函数）\n\n5. 函数名: USER_SOCKPTR\n- 参数: [指针类型参数]\n- 调用者: tcp_getsockopt\n- 被调用者: 未指定（宏/内联函数）"
  },
  {
    "id": 3642,
    "cwe": "CWE-362",
    "cve": "CVE-2022-3566",
    "purpose": "Code purpose:\"\"\"处理TCP套接字选项的设置，根据不同的协议级别选择相应的设置函数\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于tcp_setsockopt函数在处理套接字选项时缺乏适当的同步机制，导致多个线程同时访问时可能引发竞争条件漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: tcp_setsockopt\n- 参数: [struct sock *sk, int level, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: 未显示（由内核TCP处理逻辑调用）\n- 被调用者: [inet_csk, icsk->icsk_af_ops->setsockopt, do_tcp_setsockopt]\n\n2. 函数名: inet_csk\n- 参数: [struct sock *sk]\n- 调用者: tcp_setsockopt\n- 被调用者: 未显示（返回const struct inet_connection_sock *）\n\n3. 函数名: icsk_af_ops->setsockopt\n- 参数: [struct sock *sk, int level, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: tcp_setsockopt\n- 被调用者: 未显示（函数指针调用）\n\n4. 函数名: do_tcp_setsockopt\n- 参数: [struct sock *sk, int level, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: tcp_setsockopt\n- 被调用者: 未显示"
  },
  {
    "id": 3643,
    "cwe": "CWE-362",
    "cve": "CVE-2022-3566",
    "purpose": "Code purpose:\"\"\"处理IPv6套接字选项的设置操作，包括地址转换、多播控制、流量标签管理等网络配置功能\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理TCP套接字选项时，由于缺乏适当的同步机制，导致在多线程环境下可能出现竞争条件漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: do_ipv6_setsockopt\n- 参数: [struct sock *sk, int level, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: N/A (顶层函数)\n- 被调用者: [sock_net, sockptr_is_null, copy_from_sockptr, ip6_mroute_opt, ip6_mroute_setsockopt, rtnl_lock, sockopt_lock_sock, udp_sk, inet_csk, sk_refcnt_debug_dec, sock_prot_inuse_add, WRITE_ONCE, tcp_sync_mss, module_put, inet6_cleanup_sock, sk_refcnt_debug_inc, ipv6_set_opt_hdr, sk_dev_equal_l3scope, sock_kmalloc, copy_from_sockptr, ip6_datagram_send_ctl, ipv6_update_options, txopt_put, dev_get_by_index, dev_put, dev_get_by_index_rcu, l3mdev_master_ifindex_rcu, ipv6_sock_mc_join, ipv6_sock_mc_drop, ipv6_sock_ac_join, ipv6_sock_ac_drop, compat_ipv6_mcast_join_leave, ipv6_mcast_join_leave, do_ipv6_mcast_group_source, compat_ipv6_set_mcast_msfilter, ipv6_set_mcast_msfilter, ip6_ra_control, __ip6_sock_set_addr_preferences, sockopt_release_sock, rtnl_unlock]\n\n2. 函数名: setsockopt_needs_rtnl\n- 参数: [int optname]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n3. 函数名: ip6_mroute_opt\n- 参数: [int optname]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n4. 函数名: ip6_mroute_setsockopt\n- 参数: [struct sock *sk, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n5. 函数名: ipv6_set_opt_hdr\n- 参数: [struct sock *sk, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n6. 函数名: ip6_datagram_send_ctl\n- 参数: [struct net *net, struct sock *sk, struct msghdr *msg, struct flowi6 *fl6, struct ipcm6_cookie *ipc6]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n7. 函数名: ipv6_update_options\n- 参数: [struct sock *sk, struct ipv6_txoptions *opt]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n8. 函数名: ipv6_sock_mc_join\n- 参数: [struct sock *sk, int ifindex, struct in6_addr *addr]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n9. 函数名: ipv6_sock_mc_drop\n- 参数: [struct sock *sk, int ifindex, struct in6_addr *addr]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n10. 函数名: ipv6_sock_ac_join\n- 参数: [struct sock *sk, int ifindex, struct in6_addr *addr]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n11. 函数名: ipv6_sock_ac_drop\n- 参数: [struct sock *sk, int ifindex, struct in6_addr *addr]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n12. 函数名: compat_ipv6_mcast_join_leave\n- 参数: [struct sock *sk, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n13. 函数名: ipv6_mcast_join_leave\n- 参数: [struct sock *sk, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n14. 函数名: do_ipv6_mcast_group_source\n- 参数: [struct sock *sk, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n15. 函数名: compat_ipv6_set_mcast_msfilter\n- 参数: [struct sock *sk, sockptr_t optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n16. 函数名: ipv6_set_mcast_msfilter\n- 参数: [struct sock *sk, sockptr_t optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n17. 函数名: ip6_ra_control\n- 参数: [struct sock *sk, int val]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n18. 函数名: __ip6_sock_set_addr_preferences\n- 参数: [struct sock *sk, int val]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n19. 函数名: xfrm_user_policy\n- 参数: [struct sock *sk, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n20. 函数名: ipv6_flowlabel_opt\n- 参数: [struct sock *sk, sockptr_t optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []"
  },
  {
    "id": 3644,
    "cwe": "CWE-362",
    "cve": "CVE-2022-3566",
    "purpose": "Code purpose:\"\"\"该代码实现了IPv6环境下TCP连接的建立过程，包括地址验证、流标签处理、连接状态管理以及与IPv4的兼容性处理等功能。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理TCP套接字选项(tcp_getsockopt/tcp_setsockopt)时存在竞态条件，多个线程可能同时访问和修改共享资源而缺乏适当的同步机制\"\"\"",
    "functions": "Functions:\n1. 函数名: tcp_v6_connect\n- 参数: [sk, uaddr, addr_len]\n- 调用者: 无（顶层函数）\n- 被调用者: [inet_csk, tcp_inet6_sk, inet_sk, tcp_sk, sock_net, memset, IP6_ECN_flow_init, fl6_sock_lookup, fl6_sock_release, ipv6_addr_any, ipv6_addr_v4mapped, ipv6_addr_set_v4mapped, ipv6_addr_type, sk_dev_equal_l3scope, ipv6_addr_equal, WRITE_ONCE, ipv6_only_sock, tcp_v4_connect, mptcpv6_handle_mapped, rcu_dereference_protected, fl6_update_dst, security_sk_classify_flow, ip6_dst_lookup_flow, inet_bhashfn_portaddr, inet_bhash2_update_saddr, ip6_dst_store, tcp_set_state, inet6_hash_connect, sk_set_txhash, secure_tcpv6_seq, secure_tcpv6_ts_off, tcp_fastopen_defer_connect, tcp_connect]\n\n2. 函数名: inet_csk\n- 参数: [sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n3. 函数名: tcp_inet6_sk\n- 参数: [sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n4. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n5. 函数名: tcp_sk\n- 参数: [sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n6. 函数名: sock_net\n- 参数: [sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n7. 函数名: IP6_ECN_flow_init\n- 参数: [fl6.flowlabel]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n8. 函数名: fl6_sock_lookup\n- 参数: [sk, fl6.flowlabel]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n9. 函数名: fl6_sock_release\n- 参数: [flowlabel]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n10. 函数名: ipv6_addr_any\n- 参数: [&usin->sin6_addr]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n11. 函数名: ipv6_addr_v4mapped\n- 参数: [&sk->sk_v6_rcv_saddr]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n12. 函数名: ipv6_addr_set_v4mapped\n- 参数: [htonl(INADDR_LOOPBACK), &usin->sin6_addr]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n13. 函数名: ipv6_addr_type\n- 参数: [&usin->sin6_addr]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n14. 函数名: sk_dev_equal_l3scope\n- 参数: [sk, usin->sin6_scope_id]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n15. 函数名: ipv6_addr_equal\n- 参数: [&sk->sk_v6_daddr, &usin->sin6_addr]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n16. 函数名: ipv6_only_sock\n- 参数: [sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n17. 函数名: tcp_v4_connect\n- 参数: [sk, (struct sockaddr *)&sin, sizeof(sin)]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n18. 函数名: mptcpv6_handle_mapped\n- 参数: [sk, true/false]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n19. 函数名: rcu_dereference_protected\n- 参数: [np->opt, lockdep_sock_is_held(sk)]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n20. 函数名: fl6_update_dst\n- 参数: [&fl6, opt, &final]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n21. 函数名: security_sk_classify_flow\n- 参数: [sk, flowi6_to_flowi_common(&fl6)]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n22. 函数名: ip6_dst_lookup_flow\n- 参数: [net, sk, &fl6, final_p]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n23. 函数名: inet_bhashfn_portaddr\n- 参数: [tcp_death_row->hashinfo, sk, net, inet->inet_num]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n24. 函数名: inet_bhash2_update_saddr\n- 参数: [prev_addr_hashbucket, sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n25. 函数名: ip6_dst_store\n- 参数: [sk, dst, NULL, NULL]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n26. 函数名: tcp_set_state\n- 参数: [sk, TCP_SYN_SENT/TCP_CLOSE]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n27. 函数名: inet6_hash_connect\n- 参数: [tcp_death_row, sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n28. 函数名: sk_set_txhash\n- 参数: [sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n29. 函数名: secure_tcpv6_seq\n- 参数: [np->saddr.s6_addr32, sk->sk_v6_daddr.s6_addr32, inet->inet_sport, inet->inet_dport]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n30. 函数名: secure_tcpv6_ts_off\n- 参数: [net, np->saddr.s6_addr32, sk->sk_v6_daddr.s6_addr32]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n31. 函数名: tcp_fastopen_defer_connect\n- 参数: [sk, &err]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n32. 函数名: tcp_connect\n- 参数: [sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无"
  },
  {
    "id": 3645,
    "cwe": "CWE-362",
    "cve": "CVE-2022-3567",
    "purpose": "Code purpose:\"\"\"该代码片段实现了通过socket设置选项的功能，将选项设置请求传递给底层协议处理\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于在IPv6处理程序中，setsockopt操作未正确处理并发访问导致的竞争条件问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: sock_common_setsockopt\n- 参数: [struct socket *sock, int level, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [sk->sk_prot->setsockopt]\n\n2. 函数名: setsockopt\n- 参数: [struct sock *sk, int level, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: sock_common_setsockopt\n- 被调用者: 未明确（由sk->sk_prot指向的函数实现）"
  },
  {
    "id": 3646,
    "cwe": "CWE-362",
    "cve": "CVE-2022-3567",
    "purpose": "Code purpose:\"\"\"该代码片段实现了通过socket获取选项值的功能，通过调用底层协议特定的getsockopt方法来处理用户空间的选项值和长度参数。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于在IPv6处理组件的getsockopt操作中缺乏适当的同步机制，导致在多线程环境下可能发生竞争条件。\"\"\"",
    "functions": "Functions:\n1. 函数名: sock_common_getsockopt\n- 参数: [struct socket *sock, int level, int optname, char __user *optval, int __user *optlen]\n- 调用者: 未指定（由内核其他部分调用）\n- 被调用者: [sk->sk_prot->getsockopt]\n\n2. 函数名: sk->sk_prot->getsockopt\n- 参数: [struct sock *sk, int level, int optname, char __user *optval, int __user *optlen]\n- 调用者: sock_common_getsockopt\n- 被调用者: 未指定（具体实现取决于协议类型）"
  },
  {
    "id": 3647,
    "cwe": "CWE-362",
    "cve": "CVE-2022-3567",
    "purpose": "Code purpose:\"\"\"该代码实现了IPv6套接字接受连接的功能，包括获取新连接、状态验证和连接建立\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于在IPv6处理程序中inet_accept函数存在竞态条件，当多个线程同时访问共享资源时缺乏适当的同步机制，导致状态不一致。\"\"\"",
    "functions": "Functions:\n1. 函数名: inet_accept\n- 参数: [struct socket *sock, struct socket *newsock, int flags, bool kern]\n- 调用者: 未明确（由IPv6 Handler调用）\n- 被调用者: [sk1->sk_prot->accept, lock_sock, sock_rps_record_flow, WARN_ON, sock_graft, release_sock]\n\n2. 函数名: sk1->sk_prot->accept\n- 参数: [struct sock *sk1, int flags, int *err, bool kern]\n- 调用者: inet_accept\n- 被调用者: 未明确（协议特定的accept实现）\n\n3. 函数名: lock_sock\n- 参数: [struct sock *sk2]\n- 调用者: inet_accept\n- 被调用者: 未明确（内核锁函数）\n\n4. 函数名: sock_rps_record_flow\n- 参数: [struct sock *sk2]\n- 调用者: inet_accept\n- 被调用者: 未明确（记录流信息的函数）\n\n5. 函数名: WARN_ON\n- 参数: [!(1 << sk2->sk_state) & (TCPF_ESTABLISHED | TCPF_SYN_RECV | TCPF_CLOSE_WAIT | TCPF_CLOSE)]\n- 调用者: inet_accept\n- 被调用者: 未明确（内核警告宏）\n\n6. 函数名: sock_graft\n- 参数: [struct sock *sk2, struct socket *newsock]\n- 调用者: inet_accept\n- 被调用者: 未明确（socket嫁接函数）\n\n7. 函数名: release_sock\n- 参数: [struct sock *sk2]\n- 调用者: inet_accept\n- 被调用者: 未明确（内核锁释放函数）"
  },
  {
    "id": 3648,
    "cwe": "CWE-362",
    "cve": "CVE-2022-3567",
    "purpose": "Code purpose:\"\"\"该代码片段实现了通过socket发送页面数据的核心功能，支持IPv6协议处理发送操作时的竞态条件检查\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于IPv6处理程序中的inet6_stream_ops/inet6_dgram_ops组件存在竞态条件，导致在调用sendpage时可能出现并发访问问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: inet_sendpage\n- 参数: [sock, page, offset, size, flags]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [inet_send_prepare, sock_no_sendpage]\n\n2. 函数名: inet_send_prepare\n- 参数: [sk]\n- 调用者: inet_sendpage\n- 被调用者: 未明确\n\n3. 函数名: sock_no_sendpage\n- 参数: [sock, page, offset, size, flags]\n- 调用者: inet_sendpage\n- 被调用者: 未明确\n\n4. 函数名: sendpage (通过sk->sk_prot->sendpage调用)\n- 参数: [sk, page, offset, size, flags]\n- 调用者: inet_sendpage\n- 被调用者: 未明确"
  },
  {
    "id": 3649,
    "cwe": "CWE-362",
    "cve": "CVE-2022-3567",
    "purpose": "Code purpose:\"\"\"处理IPv6数据报套接字的连接操作，包括地址验证、协议断开、BPF预处理和自动绑定检查\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于在IPv6处理程序中存在竞争条件，特别是在inet6_stream_ops/inet6_dgram_ops组件的inet_dgram_connect函数中，缺乏适当的同步机制导致的数据竞争问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: inet_dgram_connect\n- 参数: [struct socket *sock, struct sockaddr *uaddr, int addr_len, int flags]\n- 调用者: 未明确（由系统调用或其他网络协议栈代码调用）\n- 被调用者: [sk->sk_prot->disconnect, sk->sk_prot->pre_connect, inet_sk, inet_autobind, sk->sk_prot->connect]\n\n2. 函数名: disconnect\n- 参数: [struct sock *sk, int flags]\n- 调用者: sk->sk_prot->disconnect (通过函数指针调用)\n- 被调用者: 未明确\n\n3. 函数名: pre_connect\n- 参数: [struct sock *sk, struct sockaddr *uaddr, int addr_len]\n- 调用者: sk->sk_prot->pre_connect (通过函数指针调用)\n- 被调用者: 未明确\n\n4. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: inet_dgram_connect\n- 被调用者: 未明确\n\n5. 函数名: inet_autobind\n- 参数: [struct sock *sk]\n- 调用者: inet_dgram_connect\n- 被调用者: 未明确\n\n6. 函数名: connect\n- 参数: [struct sock *sk, struct sockaddr *uaddr, int addr_len]\n- 调用者: sk->sk_prot->connect (通过函数指针调用)\n- 被调用者: 未明确"
  },
  {
    "id": 3657,
    "cwe": "CWE-362",
    "cve": "CVE-2022-3623",
    "purpose": "Code purpose:\"\"\"该代码用于处理虚拟内存页的跟踪和访问，包括页表项检查、页权限验证和页获取操作，同时处理并发访问时的竞争条件问题。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在follow_page_pte函数中存在竞态条件漏洞，由于未正确处理页表项(pte)的并发访问，导致在多线程环境下可能引发安全问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: follow_page_pte\n- 参数: [vma, address, pmd, flags, pgmap]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [WARN_ON_ONCE, ERR_PTR, pmd_bad, no_page_table, pte_offset_map_lock, pte_present, pte_unmap_unlock, migration_entry_wait, pte_none, pte_to_swp_entry, is_migration_entry, pte_protnone, vm_normal_page, can_follow_write_pte, pte_devmap, get_dev_pagemap, pte_page, is_zero_pfn, follow_pfn_pte, pte_write, gup_must_unshare, try_grab_page, arch_make_page_accessible, unpin_user_page, pte_dirty, set_page_dirty, mark_page_accessed]\n\n2. 函数名: WARN_ON_ONCE\n- 参数: [condition]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n3. 函数名: ERR_PTR\n- 参数: [error_code]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n4. 函数名: pmd_bad\n- 参数: [pmd]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n5. 函数名: no_page_table\n- 参数: [vma, flags]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n6. 函数名: pte_offset_map_lock\n- 参数: [mm, pmd, address, ptl]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n7. 函数名: pte_present\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n8. 函数名: pte_unmap_unlock\n- 参数: [ptep, ptl]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n9. 函数名: migration_entry_wait\n- 参数: [mm, pmd, address]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n10. 函数名: pte_none\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n11. 函数名: pte_to_swp_entry\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n12. 函数名: is_migration_entry\n- 参数: [entry]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n13. 函数名: pte_protnone\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n14. 函数名: vm_normal_page\n- 参数: [vma, address, pte]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n15. 函数名: can_follow_write_pte\n- 参数: [pte, page, vma, flags]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n16. 函数名: pte_devmap\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n17. 函数名: get_dev_pagemap\n- 参数: [pfn, pgmap]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n18. 函数名: pte_page\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n19. 函数名: is_zero_pfn\n- 参数: [pfn]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n20. 函数名: follow_pfn_pte\n- 参数: [vma, address, ptep, flags]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n21. 函数名: pte_write\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n22. 函数名: gup_must_unshare\n- 参数: [flags, page]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n23. 函数名: try_grab_page\n- 参数: [page, flags]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n24. 函数名: arch_make_page_accessible\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n25. 函数名: unpin_user_page\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n26. 函数名: pte_dirty\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n27. 函数名: set_page_dirty\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n28. 函数名: mark_page_accessed\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: []"
  },
  {
    "id": 3658,
    "cwe": "CWE-362",
    "cve": "CVE-2022-3623",
    "purpose": "Code purpose:\"\"\"该代码用于处理虚拟内存地址到物理页面的映射查找，包括处理大页、设备映射页和迁移条目等多种情况\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在follow_pmd_mask函数中存在对pmd值的竞争条件，未正确处理并发访问导致的竞态条件漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: follow_pmd_mask\n- 参数: [vma, address, pudp, flags, ctx]\n- 调用者: N/A\n- 被调用者: [pmd_offset, READ_ONCE, pmd_none, no_page_table, pmd_huge, is_vm_hugetlb_page, follow_huge_pmd, is_hugepd, pmd_val, follow_huge_pd, pmd_present, thp_migration_supported, is_pmd_migration_entry, pmd_migration_entry_wait, pmd_devmap, pmd_lock, follow_devmap_pmd, spin_unlock, pmd_trans_huge, follow_page_pte, pmd_protnone, pmd_page, is_huge_zero_page, split_huge_pmd, pmd_trans_unstable, pte_alloc, ERR_PTR, follow_trans_huge_pmd]\n\n2. 函数名: pmd_offset\n- 参数: [pudp, address]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n3. 函数名: READ_ONCE\n- 参数: [*pmd]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n4. 函数名: pmd_none\n- 参数: [pmdval]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n5. 函数名: no_page_table\n- 参数: [vma, flags]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n6. 函数名: pmd_huge\n- 参数: [pmdval]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n7. 函数名: is_vm_hugetlb_page\n- 参数: [vma]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n8. 函数名: follow_huge_pmd\n- 参数: [mm, address, pmd, flags]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n9. 函数名: is_hugepd\n- 参数: [__hugepd(pmd_val(pmdval))]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n10. 函数名: pmd_val\n- 参数: [pmdval]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n11. 函数名: follow_huge_pd\n- 参数: [vma, address, __hugepd(pmd_val(pmdval)), flags, PMD_SHIFT]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n12. 函数名: pmd_present\n- 参数: [pmdval]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n13. 函数名: thp_migration_supported\n- 参数: []\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n14. 函数名: is_pmd_migration_entry\n- 参数: [pmdval]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n15. 函数名: pmd_migration_entry_wait\n- 参数: [mm, pmd]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n16. 函数名: pmd_devmap\n- 参数: [pmdval]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n17. 函数名: pmd_lock\n- 参数: [mm, pmd]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n18. 函数名: follow_devmap_pmd\n- 参数: [vma, address, pmd, flags, &ctx->pgmap]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n19. 函数名: spin_unlock\n- 参数: [ptl]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n20. 函数名: pmd_trans_huge\n- 参数: [pmdval]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n21. 函数名: follow_page_pte\n- 参数: [vma, address, pmd, flags, &ctx->pgmap]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n22. 函数名: pmd_protnone\n- 参数: [pmdval]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n23. 函数名: pmd_page\n- 参数: [*pmd]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n24. 函数名: is_huge_zero_page\n- 参数: [page]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n25. 函数名: split_huge_pmd\n- 参数: [vma, pmd, address]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n26. 函数名: pmd_trans_unstable\n- 参数: [pmd]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n27. 函数名: pte_alloc\n- 参数: [mm, pmd]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n28. 函数名: ERR_PTR\n- 参数: [ret]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n29. 函数名: follow_trans_huge_pmd\n- 参数: [vma, address, pmd, flags]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A"
  },
  {
    "id": 3668,
    "cwe": "CWE-362",
    "cve": "CVE-2022-3635",
    "purpose": "Code purpose:\"\"\"该代码片段实现了Linux内核中IDT77252驱动模块的退出清理功能，包括注销PCI驱动、释放设备资源等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在释放card结构体后，可能仍存在对dev->phy->stop的调用，导致释放后使用(use-after-free)漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: __exit idt77252_exit\n- 参数: [void]\n- 调用者: 无（模块退出函数）\n- 被调用者: [pci_unregister_driver, dev->phy->stop, deinit_card, pci_disable_device, kfree, DIPRINTK]\n\n2. 函数名: pci_unregister_driver\n- 参数: [&idt77252_driver]\n- 调用者: idt77252_exit\n- 被调用者: 无\n\n3. 函数名: dev->phy->stop\n- 参数: [dev]\n- 调用者: idt77252_exit\n- 被调用者: 无\n\n4. 函数名: deinit_card\n- 参数: [card]\n- 调用者: idt77252_exit\n- 被调用者: 无\n\n5. 函数名: pci_disable_device\n- 参数: [card->pcidev]\n- 调用者: idt77252_exit\n- 被调用者: 无\n\n6. 函数名: kfree\n- 参数: [card]\n- 调用者: idt77252_exit\n- 被调用者: 无\n\n7. 函数名: DIPRINTK\n- 参数: [\"idt77252: finished cleanup-module().\\n\"]\n- 调用者: idt77252_exit\n- 被调用者: 无"
  },
  {
    "id": 3692,
    "cwe": "CWE-362",
    "cve": "CVE-2022-39188",
    "purpose": "Code purpose:\"\"\"在VMA边界处执行TLB刷新并重置范围，以避免范围随连续VMA之间未使用空间增长，同时确保tlb_start_vma()中的mmu_gather::vma_*标志正常工作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在VM_PFNMAP VMAs情况下存在竞态条件(unmap_mapping_range与munmap之间)，导致设备驱动程序可能在仍存在陈旧TLB条目时释放页面。\"\"\"",
    "functions": "Functions:\n1. 函数名: tlb_end_vma\n- 参数: [tlb, vma]\n- 调用者: 未明确显示（通常由内存管理相关代码调用）\n- 被调用者: [tlb_flush_mmu_tlbonly]\n\n2. 函数名: tlb_flush_mmu_tlbonly\n- 参数: [tlb]\n- 调用者: [tlb_end_vma]\n- 被调用者: 未明确显示"
  },
  {
    "id": 3693,
    "cwe": "CWE-362",
    "cve": "CVE-2022-39188",
    "purpose": "Code purpose:\"\"\"该代码片段旨在更新TLB（转译后备缓冲器）中虚拟内存区域（VMA）的标志位，但当前为空实现未实际执行任何操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在VM_PFNMAP VMAs情况下存在竞态条件(unmap_mapping_range与munmap之间)，导致设备驱动程序可能在仍存在陈旧TLB条目时释放页面。\"\"\"",
    "functions": "Functions:\n1. 函数名: tlb_update_vma_flags\n- 参数: [tlb, vma]\n- 调用者: 未提供（代码片段中未显示调用者信息）\n- 被调用者: []"
  },
  {
    "id": 3703,
    "cwe": "CWE-362",
    "cve": "CVE-2022-40307",
    "purpose": "Code purpose:\"\"\"释放EFI固件胶囊加载器相关的内存资源并清理文件私有数据\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在释放cap_info资源时存在竞态条件，导致可能发生释放后使用(UAF)的问题\"\"\"",
    "functions": "Functions:\n1. 函数名: efi_capsule_release\n- 参数: [struct inode *inode, struct file *file]\n- 调用者: 未明确（通常由文件操作结构中的release函数指针调用）\n- 被调用者: [kfree]\n\n2. 函数名: kfree\n- 参数: [void *ptr]\n- 调用者: [efi_capsule_release]\n- 被调用者: []"
  },
  {
    "id": 3720,
    "cwe": "CWE-362",
    "cve": "CVE-2022-41849",
    "purpose": "Code purpose:\"\"\"处理USB设备断开连接时的资源释放和状态清理工作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在USB设备断开连接时，由于缺乏适当的同步机制，导致在ufx_ops_open和ufx_usb_disconnect之间存在竞争条件，可能引发use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: ufx_usb_disconnect\n- 参数: [struct usb_interface *interface]\n- 调用者: 无（由USB子系统调用）\n- 被调用者: [usb_get_intfdata, pr_debug, atomic_set, usb_set_intfdata, schedule_delayed_work, kref_put]\n\n2. 函数名: usb_get_intfdata\n- 参数: [struct usb_interface *interface]\n- 调用者: ufx_usb_disconnect\n- 被调用者: 无\n\n3. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: ufx_usb_disconnect\n- 被调用者: 无\n\n4. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: ufx_usb_disconnect\n- 被调用者: 无\n\n5. 函数名: usb_set_intfdata\n- 参数: [struct usb_interface *interface, void *data]\n- 调用者: ufx_usb_disconnect\n- 被调用者: 无\n\n6. 函数名: schedule_delayed_work\n- 参数: [struct delayed_work *work, unsigned long delay]\n- 调用者: ufx_usb_disconnect\n- 被调用者: 无\n\n7. 函数名: kref_put\n- 参数: [struct kref *kref, void (*release)(struct kref *kref)]\n- 调用者: ufx_usb_disconnect\n- 被调用者: [ufx_free]\n\n8. 函数名: ufx_free\n- 参数: [struct kref *kref]\n- 调用者: kref_put\n- 被调用者: 无"
  },
  {
    "id": 3721,
    "cwe": "CWE-362",
    "cve": "CVE-2022-41849",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中USB帧缓冲设备(ufx)的打开操作，包括设备状态检查、引用计数管理以及延迟IO初始化等功能。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在ufx_ops_open函数中，当USB设备被物理移除时，dev指针可能变为悬垂指针，导致在访问dev->virtualized和dev->fb_count时出现竞争条件和使用后释放漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: ufx_ops_open\n- 参数: [struct fb_info *info, int user]\n- 调用者: 未明确显示（通常由framebuffer子系统调用）\n- 被调用者: [kref_get, kzalloc, fb_deferred_io_init, pr_debug]\n\n2. 函数名: kref_get\n- 参数: [&dev->kref]\n- 调用者: ufx_ops_open\n- 被调用者: []\n\n3. 函数名: kzalloc\n- 参数: [sizeof(*fbdefio), GFP_KERNEL]\n- 调用者: ufx_ops_open\n- 被调用者: []\n\n4. 函数名: fb_deferred_io_init\n- 参数: [info]\n- 调用者: ufx_ops_open\n- 被调用者: []\n\n5. 函数名: pr_debug\n- 参数: [\"open /dev/fb%d user=%d fb_info=%p count=%d\", info->node, user, info, dev->fb_count]\n- 调用者: ufx_ops_open\n- 被调用者: []\n\n6. 函数名: ufx_dpy_deferred_io\n- 参数: 未直接显示（通过fbdefio->deferred_io指针引用）\n- 调用者: 未直接调用（由fb_deferred_io机制后续调用）\n- 被调用者: []"
  },
  {
    "id": 3722,
    "cwe": "CWE-362",
    "cve": "CVE-2022-41850",
    "purpose": "Code purpose:\"\"\"该代码用于处理ROCCAT设备的事件报告，包括分配内存存储报告数据、管理循环缓冲区以及通知等待的读取进程。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在复制report->value时接收到新报告导致竞态条件，引发释放后使用漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: roccat_report_event\n- 参数: [minor, data]\n- 调用者: 未指定（由外部调用）\n- 被调用者: [kmemdup, kfree, wake_up_interruptible]\n\n2. 函数名: kmemdup\n- 参数: [data, device->report_size, GFP_ATOMIC]\n- 调用者: roccat_report_event\n- 被调用者: []\n\n3. 函数名: kfree\n- 参数: [report->value]\n- 调用者: roccat_report_event\n- 被调用者: []\n\n4. 函数名: wake_up_interruptible\n- 参数: [&device->wait]\n- 调用者: roccat_report_event\n- 被调用者: []"
  },
  {
    "id": 3750,
    "cwe": "CWE-362",
    "cve": "CVE-2022-45869",
    "purpose": "Code purpose:\"\"\"该代码用于在KVM虚拟化环境中准备并执行影子页面的回收操作，处理无效页面并维护MMU页表结构的一致性\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在启用嵌套虚拟化和TDP MMU时，x86 KVM子系统中存在竞争条件，导致在准备回收页面时可能引发主机操作系统崩溃或内存损坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: __kvm_mmu_prepare_zap_page\n- 参数: [kvm, sp, invalid_list, nr_zapped]\n- 调用者: 未明确显示（通常是KVM内部MMU相关函数）\n- 被调用者: [mmu_zap_unsync_children, kvm_mmu_page_unlink_children, kvm_mmu_unlink_parents, unaccount_shadowed, kvm_unlink_unsync_page, kvm_unaccount_mmu_page, is_obsolete_sp, unaccount_huge_nx_page, kvm_make_all_cpus_request]\n\n2. 函数名: mmu_zap_unsync_children\n- 参数: [kvm, sp, invalid_list]\n- 调用者: __kvm_mmu_prepare_zap_page\n- 被调用者: []\n\n3. 函数名: kvm_mmu_page_unlink_children\n- 参数: [kvm, sp, invalid_list]\n- 调用者: __kvm_mmu_prepare_zap_page\n- 被调用者: []\n\n4. 函数名: kvm_mmu_unlink_parents\n- 参数: [sp]\n- 调用者: __kvm_mmu_prepare_zap_page\n- 被调用者: []\n\n5. 函数名: unaccount_shadowed\n- 参数: [kvm, sp]\n- 调用者: __kvm_mmu_prepare_zap_page\n- 被调用者: []\n\n6. 函数名: kvm_unlink_unsync_page\n- 参数: [kvm, sp]\n- 调用者: __kvm_mmu_prepare_zap_page\n- 被调用者: []\n\n7. 函数名: kvm_unaccount_mmu_page\n- 参数: [kvm, sp]\n- 调用者: __kvm_mmu_prepare_zap_page\n- 被调用者: []\n\n8. 函数名: is_obsolete_sp\n- 参数: [kvm, sp]\n- 调用者: __kvm_mmu_prepare_zap_page\n- 被调用者: []\n\n9. 函数名: unaccount_huge_nx_page\n- 参数: [kvm, sp]\n- 调用者: __kvm_mmu_prepare_zap_page\n- 被调用者: []\n\n10. 函数名: kvm_make_all_cpus_request\n- 参数: [kvm, KVM_REQ_MMU_FREE_OBSOLETE_ROOTS]\n- 调用者: __kvm_mmu_prepare_zap_page\n- 被调用者: []"
  },
  {
    "id": 3751,
    "cwe": "CWE-362",
    "cve": "CVE-2022-45869",
    "purpose": "Code purpose:\"\"\"处理x86 KVM子系统中客户机操作系统的页错误，包括页跟踪、快速页错误处理、内存缓存填充和MMU页映射等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在启用嵌套虚拟化和TDP MMU时，x86 KVM子系统中存在竞态条件，导致锁机制处理不当，可能引发主机操作系统崩溃或内存损坏。\"\"\"",
    "functions": "Functions:\n1. 函数名: direct_page_fault\n- 参数: [struct kvm_vcpu *vcpu, struct kvm_page_fault *fault]\n- 调用者: N/A\n- 被调用者: [is_tdp_mmu, kvm_vcpu_gfn_to_memslot, page_fault_handle_page_track, fast_page_fault, mmu_topup_memory_caches, kvm_faultin_pfn, handle_abnormal_pfn, is_page_fault_stale, make_mmu_pages_available, kvm_tdp_mmu_map, __direct_map, kvm_release_pfn_clean]\n\n2. 函数名: is_tdp_mmu\n- 参数: [struct kvm_vcpu->arch.mmu]\n- 调用者: direct_page_fault\n- 被调用者: N/A\n\n3. 函数名: kvm_vcpu_gfn_to_memslot\n- 参数: [struct kvm_vcpu *vcpu, fault->gfn]\n- 调用者: direct_page_fault\n- 被调用者: N/A\n\n4. 函数名: page_fault_handle_page_track\n- 参数: [struct kvm_vcpu *vcpu, struct kvm_page_fault *fault]\n- 调用者: direct_page_fault\n- 被调用者: N/A\n\n5. 函数名: fast_page_fault\n- 参数: [struct kvm_vcpu *vcpu, struct kvm_page_fault *fault]\n- 调用者: direct_page_fault\n- 被调用者: N/A\n\n6. 函数名: mmu_topup_memory_caches\n- 参数: [struct kvm_vcpu *vcpu, false]\n- 调用者: direct_page_fault\n- 被调用者: N/A\n\n7. 函数名: kvm_faultin_pfn\n- 参数: [struct kvm_vcpu *vcpu, struct kvm_page_fault *fault]\n- 调用者: direct_page_fault\n- 被调用者: N/A\n\n8. 函数名: handle_abnormal_pfn\n- 参数: [struct kvm_vcpu *vcpu, struct kvm_page_fault *fault, ACC_ALL]\n- 调用者: direct_page_fault\n- 被调用者: N/A\n\n9. 函数名: is_page_fault_stale\n- 参数: [struct kvm_vcpu *vcpu, struct kvm_page_fault *fault, mmu_seq]\n- 调用者: direct_page_fault\n- 被调用者: N/A\n\n10. 函数名: make_mmu_pages_available\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: direct_page_fault\n- 被调用者: N/A\n\n11. 函数名: kvm_tdp_mmu_map\n- 参数: [struct kvm_vcpu *vcpu, struct kvm_page_fault *fault]\n- 调用者: direct_page_fault\n- 被调用者: N/A\n\n12. 函数名: __direct_map\n- 参数: [struct kvm_vcpu *vcpu, struct kvm_page_fault *fault]\n- 调用者: direct_page_fault\n- 被调用者: N/A\n\n13. 函数名: kvm_release_pfn_clean\n- 参数: [fault->pfn]\n- 调用者: direct_page_fault\n- 被调用者: N/A"
  },
  {
    "id": 3752,
    "cwe": "CWE-362",
    "cve": "CVE-2022-45887",
    "purpose": "Code purpose:\"\"\"释放ttusb_dec结构体中的DVB相关资源并注销前端设备\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺少对dvb_frontend_detach的调用，导致在释放资源时未能正确清理前端设备的内存，造成内存泄漏\"\"\"",
    "functions": "Functions:\n1. 函数名: ttusb_dec_exit_dvb\n- 参数: [struct ttusb_dec *dec]\n- 调用者: 未显示\n- 被调用者: [dprintk, dvb_net_release, dec->demux.dmx.close, dec->demux.dmx.remove_frontend, dvb_dmxdev_release, dvb_dmx_release, dvb_unregister_frontend, dec->fe->ops.release, dvb_unregister_adapter]\n\n2. 函数名: dprintk\n- 参数: [\"%s\\n\", __func__]\n- 调用者: ttusb_dec_exit_dvb\n- 被调用者: []\n\n3. 函数名: dvb_net_release\n- 参数: [&dec->dvb_net]\n- 调用者: ttusb_dec_exit_dvb\n- 被调用者: []\n\n4. 函数名: dec->demux.dmx.close\n- 参数: [&dec->demux.dmx]\n- 调用者: ttusb_dec_exit_dvb\n- 被调用者: []\n\n5. 函数名: dec->demux.dmx.remove_frontend\n- 参数: [&dec->demux.dmx, &dec->frontend]\n- 调用者: ttusb_dec_exit_dvb\n- 被调用者: []\n\n6. 函数名: dvb_dmxdev_release\n- 参数: [&dec->dmxdev]\n- 调用者: ttusb_dec_exit_dvb\n- 被调用者: []\n\n7. 函数名: dvb_dmx_release\n- 参数: [&dec->demux]\n- 调用者: ttusb_dec_exit_dvb\n- 被调用者: []\n\n8. 函数名: dvb_unregister_frontend\n- 参数: [dec->fe]\n- 调用者: ttusb_dec_exit_dvb\n- 被调用者: []\n\n9. 函数名: dec->fe->ops.release\n- 参数: [dec->fe]\n- 调用者: ttusb_dec_exit_dvb\n- 被调用者: []\n\n10. 函数名: dvb_unregister_adapter\n- 参数: [&dec->adapter]\n- 调用者: ttusb_dec_exit_dvb\n- 被调用者: []"
  },
  {
    "id": 3753,
    "cwe": "CWE-362",
    "cve": "CVE-2022-45888",
    "purpose": "Code purpose:\"\"\"该代码实现了xillyusb设备的打开功能，包括设备通道的初始化、读写权限检查、端点分配和数据缓冲区设置等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在USB设备物理移除时，xillyusb_open函数中存在竞态条件导致对已释放资源的后续访问，造成use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: xillyusb_open\n- 参数: [struct inode *inode, struct file *filp]\n- 调用者: 内核文件操作调用\n- 被调用者: [xillybus_find_inode, mutex_lock, dev_err, kref_get, endpoint_alloc, fifo_init, flush_downstream, report_io_error, kzalloc, kfree, xillyusb_send_opcode, request_read_anything, safely_assign_in_fifo, fifo_mem_release, endpoint_dealloc, kref_put, mutex_unlock]\n\n2. 函数名: xillybus_find_inode\n- 参数: [struct inode *inode, void **xdev, int *index]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n3. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n4. 函数名: dev_err\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n5. 函数名: kref_get\n- 参数: [struct kref *kref]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n6. 函数名: endpoint_alloc\n- 参数: [struct xillyusb_dev *xdev, int endpoint_num, work_func_t work_func, int buf_order, int bufs_num]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n7. 函数名: fifo_init\n- 参数: [struct xillyfifo *fifo, int log2_size]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n8. 函数名: flush_downstream\n- 参数: [struct xillyusb_channel *chan, int timeout, bool force]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n9. 函数名: report_io_error\n- 参数: [struct xillyusb_dev *xdev, int rc]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n10. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n11. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n12. 函数名: xillyusb_send_opcode\n- 参数: [struct xillyusb_dev *xdev, int endpoint_num, int opcode, u32 data]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n13. 函数名: request_read_anything\n- 参数: [struct xillyusb_channel *chan, int opcode]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n14. 函数名: safely_assign_in_fifo\n- 参数: [struct xillyusb_channel *chan, struct xillyfifo *in_fifo]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n15. 函数名: fifo_mem_release\n- 参数: [struct xillyfifo *fifo]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n16. 函数名: endpoint_dealloc\n- 参数: [struct xillyusb_endpoint *ep]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n17. 函数名: kref_put\n- 参数: [struct kref *kref, void (*release)(struct kref *kref)]\n- 调用者: xillyusb_open\n- 被调用者: [cleanup_dev]\n\n18. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n19. 函数名: cleanup_dev\n- 参数: [struct kref *kref]\n- 调用者: kref_put\n- 被调用者: []"
  },
  {
    "id": 3754,
    "cwe": "CWE-362",
    "cve": "CVE-2022-45888",
    "purpose": "Code purpose:\"\"\"在USB设备物理移除时，清理相关资源并处理竞争条件，但存在潜在的竞态条件和释放后使用漏洞\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在USB设备物理移除时，xillyusb_disconnect函数存在竞态条件，导致在清理资源过程中可能发生use-after-free问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: xillyusb_disconnect\n- 参数: [struct usb_interface *interface]\n- 调用者: 无（由USB子系统调用）\n- 被调用者: [usb_get_intfdata, xillybus_cleanup_chrdev, xillyusb_send_opcode, wait_event_interruptible_timeout, dev_err, report_io_error, mutex_lock, endpoint_quiesce, mutex_unlock, usb_set_intfdata, kref_put]\n\n2. 函数名: usb_get_intfdata\n- 参数: [struct usb_interface *interface]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n3. 函数名: xillybus_cleanup_chrdev\n- 参数: [struct xillyusb_dev *xdev, struct device *dev]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n4. 函数名: xillyusb_send_opcode\n- 参数: [struct xillyusb_dev *xdev, ~0, OPCODE_QUIESCE, 0]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n5. 函数名: wait_event_interruptible_timeout\n- 参数: [fifo->waitq, msg_ep->drained || xdev->error, XILLY_RESPONSE_TIMEOUT]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n6. 函数名: dev_err\n- 参数: [&interface->dev, \"Weird timeout condition on sending quiesce request.\\n\"]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n7. 函数名: report_io_error\n- 参数: [xdev, -ENODEV]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n8. 函数名: mutex_lock\n- 参数: [&chan->lock]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n9. 函数名: endpoint_quiesce\n- 参数: [chan->out_ep]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n10. 函数名: mutex_unlock\n- 参数: [&chan->lock]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n11. 函数名: usb_set_intfdata\n- 参数: [interface, NULL]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n12. 函数名: kref_put\n- 参数: [&xdev->kref, cleanup_dev]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无"
  },
  {
    "id": 3869,
    "cwe": "CWE-362",
    "cve": "CVE-2023-1582",
    "purpose": "Code purpose:\"\"\"该代码用于处理进程内存映射的页表遍历和状态信息收集，实现/proc文件系统中内存管理信息的读取功能\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在透明大页(THP)处理过程中存在竞态条件，导致本地攻击者可能通过竞争条件引发拒绝服务\"\"\"",
    "functions": "Functions:\n1. 函数名: pagemap_pmd_range\n- 参数: [pmdp, addr, end, walk]\n- 调用者: N/A (top-level function)\n- 被调用者: [pmd_trans_huge_lock, pmd_present, pmd_page, pmd_soft_dirty, pmd_uffd_wp, pmd_pfn, is_swap_pmd, pmd_to_swp_entry, pmd_swp_soft_dirty, pmd_swp_uffd_wp, is_pmd_migration_entry, pfn_swap_entry_to_page, page_mapcount, add_to_pagemap, spin_unlock, pmd_trans_unstable, pte_offset_map_lock, pte_to_pagemap_entry, pte_unmap_unlock, cond_resched]\n\n2. 函数名: pmd_trans_huge_lock\n- 参数: [pmdp, vma]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n3. 函数名: pmd_present\n- 参数: [pmd]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n4. 函数名: pmd_page\n- 参数: [pmd]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n5. 函数名: pmd_soft_dirty\n- 参数: [pmd]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n6. 函数名: pmd_uffd_wp\n- 参数: [pmd]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n7. 函数名: pmd_pfn\n- 参数: [pmd]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n8. 函数名: is_swap_pmd\n- 参数: [pmd]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n9. 函数名: pmd_to_swp_entry\n- 参数: [pmd]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n10. 函数名: pmd_swp_soft_dirty\n- 参数: [pmd]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n11. 函数名: pmd_swp_uffd_wp\n- 参数: [pmd]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n12. 函数名: is_pmd_migration_entry\n- 参数: [pmd]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n13. 函数名: pfn_swap_entry_to_page\n- 参数: [entry]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n14. 函数名: page_mapcount\n- 参数: [page]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n15. 函数名: add_to_pagemap\n- 参数: [addr, pme, pm]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n16. 函数名: spin_unlock\n- 参数: [ptl]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n17. 函数名: pmd_trans_unstable\n- 参数: [pmdp]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n18. 函数名: pte_offset_map_lock\n- 参数: [mm, pmdp, addr, ptl]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n19. 函数名: pte_to_pagemap_entry\n- 参数: [pm, vma, addr, pte]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n20. 函数名: pte_unmap_unlock\n- 参数: [orig_pte, ptl]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n21. 函数名: cond_resched\n- 参数: []\n- 调用者: pagemap_pmd_range\n- 被调用者: []"
  },
  {
    "id": 3870,
    "cwe": "CWE-362",
    "cve": "CVE-2023-1582",
    "purpose": "Code purpose:\"\"\"该代码用于统计进程内存映射中页面的使用情况，包括常驻内存、交换空间等信息，并处理可能存在的竞争条件问题。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在内存映射统计过程中缺乏适当的同步机制，导致在多线程环境下可能出现竞争条件，从而引发拒绝服务漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: smaps_pte_entry\n- 参数: [pte_t *pte, unsigned long addr, struct mm_walk *walk]\n- 调用者: 未显示（由内存管理子系统调用）\n- 被调用者: [pte_present, vm_normal_page, is_swap_pte, pte_to_swp_entry, non_swap_entry, swp_swapcount, is_pfn_swap_entry, pfn_swap_entry_to_page, smaps_pte_hole_lookup, smaps_account]\n\n2. 函数名: pte_present\n- 参数: [pte_t *pte]\n- 调用者: smaps_pte_entry\n- 被调用者: []\n\n3. 函数名: vm_normal_page\n- 参数: [struct vm_area_struct *vma, unsigned long addr, pte_t pte]\n- 调用者: smaps_pte_entry\n- 被调用者: []\n\n4. 函数名: is_swap_pte\n- 参数: [pte_t *pte]\n- 调用者: smaps_pte_entry\n- 被调用者: []\n\n5. 函数名: pte_to_swp_entry\n- 参数: [pte_t *pte]\n- 调用者: smaps_pte_entry\n- 被调用者: []\n\n6. 函数名: non_swap_entry\n- 参数: [swp_entry_t swpent]\n- 调用者: smaps_pte_entry\n- 被调用者: []\n\n7. 函数名: swp_swapcount\n- 参数: [swp_entry_t swpent]\n- 调用者: smaps_pte_entry\n- 被调用者: []\n\n8. 函数名: is_pfn_swap_entry\n- 参数: [swp_entry_t swpent]\n- 调用者: smaps_pte_entry\n- 被调用者: []\n\n9. 函数名: pfn_swap_entry_to_page\n- 参数: [swp_entry_t swpent]\n- 调用者: smaps_pte_entry\n- 被调用者: []\n\n10. 函数名: smaps_pte_hole_lookup\n- 参数: [unsigned long addr, struct mm_walk *walk]\n- 调用者: smaps_pte_entry\n- 被调用者: []\n\n11. 函数名: smaps_account\n- 参数: [struct mem_size_stats *mss, struct page *page, bool false, pte_young(*pte), pte_dirty(*pte), bool locked]\n- 调用者: smaps_pte_entry\n- 被调用者: []\n\n12. 函数名: pte_young\n- 参数: [pte_t *pte]\n- 调用者: smaps_account\n- 被调用者: []\n\n13. 函数名: pte_dirty\n- 参数: [pte_t *pte]\n- 调用者: smaps_account\n- 被调用者: []"
  },
  {
    "id": 3871,
    "cwe": "CWE-362",
    "cve": "CVE-2023-1582",
    "purpose": "Code purpose:\"\"\"将页表项(pte)转换为可分页内存映射条目(pagemap_entry_t)，包括提取页框号(frame)和标志位(flags)信息\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在访问页表项(pte)和页面(page)时缺乏适当的同步机制，导致在多线程环境下可能出现竞争条件，从而引发拒绝服务漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: pte_to_pagemap_entry\n- 参数: [pm, vma, addr, pte]\n- 调用者: N/A\n- 被调用者: [pte_present, pte_pfn, vm_normal_page, pte_soft_dirty, pte_uffd_wp, is_swap_pte, pte_swp_soft_dirty, pte_swp_uffd_wp, pte_to_swp_entry, swp_type, swp_offset, is_pfn_swap_entry, pfn_swap_entry_to_page, PageAnon, page_mapcount, make_pme]\n\n2. 函数名: pte_present\n- 参数: [pte]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n3. 函数名: pte_pfn\n- 参数: [pte]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n4. 函数名: vm_normal_page\n- 参数: [vma, addr, pte]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n5. 函数名: pte_soft_dirty\n- 参数: [pte]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n6. 函数名: pte_uffd_wp\n- 参数: [pte]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n7. 函数名: is_swap_pte\n- 参数: [pte]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n8. 函数名: pte_swp_soft_dirty\n- 参数: [pte]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n9. 函数名: pte_swp_uffd_wp\n- 参数: [pte]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n10. 函数名: pte_to_swp_entry\n- 参数: [pte]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n11. 函数名: swp_type\n- 参数: [entry]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n12. 函数名: swp_offset\n- 参数: [entry]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n13. 函数名: is_pfn_swap_entry\n- 参数: [entry]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n14. 函数名: pfn_swap_entry_to_page\n- 参数: [entry]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n15. 函数名: PageAnon\n- 参数: [page]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n16. 函数名: page_mapcount\n- 参数: [page]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n17. 函数名: make_pme\n- 参数: [frame, flags]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A"
  },
  {
    "id": 3894,
    "cwe": "CWE-362",
    "cve": "CVE-2023-2006",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中RxRPC网络协议的连接调用功能，处理客户端连接请求并管理连接资源\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在RxRPC网络协议处理bundle时，由于对对象操作缺乏适当的锁保护，导致竞态条件漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: rxrpc_connect_call\n- 参数: [struct rxrpc_sock *rx, struct rxrpc_call *call, struct rxrpc_conn_parameters *cp, struct sockaddr_rxrpc *srx, gfp_t gfp]\n- 调用者: N/A\n- 被调用者: [rxrpc_discard_expired_client_conns, rxrpc_prep_call, rxrpc_wait_for_channel, rxrpc_put_bundle, trace_rxrpc_client, rxrpc_set_call_completion, rxrpc_disconnect_client_call]\n\n2. 函数名: rxrpc_discard_expired_client_conns\n- 参数: [&rxnet->client_conn_reaper]\n- 调用者: rxrpc_connect_call\n- 被调用者: N/A\n\n3. 函数名: rxrpc_prep_call\n- 参数: [rx, call, cp, srx, gfp]\n- 调用者: rxrpc_connect_call\n- 被调用者: N/A\n\n4. 函数名: rxrpc_wait_for_channel\n- 参数: [bundle, call, gfp]\n- 调用者: rxrpc_connect_call\n- 被调用者: N/A\n\n5. 函数名: rxrpc_put_bundle\n- 参数: [bundle]\n- 调用者: rxrpc_connect_call\n- 被调用者: N/A\n\n6. 函数名: trace_rxrpc_client\n- 参数: [call->conn, ret, rxrpc_client_chan_wait_failed]\n- 调用者: rxrpc_connect_call\n- 被调用者: N/A\n\n7. 函数名: rxrpc_set_call_completion\n- 参数: [call, RXRPC_CALL_LOCAL_ERROR, 0, ret]\n- 调用者: rxrpc_connect_call\n- 被调用者: N/A\n\n8. 函数名: rxrpc_disconnect_client_call\n- 参数: [bundle, call]\n- 调用者: rxrpc_connect_call\n- 被调用者: N/A"
  },
  {
    "id": 3895,
    "cwe": "CWE-362",
    "cve": "CVE-2023-2006",
    "purpose": "Code purpose:\"\"\"分配并初始化一个RxRPC网络协议使用的bundle结构体，包含参数复制、引用计数设置和锁初始化等操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在RxRPC网络协议处理bundle时，由于对对象操作缺乏适当的锁保护，导致竞态条件漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: rxrpc_alloc_bundle\n- 参数: [struct rxrpc_conn_parameters *cp, gfp_t gfp]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [kzalloc, rxrpc_get_peer, refcount_set, spin_lock_init, INIT_LIST_HEAD]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*bundle), gfp]\n- 调用者: rxrpc_alloc_bundle\n- 被调用者: []\n\n3. 函数名: rxrpc_get_peer\n- 参数: [bundle->params.peer]\n- 调用者: rxrpc_alloc_bundle\n- 被调用者: []\n\n4. 函数名: refcount_set\n- 参数: [&bundle->ref, 1]\n- 调用者: rxrpc_alloc_bundle\n- 被调用者: []\n\n5. 函数名: spin_lock_init\n- 参数: [&bundle->channel_lock]\n- 调用者: rxrpc_alloc_bundle\n- 被调用者: []\n\n6. 函数名: INIT_LIST_HEAD\n- 参数: [&bundle->waiting_calls]\n- 调用者: rxrpc_alloc_bundle\n- 被调用者: []"
  },
  {
    "id": 3896,
    "cwe": "CWE-362",
    "cve": "CVE-2023-2006",
    "purpose": "Code purpose:\"\"\"该代码用于处理RxRPC网络协议中的连接解绑操作，管理连接与bundle之间的关系，并在无活跃连接时移除bundle\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在RxRPC网络协议处理bundle时，由于对对象操作缺乏适当的锁保护，导致存在竞态条件漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: rxrpc_unbundle_conn\n- 参数: [struct rxrpc_connection *conn]\n- 调用者: N/A\n- 被调用者: [rxrpc_process_delayed_final_acks, clear_bit, rb_erase, rxrpc_put_bundle, rxrpc_put_connection]\n\n2. 函数名: rxrpc_process_delayed_final_acks\n- 参数: [struct rxrpc_connection *conn, bool]\n- 调用者: rxrpc_unbundle_conn\n- 被调用者: N/A\n\n3. 函数名: clear_bit\n- 参数: [unsigned int, unsigned long *]\n- 调用者: rxrpc_unbundle_conn\n- 被调用者: N/A\n\n4. 函数名: rb_erase\n- 参数: [struct rb_node *, struct rb_root *]\n- 调用者: rxrpc_unbundle_conn\n- 被调用者: N/A\n\n5. 函数名: rxrpc_put_bundle\n- 参数: [struct rxrpc_bundle *]\n- 调用者: rxrpc_unbundle_conn\n- 被调用者: N/A\n\n6. 函数名: rxrpc_put_connection\n- 参数: [struct rxrpc_connection *]\n- 调用者: rxrpc_unbundle_conn\n- 被调用者: N/A"
  },
  {
    "id": 3897,
    "cwe": "CWE-362",
    "cve": "CVE-2023-2006",
    "purpose": "Code purpose:\"\"\"在RxRPC网络协议中查找或创建客户端连接包(bundle)，处理并发访问时存在竞态条件漏洞\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在RxRPC网络协议处理bundle时，由于对对象操作缺乏适当的锁保护，导致竞态条件漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: rxrpc_look_up_bundle\n- 参数: [struct rxrpc_conn_parameters *cp, gfp_t gfp]\n- 调用者: N/A (顶级函数)\n- 被调用者: [rxrpc_alloc_bundle, rb_entry, rxrpc_free_bundle, rxrpc_get_bundle, rb_link_node, rb_insert_color]\n\n2. 函数名: rxrpc_alloc_bundle\n- 参数: [struct rxrpc_conn_parameters *cp, gfp_t gfp]\n- 调用者: rxrpc_look_up_bundle\n- 被调用者: N/A\n\n3. 函数名: rb_entry\n- 参数: [struct rb_node *node, struct rxrpc_bundle, local_node]\n- 调用者: rxrpc_look_up_bundle\n- 被调用者: N/A\n\n4. 函数名: rxrpc_free_bundle\n- 参数: [struct rxrpc_bundle *candidate]\n- 调用者: rxrpc_look_up_bundle\n- 被调用者: N/A\n\n5. 函数名: rxrpc_get_bundle\n- 参数: [struct rxrpc_bundle *bundle]\n- 调用者: rxrpc_look_up_bundle\n- 被调用者: N/A\n\n6. 函数名: rb_link_node\n- 参数: [struct rb_node *node, struct rb_node *parent, struct rb_node **rb_link]\n- 调用者: rxrpc_look_up_bundle\n- 被调用者: N/A\n\n7. 函数名: rb_insert_color\n- 参数: [struct rb_node *node, struct rb_root *root]\n- 调用者: rxrpc_look_up_bundle\n- 被调用者: N/A"
  },
  {
    "id": 3898,
    "cwe": "CWE-362",
    "cve": "CVE-2023-2006",
    "purpose": "Code purpose:\"\"\"该代码用于在RxRPC网络协议中管理连接包(bundle)中的连接，处理连接的分配、重用和替换，但存在竞态条件漏洞\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在RxRPC网络协议处理bundle时，由于对对象操作缺乏适当的锁保护，导致存在竞态条件漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: rxrpc_add_conn_to_bundle\n- 参数: [bundle, gfp]\n- 调用者: 未显示\n- 被调用者: [rxrpc_alloc_client_connection, rxrpc_may_reuse_conn, trace_rxrpc_client, rxrpc_put_connection]\n\n2. 函数名: rxrpc_alloc_client_connection\n- 参数: [bundle, gfp]\n- 调用者: rxrpc_add_conn_to_bundle\n- 被调用者: 未显示\n\n3. 函数名: rxrpc_may_reuse_conn\n- 参数: [old]\n- 调用者: rxrpc_add_conn_to_bundle\n- 被调用者: 未显示\n\n4. 函数名: trace_rxrpc_client\n- 参数: [old, -1, rxrpc_client_replace] 或 [candidate, -1, rxrpc_client_duplicate]\n- 调用者: rxrpc_add_conn_to_bundle\n- 被调用者: 未显示\n\n5. 函数名: rxrpc_put_connection\n- 参数: [candidate] 或 [old]\n- 调用者: rxrpc_add_conn_to_bundle\n- 被调用者: 未显示\n\n6. 函数名: spin_unlock\n- 参数: [&bundle->channel_lock]\n- 调用者: rxrpc_add_conn_to_bundle\n- 被调用者: 未显示\n\n7. 函数名: spin_lock\n- 参数: [&bundle->channel_lock]\n- 调用者: rxrpc_add_conn_to_bundle\n- 被调用者: 未显示\n\n8. 函数名: set_bit\n- 参数: [shift + j, &bundle->avail_chans]\n- 调用者: rxrpc_add_conn_to_bundle\n- 被调用者: 未显示"
  },
  {
    "id": 3899,
    "cwe": "CWE-362",
    "cve": "CVE-2023-2006",
    "purpose": "Code purpose:\"\"\"该代码用于减少RxRPC bundle对象的引用计数并在计数归零时释放该对象\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在操作RxRPC bundle对象时缺乏适当的锁保护，导致存在竞态条件漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: rxrpc_put_bundle\n- 参数: [struct rxrpc_bundle *bundle]\n- 调用者: 未指定\n- 被调用者: [__refcount_dec_and_test, _debug, rxrpc_free_bundle]\n\n2. 函数名: __refcount_dec_and_test\n- 参数: [&bundle->ref, &r]\n- 调用者: rxrpc_put_bundle\n- 被调用者: 未指定\n\n3. 函数名: _debug\n- 参数: [\"PUT B=%x %d\", d, r]\n- 调用者: rxrpc_put_bundle\n- 被调用者: 未指定\n\n4. 函数名: rxrpc_free_bundle\n- 参数: [bundle]\n- 调用者: rxrpc_put_bundle\n- 被调用者: 未指定"
  },
  {
    "id": 3983,
    "cwe": "CWE-362",
    "cve": "CVE-2023-2898",
    "purpose": "Code purpose:\"\"\"该代码实现了F2FS文件系统的调整大小功能，需要管理员权限且文件系统非只读时，将用户空间传入的块数量参数传递给底层调整函数。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于在f2fs_ioc_resize_fs函数中未对用户传入的block_count参数进行有效性验证，可能导致空指针解引用，造成拒绝服务。\"\"\"",
    "functions": "Functions:\n1. 函数名: f2fs_ioc_resize_fs\n- 参数: [struct file *filp, unsigned long arg]\n- 调用者: 未显示（应为系统调用或上层函数）\n- 被调用者: [file_inode, capable, f2fs_readonly, copy_from_user, f2fs_resize_fs]\n\n2. 函数名: file_inode\n- 参数: [struct file *filp]\n- 调用者: f2fs_ioc_resize_fs\n- 被调用者: []\n\n3. 函数名: capable\n- 参数: [CAP_SYS_ADMIN]\n- 调用者: f2fs_ioc_resize_fs\n- 被调用者: []\n\n4. 函数名: f2fs_readonly\n- 参数: [struct super_block *sb]\n- 调用者: f2fs_ioc_resize_fs\n- 被调用者: []\n\n5. 函数名: copy_from_user\n- 参数: [__u64 *block_count, void __user *arg, sizeof(block_count)]\n- 调用者: f2fs_ioc_resize_fs\n- 被调用者: []\n\n6. 函数名: f2fs_resize_fs\n- 参数: [struct f2fs_sb_info *sbi, __u64 block_count]\n- 调用者: f2fs_ioc_resize_fs\n- 被调用者: []"
  },
  {
    "id": 3993,
    "cwe": "CWE-362",
    "cve": "CVE-2023-3108",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的对称密钥密码算法接口中，将用户空间的数据迭代器转换为散列表(sg)以便进行加密操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确处理并发条件下的资源竞争，导致在skcipher_recvmsg函数中调用get_user_pages_fast时可能引发系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: af_alg_make_sg\n- 参数: [struct af_alg_sgl *sgl, struct iov_iter *iter, int len]\n- 调用者: 未明确（可能是外部调用）\n- 被调用者: [iov_iter_get_pages, PAGE_ALIGN, WARN_ON, sg_init_table, min_t, sg_set_page]\n\n2. 函数名: iov_iter_get_pages\n- 参数: [struct iov_iter *iter, struct page **pages, size_t maxsize, unsigned maxpages, size_t *start]\n- 调用者: af_alg_make_sg\n- 被调用者: 未明确\n\n3. 函数名: PAGE_ALIGN\n- 参数: [size_t size]\n- 调用者: af_alg_make_sg\n- 被调用者: 未明确\n\n4. 函数名: WARN_ON\n- 参数: [bool condition]\n- 调用者: af_alg_make_sg\n- 被调用者: 未明确\n\n5. 函数名: sg_init_table\n- 参数: [struct scatterlist *sgl, unsigned int nents]\n- 调用者: af_alg_make_sg\n- 被调用者: 未明确\n\n6. 函数名: min_t\n- 参数: [type, x, y]\n- 调用者: af_alg_make_sg\n- 被调用者: 未明确\n\n7. 函数名: sg_set_page\n- 参数: [struct scatterlist *sg, struct page *page, unsigned int len, unsigned int offset]\n- 调用者: af_alg_make_sg\n- 被调用者: 未明确"
  },
  {
    "id": 3994,
    "cwe": "CWE-362",
    "cve": "CVE-2023-3108",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中对称密钥密码算法的接收消息功能，处理来自用户空间的加密/解密请求并返回结果。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在skcipher_recvmsg函数中未正确处理并发访问，导致竞争条件(CWE-362)可能被利用来使系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: skcipher_recvmsg\n- 参数: [struct kiocb *unused, struct socket *sock, struct msghdr *msg, size_t ignored, int flags]\n- 调用者: N/A (kernel-level socket operation)\n- 被调用者: [alg_sk, crypto_ablkcipher_blocksize, crypto_ablkcipher_reqtfm, lock_sock, iov_iter_count, list_first_entry, skcipher_wait_for_data, min_t, af_alg_make_sg, ablkcipher_request_set_crypt, af_alg_wait_for_completion, crypto_ablkcipher_encrypt, crypto_ablkcipher_decrypt, af_alg_free_sg, skcipher_pull_sgl, iov_iter_advance, skcipher_wmem_wakeup, release_sock]\n\n2. 函数名: alg_sk\n- 参数: [struct sock *sk]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n3. 函数名: crypto_ablkcipher_blocksize\n- 参数: [struct crypto_ablkcipher *tfm]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n4. 函数名: crypto_ablkcipher_reqtfm\n- 参数: [struct ablkcipher_request *req]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n5. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n6. 函数名: iov_iter_count\n- 参数: [struct iov_iter *i]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n7. 函数名: list_first_entry\n- 参数: [struct list_head *ptr, type, member]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n8. 函数名: skcipher_wait_for_data\n- 参数: [struct sock *sk, int flags]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n9. 函数名: min_t\n- 参数: [type, x, y]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n10. 函数名: af_alg_make_sg\n- 参数: [struct af_alg_sgl *sgl, struct iov_iter *iter, size_t len]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n11. 函数名: ablkcipher_request_set_crypt\n- 参数: [struct ablkcipher_request *req, struct scatterlist *src, struct scatterlist *dst, unsigned int nbytes, void *iv]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n12. 函数名: af_alg_wait_for_completion\n- 参数: [int completion, struct completion *wait]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n13. 函数名: crypto_ablkcipher_encrypt\n- 参数: [struct ablkcipher_request *req]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n14. 函数名: crypto_ablkcipher_decrypt\n- 参数: [struct ablkcipher_request *req]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n15. 函数名: af_alg_free_sg\n- 参数: [struct af_alg_sgl *sgl]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n16. 函数名: skcipher_pull_sgl\n- 参数: [struct sock *sk, int used]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n17. 函数名: iov_iter_advance\n- 参数: [struct iov_iter *i, size_t size]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n18. 函数名: skcipher_wmem_wakeup\n- 参数: [struct sock *sk]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n19. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: skcipher_recvmsg\n- 被调用者: []"
  },
  {
    "id": 3995,
    "cwe": "CWE-362",
    "cve": "CVE-2023-31083",
    "purpose": "Code purpose:\"\"\"该代码实现了HCI UART TTY设备的IO控制功能，包括设置/获取协议、设置/获取标志等操作，用于管理蓝牙串行通信。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在设置协议标志位HCI_UART_PROTO_SET和实际设置hu->proto之间存在竞态条件，导致HCIUARTGETPROTO可能在hu->proto未设置时被调用，从而引发空指针解引用。\"\"\"",
    "functions": "Functions:\n1. 函数名: hci_uart_tty_ioctl\n- 参数: [tty, cmd, arg]\n- 调用者: 未指定（由TTY子系统调用）\n- 被调用者: [test_and_set_bit, hci_uart_set_proto, clear_bit, test_bit, hci_uart_set_flags, n_tty_ioctl_helper]\n\n2. 函数名: test_and_set_bit\n- 参数: [HCI_UART_PROTO_SET, &hu->flags]\n- 调用者: hci_uart_tty_ioctl\n- 被调用者: []\n\n3. 函数名: hci_uart_set_proto\n- 参数: [hu, arg]\n- 调用者: hci_uart_tty_ioctl\n- 被调用者: []\n\n4. 函数名: clear_bit\n- 参数: [HCI_UART_PROTO_SET, &hu->flags]\n- 调用者: hci_uart_tty_ioctl\n- 被调用者: []\n\n5. 函数名: test_bit\n- 参数: [HCI_UART_PROTO_SET, &hu->flags] 或 [HCI_UART_REGISTERED, &hu->flags]\n- 调用者: hci_uart_tty_ioctl\n- 被调用者: []\n\n6. 函数名: hci_uart_set_flags\n- 参数: [hu, arg]\n- 调用者: hci_uart_tty_ioctl\n- 被调用者: []\n\n7. 函数名: n_tty_ioctl_helper\n- 参数: [tty, cmd, arg]\n- 调用者: hci_uart_tty_ioctl\n- 被调用者: []"
  },
  {
    "id": 4017,
    "cwe": "CWE-362",
    "cve": "CVE-2023-32250",
    "purpose": "Code purpose:\"\"\"释放ksmbd连接结构体中的服务器互斥锁\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_SESSION_SETUP命令时，由于对对象操作缺乏适当的锁保护，导致竞争条件漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: ksmbd_conn_unlock\n- 参数: [struct ksmbd_conn *conn]\n- 调用者: 未明确（需查看完整代码）\n- 被调用者: [mutex_unlock]"
  },
  {
    "id": 4018,
    "cwe": "CWE-362",
    "cve": "CVE-2023-32250",
    "purpose": "Code purpose:\"\"\"该代码片段用于通过获取互斥锁来保护对ksmbd连接结构的并发访问\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_SESSION_SETUP命令时，由于对对象操作缺乏适当的锁定机制，导致并发竞争条件漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: ksmbd_conn_lock\n- 参数: [struct ksmbd_conn *conn]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [mutex_lock]"
  },
  {
    "id": 4019,
    "cwe": "CWE-362",
    "cve": "CVE-2023-32250",
    "purpose": "Code purpose:\"\"\"检查ksmbd连接是否存活，根据服务器状态、会话状态、线程状态、打开文件数和最后活动时间等因素决定是否保持连接\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_SESSION_SETUP命令时，缺乏对对象操作的适当锁定机制，导致竞争条件漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: ksmbd_conn_alive\n- 参数: [struct ksmbd_conn *conn]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [ksmbd_server_running, atomic_read, time_after, ksmbd_debug]\n\n2. 函数名: ksmbd_server_running\n- 参数: []\n- 调用者: ksmbd_conn_alive\n- 被调用者: []\n\n3. 函数名: atomic_read\n- 参数: [&conn->stats.open_files_count]\n- 调用者: ksmbd_conn_alive\n- 被调用者: []\n\n4. 函数名: time_after\n- 参数: [jiffies, conn->last_active + server_conf.deadtime]\n- 调用者: ksmbd_conn_alive\n- 被调用者: []\n\n5. 函数名: ksmbd_debug\n- 参数: [CONN, \"No response from client in %lu minutes\\n\", server_conf.deadtime / SMB_ECHO_INTERVAL]\n- 调用者: ksmbd_conn_alive\n- 被调用者: []"
  },
  {
    "id": 4020,
    "cwe": "CWE-362",
    "cve": "CVE-2023-32250",
    "purpose": "Code purpose:\"\"\"检查SMB连接状态并在连接断开或需要重连时设置错误状态\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_SESSION_SETUP命令时，由于对对象操作缺乏适当的锁保护，导致竞争条件漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: check_conn_state\n- 参数: [struct ksmbd_work *work]\n- 调用者: 未明确（需查看完整代码）\n- 被调用者: [ksmbd_conn_exiting, ksmbd_conn_need_reconnect]\n\n2. 函数名: ksmbd_conn_exiting\n- 参数: [struct ksmbd_work *work]\n- 调用者: check_conn_state\n- 被调用者: []\n\n3. 函数名: ksmbd_conn_need_reconnect\n- 参数: [struct ksmbd_work *work]\n- 调用者: check_conn_state\n- 被调用者: []"
  },
  {
    "id": 4021,
    "cwe": "CWE-362",
    "cve": "CVE-2023-32250",
    "purpose": "Code purpose:\"\"\"处理SMB2协议的协商请求，包括验证请求参数、初始化服务器配置、设置安全模式等，以建立客户端与服务器之间的通信连接。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_SESSION_SETUP命令时，由于缺乏对对象操作的适当锁定机制，导致存在竞争条件漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: smb2_handle_negotiate\n- 参数: [struct ksmbd_work *work]\n- 调用者: 未显示\n- 被调用者: [smb2_get_msg, ksmbd_debug, ksmbd_conn_good, get_rfc1002_len, le32_to_cpu, le16_to_cpu, kzalloc, deassemble_neg_contexts, kfree, init_smb3_11_server, ksmbd_gen_preauth_integrity_hash, cpu_to_le32, assemble_neg_contexts, init_smb3_02_server, init_smb3_0_server, init_smb2_1_server, memset, ksmbd_systime, ksmbd_copy_gss_neg_header, inc_rfc1001_len, smb2_set_err_rsp]\n\n2. 函数名: smb2_get_msg\n- 参数: [work->request_buf, work->response_buf]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n3. 函数名: ksmbd_debug\n- 参数: [SMB, \"Received negotiate request\\n\", \"Server dialect :0x%x not supported\\n\", \"negotiate context offset %d, count %d\\n\"]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n4. 函数名: ksmbd_conn_good\n- 参数: [work]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n5. 函数名: get_rfc1002_len\n- 参数: [work->request_buf]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n6. 函数名: le32_to_cpu\n- 参数: [req->NegotiateContextOffset, req->Capabilities, rsp->NegotiateContextOffset]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n7. 函数名: le16_to_cpu\n- 参数: [req->DialectCount, req->SecurityMode, rsp->SecurityBufferOffset]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n8. 函数名: kzalloc\n- 参数: [sizeof(struct preauth_integrity_info), GFP_KERNEL]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n9. 函数名: deassemble_neg_contexts\n- 参数: [conn, req, get_rfc1002_len(work->request_buf)]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n10. 函数名: kfree\n- 参数: [conn->preauth_info]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n11. 函数名: init_smb3_11_server\n- 参数: [conn]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n12. 函数名: ksmbd_gen_preauth_integrity_hash\n- 参数: [conn, work->request_buf, conn->preauth_info->Preauth_HashValue]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n13. 函数名: cpu_to_le32\n- 参数: [OFFSET_OF_NEG_CONTEXT, conn->vals->capabilities, conn->vals->max_trans_size, conn->vals->max_read_size, conn->vals->max_write_size]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n14. 函数名: assemble_neg_contexts\n- 参数: [conn, rsp, work->response_buf]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n15. 函数名: init_smb3_02_server\n- 参数: [conn]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n16. 函数名: init_smb3_0_server\n- 参数: [conn]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n17. 函数名: init_smb2_1_server\n- 参数: [conn]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n18. 函数名: memset\n- 参数: [rsp->ServerGUID, 0, SMB2_CLIENT_GUID_SIZE]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n19. 函数名: ksmbd_systime\n- 参数: []\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n20. 函数名: ksmbd_copy_gss_neg_header\n- 参数: [(char *)(&rsp->hdr) + le16_to_cpu(rsp->SecurityBufferOffset)]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n21. 函数名: inc_rfc1001_len\n- 参数: [work->response_buf, sizeof(struct smb2_negotiate_rsp) - sizeof(struct smb2_hdr) + AUTH_GSS_LENGTH]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n22. 函数名: smb2_set_err_rsp\n- 参数: [work]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示"
  },
  {
    "id": 4022,
    "cwe": "CWE-362",
    "cve": "CVE-2023-32250",
    "purpose": "Code purpose:\"\"\"销毁与当前用户匹配的先前会话，并标记相关通道状态为退出\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_SESSION_SETUP命令时，对会话对象的操作缺乏适当的锁保护，导致竞争条件可能被利用执行内核代码。\"\"\"",
    "functions": "Functions:\n1. 函数名: destroy_previous_session\n- 参数: [conn, user, id]\n- 调用者: 未显示\n- 被调用者: [ksmbd_session_lookup_slowpath, strcmp, memcmp, xa_for_each]\n\n2. 函数名: ksmbd_session_lookup_slowpath\n- 参数: [id]\n- 调用者: destroy_previous_session\n- 被调用者: 未显示\n\n3. 函数名: strcmp\n- 参数: [user->name, prev_user->name]\n- 调用者: destroy_previous_session\n- 被调用者: 未显示\n\n4. 函数名: memcmp\n- 参数: [user->passkey, prev_user->passkey, user->passkey_sz]\n- 调用者: destroy_previous_session\n- 被调用者: 未显示\n\n5. 函数名: xa_for_each\n- 参数: [&prev_sess->ksmbd_chann_list, index, chann]\n- 调用者: destroy_previous_session\n- 被调用者: 未显示"
  },
  {
    "id": 4023,
    "cwe": "CWE-362",
    "cve": "CVE-2023-32250",
    "purpose": "Code purpose:\"\"\"该代码实现了SMB2协议协商响应的初始化功能，包括设置协议头、协商参数和安全认证相关信息。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_SESSION_SETUP命令时，由于缺乏对对象操作的适当锁定机制，导致存在竞争条件漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: init_smb2_neg_rsp\n- 参数: [struct ksmbd_work *work]\n- 调用者: 未显示\n- 被调用者: [cpu_to_be32, smb2_get_msg, memset, cpu_to_le16, ksmbd_conn_good, ksmbd_debug, cpu_to_le32, cpu_to_le64, ksmbd_systime, ksmbd_copy_gss_neg_header, le16_to_cpu, inc_rfc1001_len, ksmbd_conn_set_need_negotiate]\n\n2. 函数名: cpu_to_be32\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n3. 函数名: smb2_get_msg\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n4. 函数名: memset\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n5. 函数名: cpu_to_le16\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n6. 函数名: ksmbd_conn_good\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n7. 函数名: ksmbd_debug\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n8. 函数名: cpu_to_le32\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n9. 函数名: cpu_to_le64\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n10. 函数名: ksmbd_systime\n- 参数: []\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n11. 函数名: ksmbd_copy_gss_neg_header\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n12. 函数名: le16_to_cpu\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n13. 函数名: inc_rfc1001_len\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n14. 函数名: ksmbd_conn_set_need_negotiate\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []"
  },
  {
    "id": 4024,
    "cwe": "CWE-362",
    "cve": "CVE-2023-32250",
    "purpose": "Code purpose:\"\"\"该代码片段实现了ksmbd内核模块中TCP读取功能，用于处理SMB2协议会话建立命令的数据接收操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_SESSION_SETUP命令时，由于缺乏对对象的适当锁定机制，导致竞争条件漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: ksmbd_tcp_readv\n- 参数: [t, iov_orig, nr_segs, to_read, max_retries]\n- 调用者: N/A\n- 被调用者: [get_conn_iovec, ksmbd_conn_alive, kvec_array_init, kernel_recvmsg, try_to_freeze, usleep_range]\n\n2. 函数名: get_conn_iovec\n- 参数: [t, nr_segs]\n- 调用者: ksmbd_tcp_readv\n- 被调用者: N/A\n\n3. 函数名: ksmbd_conn_alive\n- 参数: [conn]\n- 调用者: ksmbd_tcp_readv\n- 被调用者: N/A\n\n4. 函数名: kvec_array_init\n- 参数: [iov, iov_orig, nr_segs, total_read]\n- 调用者: ksmbd_tcp_readv\n- 被调用者: N/A\n\n5. 函数名: kernel_recvmsg\n- 参数: [t->sock, &ksmbd_msg, iov, segs, to_read, 0]\n- 调用者: ksmbd_tcp_readv\n- 被调用者: N/A\n\n6. 函数名: try_to_freeze\n- 参数: []\n- 调用者: ksmbd_tcp_readv\n- 被调用者: N/A\n\n7. 函数名: usleep_range\n- 参数: [1000, 2000]\n- 调用者: ksmbd_tcp_readv\n- 被调用者: N/A"
  },
  {
    "id": 4033,
    "cwe": "CWE-362",
    "cve": "CVE-2023-32254",
    "purpose": "Code purpose:\"\"\"该代码用于在ksmbd会话中通过ID查找对应的树连接结构体\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_TREE_DISCONNECT命令时，对会话树连接对象的操作缺乏适当的锁保护机制\"\"\"",
    "functions": "Functions:\n1. 函数名: ksmbd_tree_conn_lookup\n- 参数: [sess, id]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [xa_load]\n\n2. 函数名: xa_load\n- 参数: [&sess->tree_conns, id]\n- 调用者: ksmbd_tree_conn_lookup\n- 被调用者: 未明确（内核内部函数）"
  },
  {
    "id": 4057,
    "cwe": "CWE-362",
    "cve": "CVE-2023-33203",
    "purpose": "Code purpose:\"\"\"该代码实现了EMAC网络设备驱动程序的移除功能，包括注销网络设备、清理时钟资源、释放内存映射和网络设备结构等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在emac_remove函数中存在竞态条件，当设备被物理拔出时可能导致use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: emac_remove\n- 参数: [struct platform_device *pdev]\n- 调用者: 平台设备驱动框架\n- 被调用者: [dev_get_drvdata, netdev_priv, unregister_netdev, netif_napi_del, emac_clks_teardown, put_device, mdiobus_unregister, iounmap, free_netdev]\n\n2. 函数名: dev_get_drvdata\n- 参数: [struct device *dev]\n- 调用者: emac_remove\n- 被调用者: []\n\n3. 函数名: netdev_priv\n- 参数: [struct net_device *dev]\n- 调用者: emac_remove\n- 被调用者: []\n\n4. 函数名: unregister_netdev\n- 参数: [struct net_device *dev]\n- 调用者: emac_remove\n- 被调用者: []\n\n5. 函数名: netif_napi_del\n- 参数: [struct napi_struct *napi]\n- 调用者: emac_remove\n- 被调用者: []\n\n6. 函数名: emac_clks_teardown\n- 参数: [struct emac_adapter *adpt]\n- 调用者: emac_remove\n- 被调用者: []\n\n7. 函数名: put_device\n- 参数: [struct device *dev]\n- 调用者: emac_remove\n- 被调用者: []\n\n8. 函数名: mdiobus_unregister\n- 参数: [struct mii_bus *bus]\n- 调用者: emac_remove\n- 被调用者: []\n\n9. 函数名: iounmap\n- 参数: [void *addr]\n- 调用者: emac_remove\n- 被调用者: []\n\n10. 函数名: free_netdev\n- 参数: [struct net_device *dev]\n- 调用者: emac_remove\n- 被调用者: []"
  },
  {
    "id": 4078,
    "cwe": "CWE-362",
    "cve": "CVE-2023-33951",
    "purpose": "Code purpose:\"\"\"该代码用于在vmwgfx驱动中创建一个简单的DRM缓冲区对象(dumb buffer)，处理颜色格式并计算缓冲区大小和步长(pitch)，最终通过GEM对象创建带句柄的缓冲区。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在GEM对象操作时未正确使用锁机制，导致存在竞争条件漏洞，允许本地特权用户在内核上下文中泄露信息\"\"\"",
    "functions": "Functions:\n1. 函数名: vmw_dumb_create\n- 参数: [file_priv, dev, args]\n- 调用者: 未指定（由DRM框架调用）\n- 被调用者: [vmw_priv, DIV_ROUND_UP, ALIGN, vmw_gem_object_create_with_handle]\n\n2. 函数名: vmw_priv\n- 参数: [dev]\n- 调用者: vmw_dumb_create\n- 被调用者: []\n\n3. 函数名: DIV_ROUND_UP\n- 参数: [args->bpp, 8]\n- 调用者: vmw_dumb_create\n- 被调用者: []\n\n4. 函数名: ALIGN\n- 参数: [args->pitch * args->height, PAGE_SIZE]\n- 调用者: vmw_dumb_create\n- 被调用者: []\n\n5. 函数名: vmw_gem_object_create_with_handle\n- 参数: [dev_priv, file_priv, args->size, &args->handle, &vbo]\n- 调用者: vmw_dumb_create\n- 被调用者: []"
  },
  {
    "id": 4079,
    "cwe": "CWE-362",
    "cve": "CVE-2023-33951",
    "purpose": "Code purpose:\"\"\"处理虚拟机图形驱动中用户空间与内核空间之间关于GEM对象的同步CPU操作，包括获取和释放操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在vmwgfx驱动中处理GEM对象时存在竞态条件，由于对对象操作时未正确加锁，导致本地特权用户可能泄露内核上下文信息\"\"\"",
    "functions": "Functions:\n1. 函数名: vmw_user_bo_synccpu_ioctl\n- 参数: [struct drm_device *dev, void *data, struct drm_file *file_priv]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [vmw_user_bo_lookup, vmw_user_bo_synccpu_grab, vmw_bo_unreference, vmw_user_bo_synccpu_release]\n\n2. 函数名: vmw_user_bo_lookup\n- 参数: [struct drm_file *file_priv, unsigned int handle, struct vmw_bo **vbo]\n- 调用者: vmw_user_bo_synccpu_ioctl\n- 被调用者: 未显示\n\n3. 函数名: vmw_user_bo_synccpu_grab\n- 参数: [struct vmw_bo *vbo, unsigned int flags]\n- 调用者: vmw_user_bo_synccpu_ioctl\n- 被调用者: 未显示\n\n4. 函数名: vmw_bo_unreference\n- 参数: [struct vmw_bo **vbo]\n- 调用者: vmw_user_bo_synccpu_ioctl\n- 被调用者: 未显示\n\n5. 函数名: vmw_user_bo_synccpu_release\n- 参数: [struct drm_file *file_priv, unsigned int handle, unsigned int flags]\n- 调用者: vmw_user_bo_synccpu_ioctl\n- 被调用者: 未显示"
  },
  {
    "id": 4080,
    "cwe": "CWE-362",
    "cve": "CVE-2023-33951",
    "purpose": "Code purpose:\"\"\"该代码用于释放VMware图形驱动中用户空间缓冲区对象的CPU同步资源，并处理相关引用计数\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在操作GEM对象时未正确实施锁定机制，导致存在竞争条件漏洞，允许本地特权用户在内核上下文中泄露信息\"\"\"",
    "functions": "Functions:\n1. 函数名: vmw_user_bo_synccpu_release\n- 参数: [struct drm_file *filp, uint32_t handle, uint32_t flags]\n- 调用者: 未指定（由外部调用）\n- 被调用者: [vmw_user_bo_lookup, atomic_dec, ttm_bo_put]\n\n2. 函数名: vmw_user_bo_lookup\n- 参数: [struct drm_file *filp, uint32_t handle, struct vmw_bo **vmw_bo]\n- 调用者: vmw_user_bo_synccpu_release\n- 被调用者: 未指定（可能为内部或外部函数）\n\n3. 函数名: atomic_dec\n- 参数: [atomic_t *v]\n- 调用者: vmw_user_bo_synccpu_release\n- 被调用者: 未指定（原子操作函数）\n\n4. 函数名: ttm_bo_put\n- 参数: [struct ttm_buffer_object *bo]\n- 调用者: vmw_user_bo_synccpu_release\n- 被调用者: 未指定（TTM缓冲区对象管理函数）"
  },
  {
    "id": 4081,
    "cwe": "CWE-362",
    "cve": "CVE-2023-33951",
    "purpose": "Code purpose:\"\"\"将客户机指针转换为虚拟机图形驱动可用的缓冲区对象，并处理相关的重定位信息\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在操作GEM对象时未正确实施锁定机制，导致存在竞争条件漏洞，允许本地特权用户在内核上下文中泄露信息\"\"\"",
    "functions": "Functions:\n1. 函数名: vmw_translate_guest_ptr\n- 参数: [struct vmw_private *dev_priv, struct vmw_sw_context *sw_context, SVGAGuestPtr *ptr, struct vmw_bo **vmw_bo_p]\n- 调用者: N/A\n- 被调用者: [vmw_validation_preload_bo, vmw_user_bo_lookup, drm_dbg, vmw_bo_placement_set, vmw_validation_add_bo, ttm_bo_put, vmw_validation_mem_alloc, list_add_tail]\n\n2. 函数名: vmw_validation_preload_bo\n- 参数: [sw_context->ctx]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: N/A\n\n3. 函数名: vmw_user_bo_lookup\n- 参数: [sw_context->filp, handle, &vmw_bo]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: N/A\n\n4. 函数名: drm_dbg\n- 参数: [&dev_priv->drm, \"Could not find or use GMR region.\"]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: N/A\n\n5. 函数名: vmw_bo_placement_set\n- 参数: [vmw_bo, VMW_BO_DOMAIN_GMR | VMW_BO_DOMAIN_VRAM, VMW_BO_DOMAIN_GMR | VMW_BO_DOMAIN_VRAM]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: N/A\n\n6. 函数名: vmw_validation_add_bo\n- 参数: [sw_context->ctx, vmw_bo]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: N/A\n\n7. 函数名: ttm_bo_put\n- 参数: [&vmw_bo->tbo]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: N/A\n\n8. 函数名: vmw_validation_mem_alloc\n- 参数: [sw_context->ctx, sizeof(*reloc)]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: N/A\n\n9. 函数名: list_add_tail\n- 参数: [&reloc->head, &sw_context->bo_relocations]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: N/A"
  },
  {
    "id": 4082,
    "cwe": "CWE-362",
    "cve": "CVE-2023-33951",
    "purpose": "Code purpose:\"\"\"将用户空间的MOB缓冲区ID转换为内核空间的vmw_bo对象，并建立相关映射关系\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在操作GEM对象时未正确实施锁定机制，导致存在竞争条件漏洞，允许本地特权用户在内核上下文中泄露信息\"\"\"",
    "functions": "Functions:\n1. 函数名: vmw_translate_mob_ptr\n- 参数: [dev_priv, sw_context, id, vmw_bo_p]\n- 调用者: N/A\n- 被调用者: [vmw_validation_preload_bo, vmw_user_bo_lookup, vmw_bo_placement_set, vmw_validation_add_bo, ttm_bo_put, vmw_validation_mem_alloc, list_add_tail]\n\n2. 函数名: vmw_validation_preload_bo\n- 参数: [sw_context->ctx]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: []\n\n3. 函数名: vmw_user_bo_lookup\n- 参数: [sw_context->filp, handle, &vmw_bo]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: []\n\n4. 函数名: vmw_bo_placement_set\n- 参数: [vmw_bo, VMW_BO_DOMAIN_MOB, VMW_BO_DOMAIN_MOB]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: []\n\n5. 函数名: vmw_validation_add_bo\n- 参数: [sw_context->ctx, vmw_bo]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: []\n\n6. 函数名: ttm_bo_put\n- 参数: [&vmw_bo->tbo]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: []\n\n7. 函数名: vmw_validation_mem_alloc\n- 参数: [sw_context->ctx, sizeof(*reloc)]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: []\n\n8. 函数名: list_add_tail\n- 参数: [&reloc->head, &sw_context->bo_relocations]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: []"
  },
  {
    "id": 4083,
    "cwe": "CWE-362",
    "cve": "CVE-2023-33951",
    "purpose": "Code purpose:\"\"\"该代码实现了在vmwgfx驱动中创建GEM对象并返回相关句柄和映射信息的IOCTL接口功能\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在操作GEM对象时未正确使用锁机制，导致存在竞态条件漏洞，可能造成内核信息泄露\"\"\"",
    "functions": "Functions:\n1. 函数名: vmw_gem_object_create_ioctl\n- 参数: [struct drm_device *dev, void *data, struct drm_file *filp]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [vmw_priv, vmw_gem_object_create_with_handle, drm_vma_node_offset_addr]\n\n2. 函数名: vmw_priv\n- 参数: [struct drm_device *dev]\n- 调用者: vmw_gem_object_create_ioctl\n- 被调用者: []\n\n3. 函数名: vmw_gem_object_create_with_handle\n- 参数: [struct vmw_private *dev_priv, struct drm_file *filp, req->size, &handle, &vbo]\n- 调用者: vmw_gem_object_create_ioctl\n- 被调用者: []\n\n4. 函数名: drm_vma_node_offset_addr\n- 参数: [&vbo->tbo.base.vma_node]\n- 调用者: vmw_gem_object_create_ioctl\n- 被调用者: []"
  },
  {
    "id": 4084,
    "cwe": "CWE-362",
    "cve": "CVE-2023-33951",
    "purpose": "Code purpose:\"\"\"该代码用于在vmwgfx驱动中创建和管理帧缓冲对象，处理来自用户空间的帧缓冲创建请求并验证相关参数的有效性。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在操作GEM对象时未正确实施锁定机制，导致存在竞争条件漏洞，允许本地特权用户在内核上下文中泄露信息\"\"\"",
    "functions": "Functions:\n1. 函数名: vmw_kms_fb_create\n- 参数: [struct drm_device *dev, struct drm_file *file_priv, const struct drm_mode_fb_cmd2 *mode_cmd]\n- 调用者: N/A (顶层函数)\n- 被调用者: [vmw_priv, vmw_user_lookup_handle, vmw_kms_srf_ok, vmw_kms_new_framebuffer, vmw_bo_unreference, vmw_surface_unreference]\n\n2. 函数名: vmw_priv\n- 参数: [struct drm_device *dev]\n- 调用者: vmw_kms_fb_create\n- 被调用者: []\n\n3. 函数名: vmw_user_lookup_handle\n- 参数: [struct vmw_private *dev_priv, struct drm_file *file_priv, unsigned int handle, struct vmw_surface **surface, struct vmw_bo **bo]\n- 调用者: vmw_kms_fb_create\n- 被调用者: []\n\n4. 函数名: vmw_kms_srf_ok\n- 参数: [struct vmw_private *dev_priv, unsigned int width, unsigned int height]\n- 调用者: vmw_kms_fb_create\n- 被调用者: []\n\n5. 函数名: vmw_kms_new_framebuffer\n- 参数: [struct vmw_private *dev_priv, struct vmw_bo *bo, struct vmw_surface *surface, bool is_dmabuf_proxy, const struct drm_mode_fb_cmd2 *mode_cmd]\n- 调用者: vmw_kms_fb_create\n- 被调用者: []\n\n6. 函数名: vmw_bo_unreference\n- 参数: [struct vmw_bo **bo]\n- 调用者: vmw_kms_fb_create\n- 被调用者: []\n\n7. 函数名: vmw_surface_unreference\n- 参数: [struct vmw_surface **surface]\n- 调用者: vmw_kms_fb_create\n- 被调用者: []"
  },
  {
    "id": 4085,
    "cwe": "CWE-362",
    "cve": "CVE-2023-33951",
    "purpose": "Code purpose:\"\"\"处理虚拟机图形设备驱动中的覆盖层IOCTL操作，包括流控制的启用/禁用和更新\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在操作GEM对象时未正确实现锁定机制，导致存在竞争条件漏洞，允许本地特权用户在内核上下文中泄露信息\"\"\"",
    "functions": "Functions:\n1. 函数名: vmw_overlay_ioctl\n- 参数: [struct drm_device *dev, void *data, struct drm_file *file_priv]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [vmw_fpriv, vmw_priv, vmw_overlay_available, vmw_user_stream_lookup, mutex_lock, vmw_overlay_stop, vmw_user_bo_lookup, vmw_overlay_update_stream, vmw_bo_unreference, mutex_unlock, vmw_resource_unreference]\n\n2. 函数名: vmw_fpriv\n- 参数: [struct drm_file *file_priv]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: 未显示\n\n3. 函数名: vmw_priv\n- 参数: [struct drm_device *dev]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: 未显示\n\n4. 函数名: vmw_overlay_available\n- 参数: [struct vmw_private *dev_priv]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: 未显示\n\n5. 函数名: vmw_user_stream_lookup\n- 参数: [struct vmw_private *dev_priv, struct ttm_object_file *tfile, &arg->stream_id, &res]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: 未显示\n\n6. 函数名: mutex_lock\n- 参数: [&overlay->mutex]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: 未显示\n\n7. 函数名: vmw_overlay_stop\n- 参数: [struct vmw_private *dev_priv, arg->stream_id, false, true]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: 未显示\n\n8. 函数名: vmw_user_bo_lookup\n- 参数: [file_priv, arg->handle, &buf]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: 未显示\n\n9. 函数名: vmw_overlay_update_stream\n- 参数: [struct vmw_private *dev_priv, buf, arg, true]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: 未显示\n\n10. 函数名: vmw_bo_unreference\n- 参数: [&buf]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: 未显示\n\n11. 函数名: mutex_unlock\n- 参数: [&overlay->mutex]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: 未显示\n\n12. 函数名: vmw_resource_unreference\n- 参数: [&res]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: 未显示"
  },
  {
    "id": 4086,
    "cwe": "CWE-362",
    "cve": "CVE-2023-33951",
    "purpose": "Code purpose:\"\"\"处理虚拟机图形驱动中的着色器定义操作，包括验证输入参数、查找缓冲区对象并根据着色器类型分配相应的着色器资源\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在GEM对象操作过程中未正确实施锁定机制，导致存在竞争条件漏洞，允许本地特权用户在内核上下文中泄露信息。\"\"\"",
    "functions": "Functions:\n1. 函数名: vmw_shader_define\n- 参数: [struct drm_device *dev, struct drm_file *file_priv, enum drm_vmw_shader_type shader_type_drm, u32 buffer_handle, size_t size, size_t offset, uint8_t num_input_sig, uint8_t num_output_sig, uint32_t *shader_handle]\n- 调用者: 未显示（外部调用）\n- 被调用者: [vmw_priv, vmw_fpriv, vmw_user_bo_lookup, VMW_DEBUG_USER, vmw_user_shader_alloc, vmw_bo_unreference]\n\n2. 函数名: vmw_priv\n- 参数: [struct drm_device *dev]\n- 调用者: vmw_shader_define\n- 被调用者: []\n\n3. 函数名: vmw_fpriv\n- 参数: [struct drm_file *file_priv]\n- 调用者: vmw_shader_define\n- 被调用者: []\n\n4. 函数名: vmw_user_bo_lookup\n- 参数: [struct drm_file *file_priv, u32 buffer_handle, struct vmw_bo **buffer]\n- 调用者: vmw_shader_define\n- 被调用者: []\n\n5. 函数名: VMW_DEBUG_USER\n- 参数: [const char *fmt, ...]\n- 调用者: vmw_shader_define\n- 被调用者: []\n\n6. 函数名: vmw_user_shader_alloc\n- 参数: [struct vmw_private *dev_priv, struct vmw_bo *buffer, size_t size, size_t offset, SVGA3dShaderType shader_type, uint8_t num_input_sig, uint8_t num_output_sig, struct ttm_object_file *tfile, uint32_t *shader_handle]\n- 调用者: vmw_shader_define\n- 被调用者: []\n\n7. 函数名: vmw_bo_unreference\n- 参数: [struct vmw_bo **buffer]\n- 调用者: vmw_shader_define\n- 被调用者: []"
  },
  {
    "id": 4109,
    "cwe": "CWE-362",
    "cve": "CVE-2023-35823",
    "purpose": "Code purpose:\"\"\"释放SAA7134视频设备中与传输流(TS)相关的页表资源\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在saa7134_ts_fini函数中释放了dev->ts_q.pt资源后，未将指针置空或确保后续不再被访问，导致潜在的释放后使用漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: saa7134_ts_fini\n- 参数: [struct saa7134_dev *dev]\n- 调用者: 未明确（需查看完整代码上下文）\n- 被调用者: [saa7134_pgtable_free]\n\n2. 函数名: saa7134_pgtable_free\n- 参数: [dev->pci, &dev->ts_q.pt]\n- 调用者: saa7134_ts_fini\n- 被调用者: 未明确（需查看完整代码上下文）"
  },
  {
    "id": 4110,
    "cwe": "CWE-362",
    "cve": "CVE-2023-35823",
    "purpose": "Code purpose:\"\"\"该函数用于释放或清理SAA7134视频捕获设备的VBI相关资源\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"saa7134_vbi_fini函数未正确释放资源导致后续使用时出现use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: saa7134_vbi_fini\n- 参数: [struct saa7134_dev *dev]\n- 调用者: 未提供（上下文不足）\n- 被调用者: []"
  },
  {
    "id": 4111,
    "cwe": "CWE-362",
    "cve": "CVE-2023-35823",
    "purpose": "Code purpose:\"\"\"释放saa7134视频设备相关的资源，包括页表、视频队列、VBI队列和控制处理器\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在saa7134_video_fini函数中存在释放后使用(UAF)问题，由于未正确处理资源释放顺序或同步机制，导致在释放video_q.pt和vbi_q.pt等资源后仍可能被访问。\"\"\"",
    "functions": "Functions:\n1. 函数名: saa7134_video_fini\n- 参数: [struct saa7134_dev *dev]\n- 调用者: 未显示\n- 被调用者: [saa7134_pgtable_free, v4l2_ctrl_handler_free, card_has_radio]\n\n2. 函数名: saa7134_pgtable_free\n- 参数: [dev->pci, &dev->video_q.pt], [dev->pci, &dev->vbi_q.pt]\n- 调用者: saa7134_video_fini\n- 被调用者: 未显示\n\n3. 函数名: v4l2_ctrl_handler_free\n- 参数: [&dev->ctrl_handler], [&dev->radio_ctrl_handler]\n- 调用者: saa7134_video_fini\n- 被调用者: 未显示\n\n4. 函数名: card_has_radio\n- 参数: [dev]\n- 调用者: saa7134_video_fini\n- 被调用者: 未显示"
  },
  {
    "id": 4112,
    "cwe": "CWE-362",
    "cve": "CVE-2023-35824",
    "purpose": "Code purpose:\"\"\"该代码用于在移除dm1105 PCI设备时清理相关资源，包括中断、内存映射、DVB适配器等。\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在dm1105_remove函数中，存在对已释放资源(dmx)的后续操作，导致use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: dm1105_remove\n- 参数: [struct pci_dev *pdev]\n- 调用者: 无（由内核PCI子系统调用）\n- 被调用者: [pci_get_drvdata, dm1105_ir_exit, dvb_net_release, dvb_unregister_frontend, dmx->close, dmx->disconnect_frontend, dmx->remove_frontend, dvb_dmxdev_release, dvb_dmx_release, dvb_unregister_adapter, i2c_del_adapter, dm1105_hw_exit, free_irq, pci_iounmap, pci_release_regions, pci_disable_device, kfree]\n\n2. 函数名: pci_get_drvdata\n- 参数: [struct pci_dev *pdev]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n3. 函数名: dm1105_ir_exit\n- 参数: [struct dm1105_dev *dev]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n4. 函数名: dvb_net_release\n- 参数: [struct dvb_net *dvbnet]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n5. 函数名: dvb_unregister_frontend\n- 参数: [struct dvb_frontend *fe]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n6. 函数名: dmx->close\n- 参数: [struct dmx_demux *dmx]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n7. 函数名: dmx->disconnect_frontend\n- 参数: [struct dmx_demux *dmx]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n8. 函数名: dmx->remove_frontend\n- 参数: [struct dmx_demux *dmx, struct dmx_frontend *frontend]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n9. 函数名: dvb_dmxdev_release\n- 参数: [struct dvb_demux *dvbdemux]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n10. 函数名: dvb_dmx_release\n- 参数: [struct dvb_demux *dvbdemux]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n11. 函数名: dvb_unregister_adapter\n- 参数: [struct dvb_adapter *dvb_adapter]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n12. 函数名: i2c_del_adapter\n- 参数: [struct i2c_adapter *adap]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n13. 函数名: dm1105_hw_exit\n- 参数: [struct dm1105_dev *dev]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n14. 函数名: free_irq\n- 参数: [unsigned int irq, void *dev_id]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n15. 函数名: pci_iounmap\n- 参数: [struct pci_dev *pdev, void __iomem *addr]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n16. 函数名: pci_release_regions\n- 参数: [struct pci_dev *pdev]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n17. 函数名: pci_disable_device\n- 参数: [struct pci_dev *pdev]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n18. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: dm1105_remove\n- 被调用者: 无"
  },
  {
    "id": 4113,
    "cwe": "CWE-362",
    "cve": "CVE-2023-35826",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理Cedrus视频解码器设备的移除操作，包括注销媒体设备、释放资源和清理相关数据结构。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在cedrus_remove函数中，存在对已释放的media设备节点(dev->mdev.devnode)的后续访问，导致use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: cedrus_remove\n- 参数: [struct platform_device *pdev]\n- 调用者: 未显示（由平台驱动框架调用）\n- 被调用者: [platform_get_drvdata, media_devnode_is_registered, media_device_unregister, v4l2_m2m_unregister_media_controller, media_device_cleanup, v4l2_m2m_release, video_unregister_device, v4l2_device_unregister, cedrus_hw_remove]\n\n2. 函数名: platform_get_drvdata\n- 参数: [struct platform_device *pdev]\n- 调用者: cedrus_remove\n- 被调用者: []\n\n3. 函数名: media_devnode_is_registered\n- 参数: [dev->mdev.devnode]\n- 调用者: cedrus_remove\n- 被调用者: []\n\n4. 函数名: media_device_unregister\n- 参数: [&dev->mdev]\n- 调用者: cedrus_remove\n- 被调用者: []\n\n5. 函数名: v4l2_m2m_unregister_media_controller\n- 参数: [dev->m2m_dev]\n- 调用者: cedrus_remove\n- 被调用者: []\n\n6. 函数名: media_device_cleanup\n- 参数: [&dev->mdev]\n- 调用者: cedrus_remove\n- 被调用者: []\n\n7. 函数名: v4l2_m2m_release\n- 参数: [dev->m2m_dev]\n- 调用者: cedrus_remove\n- 被调用者: []\n\n8. 函数名: video_unregister_device\n- 参数: [&dev->vfd]\n- 调用者: cedrus_remove\n- 被调用者: []\n\n9. 函数名: v4l2_device_unregister\n- 参数: [&dev->v4l2_dev]\n- 调用者: cedrus_remove\n- 被调用者: []\n\n10. 函数名: cedrus_hw_remove\n- 参数: [dev]\n- 调用者: cedrus_remove\n- 被调用者: []"
  },
  {
    "id": 4114,
    "cwe": "CWE-362",
    "cve": "CVE-2023-35827",
    "purpose": "Code purpose:\"\"\"关闭网络设备并释放相关资源，包括中断禁用、DMA停止、时间戳列表清理、PHY断开连接和内存释放等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在ravb_close函数中，存在资源释放顺序不当的问题，可能导致在释放中断或DMA资源后，其他代码路径仍尝试访问这些已被释放的资源，从而引发use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: ravb_close\n- 参数: [struct net_device *ndev]\n- 调用者: 未显示\n- 被调用者: [netdev_priv, netif_tx_stop_all_queues, ravb_write, ravb_ptp_stop, ravb_stop_dma, netdev_err, list_for_each_entry_safe, list_del, kfree_skb, kfree, phy_stop, phy_disconnect, of_phy_is_fixed_link, of_phy_deregister_fixed_link, free_irq, napi_disable, ravb_ring_free]\n\n2. 函数名: netdev_priv\n- 参数: [struct net_device *ndev]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n3. 函数名: netif_tx_stop_all_queues\n- 参数: [struct net_device *ndev]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n4. 函数名: ravb_write\n- 参数: [struct net_device *ndev, int value, int reg]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n5. 函数名: ravb_ptp_stop\n- 参数: [struct net_device *ndev]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n6. 函数名: ravb_stop_dma\n- 参数: [struct net_device *ndev]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n7. 函数名: netdev_err\n- 参数: [struct net_device *ndev, const char *fmt, ...]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n8. 函数名: list_for_each_entry_safe\n- 参数: [type *pos, type *n, struct list_head *head, member]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n9. 函数名: list_del\n- 参数: [struct list_head *entry]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n10. 函数名: kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n11. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n12. 函数名: phy_stop\n- 参数: [struct phy_device *phydev]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n13. 函数名: phy_disconnect\n- 参数: [struct phy_device *phydev]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n14. 函数名: of_phy_is_fixed_link\n- 参数: [struct device_node *np]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n15. 函数名: of_phy_deregister_fixed_link\n- 参数: [struct device_node *np]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n16. 函数名: free_irq\n- 参数: [unsigned int irq, void *dev_id]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n17. 函数名: napi_disable\n- 参数: [struct napi_struct *n]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n18. 函数名: ravb_ring_free\n- 参数: [struct net_device *ndev, int queue]\n- 调用者: ravb_close\n- 被调用者: 未显示"
  },
  {
    "id": 4115,
    "cwe": "CWE-362",
    "cve": "CVE-2023-35828",
    "purpose": "Code purpose:\"\"\"该代码实现了Renesas USB3设备驱动在移除时的资源清理功能，包括删除调试文件系统、移除设备属性、注销USB角色切换、删除USB gadget UDC、重置控制、释放DMA资源、释放端点请求以及禁用电源管理等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在设备移除过程中，存在对已释放资源的后续访问，导致了use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: renesas_usb3_remove\n- 参数: [struct platform_device *pdev]\n- 调用者: platform_driver_unregister (间接调用)\n- 被调用者: [platform_get_drvdata, debugfs_remove_recursive, device_remove_file, usb_role_switch_unregister, usb_del_gadget_udc, reset_control_assert, renesas_usb3_dma_free_prd, __renesas_usb3_ep_free_request, pm_runtime_disable]\n\n2. 函数名: platform_get_drvdata\n- 参数: [struct platform_device *pdev]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n3. 函数名: debugfs_remove_recursive\n- 参数: [struct dentry *dentry]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n4. 函数名: device_remove_file\n- 参数: [struct device *dev, const struct device_attribute *attr]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n5. 函数名: usb_role_switch_unregister\n- 参数: [struct usb_role_switch *sw]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n6. 函数名: usb_del_gadget_udc\n- 参数: [struct usb_gadget *gadget]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n7. 函数名: reset_control_assert\n- 参数: [struct reset_control *rstc]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n8. 函数名: renesas_usb3_dma_free_prd\n- 参数: [struct renesas_usb3 *usb3, struct device *dev]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n9. 函数名: __renesas_usb3_ep_free_request\n- 参数: [struct usb_request *req]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n10. 函数名: pm_runtime_disable\n- 参数: [struct device *dev]\n- 调用者: renesas_usb3_remove\n- 被调用者: []"
  },
  {
    "id": 4116,
    "cwe": "CWE-362",
    "cve": "CVE-2023-35829",
    "purpose": "Code purpose:\"\"\"该代码片段实现了Linux内核中rkvdec驱动程序的移除功能，包括清理V4L2相关资源和禁用电源管理功能\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在rkvdec_remove函数中，未正确管理资源释放顺序导致在设备移除时可能发生use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: rkvdec_remove\n- 参数: [struct platform_device *pdev]\n- 调用者: 未明确（通常由平台驱动框架调用）\n- 被调用者: [platform_get_drvdata, rkvdec_v4l2_cleanup, pm_runtime_disable, pm_runtime_dont_use_autosuspend]\n\n2. 函数名: platform_get_drvdata\n- 参数: [struct platform_device *pdev]\n- 调用者: rkvdec_remove\n- 被调用者: []\n\n3. 函数名: rkvdec_v4l2_cleanup\n- 参数: [struct rkvdec_dev *rkvdec]\n- 调用者: rkvdec_remove\n- 被调用者: []\n\n4. 函数名: pm_runtime_disable\n- 参数: [struct device *dev]\n- 调用者: rkvdec_remove\n- 被调用者: []\n\n5. 函数名: pm_runtime_dont_use_autosuspend\n- 参数: [struct device *dev]\n- 调用者: rkvdec_remove\n- 被调用者: []"
  },
  {
    "id": 4208,
    "cwe": "CWE-362",
    "cve": "CVE-2023-42756",
    "purpose": "Code purpose:\"\"\"该代码实现了对IP集合(ipset)的操作调用，包括添加、删除等操作，并处理可能的错误和重试情况，同时支持在批处理模式下返回错误行号信息。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于IPSET_CMD_ADD和IPSET_CMD_SWAP之间的竞争条件导致错误地调用了__ip_set_put，从而引发内核崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: call_ad\n- 参数: [net, ctnl, skb, set, tb, adt, flags, use_lineno]\n- 调用者: (未显示)\n- 被调用者: [__ip_set_get, nfnl_unlock, cond_resched, nfnl_lock, __ip_set_put, ip_set_lock, ip_set_unlock, nlmsg_hdr, nlmsg_new, nlmsg_put, nlmsg_data, unsafe_memcpy, nla_parse, nlmsg_free, nla_data, nfnetlink_unicast]\n\n2. 函数名: __ip_set_get\n- 参数: [set]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n3. 函数名: nfnl_unlock\n- 参数: [NFNL_SUBSYS_IPSET]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n4. 函数名: cond_resched\n- 参数: []\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n5. 函数名: nfnl_lock\n- 参数: [NFNL_SUBSYS_IPSET]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n6. 函数名: __ip_set_put\n- 参数: [set]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n7. 函数名: ip_set_lock\n- 参数: [set]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n8. 函数名: ip_set_unlock\n- 参数: [set]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n9. 函数名: nlmsg_hdr\n- 参数: [skb]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n10. 函数名: nlmsg_new\n- 参数: [payload, GFP_KERNEL]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n11. 函数名: nlmsg_put\n- 参数: [skb2, NETLINK_CB(skb).portid, nlh->nlmsg_seq, NLMSG_ERROR, payload, 0]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n12. 函数名: nlmsg_data\n- 参数: [rep]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n13. 函数名: unsafe_memcpy\n- 参数: [&errmsg->msg, nlh, nlh->nlmsg_len]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n14. 函数名: nla_parse\n- 参数: [cda, IPSET_ATTR_CMD_MAX, cmdattr, nlh->nlmsg_len - min_len, ip_set_adt_policy, NULL]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n15. 函数名: nlmsg_free\n- 参数: [skb2]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n16. 函数名: nla_data\n- 参数: [cda[IPSET_ATTR_LINENO]]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n17. 函数名: nfnetlink_unicast\n- 参数: [skb2, net, NETLINK_CB(skb).portid]\n- 调用者: call_ad\n- 被调用者: (未显示)"
  },
  {
    "id": 4243,
    "cwe": "CWE-362",
    "cve": "CVE-2023-4732",
    "purpose": "Code purpose:\"\"\"该代码用于处理大页内存保护属性的修改，包括NUMA迁移、用户态页错误处理等操作，并确保在多线程环境下的正确同步。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在内存管理子系统中，pfn_swap_entry_to_page函数存在缺陷，导致本地特权攻击者可能通过引用pmd_t x的BUG语句引发拒绝服务问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: change_huge_pmd\n- 参数: [struct vm_area_struct *vma, pmd_t *pmd, unsigned long addr, pgprot_t newprot, unsigned long cp_flags]\n- 调用者: 未明确显示（由内存管理子系统调用）\n- 被调用者: [__pmd_trans_huge_lock, pmd_write, is_swap_pmd, pmd_to_swp_entry, is_pmd_migration_entry, is_write_migration_entry, make_migration_entry_read, swp_entry_to_pmd, pmd_swp_soft_dirty, pmd_swp_mksoft_dirty, set_pmd_at, is_huge_zero_pmd, pmd_protnone, pmdp_invalidate, pmd_modify, pmd_mk_savedwrite, pmd_wrprotect, pmd_mkuffd_wp, pmd_clear_uffd_wp, vma_is_anonymous, spin_unlock]\n\n2. 函数名: __pmd_trans_huge_lock\n- 参数: [pmd_t *pmd, struct vm_area_struct *vma]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n3. 函数名: pmd_write\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n4. 函数名: is_swap_pmd\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n5. 函数名: pmd_to_swp_entry\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n6. 函数名: is_pmd_migration_entry\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n7. 函数名: is_write_migration_entry\n- 参数: [swp_entry_t entry]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n8. 函数名: make_migration_entry_read\n- 参数: [swp_entry_t *entry]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n9. 函数名: swp_entry_to_pmd\n- 参数: [swp_entry_t entry]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n10. 函数名: pmd_swp_soft_dirty\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n11. 函数名: pmd_swp_mksoft_dirty\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n12. 函数名: set_pmd_at\n- 参数: [struct mm_struct *mm, unsigned long addr, pmd_t *pmd, pmd_t entry]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n13. 函数名: is_huge_zero_pmd\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n14. 函数名: pmd_protnone\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n15. 函数名: pmdp_invalidate\n- 参数: [struct vm_area_struct *vma, unsigned long addr, pmd_t *pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n16. 函数名: pmd_modify\n- 参数: [pmd_t pmd, pgprot_t newprot]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n17. 函数名: pmd_mk_savedwrite\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n18. 函数名: pmd_wrprotect\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n19. 函数名: pmd_mkuffd_wp\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n20. 函数名: pmd_clear_uffd_wp\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n21. 函数名: vma_is_anonymous\n- 参数: [struct vm_area_struct *vma]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n22. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: change_huge_pmd\n- 被调用者: []"
  },
  {
    "id": 4244,
    "cwe": "CWE-362",
    "cve": "CVE-2023-4732",
    "purpose": "Code purpose:\"\"\"该代码用于处理内存迁移过程中大页(PMD)的移除和替换操作，包括页表项更新、缓存刷新和内存映射维护等功能。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在内存管理子系统中，pfn_swap_entry_to_page函数处理pmd_t类型的交换条目时存在缺陷，导致本地特权攻击者可能通过触发BUG语句引发拒绝服务问题\"\"\"",
    "functions": "Functions:\n1. 函数名: remove_migration_pmd\n- 参数: [pvmw, new]\n- 调用者: N/A\n- 被调用者: [pmd_to_swp_entry, get_page, pmd_mkold, mk_huge_pmd, pmd_swp_soft_dirty, pmd_mksoft_dirty, is_write_migration_entry, maybe_pmd_mkwrite, flush_cache_range, PageAnon, page_add_anon_rmap, page_add_file_rmap, set_pmd_at, PageDoubleMap, mlock_vma_page, update_mmu_cache_pmd]\n\n2. 函数名: pmd_to_swp_entry\n- 参数: [*pvmw->pmd]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n3. 函数名: get_page\n- 参数: [new]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n4. 函数名: pmd_mkold\n- 参数: [mk_huge_pmd(new, vma->vm_page_prot)]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n5. 函数名: mk_huge_pmd\n- 参数: [new, vma->vm_page_prot]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n6. 函数名: pmd_swp_soft_dirty\n- 参数: [*pvmw->pmd]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n7. 函数名: pmd_mksoft_dirty\n- 参数: [pmde]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n8. 函数名: is_write_migration_entry\n- 参数: [entry]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n9. 函数名: maybe_pmd_mkwrite\n- 参数: [pmde, vma]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n10. 函数名: flush_cache_range\n- 参数: [vma, mmun_start, mmun_start + HPAGE_PMD_SIZE]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n11. 函数名: PageAnon\n- 参数: [new]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n12. 函数名: page_add_anon_rmap\n- 参数: [new, vma, mmun_start, true]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n13. 函数名: page_add_file_rmap\n- 参数: [new, true]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n14. 函数名: set_pmd_at\n- 参数: [mm, mmun_start, pvmw->pmd, pmde]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n15. 函数名: PageDoubleMap\n- 参数: [new]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n16. 函数名: mlock_vma_page\n- 参数: [new]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n17. 函数名: update_mmu_cache_pmd\n- 参数: [vma, address, pvmw->pmd]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A"
  },
  {
    "id": 4245,
    "cwe": "CWE-362",
    "cve": "CVE-2023-4732",
    "purpose": "Code purpose:\"\"\"该代码用于在内存管理子系统中复制当前页表条目(PTE)，处理写保护、共享映射和用户态页错误处理等特性，实现虚拟内存页的复制功能\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在内存管理子系统中处理交换页表项时未正确验证pmd_t类型，导致本地攻击者可能通过触发BUG语句引发拒绝服务问题\"\"\"",
    "functions": "Functions:\n1. 函数名: copy_present_pte\n- 参数: [dst_vma, src_vma, dst_pte, src_pte, addr, rss, prealloc]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [vm_normal_page, copy_present_page, get_page, page_dup_rmap, is_cow_mapping, pte_write, ptep_set_wrprotect, pte_wrprotect, pte_mkclean, pte_mkold, pte_clear_uffd_wp, set_pte_at]\n\n2. 函数名: vm_normal_page\n- 参数: [src_vma, addr, pte]\n- 调用者: copy_present_pte\n- 被调用者: []\n\n3. 函数名: copy_present_page\n- 参数: [dst_vma, src_vma, dst_pte, src_pte, addr, rss, prealloc, pte, page]\n- 调用者: copy_present_pte\n- 被调用者: []\n\n4. 函数名: get_page\n- 参数: [page]\n- 调用者: copy_present_pte\n- 被调用者: []\n\n5. 函数名: page_dup_rmap\n- 参数: [page, false]\n- 调用者: copy_present_pte\n- 被调用者: []\n\n6. 函数名: is_cow_mapping\n- 参数: [vm_flags]\n- 调用者: copy_present_pte\n- 被调用者: []\n\n7. 函数名: pte_write\n- 参数: [pte]\n- 调用者: copy_present_pte\n- 被调用者: []\n\n8. 函数名: ptep_set_wrprotect\n- 参数: [src_mm, addr, src_pte]\n- 调用者: copy_present_pte\n- 被调用者: []\n\n9. 函数名: pte_wrprotect\n- 参数: [pte]\n- 调用者: copy_present_pte\n- 被调用者: []\n\n10. 函数名: pte_mkclean\n- 参数: [pte]\n- 调用者: copy_present_pte\n- 被调用者: []\n\n11. 函数名: pte_mkold\n- 参数: [pte]\n- 调用者: copy_present_pte\n- 被调用者: []\n\n12. 函数名: pte_clear_uffd_wp\n- 参数: [pte]\n- 调用者: copy_present_pte\n- 被调用者: []\n\n13. 函数名: set_pte_at\n- 参数: [dst_vma->vm_mm, addr, dst_pte, pte]\n- 调用者: copy_present_pte\n- 被调用者: []"
  },
  {
    "id": 4246,
    "cwe": "CWE-362",
    "cve": "CVE-2023-4732",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核内存管理子系统中复制进程地址空间的PMD(页中间目录)范围，处理大页和普通页的复制操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在内存管理子系统中处理交换页表项时，对pmd_t类型的引用存在缺陷，导致本地特权攻击者可能通过触发BUG语句引发拒绝服务问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: copy_pmd_range\n- 参数: [dst_vma, src_vma, dst_pud, src_pud, addr, end]\n- 调用者: 未明确（由内核内存管理子系统调用）\n- 被调用者: [pmd_alloc, pmd_offset, pmd_addr_end, is_swap_pmd, pmd_trans_huge, pmd_devmap, copy_huge_pmd, pmd_none_or_clear_bad, copy_pte_range]\n\n2. 函数名: pmd_alloc\n- 参数: [dst_mm, dst_pud, addr]\n- 调用者: copy_pmd_range\n- 被调用者: []\n\n3. 函数名: pmd_offset\n- 参数: [src_pud, addr]\n- 调用者: copy_pmd_range\n- 被调用者: []\n\n4. 函数名: pmd_addr_end\n- 参数: [addr, end]\n- 调用者: copy_pmd_range\n- 被调用者: []\n\n5. 函数名: is_swap_pmd\n- 参数: [*src_pmd]\n- 调用者: copy_pmd_range\n- 被调用者: []\n\n6. 函数名: pmd_trans_huge\n- 参数: [*src_pmd]\n- 调用者: copy_pmd_range\n- 被调用者: []\n\n7. 函数名: pmd_devmap\n- 参数: [*src_pmd]\n- 调用者: copy_pmd_range\n- 被调用者: []\n\n8. 函数名: copy_huge_pmd\n- 参数: [dst_mm, src_mm, dst_pmd, src_pmd, addr, src_vma]\n- 调用者: copy_pmd_range\n- 被调用者: []\n\n9. 函数名: pmd_none_or_clear_bad\n- 参数: [src_pmd]\n- 调用者: copy_pmd_range\n- 被调用者: []\n\n10. 函数名: copy_pte_range\n- 参数: [dst_vma, src_vma, dst_pmd, src_pmd, addr, next]\n- 调用者: copy_pmd_range\n- 被调用者: []"
  },
  {
    "id": 4247,
    "cwe": "CWE-362",
    "cve": "CVE-2023-4732",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核内存管理子系统中复制进程地址空间中的页表项(PTE)范围，处理包括正常页表项和交换页表项的复制操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在内存管理子系统中，pfn_swap_entry_to_page函数处理交换条目时存在缺陷，导致本地特权攻击者可能通过引用pmd_t x触发BUG语句造成拒绝服务\"\"\"",
    "functions": "Functions:\n1. 函数名: copy_pte_range\n- 参数: [struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma, pmd_t *dst_pmd, pmd_t *src_pmd, unsigned long addr, unsigned long end]\n- 调用者: N/A (顶级函数)\n- 被调用者: [pte_alloc_map_lock, pte_offset_map, pte_lockptr, spin_lock_nested, arch_enter_lazy_mmu_mode, need_resched, spin_needbreak, pte_none, pte_present, copy_nonpresent_pte, copy_present_pte, put_page, arch_leave_lazy_mmu_mode, spin_unlock, pte_unmap, add_mm_rss_vec, pte_unmap_unlock, cond_resched, add_swap_count_continuation, page_copy_prealloc]\n\n2. 函数名: pte_alloc_map_lock\n- 参数: [struct mm_struct *dst_mm, pmd_t *dst_pmd, unsigned long addr, spinlock_t **dst_ptl]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n3. 函数名: pte_offset_map\n- 参数: [pmd_t *src_pmd, unsigned long addr]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n4. 函数名: pte_lockptr\n- 参数: [struct mm_struct *src_mm, pmd_t *src_pmd]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n5. 函数名: spin_lock_nested\n- 参数: [spinlock_t *src_ptl, int SINGLE_DEPTH_NESTING]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n6. 函数名: arch_enter_lazy_mmu_mode\n- 参数: []\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n7. 函数名: need_resched\n- 参数: []\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n8. 函数名: spin_needbreak\n- 参数: [spinlock_t *src_ptl/dst_ptl]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n9. 函数名: pte_none\n- 参数: [pte_t *src_pte]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n10. 函数名: pte_present\n- 参数: [pte_t *src_pte]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n11. 函数名: copy_nonpresent_pte\n- 参数: [struct mm_struct *dst_mm, struct mm_struct *src_mm, pte_t *dst_pte, pte_t *src_pte, struct vm_area_struct *src_vma, unsigned long addr, int *rss]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n12. 函数名: copy_present_pte\n- 参数: [struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma, pte_t *dst_pte, pte_t *src_pte, unsigned long addr, int *rss, struct page **prealloc]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n13. 函数名: put_page\n- 参数: [struct page *prealloc]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n14. 函数名: arch_leave_lazy_mmu_mode\n- 参数: []\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n15. 函数名: spin_unlock\n- 参数: [spinlock_t *src_ptl]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n16. 函数名: pte_unmap\n- 参数: [pte_t *orig_src_pte]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n17. 函数名: add_mm_rss_vec\n- 参数: [struct mm_struct *dst_mm, int *rss]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n18. 函数名: pte_unmap_unlock\n- 参数: [pte_t *orig_dst_pte, spinlock_t *dst_ptl]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n19. 函数名: cond_resched\n- 参数: []\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n20. 函数名: add_swap_count_continuation\n- 参数: [swp_entry_t entry, gfp_t GFP_KERNEL]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n21. 函数名: page_copy_prealloc\n- 参数: [struct mm_struct *src_mm, struct vm_area_struct *src_vma, unsigned long addr]\n- 调用者: copy_pte_range\n- 被调用者: N/A"
  },
  {
    "id": 4248,
    "cwe": "CWE-362",
    "cve": "CVE-2023-4732",
    "purpose": "Code purpose:\"\"\"该代码片段的核心功能是在内存管理子系统中处理页面复制操作，特别是针对可能被父进程固定的页面进行特殊处理，确保这些页面不会被随机替换。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于内存管理子系统中的pfn_swap_entry_to_page函数在处理交换条目到页面的转换时，错误地引用了pmd_t类型导致内核触发BUG语句，造成拒绝服务漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: copy_present_page\n- 参数: [dst_vma, src_vma, dst_pte, src_pte, addr, rss, prealloc, pte, page]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [page_needs_cow_for_dma, copy_user_highpage, __SetPageUptodate, page_add_new_anon_rmap, lru_cache_add_inactive_or_unevictable, mk_pte, maybe_mkwrite, pte_mkdirty, set_pte_at]\n\n2. 函数名: page_needs_cow_for_dma\n- 参数: [src_vma, page]\n- 调用者: copy_present_page\n- 被调用者: 未明确\n\n3. 函数名: copy_user_highpage\n- 参数: [new_page, page, addr, src_vma]\n- 调用者: copy_present_page\n- 被调用者: 未明确\n\n4. 函数名: __SetPageUptodate\n- 参数: [new_page]\n- 调用者: copy_present_page\n- 被调用者: 未明确\n\n5. 函数名: page_add_new_anon_rmap\n- 参数: [new_page, dst_vma, addr, false]\n- 调用者: copy_present_page\n- 被调用者: 未明确\n\n6. 函数名: lru_cache_add_inactive_or_unevictable\n- 参数: [new_page, dst_vma]\n- 调用者: copy_present_page\n- 被调用者: 未明确\n\n7. 函数名: mk_pte\n- 参数: [new_page, dst_vma->vm_page_prot]\n- 调用者: copy_present_page\n- 被调用者: 未明确\n\n8. 函数名: maybe_mkwrite\n- 参数: [pte_mkdirty(pte), dst_vma]\n- 调用者: copy_present_page\n- 被调用者: 未明确\n\n9. 函数名: pte_mkdirty\n- 参数: [pte]\n- 调用者: copy_present_page\n- 被调用者: 未明确\n\n10. 函数名: set_pte_at\n- 参数: [dst_vma->vm_mm, addr, dst_pte, pte]\n- 调用者: copy_present_page\n- 被调用者: 未明确"
  },
  {
    "id": 4302,
    "cwe": "CWE-362",
    "cve": "CVE-2023-6546",
    "purpose": "Code purpose:\"\"\"清理和释放GSM多路复用器(mux)相关的资源，包括关闭数据链路连接接口(DLCI)、停止定时器、刷新工作队列以及释放内存等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当两个线程同时执行GSMIOC_SETCONF ioctl操作时，由于缺乏适当的同步机制，导致在重启gsm mux过程中出现竞争条件，可能引发对已释放的struct gsm_dlci结构的use-after-free问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: gsm_cleanup_mux\n- 参数: [struct gsm_mux *gsm, bool disc]\n- 调用者: 未显示\n- 被调用者: [mutex_lock, gsm_dlci_begin_close, wait_event, del_timer_sync, flush_work, gsm_unregister_devices, gsm_dlci_release, mutex_unlock, tty_ldisc_flush, list_for_each_entry_safe, kfree, INIT_LIST_HEAD]\n\n2. 函数名: mutex_lock\n- 参数: [&gsm->mutex]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示\n\n3. 函数名: gsm_dlci_begin_close\n- 参数: [dlci]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示\n\n4. 函数名: wait_event\n- 参数: [gsm->event, dlci->state == DLCI_CLOSED]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示\n\n5. 函数名: del_timer_sync\n- 参数: [&gsm->kick_timer], [&gsm->t2_timer], [&gsm->ka_timer]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示\n\n6. 函数名: flush_work\n- 参数: [&gsm->tx_work]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示\n\n7. 函数名: gsm_unregister_devices\n- 参数: [gsm_tty_driver, gsm->num]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示\n\n8. 函数名: gsm_dlci_release\n- 参数: [gsm->dlci[i]]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示\n\n9. 函数名: mutex_unlock\n- 参数: [&gsm->mutex]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示\n\n10. 函数名: tty_ldisc_flush\n- 参数: [gsm->tty]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示\n\n11. 函数名: list_for_each_entry_safe\n- 参数: [txq, ntxq, &gsm->tx_ctrl_list, list], [txq, ntxq, &gsm->tx_data_list, list]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示\n\n12. 函数名: kfree\n- 参数: [txq]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示\n\n13. 函数名: INIT_LIST_HEAD\n- 参数: [&gsm->tx_ctrl_list], [&gsm->tx_data_list]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示"
  },
  {
    "id": 428,
    "cwe": "CWE-416",
    "cve": "CVE-2014-0100",
    "purpose": "Code purpose:\"\"\"该代码用于在网络碎片重组过程中管理碎片队列，通过哈希表查找或创建新的队列项，并处理并发访问的竞争条件\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在inet_frag_intern函数中存在竞态条件，当系统CPU负载高时，攻击者通过发送大量分片ICMP Echo请求包可能导致使用后释放错误\"\"\"",
    "functions": "Functions:\n1. 函数名: inet_frag_intern\n- 参数: [struct netns_frags *nf, struct inet_frag_queue *qp_in, struct inet_frags *f, void *arg]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [atomic_inc, mod_timer, hlist_add_head, inet_frag_put, inet_frag_lru_add, read_lock, read_unlock, spin_lock, spin_unlock, f->hashfn, f->match]\n\n2. 函数名: atomic_inc\n- 参数: [atomic_t *v]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n3. 函数名: mod_timer\n- 参数: [struct timer_list *timer, unsigned long expires]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n4. 函数名: hlist_add_head\n- 参数: [struct hlist_node *n, struct hlist_head *h]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n5. 函数名: inet_frag_put\n- 参数: [struct inet_frag_queue *q, struct inet_frags *f]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n6. 函数名: inet_frag_lru_add\n- 参数: [struct netns_frags *nf, struct inet_frag_queue *qp]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n7. 函数名: read_lock\n- 参数: [rwlock_t *lock]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n8. 函数名: read_unlock\n- 参数: [rwlock_t *lock]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n9. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n10. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n11. 函数名: f->hashfn\n- 参数: [struct inet_frag_queue *qp_in]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n12. 函数名: f->match\n- 参数: [struct inet_frag_queue *qp, void *arg]\n- 调用者: inet_frag_intern\n- 被调用者: []"
  },
  {
    "id": 431,
    "cwe": "CWE-416",
    "cve": "CVE-2014-0131",
    "purpose": "Code purpose:\"\"\"该代码用于在网络数据包分段处理时，将一个大的sk_buff结构分割成多个小的sk_buff结构，以支持网络设备的分散/聚集(Scatter/Gather)功能。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在skb_segment函数中处理网络数据包分段时，由于缺少对sk_buff结构的适当孤立操作，导致可能发生释放后重用(use-after-free)的情况，从而允许攻击者获取内核内存中的敏感信息。\"\"\"",
    "functions": "Functions:\n1. 函数名: skb_segment\n- 参数: [head_skb, features]\n- 调用者: N/A (top-level function)\n- 被调用者: [skb_shinfo, skb_mac_header, skb_tnl_header_len, skb_network_protocol, can_checksum_protocol, __skb_push, skb_headroom, skb_headlen, skb_clone, pskb_trim, kfree_skb, skb_end_offset, skb_cow_head, skb_release_head_state, __alloc_skb, skb_reserve, __skb_put, __copy_skb_header, skb_headers_offset_update, skb_copy_from_linear_data_offset, skb_copy_and_csum_bits, skb_put, skb_checksum, kfree_skb_list]\n\n2. 函数名: skb_shinfo\n- 参数: [skb]\n- 调用者: skb_segment\n- 被调用者: []\n\n3. 函数名: skb_mac_header\n- 参数: [skb]\n- 调用者: skb_segment\n- 被调用者: []\n\n4. 函数名: skb_tnl_header_len\n- 参数: [skb]\n- 调用者: skb_segment\n- 被调用者: []\n\n5. 函数名: skb_network_protocol\n- 参数: [skb]\n- 调用者: skb_segment\n- 被调用者: []\n\n6. 函数名: can_checksum_protocol\n- 参数: [features, proto]\n- 调用者: skb_segment\n- 被调用者: []\n\n7. 函数名: __skb_push\n- 参数: [skb, len]\n- 调用者: skb_segment\n- 被调用者: []\n\n8. 函数名: skb_headroom\n- 参数: [skb]\n- 调用者: skb_segment\n- 被调用者: []\n\n9. 函数名: skb_headlen\n- 参数: [skb]\n- 调用者: skb_segment\n- 被调用者: []\n\n10. 函数名: skb_clone\n- 参数: [skb, gfp_mask]\n- 调用者: skb_segment\n- 被调用者: []\n\n11. 函数名: pskb_trim\n- 参数: [skb, len]\n- 调用者: skb_segment\n- 被调用者: []\n\n12. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: skb_segment\n- 被调用者: []\n\n13. 函数名: skb_end_offset\n- 参数: [skb]\n- 调用者: skb_segment\n- 被调用者: []\n\n14. 函数名: skb_cow_head\n- 参数: [skb, headroom]\n- 调用者: skb_segment\n- 被调用者: []\n\n15. 函数名: skb_release_head_state\n- 参数: [skb]\n- 调用者: skb_segment\n- 被调用者: []\n\n16. 函数名: __alloc_skb\n- 参数: [size, priority, flags, node]\n- 调用者: skb_segment\n- 被调用者: []\n\n17. 函数名: skb_reserve\n- 参数: [skb, len]\n- 调用者: skb_segment\n- 被调用者: []\n\n18. 函数名: __skb_put\n- 参数: [skb, len]\n- 调用者: skb_segment\n- 被调用者: []\n\n19. 函数名: __copy_skb_header\n- 参数: [new, old]\n- 调用者: skb_segment\n- 被调用者: []\n\n20. 函数名: skb_headers_offset_update\n- 参数: [skb, offset]\n- 调用者: skb_segment\n- 被调用者: []\n\n21. 函数名: skb_copy_from_linear_data_offset\n- 参数: [skb, offset, to, len]\n- 调用者: skb_segment\n- 被调用者: []\n\n22. 函数名: skb_copy_and_csum_bits\n- 参数: [skb, offset, to, len, csum]\n- 调用者: skb_segment\n- 被调用者: []\n\n23. 函数名: skb_put\n- 参数: [skb, len]\n- 调用者: skb_segment\n- 被调用者: []\n\n24. 函数名: skb_checksum\n- 参数: [skb, offset, len, csum]\n- 调用者: skb_segment\n- 被调用者: []\n\n25. 函数名: kfree_skb_list\n- 参数: [segs]\n- 调用者: skb_segment\n- 被调用者: []"
  },
  {
    "id": 462,
    "cwe": "CWE-416",
    "cve": "CVE-2014-0203",
    "purpose": "Code purpose:\"\"\"该代码用于在内核中处理符号链接的跟随操作，确保正确解析路径并访问目标文件。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在2.6.33版本前的__do_follow_link函数中，对某些文件系统最后一个路径组件的处理不当，导致本地用户可通过open系统调用触发错误的释放操作和系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: __do_follow_link\n- 参数: [struct path *path, struct nameidata *nd]\n- 调用者: 未明确（通常是内核中的路径查找相关函数）\n- 被调用者: [touch_atime, nd_set_link, path_to_nameidata, dget, mntget, PTR_ERR, IS_ERR, nd_get_link, __vfs_follow_link, force_reval_path, path_put]\n\n2. 函数名: touch_atime\n- 参数: [struct vfsmount *mnt, struct dentry *dentry]\n- 调用者: __do_follow_link\n- 被调用者: []\n\n3. 函数名: nd_set_link\n- 参数: [struct nameidata *nd, void *ptr]\n- 调用者: __do_follow_link\n- 被调用者: []\n\n4. 函数名: path_to_nameidata\n- 参数: [struct path *path, struct nameidata *nd]\n- 调用者: __do_follow_link\n- 被调用者: []\n\n5. 函数名: dget\n- 参数: [struct dentry *dentry]\n- 调用者: __do_follow_link\n- 被调用者: []\n\n6. 函数名: mntget\n- 参数: [struct vfsmount *mnt]\n- 调用者: __do_follow_link\n- 被调用者: []\n\n7. 函数名: PTR_ERR\n- 参数: [void *ptr]\n- 调用者: __do_follow_link\n- 被调用者: []\n\n8. 函数名: IS_ERR\n- 参数: [void *ptr]\n- 调用者: __do_follow_link\n- 被调用者: []\n\n9. 函数名: nd_get_link\n- 参数: [struct nameidata *nd]\n- 调用者: __do_follow_link\n- 被调用者: []\n\n10. 函数名: __vfs_follow_link\n- 参数: [struct nameidata *nd, char *name]\n- 调用者: __do_follow_link\n- 被调用者: []\n\n11. 函数名: force_reval_path\n- 参数: [struct path *path, struct nameidata *nd]\n- 调用者: __do_follow_link\n- 被调用者: []\n\n12. 函数名: path_put\n- 参数: [struct path *path]\n- 调用者: __do_follow_link\n- 被调用者: []"
  },
  {
    "id": 463,
    "cwe": "CWE-416",
    "cve": "CVE-2014-0203",
    "purpose": "Code purpose:\"\"\"处理/proc文件系统中进程ID符号链接的跟随操作，并检查文件描述符访问权限\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"内核在处理某些文件系统的最后一个路径组件时未正确释放资源，导致可被本地用户利用造成系统崩溃\"\"\"",
    "functions": "Functions:\n1. 函数名: proc_pid_follow_link\n- 参数: [dentry, nd]\n- 调用者: 未指定（由内核调用）\n- 被调用者: [path_put, proc_fd_access_allowed, PROC_I, ERR_PTR]\n\n2. 函数名: path_put\n- 参数: [&nd->path]\n- 调用者: proc_pid_follow_link\n- 被调用者: []\n\n3. 函数名: proc_fd_access_allowed\n- 参数: [inode]\n- 调用者: proc_pid_follow_link\n- 被调用者: []\n\n4. 函数名: PROC_I\n- 参数: [inode]\n- 调用者: proc_pid_follow_link\n- 被调用者: []\n\n5. 函数名: ERR_PTR\n- 参数: [error]\n- 调用者: proc_pid_follow_link\n- 被调用者: []"
  },
  {
    "id": 484,
    "cwe": "CWE-416",
    "cve": "CVE-2014-2568",
    "purpose": "Code purpose:\"\"\"构建并发送包含网络数据包信息的Netlink消息，用于内核与用户空间之间的通信\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"内核在skb_zerocopy操作中未正确执行内存引用计数管理，导致释放后重用漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: nfqnl_build_packet_message\n- 参数: [net, queue, entry, packet_id_ptr]\n- 调用者: 未显示\n- 被调用者: [nlmsg_total_size, nla_total_size, skb_csum_unnecessary, ACCESS_ONCE, skb_checksum_help, skb_zerocopy_headlen, min_t, nfqnl_ct_get, nfnetlink_alloc_skb, nlmsg_put, kfree_skb, nlmsg_data, __nla_reserve, nla_data, nla_put_be32, br_port_get_rcu, dev_parse_header, ktime_to_timeval, nfqnl_put_sk_uidgid, nfqnl_ct_put, nfqnl_put_packet_info, skb_tailroom, skb_put, skb_zerocopy]\n\n2. 函数名: nlmsg_total_size\n- 参数: [size]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n3. 函数名: nla_total_size\n- 参数: [size]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n4. 函数名: skb_csum_unnecessary\n- 参数: [entskb]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n5. 函数名: ACCESS_ONCE\n- 参数: [queue->copy_mode]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n6. 函数名: skb_checksum_help\n- 参数: [entskb]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n7. 函数名: skb_zerocopy_headlen\n- 参数: [entskb]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n8. 函数名: min_t\n- 参数: [unsigned int, hlen, data_len]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n9. 函数名: nfqnl_ct_get\n- 参数: [entskb, &size, &ctinfo]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n10. 函数名: nfnetlink_alloc_skb\n- 参数: [net, size, queue->peer_portid, GFP_ATOMIC]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n11. 函数名: nlmsg_put\n- 参数: [skb, 0, 0, NFNL_SUBSYS_QUEUE << 8 | NFQNL_MSG_PACKET, sizeof(struct nfgenmsg), 0]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n12. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n13. 函数名: nlmsg_data\n- 参数: [nlh]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n14. 函数名: __nla_reserve\n- 参数: [skb, NFQA_PACKET_HDR, sizeof(*pmsg)]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n15. 函数名: nla_data\n- 参数: [nla]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n16. 函数名: nla_put_be32\n- 参数: [skb, NFQA_IFINDEX_INDEV, htonl(indev->ifindex)]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n17. 函数名: br_port_get_rcu\n- 参数: [indev]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n18. 函数名: dev_parse_header\n- 参数: [entskb, phw.hw_addr]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n19. 函数名: ktime_to_timeval\n- 参数: [entskb->tstamp]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n20. 函数名: nfqnl_put_sk_uidgid\n- 参数: [skb, entskb->sk]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n21. 函数名: nfqnl_ct_put\n- 参数: [skb, ct, ctinfo]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n22. 函数名: nfqnl_put_packet_info\n- 参数: [skb, entskb, csum_verify]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n23. 函数名: skb_tailroom\n- 参数: [skb]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n24. 函数名: skb_put\n- 参数: [skb, sizeof(*nla)]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n25. 函数名: skb_zerocopy\n- 参数: [skb, entskb, data_len, hlen]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []"
  },
  {
    "id": 485,
    "cwe": "CWE-416",
    "cve": "CVE-2014-2568",
    "purpose": "Code purpose:\"\"\"将网络数据包从内核空间通过Netlink套接字安全地传递到用户空间，同时处理VLAN标签、校验和以及内存对齐等网络数据包特性\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"内核在skb_zerocopy操作中未正确处理skb缓冲区的引用计数，导致释放后重用漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: queue_userspace_packet\n- 参数: [dp, skb, upcall_info]\n- 调用者: N/A (顶层函数)\n- 被调用者: [get_dpifindex, skb_clone, __vlan_put_tag, vlan_tx_tag_present, vlan_tx_tag_get, nla_attr_size, skb_checksum_help, skb_zerocopy_headlen, upcall_msg_size, genlmsg_new_unicast, genlmsg_put, nla_nest_start, ovs_nla_put_flow, nla_nest_end, __nla_put, nla_reserve, skb_zerocopy, skb_put, genlmsg_unicast, kfree_skb]\n\n2. 函数名: get_dpifindex\n- 参数: [dp]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n3. 函数名: skb_clone\n- 参数: [skb, GFP_ATOMIC]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n4. 函数名: __vlan_put_tag\n- 参数: [nskb, nskb->vlan_proto, vlan_tx_tag_get(nskb)]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n5. 函数名: vlan_tx_tag_present\n- 参数: [skb]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n6. 函数名: vlan_tx_tag_get\n- 参数: [nskb]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n7. 函数名: nla_attr_size\n- 参数: [skb->len]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n8. 函数名: skb_checksum_help\n- 参数: [skb]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n9. 函数名: skb_zerocopy_headlen\n- 参数: [skb]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n10. 函数名: upcall_msg_size\n- 参数: [upcall_info->userdata, hlen]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n11. 函数名: genlmsg_new_unicast\n- 参数: [len, &info, GFP_ATOMIC]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n12. 函数名: genlmsg_put\n- 参数: [user_skb, 0, 0, &dp_packet_genl_family, 0, upcall_info->cmd]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n13. 函数名: nla_nest_start\n- 参数: [user_skb, OVS_PACKET_ATTR_KEY]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n14. 函数名: ovs_nla_put_flow\n- 参数: [upcall_info->key, upcall_info->key, user_skb]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n15. 函数名: nla_nest_end\n- 参数: [user_skb, nla]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n16. 函数名: __nla_put\n- 参数: [user_skb, OVS_PACKET_ATTR_USERDATA, nla_len(upcall_info->userdata), nla_data(upcall_info->userdata)]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n17. 函数名: nla_reserve\n- 参数: [user_skb, OVS_PACKET_ATTR_PACKET, 0]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n18. 函数名: skb_zerocopy\n- 参数: [user_skb, skb, skb->len, hlen]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n19. 函数名: skb_put\n- 参数: [user_skb, plen]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n20. 函数名: genlmsg_unicast\n- 参数: [ovs_dp_get_net(dp), user_skb, upcall_info->portid]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n21. 函数名: kfree_skb\n- 参数: [nskb]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n22. 函数名: ovs_dp_get_net\n- 参数: [dp]\n- 调用者: queue_userspace_packet\n- 被调用者: []"
  },
  {
    "id": 498,
    "cwe": "CWE-416",
    "cve": "CVE-2014-2851",
    "purpose": "Code purpose:\"\"\"该代码用于检查当前进程的有效组ID是否在允许的ping组范围内，以决定是否允许初始化ping套接字。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确处理组信息块的引用计数管理，导致整数溢出可能引发引用计数错误，从而造成释放后使用漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: ping_init_sock\n- 参数: [struct sock *sk]\n- 调用者: N/A\n- 被调用者: [sock_net, current_egid, get_current_groups, inet_get_ping_group_range_net, gid_lte, min_t]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: ping_init_sock\n- 被调用者: N/A\n\n3. 函数名: current_egid\n- 参数: []\n- 调用者: ping_init_sock\n- 被调用者: N/A\n\n4. 函数名: get_current_groups\n- 参数: []\n- 调用者: ping_init_sock\n- 被调用者: N/A\n\n5. 函数名: inet_get_ping_group_range_net\n- 参数: [struct net *net, kgid_t *low, kgid_t *high]\n- 调用者: ping_init_sock\n- 被调用者: N/A\n\n6. 函数名: gid_lte\n- 参数: [kgid_t left, kgid_t right]\n- 调用者: ping_init_sock\n- 被调用者: N/A\n\n7. 函数名: min_t\n- 参数: [int type, int a, int b]\n- 调用者: ping_init_sock\n- 被调用者: N/A"
  },
  {
    "id": 567,
    "cwe": "CWE-416",
    "cve": "CVE-2014-4653",
    "purpose": "Code purpose:\"\"\"该代码用于向声卡控制链表中添加新的控制元素，并处理相关的通知和错误检查。\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在释放读写锁后未正确保护控制元素的内存访问，导致可能发生use-after-free情况\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_ctl_add\n- 参数: [struct snd_card *card, struct snd_kcontrol *kcontrol]\n- 调用者: N/A (顶层函数)\n- 被调用者: [snd_BUG_ON, snd_ctl_find_id, dev_err, snd_ctl_find_hole, list_add_tail, snd_ctl_notify, snd_ctl_free_one]\n\n2. 函数名: snd_BUG_ON\n- 参数: [condition]\n- 调用者: snd_ctl_add\n- 被调用者: N/A\n\n3. 函数名: snd_ctl_find_id\n- 参数: [struct snd_card *card, struct snd_ctl_elem_id *id]\n- 调用者: snd_ctl_add\n- 被调用者: N/A\n\n4. 函数名: dev_err\n- 参数: [struct device *dev, const char *fmt, ...]\n- 调用者: snd_ctl_add\n- 被调用者: N/A\n\n5. 函数名: snd_ctl_find_hole\n- 参数: [struct snd_card *card, unsigned int count]\n- 调用者: snd_ctl_add\n- 被调用者: N/A\n\n6. 函数名: list_add_tail\n- 参数: [struct list_head *new, struct list_head *head]\n- 调用者: snd_ctl_add\n- 被调用者: N/A\n\n7. 函数名: snd_ctl_notify\n- 参数: [struct snd_card *card, int mask, struct snd_ctl_elem_id *id]\n- 调用者: snd_ctl_add\n- 被调用者: N/A\n\n8. 函数名: snd_ctl_free_one\n- 参数: [struct snd_kcontrol *kcontrol]\n- 调用者: snd_ctl_add\n- 被调用者: N/A"
  },
  {
    "id": 568,
    "cwe": "CWE-416",
    "cve": "CVE-2014-4653",
    "purpose": "Code purpose:\"\"\"该代码实现了ALSA控制接口中TLV(Tagged List Value)数据的读写操作，包括权限检查、内存拷贝和回调处理等功能。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"内核ALSA控制实现中未正确持有读写锁，导致存在竞争条件可能引发释放后重用问题\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_ctl_tlv_ioctl\n- 参数: [struct snd_ctl_file *file, struct snd_ctl_tlv __user *_tlv, int op_flag]\n- 调用者: 未指定（由系统调用触发）\n- 被调用者: [copy_from_user, down_read, snd_ctl_find_numid, up_read, snd_ctl_notify, copy_to_user]\n\n2. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: snd_ctl_tlv_ioctl\n- 被调用者: []\n\n3. 函数名: down_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: snd_ctl_tlv_ioctl\n- 被调用者: []\n\n4. 函数名: snd_ctl_find_numid\n- 参数: [struct snd_card *card, int numid]\n- 调用者: snd_ctl_tlv_ioctl\n- 被调用者: []\n\n5. 函数名: up_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: snd_ctl_tlv_ioctl\n- 被调用者: []\n\n6. 函数名: snd_ctl_notify\n- 参数: [struct snd_card *card, int mask, struct snd_ctl_elem_id *id]\n- 调用者: snd_ctl_tlv_ioctl\n- 被调用者: []\n\n7. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: snd_ctl_tlv_ioctl\n- 被调用者: []"
  },
  {
    "id": 569,
    "cwe": "CWE-416",
    "cve": "CVE-2014-4653",
    "purpose": "Code purpose:\"\"\"该代码实现了ALSA控制接口中元素写入功能，包括查找控制元素、验证写入权限并执行写入操作，同时处理相关通知事件。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在释放读锁后仍可能访问已被释放的内存，导致存在use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_ctl_elem_write\n- 参数: [struct snd_card *card, struct snd_ctl_file *file, struct snd_ctl_elem_value *control]\n- 调用者: N/A\n- 被调用者: [down_read, snd_ctl_find_id, snd_ctl_get_ioff, snd_ctl_build_ioff, kctl->put, up_read, snd_ctl_notify]\n\n2. 函数名: snd_ctl_find_id\n- 参数: [struct snd_card *card, &control->id]\n- 调用者: snd_ctl_elem_write\n- 被调用者: N/A\n\n3. 函数名: snd_ctl_get_ioff\n- 参数: [kctl, &control->id]\n- 调用者: snd_ctl_elem_write\n- 被调用者: N/A\n\n4. 函数名: snd_ctl_build_ioff\n- 参数: [&control->id, kctl, index_offset]\n- 调用者: snd_ctl_elem_write\n- 被调用者: N/A\n\n5. 函数名: down_read\n- 参数: [&card->controls_rwsem]\n- 调用者: snd_ctl_elem_write\n- 被调用者: N/A\n\n6. 函数名: up_read\n- 参数: [&card->controls_rwsem]\n- 调用者: snd_ctl_elem_write\n- 被调用者: N/A\n\n7. 函数名: snd_ctl_notify\n- 参数: [card, SNDRV_CTL_EVENT_MASK_VALUE, &control->id]\n- 调用者: snd_ctl_elem_write\n- 被调用者: N/A\n\n8. 函数名: kctl->put\n- 参数: [kctl, control]\n- 调用者: snd_ctl_elem_write\n- 被调用者: N/A"
  },
  {
    "id": 570,
    "cwe": "CWE-416",
    "cve": "CVE-2014-4653",
    "purpose": "Code purpose:\"\"\"该代码用于替换或添加ALSA声卡控制元素，管理控制列表并处理相关通知事件\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在snd_ctl_replace函数中，当执行snd_ctl_remove操作后未重新获取锁就直接跳转到add标签继续操作，导致潜在的竞争条件和use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_ctl_replace\n- 参数: [struct snd_card *card, struct snd_kcontrol *kcontrol, bool add_on_replace]\n- 调用者: N/A (top-level function)\n- 被调用者: [snd_ctl_find_id, snd_ctl_remove, snd_ctl_find_hole, list_add_tail, snd_ctl_notify, snd_ctl_free_one]\n\n2. 函数名: snd_ctl_find_id\n- 参数: [struct snd_card *card, struct snd_ctl_elem_id *id]\n- 调用者: snd_ctl_replace\n- 被调用者: []\n\n3. 函数名: snd_ctl_remove\n- 参数: [struct snd_card *card, struct snd_kcontrol *old]\n- 调用者: snd_ctl_replace\n- 被调用者: []\n\n4. 函数名: snd_ctl_find_hole\n- 参数: [struct snd_card *card, int count]\n- 调用者: snd_ctl_replace\n- 被调用者: []\n\n5. 函数名: list_add_tail\n- 参数: [struct list_head *list, struct list_head *head]\n- 调用者: snd_ctl_replace\n- 被调用者: []\n\n6. 函数名: snd_ctl_notify\n- 参数: [struct snd_card *card, int mask, struct snd_ctl_elem_id *id]\n- 调用者: snd_ctl_replace\n- 被调用者: []\n\n7. 函数名: snd_ctl_free_one\n- 参数: [struct snd_kcontrol *kcontrol]\n- 调用者: snd_ctl_replace\n- 被调用者: []"
  },
  {
    "id": 571,
    "cwe": "CWE-416",
    "cve": "CVE-2014-4654",
    "purpose": "Code purpose:\"\"\"该代码实现了ALSA控制接口中元素的添加和替换功能，允许用户空间通过ioctl调用管理音频控制元素\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于snd_ctl_elem_add函数在执行SNDRV_CTL_IOCTL_ELEM_REPLACE操作时未进行适当的权限检查，导致本地用户可通过/dev/snd/controlCX设备文件进行未授权的内核控制移除，从而引发拒绝服务。\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_ctl_elem_add\n- 参数: [struct snd_ctl_file *file, struct snd_ctl_elem_info *info, int replace]\n- 调用者: 外部调用（通过ioctl）\n- 被调用者: [snd_ctl_find_id, snd_ctl_remove, snd_ctl_elem_user_enum_info, snd_ctl_elem_user_info, snd_ctl_elem_user_get, snd_ctl_elem_user_put, snd_ctl_elem_user_tlv, snd_ctl_elem_init_enum_names, snd_ctl_new, snd_ctl_add, snd_ctl_elem_user_free, kzalloc, kfree, memset, memcpy, down_write, up_write]\n\n2. 函数名: snd_ctl_find_id\n- 参数: [struct snd_card *card, struct snd_ctl_elem_id *id]\n- 调用者: snd_ctl_elem_add\n- 被调用者: []\n\n3. 函数名: snd_ctl_remove\n- 参数: [struct snd_card *card, struct snd_kcontrol *kcontrol]\n- 调用者: snd_ctl_elem_add\n- 被调用者: []\n\n4. 函数名: snd_ctl_elem_user_enum_info\n- 参数: [struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo]\n- 调用者: snd_ctl_elem_add\n- 被调用者: []\n\n5. 函数名: snd_ctl_elem_user_info\n- 参数: [struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo]\n- 调用者: snd_ctl_elem_add\n- 被调用者: []\n\n6. 函数名: snd_ctl_elem_user_get\n- 参数: [struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol]\n- 调用者: snd_ctl_elem_add\n- 被调用者: []\n\n7. 函数名: snd_ctl_elem_user_put\n- 参数: [struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol]\n- 调用者: snd_ctl_elem_add\n- 被调用者: []\n\n8. 函数名: snd_ctl_elem_user_tlv\n- 参数: [struct snd_kcontrol *kcontrol, int op_flag, unsigned int size, unsigned int __user *tlv]\n- 调用者: snd_ctl_elem_add\n- 被调用者: []\n\n9. 函数名: snd_ctl_elem_init_enum_names\n- 参数: [struct user_element *ue]\n- 调用者: snd_ctl_elem_add\n- 被调用者: []\n\n10. 函数名: snd_ctl_new\n- 参数: [struct snd_kcontrol *kcontrol, unsigned int access]\n- 调用者: snd_ctl_elem_add\n- 被调用者: []\n\n11. 函数名: snd_ctl_add\n- 参数: [struct snd_card *card, struct snd_kcontrol *kcontrol]\n- 调用者: snd_ctl_elem_add\n- 被调用者: []\n\n12. 函数名: snd_ctl_elem_user_free\n- 参数: [struct snd_kcontrol *kcontrol]\n- 调用者: snd_ctl_elem_add\n- 被调用者: []"
  },
  {
    "id": 711,
    "cwe": "CWE-416",
    "cve": "CVE-2014-9914",
    "purpose": "Code purpose:\"\"\"该代码用于在IPv4 UDP套接字释放时处理路由缓存更新，确保数据包能正确路由到目标地址\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在多线程访问IPv4 UDP套接字的内部数据结构时，由于锁定机制不当导致的竞态条件，可能引发释放后重用问题\"\"\"",
    "functions": "Functions:\n1. 函数名: ip4_datagram_release_cb\n- 参数: [struct sock *sk]\n- 调用者: 未显示\n- 被调用者: [inet_sk, __sk_dst_get, __sk_dst_check, rcu_read_lock, rcu_dereference, ip_route_output_ports, sock_net, IS_ERR, __sk_dst_set, rcu_read_unlock]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: 未显示\n\n3. 函数名: __sk_dst_get\n- 参数: [struct sock *sk]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: 未显示\n\n4. 函数名: __sk_dst_check\n- 参数: [struct sock *sk, 0]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: 未显示\n\n5. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: ip4_datagram_release_cb\n- 被调用者: 未显示\n\n6. 函数名: rcu_dereference\n- 参数: [inet->inet_opt]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: 未显示\n\n7. 函数名: ip_route_output_ports\n- 参数: [sock_net(sk), &fl4, sk, daddr, inet->inet_saddr, inet->inet_dport, inet->inet_sport, sk->sk_protocol, RT_CONN_FLAGS(sk), sk->sk_bound_dev_if]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: 未显示\n\n8. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: 未显示\n\n9. 函数名: IS_ERR\n- 参数: [rt]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: 未显示\n\n10. 函数名: __sk_dst_set\n- 参数: [sk, &rt->dst]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: 未显示\n\n11. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: ip4_datagram_release_cb\n- 被调用者: 未显示"
  },
  {
    "id": 714,
    "cwe": "CWE-416",
    "cve": "CVE-2014-9940",
    "purpose": "Code purpose:\"\"\"释放与调节器使能GPIO相关的资源，包括减少引用计数或在引用计数为1时释放GPIO和内存资源\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在释放GPIO资源时未正确处理引用计数，导致可能发生use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: regulator_ena_gpio_free\n- 参数: [struct regulator_dev *rdev]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [gpiod_put, list_del, kfree]\n\n2. 函数名: gpiod_put\n- 参数: [struct gpio_desc *gpiod]\n- 调用者: regulator_ena_gpio_free\n- 被调用者: 未明确\n\n3. 函数名: list_del\n- 参数: [struct list_head *entry]\n- 调用者: regulator_ena_gpio_free\n- 被调用者: 未明确\n\n4. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: regulator_ena_gpio_free\n- 被调用者: 未明确"
  },
  {
    "id": 778,
    "cwe": "CWE-416",
    "cve": "CVE-2015-5706",
    "purpose": "Code purpose:\"\"\"处理文件路径打开操作，包括临时文件创建、路径解析和符号链接跟踪等功能\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在path_openat函数中处理O_TMPFILE文件时存在双重清理操作，导致释放后重用(use-after-free)漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: path_openat\n- 参数: [dfd, pathname, nd, op, flags]\n- 调用者: 未显示\n- 被调用者: [get_empty_filp, do_tmpfile, path_init, do_last, may_follow_link, follow_link, put_link, path_cleanup, put_filp, ERR_PTR]\n\n2. 函数名: get_empty_filp\n- 参数: []\n- 调用者: path_openat\n- 被调用者: 未显示\n\n3. 函数名: do_tmpfile\n- 参数: [dfd, pathname, nd, flags, op, file, opened]\n- 调用者: path_openat\n- 被调用者: 未显示\n\n4. 函数名: path_init\n- 参数: [dfd, pathname, flags, nd]\n- 调用者: path_openat\n- 被调用者: 未显示\n\n5. 函数名: do_last\n- 参数: [nd, path, file, op, opened, pathname]\n- 调用者: path_openat\n- 被调用者: 未显示\n\n6. 函数名: may_follow_link\n- 参数: [link, nd]\n- 调用者: path_openat\n- 被调用者: 未显示\n\n7. 函数名: follow_link\n- 参数: [link, nd, cookie]\n- 调用者: path_openat\n- 被调用者: 未显示\n\n8. 函数名: put_link\n- 参数: [nd, link, cookie]\n- 调用者: path_openat\n- 被调用者: 未显示\n\n9. 函数名: path_cleanup\n- 参数: [nd]\n- 调用者: path_openat\n- 被调用者: 未显示\n\n10. 函数名: put_filp\n- 参数: [file]\n- 调用者: path_openat\n- 被调用者: 未显示\n\n11. 函数名: ERR_PTR\n- 参数: [error]\n- 调用者: path_openat\n- 被调用者: 未显示\n\n12. 函数名: path_put_conditional\n- 参数: [path, nd]\n- 调用者: path_openat\n- 被调用者: 未显示\n\n13. 函数名: path_put\n- 参数: [nd->path]\n- 调用者: path_openat\n- 被调用者: 未显示"
  },
  {
    "id": 869,
    "cwe": "CWE-416",
    "cve": "CVE-2015-8961",
    "purpose": "Code purpose:\"\"\"该代码用于处理ext4文件系统日志事务的停止操作，包括错误处理和资源释放\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在__ext4_journal_stop函数中，对handle->h_err错误字段的访问存在竞争条件，可能导致释放后使用(use-after-free)漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: __ext4_journal_stop\n- 参数: [where, line, handle]\n- 调用者: 未明确（外部调用）\n- 被调用者: [ext4_handle_valid, ext4_put_nojournal, jbd2_journal_stop, __ext4_std_error]\n\n2. 函数名: ext4_handle_valid\n- 参数: [handle]\n- 调用者: __ext4_journal_stop\n- 被调用者: 未明确\n\n3. 函数名: ext4_put_nojournal\n- 参数: [handle]\n- 调用者: __ext4_journal_stop\n- 被调用者: 未明确\n\n4. 函数名: jbd2_journal_stop\n- 参数: [handle]\n- 调用者: __ext4_journal_stop\n- 被调用者: 未明确\n\n5. 函数名: __ext4_std_error\n- 参数: [sb, where, line, err]\n- 调用者: __ext4_journal_stop\n- 被调用者: 未明确"
  },
  {
    "id": 871,
    "cwe": "CWE-416",
    "cve": "CVE-2015-8963",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中为性能监控事件添加软件事件处理，涉及CPU热插拔时的竞态条件处理\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在CPU热拔插操作期间，由于对swevent数据结构的错误处理导致竞态条件，可能引发释放后重用漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: perf_swevent_add\n- 参数: [struct perf_event *event, int flags]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [this_cpu_ptr, is_sampling_event, perf_swevent_set_period, find_swevent_head, WARN_ON_ONCE, hlist_add_head_rcu, perf_event_update_userpage]\n\n2. 函数名: this_cpu_ptr\n- 参数: [&swevent_htable]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n3. 函数名: is_sampling_event\n- 参数: [struct perf_event *event]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n4. 函数名: perf_swevent_set_period\n- 参数: [struct perf_event *event]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n5. 函数名: find_swevent_head\n- 参数: [struct swevent_htable *swhash, struct perf_event *event]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n6. 函数名: WARN_ON_ONCE\n- 参数: [swhash->online]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n7. 函数名: hlist_add_head_rcu\n- 参数: [&event->hlist_entry, head]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n8. 函数名: perf_event_update_userpage\n- 参数: [struct perf_event *event]\n- 调用者: perf_swevent_add\n- 被调用者: []"
  },
  {
    "id": 872,
    "cwe": "CWE-416",
    "cve": "CVE-2015-8963",
    "purpose": "Code purpose:\"\"\"初始化指定CPU的性能事件监控数据结构，并在有引用时分配新的监控链表\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在CPU热插拔操作期间，由于对swevent数据结构的竞争条件处理不当，导致可能发生释放后重用(UAF)漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: perf_event_init_cpu\n- 参数: [cpu]\n- 调用者: 未显示（由系统CPU热插拔操作触发）\n- 被调用者: [mutex_lock, kzalloc_node, WARN_ON, rcu_assign_pointer, mutex_unlock, cpu_to_node]\n\n2. 函数名: mutex_lock\n- 参数: [&swhash->hlist_mutex]\n- 调用者: perf_event_init_cpu\n- 被调用者: []\n\n3. 函数名: kzalloc_node\n- 参数: [sizeof(*hlist), GFP_KERNEL, cpu_to_node(cpu)]\n- 调用者: perf_event_init_cpu\n- 被调用者: []\n\n4. 函数名: WARN_ON\n- 参数: [!hlist]\n- 调用者: perf_event_init_cpu\n- 被调用者: []\n\n5. 函数名: rcu_assign_pointer\n- 参数: [swhash->swevent_hlist, hlist]\n- 调用者: perf_event_init_cpu\n- 被调用者: []\n\n6. 函数名: mutex_unlock\n- 参数: [&swhash->hlist_mutex]\n- 调用者: perf_event_init_cpu\n- 被调用者: []\n\n7. 函数名: cpu_to_node\n- 参数: [cpu]\n- 调用者: perf_event_init_cpu\n- 被调用者: []"
  },
  {
    "id": 873,
    "cwe": "CWE-416",
    "cve": "CVE-2015-8963",
    "purpose": "Code purpose:\"\"\"该代码用于在多核环境下安全地获取和引用特定CPU上的软件事件哈希表，并在需要时分配新的哈希表结构。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在CPU热拔插操作期间，由于对swevent数据结构的处理不当，导致存在竞态条件可能引发释放后重用问题\"\"\"",
    "functions": "Functions:\n1. 函数名: swevent_hlist_get_cpu\n- 参数: [struct perf_event *event, int cpu]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [swevent_hlist_deref, cpu_online, kzalloc, rcu_assign_pointer, mutex_lock, mutex_unlock]\n\n2. 函数名: swevent_hlist_deref\n- 参数: [struct swevent_htable *swhash]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: []\n\n3. 函数名: cpu_online\n- 参数: [int cpu]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: []\n\n4. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: []\n\n5. 函数名: rcu_assign_pointer\n- 参数: [pointer, value]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: []\n\n6. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: []\n\n7. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: []"
  },
  {
    "id": 893,
    "cwe": "CWE-416",
    "cve": "CVE-2016-10088",
    "purpose": "Code purpose:\"\"\"处理来自用户空间的写入请求，将数据通过BSG(Block SCSI Generic)接口写入设备，并返回写入的字节数。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中的sg实现未正确限制KERNEL_DS选项设置时的写操作，导致本地用户可通过访问/dev/sg设备任意读写内核内存或引发拒绝服务\"\"\"",
    "functions": "Functions:\n1. 函数名: bsg_write\n- 参数: [struct file *file, const char __user *buf, size_t count, loff_t *ppos]\n- 调用者: 未指定（由文件操作结构调用）\n- 被调用者: [dprintk, bsg_set_block, __bsg_write, err_block_err]\n\n2. 函数名: dprintk\n- 参数: [const char *fmt, ...]（变参函数）\n- 调用者: [bsg_write]\n- 被调用者: []\n\n3. 函数名: bsg_set_block\n- 参数: [struct bsg_device *bd, struct file *file]\n- 调用者: [bsg_write]\n- 被调用者: []\n\n4. 函数名: __bsg_write\n- 参数: [struct bsg_device *bd, const char __user *buf, size_t count, ssize_t *bytes_written, int write_mode]\n- 调用者: [bsg_write]\n- 被调用者: []\n\n5. 函数名: err_block_err\n- 参数: [int ret]\n- 调用者: [bsg_write]\n- 被调用者: []"
  },
  {
    "id": 894,
    "cwe": "CWE-416",
    "cve": "CVE-2016-10088",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中SCSI通用设备(/dev/sg)的写操作处理功能，包括命令解析、数据传输方向控制和请求处理等。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中的sg实现未正确限制KERNEL_DS选项设置时的写操作，导致本地用户可通过访问/dev/sg设备读写任意内核内存或引发释放后重用漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: sg_write\n- 参数: [struct file *filp, const char __user *buf, size_t count, loff_t *ppos]\n- 调用者: 文件系统调用\n- 被调用者: [sg_printk, scsi_block_when_processing_errors, access_ok, __copy_from_user, sg_new_write, sg_add_request, __get_user, sg_remove_request, sg_common_write, strcmp, strcpy, printk_ratelimited]\n\n2. 函数名: sg_printk\n- 参数: [int log_level, Sg_device *sdp, const char *fmt, ...]\n- 调用者: sg_write\n- 被调用者: []\n\n3. 函数名: scsi_block_when_processing_errors\n- 参数: [struct scsi_device *sdev]\n- 调用者: sg_write\n- 被调用者: []\n\n4. 函数名: access_ok\n- 参数: [int type, const void __user *addr, unsigned long size]\n- 调用者: sg_write\n- 被调用者: []\n\n5. 函数名: __copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: sg_write\n- 被调用者: []\n\n6. 函数名: sg_new_write\n- 参数: [Sg_fd *sfp, struct file *filp, const char __user *buf, size_t count, int blocking, int read_only, int force_packid, sg_io_hdr_t *hp]\n- 调用者: sg_write\n- 被调用者: []\n\n7. 函数名: sg_add_request\n- 参数: [Sg_fd *sfp]\n- 调用者: sg_write\n- 被调用者: []\n\n8. 函数名: __get_user\n- 参数: [type x, const type __user *ptr]\n- 调用者: sg_write\n- 被调用者: []\n\n9. 函数名: sg_remove_request\n- 参数: [Sg_fd *sfp, Sg_request *srp]\n- 调用者: sg_write\n- 被调用者: []\n\n10. 函数名: sg_common_write\n- 参数: [Sg_fd *sfp, Sg_request *srp, unsigned char *cmnd, int timeout, int blocking]\n- 调用者: sg_write\n- 被调用者: []\n\n11. 函数名: strcmp\n- 参数: [const char *s1, const char *s2]\n- 调用者: sg_write\n- 被调用者: []\n\n12. 函数名: strcpy\n- 参数: [char *dest, const char *src]\n- 调用者: sg_write\n- 被调用者: []\n\n13. 函数名: printk_ratelimited\n- 参数: [const char *fmt, ...]\n- 调用者: sg_write\n- 被调用者: []"
  },
  {
    "id": 898,
    "cwe": "CWE-416",
    "cve": "CVE-2016-10200",
    "purpose": "Code purpose:\"\"\"实现L2TPv3 IP封装功能中的socket绑定操作，包括地址验证、状态检查和绑定表管理\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在检查SOCK_ZAPPED状态和实际绑定操作之间存在竞争条件，导致多个bind系统调用可能绕过状态检查，引发use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: l2tp_ip_bind\n- 参数: [struct sock *sk, struct sockaddr *uaddr, int addr_len]\n- 调用者: 未显示（应为系统调用或内核其他模块）\n- 被调用者: [inet_sk, sock_net, sock_flag, __l2tp_ip_bind_lookup, read_lock_bh, read_unlock_bh, lock_sock, inet_addr_type, sk_dst_reset, l2tp_ip_sk, write_lock_bh, sk_add_bind_node, sk_del_node_init, write_unlock_bh, sock_reset_flag, release_sock]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n3. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n4. 函数名: sock_flag\n- 参数: [struct sock *sk, SOCK_ZAPPED]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n5. 函数名: __l2tp_ip_bind_lookup\n- 参数: [struct net *net, addr->l2tp_addr.s_addr, sk->sk_bound_dev_if, addr->l2tp_conn_id]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n6. 函数名: read_lock_bh\n- 参数: [&l2tp_ip_lock]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n7. 函数名: read_unlock_bh\n- 参数: [&l2tp_ip_lock]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n8. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n9. 函数名: inet_addr_type\n- 参数: [struct net *net, addr->l2tp_addr.s_addr]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n10. 函数名: sk_dst_reset\n- 参数: [struct sock *sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n11. 函数名: l2tp_ip_sk\n- 参数: [struct sock *sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n12. 函数名: write_lock_bh\n- 参数: [&l2tp_ip_lock]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n13. 函数名: sk_add_bind_node\n- 参数: [struct sock *sk, &l2tp_ip_bind_table]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n14. 函数名: sk_del_node_init\n- 参数: [struct sock *sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n15. 函数名: write_unlock_bh\n- 参数: [&l2tp_ip_lock]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n16. 函数名: sock_reset_flag\n- 参数: [struct sock *sk, SOCK_ZAPPED]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n17. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []"
  },
  {
    "id": 899,
    "cwe": "CWE-416",
    "cve": "CVE-2016-10200",
    "purpose": "Code purpose:\"\"\"该代码实现了L2TPv3协议在IPv6环境下的socket绑定功能，包括地址验证、状态检查和绑定表管理。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多次bind系统调用时未能正确检查SOCK_ZAPPED状态，导致竞争条件引发的use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: l2tp_ip6_bind\n- 参数: [sk, uaddr, addr_len]\n- 调用者: 未显示（系统调用）\n- 被调用者: [inet_sk, inet6_sk, sock_net, ipv6_addr_type, __l2tp_ip6_bind_lookup, lock_sock, rcu_read_lock, dev_get_by_index_rcu, ipv6_chk_addr, rcu_read_unlock, sk_add_bind_node, sk_del_node_init, sock_reset_flag, release_sock]\n\n2. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n3. 函数名: inet6_sk\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n4. 函数名: sock_net\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n5. 函数名: ipv6_addr_type\n- 参数: [&addr->l2tp_addr]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n6. 函数名: __l2tp_ip6_bind_lookup\n- 参数: [net, &addr->l2tp_addr, sk->sk_bound_dev_if, addr->l2tp_conn_id]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n7. 函数名: lock_sock\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n8. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n9. 函数名: dev_get_by_index_rcu\n- 参数: [sock_net(sk), sk->sk_bound_dev_if]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n10. 函数名: ipv6_chk_addr\n- 参数: [sock_net(sk), &addr->l2tp_addr, dev, 0]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n11. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n12. 函数名: sk_add_bind_node\n- 参数: [sk, &l2tp_ip6_bind_table]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n13. 函数名: sk_del_node_init\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n14. 函数名: sock_reset_flag\n- 参数: [sk, SOCK_ZAPPED]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n15. 函数名: release_sock\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []"
  },
  {
    "id": 907,
    "cwe": "CWE-416",
    "cve": "CVE-2016-10905",
    "purpose": "Code purpose:\"\"\"该代码用于清理GFS2文件系统中的资源组描述符(rgrpd)及相关资源，包括释放内存、删除索引树节点和处理关联的glock对象\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在gfs2_clear_rgrpd函数中，由于在释放rgd资源后未正确处理gl对象的引用，导致后续操作可能访问已释放的内存区域，造成use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: gfs2_clear_rgrpd\n- 参数: [struct gfs2_sbd *sdp]\n- 调用者: N/A\n- 被调用者: [rb_first, rb_entry, rb_erase, spin_lock, spin_unlock, gfs2_glock_add_to_lru, gfs2_glock_put, gfs2_free_clones, kfree, return_all_reservations, kmem_cache_free]\n\n2. 函数名: rb_first\n- 参数: [&sdp->sd_rindex_tree]\n- 调用者: gfs2_clear_rgrpd\n- 被调用者: N/A\n\n3. 函数名: rb_entry\n- 参数: [n, struct gfs2_rgrpd, rd_node]\n- 调用者: gfs2_clear_rgrpd\n- 被调用者: N/A\n\n4. 函数名: rb_erase\n- 参数: [n, &sdp->sd_rindex_tree]\n- 调用者: gfs2_clear_rgrpd\n- 被调用者: N/A\n\n5. 函数名: spin_lock\n- 参数: [&gl->gl_lockref.lock]\n- 调用者: gfs2_clear_rgrpd\n- 被调用者: N/A\n\n6. 函数名: spin_unlock\n- 参数: [&gl->gl_lockref.lock]\n- 调用者: gfs2_clear_rgrpd\n- 被调用者: N/A\n\n7. 函数名: gfs2_glock_add_to_lru\n- 参数: [gl]\n- 调用者: gfs2_clear_rgrpd\n- 被调用者: N/A\n\n8. 函数名: gfs2_glock_put\n- 参数: [gl]\n- 调用者: gfs2_clear_rgrpd\n- 被调用者: N/A\n\n9. 函数名: gfs2_free_clones\n- 参数: [rgd]\n- 调用者: gfs2_clear_rgrpd\n- 被调用者: N/A\n\n10. 函数名: kfree\n- 参数: [rgd->rd_bits]\n- 调用者: gfs2_clear_rgrpd\n- 被调用者: N/A\n\n11. 函数名: return_all_reservations\n- 参数: [rgd]\n- 调用者: gfs2_clear_rgrpd\n- 被调用者: N/A\n\n12. 函数名: kmem_cache_free\n- 参数: [gfs2_rgrpd_cachep, rgd]\n- 调用者: gfs2_clear_rgrpd\n- 被调用者: N/A"
  },
  {
    "id": 908,
    "cwe": "CWE-416",
    "cve": "CVE-2016-10905",
    "purpose": "Code purpose:\"\"\"读取并处理GFS2文件系统的资源组索引条目，分配和管理相关资源组描述符\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在read_rindex_entry函数中，当rgd_insert失败时，错误处理路径中直接释放了rgd结构体，但未正确处理与之关联的glock对象，导致后续可能发生use-after-free\"\"\"",
    "functions": "Functions:\n1. 函数名: read_rindex_entry\n- 参数: [struct gfs2_inode *ip]\n- 调用者: 未明确显示（可能是外部调用）\n- 被调用者: [i_size_read, gfs2_internal_read, kmem_cache_zalloc, be64_to_cpu, be32_to_cpu, spin_lock_init, compute_bitstructs, gfs2_glock_get, PAGE_ALIGN, spin_lock, rgd_insert, spin_unlock, gfs2_glock_put, kfree, kmem_cache_free]\n\n2. 函数名: i_size_read\n- 参数: [struct inode *inode]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n3. 函数名: gfs2_internal_read\n- 参数: [struct gfs2_inode *ip, char *buf, loff_t *pos, size_t size]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n4. 函数名: kmem_cache_zalloc\n- 参数: [struct kmem_cache *cachep, gfp_t flags]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n5. 函数名: be64_to_cpu\n- 参数: [__be64 x]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n6. 函数名: be32_to_cpu\n- 参数: [__be32 x]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n7. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n8. 函数名: compute_bitstructs\n- 参数: [struct gfs2_rgrpd *rgd]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n9. 函数名: gfs2_glock_get\n- 参数: [struct gfs2_sbd *sdp, u64 number, const struct gfs2_glock_operations *glops, int create, struct gfs2_glock **glp]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n10. 函数名: PAGE_ALIGN\n- 参数: [unsigned long addr]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n11. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n12. 函数名: rgd_insert\n- 参数: [struct gfs2_rgrpd *rgd]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n13. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n14. 函数名: gfs2_glock_put\n- 参数: [struct gfs2_glock *gl]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n15. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n16. 函数名: kmem_cache_free\n- 参数: [struct kmem_cache *cachep, void *objp]\n- 调用者: read_rindex_entry\n- 被调用者: []"
  },
  {
    "id": 909,
    "cwe": "CWE-416",
    "cve": "CVE-2016-10906",
    "purpose": "Code purpose:\"\"\"该代码实现了ARC EMAC网络设备驱动中的数据包发送功能，包括数据包填充、DMA映射、传输描述符更新和队列状态管理。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于arc_emac_tx和arc_emac_tx_clean函数之间的竞争条件导致释放后使用漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: arc_emac_tx\n- 参数: [struct sk_buff *skb, struct net_device *ndev]\n- 调用者: 未显示（通常由网络子系统调用）\n- 被调用者: [skb_padto, max_t, arc_emac_tx_avail, netif_stop_queue, netdev_err, dma_map_single, dma_mapping_error, dev_kfree_skb, dma_unmap_addr_set, dma_unmap_len_set, cpu_to_le32, wmb, skb_tx_timestamp, smp_mb, netif_start_queue, arc_reg_set]\n\n2. 函数名: skb_padto\n- 参数: [struct sk_buff *skb, unsigned int len]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n3. 函数名: max_t\n- 参数: [unsigned int, ETH_ZLEN, skb->len]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n4. 函数名: arc_emac_tx_avail\n- 参数: [struct arc_emac_priv *priv]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n5. 函数名: netif_stop_queue\n- 参数: [struct net_device *ndev]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n6. 函数名: netdev_err\n- 参数: [struct net_device *ndev, const char *fmt, ...]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n7. 函数名: dma_map_single\n- 参数: [struct device *dev, void *ptr, size_t size, enum dma_data_direction dir]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n8. 函数名: dma_mapping_error\n- 参数: [struct device *dev, dma_addr_t dma_addr]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n9. 函数名: dev_kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n10. 函数名: dma_unmap_addr_set\n- 参数: [struct buffer *buf, dma_addr_t addr, dma_addr_t val]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n11. 函数名: dma_unmap_len_set\n- 参数: [struct buffer *buf, unsigned int len, unsigned int val]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n12. 函数名: cpu_to_le32\n- 参数: [__u32 val]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n13. 函数名: wmb\n- 参数: []\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n14. 函数名: skb_tx_timestamp\n- 参数: [struct sk_buff *skb]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n15. 函数名: smp_mb\n- 参数: []\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n16. 函数名: netif_start_queue\n- 参数: [struct net_device *dev]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n17. 函数名: arc_reg_set\n- 参数: [struct arc_emac_priv *priv, int reg, u32 value]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示"
  },
  {
    "id": 910,
    "cwe": "CWE-416",
    "cve": "CVE-2016-10906",
    "purpose": "Code purpose:\"\"\"该代码用于清理网络设备发送缓冲区中的已完成传输的数据包，并更新相关统计信息。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于arc_emac_tx和arc_emac_tx_clean函数之间的竞争条件导致释放后使用漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: arc_emac_tx_clean\n- 参数: [struct net_device *ndev]\n- 调用者: 未明确显示（通常由网络子系统调用）\n- 被调用者: [le32_to_cpu, dma_unmap_single, dev_kfree_skb_irq, smp_mb, netif_queue_stopped, arc_emac_tx_avail, netif_wake_queue]\n\n2. 函数名: le32_to_cpu\n- 参数: [unsigned int info]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n3. 函数名: dma_unmap_single\n- 参数: [&ndev->dev, dma_unmap_addr(tx_buff, addr), dma_unmap_len(tx_buff, len), DMA_TO_DEVICE]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n4. 函数名: dev_kfree_skb_irq\n- 参数: [struct sk_buff *skb]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n5. 函数名: smp_mb\n- 参数: []\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n6. 函数名: netif_queue_stopped\n- 参数: [struct net_device *ndev]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n7. 函数名: arc_emac_tx_avail\n- 参数: [struct arc_emac_priv *priv]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n8. 函数名: netif_wake_queue\n- 参数: [struct net_device *ndev]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []"
  },
  {
    "id": 989,
    "cwe": "CWE-416",
    "cve": "CVE-2016-3841",
    "purpose": "Code purpose:\"\"\"处理IPv6 DCCP协议中接收请求并创建新套接字的过程，包括IPv4映射和IPv6原生连接的处理\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致在精心构造的sendmsg系统调用下可能发生use-after-free，从而允许本地用户提升权限或引发拒绝服务\"\"\"",
    "functions": "Functions:\n1. 函数名: dccp_v6_request_recv_sock\n- 参数: [const struct sock *sk, struct sk_buff *skb, struct request_sock *req, struct dst_entry *dst, struct request_sock *req_unhash, bool *own_req]\n- 调用者: 未显示\n- 被调用者: [inet_rsk, inet6_sk, dccp_v4_request_recv_sock, inet_sk, memcpy, inet_csk, dccp_v4_do_rcv, inet6_iif, dccp_sync_mss, sk_acceptq_is_full, inet6_csk_route_req, dccp_create_openreq_child, __ip6_dst_store, ipv6_dup_options, __inet_inherit_port, inet_csk_prepare_forced_close, dccp_done, inet_ehash_nolisten, skb_clone, consume_skb, skb_set_owner_r, dst_release]\n\n2. 函数名: dccp_v4_request_recv_sock\n- 参数: [const struct sock *sk, struct sk_buff *skb, struct request_sock *req, struct dst_entry *dst, struct request_sock *req_unhash, bool *own_req]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n3. 函数名: dccp_create_openreq_child\n- 参数: [const struct sock *sk, struct request_sock *req, struct sk_buff *skb]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n4. 函数名: dccp_sync_mss\n- 参数: [struct sock *newsk, inet_csk(newsk)->icsk_pmtu_cookie]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n5. 函数名: dccp_v4_do_rcv\n- 参数: 未显示\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n6. 函数名: dccp_done\n- 参数: [struct sock *newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n7. 函数名: inet_rsk\n- 参数: [struct request_sock *req]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n8. 函数名: inet6_sk\n- 参数: [const struct sock *sk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n9. 函数名: inet_sk\n- 参数: [struct sock *newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n10. 函数名: inet_csk\n- 参数: [struct sock *newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n11. 函数名: inet6_iif\n- 参数: [struct sk_buff *skb]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n12. 函数名: sk_acceptq_is_full\n- 参数: [const struct sock *sk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n13. 函数名: inet6_csk_route_req\n- 参数: [const struct sock *sk, struct flowi6 *fl6, struct request_sock *req, IPPROTO_DCCP]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n14. 函数名: __ip6_dst_store\n- 参数: [struct sock *newsk, struct dst_entry *dst, NULL, NULL]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n15. 函数名: ipv6_dup_options\n- 参数: [struct sock *newsk, np->opt]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n16. 函数名: __inet_inherit_port\n- 参数: [const struct sock *sk, struct sock *newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n17. 函数名: inet_csk_prepare_forced_close\n- 参数: [struct sock *newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n18. 函数名: inet_ehash_nolisten\n- 参数: [struct sock *newsk, req_to_sk(req_unhash)]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n19. 函数名: skb_clone\n- 参数: [ireq->pktopts, GFP_ATOMIC]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n20. 函数名: consume_skb\n- 参数: [ireq->pktopts]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n21. 函数名: skb_set_owner_r\n- 参数: [newnp->pktoptions, newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n22. 函数名: dst_release\n- 参数: [struct dst_entry *dst]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示"
  },
  {
    "id": 990,
    "cwe": "CWE-416",
    "cve": "CVE-2016-3841",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中DCCP协议在IPv6环境下的客户端连接功能，包括地址处理、路由查找和连接建立等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致本地用户可通过精心构造的sendmsg系统调用触发释放后重用漏洞，从而获取权限或造成系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: dccp_v6_connect\n- 参数: [sk, uaddr, addr_len]\n- 调用者: 无（系统调用）\n- 被调用者: [inet_csk, inet_sk, inet6_sk, dccp_sk, memset, ipv6_addr_any, ipv6_addr_type, fl6_sock_lookup, fl6_sock_release, SOCK_DEBUG, __ipv6_only_sock, dccp_v4_connect, security_sk_classify_flow, fl6_update_dst, ip6_dst_lookup_flow, __ip6_dst_store, dccp_set_state, inet6_hash_connect, secure_dccpv6_sequence_number, dccp_connect, __sk_dst_reset]\n\n2. 函数名: inet_csk\n- 参数: [sk]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n3. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n4. 函数名: inet6_sk\n- 参数: [sk]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n5. 函数名: dccp_sk\n- 参数: [sk]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n6. 函数名: memset\n- 参数: [&fl6, 0, sizeof(fl6)]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n7. 函数名: ipv6_addr_any\n- 参数: [&usin->sin6_addr]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n8. 函数名: ipv6_addr_type\n- 参数: [&usin->sin6_addr]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n9. 函数名: fl6_sock_lookup\n- 参数: [sk, fl6.flowlabel]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n10. 函数名: fl6_sock_release\n- 参数: [flowlabel]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n11. 函数名: SOCK_DEBUG\n- 参数: [sk, \"connect: ipv4 mapped\"]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n12. 函数名: __ipv6_only_sock\n- 参数: [sk]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n13. 函数名: dccp_v4_connect\n- 参数: [sk, (struct sockaddr *)&sin, sizeof(sin)]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n14. 函数名: security_sk_classify_flow\n- 参数: [sk, flowi6_to_flowi(&fl6)]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n15. 函数名: fl6_update_dst\n- 参数: [&fl6, np->opt, &final]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n16. 函数名: ip6_dst_lookup_flow\n- 参数: [sk, &fl6, final_p]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n17. 函数名: __ip6_dst_store\n- 参数: [sk, dst, NULL, NULL]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n18. 函数名: dccp_set_state\n- 参数: [sk, DCCP_REQUESTING/DCCP_CLOSED]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n19. 函数名: inet6_hash_connect\n- 参数: [&dccp_death_row, sk]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n20. 函数名: secure_dccpv6_sequence_number\n- 参数: [np->saddr.s6_addr32, sk->sk_v6_daddr.s6_addr32, inet->inet_sport, inet->inet_dport]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n21. 函数名: dccp_connect\n- 参数: [sk]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n22. 函数名: __sk_dst_reset\n- 参数: [sk]\n- 调用者: dccp_v6_connect\n- 被调用者: 无"
  },
  {
    "id": 991,
    "cwe": "CWE-416",
    "cve": "CVE-2016-3841",
    "purpose": "Code purpose:\"\"\"该代码用于处理DCCP协议在IPv6下的响应发送，包括构建响应报文、计算校验和并通过IPv6协议栈发送响应。\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致在精心构造的sendmsg系统调用下可能发生释放后重用(use-after-free)问题\"\"\"",
    "functions": "Functions:\n1. 函数名: dccp_v6_send_response\n- 参数: [const struct sock *sk, struct request_sock *req]\n- 调用者: N/A\n- 被调用者: [inet_rsk, inet6_sk, memset, htons, security_req_classify_flow, flowi6_to_flowi, fl6_update_dst, ip6_dst_lookup_flow, IS_ERR, PTR_ERR, dccp_make_response, dccp_v6_csum_finish, ip6_xmit, net_xmit_eval, dst_release]\n\n2. 函数名: inet_rsk\n- 参数: [struct request_sock *req]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n3. 函数名: inet6_sk\n- 参数: [const struct sock *sk]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n4. 函数名: memset\n- 参数: [&fl6, 0, sizeof(fl6)]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n5. 函数名: htons\n- 参数: [ireq->ir_num]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n6. 函数名: security_req_classify_flow\n- 参数: [req, flowi6_to_flowi(&fl6)]\n- 调用者: dccp_v6_send_response\n- 被调用者: [flowi6_to_flowi]\n\n7. 函数名: flowi6_to_flowi\n- 参数: [&fl6]\n- 调用者: security_req_classify_flow\n- 被调用者: N/A\n\n8. 函数名: fl6_update_dst\n- 参数: [&fl6, np->opt, &final]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n9. 函数名: ip6_dst_lookup_flow\n- 参数: [sk, &fl6, final_p]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n10. 函数名: IS_ERR\n- 参数: [dst]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n11. 函数名: PTR_ERR\n- 参数: [dst]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n12. 函数名: dccp_make_response\n- 参数: [sk, dst, req]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n13. 函数名: dccp_v6_csum_finish\n- 参数: [skb, &ireq->ir_v6_loc_addr, &ireq->ir_v6_rmt_addr]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n14. 函数名: ip6_xmit\n- 参数: [sk, skb, &fl6, np->opt, np->tclass]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n15. 函数名: net_xmit_eval\n- 参数: [err]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n16. 函数名: dst_release\n- 参数: [dst]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A"
  },
  {
    "id": 992,
    "cwe": "CWE-416",
    "cve": "CVE-2016-3841",
    "purpose": "Code purpose:\"\"\"释放IPv6套接字相关资源，包括接收选项、PMTU数据、流标签和传输选项\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在释放后使用(UAF)问题，导致本地用户可通过特制的sendmsg系统调用获取权限或引发拒绝服务\"\"\"",
    "functions": "Functions:\n1. 函数名: inet6_destroy_sock\n- 参数: [sk]\n- 调用者: 未显示\n- 被调用者: [inet6_sk, xchg, kfree_skb, fl6_free_socklist, sock_kfree_s]\n\n2. 函数名: inet6_sk\n- 参数: [sk]\n- 调用者: inet6_destroy_sock\n- 被调用者: 未显示\n\n3. 函数名: xchg\n- 参数: [&np->pktoptions, NULL], [&np->rxpmtu, NULL], [&np->opt, NULL]\n- 调用者: inet6_destroy_sock\n- 被调用者: 未显示\n\n4. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: inet6_destroy_sock\n- 被调用者: 未显示\n\n5. 函数名: fl6_free_socklist\n- 参数: [sk]\n- 调用者: inet6_destroy_sock\n- 被调用者: 未显示\n\n6. 函数名: sock_kfree_s\n- 参数: [sk, opt, opt->tot_len]\n- 调用者: inet6_destroy_sock\n- 被调用者: 未显示"
  },
  {
    "id": 993,
    "cwe": "CWE-416",
    "cve": "CVE-2016-3841",
    "purpose": "Code purpose:\"\"\"该代码用于重建IPv6套接字的头部信息，包括检查目标路由缓存、创建新的流标签和查找目标路由等操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致在特定情况下可能发生use-after-free错误，允许本地用户通过精心构造的sendmsg系统调用提升权限或造成拒绝服务\"\"\"",
    "functions": "Functions:\n1. 函数名: inet6_sk_rebuild_header\n- 参数: [struct sock *sk]\n- 调用者: 未显示\n- 被调用者: [inet6_sk, __sk_dst_check, inet_sk, memset, security_sk_classify_flow, fl6_update_dst, ip6_dst_lookup_flow, __ip6_dst_store]\n\n2. 函数名: inet6_sk\n- 参数: [struct sock *sk]\n- 调用者: inet6_sk_rebuild_header\n- 被调用者: 未显示\n\n3. 函数名: __sk_dst_check\n- 参数: [struct sock *sk, np->dst_cookie]\n- 调用者: inet6_sk_rebuild_header\n- 被调用者: 未显示\n\n4. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: inet6_sk_rebuild_header\n- 被调用者: 未显示\n\n5. 函数名: memset\n- 参数: [&fl6, 0, sizeof(fl6)]\n- 调用者: inet6_sk_rebuild_header\n- 被调用者: 未显示\n\n6. 函数名: security_sk_classify_flow\n- 参数: [sk, flowi6_to_flowi(&fl6)]\n- 调用者: inet6_sk_rebuild_header\n- 被调用者: 未显示\n\n7. 函数名: fl6_update_dst\n- 参数: [&fl6, np->opt, &final]\n- 调用者: inet6_sk_rebuild_header\n- 被调用者: 未显示\n\n8. 函数名: ip6_dst_lookup_flow\n- 参数: [sk, &fl6, final_p]\n- 调用者: inet6_sk_rebuild_header\n- 被调用者: 未显示\n\n9. 函数名: __ip6_dst_store\n- 参数: [sk, dst, NULL, NULL]\n- 调用者: inet6_sk_rebuild_header\n- 被调用者: 未显示"
  },
  {
    "id": 994,
    "cwe": "CWE-416",
    "cve": "CVE-2016-3841",
    "purpose": "Code purpose:\"\"\"该代码实现了IPv6数据报的连接功能，处理IPv6套接字连接请求并建立相应的路由和地址信息\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在use-after-free漏洞，本地用户可通过精心构造的sendmsg系统调用利用此漏洞获取权限或导致系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: __ip6_datagram_connect\n- 参数: [sk, uaddr, addr_len]\n- 调用者: 未显示（系统调用或内核其他部分）\n- 被调用者: [__ipv6_only_sock, __ip4_datagram_connect, fl6_sock_lookup, ipv6_addr_type, ipv6_addr_set_v4mapped, ipv6_addr_any, ipv6_mapped_addr_any, __ipv6_addr_needs_scope_id, security_sk_classify_flow, fl6_update_dst, ip6_dst_lookup_flow, ip6_dst_store, sk_set_txhash, fl6_sock_release]\n\n2. 函数名: __ipv6_only_sock\n- 参数: [sk]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n3. 函数名: __ip4_datagram_connect\n- 参数: [sk, uaddr, addr_len]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n4. 函数名: fl6_sock_lookup\n- 参数: [sk, fl6.flowlabel]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n5. 函数名: ipv6_addr_type\n- 参数: [&usin->sin6_addr]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n6. 函数名: ipv6_addr_set_v4mapped\n- 参数: [inet->inet_daddr, &sk->sk_v6_daddr], [inet->inet_saddr, &np->saddr], [inet->inet_rcv_saddr, &sk->sk_v6_rcv_saddr]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n7. 函数名: ipv6_addr_any\n- 参数: [&np->saddr], [&sk->sk_v6_rcv_saddr], [&np->saddr], [&sk->sk_v6_rcv_saddr]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n8. 函数名: ipv6_mapped_addr_any\n- 参数: [&np->saddr], [&sk->sk_v6_rcv_saddr]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n9. 函数名: __ipv6_addr_needs_scope_id\n- 参数: [addr_type]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n10. 函数名: security_sk_classify_flow\n- 参数: [sk, flowi6_to_flowi(&fl6)]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n11. 函数名: fl6_update_dst\n- 参数: [&fl6, opt, &final]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n12. 函数名: ip6_dst_lookup_flow\n- 参数: [sk, &fl6, final_p]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n13. 函数名: ip6_dst_store\n- 参数: [sk, dst, ipv6_addr_equal(&fl6.daddr, &sk->sk_v6_daddr) ? &sk->sk_v6_daddr : NULL, ipv6_addr_equal(&fl6.saddr, &np->saddr) ? &np->saddr : NULL]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n14. 函数名: sk_set_txhash\n- 参数: [sk]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n15. 函数名: fl6_sock_release\n- 参数: [flowlabel]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []"
  },
  {
    "id": 995,
    "cwe": "CWE-416",
    "cve": "CVE-2016-3841",
    "purpose": "Code purpose:\"\"\"复制IPv6传输选项结构体并调整其中的指针偏移量\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在复制IPv6选项时未正确处理内存指针，导致后续可能发生use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: ipv6_dup_options\n- 参数: [sk, opt]\n- 调用者: 未明确（由Linux内核IPv6栈调用）\n- 被调用者: [sock_kmalloc, memcpy]\n\n2. 函数名: sock_kmalloc\n- 参数: [sk, size, flags]\n- 调用者: ipv6_dup_options\n- 被调用者: []\n\n3. 函数名: memcpy\n- 参数: [dest, src, n]\n- 调用者: ipv6_dup_options\n- 被调用者: []"
  },
  {
    "id": 996,
    "cwe": "CWE-416",
    "cve": "CVE-2016-3841",
    "purpose": "Code purpose:\"\"\"该代码用于更新IPv6套接字的传输选项，包括处理各种IPv6选项头(如HOPOPTS、RTHDRDSTOPTS等)的重新分配和复制，并计算新的选项总长度。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在释放后使用(UAF)漏洞，由于未正确管理内存导致本地用户可通过精心构造的sendmsg系统调用触发该漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: ipv6_renew_options\n- 参数: [sk, opt, newtype, newopt, newoptlen]\n- 调用者: 未显示（由系统调用触发）\n- 被调用者: [CMSG_ALIGN, ipv6_optlen, sock_kmalloc, ERR_PTR, memset, ipv6_renew_option, sock_kfree_s]\n\n2. 函数名: CMSG_ALIGN\n- 参数: [未显示具体参数]\n- 调用者: ipv6_renew_options\n- 被调用者: []\n\n3. 函数名: ipv6_optlen\n- 参数: [未显示具体参数]\n- 调用者: ipv6_renew_options\n- 被调用者: []\n\n4. 函数名: sock_kmalloc\n- 参数: [sk, tot_len, GFP_ATOMIC]\n- 调用者: ipv6_renew_options\n- 被调用者: []\n\n5. 函数名: ERR_PTR\n- 参数: [err_code]\n- 调用者: ipv6_renew_options\n- 被调用者: []\n\n6. 函数名: memset\n- 参数: [opt2, 0, tot_len]\n- 调用者: ipv6_renew_options\n- 被调用者: []\n\n7. 函数名: ipv6_renew_option\n- 参数: [opt_old, newopt, newoptlen, condition, opt_new, p]\n- 调用者: ipv6_renew_options\n- 被调用者: []\n\n8. 函数名: sock_kfree_s\n- 参数: [sk, opt2, opt2->tot_len]\n- 调用者: ipv6_renew_options\n- 被调用者: []"
  },
  {
    "id": 997,
    "cwe": "CWE-416",
    "cve": "CVE-2016-3841",
    "purpose": "Code purpose:\"\"\"该代码用于为IPv6套接字创建或检查路由缓存条目，处理流标签、源/目的地址等网络流信息，并返回目标路由条目。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致在特定情况下可能发生释放后重用(use-after-free)漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: inet6_csk_route_socket\n- 参数: [struct sock *sk, struct flowi6 *fl6]\n- 调用者: 未指定\n- 被调用者: [inet_sk, inet6_sk, memset, IP6_ECN_flow_xmit, security_sk_classify_flow, flowi6_to_flowi, fl6_update_dst, __inet6_csk_dst_check, ip6_dst_lookup_flow, IS_ERR, __inet6_csk_dst_store]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: inet6_csk_route_socket\n- 被调用者: 未指定\n\n3. 函数名: inet6_sk\n- 参数: [struct sock *sk]\n- 调用者: inet6_csk_route_socket\n- 被调用者: 未指定\n\n4. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: inet6_csk_route_socket\n- 被调用者: 未指定\n\n5. 函数名: IP6_ECN_flow_xmit\n- 参数: [struct sock *sk, __be32 flowlabel]\n- 调用者: inet6_csk_route_socket\n- 被调用者: 未指定\n\n6. 函数名: security_sk_classify_flow\n- 参数: [struct sock *sk, struct flowi *fl]\n- 调用者: inet6_csk_route_socket\n- 被调用者: 未指定\n\n7. 函数名: flowi6_to_flowi\n- 参数: [struct flowi6 *fl6]\n- 调用者: inet6_csk_route_socket\n- 被调用者: 未指定\n\n8. 函数名: fl6_update_dst\n- 参数: [struct flowi6 *fl6, struct ipv6_txoptions *opt, struct in6_addr *final]\n- 调用者: inet6_csk_route_socket\n- 被调用者: 未指定\n\n9. 函数名: __inet6_csk_dst_check\n- 参数: [struct sock *sk, u32 cookie]\n- 调用者: inet6_csk_route_socket\n- 被调用者: 未指定\n\n10. 函数名: ip6_dst_lookup_flow\n- 参数: [struct sock *sk, struct flowi6 *fl6, struct in6_addr *final_dst]\n- 调用者: inet6_csk_route_socket\n- 被调用者: 未指定\n\n11. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: inet6_csk_route_socket\n- 被调用者: 未指定\n\n12. 函数名: __inet6_csk_dst_store\n- 参数: [struct sock *sk, struct dst_entry *dst, struct dst_entry *old_dst, struct dst_entry *new_dst]\n- 调用者: inet6_csk_route_socket\n- 被调用者: 未指定"
  },
  {
    "id": 998,
    "cwe": "CWE-416",
    "cve": "CVE-2016-3841",
    "purpose": "Code purpose:\"\"\"该代码用于在IPv6协议栈中为传入的连接请求创建路由条目，处理源地址、目的地址、端口等网络流信息，并最终查找和返回对应的路由目标。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致在精心构造的sendmsg系统调用下可能发生use-after-free错误，允许本地用户提升权限或引发拒绝服务\"\"\"",
    "functions": "Functions:\n1. 函数名: inet6_csk_route_req\n- 参数: [const struct sock *sk, struct flowi6 *fl6, const struct request_sock *req, u8 proto]\n- 调用者: 未指定\n- 被调用者: [inet_rsk, inet6_sk, memset, fl6_update_dst, htons, security_req_classify_flow, flowi6_to_flowi, ip6_dst_lookup_flow, IS_ERR]\n\n2. 函数名: inet_rsk\n- 参数: [const struct request_sock *req]\n- 调用者: inet6_csk_route_req\n- 被调用者: 未指定\n\n3. 函数名: inet6_sk\n- 参数: [const struct sock *sk]\n- 调用者: inet6_csk_route_req\n- 被调用者: 未指定\n\n4. 函数名: memset\n- 参数: [struct flowi6 *fl6, 0, sizeof(*fl6)]\n- 调用者: inet6_csk_route_req\n- 被调用者: 未指定\n\n5. 函数名: fl6_update_dst\n- 参数: [struct flowi6 *fl6, np->opt, &final]\n- 调用者: inet6_csk_route_req\n- 被调用者: 未指定\n\n6. 函数名: htons\n- 参数: [ireq->ir_num]\n- 调用者: inet6_csk_route_req\n- 被调用者: 未指定\n\n7. 函数名: security_req_classify_flow\n- 参数: [req, flowi6_to_flowi(fl6)]\n- 调用者: inet6_csk_route_req\n- 被调用者: [flowi6_to_flowi]\n\n8. 函数名: flowi6_to_flowi\n- 参数: [struct flowi6 *fl6]\n- 调用者: security_req_classify_flow\n- 被调用者: 未指定\n\n9. 函数名: ip6_dst_lookup_flow\n- 参数: [sk, fl6, final_p]\n- 调用者: inet6_csk_route_req\n- 被调用者: 未指定\n\n10. 函数名: IS_ERR\n- 参数: [dst]\n- 调用者: inet6_csk_route_req\n- 被调用者: 未指定"
  },
  {
    "id": 999,
    "cwe": "CWE-416",
    "cve": "CVE-2016-3841",
    "purpose": "Code purpose:\"\"\"该代码片段实现了IPv6套接字的数据发送功能，包括路由查找、目标地址设置和实际数据发送操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致在sendmsg系统调用中可能发生释放后重用(UAF)问题\"\"\"",
    "functions": "Functions:\n1. 函数名: inet6_csk_xmit\n- 参数: [sk, skb, fl_unused]\n- 调用者: 未指定\n- 被调用者: [inet6_sk, inet6_csk_route_socket, IS_ERR, PTR_ERR, kfree_skb, rcu_read_lock, skb_dst_set_noref, ip6_xmit, rcu_read_unlock]\n\n2. 函数名: inet6_sk\n- 参数: [sk]\n- 调用者: inet6_csk_xmit\n- 被调用者: 未指定\n\n3. 函数名: inet6_csk_route_socket\n- 参数: [sk, &fl6]\n- 调用者: inet6_csk_xmit\n- 被调用者: 未指定\n\n4. 函数名: IS_ERR\n- 参数: [dst]\n- 调用者: inet6_csk_xmit\n- 被调用者: 未指定\n\n5. 函数名: PTR_ERR\n- 参数: [dst]\n- 调用者: inet6_csk_xmit\n- 被调用者: 未指定\n\n6. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: inet6_csk_xmit\n- 被调用者: 未指定\n\n7. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: inet6_csk_xmit\n- 被调用者: 未指定\n\n8. 函数名: skb_dst_set_noref\n- 参数: [skb, dst]\n- 调用者: inet6_csk_xmit\n- 被调用者: 未指定\n\n9. 函数名: ip6_xmit\n- 参数: [sk, skb, &fl6, np->opt, np->tclass]\n- 调用者: inet6_csk_xmit\n- 被调用者: 未指定\n\n10. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: inet6_csk_xmit\n- 被调用者: 未指定"
  },
  {
    "id": 1000,
    "cwe": "CWE-416",
    "cve": "CVE-2016-3841",
    "purpose": "Code purpose:\"\"\"该代码用于更新IPv6套接字的传输选项，处理选项长度并同步最大段大小(MSS)。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在释放后使用漏洞，由于未正确管理ipv6_txoptions结构体的生命周期，导致本地用户可通过特制的sendmsg系统调用触发该漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: ipv6_update_options\n- 参数: [sk, opt]\n- 调用者: 未明确（由系统调用触发）\n- 被调用者: [inet_sk, inet_csk, xchg, sk_dst_reset]\n\n2. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: ipv6_update_options\n- 被调用者: []\n\n3. 函数名: inet_csk\n- 参数: [sk]\n- 调用者: ipv6_update_options\n- 被调用者: []\n\n4. 函数名: xchg\n- 参数: [&inet6_sk(sk)->opt, opt]\n- 调用者: ipv6_update_options\n- 被调用者: []\n\n5. 函数名: sk_dst_reset\n- 参数: [sk]\n- 调用者: ipv6_update_options\n- 被调用者: []\n\n6. 函数名: icsk_sync_mss\n- 参数: [sk, icsk->icsk_pmtu_cookie]\n- 调用者: ipv6_update_options\n- 被调用者: []"
  },
  {
    "id": 1001,
    "cwe": "CWE-416",
    "cve": "CVE-2016-3841",
    "purpose": "Code purpose:\"\"\"处理IPv6套接字选项的设置，包括地址格式、多播、流标签等多种选项的配置和验证\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在释放后使用(UAF)漏洞，本地攻击者可通过精心构造的sendmsg系统调用利用此漏洞获取权限或导致系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: do_ipv6_setsockopt\n- 参数: [struct sock *sk, int level, int optname, char __user *optval, unsigned int optlen]\n- 调用者: 系统调用\n- 被调用者: [sock_net, setsockopt_needs_rtnl, get_user, ip6_mroute_opt, ip6_mroute_setsockopt, rtnl_lock, lock_sock, udp_sk, ipv6_only_sock, ipv6_addr_v4mapped, fl6_free_socklist, ipv6_sock_mc_close, sk_refcnt_debug_dec, sock_prot_inuse_add, local_bh_disable, local_bh_enable, tcp_sync_mss, xchg, sock_kfree_s, kfree_skb, sk_refcnt_debug_inc, module_put, ns_capable, ipv6_renew_options, ipv6_update_options, copy_from_user, dev_get_by_index, dev_put, ipv6_sock_mc_join, ipv6_sock_mc_drop, ipv6_sock_ac_join, ipv6_sock_ac_drop, ip6_mc_source, ip6_mc_msfilter, ip6_ra_control, xfrm_user_policy, ipv6_flowlabel_opt, release_sock, rtnl_unlock]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n3. 函数名: setsockopt_needs_rtnl\n- 参数: [int optname]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n4. 函数名: get_user\n- 参数: [int val, int __user *optval]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n5. 函数名: ip6_mroute_opt\n- 参数: [int optname]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n6. 函数名: ip6_mroute_setsockopt\n- 参数: [struct sock *sk, int optname, char __user *optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n7. 函数名: rtnl_lock\n- 参数: []\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n8. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n9. 函数名: udp_sk\n- 参数: [struct sock *sk]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n10. 函数名: ipv6_only_sock\n- 参数: [struct sock *sk]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n11. 函数名: ipv6_addr_v4mapped\n- 参数: [struct in6_addr *addr]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n12. 函数名: fl6_free_socklist\n- 参数: [struct sock *sk]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n13. 函数名: ipv6_sock_mc_close\n- 参数: [struct sock *sk]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n14. 函数名: sk_refcnt_debug_dec\n- 参数: [struct sock *sk]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n15. 函数名: sock_prot_inuse_add\n- 参数: [struct net *net, struct proto *prot, int val]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n16. 函数名: local_bh_disable\n- 参数: []\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n17. 函数名: local_bh_enable\n- 参数: []\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n18. 函数名: tcp_sync_mss\n- 参数: [struct sock *sk, u32 pmtu]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n19. 函数名: xchg\n- 参数: [struct ipv6_txoptions **np_opt, NULL]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n20. 函数名: sock_kfree_s\n- 参数: [struct sock *sk, void *mem, int size]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n21. 函数名: kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n22. 函数名: sk_refcnt_debug_inc\n- 参数: [struct sock *sk]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n23. 函数名: module_put\n- 参数: [struct module *mod]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n24. 函数名: ns_capable\n- 参数: [struct user_namespace *ns, int cap]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n25. 函数名: ipv6_renew_options\n- 参数: [struct sock *sk, struct ipv6_txoptions *opt, int optname, struct ipv6_opt_hdr __user *optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n26. 函数名: ipv6_update_options\n- 参数: [struct sock *sk, struct ipv6_txoptions *opt]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n27. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n28. 函数名: dev_get_by_index\n- 参数: [struct net *net, int ifindex]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n29. 函数名: dev_put\n- 参数: [struct net_device *dev]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n30. 函数名: ipv6_sock_mc_join\n- 参数: [struct sock *sk, int ifindex, struct in6_addr *addr]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n31. 函数名: ipv6_sock_mc_drop\n- 参数: [struct sock *sk, int ifindex, struct in6_addr *addr]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n32. 函数名: ipv6_sock_ac_join\n- 参数: [struct sock *sk, int ifindex, struct in6_addr *addr]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n33. 函数名: ipv6_sock_ac_drop\n- 参数: [struct sock *sk, int ifindex, struct in6_addr *addr]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n34. 函数名: ip6_mc_source\n- 参数: [int add, int omode, struct sock *sk, struct group_source_req *p]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n35. 函数名: ip6_mc_msfilter\n- 参数: [struct sock *sk, struct group_filter *gsf]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n36. 函数名: ip6_ra_control\n- 参数: [struct sock *sk, int val]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n37. 函数名: xfrm_user_policy\n- 参数: [struct sock *sk, int optname, char __user *optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n38. 函数名: ipv6_flowlabel_opt\n- 参数: [struct sock *sk, char __user *optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n39. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n40. 函数名: rtnl_unlock\n- 参数: []\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []"
  },
  {
    "id": 1002,
    "cwe": "CWE-416",
    "cve": "CVE-2016-3841",
    "purpose": "Code purpose:\"\"\"该代码实现了IPv6套接字选项的获取功能，处理不同类型的IPv6选项请求并返回相应的配置信息或状态值。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在释放后使用漏洞，本地攻击者可通过精心构造的sendmsg系统调用利用此漏洞获取权限或导致系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: do_ipv6_getsockopt\n- 参数: [struct sock *sk, int level, int optname, char __user *optval, int __user *optlen, unsigned int flags]\n- 调用者: 未显示\n- 被调用者: [ip6_mroute_getsockopt, get_user, copy_from_user, lock_sock, ip6_mc_msfget, release_sock, ip6_datagram_recv_ctl, put_cmsg, __sk_dst_get, dst_mtu, ipv6_getsockopt_sticky, put_user, copy_to_user, ipv6_flowlabel_opt_get]\n\n2. 函数名: ip6_mroute_getsockopt\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n3. 函数名: get_user\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n4. 函数名: copy_from_user\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n5. 函数名: lock_sock\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n6. 函数名: ip6_mc_msfget\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n7. 函数名: release_sock\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n8. 函数名: ip6_datagram_recv_ctl\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n9. 函数名: put_cmsg\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n10. 函数名: __sk_dst_get\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n11. 函数名: dst_mtu\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n12. 函数名: ipv6_getsockopt_sticky\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n13. 函数名: put_user\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n14. 函数名: copy_to_user\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n15. 函数名: ipv6_flowlabel_opt_get\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示"
  },
  {
    "id": 1003,
    "cwe": "CWE-416",
    "cve": "CVE-2016-3841",
    "purpose": "Code purpose:\"\"\"处理IPv6原始套接字发送消息的请求，包括地址验证、流标签处理、选项设置和数据发送等功能\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致本地用户可通过精心构造的sendmsg系统调用触发释放后使用漏洞，从而获取权限或造成系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: rawv6_sendmsg\n- 参数: [struct sock *sk, struct msghdr *msg, size_t len]\n- 调用者: 系统调用\n- 被调用者: [fl6_sock_lookup, ip6_datagram_send_ctl, fl6_sock_release, fl6_merge_options, ipv6_fixup_options, rawv6_probe_proto_opt, fl6_update_dst, ip6_dst_lookup_flow, ip6_sk_dst_hoplimit, rawv6_send_hdrinc, ip6_append_data, ip6_flush_pending_frames, rawv6_push_pending_frames, dst_release, dst_confirm]\n\n2. 函数名: fl6_sock_lookup\n- 参数: [struct sock *sk, fl6.flowlabel]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n3. 函数名: ip6_datagram_send_ctl\n- 参数: [sock_net(sk), sk, msg, &fl6, opt, &hlimit, &tclass, &dontfrag]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n4. 函数名: fl6_sock_release\n- 参数: [flowlabel]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n5. 函数名: fl6_merge_options\n- 参数: [&opt_space, flowlabel, opt]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n6. 函数名: ipv6_fixup_options\n- 参数: [&opt_space, opt]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n7. 函数名: rawv6_probe_proto_opt\n- 参数: [&rfv, &fl6]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n8. 函数名: fl6_update_dst\n- 参数: [&fl6, opt, &final]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n9. 函数名: ip6_dst_lookup_flow\n- 参数: [sk, &fl6, final_p]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n10. 函数名: ip6_sk_dst_hoplimit\n- 参数: [np, &fl6, dst]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n11. 函数名: rawv6_send_hdrinc\n- 参数: [sk, msg, len, &fl6, &dst, msg->msg_flags]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n12. 函数名: ip6_append_data\n- 参数: [sk, raw6_getfrag, &rfv, len, 0, hlimit, tclass, opt, &fl6, (struct rt6_info *)dst, msg->msg_flags, dontfrag]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n13. 函数名: ip6_flush_pending_frames\n- 参数: [sk]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n14. 函数名: rawv6_push_pending_frames\n- 参数: [sk, &fl6, rp]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n15. 函数名: dst_release\n- 参数: [dst]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n16. 函数名: dst_confirm\n- 参数: [dst]\n- 调用者: rawv6_sendmsg\n- 被调用者: []"
  },
  {
    "id": 1004,
    "cwe": "CWE-416",
    "cve": "CVE-2016-3841",
    "purpose": "Code purpose:\"\"\"该代码用于处理IPv6 TCP同步cookie验证，验证接收到的TCP SYN-ACK报文中的cookie有效性并建立相应的请求套接字\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致在精心构造的sendmsg系统调用下可能发生use-after-free错误，允许本地用户提升权限或引发拒绝服务\"\"\"",
    "functions": "Functions:\n1. 函数名: cookie_v6_check\n- 参数: [struct sock *sk, struct sk_buff *skb]\n- 调用者: 未显示\n- 被调用者: [tcp_synq_no_recent_overflow, __cookie_v6_check, tcp_parse_options, cookie_timestamp_decode, inet_reqsk_alloc, security_inet_conn_request, ipv6_opt_accepted, tcp_v6_iif, inet_request_mark, fl6_update_dst, ip6_dst_lookup_flow, tcp_select_initial_window, tcp_get_cookie_sock, reqsk_free]\n\n2. 函数名: tcp_synq_no_recent_overflow\n- 参数: [struct sock *sk]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n3. 函数名: __cookie_v6_check\n- 参数: [ipv6_hdr(skb), th, cookie]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n4. 函数名: tcp_parse_options\n- 参数: [skb, &tcp_opt, 0, NULL]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n5. 函数名: cookie_timestamp_decode\n- 参数: [&tcp_opt]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n6. 函数名: inet_reqsk_alloc\n- 参数: [&tcp6_request_sock_ops, sk, false]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n7. 函数名: security_inet_conn_request\n- 参数: [sk, skb, req]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n8. 函数名: ipv6_opt_accepted\n- 参数: [sk, skb, &TCP_SKB_CB(skb)->header.h6]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n9. 函数名: tcp_v6_iif\n- 参数: [skb]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n10. 函数名: inet_request_mark\n- 参数: [sk, skb]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n11. 函数名: fl6_update_dst\n- 参数: [&fl6, np->opt, &final]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n12. 函数名: ip6_dst_lookup_flow\n- 参数: [sk, &fl6, final_p]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n13. 函数名: tcp_select_initial_window\n- 参数: [tcp_full_space(sk), req->mss, &req->rsk_rcv_wnd, &req->rsk_window_clamp, ireq->wscale_ok, &rcv_wscale, dst_metric(dst, RTAX_INITRWND)]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n14. 函数名: tcp_get_cookie_sock\n- 参数: [sk, skb, req, dst]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n15. 函数名: reqsk_free\n- 参数: [req]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示"
  },
  {
    "id": 1005,
    "cwe": "CWE-416",
    "cve": "CVE-2016-3841",
    "purpose": "Code purpose:\"\"\"该代码片段实现了Linux内核中IPv6协议栈发送SYN-ACK响应的功能，用于TCP连接建立过程中的三次握手阶段。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致在精心构造的sendmsg系统调用下可能发生释放后重用(use-after-free)，从而允许本地用户提升权限或引发拒绝服务\"\"\"",
    "functions": "Functions:\n1. 函数名: tcp_v6_send_synack\n- 参数: [const struct sock *sk, struct dst_entry *dst, struct flowi *fl, struct request_sock *req, struct tcp_fastopen_cookie *foc, bool attach_req]\n- 调用者: 未显示\n- 被调用者: [inet_rsk, inet6_sk, inet6_csk_route_req, tcp_make_synack, __tcp_v6_send_check, ip6_flowlabel, ipv6_hdr, ip6_xmit, net_xmit_eval]\n\n2. 函数名: inet_rsk\n- 参数: [struct request_sock *req]\n- 调用者: tcp_v6_send_synack\n- 被调用者: 未显示\n\n3. 函数名: inet6_sk\n- 参数: [const struct sock *sk]\n- 调用者: tcp_v6_send_synack\n- 被调用者: 未显示\n\n4. 函数名: inet6_csk_route_req\n- 参数: [const struct sock *sk, struct flowi6 *fl6, struct request_sock *req, int protocol]\n- 调用者: tcp_v6_send_synack\n- 被调用者: 未显示\n\n5. 函数名: tcp_make_synack\n- 参数: [const struct sock *sk, struct dst_entry *dst, struct request_sock *req, struct tcp_fastopen_cookie *foc, bool attach_req]\n- 调用者: tcp_v6_send_synack\n- 被调用者: 未显示\n\n6. 函数名: __tcp_v6_send_check\n- 参数: [struct sk_buff *skb, const struct in6_addr *saddr, const struct in6_addr *daddr]\n- 调用者: tcp_v6_send_synack\n- 被调用者: 未显示\n\n7. 函数名: ip6_flowlabel\n- 参数: [struct ipv6hdr *hdr]\n- 调用者: tcp_v6_send_synack\n- 被调用者: 未显示\n\n8. 函数名: ipv6_hdr\n- 参数: [const struct sk_buff *skb]\n- 调用者: tcp_v6_send_synack\n- 被调用者: 未显示\n\n9. 函数名: ip6_xmit\n- 参数: [struct sock *sk, struct sk_buff *skb, struct flowi6 *fl6, struct ipv6_txoptions *opt, int tclass]\n- 调用者: tcp_v6_send_synack\n- 被调用者: 未显示\n\n10. 函数名: net_xmit_eval\n- 参数: [int err]\n- 调用者: tcp_v6_send_synack\n- 被调用者: 未显示"
  },
  {
    "id": 1006,
    "cwe": "CWE-416",
    "cve": "CVE-2016-3841",
    "purpose": "Code purpose:\"\"\"处理IPv6 TCP连接的同步接收套接字创建过程，包括IPv4映射地址的处理和套接字选项的复制\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致在精心构造的sendmsg系统调用下可能发生use-after-free错误，从而允许本地用户提升权限或造成拒绝服务\"\"\"",
    "functions": "Functions:\n1. 函数名: tcp_v6_syn_recv_sock\n- 参数: [sk, skb, req, dst, req_unhash, own_req]\n- 调用者: 未显示（由内核TCP/IP协议栈调用）\n- 被调用者: [tcp_v4_syn_recv_sock, inet6_sk, inet_sk, tcp_sk, memcpy, inet_csk, tcp_sync_mss, sk_acceptq_is_full, inet6_csk_route_req, tcp_create_openreq_child, __ip6_dst_store, inet6_sk_rx_dst_set, ipv6_dup_options, tcp_ca_openreq_child, dst_mtu, dst_metric_advmss, tcp_initialize_rcv_mss, tcp_v6_md5_do_lookup, tcp_md5_do_add, __inet_inherit_port, inet_csk_prepare_forced_close, tcp_done, inet_ehash_nolisten, tcp_move_syn, skb_clone, consume_skb, skb_set_owner_r, NET_INC_STATS_BH, dst_release]\n\n2. 函数名: tcp_v4_syn_recv_sock\n- 参数: [sk, skb, req, dst, req_unhash, own_req]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n3. 函数名: inet6_sk\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n4. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n5. 函数名: tcp_sk\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n6. 函数名: memcpy\n- 参数: [dest, src, n]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n7. 函数名: inet_csk\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n8. 函数名: tcp_sync_mss\n- 参数: [sk, pmtu]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n9. 函数名: sk_acceptq_is_full\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n10. 函数名: inet6_csk_route_req\n- 参数: [sk, fl6, req, proto]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n11. 函数名: tcp_create_openreq_child\n- 参数: [sk, req, skb]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n12. 函数名: __ip6_dst_store\n- 参数: [sk, dst, saddr, daddr]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n13. 函数名: inet6_sk_rx_dst_set\n- 参数: [sk, skb]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n14. 函数名: ipv6_dup_options\n- 参数: [sk, opt]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n15. 函数名: tcp_ca_openreq_child\n- 参数: [sk, dst]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n16. 函数名: dst_mtu\n- 参数: [dst]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n17. 函数名: dst_metric_advmss\n- 参数: [dst]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n18. 函数名: tcp_initialize_rcv_mss\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n19. 函数名: tcp_v6_md5_do_lookup\n- 参数: [sk, addr]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n20. 函数名: tcp_md5_do_add\n- 参数: [sk, addr, family, key, keylen, gfp]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n21. 函数名: __inet_inherit_port\n- 参数: [sk, newsk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n22. 函数名: inet_csk_prepare_forced_close\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n23. 函数名: tcp_done\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n24. 函数名: inet_ehash_nolisten\n- 参数: [sk, sk2]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n25. 函数名: tcp_move_syn\n- 参数: [tp, req]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n26. 函数名: skb_clone\n- 参数: [skb, gfp_mask]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n27. 函数名: consume_skb\n- 参数: [skb]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n28. 函数名: skb_set_owner_r\n- 参数: [skb, sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n29. 函数名: NET_INC_STATS_BH\n- 参数: [net, stat]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n30. 函数名: dst_release\n- 参数: [dst]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示"
  },
  {
    "id": 1007,
    "cwe": "CWE-416",
    "cve": "CVE-2016-3841",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中IPv6协议栈的TCP连接功能，处理IPv6地址转换、流标签、多播地址检查等操作，并建立TCP连接\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致本地用户可通过精心构造的sendmsg系统调用触发释放后重用漏洞，从而获取权限或造成系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: tcp_v6_connect\n- 参数: [struct sock *sk, struct sockaddr *uaddr, int addr_len]\n- 调用者: 无（系统调用）\n- 被调用者: [inet_sk, inet_csk, tcp_sk, inet6_sk, ipv6_addr_any, ipv6_addr_type, ipv6_addr_equal, fl6_sock_lookup, fl6_sock_release, __ipv6_only_sock, tcp_v4_connect, fl6_update_dst, security_sk_classify_flow, ip6_dst_lookup_flow, __ip6_dst_store, tcp_fetch_timewait_stamp, tcp_set_state, inet6_hash_connect, sk_set_txhash, secure_tcpv6_sequence_number, tcp_connect, __sk_dst_reset]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n3. 函数名: inet_csk\n- 参数: [struct sock *sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n4. 函数名: tcp_sk\n- 参数: [struct sock *sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n5. 函数名: inet6_sk\n- 参数: [struct sock *sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n6. 函数名: ipv6_addr_any\n- 参数: [const struct in6_addr *addr]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n7. 函数名: ipv6_addr_type\n- 参数: [const struct in6_addr *addr]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n8. 函数名: ipv6_addr_equal\n- 参数: [const struct in6_addr *a1, const struct in6_addr *a2]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n9. 函数名: fl6_sock_lookup\n- 参数: [struct sock *sk, __be32 label]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n10. 函数名: fl6_sock_release\n- 参数: [struct ip6_flowlabel *fl]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n11. 函数名: __ipv6_only_sock\n- 参数: [struct sock *sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n12. 函数名: tcp_v4_connect\n- 参数: [struct sock *sk, struct sockaddr *uaddr, int addr_len]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n13. 函数名: fl6_update_dst\n- 参数: [struct flowi6 *fl6, struct ipv6_txoptions *opt, struct in6_addr *final]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n14. 函数名: security_sk_classify_flow\n- 参数: [struct sock *sk, struct flowi *fl]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n15. 函数名: ip6_dst_lookup_flow\n- 参数: [struct sock *sk, struct flowi6 *fl6, struct in6_addr *final]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n16. 函数名: __ip6_dst_store\n- 参数: [struct sock *sk, struct dst_entry *dst, struct dst_entry *old, struct dst_entry *(*gc)(struct dst_entry *)]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n17. 函数名: tcp_fetch_timewait_stamp\n- 参数: [struct sock *sk, struct dst_entry *dst]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n18. 函数名: tcp_set_state\n- 参数: [struct sock *sk, int state]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n19. 函数名: inet6_hash_connect\n- 参数: [struct inet_timewait_death_row *death_row, struct sock *sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n20. 函数名: sk_set_txhash\n- 参数: [struct sock *sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n21. 函数名: secure_tcpv6_sequence_number\n- 参数: [__be32 *saddr, __be32 *daddr, __be16 sport, __be16 dport]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n22. 函数名: tcp_connect\n- 参数: [struct sock *sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n23. 函数名: __sk_dst_reset\n- 参数: [struct sock *sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无"
  },
  {
    "id": 1008,
    "cwe": "CWE-416",
    "cve": "CVE-2016-3841",
    "purpose": "Code purpose:\"\"\"处理IPv6 UDP套接字发送消息的请求，包括地址验证、选项处理和实际数据发送等功能。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在use-after-free漏洞，本地用户可通过精心构造的sendmsg系统调用利用此漏洞获取权限或导致系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: udpv6_sendmsg\n- 参数: [struct sock *sk, struct msghdr *msg, size_t len]\n- 调用者: 系统调用\n- 被调用者: [udp_sendmsg, udplite_getfrag, ip_generic_getfrag, lock_sock, release_sock, fl6_sock_lookup, ip6_datagram_send_ctl, fl6_sock_release, fl6_merge_options, ipv6_fixup_options, fl6_update_dst, security_sk_classify_flow, ip6_sk_dst_lookup_flow, ip6_make_skb, udp_v6_send_skb, ip6_append_data, udp_v6_flush_pending_frames, udp_v6_push_pending_frames, ip6_dst_store, dst_release, dst_confirm]\n\n2. 函数名: udp_sendmsg\n- 参数: [struct sock *sk, struct msghdr *msg, size_t len]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n3. 函数名: udplite_getfrag\n- 参数: [void *, char *, int, int, int, struct sk_buff *]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n4. 函数名: ip_generic_getfrag\n- 参数: [void *, char *, int, int, int, struct sk_buff *]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n5. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n6. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n7. 函数名: fl6_sock_lookup\n- 参数: [struct sock *sk, fl6.flowlabel]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n8. 函数名: ip6_datagram_send_ctl\n- 参数: [sock_net(sk), sk, msg, &fl6, opt, &hlimit, &tclass, &dontfrag]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n9. 函数名: fl6_sock_release\n- 参数: [flowlabel]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n10. 函数名: fl6_merge_options\n- 参数: [&opt_space, flowlabel, opt]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n11. 函数名: ipv6_fixup_options\n- 参数: [&opt_space, opt]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n12. 函数名: fl6_update_dst\n- 参数: [&fl6, opt, &final]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n13. 函数名: security_sk_classify_flow\n- 参数: [sk, flowi6_to_flowi(&fl6)]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n14. 函数名: ip6_sk_dst_lookup_flow\n- 参数: [sk, &fl6, final_p]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n15. 函数名: ip6_make_skb\n- 参数: [sk, getfrag, msg, ulen, sizeof(struct udphdr), hlimit, tclass, opt, &fl6, (struct rt6_info *)dst, msg->msg_flags, dontfrag]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n16. 函数名: udp_v6_send_skb\n- 参数: [skb, &fl6]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n17. 函数名: ip6_append_data\n- 参数: [sk, getfrag, msg, ulen, sizeof(struct udphdr), hlimit, tclass, opt, &fl6, (struct rt6_info *)dst, corkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags, dontfrag]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n18. 函数名: udp_v6_flush_pending_frames\n- 参数: [sk]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n19. 函数名: udp_v6_push_pending_frames\n- 参数: [sk]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n20. 函数名: ip6_dst_store\n- 参数: [sk, dst, ipv6_addr_equal(&fl6.daddr, &sk->sk_v6_daddr) ? &sk->sk_v6_daddr : NULL, #ifdef CONFIG_IPV6_SUBTREES ipv6_addr_equal(&fl6.saddr, &np->saddr) ? &np->saddr : #endif NULL]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n21. 函数名: dst_release\n- 参数: [dst]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n22. 函数名: dst_confirm\n- 参数: [dst]\n- 调用者: udpv6_sendmsg\n- 被调用者: []"
  },
  {
    "id": 1009,
    "cwe": "CWE-416",
    "cve": "CVE-2016-3841",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中L2TP over IPv6协议的数据发送功能，处理消息头、地址验证、流标签管理和数据包发送等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致本地用户可通过精心构造的sendmsg系统调用触发释放后重用漏洞，从而获取权限或造成系统崩溃。\"\"\"",
    "functions": "Functions:\n1. 函数名: l2tp_ip6_sendmsg\n- 参数: [struct sock *sk, struct msghdr *msg, size_t len]\n- 调用者: 系统调用sendmsg\n- 被调用者: [fl6_sock_lookup, ip6_datagram_send_ctl, fl6_sock_release, fl6_merge_options, ipv6_fixup_options, fl6_update_dst, security_sk_classify_flow, ip6_dst_lookup_flow, ip6_sk_dst_hoplimit, ip6_append_data, ip6_flush_pending_frames, l2tp_ip6_push_pending_frames, dst_release, dst_confirm]\n\n2. 函数名: fl6_sock_lookup\n- 参数: [struct sock *sk, fl6.flowlabel]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n3. 函数名: ip6_datagram_send_ctl\n- 参数: [sock_net(sk), sk, msg, &fl6, opt, &hlimit, &tclass, &dontfrag]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n4. 函数名: fl6_sock_release\n- 参数: [flowlabel]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n5. 函数名: fl6_merge_options\n- 参数: [&opt_space, flowlabel, opt]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n6. 函数名: ipv6_fixup_options\n- 参数: [&opt_space, opt]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n7. 函数名: fl6_update_dst\n- 参数: [&fl6, opt, &final]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n8. 函数名: security_sk_classify_flow\n- 参数: [sk, flowi6_to_flowi(&fl6)]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n9. 函数名: ip6_dst_lookup_flow\n- 参数: [sk, &fl6, final_p]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n10. 函数名: ip6_sk_dst_hoplimit\n- 参数: [np, &fl6, dst]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n11. 函数名: ip6_append_data\n- 参数: [sk, ip_generic_getfrag, msg, ulen, transhdrlen, hlimit, tclass, opt, &fl6, (struct rt6_info *)dst, msg->msg_flags, dontfrag]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n12. 函数名: ip6_flush_pending_frames\n- 参数: [sk]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n13. 函数名: l2tp_ip6_push_pending_frames\n- 参数: [sk]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n14. 函数名: dst_release\n- 参数: [dst]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n15. 函数名: dst_confirm\n- 参数: [dst]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []"
  },
  {
    "id": 1035,
    "cwe": "CWE-416",
    "cve": "CVE-2016-4805",
    "purpose": "Code purpose:\"\"\"该代码用于注销PPP通道，包括释放相关资源、断开连接并从网络命名空间中移除通道\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在释放通道资源后未正确处理网络命名空间的引用，导致在移除网络命名空间时可能访问已释放的内存区域\"\"\"",
    "functions": "Functions:\n1. 函数名: ppp_unregister_channel\n- 参数: [struct ppp_channel *chan]\n- 调用者: 未明确（由系统调用或内核其他部分调用）\n- 被调用者: [down_write, spin_lock_bh, spin_unlock_bh, up_write, ppp_disconnect_channel, ppp_pernet, list_del, wake_up_interruptible, atomic_dec_and_test, ppp_destroy_channel]\n\n2. 函数名: down_write\n- 参数: [&pch->chan_sem]\n- 调用者: ppp_unregister_channel\n- 被调用者: []\n\n3. 函数名: spin_lock_bh\n- 参数: [&pch->downl], [&pn->all_channels_lock]\n- 调用者: ppp_unregister_channel\n- 被调用者: []\n\n4. 函数名: spin_unlock_bh\n- 参数: [&pch->downl], [&pn->all_channels_lock]\n- 调用者: ppp_unregister_channel\n- 被调用者: []\n\n5. 函数名: up_write\n- 参数: [&pch->chan_sem]\n- 调用者: ppp_unregister_channel\n- 被调用者: []\n\n6. 函数名: ppp_disconnect_channel\n- 参数: [pch]\n- 调用者: ppp_unregister_channel\n- 被调用者: []\n\n7. 函数名: ppp_pernet\n- 参数: [pch->chan_net]\n- 调用者: ppp_unregister_channel\n- 被调用者: []\n\n8. 函数名: list_del\n- 参数: [&pch->list]\n- 调用者: ppp_unregister_channel\n- 被调用者: []\n\n9. 函数名: wake_up_interruptible\n- 参数: [&pch->file.rwait]\n- 调用者: ppp_unregister_channel\n- 被调用者: []\n\n10. 函数名: atomic_dec_and_test\n- 参数: [&pch->file.refcnt]\n- 调用者: ppp_unregister_channel\n- 被调用者: []\n\n11. 函数名: ppp_destroy_channel\n- 参数: [pch]\n- 调用者: ppp_unregister_channel\n- 被调用者: []"
  },
  {
    "id": 1036,
    "cwe": "CWE-416",
    "cve": "CVE-2016-4805",
    "purpose": "Code purpose:\"\"\"注册PPP网络通道并将其添加到网络命名空间的新通道列表中\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在移除网络命名空间时未正确处理ppp_register_net_channel和ppp_unregister_channel函数间的同步，导致释放后重用(use-after-free)漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: ppp_register_net_channel\n- 参数: [net, chan]\n- 调用者: 未显示\n- 被调用者: [kzalloc, ppp_pernet, init_ppp_file, init_rwsem, spin_lock_init, rwlock_init, spin_lock_bh, list_add, atomic_inc, spin_unlock_bh]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(struct channel), GFP_KERNEL]\n- 调用者: ppp_register_net_channel\n- 被调用者: 未显示\n\n3. 函数名: ppp_pernet\n- 参数: [net]\n- 调用者: ppp_register_net_channel\n- 被调用者: 未显示\n\n4. 函数名: init_ppp_file\n- 参数: [&pch->file, CHANNEL]\n- 调用者: ppp_register_net_channel\n- 被调用者: 未显示\n\n5. 函数名: init_rwsem\n- 参数: [&pch->chan_sem]\n- 调用者: ppp_register_net_channel\n- 被调用者: 未显示\n\n6. 函数名: spin_lock_init\n- 参数: [&pch->downl]\n- 调用者: ppp_register_net_channel\n- 被调用者: 未显示\n\n7. 函数名: rwlock_init\n- 参数: [&pch->upl]\n- 调用者: ppp_register_net_channel\n- 被调用者: 未显示\n\n8. 函数名: spin_lock_bh\n- 参数: [&pn->all_channels_lock]\n- 调用者: ppp_register_net_channel\n- 被调用者: 未显示\n\n9. 函数名: list_add\n- 参数: [&pch->list, &pn->new_channels]\n- 调用者: ppp_register_net_channel\n- 被调用者: 未显示\n\n10. 函数名: atomic_inc\n- 参数: [&channel_count]\n- 调用者: ppp_register_net_channel\n- 被调用者: 未显示\n\n11. 函数名: spin_unlock_bh\n- 参数: [&pn->all_channels_lock]\n- 调用者: ppp_register_net_channel\n- 被调用者: 未显示"
  },
  {
    "id": 1091,
    "cwe": "CWE-416",
    "cve": "CVE-2016-6828",
    "purpose": "Code purpose:\"\"\"检查并更新TCP发送队列头指针，防止因数据复制失败导致的SACK状态不一致问题\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"内核在维护TCP SACK状态时，未能正确处理数据复制失败后的sk_send_head指针，导致后续可能发生use-after-free问题\"\"\"",
    "functions": "Functions:\n1. 函数名: tcp_check_send_head\n- 参数: [sk, skb_unlinked]\n- 调用者: 未明确（可能是TCP协议栈中处理SACK选项的相关函数）\n- 被调用者: []"
  },
  {
    "id": 1109,
    "cwe": "CWE-416",
    "cve": "CVE-2016-7910",
    "purpose": "Code purpose:\"\"\"在停止磁盘序列文件操作时释放迭代器资源\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在disk_seqf_stop函数中，即使对应的start操作失败，仍会执行stop操作释放iter指针，导致后续可能发生use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: disk_seqf_stop\n- 参数: [struct seq_file *seqf, void *v]\n- 调用者: 未明确（由内核序列文件系统调用）\n- 被调用者: [class_dev_iter_exit, kfree]\n\n2. 函数名: class_dev_iter_exit\n- 参数: [struct class_dev_iter *iter]\n- 调用者: disk_seqf_stop\n- 被调用者: []\n\n3. 函数名: kfree\n- 参数: [void *ptr]\n- 调用者: disk_seqf_stop\n- 被调用者: []"
  },
  {
    "id": 1110,
    "cwe": "CWE-416",
    "cve": "CVE-2016-7911",
    "purpose": "Code purpose:\"\"\"获取指定任务的I/O优先级值，包括安全检查并返回默认或任务特定的I/O优先级\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在get_task_ioprio函数中访问p->io_context时存在竞态条件，可能导致在释放io_context后仍被访问，造成use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: get_task_ioprio\n- 参数: [struct task_struct *p]\n- 调用者: 未明确显示（由系统调用ioprio_get触发）\n- 被调用者: [security_task_getioprio, IOPRIO_PRIO_VALUE]\n\n2. 函数名: security_task_getioprio\n- 参数: [struct task_struct *p]\n- 调用者: get_task_ioprio\n- 被调用者: []\n\n3. 函数名: IOPRIO_PRIO_VALUE\n- 参数: [IOPRIO_CLASS_NONE, IOPRIO_NORM]（宏参数）\n- 调用者: get_task_ioprio\n- 被调用者: []"
  },
  {
    "id": 1111,
    "cwe": "CWE-416",
    "cve": "CVE-2016-7912",
    "purpose": "Code purpose:\"\"\"该代码用于处理USB功能文件系统(FFS)中的用户空间I/O数据拷贝工作，包括数据拷贝、完成回调通知和资源释放等功能。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在ffs_user_copy_worker函数中，io_data结构体在回调函数ki_complete执行后被释放，但回调函数可能仍会访问该结构体，导致释放后使用漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: ffs_user_copy_worker\n- 参数: [work]\n- 调用者: N/A (workqueue callback)\n- 被调用者: [container_of, use_mm, copy_to_iter, iov_iter_count, unuse_mm, eventfd_signal, usb_ep_free_request, kfree]\n\n2. 函数名: container_of\n- 参数: [work, struct ffs_io_data, work]\n- 调用者: ffs_user_copy_worker\n- 被调用者: N/A\n\n3. 函数名: use_mm\n- 参数: [io_data->mm]\n- 调用者: ffs_user_copy_worker\n- 被调用者: N/A\n\n4. 函数名: copy_to_iter\n- 参数: [io_data->buf, ret, &io_data->data]\n- 调用者: ffs_user_copy_worker\n- 被调用者: N/A\n\n5. 函数名: iov_iter_count\n- 参数: [&io_data->data]\n- 调用者: ffs_user_copy_worker\n- 被调用者: N/A\n\n6. 函数名: unuse_mm\n- 参数: [io_data->mm]\n- 调用者: ffs_user_copy_worker\n- 被调用者: N/A\n\n7. 函数名: eventfd_signal\n- 参数: [io_data->ffs->ffs_eventfd, 1]\n- 调用者: ffs_user_copy_worker\n- 被调用者: N/A\n\n8. 函数名: usb_ep_free_request\n- 参数: [io_data->ep, io_data->req]\n- 调用者: ffs_user_copy_worker\n- 被调用者: N/A\n\n9. 函数名: kfree\n- 参数: [io_data->to_free], [io_data->buf], [io_data]\n- 调用者: ffs_user_copy_worker\n- 被调用者: N/A"
  },
  {
    "id": 1112,
    "cwe": "CWE-416",
    "cve": "CVE-2016-7913",
    "purpose": "Code purpose:\"\"\"该代码用于配置xc2028调谐器的参数，包括处理固件名称的复制和更新，并请求加载新的固件。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在释放priv->ctrl.fname后未正确检查p->fname是否为NULL，导致可能发生use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: xc2028_set_config\n- 参数: [struct dvb_frontend *fe, void *priv_cfg]\n- 调用者: 未明确显示（由内核其他部分调用）\n- 被调用者: [mutex_lock, kfree, memcpy, kstrdup, free_firmware, strcmp, request_firmware_nowait, mutex_unlock]\n\n2. 函数名: tuner_dbg\n- 参数: [const char *fmt, ...]\n- 调用者: xc2028_set_config\n- 被调用者: []\n\n3. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: xc2028_set_config\n- 被调用者: []\n\n4. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: xc2028_set_config\n- 被调用者: []\n\n5. 函数名: memcpy\n- 参数: [void *to, const void *from, __kernel_size_t n]\n- 调用者: xc2028_set_config\n- 被调用者: []\n\n6. 函数名: kstrdup\n- 参数: [const char *s, gfp_t gfp]\n- 调用者: xc2028_set_config\n- 被调用者: []\n\n7. 函数名: free_firmware\n- 参数: [struct xc2028_data *priv]\n- 调用者: xc2028_set_config\n- 被调用者: []\n\n8. 函数名: strcmp\n- 参数: [const char *cs, const char *ct]\n- 调用者: xc2028_set_config\n- 被调用者: []\n\n9. 函数名: request_firmware_nowait\n- 参数: [struct module *module, int uevent, const char *name, struct device *device, gfp_t gfp, void *context, void (*cont)(const struct firmware *fw, void *context)]\n- 调用者: xc2028_set_config\n- 被调用者: []\n\n10. 函数名: tuner_err\n- 参数: [const char *fmt, ...]\n- 调用者: xc2028_set_config\n- 被调用者: []\n\n11. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: xc2028_set_config\n- 被调用者: []\n\n12. 函数名: load_firmware_cb\n- 参数: [const struct firmware *fw, void *context]\n- 调用者: request_firmware_nowait\n- 被调用者: []"
  },
  {
    "id": 1131,
    "cwe": "CWE-416",
    "cve": "CVE-2016-8655",
    "purpose": "Code purpose:\"\"\"该代码用于设置和管理Linux内核中AF_PACKET套接字的环形缓冲区，处理接收和发送数据包的相关配置和资源分配。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中的packet_set_ring函数存在竞态条件，当本地用户利用CAP_NET_RAW能力更改socket版本时，可能导致use-after-free漏洞，从而引发权限提升或拒绝服务。\"\"\"",
    "functions": "Functions:\n1. 函数名: packet_set_ring\n- 参数: [struct sock *sk, union tpacket_req_u *req_u, int closing, int tx_ring]\n- 调用者: N/A (顶层函数)\n- 被调用者: [pkt_sk, net_warn_ratelimited, atomic_read, packet_read_pending, PAGE_ALIGNED, get_order, alloc_pg_vec, init_prb_bdqc, lock_sock, __unregister_prot_hook, synchronize_net, mutex_lock, spin_lock_bh, spin_unlock_bh, mutex_unlock, register_prot_hook, prb_shutdown_retire_blk_timer, release_sock, free_pg_vec]\n\n2. 函数名: pkt_sk\n- 参数: [struct sock *sk]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n3. 函数名: net_warn_ratelimited\n- 参数: [const char *fmt, ...]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n4. 函数名: atomic_read\n- 参数: [const atomic_t *v]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n5. 函数名: packet_read_pending\n- 参数: [struct packet_ring_buffer *rb]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n6. 函数名: PAGE_ALIGNED\n- 参数: [unsigned long addr]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n7. 函数名: get_order\n- 参数: [unsigned long size]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n8. 函数名: alloc_pg_vec\n- 参数: [struct tpacket_req *req, int order]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n9. 函数名: init_prb_bdqc\n- 参数: [struct packet_sock *po, struct packet_ring_buffer *rb, struct pgv *pg_vec, union tpacket_req_u *req_u]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n10. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n11. 函数名: __unregister_prot_hook\n- 参数: [struct sock *sk, bool sync]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n12. 函数名: synchronize_net\n- 参数: []\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n13. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n14. 函数名: spin_lock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n15. 函数名: spin_unlock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n16. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n17. 函数名: register_prot_hook\n- 参数: [struct sock *sk]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n18. 函数名: prb_shutdown_retire_blk_timer\n- 参数: [struct packet_sock *po, struct sk_buff_head *rb_queue]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n19. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n20. 函数名: free_pg_vec\n- 参数: [struct pgv *pg_vec, int order, int len]\n- 调用者: packet_set_ring\n- 被调用者: N/A"
  },
  {
    "id": 1132,
    "cwe": "CWE-416",
    "cve": "CVE-2016-8655",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中AF_PACKET套接字的选项设置功能，包括成员管理、环形缓冲区配置、版本控制等网络包处理操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中的packet_setsockopt函数存在竞态条件漏洞，允许本地用户通过CAP_NET_RAW能力更改socket版本，导致packet_set_ring和packet_setsockopt函数之间的使用后释放问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: packet_setsockopt\n- 参数: [struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen]\n- 调用者: 未显示（系统调用）\n- 被调用者: [pkt_sk, memset, copy_from_user, packet_mc_add, packet_mc_drop, packet_set_ring, fanout_add, fanout_set_data]\n\n2. 函数名: pkt_sk\n- 参数: [struct sock *sk]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n3. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n4. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n5. 函数名: packet_mc_add\n- 参数: [struct sock *sk, struct packet_mreq_max *mreq]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n6. 函数名: packet_mc_drop\n- 参数: [struct sock *sk, struct packet_mreq_max *mreq]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n7. 函数名: packet_set_ring\n- 参数: [struct sock *sk, union tpacket_req_u *req_u, int flag, int tx_ring]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n8. 函数名: fanout_add\n- 参数: [struct sock *sk, int val1, int val2]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n9. 函数名: fanout_set_data\n- 参数: [struct packet_sock *po, char __user *optval, unsigned int optlen]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示"
  },
  {
    "id": 1139,
    "cwe": "CWE-416",
    "cve": "CVE-2016-9120",
    "purpose": "Code purpose:\"\"\"释放ION内存客户端中的句柄资源并验证其有效性\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在释放ION句柄时存在竞态条件，当两个CPU同时调用ION_IOC_FREE时可能导致use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: ion_free\n- 参数: [struct ion_client *client, struct ion_handle *handle]\n- 调用者: 未明确显示（可能是ION_IOC_FREE的调用者）\n- 被调用者: [ion_handle_validate, ion_handle_put]\n\n2. 函数名: ion_handle_validate\n- 参数: [struct ion_client *client, struct ion_handle *handle]\n- 调用者: ion_free\n- 被调用者: []\n\n3. 函数名: ion_handle_put\n- 参数: [struct ion_handle *handle]\n- 调用者: ion_free\n- 被调用者: []\n\n4. 函数名: mutex_lock\n- 参数: [&client->lock]\n- 调用者: ion_free\n- 被调用者: []\n\n5. 函数名: mutex_unlock\n- 参数: [&client->lock]\n- 调用者: ion_free\n- 被调用者: []"
  },
  {
    "id": 1140,
    "cwe": "CWE-416",
    "cve": "CVE-2016-9120",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中ION内存管理子系统的ioctl接口，用于处理内存分配、释放、共享等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当两个CPU同时调用ION_IOC_FREE时，由于缺乏适当的同步机制，导致ion_handle_get_by_id和ion_free之间存在竞争条件，可能引发use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: ion_ioctl\n- 参数: [struct file *filp, unsigned int cmd, unsigned long arg]\n- 调用者: 无（系统调用接口）\n- 被调用者: [ion_ioctl_dir, _IOC_SIZE, copy_from_user, ion_alloc, PTR_ERR, ion_handle_get_by_id, ion_free, ion_handle_put, ion_share_dma_buf_fd, ion_import_dma_buf_fd, ion_sync_for_device, copy_to_user]\n\n2. 函数名: ion_ioctl_dir\n- 参数: [unsigned int cmd]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n3. 函数名: _IOC_SIZE\n- 参数: [unsigned int cmd]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n4. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n5. 函数名: ion_alloc\n- 参数: [struct ion_client *client, size_t len, size_t align, unsigned int heap_id_mask, unsigned int flags]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n6. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n7. 函数名: ion_handle_get_by_id\n- 参数: [struct ion_client *client, int id]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n8. 函数名: ion_free\n- 参数: [struct ion_client *client, struct ion_handle *handle]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n9. 函数名: ion_handle_put\n- 参数: [struct ion_handle *handle]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n10. 函数名: ion_share_dma_buf_fd\n- 参数: [struct ion_client *client, struct ion_handle *handle]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n11. 函数名: ion_import_dma_buf_fd\n- 参数: [struct ion_client *client, int fd]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n12. 函数名: ion_sync_for_device\n- 参数: [struct ion_client *client, int fd]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n13. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: ion_ioctl\n- 被调用者: 无"
  },
  {
    "id": 1141,
    "cwe": "CWE-416",
    "cve": "CVE-2016-9120",
    "purpose": "Code purpose:\"\"\"该代码用于通过减少引用计数来安全释放ION内存句柄，并在引用计数归零时销毁句柄\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多CPU并发调用ION_IOC_FREE时，ion_handle_put函数中的互斥锁保护不足，导致存在竞争条件可能引发use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: ion_handle_put\n- 参数: [struct ion_handle *handle]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [mutex_lock, kref_put, mutex_unlock]\n\n2. 函数名: mutex_lock\n- 参数: [&client->lock]\n- 调用者: ion_handle_put\n- 被调用者: []\n\n3. 函数名: kref_put\n- 参数: [&handle->ref, ion_handle_destroy]\n- 调用者: ion_handle_put\n- 被调用者: [ion_handle_destroy]\n\n4. 函数名: mutex_unlock\n- 参数: [&client->lock]\n- 调用者: ion_handle_put\n- 被调用者: []\n\n5. 函数名: ion_handle_destroy\n- 参数: 未明确（通过kref_put间接调用）\n- 调用者: kref_put\n- 被调用者: []"
  },
  {
    "id": 1142,
    "cwe": "CWE-416",
    "cve": "CVE-2016-9120",
    "purpose": "Code purpose:\"\"\"通过ID查找并获取ion_handle结构体引用，同时处理并发访问\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多CPU并发调用ION_IOC_FREE时，缺乏对ion_handle_get_by_id函数中handle引用的充分保护，导致可能发生use-after-free情况。\"\"\"",
    "functions": "Functions:\n1. 函数名: ion_handle_get_by_id\n- 参数: [struct ion_client *client, int id]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [mutex_lock, idr_find, ion_handle_get, mutex_unlock, ERR_PTR]\n\n2. 函数名: mutex_lock\n- 参数: [&client->lock]\n- 调用者: ion_handle_get_by_id\n- 被调用者: []\n\n3. 函数名: idr_find\n- 参数: [&client->idr, id]\n- 调用者: ion_handle_get_by_id\n- 被调用者: []\n\n4. 函数名: ion_handle_get\n- 参数: [handle]\n- 调用者: ion_handle_get_by_id\n- 被调用者: []\n\n5. 函数名: mutex_unlock\n- 参数: [&client->lock]\n- 调用者: ion_handle_get_by_id\n- 被调用者: []\n\n6. 函数名: ERR_PTR\n- 参数: [-EINVAL]\n- 调用者: ion_handle_get_by_id\n- 被调用者: []"
  },
  {
    "id": 1146,
    "cwe": "CWE-416",
    "cve": "CVE-2016-9576",
    "purpose": "Code purpose:\"\"\"该代码用于将用户空间的I/O向量请求映射到内核空间的块设备请求，处理数据传输的映射和复制操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中的blk_rq_map_user_iov函数未能正确限制迭代器类型，导致本地用户可通过访问/dev/sg设备读写任意内核内存或引发拒绝服务（释放后重用）。\"\"\"",
    "functions": "Functions:\n1. 函数名: blk_rq_map_user_iov\n- 参数: [q, rq, map_data, iter, gfp_mask]\n- 调用者: N/A\n- 被调用者: [iov_iter_alignment, queue_dma_alignment, queue_virt_boundary, iov_iter_gap_alignment, __blk_rq_map_user_iov, iov_iter_count, bio_flagged, __blk_rq_unmap_user]\n\n2. 函数名: iov_iter_alignment\n- 参数: [iter]\n- 调用者: blk_rq_map_user_iov\n- 被调用者: N/A\n\n3. 函数名: queue_dma_alignment\n- 参数: [q]\n- 调用者: blk_rq_map_user_iov\n- 被调用者: N/A\n\n4. 函数名: queue_virt_boundary\n- 参数: [q]\n- 调用者: blk_rq_map_user_iov\n- 被调用者: N/A\n\n5. 函数名: iov_iter_gap_alignment\n- 参数: [iter]\n- 调用者: blk_rq_map_user_iov\n- 被调用者: N/A\n\n6. 函数名: __blk_rq_map_user_iov\n- 参数: [rq, map_data, i, gfp_mask, copy]\n- 调用者: blk_rq_map_user_iov\n- 被调用者: N/A\n\n7. 函数名: iov_iter_count\n- 参数: [i]\n- 调用者: blk_rq_map_user_iov\n- 被调用者: N/A\n\n8. 函数名: bio_flagged\n- 参数: [bio, BIO_USER_MAPPED]\n- 调用者: blk_rq_map_user_iov\n- 被调用者: N/A\n\n9. 函数名: __blk_rq_unmap_user\n- 参数: [bio]\n- 调用者: blk_rq_map_user_iov\n- 被调用者: N/A"
  },
  {
    "id": 1168,
    "cwe": "CWE-416",
    "cve": "CVE-2016-9794",
    "purpose": "Code purpose:\"\"\"该代码用于处理音频PCM子流周期中断事件，更新硬件指针位置并触发定时器中断，最后通知异步I/O事件\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在snd_pcm_period_elapsed函数中存在竞态条件，当处理SNDRV_PCM_TRIGGER_START命令时可能导致use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_pcm_period_elapsed\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: 未明确（由系统或驱动调用）\n- 被调用者: [PCM_RUNTIME_CHECK, snd_pcm_stream_lock_irqsave, snd_pcm_running, snd_pcm_update_hw_ptr0, snd_timer_interrupt, snd_pcm_stream_unlock_irqrestore, kill_fasync]\n\n2. 函数名: PCM_RUNTIME_CHECK\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n3. 函数名: snd_pcm_stream_lock_irqsave\n- 参数: [struct snd_pcm_substream *substream, unsigned long flags]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n4. 函数名: snd_pcm_running\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n5. 函数名: snd_pcm_update_hw_ptr0\n- 参数: [struct snd_pcm_substream *substream, int in_interrupt]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n6. 函数名: snd_timer_interrupt\n- 参数: [struct snd_timer *timer, int ticks]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n7. 函数名: snd_pcm_stream_unlock_irqrestore\n- 参数: [struct snd_pcm_substream *substream, unsigned long flags]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n8. 函数名: kill_fasync\n- 参数: [struct fasync_struct **fp, int sig, int band]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []"
  },
  {
    "id": 1175,
    "cwe": "CWE-416",
    "cve": "CVE-2017-0861",
    "purpose": "Code purpose:\"\"\"处理ALSA子系统中的PCM设备控制IOCTL命令，包括获取下一个设备、获取PCM信息以及设置首选子设备等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在释放互斥锁后未正确验证或保护指针的使用，导致在snd_pcm_info_user函数中可能访问已释放的内存区域\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_pcm_control_ioctl\n- 参数: [struct snd_card *card, struct snd_ctl_file *control, unsigned int cmd, unsigned long arg]\n- 调用者: 未显示（由系统调用触发）\n- 被调用者: [get_user, mutex_lock, snd_pcm_next, mutex_unlock, put_user, snd_pcm_get, snd_pcm_info_user]\n\n2. 函数名: get_user\n- 参数: [device, (int __user *)arg]\n- 调用者: snd_pcm_control_ioctl\n- 被调用者: 未显示（内核函数）\n\n3. 函数名: mutex_lock\n- 参数: [&register_mutex]\n- 调用者: snd_pcm_control_ioctl\n- 被调用者: 未显示（内核同步原语）\n\n4. 函数名: snd_pcm_next\n- 参数: [card, device]\n- 调用者: snd_pcm_control_ioctl\n- 被调用者: 未显示（内核ALSA子系统函数）\n\n5. 函数名: mutex_unlock\n- 参数: [&register_mutex]\n- 调用者: snd_pcm_control_ioctl\n- 被调用者: 未显示（内核同步原语）\n\n6. 函数名: put_user\n- 参数: [device, (int __user *)arg]\n- 调用者: snd_pcm_control_ioctl\n- 被调用者: 未显示（内核函数）\n\n7. 函数名: snd_pcm_get\n- 参数: [card, device]\n- 调用者: snd_pcm_control_ioctl\n- 被调用者: 未显示（内核ALSA子系统函数）\n\n8. 函数名: snd_pcm_info_user\n- 参数: [substream, info]\n- 调用者: snd_pcm_control_ioctl\n- 被调用者: 未显示（内核ALSA子系统函数）"
  },
  {
    "id": 1242,
    "cwe": "CWE-416",
    "cve": "CVE-2017-10661",
    "purpose": "Code purpose:\"\"\"该代码用于设置timerfd的取消功能，根据时钟类型和标志位决定是否将定时器上下文添加到取消列表或从中移除。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多线程环境下对might_cancel标志和取消列表的操作缺乏适当的同步保护，导致竞争条件可能引发列表损坏或释放后使用漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: timerfd_setup_cancel\n- 参数: [struct timerfd_ctx *ctx, int flags]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [spin_lock, list_add_rcu, spin_unlock, timerfd_remove_cancel]\n\n2. 函数名: spin_lock\n- 参数: [&cancel_lock]\n- 调用者: timerfd_setup_cancel\n- 被调用者: []\n\n3. 函数名: list_add_rcu\n- 参数: [&ctx->clist, &cancel_list]\n- 调用者: timerfd_setup_cancel\n- 被调用者: []\n\n4. 函数名: spin_unlock\n- 参数: [&cancel_lock]\n- 调用者: timerfd_setup_cancel\n- 被调用者: []\n\n5. 函数名: timerfd_remove_cancel\n- 参数: [ctx]\n- 调用者: timerfd_setup_cancel\n- 被调用者: []"
  },
  {
    "id": 1243,
    "cwe": "CWE-416",
    "cve": "CVE-2017-10661",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中的timerfd_create系统调用，用于创建一个定时器文件描述符，允许用户空间程序通过文件描述符接口来接收定时事件通知。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于timerfd_create函数中存在竞态条件，当多个文件描述符操作同时进行时，可能导致队列管理不当，引发列表损坏或释放后重用漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: SYSCALL_DEFINE2(timerfd_create)\n- 参数: [int clockid, int flags]\n- 调用者: 系统调用\n- 被调用者: [kzalloc, init_waitqueue_head, isalarm, alarm_init, hrtimer_init, ktime_mono_to_real, anon_inode_getfd, kfree]\n\n2. 函数名: BUILD_BUG_ON\n- 参数: [condition]\n- 调用者: SYSCALL_DEFINE2(timerfd_create)\n- 被调用者: []\n\n3. 函数名: capable\n- 参数: [CAP_WAKE_ALARM]\n- 调用者: SYSCALL_DEFINE2(timerfd_create)\n- 被调用者: []\n\n4. 函数名: kzalloc\n- 参数: [sizeof(*ctx), GFP_KERNEL]\n- 调用者: SYSCALL_DEFINE2(timerfd_create)\n- 被调用者: []\n\n5. 函数名: init_waitqueue_head\n- 参数: [&ctx->wqh]\n- 调用者: SYSCALL_DEFINE2(timerfd_create)\n- 被调用者: []\n\n6. 函数名: isalarm\n- 参数: [ctx]\n- 调用者: SYSCALL_DEFINE2(timerfd_create)\n- 被调用者: []\n\n7. 函数名: alarm_init\n- 参数: [&ctx->t.alarm, ALARM_REALTIME/ALARM_BOOTTIME, timerfd_alarmproc]\n- 调用者: SYSCALL_DEFINE2(timerfd_create)\n- 被调用者: []\n\n8. 函数名: hrtimer_init\n- 参数: [&ctx->t.tmr, clockid, HRTIMER_MODE_ABS]\n- 调用者: SYSCALL_DEFINE2(timerfd_create)\n- 被调用者: []\n\n9. 函数名: ktime_mono_to_real\n- 参数: [0]\n- 调用者: SYSCALL_DEFINE2(timerfd_create)\n- 被调用者: []\n\n10. 函数名: anon_inode_getfd\n- 参数: [\"[timerfd]\", &timerfd_fops, ctx, O_RDWR | (flags & TFD_SHARED_FCNTL_FLAGS)]\n- 调用者: SYSCALL_DEFINE2(timerfd_create)\n- 被调用者: []\n\n11. 函数名: kfree\n- 参数: [ctx]\n- 调用者: SYSCALL_DEFINE2(timerfd_create)\n- 被调用者: []"
  },
  {
    "id": 1244,
    "cwe": "CWE-416",
    "cve": "CVE-2017-10661",
    "purpose": "Code purpose:\"\"\"该代码用于在取消定时器文件描述符操作时，从取消队列中安全移除上下文对象并防止竞态条件\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于timerfd_remove_cancel函数在多线程环境下对ctx->might_cancel标志和链表操作缺乏原子性保护，导致竞争条件可能引发链表损坏或释放后使用漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: timerfd_remove_cancel\n- 参数: [struct timerfd_ctx *ctx]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [spin_lock, list_del_rcu, spin_unlock]"
  },
  {
    "id": 1249,
    "cwe": "CWE-416",
    "cve": "CVE-2017-11176",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中消息队列的通知机制，允许用户空间程序通过信号、线程或空操作等方式接收队列通知，并处理相关套接字资源。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在重试逻辑中未将sock指针置为NULL，导致用户空间关闭Netlink套接字时可能引发use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: do_mq_notify\n- 参数: [mqd_t mqdes, const struct sigevent *notification]\n- 调用者: 无（内核函数）\n- 被调用者: [audit_mq_notify, valid_signal, alloc_skb, copy_from_user, skb_put, fdget, netlink_getsockbyfilp, fdput, netlink_attachskb, file_inode, current_time, remove_notification, get_pid, get_user_ns, spin_lock, spin_unlock, netlink_detachskb, dev_kfree_skb]\n\n2. 函数名: audit_mq_notify\n- 参数: [mqd_t mqdes, const struct sigevent *notification]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n3. 函数名: valid_signal\n- 参数: [int sig]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n4. 函数名: alloc_skb\n- 参数: [unsigned int size, gfp_t priority]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n5. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n6. 函数名: skb_put\n- 参数: [struct sk_buff *skb, unsigned int len]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n7. 函数名: fdget\n- 参数: [int fd]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n8. 函数名: netlink_getsockbyfilp\n- 参数: [struct file *filp]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n9. 函数名: fdput\n- 参数: [struct fd fd]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n10. 函数名: netlink_attachskb\n- 参数: [struct sock *sk, struct sk_buff *skb, long *timeo, struct sock *ssk]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n11. 函数名: file_inode\n- 参数: [const struct file *file]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n12. 函数名: current_time\n- 参数: [struct inode *inode]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n13. 函数名: remove_notification\n- 参数: [struct mqueue_inode_info *info]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n14. 函数名: get_pid\n- 参数: [struct pid *pid]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n15. 函数名: get_user_ns\n- 参数: [struct user_namespace *ns]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n16. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n17. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n18. 函数名: netlink_detachskb\n- 参数: [struct sock *sk, struct sk_buff *skb]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n19. 函数名: dev_kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: do_mq_notify\n- 被调用者: []"
  },
  {
    "id": 1289,
    "cwe": "CWE-416",
    "cve": "CVE-2017-15115",
    "purpose": "Code purpose:\"\"\"该代码用于在SCTP协议中实现将一个关联(association)从原始socket分离(peel-off)到新socket的功能\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"sctp_do_peeloff函数在执行peel-off操作时未验证目标网络命名空间(netns)是否匹配，导致可能发生跨命名空间的资源访问\"\"\"",
    "functions": "Functions:\n1. 函数名: sctp_do_peeloff\n- 参数: [struct sock *sk, sctp_assoc_t id, struct socket **sockp]\n- 调用者: 未显示\n- 被调用者: [sctp_id2assoc, sctp_sk, sock_create, sctp_copy_sock, sp->pf->to_sk_daddr, sctp_sock_migrate]\n\n2. 函数名: sctp_id2assoc\n- 参数: [struct sock *sk, sctp_assoc_t id]\n- 调用者: sctp_do_peeloff\n- 被调用者: 未显示\n\n3. 函数名: sctp_sk\n- 参数: [struct sock *sk]\n- 调用者: sctp_do_peeloff\n- 被调用者: 未显示\n\n4. 函数名: sock_create\n- 参数: [sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock]\n- 调用者: sctp_do_peeloff\n- 被调用者: 未显示\n\n5. 函数名: sctp_copy_sock\n- 参数: [sock->sk, sk, asoc]\n- 调用者: sctp_do_peeloff\n- 被调用者: 未显示\n\n6. 函数名: to_sk_daddr\n- 参数: [&asoc->peer.primary_addr, sk]\n- 调用者: sctp_do_peeloff (通过sp->pf->to_sk_daddr)\n- 被调用者: 未显示\n\n7. 函数名: sctp_sock_migrate\n- 参数: [sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH]\n- 调用者: sctp_do_peeloff\n- 被调用者: 未显示"
  },
  {
    "id": 1300,
    "cwe": "CWE-416",
    "cve": "CVE-2017-15265",
    "purpose": "Code purpose:\"\"\"该代码用于处理ALSA子系统中的序列端口创建请求，包括权限检查、端口创建、回调函数设置以及端口信息更新等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在ALSA子系统中存在竞态条件，当处理/dev/snd/seq的ioctl调用时，可能导致使用后释放(UAF)漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_seq_ioctl_create_port\n- 参数: [struct snd_seq_client *client, void *arg]\n- 调用者: 未指定（由ioctl调用触发）\n- 被调用者: [snd_seq_create_port, snd_seq_delete_port, snd_seq_set_port_info, snd_seq_system_client_ev_port_start]\n\n2. 函数名: snd_seq_create_port\n- 参数: [struct snd_seq_client *client, int port]\n- 调用者: snd_seq_ioctl_create_port\n- 被调用者: 未指定\n\n3. 函数名: snd_seq_delete_port\n- 参数: [struct snd_seq_client *client, int port]\n- 调用者: snd_seq_ioctl_create_port\n- 被调用者: 未指定\n\n4. 函数名: snd_seq_set_port_info\n- 参数: [struct snd_seq_client_port *port, struct snd_seq_port_info *info]\n- 调用者: snd_seq_ioctl_create_port\n- 被调用者: 未指定\n\n5. 函数名: snd_seq_system_client_ev_port_start\n- 参数: [int client, int port]\n- 调用者: snd_seq_ioctl_create_port\n- 被调用者: 未指定"
  },
  {
    "id": 1301,
    "cwe": "CWE-416",
    "cve": "CVE-2017-15265",
    "purpose": "Code purpose:\"\"\"创建一个新的ALSA序列端口并初始化其数据结构，同时管理客户端端口列表\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在ALSA子系统中存在竞态条件，当处理/dev/snd/seq的ioctl调用时，由于对端口资源的创建和管理缺乏适当的同步保护，可能导致use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_seq_create_port\n- 参数: [struct snd_seq_client *client, int port]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [snd_BUG_ON, pr_warn, kzalloc, sprintf, snd_use_lock_init, port_subs_info_init, mutex_lock, write_lock_irqsave, list_for_each_entry, list_add_tail, write_unlock_irqrestore, mutex_unlock]\n\n2. 函数名: snd_BUG_ON\n- 参数: [!client]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n3. 函数名: pr_warn\n- 参数: [\"ALSA: seq: too many ports for client %d\\n\", client->number]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n4. 函数名: kzalloc\n- 参数: [sizeof(*new_port), GFP_KERNEL]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n5. 函数名: sprintf\n- 参数: [new_port->name, \"port-%d\", num]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n6. 函数名: snd_use_lock_init\n- 参数: [&new_port->use_lock]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n7. 函数名: port_subs_info_init\n- 参数: [&new_port->c_src]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n8. 函数名: port_subs_info_init\n- 参数: [&new_port->c_dest]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n9. 函数名: mutex_lock\n- 参数: [&client->ports_mutex]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n10. 函数名: write_lock_irqsave\n- 参数: [&client->ports_lock, flags]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n11. 函数名: list_for_each_entry\n- 参数: [p, &client->ports_list_head, list]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n12. 函数名: list_add_tail\n- 参数: [&new_port->list, &p->list]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n13. 函数名: write_unlock_irqrestore\n- 参数: [&client->ports_lock, flags]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n14. 函数名: mutex_unlock\n- 参数: [&client->ports_mutex]\n- 调用者: snd_seq_create_port\n- 被调用者: []"
  },
  {
    "id": 1309,
    "cwe": "CWE-416",
    "cve": "CVE-2017-16525",
    "purpose": "Code purpose:\"\"\"该代码用于设置USB串行控制台，包括配置波特率、数据位、校验位等参数，并处理USB设备的连接和初始化。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在USB控制台设置过程中，当设备断开连接或设置失败时，未能正确处理tty结构体的引用计数和内存释放，导致use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: usb_console_setup\n- 参数: [struct console *co, char *options]\n- 调用者: 未明确显示（通常由console子系统调用）\n- 被调用者: [simple_strtoul, usb_serial_port_get_by_minor, usb_autopm_get_interface, tty_port_tty_set, kzalloc, kref_init, init_ldsem, spin_lock_init, INIT_LIST_HEAD, kref_get, __module_get, tty_init_termios, tty_termios_encode_baud_rate, memset, tty_kref_put, tty_port_set_initialized, usb_autopm_put_interface, usb_serial_put, mutex_unlock]\n\n2. 函数名: simple_strtoul\n- 参数: [const char *nptr, char **endptr, int base]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n3. 函数名: usb_serial_port_get_by_minor\n- 参数: [int minor]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n4. 函数名: usb_autopm_get_interface\n- 参数: [struct usb_interface *intf]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n5. 函数名: tty_port_tty_set\n- 参数: [struct tty_port *port, struct tty_struct *tty]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n6. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n7. 函数名: kref_init\n- 参数: [struct kref *kref]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n8. 函数名: init_ldsem\n- 参数: [struct ld_semaphore *sem]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n9. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n10. 函数名: INIT_LIST_HEAD\n- 参数: [struct list_head *list]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n11. 函数名: kref_get\n- 参数: [struct kref *kref]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n12. 函数名: __module_get\n- 参数: [struct module *module]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n13. 函数名: tty_init_termios\n- 参数: [struct tty_struct *tty]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n14. 函数名: tty_termios_encode_baud_rate\n- 参数: [struct ktermios *termios, speed_t ibaud, speed_t obaud]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n15. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n16. 函数名: tty_kref_put\n- 参数: [struct tty_struct *tty]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n17. 函数名: tty_port_set_initialized\n- 参数: [struct tty_port *port, bool val]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n18. 函数名: usb_autopm_put_interface\n- 参数: [struct usb_interface *intf]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n19. 函数名: usb_serial_put\n- 参数: [struct usb_serial *serial]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n20. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: usb_console_setup\n- 被调用者: []"
  },
  {
    "id": 1312,
    "cwe": "CWE-416",
    "cve": "CVE-2017-16527",
    "purpose": "Code purpose:\"\"\"释放USB音频混音器接口相关的内存资源，包括元素ID、URB传输缓冲区和设置包等。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在释放mixer资源时未正确处理urb和rc_urb的释放顺序，导致可能发生use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_usb_mixer_free\n- 参数: [struct usb_mixer_interface *mixer]\n- 调用者: 未明确（由系统调用）\n- 被调用者: [kfree, usb_free_urb]\n\n2. 函数名: kfree\n- 参数: [void *ptr]\n- 调用者: snd_usb_mixer_free\n- 被调用者: []\n\n3. 函数名: usb_free_urb\n- 参数: [struct urb *urb]\n- 调用者: snd_usb_mixer_free\n- 被调用者: []"
  },
  {
    "id": 1313,
    "cwe": "CWE-416",
    "cve": "CVE-2017-16527",
    "purpose": "Code purpose:\"\"\"在USB音频设备断开连接时终止相关的URB(USB请求块)传输\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在snd_usb_mixer_disconnect函数中，由于没有正确处理mixer对象的生命周期，导致在usb_kill_urb调用后可能出现use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_usb_mixer_disconnect\n- 参数: [struct usb_mixer_interface *mixer]\n- 调用者: 未明确（由系统调用）\n- 被调用者: [usb_kill_urb, usb_kill_urb]\n\n2. 函数名: usb_kill_urb\n- 参数: [struct urb *urb] (通过mixer->urb和mixer->rc_urb传递)\n- 调用者: snd_usb_mixer_disconnect\n- 被调用者: []"
  },
  {
    "id": 1314,
    "cwe": "CWE-416",
    "cve": "CVE-2017-16528",
    "purpose": "Code purpose:\"\"\"释放序列设备资源并减少设备引用计数\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在释放设备资源时未正确处理引用计数，导致后续可能发生use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: snd_seq_device_dev_free\n- 参数: [struct snd_device *device]\n- 调用者: 未明确（由Linux内核设备子系统调用）\n- 被调用者: [put_device]"
  },
  {
    "id": 1342,
    "cwe": "CWE-416",
    "cve": "CVE-2017-16648",
    "purpose": "Code purpose:\"\"\"释放DVB前端设备相关资源并处理前端私有数据的清理工作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在释放fepriv内存后仍可能被访问，导致use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: __dvb_frontend_free\n- 参数: [struct dvb_frontend *fe]\n- 调用者: 未明确（可能是外部调用）\n- 被调用者: [dvb_free_device, dvb_frontend_invoke_release, kfree]\n\n2. 函数名: dvb_free_device\n- 参数: [fepriv->dvbdev]\n- 调用者: __dvb_frontend_free\n- 被调用者: 未明确\n\n3. 函数名: dvb_frontend_invoke_release\n- 参数: [fe, fe->ops.release]\n- 调用者: __dvb_frontend_free\n- 被调用者: 未明确\n\n4. 函数名: kfree\n- 参数: [fepriv]\n- 调用者: __dvb_frontend_free\n- 被调用者: 未明确"
  },
  {
    "id": 1352,
    "cwe": "CWE-416",
    "cve": "CVE-2017-16939",
    "purpose": "Code purpose:\"\"\"该代码片段实现了XFRM策略转储完成时的清理操作，包括结束策略遍历并释放相关网络资源。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在XFRM策略转储实现中存在对已释放内存的后续使用（use-after-free），本地用户可通过特制的SO_RCVBUF setsockopt系统调用结合XFRM_MSG_GETPOLICY Netlink消息利用此漏洞获取权限或导致拒绝服务。\"\"\"",
    "functions": "Functions:\n1. 函数名: xfrm_dump_policy_done\n- 参数: [struct netlink_callback *cb]\n- 调用者: 未明确（由内核网络子系统调用）\n- 被调用者: [sock_net, xfrm_policy_walk_done]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: xfrm_dump_policy_done\n- 被调用者: []\n\n3. 函数名: xfrm_policy_walk_done\n- 参数: [struct xfrm_policy_walk *walk, struct net *net]\n- 调用者: xfrm_dump_policy_done\n- 被调用者: []"
  },
  {
    "id": 1353,
    "cwe": "CWE-416",
    "cve": "CVE-2017-16939",
    "purpose": "Code purpose:\"\"\"该代码实现了XFRM策略的转储功能，通过Netlink回调机制将网络策略信息从内核空间传输到用户空间\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在XFRM策略转储实现中存在use-after-free漏洞，攻击者可通过特制的SO_RCVBUF setsockopt系统调用结合XFRM_MSG_GETPOLICY Netlink消息利用该漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: xfrm_dump_policy\n- 参数: [skb, cb]\n- 调用者: 未明确（由内核网络子系统调用）\n- 被调用者: [sock_net, xfrm_policy_walk_init, xfrm_policy_walk]\n\n2. 函数名: sock_net\n- 参数: [skb->sk]\n- 调用者: xfrm_dump_policy\n- 被调用者: []\n\n3. 函数名: xfrm_policy_walk_init\n- 参数: [walk, XFRM_POLICY_TYPE_ANY]\n- 调用者: xfrm_dump_policy\n- 被调用者: []\n\n4. 函数名: xfrm_policy_walk\n- 参数: [net, walk, dump_one_policy, &info]\n- 调用者: xfrm_dump_policy\n- 被调用者: [dump_one_policy]\n\n5. 函数名: dump_one_policy\n- 参数: [未明确，通过函数指针传递]\n- 调用者: xfrm_policy_walk\n- 被调用者: []"
  },
  {
    "id": 1354,
    "cwe": "CWE-416",
    "cve": "CVE-2017-16939",
    "purpose": "Code purpose:\"\"\"处理XFRM(IPsec)相关的用户空间消息，包括权限检查、消息解析和执行相应操作\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在XFRM策略转储实现中存在use-after-free漏洞，攻击者可通过精心构造的SO_RCVBUF setsockopt系统调用结合XFRM_MSG_GETPOLICY Netlink消息触发。\"\"\"",
    "functions": "Functions:\n1. 函数名: xfrm_user_rcv_msg\n- 参数: [struct sk_buff *skb, struct nlmsghdr *nlh, struct netlink_ext_ack *extack]\n- 调用者: 未显示（由内核网络子系统调用）\n- 被调用者: [sock_net, nlmsg_parse, netlink_net_capable, netlink_dump_start, link->dump, link->done, link->doit]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: xfrm_user_rcv_msg\n- 被调用者: 未显示\n\n3. 函数名: nlmsg_parse\n- 参数: [struct nlmsghdr *nlh, int hdrlen, struct nlattr *tb[], int maxtype, const struct nla_policy *policy, struct netlink_ext_ack *extack]\n- 调用者: xfrm_user_rcv_msg\n- 被调用者: 未显示\n\n4. 函数名: netlink_net_capable\n- 参数: [struct sk_buff *skb, int cap]\n- 调用者: xfrm_user_rcv_msg\n- 被调用者: 未显示\n\n5. 函数名: netlink_dump_start\n- 参数: [struct sock *ssk, struct sk_buff *skb, struct nlmsghdr *nlh, struct netlink_dump_control *control]\n- 调用者: xfrm_user_rcv_msg\n- 被调用者: 未显示\n\n6. 函数名: link->dump\n- 参数: 未显示（函数指针）\n- 调用者: xfrm_user_rcv_msg\n- 被调用者: 未显示\n\n7. 函数名: link->done\n- 参数: 未显示（函数指针）\n- 调用者: xfrm_user_rcv_msg\n- 被调用者: 未显示\n\n8. 函数名: link->doit\n- 参数: [struct sk_buff *skb, struct nlmsghdr *nlh, struct nlattr **attrs]\n- 调用者: xfrm_user_rcv_msg\n- 被调用者: 未显示"
  },
  {
    "id": 1357,
    "cwe": "CWE-416",
    "cve": "CVE-2017-17052",
    "purpose": "Code purpose:\"\"\"初始化新进程的内存管理结构体(mm_struct)，设置其初始状态和相关参数\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"mm_init函数在初始化新进程的mm_struct时未清除->exe_file成员，导致可能发生use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: mm_init\n- 参数: [mm, p, user_ns]\n- 调用者: 未明确（通常是进程创建相关函数）\n- 被调用者: [atomic_set, init_rwsem, INIT_LIST_HEAD, atomic_long_set, mm_nr_pmds_init, memset, spin_lock_init, mm_init_cpumask, mm_init_aio, mm_init_owner, mmu_notifier_mm_init, init_tlb_flush_pending, mm_alloc_pgd, init_new_context, get_user_ns, mm_free_pgd, free_mm]\n\n2. 函数名: atomic_set\n- 参数: [&mm->mm_users, 1]\n- 调用者: mm_init\n- 被调用者: []\n\n3. 函数名: init_rwsem\n- 参数: [&mm->mmap_sem]\n- 调用者: mm_init\n- 被调用者: []\n\n4. 函数名: INIT_LIST_HEAD\n- 参数: [&mm->mmlist]\n- 调用者: mm_init\n- 被调用者: []\n\n5. 函数名: atomic_long_set\n- 参数: [&mm->nr_ptes, 0]\n- 调用者: mm_init\n- 被调用者: []\n\n6. 函数名: mm_nr_pmds_init\n- 参数: [mm]\n- 调用者: mm_init\n- 被调用者: []\n\n7. 函数名: memset\n- 参数: [&mm->rss_stat, 0, sizeof(mm->rss_stat)]\n- 调用者: mm_init\n- 被调用者: []\n\n8. 函数名: spin_lock_init\n- 参数: [&mm->page_table_lock]\n- 调用者: mm_init\n- 被调用者: []\n\n9. 函数名: mm_init_cpumask\n- 参数: [mm]\n- 调用者: mm_init\n- 被调用者: []\n\n10. 函数名: mm_init_aio\n- 参数: [mm]\n- 调用者: mm_init\n- 被调用者: []\n\n11. 函数名: mm_init_owner\n- 参数: [mm, p]\n- 调用者: mm_init\n- 被调用者: []\n\n12. 函数名: mmu_notifier_mm_init\n- 参数: [mm]\n- 调用者: mm_init\n- 被调用者: []\n\n13. 函数名: init_tlb_flush_pending\n- 参数: [mm]\n- 调用者: mm_init\n- 被调用者: []\n\n14. 函数名: mm_alloc_pgd\n- 参数: [mm]\n- 调用者: mm_init\n- 被调用者: []\n\n15. 函数名: init_new_context\n- 参数: [p, mm]\n- 调用者: mm_init\n- 被调用者: []\n\n16. 函数名: get_user_ns\n- 参数: [user_ns]\n- 调用者: mm_init\n- 被调用者: []\n\n17. 函数名: mm_free_pgd\n- 参数: [mm]\n- 调用者: mm_init\n- 被调用者: []\n\n18. 函数名: free_mm\n- 参数: [mm]\n- 调用者: mm_init\n- 被调用者: []"
  },
  {
    "id": 1358,
    "cwe": "CWE-416",
    "cve": "CVE-2017-17053",
    "purpose": "Code purpose:\"\"\"初始化新进程的内存管理上下文，包括内存保护密钥和LDT表的设置\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在创建新进程时，init_new_context函数未能正确处理LDT表分配失败的情况，导致可能发生use-after-free或其他未定义影响\"\"\"",
    "functions": "Functions:\n1. 函数名: init_new_context\n- 参数: [struct task_struct *tsk, struct mm_struct *mm]\n- 调用者: 未明确显示（通常由进程创建相关函数调用）\n- 被调用者: [init_new_context_ldt]\n\n2. 函数名: init_new_context_ldt\n- 参数: [struct task_struct *tsk, struct mm_struct *mm]\n- 调用者: init_new_context\n- 被调用者: []"
  },
  {
    "id": 1386,
    "cwe": "CWE-416",
    "cve": "CVE-2017-17975",
    "purpose": "Code purpose:\"\"\"该代码用于探测并初始化USB视频采集设备(USBTV007)，包括视频和音频功能的初始化，并在失败时进行资源清理。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在音频注册失败时，代码会先释放usbtv数据结构，然后在usbtv_video_fail标签处再次尝试访问和释放已释放的内存，导致use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: usbtv_probe\n- 参数: [struct usb_interface *intf, const struct usb_device_id *id]\n- 调用者: 内核USB子系统\n- 被调用者: [usb_endpoint_maxp, usb_endpoint_maxp_mult, kzalloc, usb_get_dev, interface_to_usbdev, usb_set_intfdata, usbtv_video_init, usbtv_audio_init, v4l2_device_get, dev_info, usbtv_video_free, usb_put_dev, kfree]\n\n2. 函数名: usb_endpoint_maxp\n- 参数: [&ep->desc]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n3. 函数名: usb_endpoint_maxp_mult\n- 参数: [&ep->desc]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n4. 函数名: kzalloc\n- 参数: [sizeof(struct usbtv), GFP_KERNEL]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n5. 函数名: usb_get_dev\n- 参数: [interface_to_usbdev(intf)]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n6. 函数名: interface_to_usbdev\n- 参数: [intf]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n7. 函数名: usb_set_intfdata\n- 参数: [intf, usbtv]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n8. 函数名: usbtv_video_init\n- 参数: [usbtv]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n9. 函数名: usbtv_audio_init\n- 参数: [usbtv]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n10. 函数名: v4l2_device_get\n- 参数: [&usbtv->v4l2_dev]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n11. 函数名: dev_info\n- 参数: [dev, \"Fushicai USBTV007 Audio-Video Grabber\\n\"]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n12. 函数名: usbtv_video_free\n- 参数: [usbtv]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n13. 函数名: usb_put_dev\n- 参数: [usbtv->udev]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n14. 函数名: kfree\n- 参数: [usbtv]\n- 调用者: usbtv_probe\n- 被调用者: []"
  },
  {
    "id": 1387,
    "cwe": "CWE-416",
    "cve": "CVE-2017-18017",
    "purpose": "Code purpose:\"\"\"该代码用于修改TCP数据包中的MSS(最大分段大小)选项，以适配路径MTU或强制设置特定MSS值，防止TCP分段问题。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在处理TCP MSS选项时，由于在扩展skb缓冲区后未正确更新TCP头部指针，导致潜在的use-after-free和内存损坏问题\"\"\"",
    "functions": "Functions:\n1. 函数名: tcpmss_mangle_packet\n- 参数: [skb, par, family, tcphoff, minlen]\n- 调用者: 未明确显示（由iptables/netfilter框架调用）\n- 被调用者: [skb_make_writable, tcpmss_reverse_mtu, dst_mtu, net_err_ratelimited, optlen, inet_proto_csum_replace2, htons, skb_tailroom, pskb_expand_head, skb_put, xt_family, memmove, inet_proto_csum_replace4]\n\n2. 函数名: skb_make_writable\n- 参数: [skb, len]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n3. 函数名: tcpmss_reverse_mtu\n- 参数: [net, skb, family]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n4. 函数名: dst_mtu\n- 参数: [skb_dst(skb)]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n5. 函数名: net_err_ratelimited\n- 参数: [format string, min_mtu]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n6. 函数名: optlen\n- 参数: [opt, i]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n7. 函数名: inet_proto_csum_replace2\n- 参数: [&tcph->check, skb, htons(oldmss), htons(newmss), false]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n8. 函数名: htons\n- 参数: [value]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n9. 函数名: skb_tailroom\n- 参数: [skb]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n10. 函数名: pskb_expand_head\n- 参数: [skb, 0, TCPOLEN_MSS - skb_tailroom(skb), GFP_ATOMIC]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n11. 函数名: skb_put\n- 参数: [skb, TCPOLEN_MSS]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n12. 函数名: xt_family\n- 参数: [par]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n13. 函数名: memmove\n- 参数: [opt + TCPOLEN_MSS, opt, len - sizeof(struct tcphdr)]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n14. 函数名: inet_proto_csum_replace4\n- 参数: [&tcph->check, skb, 0, *((__be32 *)opt), false]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []"
  },
  {
    "id": 1397,
    "cwe": "CWE-416",
    "cve": "CVE-2017-18202",
    "purpose": "Code purpose:\"\"\"该代码用于在内存不足(OOM)情况下回收已终止进程的内存资源，通过解除内存映射来释放匿名页面和共享内存页面。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核的__oom_reap_task_mm函数中，由于未正确处理TLB收集操作，导致在特定时间窗口内触发copy_to_user调用时可能出现TLB条目泄漏或释放后重用问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: __oom_reap_task_mm\n- 参数: [struct task_struct *tsk, struct mm_struct *mm]\n- 调用者: 未明确显示（应为oom killer相关调用）\n- 被调用者: [down_read_trylock, trace_skip_task_reaping, up_read, schedule_timeout_idle, test_bit, trace_start_task_reaping, set_bit, tlb_gather_mmu, can_madv_dontneed_vma, vma_is_anonymous, unmap_page_range, tlb_finish_mmu, get_mm_counter, task_pid_nr, trace_finish_task_reaping, mutex_unlock]\n\n2. 函数名: down_read_trylock\n- 参数: [struct rw_semaphore *sem]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n3. 函数名: trace_skip_task_reaping\n- 参数: [pid_t pid]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n4. 函数名: up_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n5. 函数名: schedule_timeout_idle\n- 参数: [long timeout]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n6. 函数名: test_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n7. 函数名: trace_start_task_reaping\n- 参数: [pid_t pid]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n8. 函数名: set_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n9. 函数名: tlb_gather_mmu\n- 参数: [struct mmu_gather *tlb, struct mm_struct *mm, unsigned long start, unsigned long end]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n10. 函数名: can_madv_dontneed_vma\n- 参数: [struct vm_area_struct *vma]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n11. 函数名: vma_is_anonymous\n- 参数: [struct vm_area_struct *vma]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n12. 函数名: unmap_page_range\n- 参数: [struct mmu_gather *tlb, struct vm_area_struct *vma, unsigned long addr, unsigned long end, struct zap_details *details]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n13. 函数名: tlb_finish_mmu\n- 参数: [struct mmu_gather *tlb, unsigned long start, unsigned long end]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n14. 函数名: get_mm_counter\n- 参数: [struct mm_struct *mm, int member]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n15. 函数名: task_pid_nr\n- 参数: [struct task_struct *tsk]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n16. 函数名: trace_finish_task_reaping\n- 参数: [pid_t pid]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n17. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []"
  },
  {
    "id": 1404,
    "cwe": "CWE-416",
    "cve": "CVE-2017-18218",
    "purpose": "Code purpose:\"\"\"该代码实现了网络设备的数据包发送功能，包括数据包的分段处理、DMA映射、描述符填充以及错误处理等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于hns_nic_net_xmit_hw函数在处理skb缓冲区时存在释放后使用(use-after-free)的问题，导致本地用户可能通过利用hns_nic_net_xmit_hw和hns_nic_net_xmit之间skb处理的差异引发拒绝服务或其他影响\"\"\"",
    "functions": "Functions:\n1. 函数名: hns_nic_net_xmit_hw\n- 参数: [ndev, skb, ring_data]\n- 调用者: 未显示\n- 被调用者: [netdev_priv, ring_to_dev, skb_shinfo, dma_map_single, dma_mapping_error, priv->ops.fill_desc, skb_frag_size, skb_frag_dma_map, skb_frag_page, netdev_get_tx_queue, netdev_tx_sent_queue, hnae_queue_xmit, unfill_desc, dma_unmap_page, dma_unmap_single, dev_kfree_skb_any, netif_stop_subqueue]\n\n2. 函数名: netdev_priv\n- 参数: [ndev]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n3. 函数名: ring_to_dev\n- 参数: [ring]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n4. 函数名: skb_shinfo\n- 参数: [skb]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n5. 函数名: dma_map_single\n- 参数: [dev, skb->data, size, DMA_TO_DEVICE]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n6. 函数名: dma_mapping_error\n- 参数: [dev, dma]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n7. 函数名: skb_frag_size\n- 参数: [frag]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n8. 函数名: skb_frag_dma_map\n- 参数: [dev, frag, 0, size, DMA_TO_DEVICE]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n9. 函数名: skb_frag_page\n- 参数: [frag]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n10. 函数名: netdev_get_tx_queue\n- 参数: [ndev, skb->queue_mapping]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n11. 函数名: netdev_tx_sent_queue\n- 参数: [dev_queue, skb->len]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n12. 函数名: hnae_queue_xmit\n- 参数: [priv->ae_handle->qs[skb->queue_mapping], buf_num]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n13. 函数名: unfill_desc\n- 参数: [ring]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n14. 函数名: dma_unmap_page\n- 参数: [dev, ring->desc_cb[ring->next_to_use].dma, ring->desc_cb[ring->next_to_use].length, DMA_TO_DEVICE]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n15. 函数名: dma_unmap_single\n- 参数: [dev, ring->desc_cb[next_to_use].dma, ring->desc_cb[next_to_use].length, DMA_TO_DEVICE]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n16. 函数名: dev_kfree_skb_any\n- 参数: [skb]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n17. 函数名: netif_stop_subqueue\n- 参数: [ndev, skb->queue_mapping]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []"
  },
  {
    "id": 1405,
    "cwe": "CWE-416",
    "cve": "CVE-2017-18218",
    "purpose": "Code purpose:\"\"\"该代码片段实现了网络设备的数据包发送功能，包括队列映射验证、硬件发送操作和发送统计更新。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于hns_nic_net_xmit_hw和hns_nic_net_xmit对skb的处理存在差异，导致可能发生释放后使用(use-after-free)的情况\"\"\"",
    "functions": "Functions:\n1. 函数名: hns_nic_net_xmit\n- 参数: [struct sk_buff *skb, struct net_device *ndev]\n- 调用者: 未显示（通常由网络子系统调用）\n- 被调用者: [netdev_priv, assert, hns_nic_net_xmit_hw, netif_trans_update, tx_ring_data]\n\n2. 函数名: netdev_priv\n- 参数: [struct net_device *ndev]\n- 调用者: hns_nic_net_xmit\n- 被调用者: 未显示\n\n3. 函数名: assert\n- 参数: [skb->queue_mapping < ndev->ae_handle->q_num]\n- 调用者: hns_nic_net_xmit\n- 被调用者: 未显示\n\n4. 函数名: hns_nic_net_xmit_hw\n- 参数: [struct net_device *ndev, struct sk_buff *skb, &tx_ring_data(priv, skb->queue_mapping)]\n- 调用者: hns_nic_net_xmit\n- 被调用者: 未显示\n\n5. 函数名: netif_trans_update\n- 参数: [struct net_device *ndev]\n- 调用者: hns_nic_net_xmit\n- 被调用者: 未显示\n\n6. 函数名: tx_ring_data\n- 参数: [priv, skb->queue_mapping]\n- 调用者: hns_nic_net_xmit\n- 被调用者: 未显示"
  },
  {
    "id": 1444,
    "cwe": "CWE-416",
    "cve": "CVE-2017-2584",
    "purpose": "Code purpose:\"\"\"该代码用于在x86模拟环境中执行fxrstor指令，包括检查FXSR支持、读取浮点状态、验证mxcsr寄存器值，并最终恢复浮点状态\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在em_fxrstor函数中，由于对fx_state结构体的使用缺乏充分的边界检查和验证，导致可能发生使用后释放或内核信息泄露的安全问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: em_fxrstor\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: 未明确（由指令模拟器调用）\n- 被调用者: [check_fxsr, segmented_read, emulate_gp, fxrstor_fixup, asm_safe]\n\n2. 函数名: check_fxsr\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: em_fxrstor\n- 被调用者: []\n\n3. 函数名: segmented_read\n- 参数: [struct x86_emulate_ctxt *ctxt, ctxt->memop.addr.mem, &fx_state, 512]\n- 调用者: em_fxrstor\n- 被调用者: []\n\n4. 函数名: emulate_gp\n- 参数: [struct x86_emulate_ctxt *ctxt, 0]\n- 调用者: em_fxrstor\n- 被调用者: []\n\n5. 函数名: fxrstor_fixup\n- 参数: [struct x86_emulate_ctxt *ctxt, &fx_state]\n- 调用者: em_fxrstor\n- 被调用者: []\n\n6. 函数名: asm_safe\n- 参数: [\"fxrstor %[fx]\", : [fx] \"m\"(fx_state)]\n- 调用者: em_fxrstor\n- 被调用者: []\n\n7. 函数名: ctxt->ops->get_fpu\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: em_fxrstor\n- 被调用者: []\n\n8. 函数名: ctxt->ops->put_fpu\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: em_fxrstor\n- 被调用者: []"
  },
  {
    "id": 1445,
    "cwe": "CWE-416",
    "cve": "CVE-2017-2584",
    "purpose": "Code purpose:\"\"\"模拟存储描述符指针操作，包括根据模式设置操作字节数并执行分段写入\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在指令模拟过程中未正确处理内存释放后的访问，导致存在释放后使用漏洞，可能泄露内核敏感信息或引发拒绝服务。\"\"\"",
    "functions": "Functions:\n1. 函数名: emulate_store_desc_ptr\n- 参数: [struct x86_emulate_ctxt *ctxt, void (*get)(struct x86_emulate_ctxt *ctxt, struct desc_ptr *ptr)]\n- 调用者: 未明确显示（由指令模拟相关功能调用）\n- 被调用者: [get, segmented_write]\n\n2. 函数名: get\n- 参数: [struct x86_emulate_ctxt *ctxt, struct desc_ptr *ptr]\n- 调用者: emulate_store_desc_ptr\n- 被调用者: 未明确显示（函数指针，具体实现未在代码片段中给出）\n\n3. 函数名: segmented_write\n- 参数: [struct x86_emulate_ctxt *ctxt, ctxt->dst.addr.mem, &desc_ptr, 2 + ctxt->op_bytes]\n- 调用者: emulate_store_desc_ptr\n- 被调用者: 未明确显示（未在代码片段中给出）"
  },
  {
    "id": 1446,
    "cwe": "CWE-416",
    "cve": "CVE-2017-2584",
    "purpose": "Code purpose:\"\"\"该代码用于在KVM虚拟化环境中模拟执行fxsave指令，保存FPU状态到指定内存位置\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在em_fxsave函数中，由于未正确验证用户提供的输入并处理fx_state结构体，导致内核内存信息泄露或使用后释放漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: em_fxsave\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [check_fxsr, asm_safe, segmented_write, ctxt->ops->get_fpu, ctxt->ops->put_fpu, ctxt->ops->get_cr]\n\n2. 函数名: check_fxsr\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: em_fxsave\n- 被调用者: 未明确\n\n3. 函数名: asm_safe\n- 参数: [\"fxsave %[fx]\", , [fx] \"+m\"(fx_state)]\n- 调用者: em_fxsave\n- 被调用者: 未明确\n\n4. 函数名: segmented_write\n- 参数: [struct x86_emulate_ctxt *ctxt, ctxt->memop.addr.mem, &fx_state, size]\n- 调用者: em_fxsave\n- 被调用者: 未明确\n\n5. 函数名: ctxt->ops->get_fpu\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: em_fxsave\n- 被调用者: 未明确\n\n6. 函数名: ctxt->ops->put_fpu\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: em_fxsave\n- 被调用者: 未明确\n\n7. 函数名: ctxt->ops->get_cr\n- 参数: [struct x86_emulate_ctxt *ctxt, 4]\n- 调用者: em_fxsave\n- 被调用者: 未明确"
  },
  {
    "id": 1482,
    "cwe": "CWE-416",
    "cve": "CVE-2017-6346",
    "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中PACKET_FANOUT套接字选项的功能，用于将多个套接字分组以进行数据包分发处理。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多线程环境下对fanout_list的访问缺乏足够的同步保护，导致在PACKET_FANOUT setsockopt系统调用时可能出现竞争条件，引发use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: fanout_add\n- 参数: [struct sock *sk, u16 id, u16 type_flags]\n- 调用者: 未明确显示（应为系统调用处理函数）\n- 被调用者: [pkt_sk, kzalloc, atomic_long_set, mutex_lock, list_for_each_entry, read_pnet, sock_net, write_pnet, spin_lock_init, atomic_set, fanout_init_data, dev_add_pack, list_add, atomic_read, __dev_remove_pack, atomic_inc, __fanout_link, mutex_unlock, kfree]\n\n2. 函数名: pkt_sk\n- 参数: [struct sock *sk]\n- 调用者: fanout_add\n- 被调用者: []\n\n3. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: fanout_add\n- 被调用者: []\n\n4. 函数名: atomic_long_set\n- 参数: [atomic_long_t *v, long i]\n- 调用者: fanout_add\n- 被调用者: []\n\n5. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: fanout_add\n- 被调用者: []\n\n6. 函数名: list_for_each_entry\n- 参数: [type *pos, struct list_head *head, member]\n- 调用者: fanout_add\n- 被调用者: []\n\n7. 函数名: read_pnet\n- 参数: [const possible_net_t *net]\n- 调用者: fanout_add\n- 被调用者: []\n\n8. 函数名: sock_net\n- 参数: [const struct sock *sk]\n- 调用者: fanout_add\n- 被调用者: []\n\n9. 函数名: write_pnet\n- 参数: [possible_net_t *net, struct net *net]\n- 调用者: fanout_add\n- 被调用者: []\n\n10. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: fanout_add\n- 被调用者: []\n\n11. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: fanout_add\n- 被调用者: []\n\n12. 函数名: fanout_init_data\n- 参数: [struct packet_fanout *f]\n- 调用者: fanout_add\n- 被调用者: []\n\n13. 函数名: dev_add_pack\n- 参数: [struct packet_type *pt]\n- 调用者: fanout_add\n- 被调用者: []\n\n14. 函数名: list_add\n- 参数: [struct list_head *new, struct list_head *head]\n- 调用者: fanout_add\n- 被调用者: []\n\n15. 函数名: atomic_read\n- 参数: [const atomic_t *v]\n- 调用者: fanout_add\n- 被调用者: []\n\n16. 函数名: __dev_remove_pack\n- 参数: [struct packet_type *pt]\n- 调用者: fanout_add\n- 被调用者: []\n\n17. 函数名: atomic_inc\n- 参数: [atomic_t *v]\n- 调用者: fanout_add\n- 被调用者: []\n\n18. 函数名: __fanout_link\n- 参数: [struct sock *sk, struct packet_sock *po]\n- 调用者: fanout_add\n- 被调用者: []\n\n19. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: fanout_add\n- 被调用者: []\n\n20. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: fanout_add\n- 被调用者: []"
  },
  {
    "id": 1483,
    "cwe": "CWE-416",
    "cve": "CVE-2017-6346",
    "purpose": "Code purpose:\"\"\"管理网络数据包扇出(fanout)结构的释放，包括引用计数递减、链表删除和内存释放等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在多线程环境下，由于缺乏对fanout结构体的引用计数的适当保护，导致在释放内存后可能被其他线程继续访问，造成use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: fanout_release\n- 参数: [struct sock *sk]\n- 调用者: 未明确显示（由系统调用触发）\n- 被调用者: [pkt_sk, mutex_lock, atomic_dec_and_test, list_del, dev_remove_pack, fanout_release_data, kfree, mutex_unlock, kfree_rcu]\n\n2. 函数名: pkt_sk\n- 参数: [struct sock *sk]\n- 调用者: fanout_release\n- 被调用者: []\n\n3. 函数名: mutex_lock\n- 参数: [&fanout_mutex]\n- 调用者: fanout_release\n- 被调用者: []\n\n4. 函数名: atomic_dec_and_test\n- 参数: [&f->sk_ref]\n- 调用者: fanout_release\n- 被调用者: []\n\n5. 函数名: list_del\n- 参数: [&f->list]\n- 调用者: fanout_release\n- 被调用者: []\n\n6. 函数名: dev_remove_pack\n- 参数: [&f->prot_hook]\n- 调用者: fanout_release\n- 被调用者: []\n\n7. 函数名: fanout_release_data\n- 参数: [f]\n- 调用者: fanout_release\n- 被调用者: []\n\n8. 函数名: kfree\n- 参数: [f]\n- 调用者: fanout_release\n- 被调用者: []\n\n9. 函数名: mutex_unlock\n- 参数: [&fanout_mutex]\n- 调用者: fanout_release\n- 被调用者: []\n\n10. 函数名: kfree_rcu\n- 参数: [po->rollover, rcu]\n- 调用者: fanout_release\n- 被调用者: []"
  },
  {
    "id": 1487,
    "cwe": "CWE-416",
    "cve": "CVE-2017-6874",
    "purpose": "Code purpose:\"\"\"该代码用于在原子计数器减至零时释放ucounts结构体，涉及链表操作和内存释放\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"由于原子递减操作与链表删除操作之间的竞争条件，导致在释放ucounts结构体后可能被再次访问，造成释放后重用漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: put_ucounts\n- 参数: [struct ucounts *ucounts]\n- 调用者: 未明确（由系统调用触发）\n- 被调用者: [atomic_dec_and_test, spin_lock_irqsave, hlist_del_init, spin_unlock_irqrestore, kfree]\n\n2. 函数名: atomic_dec_and_test\n- 参数: [&ucounts->count]\n- 调用者: put_ucounts\n- 被调用者: []\n\n3. 函数名: spin_lock_irqsave\n- 参数: [&ucounts_lock, flags]\n- 调用者: put_ucounts\n- 被调用者: []\n\n4. 函数名: hlist_del_init\n- 参数: [&ucounts->node]\n- 调用者: put_ucounts\n- 被调用者: []\n\n5. 函数名: spin_unlock_irqrestore\n- 参数: [&ucounts_lock, flags]\n- 调用者: put_ucounts\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [ucounts]\n- 调用者: put_ucounts\n- 被调用者: []"
  },
  {
    "id": 1488,
    "cwe": "CWE-416",
    "cve": "CVE-2017-6874",
    "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中管理用户命名空间的引用计数，通过哈希表查找或创建ucounts结构体来跟踪特定用户命名空间和用户ID的使用情况。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"竞态条件下，由于get_ucounts函数中释放和重用ucounts对象时缺乏适当的同步保护，导致可能发生use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: get_ucounts\n- 参数: [struct user_namespace *ns, kuid_t uid]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [ucounts_hashentry, find_ucounts, spin_lock_irq, spin_unlock_irq, kzalloc, kfree, atomic_set, hlist_add_head, atomic_add_unless]\n\n2. 函数名: ucounts_hashentry\n- 参数: [struct user_namespace *ns, kuid_t uid]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n3. 函数名: find_ucounts\n- 参数: [struct user_namespace *ns, kuid_t uid, struct hlist_head *hashent]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n4. 函数名: spin_lock_irq\n- 参数: [&ucounts_lock]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n5. 函数名: spin_unlock_irq\n- 参数: [&ucounts_lock]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n6. 函数名: kzalloc\n- 参数: [sizeof(*new), GFP_KERNEL]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n7. 函数名: kfree\n- 参数: [new]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n8. 函数名: atomic_set\n- 参数: [&new->count, 0]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n9. 函数名: hlist_add_head\n- 参数: [&new->node, hashent]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n10. 函数名: atomic_add_unless\n- 参数: [&ucounts->count, 1, INT_MAX]\n- 调用者: get_ucounts\n- 被调用者: 未明确"
  },
  {
    "id": 1497,
    "cwe": "CWE-416",
    "cve": "CVE-2017-7374",
    "purpose": "Code purpose:\"\"\"验证加密文件系统中目录项的有效性，特别是处理与加密密钥相关的状态变化\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在密钥被撤销后，代码未正确处理加密信息对象(ci)的释放，导致后续使用时可能引用已释放的内存\"\"\"",
    "functions": "Functions:\n1. 函数名: fscrypt_d_revalidate\n- 参数: [struct dentry *dentry, unsigned int flags]\n- 调用者: 未显示（通常由文件系统调用）\n- 被调用者: [dget_parent, d_inode, dput, spin_lock, spin_unlock, d_is_negative]\n\n2. 函数名: dget_parent\n- 参数: [struct dentry *dentry]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: []\n\n3. 函数名: d_inode\n- 参数: [struct dentry *dentry]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: []\n\n4. 函数名: dput\n- 参数: [struct dentry *dentry]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: []\n\n5. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: []\n\n6. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: []\n\n7. 函数名: d_is_negative\n- 参数: [const struct dentry *dentry]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: []"
  },
  {
    "id": 1498,
    "cwe": "CWE-416",
    "cve": "CVE-2017-7374",
    "purpose": "Code purpose:\"\"\"该代码用于处理Linux内核中文件系统加密相关的文件名设置，包括加密文件名分配、加密操作以及解密处理等功能。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当密钥环中的密钥被撤销时，加密转换对象被过早释放，导致后续使用时出现空指针解引用问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: fscrypt_setup_filename\n- 参数: [struct inode *dir, const struct qstr *iname, int lookup, struct fscrypt_name *fname]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [memset, fscrypt_is_dot_dotdot, fscrypt_get_crypt_info, fscrypt_fname_alloc_buffer, fname_encrypt, kmalloc, digest_decode, memcpy, fscrypt_fname_free_buffer]\n\n2. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: fscrypt_setup_filename\n- 被调用者: 无\n\n3. 函数名: fscrypt_is_dot_dotdot\n- 参数: [const struct qstr *iname]\n- 调用者: fscrypt_setup_filename\n- 被调用者: 无\n\n4. 函数名: fscrypt_get_crypt_info\n- 参数: [struct inode *dir]\n- 调用者: fscrypt_setup_filename\n- 被调用者: 无\n\n5. 函数名: fscrypt_fname_alloc_buffer\n- 参数: [struct inode *dir, unsigned int len, struct fscrypt_str *crypto_buf]\n- 调用者: fscrypt_setup_filename\n- 被调用者: 无\n\n6. 函数名: fname_encrypt\n- 参数: [struct inode *dir, const struct qstr *iname, struct fscrypt_str *out]\n- 调用者: fscrypt_setup_filename\n- 被调用者: 无\n\n7. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: fscrypt_setup_filename\n- 被调用者: 无\n\n8. 函数名: digest_decode\n- 参数: [const char *src, int len, char *dst]\n- 调用者: fscrypt_setup_filename\n- 被调用者: 无\n\n9. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: fscrypt_setup_filename\n- 被调用者: 无\n\n10. 函数名: fscrypt_fname_free_buffer\n- 参数: [struct fscrypt_str *crypto_buf]\n- 调用者: fscrypt_setup_filename\n- 被调用者: 无"
  },
  {
    "id": 1499,
    "cwe": "CWE-416",
    "cve": "CVE-2017-7374",
    "purpose": "Code purpose:\"\"\"检查inode的加密信息是否有效，若无效则重新获取加密信息\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"当密钥环密钥被撤销时，加密信息结构体中的密钥指针未被及时清理，导致后续使用时可能引用已释放的内存。\"\"\"",
    "functions": "Functions:\n1. 函数名: fscrypt_get_encryption_info\n- 参数: [struct inode *inode]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [fscrypt_get_crypt_info]\n\n2. 函数名: fscrypt_get_crypt_info\n- 参数: [struct inode *inode]\n- 调用者: [fscrypt_get_encryption_info]\n- 被调用者: 未明确（代码片段中未显示）"
  },
  {
    "id": 1500,
    "cwe": "CWE-416",
    "cve": "CVE-2017-7374",
    "purpose": "Code purpose:\"\"\"验证用户提供的加密密钥并派生用于文件系统加密的密钥\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在密钥被撤销后仍尝试访问已释放的密钥环密钥，导致使用后释放漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: validate_user_key\n- 参数: [struct fscrypt_info *crypt_info, struct fscrypt_context *ctx, u8 *raw_key, const char *prefix]\n- 调用者: (未明确显示)\n- 被调用者: [kasprintf, request_key, kfree, IS_ERR, PTR_ERR, printk_once, down_read, user_key_payload, up_read, derive_key_aes, key_put]\n\n2. 函数名: kasprintf\n- 参数: [GFP_NOFS, \"%s%*phN\", prefix, FS_KEY_DESCRIPTOR_SIZE, ctx->master_key_descriptor]\n- 调用者: validate_user_key\n- 被调用者: (未明确显示)\n\n3. 函数名: request_key\n- 参数: [&key_type_logon, description, NULL]\n- 调用者: validate_user_key\n- 被调用者: (未明确显示)\n\n4. 函数名: kfree\n- 参数: [description]\n- 调用者: validate_user_key\n- 被调用者: (未明确显示)\n\n5. 函数名: IS_ERR\n- 参数: [keyring_key]\n- 调用者: validate_user_key\n- 被调用者: (未明确显示)\n\n6. 函数名: PTR_ERR\n- 参数: [keyring_key]\n- 调用者: validate_user_key\n- 被调用者: (未明确显示)\n\n7. 函数名: printk_once\n- 参数: [KERN_WARNING, \"%s: key type must be logon\\n\", __func__]\n- 调用者: validate_user_key\n- 被调用者: (未明确显示)\n\n8. 函数名: down_read\n- 参数: [&keyring_key->sem]\n- 调用者: validate_user_key\n- 被调用者: (未明确显示)\n\n9. 函数名: user_key_payload\n- 参数: [keyring_key]\n- 调用者: validate_user_key\n- 被调用者: (未明确显示)\n\n10. 函数名: up_read\n- 参数: [&keyring_key->sem]\n- 调用者: validate_user_key\n- 被调用者: (未明确显示)\n\n11. 函数名: derive_key_aes\n- 参数: [ctx->nonce, master_key->raw, raw_key]\n- 调用者: validate_user_key\n- 被调用者: (未明确显示)\n\n12. 函数名: key_put\n- 参数: [keyring_key]\n- 调用者: validate_user_key\n- 被调用者: (未明确显示)"
  },
  {
    "id": 1501,
    "cwe": "CWE-416",
    "cve": "CVE-2017-7374",
    "purpose": "Code purpose:\"\"\"释放文件系统加密信息结构体及其相关资源\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在释放加密信息结构体时未正确处理密钥环密钥与加密转换对象的引用关系，导致密钥被撤销时可能引发提前释放和使用后释放问题\"\"\"",
    "functions": "Functions:\n1. 函数名: put_crypt_info\n- 参数: [struct fscrypt_info *ci]\n- 调用者: 未指定\n- 被调用者: [key_put, crypto_free_skcipher, kmem_cache_free]\n\n2. 函数名: key_put\n- 参数: [ci->ci_keyring_key]\n- 调用者: put_crypt_info\n- 被调用者: 未指定\n\n3. 函数名: crypto_free_skcipher\n- 参数: [ci->ci_ctfm]\n- 调用者: put_crypt_info\n- 被调用者: 未指定\n\n4. 函数名: kmem_cache_free\n- 参数: [fscrypt_info_cachep, ci]\n- 调用者: put_crypt_info\n- 被调用者: 未指定"
  },
  {
    "id": 1507,
    "cwe": "CWE-416",
    "cve": "CVE-2017-7487",
    "purpose": "Code purpose:\"\"\"处理IPX网络接口的ioctl命令，包括设置/获取接口地址、创建/删除接口以及配置自动创建和选择参数\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中ipxitf_ioctl函数在处理SIOCGIFADDR ioctl调用时未能正确管理引用计数，导致在调用失败时可能发生引用计数错误，从而引发use-after-free问题。\"\"\"",
    "functions": "Functions:\n1. 函数名: ipxitf_ioctl\n- 参数: [unsigned int cmd, void __user *arg]\n- 调用者: 未显示（应为内核IOCTL处理调用）\n- 被调用者: [copy_from_user, memcpy, ipxitf_delete, ipxitf_create, __dev_get_by_name, ipxitf_find_using_phys, ipx_map_frame_type, copy_to_user, ipxitf_put, get_user]\n\n2. 函数名: copy_from_user\n- 参数: [&ifr, arg, sizeof(ifr)]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n3. 函数名: memcpy\n- 参数: [f.ipx_device, ifr.ifr_name, sizeof(f.ipx_device)] 和 [f.ipx_node, sipx->sipx_node, IPX_NODE_LEN] 和 [sipx->sipx_node, ipxif->if_node, sizeof(sipx->sipx_node)]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n4. 函数名: ipxitf_delete\n- 参数: [&f]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n5. 函数名: ipxitf_create\n- 参数: [&f]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n6. 函数名: __dev_get_by_name\n- 参数: [&init_net, ifr.ifr_name]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n7. 函数名: ipxitf_find_using_phys\n- 参数: [dev, ipx_map_frame_type(sipx->sipx_type)]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n8. 函数名: ipx_map_frame_type\n- 参数: [sipx->sipx_type]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n9. 函数名: copy_to_user\n- 参数: [arg, &ifr, sizeof(ifr)]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n10. 函数名: ipxitf_put\n- 参数: [ipxif]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n11. 函数名: get_user\n- 参数: [val, (unsigned char __user *) arg]\n- 调用者: ipxitf_ioctl\n- 被调用者: []"
  },
  {
    "id": 1554,
    "cwe": "CWE-416",
    "cve": "CVE-2017-8824",
    "purpose": "Code purpose:\"\"\"该代码实现了DCCP协议套接字断开连接的功能，包括状态转换、资源清理和重置相关参数等操作。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在DCCP_LISTEN状态下通过AF_UNSPEC connect系统调用触发的dccp_disconnect函数中存在use-after-free漏洞\"\"\"",
    "functions": "Functions:\n1. 函数名: dccp_disconnect\n- 参数: [struct sock *sk, int flags]\n- 调用者: 未显示（由系统调用触发）\n- 被调用者: [inet_csk, inet_sk, dccp_set_state, inet_csk_listen_stop, dccp_need_reset, dccp_send_reset, dccp_clear_xmit_timers, __skb_queue_purge, __kfree_skb, inet_reset_saddr, sock_reset_flag, inet_csk_delack_init, __sk_dst_reset, sk->sk_error_report]\n\n2. 函数名: inet_csk\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n3. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n4. 函数名: dccp_set_state\n- 参数: [struct sock *sk, int state]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n5. 函数名: inet_csk_listen_stop\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n6. 函数名: dccp_need_reset\n- 参数: [int old_state]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n7. 函数名: dccp_send_reset\n- 参数: [struct sock *sk, int code]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n8. 函数名: dccp_clear_xmit_timers\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n9. 函数名: __skb_queue_purge\n- 参数: [struct sk_buff_head *list]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n10. 函数名: __kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n11. 函数名: inet_reset_saddr\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n12. 函数名: sock_reset_flag\n- 参数: [struct sock *sk, int flag]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n13. 函数名: inet_csk_delack_init\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n14. 函数名: __sk_dst_reset\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n15. 函数名: sk->sk_error_report\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: []"
  },
  {
    "id": 1593,
    "cwe": "CWE-416",
    "cve": "CVE-2018-10675",
    "purpose": "Code purpose:\"\"\"该代码用于获取当前进程的内存策略信息，包括策略类型和节点掩码，可通过不同标志位控制获取策略的方式和内容。\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在do_get_mempolicy函数中，当flags包含MPOL_F_ADDR时，如果vma存在但pol为NULL，会直接使用default_policy，但在后续操作中未正确处理vma的锁释放和pol的引用计数，导致use-after-free漏洞。\"\"\"",
    "functions": "Functions:\n1. 函数名: do_get_mempolicy\n- 参数: [int *policy, nodemask_t *nmask, unsigned long addr, unsigned long flags]\n- 调用者: 系统调用\n- 被调用者: [task_lock, task_unlock, down_read, up_read, find_vma_intersection, lookup_node, next_node_in, mpol_store_user_nodemask, get_policy_nodemask, mpol_cond_put]\n\n2. 函数名: task_lock\n- 参数: [current]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n3. 函数名: task_unlock\n- 参数: [current]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n4. 函数名: down_read\n- 参数: [&mm->mmap_sem]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n5. 函数名: up_read\n- 参数: [&mm->mmap_sem]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n6. 函数名: find_vma_intersection\n- 参数: [mm, addr, addr+1]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n7. 函数名: lookup_node\n- 参数: [addr]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n8. 函数名: next_node_in\n- 参数: [current->il_prev, pol->v.nodes]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n9. 函数名: mpol_store_user_nodemask\n- 参数: [pol]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n10. 函数名: get_policy_nodemask\n- 参数: [pol, nmask]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n11. 函数名: mpol_cond_put\n- 参数: [pol]\n- 调用者: do_get_mempolicy\n- 被调用者: []"
  },
  {
    "id": 1604,
    "cwe": "CWE-416",
    "cve": "CVE-2018-10876",
    "purpose": "Code purpose:\"\"\"该代码用于在ext4文件系统中异步读取指定块组的块位图，并进行验证和初始化处理\"\"\"",
    "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4文件系统中处理特制镜像时，ext4_ext_remove_space()函数存在释放后使用(UAF)问题\"\"\"",
    "functions": "Functions:\n1. 函数名: ext4_read_block_bitmap_nowait\n- 参数: [struct super_block *sb, ext4_group_t block_group]\n- 调用者: N/A\n- 被调用者: [ext4_get_group_desc, ext4_block_bitmap, le32_to_cpu, ext4_blocks_count, ext4_error, ext4_mark_group_bitmap_corrupted, sb_getblk, bitmap_uptodate, lock_buffer, unlock_buffer, ext4_lock_group, ext4_init_block_bitmap, set_bitmap_uptodate, set_buffer_uptodate, set_buffer_verified, ext4_unlock_group, buffer_uptodate, set_buffer_new, trace_ext4_read_block_bitmap_load, ext4_end_bitmap_read, get_bh, submit_bh, ext4_validate_block_bitmap, put_bh]\n\n2. 函数名: ext4_get_group_desc\n- 参数: [struct super_block *sb, ext4_group_t block_group, NULL]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n3. 函数名: ext4_block_bitmap\n- 参数: [struct super_block *sb, struct ext4_group_desc *desc]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n4. 函数名: le32_to_cpu\n- 参数: [sbi->s_es->s_first_data_block]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n5. 函数名: ext4_blocks_count\n- 参数: [sbi->s_es]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n6. 函数名: ext4_error\n- 参数: [sb, \"Invalid block bitmap block %llu in block_group %u\", bitmap_blk, block_group]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n7. 函数名: ext4_mark_group_bitmap_corrupted\n- 参数: [sb, block_group, EXT4_GROUP_INFO_BBITMAP_CORRUPT]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n8. 函数名: sb_getblk\n- 参数: [sb, bitmap_blk]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n9. 函数名: bitmap_uptodate\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n10. 函数名: lock_buffer\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n11. 函数名: unlock_buffer\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n12. 函数名: ext4_lock_group\n- 参数: [sb, block_group]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n13. 函数名: ext4_init_block_bitmap\n- 参数: [sb, bh, block_group, desc]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n14. 函数名: set_bitmap_uptodate\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n15. 函数名: set_buffer_uptodate\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n16. 函数名: set_buffer_verified\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n17. 函数名: ext4_unlock_group\n- 参数: [sb, block_group]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n18. 函数名: buffer_uptodate\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n19. 函数名: set_buffer_new\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n20. 函数名: trace_ext4_read_block_bitmap_load\n- 参数: [sb, block_group]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n21. 函数名: ext4_end_bitmap_read\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n22. 函数名: get_bh\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n23. 函数名: submit_bh\n- 参数: [REQ_OP_READ, REQ_META | REQ_PRIO, bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n24. 函数名: ext4_validate_block_bitmap\n- 参数: [sb, desc, block_group, bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n25. 函数名: put_bh\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A"
  }
]