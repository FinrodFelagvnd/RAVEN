[
    {
        "id": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2006-3635",
        "purpose": "Code purpose:\"\"\"初始化IA-64架构的系统环境，包括处理器、内存、ACPI、控制台等硬件相关设置，并处理启动参数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核ia64子系统中对无效寄存器栈引擎(RSE)状态处理不当，导致本地用户可通过特制应用程序消耗栈空间造成系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: setup_arch\n- 参数: [char **cmdline_p]\n- 调用者: 未显示\n- 被调用者: [unw_init, ia64_patch_vtop, __va, strlcpy, efi_init, io_port_init, machvec_init_from_cmdline, parse_early_param, early_console_setup, mark_bsp_online, acpi_table_init, acpi_numa_init, per_cpu_scan_finalize, cpus_weight, smp_build_cpu_map, find_memory, ia64_sal_init, hard_smp_processor_id, cpu_init, mmu_context_init, check_sal_cache_flush, acpi_boot_init, efi_mem_type, ia64_mca_init, platform_setup, paging_init]\n\n2. 函数名: unw_init\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n3. 函数名: ia64_patch_vtop\n- 参数: [(u64) __start___vtop_patchlist, (u64) __end___vtop_patchlist]\n- 调用者: setup_arch\n- 被调用者: []\n\n4. 函数名: __va\n- 参数: [ia64_boot_param->command_line]\n- 调用者: setup_arch\n- 被调用者: []\n\n5. 函数名: strlcpy\n- 参数: [boot_command_line, *cmdline_p, COMMAND_LINE_SIZE]\n- 调用者: setup_arch\n- 被调用者: []\n\n6. 函数名: efi_init\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n7. 函数名: io_port_init\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n8. 函数名: machvec_init_from_cmdline\n- 参数: [*cmdline_p]\n- 调用者: setup_arch\n- 被调用者: []\n\n9. 函数名: parse_early_param\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n10. 函数名: early_console_setup\n- 参数: [*cmdline_p]\n- 调用者: setup_arch\n- 被调用者: []\n\n11. 函数名: mark_bsp_online\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n12. 函数名: acpi_table_init\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n13. 函数名: acpi_numa_init\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n14. 函数名: per_cpu_scan_finalize\n- 参数: [(cpus_weight(early_cpu_possible_map) == 0 ? 32 : cpus_weight(early_cpu_possible_map)), additional_cpus]\n- 调用者: setup_arch\n- 被调用者: [cpus_weight]\n\n15. 函数名: cpus_weight\n- 参数: [early_cpu_possible_map]\n- 调用者: per_cpu_scan_finalize\n- 被调用者: []\n\n16. 函数名: smp_build_cpu_map\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n17. 函数名: find_memory\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n18. 函数名: ia64_sal_init\n- 参数: [__va(efi.sal_systab)]\n- 调用者: setup_arch\n- 被调用者: [__va]\n\n19. 函数名: hard_smp_processor_id\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n20. 函数名: cpu_init\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n21. 函数名: mmu_context_init\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n22. 函数名: check_sal_cache_flush\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n23. 函数名: acpi_boot_init\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n24. 函数名: efi_mem_type\n- 参数: [0xA0000]\n- 调用者: setup_arch\n- 被调用者: []\n\n25. 函数名: ia64_mca_init\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []\n\n26. 函数名: platform_setup\n- 参数: [cmdline_p]\n- 调用者: setup_arch\n- 被调用者: []\n\n27. 函数名: paging_init\n- 参数: []\n- 调用者: setup_arch\n- 被调用者: []"
    },
    {
        "id": 4,
        "cwe": "CWE-119",
        "cve": "CVE-2007-6761",
        "purpose": "Code purpose:\"\"\"该代码用于实现视频缓冲区的内存映射功能，将用户空间的虚拟内存区域(vma)映射到内核空间的视频缓冲区，以便用户空间可以直接访问视频数据。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未正确初始化videobuf_mapping数据结构，导致计数错误和videobuf泄漏\"\"\"",
        "functions": "Functions:\n1. 函数名: __videobuf_mmap_mapper\n- 参数: [struct videobuf_queue *q, struct vm_area_struct *vma]\n- 调用者: 未明确（应为内核中调用mmap相关操作的代码）\n- 被调用者: [kmalloc, dprintk, kfree, remap_vmalloc_range, memcpy, videobuf_vm_open]\n\n2. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: __videobuf_mmap_mapper\n- 被调用者: []\n\n3. 函数名: dprintk\n- 参数: [int level, const char *fmt, ...]\n- 调用者: __videobuf_mmap_mapper\n- 被调用者: []\n\n4. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: __videobuf_mmap_mapper\n- 被调用者: []\n\n5. 函数名: remap_vmalloc_range\n- 参数: [struct vm_area_struct *vma, void *addr, unsigned long pgoff]\n- 调用者: __videobuf_mmap_mapper\n- 被调用者: []\n\n6. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: __videobuf_mmap_mapper\n- 被调用者: []\n\n7. 函数名: videobuf_vm_open\n- 参数: [struct vm_area_struct *vma]\n- 调用者: __videobuf_mmap_mapper\n- 被调用者: []"
    },
    {
        "id": 5,
        "cwe": "CWE-119",
        "cve": "CVE-2007-6761",
        "purpose": "Code purpose:\"\"\"该代码用于处理视频缓冲区的虚拟内存区域关闭操作，包括减少映射计数、释放相关资源并在计数为零时释放映射结构体。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未正确初始化videobuf_mapping数据结构，导致count值不正确和videobuf泄漏\"\"\"",
        "functions": "Functions:\n1. 函数名: videobuf_vm_close\n- 参数: [struct vm_area_struct *vma]\n- 调用者: 内核虚拟内存管理系统（当vma区域关闭时）\n- 被调用者: [mutex_lock, mutex_unlock, kfree, dprintk]\n\n2. 函数名: dprintk\n- 参数: [int level, const char *fmt, ...]\n- 调用者: videobuf_vm_close\n- 被调用者: []\n\n3. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: videobuf_vm_close\n- 被调用者: []\n\n4. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: videobuf_vm_close\n- 被调用者: []\n\n5. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: videobuf_vm_close\n- 被调用者: []\n\n6. 函数名: buf_release\n- 参数: [struct videobuf_queue *q, struct videobuf_buffer *buf]\n- 调用者: videobuf_vm_close (通过q->ops->buf_release调用)\n- 被调用者: []"
    },
    {
        "id": 6,
        "cwe": "CWE-119",
        "cve": "CVE-2007-6761",
        "purpose": "Code purpose:\"\"\"该代码片段用于处理视频缓冲区的虚拟内存映射打开操作，增加映射计数器的值\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未初始化videobuf_mapping数据结构导致计数错误和videobuf泄漏\"\"\"",
        "functions": "Functions:\n1. 函数名: videobuf_vm_open\n- 参数: [struct vm_area_struct *vma]\n- 调用者: 未明确指定（通常由内核内存管理子系统调用）\n- 被调用者: [dprintk]"
    },
    {
        "id": 7,
        "cwe": "CWE-119",
        "cve": "CVE-2007-6762",
        "purpose": "Code purpose:\"\"\"该代码用于处理CIPSO v4协议的标签列表，将网络标签信息添加到DOI定义结构中，但存在数组越界漏洞。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在循环条件中未正确处理数组边界检查，导致doi_def->tags数组可能被越界写入一个元素\"\"\"",
        "functions": "Functions:\n1. 函数名: netlbl_cipsov4_add_common\n- 参数: [info, doi_def]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [nla_get_u32, nla_validate_nested, nla_for_each_nested, nla_get_u8]\n\n2. 函数名: nla_get_u32\n- 参数: [info->attrs[NLBL_CIPSOV4_A_DOI]]\n- 调用者: netlbl_cipsov4_add_common\n- 被调用者: []\n\n3. 函数名: nla_validate_nested\n- 参数: [info->attrs[NLBL_CIPSOV4_A_TAGLST], NLBL_CIPSOV4_A_MAX, netlbl_cipsov4_genl_policy]\n- 调用者: netlbl_cipsov4_add_common\n- 被调用者: []\n\n4. 函数名: nla_for_each_nested\n- 参数: [nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem]\n- 调用者: netlbl_cipsov4_add_common\n- 被调用者: []\n\n5. 函数名: nla_get_u8\n- 参数: [nla]\n- 调用者: netlbl_cipsov4_add_common\n- 被调用者: []"
    },
    {
        "id": 10,
        "cwe": "CWE-119",
        "cve": "CVE-2009-2692",
        "purpose": "Code purpose:\"\"\"该代码片段实现了通过socket发送页面数据的核心功能，主要处理非阻塞标志和多次发送标志的设置，并调用底层操作发送数据\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核未初始化proto_ops结构中的所有函数指针，导致本地用户可通过映射零页并触发空指针解引用获取权限\"\"\"",
        "functions": "Functions:\n1. 函数名: sock_sendpage\n- 参数: [struct file *file, struct page *page, int offset, size_t size, loff_t *ppos, int more]\n- 调用者: 未指定（由内核其他部分调用）\n- 被调用者: [sock->ops->sendpage]\n\n2. 函数名: sock->ops->sendpage\n- 参数: [struct socket *sock, struct page *page, int offset, size_t size, int flags]\n- 调用者: sock_sendpage\n- 被调用者: 未指定（由具体协议实现提供）"
    },
    {
        "id": 28,
        "cwe": "CWE-119",
        "cve": "CVE-2010-5332",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中为Mellanox网卡设备注册MAC地址，并管理MAC地址表的引用计数和空闲索引\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当MAC表中没有空闲条目时，循环结束后未检查free变量仍为初始值-1，导致后续数组越界访问\"\"\"",
        "functions": "Functions:\n1. 函数名: mlx4_register_mac\n- 参数: [struct mlx4_dev *dev, u8 port, u64 mac, int *index]\n- 调用者: N/A\n- 被调用者: [mlx4_dbg, mutex_lock, be64_to_cpu, cpu_to_be64, mlx4_set_port_mac_table, mlx4_err, mutex_unlock]\n\n2. 函数名: mlx4_dbg\n- 参数: [struct mlx4_dev *dev, const char *fmt, ...]\n- 调用者: mlx4_register_mac\n- 被调用者: N/A\n\n3. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: mlx4_register_mac\n- 被调用者: N/A\n\n4. 函数名: be64_to_cpu\n- 参数: [__be64 x]\n- 调用者: mlx4_register_mac\n- 被调用者: N/A\n\n5. 函数名: cpu_to_be64\n- 参数: [u64 x]\n- 调用者: mlx4_register_mac\n- 被调用者: N/A\n\n6. 函数名: mlx4_set_port_mac_table\n- 参数: [struct mlx4_dev *dev, u8 port, __be64 *entries]\n- 调用者: mlx4_register_mac\n- 被调用者: N/A\n\n7. 函数名: mlx4_err\n- 参数: [struct mlx4_dev *dev, const char *fmt, ...]\n- 调用者: mlx4_register_mac\n- 被调用者: N/A\n\n8. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: mlx4_register_mac\n- 被调用者: N/A"
    },
    {
        "id": 29,
        "cwe": "CWE-119",
        "cve": "CVE-2010-5332",
        "purpose": "Code purpose:\"\"\"在Linux内核中为指定端口注册VLAN并管理VLAN表项\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当在mlx4_register_vlan()函数中搜索空闲条目时，如果没有找到空闲条目且循环结束时未更新free变量，会导致后续数组越界访问。\"\"\"",
        "functions": "Functions:\n1. 函数名: mlx4_register_vlan\n- 参数: [struct mlx4_dev *dev, u8 port, u16 vlan, int *index]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [mlx4_set_port_vlan_table, mlx4_warn, mutex_lock, mutex_unlock, be32_to_cpu, cpu_to_be32]\n\n2. 函数名: mlx4_set_port_vlan_table\n- 参数: [struct mlx4_dev *dev, u8 port, u32 *entries]\n- 调用者: mlx4_register_vlan\n- 被调用者: 未明确（可能是底层驱动函数）\n\n3. 函数名: mlx4_warn\n- 参数: [struct mlx4_dev *dev, const char *format, ...]\n- 调用者: mlx4_register_vlan\n- 被调用者: 未明确（可能是内核打印函数）\n\n4. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: mlx4_register_vlan\n- 被调用者: 未明确（内核互斥锁函数）\n\n5. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: mlx4_register_vlan\n- 被调用者: 未明确（内核互斥锁函数）\n\n6. 函数名: be32_to_cpu\n- 参数: [__be32 val]\n- 调用者: mlx4_register_vlan\n- 被调用者: 未明确（字节序转换函数）\n\n7. 函数名: cpu_to_be32\n- 参数: [u32 val]\n- 调用者: mlx4_register_vlan\n- 被调用者: 未明确（字节序转换函数）"
    },
    {
        "id": 30,
        "cwe": "CWE-119",
        "cve": "CVE-2011-4098",
        "purpose": "Code purpose:\"\"\"该代码实现了GFS2文件系统中块分配的功能，包括处理间接块分配、树高度增长以及数据块分配等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"GFS2文件系统中的fallocate实现依赖于页面缓存，在内存不足的情况下可能导致本地用户通过预分配块造成拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: gfs2_bmap_alloc\n- 参数: [inode, lblock, bh_map, mp, sheight, height, maxlen]\n- 调用者: N/A (top-level function)\n- 被调用者: [GFS2_I, GFS2_SB, gfs2_trans_add_bh, gfs2_extent_length, metapointer, min, metapath_branch_start, gfs2_alloc_block, gfs2_is_jdata, gfs2_trans_add_unrevoke, gfs2_indirect_init, gfs2_buffer_copy_tail, gfs2_buffer_clear_tail, brelse, cpu_to_be64, gfs2_add_inode_blocks, gfs2_dinode_out, map_bh, set_buffer_new]\n\n2. 函数名: GFS2_I\n- 参数: [inode]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n3. 函数名: GFS2_SB\n- 参数: [inode]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n4. 函数名: gfs2_trans_add_bh\n- 参数: [ip->i_gl, dibh, 1]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n5. 函数名: gfs2_extent_length\n- 参数: [bh->b_data, bh->b_size, ptr, maxlen, &eob]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n6. 函数名: metapointer\n- 参数: [end_of_metadata, mp]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n7. 函数名: min\n- 参数: [maxlen, ptrs_per_blk - mp->mp_list[end_of_metadata]]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n8. 函数名: metapath_branch_start\n- 参数: [mp]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n9. 函数名: gfs2_alloc_block\n- 参数: [ip, &bn, &n]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n10. 函数名: gfs2_is_jdata\n- 参数: [ip]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n11. 函数名: gfs2_trans_add_unrevoke\n- 参数: [sdp, bn, n]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n12. 函数名: gfs2_indirect_init\n- 参数: [mp, ip->i_gl, i, 0, bn++]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n13. 函数名: gfs2_buffer_copy_tail\n- 参数: [mp->mp_bh[i], sizeof(struct gfs2_meta_header), dibh, sizeof(struct gfs2_dinode)]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n14. 函数名: gfs2_buffer_clear_tail\n- 参数: [dibh, sizeof(struct gfs2_dinode) + sizeof(__be64)]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n15. 函数名: brelse\n- 参数: [mp->mp_bh[i]]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n16. 函数名: cpu_to_be64\n- 参数: [bn++]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n17. 函数名: gfs2_add_inode_blocks\n- 参数: [&ip->i_inode, alloced]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n18. 函数名: gfs2_dinode_out\n- 参数: [ip, mp->mp_bh[0]->b_data]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n19. 函数名: map_bh\n- 参数: [bh_map, inode->i_sb, dblock]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []\n\n20. 函数名: set_buffer_new\n- 参数: [bh_map]\n- 调用者: gfs2_bmap_alloc\n- 被调用者: []"
    },
    {
        "id": 31,
        "cwe": "CWE-119",
        "cve": "CVE-2011-4098",
        "purpose": "Code purpose:\"\"\"该代码实现了GFS2文件系统中预分配文件空间的功能，通过操作页缓存来扩展文件大小并分配物理块。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"GFS2文件系统中的fallocate实现过度依赖页面缓存，在内存不足的情况下可能导致本地用户通过预分配块造成拒绝服务。\"\"\"",
        "functions": "Functions:\n1. 函数名: fallocate_chunk\n- 参数: [struct inode *inode, loff_t offset, loff_t len, int mode]\n- 调用者: 未显示\n- 被调用者: [GFS2_I, gfs2_meta_inode_buffer, gfs2_trans_add_bh, gfs2_is_stuffed, gfs2_unstuff_dinode, grab_cache_page_write_begin, write_empty_blocks, i_size_write, unlock_page, page_cache_release, mark_inode_dirty, brelse]\n\n2. 函数名: GFS2_I\n- 参数: [struct inode *inode]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示\n\n3. 函数名: gfs2_meta_inode_buffer\n- 参数: [struct gfs2_inode *ip, struct buffer_head **dibh]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示\n\n4. 函数名: gfs2_trans_add_bh\n- 参数: [struct gfs2_glock *gl, struct buffer_head *bh, int meta]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示\n\n5. 函数名: gfs2_is_stuffed\n- 参数: [struct gfs2_inode *ip]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示\n\n6. 函数名: gfs2_unstuff_dinode\n- 参数: [struct gfs2_inode *ip, struct page *page]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示\n\n7. 函数名: grab_cache_page_write_begin\n- 参数: [struct address_space *mapping, pgoff_t index, unsigned flags]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示\n\n8. 函数名: write_empty_blocks\n- 参数: [struct page *page, unsigned int from, unsigned int to, int mode]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示\n\n9. 函数名: i_size_write\n- 参数: [struct inode *inode, loff_t i_size]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示\n\n10. 函数名: unlock_page\n- 参数: [struct page *page]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示\n\n11. 函数名: page_cache_release\n- 参数: [struct page *page]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示\n\n12. 函数名: mark_inode_dirty\n- 参数: [struct inode *inode]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示\n\n13. 函数名: brelse\n- 参数: [struct buffer_head *bh]\n- 调用者: fallocate_chunk\n- 被调用者: 未显示"
    },
    {
        "id": 32,
        "cwe": "CWE-119",
        "cve": "CVE-2011-4098",
        "purpose": "Code purpose:\"\"\"该代码实现了GFS2文件系统中的fallocate功能，用于预分配文件空间，但在内存不足时可能因依赖页面缓存而导致拒绝服务漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"GFS2文件系统中的fallocate实现依赖于页缓存，在内存不足的情况下可能导致本地用户通过预分配块造成拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: gfs2_fallocate\n- 参数: [struct file *file, int mode, loff_t offset, loff_t len]\n- 调用者: 无（系统调用接口）\n- 被调用者: [gfs2_holder_init, gfs2_glock_nq, gfs2_write_alloc_required, gfs2_alloc_get, gfs2_quota_lock_check, gfs2_write_calc_reserv, gfs2_inplace_reserve, calc_max_reserv, gfs2_trans_begin, fallocate_chunk, gfs2_trans_end, gfs2_inplace_release, gfs2_quota_unlock, gfs2_alloc_put, gfs2_glock_dq, gfs2_holder_uninit]\n\n2. 函数名: gfs2_holder_init\n- 参数: [ip->i_gl, LM_ST_EXCLUSIVE, 0, &ip->i_gh]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n3. 函数名: gfs2_glock_nq\n- 参数: [&ip->i_gh]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n4. 函数名: gfs2_write_alloc_required\n- 参数: [ip, offset, len]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n5. 函数名: gfs2_alloc_get\n- 参数: [ip]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n6. 函数名: gfs2_quota_lock_check\n- 参数: [ip]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n7. 函数名: gfs2_write_calc_reserv\n- 参数: [ip, bytes, &data_blocks, &ind_blocks]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n8. 函数名: gfs2_inplace_reserve\n- 参数: [ip]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n9. 函数名: calc_max_reserv\n- 参数: [ip, len, &max_bytes, &data_blocks, &ind_blocks]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n10. 函数名: gfs2_trans_begin\n- 参数: [sdp, rblocks, PAGE_CACHE_SIZE/sdp->sd_sb.sb_bsize]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n11. 函数名: fallocate_chunk\n- 参数: [inode, offset, max_bytes, mode]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n12. 函数名: gfs2_trans_end\n- 参数: [sdp]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n13. 函数名: gfs2_inplace_release\n- 参数: [ip]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n14. 函数名: gfs2_quota_unlock\n- 参数: [ip]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n15. 函数名: gfs2_alloc_put\n- 参数: [ip]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n16. 函数名: gfs2_glock_dq\n- 参数: [&ip->i_gh]\n- 调用者: gfs2_fallocate\n- 被调用者: 无\n\n17. 函数名: gfs2_holder_uninit\n- 参数: [&ip->i_gh]\n- 调用者: gfs2_fallocate\n- 被调用者: 无"
    },
    {
        "id": 39,
        "cwe": "CWE-119",
        "cve": "CVE-2011-5327",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中为TCM（Target Core Module）环回驱动创建和注册一个NAA（Network Address Authority）目标端口组，处理传入的配置参数并验证其有效性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在tcm_loop_make_naa_tpg函数中，对tpgt值的边界检查不严格，存在off-by-one错误，可能导致数组越界访问和内存损坏\"\"\"",
        "functions": "Functions:\n1. 函数名: tcm_loop_make_naa_tpg\n- 参数: [wwn, group, name]\n- 调用者: 未明确显示（由configfs调用）\n- 被调用者: [container_of, strstr, printk, simple_strtoul, core_tpg_register, tcm_loop_dump_proto_id, config_item_name]\n\n2. 函数名: container_of\n- 参数: [wwn, struct tcm_loop_hba, tl_hba_wwn]\n- 调用者: tcm_loop_make_naa_tpg\n- 被调用者: []\n\n3. 函数名: strstr\n- 参数: [name, \"tpgt_\"]\n- 调用者: tcm_loop_make_naa_tpg\n- 被调用者: []\n\n4. 函数名: printk\n- 参数: [KERN_ERR, \"Unable to locate \\\"tpgt_#\\\" directory group\\n\"] 和 [KERN_ERR, \"Passed tpgt: %hu exceeds TL_TPGS_PER_HBA: %u\\n\", tpgt, TL_TPGS_PER_HBA] 和 [KERN_INFO, \"TCM_Loop_ConfigFS: Allocated Emulated %s Target Port %s,t,0x%04x\\n\", tcm_loop_dump_proto_id(tl_hba), config_item_name(&wwn->wwn_group.cg_item), tpgt]\n- 调用者: tcm_loop_make_naa_tpg\n- 被调用者: []\n\n5. 函数名: simple_strtoul\n- 参数: [tpgt_str, &end_ptr, 0]\n- 调用者: tcm_loop_make_naa_tpg\n- 被调用者: []\n\n6. 函数名: core_tpg_register\n- 参数: [&tcm_loop_fabric_configfs->tf_ops, wwn, &tl_tpg->tl_se_tpg, tl_tpg, TRANSPORT_TPG_TYPE_NORMAL]\n- 调用者: tcm_loop_make_naa_tpg\n- 被调用者: []\n\n7. 函数名: tcm_loop_dump_proto_id\n- 参数: [tl_hba]\n- 调用者: tcm_loop_make_naa_tpg\n- 被调用者: []\n\n8. 函数名: config_item_name\n- 参数: [&wwn->wwn_group.cg_item]\n- 调用者: tcm_loop_make_naa_tpg\n- 被调用者: []"
    },
    {
        "id": 40,
        "cwe": "CWE-119",
        "cve": "CVE-2012-2119",
        "purpose": "Code purpose:\"\"\"将用户空间的iovec数据通过零拷贝方式复制到内核空间的sk_buff中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理长向量长度时未正确验证边界条件，导致缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: zerocopy_sg_from_iovec\n- 参数: [skb, from, offset, count]\n- 调用者: 未显示（由macvtap设备驱动调用）\n- 被调用者: [iov_length, min_t, copy_from_user, get_user_pages_fast, skb_shinfo, __skb_fill_page_desc]\n\n2. 函数名: iov_length\n- 参数: [from, count]\n- 调用者: zerocopy_sg_from_iovec\n- 被调用者: 未显示\n\n3. 函数名: min_t\n- 参数: [unsigned int, copy, from->iov_len - offset]\n- 调用者: zerocopy_sg_from_iovec\n- 被调用者: 未显示\n\n4. 函数名: copy_from_user\n- 参数: [skb->data + offset1, from->iov_base + offset, size]\n- 调用者: zerocopy_sg_from_iovec\n- 被调用者: 未显示\n\n5. 函数名: get_user_pages_fast\n- 参数: [base, size, 0, &page[i]]\n- 调用者: zerocopy_sg_from_iovec\n- 被调用者: 未显示\n\n6. 函数名: skb_shinfo\n- 参数: [skb]\n- 调用者: zerocopy_sg_from_iovec\n- 被调用者: 未显示\n\n7. 函数名: __skb_fill_page_desc\n- 参数: [skb, i, page[i], off, size]\n- 调用者: zerocopy_sg_from_iovec\n- 被调用者: 未显示"
    },
    {
        "id": 42,
        "cwe": "CWE-119",
        "cve": "CVE-2012-2137",
        "purpose": "Code purpose:\"\"\"该代码用于设置KVM虚拟机的IRQ路由表条目，处理不同类型的中断路由配置，包括IRQ芯片和MSI中断。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"setup_routing_entry函数在处理MSI中断路由时未正确验证输入参数，导致缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: setup_routing_entry\n- 参数: [struct kvm_irq_routing_table *rt, struct kvm_kernel_irq_routing_entry *e, const struct kvm_irq_routing_entry *ue]\n- 调用者: 未明确显示（通常是KVM子系统中的IRQ路由设置相关函数）\n- 被调用者: [kvm_set_pic_irq, kvm_set_ioapic_irq, kvm_set_msi]\n\n2. 函数名: kvm_set_pic_irq\n- 参数: 未显示（由函数指针调用）\n- 调用者: setup_routing_entry\n- 被调用者: []\n\n3. 函数名: kvm_set_ioapic_irq\n- 参数: 未显示（由函数指针调用）\n- 调用者: setup_routing_entry\n- 被调用者: []\n\n4. 函数名: kvm_set_msi\n- 参数: 未显示（由函数指针调用）\n- 调用者: setup_routing_entry\n- 被调用者: []\n\n5. 函数名: hlist_for_each_entry\n- 参数: [ei, n, &rt->map[ue->gsi], link]\n- 调用者: setup_routing_entry\n- 被调用者: []\n\n6. 函数名: hlist_add_head\n- 参数: [&e->link, &rt->map[e->gsi]]\n- 调用者: setup_routing_entry\n- 被调用者: []"
    },
    {
        "id": 53,
        "cwe": "CWE-119",
        "cve": "CVE-2012-2745",
        "purpose": "Code purpose:\"\"\"该代码用于在进程创建时复制或创建新的凭证(credentials)，包括处理线程组凭证、密钥环(keyring)以及用户命名空间等，确保新进程或线程拥有适当的权限和访问控制。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在copy_creds函数中，当CLONE_THREAD标志被设置时，未能正确处理会话密钥环的替换，导致子进程获得了无效的会话密钥环引用\"\"\"",
        "functions": "Functions:\n1. 函数名: copy_creds\n- 参数: [struct task_struct *p, unsigned long clone_flags]\n- 调用者: N/A\n- 被调用者: [get_cred, alter_cred_subscribers, atomic_read, read_cred_subscribers, atomic_inc, prepare_creds, create_user_ns, key_put, install_thread_keyring_to_cred, kmalloc, atomic_set, spin_lock_init, key_get, release_tgcred, validate_creds, put_cred]\n\n2. 函数名: get_cred\n- 参数: [struct cred *cred]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n3. 函数名: alter_cred_subscribers\n- 参数: [struct cred *cred, int count]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n4. 函数名: atomic_read\n- 参数: [atomic_t *v]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n5. 函数名: read_cred_subscribers\n- 参数: [struct cred *cred]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n6. 函数名: atomic_inc\n- 参数: [atomic_t *v]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n7. 函数名: prepare_creds\n- 参数: []\n- 调用者: copy_creds\n- 被调用者: N/A\n\n8. 函数名: create_user_ns\n- 参数: [struct cred *new]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n9. 函数名: key_put\n- 参数: [struct key *key]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n10. 函数名: install_thread_keyring_to_cred\n- 参数: [struct cred *new]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n11. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n12. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n13. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n14. 函数名: key_get\n- 参数: [struct key *key]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n15. 函数名: release_tgcred\n- 参数: [struct cred *new]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n16. 函数名: validate_creds\n- 参数: [struct cred *cred]\n- 调用者: copy_creds\n- 被调用者: N/A\n\n17. 函数名: put_cred\n- 参数: [struct cred *cred]\n- 调用者: copy_creds\n- 被调用者: N/A"
    },
    {
        "id": 54,
        "cwe": "CWE-119",
        "cve": "CVE-2012-3364",
        "purpose": "Code purpose:\"\"\"处理NFC设备激活参数，根据不同的RF技术和模式提取并复制相应的数据到结构体中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未验证输入数据的长度是否超出目标缓冲区大小，导致栈缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: nci_extract_activation_params_iso_dep\n- 参数: [struct nci_dev *ndev, struct nci_rf_intf_activated_ntf *ntf, __u8 *data]\n- 调用者: 未显示在代码片段中\n- 被调用者: [memcpy, pr_debug, pr_err]\n\n2. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: nci_extract_activation_params_iso_dep\n- 被调用者: []\n\n3. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: nci_extract_activation_params_iso_dep\n- 被调用者: []\n\n4. 函数名: pr_err\n- 参数: [const char *fmt, ...]\n- 调用者: nci_extract_activation_params_iso_dep\n- 被调用者: []"
    },
    {
        "id": 55,
        "cwe": "CWE-119",
        "cve": "CVE-2012-3364",
        "purpose": "Code purpose:\"\"\"从NCI数据中提取NFCF被动轮询模式的RF参数，包括比特率和sensf_res数据\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未验证输入数据中sensf_res_len字段的长度，导致memcpy操作可能引发栈缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: nci_extract_rf_params_nfcf_passive_poll\n- 参数: [struct nci_dev *ndev, struct rf_tech_specific_params_nfcf_poll *nfcf_poll, __u8 *data]\n- 调用者: 未明确（由NCI模块调用）\n- 被调用者: [memcpy, pr_debug]\n\n2. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: nci_extract_rf_params_nfcf_passive_poll\n- 被调用者: []\n\n3. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: nci_extract_rf_params_nfcf_passive_poll\n- 被调用者: []"
    },
    {
        "id": 56,
        "cwe": "CWE-119",
        "cve": "CVE-2012-3364",
        "purpose": "Code purpose:\"\"\"从NFC数据中提取NFCA被动轮询模式的RF技术特定参数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对输入的nfcid1_len和sel_res_len长度进行有效验证，导致memcpy操作可能引发栈缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nci_extract_rf_params_nfca_passive_poll\n- 参数: [struct nci_dev *ndev, struct rf_tech_specific_params_nfca_poll *nfca_poll, __u8 *data]\n- 调用者: 未明确显示（由NCI接口调用）\n- 被调用者: [__le16_to_cpu, memcpy, pr_debug]\n\n2. 函数名: __le16_to_cpu\n- 参数: [__u16 *data]\n- 调用者: nci_extract_rf_params_nfca_passive_poll\n- 被调用者: []\n\n3. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: nci_extract_rf_params_nfca_passive_poll\n- 被调用者: []\n\n4. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: nci_extract_rf_params_nfca_passive_poll\n- 被调用者: []"
    },
    {
        "id": 57,
        "cwe": "CWE-119",
        "cve": "CVE-2012-3364",
        "purpose": "Code purpose:\"\"\"从NFC数据中提取RF技术特定参数并复制到目标缓冲区\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未对输入的sensb_res_len进行有效验证，导致memcpy操作时可能发生栈缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: nci_extract_rf_params_nfcb_passive_poll\n- 参数: [struct nci_dev *ndev, struct rf_tech_specific_params_nfcb_poll *nfcb_poll, __u8 *data]\n- 调用者: 未明确（由NCI模块调用）\n- 被调用者: [memcpy, pr_debug]\n\n2. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: nci_extract_rf_params_nfcb_passive_poll\n- 被调用者: []\n\n3. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: nci_extract_rf_params_nfcb_passive_poll\n- 被调用者: []"
    },
    {
        "id": 142,
        "cwe": "CWE-119",
        "cve": "CVE-2012-6704",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中获取套接字选项(sock_getsockopt)的功能，处理各种套接字选项的查询请求并将结果返回给用户空间。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理SO_SNDBUF和SO_RCVBUF选项时未正确验证负数值，导致本地用户可利用CAP_NET_ADMIN权限通过特制的setsockopt系统调用造成内存破坏或系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: sock_getsockopt\n- 参数: [struct socket *sock, int level, int optname, char __user *optval, int __user *optlen]\n- 调用者: 未明确显示（通常是系统调用或内核其他模块）\n- 被调用者: [get_user, memset, sock_flag, sock_error, xchg, sock_warn_obsolete_bsdism, cred_to_ucred, copy_to_user, put_user, security_socket_getpeersec_stream]\n\n2. 函数名: get_user\n- 参数: [len, optlen]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n3. 函数名: memset\n- 参数: [&v, 0, sizeof(v)]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n4. 函数名: sock_flag\n- 参数: [sk, SOCK_DBG/SOCK_LOCALROUTE/SOCK_BROADCAST/SOCK_KEEPOPEN/SOCK_URGINLINE/SOCK_LINGER/SOCK_RCVTSTAMP/SOCK_RCVTSTAMPNS/SOCK_TIMESTAMPING_TX_HARDWARE/SOCK_TIMESTAMPING_TX_SOFTWARE/SOCK_TIMESTAMPING_RX_HARDWARE/SOCK_TIMESTAMPING_RX_SOFTWARE/SOCK_TIMESTAMPING_SOFTWARE/SOCK_TIMESTAMPING_SYS_HARDWARE/SOCK_TIMESTAMPING_RAW_HARDWARE/SOCK_RXQ_OVFL/SOCK_WIFI_STATUS/SOCK_NOFCS]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n5. 函数名: sock_error\n- 参数: [sk]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n6. 函数名: xchg\n- 参数: [&sk->sk_err_soft, 0]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n7. 函数名: sock_warn_obsolete_bsdism\n- 参数: [\"getsockopt\"]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n8. 函数名: cred_to_ucred\n- 参数: [sk->sk_peer_pid, sk->sk_peer_cred, &peercred]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n9. 函数名: copy_to_user\n- 参数: [optval, &peercred/address/&v, len]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n10. 函数名: put_user\n- 参数: [len, optlen]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n11. 函数名: security_socket_getpeersec_stream\n- 参数: [sock, optval, optlen, len]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n12. 函数名: sock->ops->getname\n- 参数: [sock, (struct sockaddr *)address, &lv, 2]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n13. 函数名: sock->ops->set_peek_off\n- 参数: 未显示具体参数\n- 调用者: sock_getsockopt\n- 被调用者: []"
    },
    {
        "id": 143,
        "cwe": "CWE-119",
        "cve": "CVE-2012-6712",
        "purpose": "Code purpose:\"\"\"处理无线网络接口中添加或修改站点(STA)的响应，包括状态检查和内存操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理添加站点的响应时，未正确验证sta_id的范围，导致可能访问超出stations数组边界的元素，造成内存损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: iwl_process_add_sta_resp\n- 参数: [priv, addsta, pkt]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [IWL_ERR, IWL_DEBUG_INFO, iwl_sta_ucode_activate, spin_lock_irqsave, spin_unlock_irqrestore, IWL_DEBUG_ASSOC]\n\n2. 函数名: IWL_ERR\n- 参数: [priv, format_string, ...]\n- 调用者: iwl_process_add_sta_resp\n- 被调用者: []\n\n3. 函数名: IWL_DEBUG_INFO\n- 参数: [priv, format_string, ...]\n- 调用者: iwl_process_add_sta_resp\n- 被调用者: []\n\n4. 函数名: iwl_sta_ucode_activate\n- 参数: [priv, sta_id]\n- 调用者: iwl_process_add_sta_resp\n- 被调用者: []\n\n5. 函数名: spin_lock_irqsave\n- 参数: [lock, flags]\n- 调用者: iwl_process_add_sta_resp\n- 被调用者: []\n\n6. 函数名: spin_unlock_irqrestore\n- 参数: [lock, flags]\n- 调用者: iwl_process_add_sta_resp\n- 被调用者: []\n\n7. 函数名: IWL_DEBUG_ASSOC\n- 参数: [priv, format_string, ...]\n- 调用者: iwl_process_add_sta_resp\n- 被调用者: []"
    },
    {
        "id": 144,
        "cwe": "CWE-119",
        "cve": "CVE-2012-6712",
        "purpose": "Code purpose:\"\"\"该代码用于激活无线网络驱动中指定站点的Ucode状态，并检查站点是否已激活或存在于驱动程序中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未对sta_id参数进行边界检查，导致数组越界访问，造成内存损坏\"\"\"",
        "functions": "Functions:\n1. 函数名: iwl_sta_ucode_activate\n- 参数: [struct iwl_priv *priv, u8 sta_id]\n- 调用者: 未显示（上下文不足）\n- 被调用者: [IWL_ERR, IWL_DEBUG_ASSOC]\n\n2. 函数名: IWL_ERR\n- 参数: [struct iwl_priv *priv, const char *fmt, ...]\n- 调用者: iwl_sta_ucode_activate\n- 被调用者: 未显示（假设为内核日志打印函数）\n\n3. 函数名: IWL_DEBUG_ASSOC\n- 参数: [struct iwl_priv *priv, const char *fmt, ...]\n- 调用者: iwl_sta_ucode_activate\n- 被调用者: 未显示（假设为调试日志打印函数）"
    },
    {
        "id": 151,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0231",
        "purpose": "Code purpose:\"\"\"该代码用于在Xen的PCI后端驱动中启用MSI（消息信号中断）功能，并处理相关的中断向量映射和状态返回。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对verbose_request进行限制，攻击者可通过大量触发MSI启用请求导致内核日志被填满，造成拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: xen_pcibk_enable_msi\n- 参数: [struct xen_pcibk_device *pdev, struct pci_dev *dev, struct xen_pci_op *op]\n- 调用者: 未明确显示（由PCI后端驱动调用）\n- 被调用者: [printk, pci_enable_msi, xen_pirq_from_irq, pci_get_drvdata]\n\n2. 函数名: printk\n- 参数: [KERN_DEBUG/KERN_ERR, format string, variables...]\n- 调用者: xen_pcibk_enable_msi\n- 被调用者: []\n\n3. 函数名: pci_enable_msi\n- 参数: [struct pci_dev *dev]\n- 调用者: xen_pcibk_enable_msi\n- 被调用者: []\n\n4. 函数名: xen_pirq_from_irq\n- 参数: [dev->irq]\n- 调用者: xen_pcibk_enable_msi\n- 被调用者: []\n\n5. 函数名: pci_get_drvdata\n- 参数: [struct pci_dev *dev]\n- 调用者: xen_pcibk_enable_msi\n- 被调用者: []"
    },
    {
        "id": 152,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0231",
        "purpose": "Code purpose:\"\"\"该代码用于在Xen的PCI后端驱动中启用MSI-X中断功能，处理来自客户操作系统的MSI-X请求。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对op->value进行有效限制，导致可以触发大量内核日志消息，造成拒绝服务攻击\"\"\"",
        "functions": "Functions:\n1. 函数名: xen_pcibk_enable_msix\n- 参数: [struct xen_pcibk_device *pdev, struct pci_dev *dev, struct xen_pci_op *op]\n- 调用者: 未明确显示（由PCI后端驱动调用）\n- 被调用者: [printk, kmalloc, pci_enable_msix, xen_pirq_from_irq, kfree, pci_get_drvdata]\n\n2. 函数名: printk\n- 参数: [KERN_DEBUG/KERN_WARNING, format string, ...]\n- 调用者: xen_pcibk_enable_msix\n- 被调用者: []\n\n3. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: xen_pcibk_enable_msix\n- 被调用者: []\n\n4. 函数名: pci_enable_msix\n- 参数: [struct pci_dev *dev, struct msix_entry *entries, int nvec]\n- 调用者: xen_pcibk_enable_msix\n- 被调用者: []\n\n5. 函数名: xen_pirq_from_irq\n- 参数: [int irq]\n- 调用者: xen_pcibk_enable_msix\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: xen_pcibk_enable_msix\n- 被调用者: []\n\n7. 函数名: pci_get_drvdata\n- 参数: [struct pci_dev *pdev]\n- 调用者: xen_pcibk_enable_msix\n- 被调用者: []"
    },
    {
        "id": 155,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0309",
        "purpose": "Code purpose:\"\"\"检查页中间目录(PMD)条目是否标记为存在(_PAGE_PRESENT)\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当使用透明大页时，内核未能正确处理PROT_NONE内存区域的pmd_present检查，导致本地用户可通过特制应用造成系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: pmd_present\n- 参数: [pmd_t pmd]\n- 调用者: 未明确（需结合完整代码上下文）\n- 被调用者: [pmd_flags]\n\n2. 函数名: pmd_flags\n- 参数: [pmd_t pmd]\n- 调用者: [pmd_present]\n- 被调用者: 未明确（需结合完整代码上下文）"
    },
    {
        "id": 156,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0309",
        "purpose": "Code purpose:\"\"\"检查页中间目录(PMD)条目是否标记为大页且存在\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核在处理使用透明大页(PROT_NONE)的内存区域时，未能正确验证页表项标志位(_PAGE_PSE和_PAGE_PRESENT)的组合情况，导致本地用户可通过特制应用触发系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: pmd_large\n- 参数: [pmd_t pte]\n- 调用者: 未提供（上下文不足）\n- 被调用者: [pmd_flags]\n\n2. 函数名: pmd_flags\n- 参数: [pmd_t pte]\n- 调用者: [pmd_large]\n- 被调用者: 未提供（上下文不足）"
    },
    {
        "id": 157,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0310",
        "purpose": "Code purpose:\"\"\"验证CIPSO IPv4选项的有效性，包括长度检查、标签验证和内容校验，以防止无效或恶意输入导致系统问题\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在cipso_v4_validate函数中，当处理IPOPT_CIPSO选项时，未充分验证skb->dev指针是否为空，导致本地用户可通过特制的setsockopt调用触发空指针解引用，造成系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: cipso_v4_validate\n- 参数: [const struct sk_buff *skb, unsigned char **option]\n- 调用者: 未明确显示（由系统调用触发）\n- 被调用者: [cipso_v4_doi_search, get_unaligned_be32, cipso_v4_map_lvl_valid, cipso_v4_map_cat_rbm_valid, cipso_v4_map_cat_enum_valid, cipso_v4_map_cat_rng_valid]\n\n2. 函数名: cipso_v4_doi_search\n- 参数: [u32 doi]\n- 调用者: cipso_v4_validate\n- 被调用者: []\n\n3. 函数名: get_unaligned_be32\n- 参数: [const void *p]\n- 调用者: cipso_v4_validate\n- 被调用者: []\n\n4. 函数名: cipso_v4_map_lvl_valid\n- 参数: [struct cipso_v4_doi *doi_def, unsigned char level]\n- 调用者: cipso_v4_validate\n- 被调用者: []\n\n5. 函数名: cipso_v4_map_cat_rbm_valid\n- 参数: [struct cipso_v4_doi *doi_def, unsigned char *catmap, u32 catmap_len]\n- 调用者: cipso_v4_validate\n- 被调用者: []\n\n6. 函数名: cipso_v4_map_cat_enum_valid\n- 参数: [struct cipso_v4_doi *doi_def, unsigned char *catmap, u32 catmap_len]\n- 调用者: cipso_v4_validate\n- 被调用者: []\n\n7. 函数名: cipso_v4_map_cat_rng_valid\n- 参数: [struct cipso_v4_doi *doi_def, unsigned char *catmap, u32 catmap_len]\n- 调用者: cipso_v4_validate\n- 被调用者: []"
    },
    {
        "id": 170,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1772",
        "purpose": "Code purpose:\"\"\"将用户空间提供的多个iovec数据合并为一个字符串并通过printk输出到内核日志\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核日志处理函数未正确移除syslog头部的前缀字符串，导致本地用户可通过写入/dev/kmsg触发缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: kmsg_writev\n- 参数: [struct kiocb *iocb, const struct iovec *iv, unsigned long count, loff_t pos]\n- 调用者: 系统调用（未明确显示）\n- 被调用者: [iov_length, kmalloc, copy_from_user, printk, kfree]\n\n2. 函数名: iov_length\n- 参数: [const struct iovec *iv, unsigned long count]\n- 调用者: kmsg_writev\n- 被调用者: []\n\n3. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: kmsg_writev\n- 被调用者: []\n\n4. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: kmsg_writev\n- 被调用者: []\n\n5. 函数名: printk\n- 参数: [const char *fmt, ...]\n- 调用者: kmsg_writev\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: kmsg_writev\n- 被调用者: []"
    },
    {
        "id": 171,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1772",
        "purpose": "Code purpose:\"\"\"该代码用于解锁控制台并处理内核日志缓冲区中的消息，包括将消息传递给控制台驱动程序和唤醒日志守护进程。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"log_prefix函数未能正确移除syslog头部的前缀字符串，导致本地用户可通过写入/dev/kmsg触发call_console_drivers函数调用，造成缓冲区溢出和系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: console_unlock\n- 参数: []\n- 调用者: N/A\n- 被调用者: [up, raw_spin_lock_irqsave, raw_spin_unlock, stop_critical_timings, call_console_drivers, start_critical_timings, local_irq_restore, raw_spin_unlock_irqrestore, console_trylock, wake_up_klogd]\n\n2. 函数名: up\n- 参数: [console_sem]\n- 调用者: console_unlock\n- 被调用者: []\n\n3. 函数名: raw_spin_lock_irqsave\n- 参数: [logbuf_lock, flags]\n- 调用者: console_unlock\n- 被调用者: []\n\n4. 函数名: raw_spin_unlock\n- 参数: [logbuf_lock]\n- 调用者: console_unlock\n- 被调用者: []\n\n5. 函数名: stop_critical_timings\n- 参数: []\n- 调用者: console_unlock\n- 被调用者: []\n\n6. 函数名: call_console_drivers\n- 参数: [_con_start, _log_end]\n- 调用者: console_unlock\n- 被调用者: []\n\n7. 函数名: start_critical_timings\n- 参数: []\n- 调用者: console_unlock\n- 被调用者: []\n\n8. 函数名: local_irq_restore\n- 参数: [flags]\n- 调用者: console_unlock\n- 被调用者: []\n\n9. 函数名: raw_spin_unlock_irqrestore\n- 参数: [logbuf_lock, flags]\n- 调用者: console_unlock\n- 被调用者: []\n\n10. 函数名: console_trylock\n- 参数: []\n- 调用者: console_unlock\n- 被调用者: []\n\n11. 函数名: wake_up_klogd\n- 参数: []\n- 调用者: console_unlock\n- 被调用者: []"
    },
    {
        "id": 172,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1772",
        "purpose": "Code purpose:\"\"\"初始化内核日志缓冲区并处理日志数据的迁移和缓冲区大小调整\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核日志缓冲区处理函数未正确移除syslog头部的prefix字符串，导致本地用户可通过写入/dev/kmsg触发缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: setup_log_buf\n- 参数: [early]\n- 调用者: 未显示\n- 被调用者: [memblock_alloc, __va, alloc_bootmem_nopanic, raw_spin_lock_irqsave, raw_spin_unlock_irqrestore, pr_err, pr_info]\n\n2. 函数名: memblock_alloc\n- 参数: [new_log_buf_len, PAGE_SIZE]\n- 调用者: setup_log_buf\n- 被调用者: 未显示\n\n3. 函数名: __va\n- 参数: [mem]\n- 调用者: setup_log_buf\n- 被调用者: 未显示\n\n4. 函数名: alloc_bootmem_nopanic\n- 参数: [new_log_buf_len]\n- 调用者: setup_log_buf\n- 被调用者: 未显示\n\n5. 函数名: raw_spin_lock_irqsave\n- 参数: [&logbuf_lock, flags]\n- 调用者: setup_log_buf\n- 被调用者: 未显示\n\n6. 函数名: raw_spin_unlock_irqrestore\n- 参数: [&logbuf_lock, flags]\n- 调用者: setup_log_buf\n- 被调用者: 未显示\n\n7. 函数名: pr_err\n- 参数: [\"log_buf_len: %ld bytes not available\\n\", new_log_buf_len]\n- 调用者: setup_log_buf\n- 被调用者: 未显示\n\n8. 函数名: pr_info\n- 参数: [\"log_buf_len: %d\\n\", log_buf_len]\n- 调用者: setup_log_buf\n- 被调用者: 未显示\n\n9. 函数名: pr_info\n- 参数: [\"early log buf free: %d(%d%%)\\n\", free, (free * 100) / __LOG_BUF_LEN]\n- 调用者: setup_log_buf\n- 被调用者: 未显示"
    },
    {
        "id": 173,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1772",
        "purpose": "Code purpose:\"\"\"该代码用于设置syslog数据的指针数组，指向内核日志缓冲区的不同位置。\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未正确处理syslog头部的prefix字符串导致缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: kdb_syslog_data\n- 参数: [syslog_data]\n- 调用者: 未明确（可能是内核其他模块）\n- 被调用者: []"
    },
    {
        "id": 174,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1772",
        "purpose": "Code purpose:\"\"\"为内核崩溃转储设置日志缓冲区的相关符号信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核3.x版本中log_prefix函数未能正确移除syslog头部的前缀字符串，导致本地用户可通过写入/dev/kmsg触发缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: log_buf_kexec_setup\n- 参数: []\n- 调用者: N/A\n- 被调用者: [VMCOREINFO_SYMBOL]\n\n2. 函数名: VMCOREINFO_SYMBOL\n- 参数: [log_buf, log_end, log_buf_len, logged_chars]\n- 调用者: log_buf_kexec_setup\n- 被调用者: []"
    },
    {
        "id": 175,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1772",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中的printk功能，用于处理内核消息的格式化输出和日志记录，包括日志级别处理、前缀解析和缓冲区管理等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"log_prefix函数未能正确移除syslog头中的前缀字符串，导致本地用户可通过写入/dev/kmsg触发缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: vprintk\n- 参数: [const char *fmt, va_list args]\n- 调用者: N/A (kernel function)\n- 被调用者: [boot_delay_msec, printk_delay, local_irq_save, smp_processor_id, zap_locks, lockdep_off, raw_spin_lock, strcpy, strlen, vscnprintf, log_prefix, emit_log_char, cpu_clock, do_div, sprintf, console_trylock_for_printk, console_unlock, lockdep_on, local_irq_restore]\n\n2. 函数名: boot_delay_msec\n- 参数: []\n- 调用者: vprintk\n- 被调用者: []\n\n3. 函数名: printk_delay\n- 参数: []\n- 调用者: vprintk\n- 被调用者: []\n\n4. 函数名: local_irq_save\n- 参数: [unsigned long flags]\n- 调用者: vprintk\n- 被调用者: []\n\n5. 函数名: smp_processor_id\n- 参数: []\n- 调用者: vprintk\n- 被调用者: []\n\n6. 函数名: zap_locks\n- 参数: []\n- 调用者: vprintk\n- 被调用者: []\n\n7. 函数名: lockdep_off\n- 参数: []\n- 调用者: vprintk\n- 被调用者: []\n\n8. 函数名: raw_spin_lock\n- 参数: [&logbuf_lock]\n- 调用者: vprintk\n- 被调用者: []\n\n9. 函数名: strcpy\n- 参数: [printk_buf, recursion_bug_msg]\n- 调用者: vprintk\n- 被调用者: []\n\n10. 函数名: strlen\n- 参数: [recursion_bug_msg]\n- 调用者: vprintk\n- 被调用者: []\n\n11. 函数名: vscnprintf\n- 参数: [printk_buf + printed_len, sizeof(printk_buf) - printed_len, fmt, args]\n- 调用者: vprintk\n- 被调用者: []\n\n12. 函数名: log_prefix\n- 参数: [p, &current_log_level, &special]\n- 调用者: vprintk\n- 被调用者: []\n\n13. 函数名: emit_log_char\n- 参数: [char]\n- 调用者: vprintk\n- 被调用者: []\n\n14. 函数名: cpu_clock\n- 参数: [printk_cpu]\n- 调用者: vprintk\n- 被调用者: []\n\n15. 函数名: do_div\n- 参数: [t, 1000000000]\n- 调用者: vprintk\n- 被调用者: []\n\n16. 函数名: sprintf\n- 参数: [tbuf, \"[%5lu.%06lu] \", (unsigned long) t, nanosec_rem / 1000]\n- 调用者: vprintk\n- 被调用者: []\n\n17. 函数名: console_trylock_for_printk\n- 参数: [this_cpu]\n- 调用者: vprintk\n- 被调用者: []\n\n18. 函数名: console_unlock\n- 参数: []\n- 调用者: vprintk\n- 被调用者: []\n\n19. 函数名: lockdep_on\n- 参数: []\n- 调用者: vprintk\n- 被调用者: []\n\n20. 函数名: local_irq_restore\n- 参数: [flags]\n- 调用者: vprintk\n- 被调用者: []"
    },
    {
        "id": 176,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1772",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中系统日志(syslog)的各种操作功能，包括读取、清除日志、控制台日志级别设置等系统调用处理。\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核3.x版本中log_prefix函数未能正确移除syslog头部的前缀字符串，导致本地用户可通过写入/dev/kmsg触发缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: do_syslog\n- 参数: [int type, char __user *buf, int len, bool from_file]\n- 调用者: 未显示（系统调用）\n- 被调用者: [check_syslog_permissions, security_syslog, access_ok, wait_event_interruptible, __put_user, cond_resched, __get_user]\n\n2. 函数名: check_syslog_permissions\n- 参数: [int type, bool from_file]\n- 调用者: do_syslog\n- 被调用者: 未显示\n\n3. 函数名: security_syslog\n- 参数: [int type]\n- 调用者: do_syslog\n- 被调用者: 未显示\n\n4. 函数名: access_ok\n- 参数: [VERIFY_WRITE, buf, len]\n- 调用者: do_syslog\n- 被调用者: 未显示\n\n5. 函数名: wait_event_interruptible\n- 参数: [log_wait, (log_start - log_end)]\n- 调用者: do_syslog\n- 被调用者: 未显示\n\n6. 函数名: __put_user\n- 参数: [c, buf] 或 [c, &buf[count-1-i]] 或 [c, &buf[i]]\n- 调用者: do_syslog\n- 被调用者: 未显示\n\n7. 函数名: cond_resched\n- 参数: []\n- 调用者: do_syslog\n- 被调用者: 未显示\n\n8. 函数名: __get_user\n- 参数: [c, &buf[i+offset]]\n- 调用者: do_syslog\n- 被调用者: 未显示"
    },
    {
        "id": 177,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1772",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中的printk函数，用于内核日志记录，支持可变参数处理并通过不同路径输出日志信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核printk函数在处理syslog头部前缀字符串时未正确移除前缀，导致本地用户可通过写入/dev/kmsg触发缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: printk\n- 参数: [const char *fmt, ...]\n- 调用者: N/A (kernel-level function)\n- 被调用者: [vkdb_printf, vprintk]\n\n2. 函数名: vkdb_printf\n- 参数: [const char *fmt, va_list args]\n- 调用者: printk\n- 被调用者: N/A\n\n3. 函数名: vprintk\n- 参数: [const char *fmt, va_list args]\n- 调用者: printk\n- 被调用者: N/A\n\n4. 函数名: va_start\n- 参数: [va_list ap, last_arg]\n- 调用者: printk\n- 被调用者: N/A\n\n5. 函数名: va_end\n- 参数: [va_list ap]\n- 调用者: printk\n- 被调用者: N/A\n\n6. 函数名: unlikely\n- 参数: [bool condition]\n- 调用者: printk\n- 被调用者: N/A"
    },
    {
        "id": 178,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1772",
        "purpose": "Code purpose:\"\"\"该代码用于在内核发生特定事件(如OOPS)时转储内核日志缓冲区内容，以便调试或记录系统状态。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核日志处理函数未正确移除syslog头部的前缀字符串，导致本地用户可通过写入/dev/kmsg触发缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: kmsg_dump\n- 参数: [reason]\n- 调用者: 未显示（由系统调用）\n- 被调用者: [raw_spin_lock_irqsave, raw_spin_unlock_irqrestore, rcu_read_lock, list_for_each_entry_rcu, rcu_read_unlock, dumper->dump]\n\n2. 函数名: raw_spin_lock_irqsave\n- 参数: [&logbuf_lock, flags]\n- 调用者: kmsg_dump\n- 被调用者: []\n\n3. 函数名: raw_spin_unlock_irqrestore\n- 参数: [&logbuf_lock, flags]\n- 调用者: kmsg_dump\n- 被调用者: []\n\n4. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: kmsg_dump\n- 被调用者: []\n\n5. 函数名: list_for_each_entry_rcu\n- 参数: [dumper, &dump_list, list]\n- 调用者: kmsg_dump\n- 被调用者: [dumper->dump]\n\n6. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: kmsg_dump\n- 被调用者: []\n\n7. 函数名: dumper->dump\n- 参数: [dumper, reason, s1, l1, s2, l2]\n- 调用者: list_for_each_entry_rcu\n- 被调用者: []"
    },
    {
        "id": 179,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1772",
        "purpose": "Code purpose:\"\"\"注册新的控制台设备并管理控制台驱动程序的启用、禁用和切换，包括处理引导控制台和常规控制台之间的关系\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核的log_prefix函数未能正确从syslog头部移除前缀字符串，导致本地用户可通过/dev/kmsg写入访问触发缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: register_console\n- 参数: [struct console *newcon]\n- 调用者: 无（顶级函数）\n- 被调用者: [printk, for_each_console, newcon->early_setup, newcon->setup, strcmp, braille_register_console, console_lock, raw_spin_lock_irqsave, raw_spin_unlock_irqrestore, console_unlock, console_sysfs_notify, unregister_console]\n\n2. 函数名: printk\n- 参数: [const char *fmt, ...]\n- 调用者: register_console\n- 被调用者: 无（假设为标准库函数）\n\n3. 函数名: for_each_console\n- 参数: [struct console *con]\n- 调用者: register_console\n- 被调用者: 无（宏定义）\n\n4. 函数名: early_setup\n- 参数: 无\n- 调用者: register_console\n- 被调用者: 无（函数指针）\n\n5. 函数名: setup\n- 参数: [struct console *con, char *options]\n- 调用者: register_console\n- 被调用者: 无（函数指针）\n\n6. 函数名: strcmp\n- 参数: [const char *s1, const char *s2]\n- 调用者: register_console\n- 被调用者: 无（标准库函数）\n\n7. 函数名: braille_register_console\n- 参数: [struct console *con, int index, char *options, char *brl_options]\n- 调用者: register_console\n- 被调用者: 无\n\n8. 函数名: console_lock\n- 参数: 无\n- 调用者: register_console\n- 被调用者: 无\n\n9. 函数名: raw_spin_lock_irqsave\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: register_console\n- 被调用者: 无\n\n10. 函数名: raw_spin_unlock_irqrestore\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: register_console\n- 被调用者: 无\n\n11. 函数名: console_unlock\n- 参数: 无\n- 调用者: register_console\n- 被调用者: 无\n\n12. 函数名: console_sysfs_notify\n- 参数: 无\n- 调用者: register_console\n- 被调用者: 无\n\n13. 函数名: unregister_console\n- 参数: [struct console *con]\n- 调用者: register_console\n- 被调用者: 无"
    },
    {
        "id": 180,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1772",
        "purpose": "Code purpose:\"\"\"该代码片段用于在打印内核日志时尝试获取控制台锁，并在无法使用控制台时安全释放锁以防止缓冲区溢出。\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核的log_prefix函数未能正确移除syslog头中的前缀字符串，导致本地用户可通过写入/dev/kmsg触发缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: console_trylock_for_printk\n- 参数: [unsigned int cpu]\n- 调用者: 未显示（上下文不足）\n- 被调用者: [console_trylock, can_use_console, up, raw_spin_unlock]\n\n2. 函数名: console_trylock\n- 参数: []\n- 调用者: console_trylock_for_printk\n- 被调用者: 未显示（上下文不足）\n\n3. 函数名: can_use_console\n- 参数: [unsigned int cpu]\n- 调用者: console_trylock_for_printk\n- 被调用者: 未显示（上下文不足）\n\n4. 函数名: up\n- 参数: [&console_sem]\n- 调用者: console_trylock_for_printk\n- 被调用者: 未显示（上下文不足）\n\n5. 函数名: raw_spin_unlock\n- 参数: [&logbuf_lock]\n- 调用者: console_trylock_for_printk\n- 被调用者: 未显示（上下文不足）"
    },
    {
        "id": 181,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1773",
        "purpose": "Code purpose:\"\"\"该代码用于处理主机与虚拟机之间的键值对(KVP)通信，包括错误处理和UTF-8到UTF-16的字符串编码转换。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在UTF-8到UTF-16的转换过程中，未对输入数据进行有效边界检查，导致缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: kvp_respond_to_host\n- 参数: [char *key, char *value, int error]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [utf8s_to_utf16s, strlen, pr_warn, vmbus_sendpacket]\n\n2. 函数名: utf8s_to_utf16s\n- 参数: [char *key_name, int strlen(key_name), wchar_t *kvp_data->data.key]\n- 调用者: kvp_respond_to_host\n- 被调用者: 未显示（可能是内核函数）\n\n3. 函数名: strlen\n- 参数: [char *key_name]\n- 调用者: kvp_respond_to_host\n- 被调用者: 未显示（标准库函数）\n\n4. 函数名: pr_warn\n- 参数: [const char *fmt]\n- 调用者: kvp_respond_to_host\n- 被调用者: 未显示（内核打印函数）\n\n5. 函数名: vmbus_sendpacket\n- 参数: [struct vmbus_channel *channel, char *recv_buffer, u32 buf_len, u64 req_id, int VM_PKT_DATA_INBAND, int 0]\n- 调用者: kvp_respond_to_host\n- 被调用者: 未显示（可能是Hyper-V通信函数）"
    },
    {
        "id": 182,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1773",
        "purpose": "Code purpose:\"\"\"将文件名从UTF-8或本地字符集转换为UTF-16编码格式，并处理VFAT文件系统中的长文件名限制\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核VFAT文件系统实现中，在启用utf8挂载选项时，未正确处理UTF-8到UTF-16转换过程中的缓冲区边界检查，导致缓冲区溢出漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: xlate_to_uni\n- 参数: [const unsigned char *name, int len, unsigned char *outname, int *longlen, int *outlen, int escape, int utf8, struct nls_table *nls]\n- 调用者: 未显示（由VFAT文件系统实现调用）\n- 被调用者: [utf8s_to_utf16s, nls->char2uni]\n\n2. 函数名: utf8s_to_utf16s\n- 参数: [const unsigned char *name, int len, wchar_t *outname]\n- 调用者: xlate_to_uni\n- 被调用者: 未显示\n\n3. 函数名: char2uni\n- 参数: [const unsigned char *ip, int len, wchar_t *op]\n- 调用者: xlate_to_uni\n- 被调用者: 未显示"
    },
    {
        "id": 201,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1860",
        "purpose": "Code purpose:\"\"\"该代码实现了USB CDC-WDM设备驱动中的读取功能，处理来自用户空间的数据读取请求，并管理设备状态和缓冲区。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"wdm_read函数在处理USB设备数据时未充分验证用户空间缓冲区大小，导致堆缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: wdm_read\n- 参数: [struct file *file, char __user *buffer, size_t count, loff_t *ppos]\n- 调用者: 未显示（由文件操作结构调用）\n- 被调用者: [mutex_lock_interruptible, ACCESS_ONCE, test_bit, wait_event_interruptible, usb_mark_last_busy, spin_lock_irq, spin_unlock_irq, copy_to_user, mutex_unlock]\n\n2. 函数名: mutex_lock_interruptible\n- 参数: [&desc->rlock]\n- 调用者: wdm_read\n- 被调用者: 未显示（内核函数）\n\n3. 函数名: ACCESS_ONCE\n- 参数: [desc->length]\n- 调用者: wdm_read\n- 被调用者: 未显示（内核宏）\n\n4. 函数名: test_bit\n- 参数: [WDM_DISCONNECTING, &desc->flags], [WDM_READ, &desc->flags], [WDM_RESETTING, &desc->flags]\n- 调用者: wdm_read\n- 被调用者: 未显示（内核函数）\n\n5. 函数名: wait_event_interruptible\n- 参数: [desc->wait, test_bit(WDM_READ, &desc->flags)]\n- 调用者: wdm_read\n- 被调用者: 未显示（内核函数）\n\n6. 函数名: usb_mark_last_busy\n- 参数: [interface_to_usbdev(desc->intf)]\n- 调用者: wdm_read\n- 被调用者: 未显示（内核函数）\n\n7. 函数名: spin_lock_irq\n- 参数: [&desc->iuspin]\n- 调用者: wdm_read\n- 被调用者: 未显示（内核函数）\n\n8. 函数名: spin_unlock_irq\n- 参数: [&desc->iuspin]\n- 调用者: wdm_read\n- 被调用者: 未显示（内核函数）\n\n9. 函数名: copy_to_user\n- 参数: [buffer, desc->ubuf, cntr]\n- 调用者: wdm_read\n- 被调用者: 未显示（内核函数）\n\n10. 函数名: mutex_unlock\n- 参数: [&desc->rlock]\n- 调用者: wdm_read\n- 被调用者: 未显示（内核函数）"
    },
    {
        "id": 202,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1860",
        "purpose": "Code purpose:\"\"\"处理USB接口重置后的恢复操作，包括清除重置标志、恢复URB丢失状态并释放读写锁\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"wdm_post_reset函数在释放锁之前未正确验证描述符状态，可能导致堆缓冲区溢出漏洞，允许通过特制USB设备触发系统崩溃或执行任意代码。\"\"\"",
        "functions": "Functions:\n1. 函数名: wdm_post_reset\n- 参数: [struct usb_interface *intf]\n- 调用者: 未显示\n- 被调用者: [wdm_find_device, clear_bit, recover_from_urb_loss, mutex_unlock]\n\n2. 函数名: wdm_find_device\n- 参数: [struct usb_interface *intf]\n- 调用者: wdm_post_reset\n- 被调用者: 未显示\n\n3. 函数名: clear_bit\n- 参数: [WDM_RESETTING, &desc->flags]\n- 调用者: wdm_post_reset\n- 被调用者: 未显示\n\n4. 函数名: recover_from_urb_loss\n- 参数: [struct wdm_device *desc]\n- 调用者: wdm_post_reset\n- 被调用者: 未显示\n\n5. 函数名: mutex_unlock\n- 参数: [&desc->wlock], [&desc->rlock]\n- 调用者: wdm_post_reset\n- 被调用者: 未显示"
    },
    {
        "id": 203,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1860",
        "purpose": "Code purpose:\"\"\"处理USB CDC-WDM设备的URB回调，将接收到的数据移动到缓冲区并更新状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在wdm_in_callback函数中，memmove操作未对desc->length和desc->reslength进行边界检查，导致堆缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: wdm_in_callback\n- 参数: [struct urb *urb]\n- 调用者: 未显示（由USB子系统调用）\n- 被调用者: [dev_dbg, dev_err, memmove, wake_up, clear_bit, set_bit, spin_lock, spin_unlock]\n\n2. 函数名: dev_dbg\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: wdm_in_callback\n- 被调用者: []\n\n3. 函数名: dev_err\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: wdm_in_callback\n- 被调用者: []\n\n4. 函数名: memmove\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: wdm_in_callback\n- 被调用者: []\n\n5. 函数名: wake_up\n- 参数: [wait_queue_head_t *q]\n- 调用者: wdm_in_callback\n- 被调用者: []\n\n6. 函数名: clear_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: wdm_in_callback\n- 被调用者: []\n\n7. 函数名: set_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: wdm_in_callback\n- 被调用者: []\n\n8. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: wdm_in_callback\n- 被调用者: []\n\n9. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: wdm_in_callback\n- 被调用者: []"
    },
    {
        "id": 205,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1929",
        "purpose": "Code purpose:\"\"\"读取和处理PCI设备的VPD(Vital Product Data)信息，包括制造商ID、版本号和部件号等，并将其存储到驱动程序数据结构中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理VPD数据时未充分验证输入长度，导致堆缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: tg3_read_vpd\n- 参数: [struct tg3 *tp]\n- 调用者: 未显示\n- 被调用者: [tg3_vpd_readblock, pci_vpd_find_tag, pci_vpd_lrdt_size, pci_vpd_find_info_keyword, pci_vpd_info_field_size, memcmp, memcpy, strncat, kfree, tg3_asic_rev, strcpy]\n\n2. 函数名: tg3_vpd_readblock\n- 参数: [struct tg3 *tp, u32 *vpdlen]\n- 调用者: tg3_read_vpd\n- 被调用者: 未显示\n\n3. 函数名: pci_vpd_find_tag\n- 参数: [u8 *vpd_data, int offset, int len, int tag]\n- 调用者: tg3_read_vpd\n- 被调用者: 未显示\n\n4. 函数名: pci_vpd_lrdt_size\n- 参数: [u8 *lrdt]\n- 调用者: tg3_read_vpd\n- 被调用者: 未显示\n\n5. 函数名: pci_vpd_find_info_keyword\n- 参数: [u8 *vpd_data, int offset, int len, int keyword]\n- 调用者: tg3_read_vpd\n- 被调用者: 未显示\n\n6. 函数名: pci_vpd_info_field_size\n- 参数: [u8 *info_field]\n- 调用者: tg3_read_vpd\n- 被调用者: 未显示\n\n7. 函数名: memcmp\n- 参数: [const void *s1, const void *s2, size_t n]\n- 调用者: tg3_read_vpd\n- 被调用者: 未显示\n\n8. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: tg3_read_vpd\n- 被调用者: 未显示\n\n9. 函数名: strncat\n- 参数: [char *dest, const char *src, size_t n]\n- 调用者: tg3_read_vpd\n- 被调用者: 未显示\n\n10. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: tg3_read_vpd\n- 被调用者: 未显示\n\n11. 函数名: tg3_asic_rev\n- 参数: [struct tg3 *tp]\n- 调用者: tg3_read_vpd\n- 被调用者: 未显示\n\n12. 函数名: strcpy\n- 参数: [char *dest, const char *src]\n- 调用者: tg3_read_vpd\n- 被调用者: 未显示"
    },
    {
        "id": 224,
        "cwe": "CWE-119",
        "cve": "CVE-2013-2234",
        "purpose": "Code purpose:\"\"\"该代码用于在IPSec密钥套接字中创建并广播一个SADB_FLUSH类型的消息，通知安全关联(SA)的刷新操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未初始化结构体成员导致内核堆内存敏感信息泄露\"\"\"",
        "functions": "Functions:\n1. 函数名: key_notify_sa_flush\n- 参数: [const struct km_event *c]\n- 调用者: 未指定（由内核其他部分调用）\n- 被调用者: [alloc_skb, skb_put, pfkey_proto2satype, pfkey_broadcast]\n\n2. 函数名: alloc_skb\n- 参数: [sizeof(struct sadb_msg) + 16, GFP_ATOMIC]\n- 调用者: key_notify_sa_flush\n- 被调用者: []\n\n3. 函数名: skb_put\n- 参数: [skb, sizeof(struct sadb_msg)]\n- 调用者: key_notify_sa_flush\n- 被调用者: []\n\n4. 函数名: pfkey_proto2satype\n- 参数: [c->data.proto]\n- 调用者: key_notify_sa_flush\n- 被调用者: []\n\n5. 函数名: pfkey_broadcast\n- 参数: [skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net]\n- 调用者: key_notify_sa_flush\n- 被调用者: []"
    },
    {
        "id": 225,
        "cwe": "CWE-119",
        "cve": "CVE-2013-2234",
        "purpose": "Code purpose:\"\"\"该代码用于在IPSec密钥套接字中初始化并广播策略刷新通知消息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未初始化结构体成员导致内核堆内存敏感信息泄露\"\"\"",
        "functions": "Functions:\n1. 函数名: key_notify_policy_flush\n- 参数: [const struct km_event *c]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [alloc_skb, skb_put, pfkey_broadcast]\n\n2. 函数名: alloc_skb\n- 参数: [sizeof(struct sadb_msg) + 16, GFP_ATOMIC]\n- 调用者: key_notify_policy_flush\n- 被调用者: []\n\n3. 函数名: skb_put\n- 参数: [skb_out, sizeof(struct sadb_msg)]\n- 调用者: key_notify_policy_flush\n- 被调用者: []\n\n4. 函数名: pfkey_broadcast\n- 参数: [skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net]\n- 调用者: key_notify_policy_flush\n- 被调用者: []"
    },
    {
        "id": 238,
        "cwe": "CWE-119",
        "cve": "CVE-2013-2850",
        "purpose": "Code purpose:\"\"\"该代码用于解码iSCSI协议中的文本输入参数，处理安全阶段检查、参数验证及响应生成，并将结果存储在连接参数列表中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理长密钥时未正确验证输入长度，导致堆缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: iscsi_decode_text_input\n- 参数: [u8 phase, u8 sender, char *textbuf, u32 length, struct iscsi_conn *conn]\n- 调用者: N/A\n- 被调用者: [kzalloc, memcpy, iscsi_extract_key_value, pr_debug, iscsi_check_for_auth_key, strlen, iscsi_check_key, iscsi_add_notunderstood_response, iscsi_check_value, iscsi_check_proposer_state, iscsi_check_acceptor_state, kfree]\n\n2. 函数名: iscsi_extract_key_value\n- 参数: [char *start, char **key, char **value]\n- 调用者: iscsi_decode_text_input\n- 被调用者: N/A\n\n3. 函数名: iscsi_check_for_auth_key\n- 参数: [char *key]\n- 调用者: iscsi_decode_text_input\n- 被调用者: N/A\n\n4. 函数名: iscsi_check_key\n- 参数: [char *key, u8 phase, u8 sender, struct iscsi_param_list *param_list]\n- 调用者: iscsi_decode_text_input\n- 被调用者: N/A\n\n5. 函数名: iscsi_add_notunderstood_response\n- 参数: [char *key, char *value, struct iscsi_param_list *param_list]\n- 调用者: iscsi_decode_text_input\n- 被调用者: N/A\n\n6. 函数名: iscsi_check_value\n- 参数: [struct iscsi_param *param, char *value]\n- 调用者: iscsi_decode_text_input\n- 被调用者: N/A\n\n7. 函数名: iscsi_check_proposer_state\n- 参数: [struct iscsi_param *param, char *value]\n- 调用者: iscsi_decode_text_input\n- 被调用者: N/A\n\n8. 函数名: iscsi_check_acceptor_state\n- 参数: [struct iscsi_param *param, char *value, struct iscsi_conn *conn]\n- 调用者: iscsi_decode_text_input\n- 被调用者: N/A"
    },
    {
        "id": 239,
        "cwe": "CWE-119",
        "cve": "CVE-2013-2850",
        "purpose": "Code purpose:\"\"\"该代码用于在iSCSI协议中为无法识别的键值对添加错误响应，包括内存分配和字符串复制操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理长键名时未正确检查键名长度，导致堆缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: iscsi_add_notunderstood_response\n- 参数: [key, value, param_list]\n- 调用者: 未指定（由外部调用）\n- 被调用者: [strlen, pr_err, kzalloc, INIT_LIST_HEAD, strncpy, list_add_tail]\n\n2. 函数名: strlen\n- 参数: [str]\n- 调用者: iscsi_add_notunderstood_response\n- 被调用者: []\n\n3. 函数名: pr_err\n- 参数: [format, ...]\n- 调用者: iscsi_add_notunderstood_response\n- 被调用者: []\n\n4. 函数名: kzalloc\n- 参数: [size, flags]\n- 调用者: iscsi_add_notunderstood_response\n- 被调用者: []\n\n5. 函数名: INIT_LIST_HEAD\n- 参数: [list]\n- 调用者: iscsi_add_notunderstood_response\n- 被调用者: []\n\n6. 函数名: strncpy\n- 参数: [dest, src, count]\n- 调用者: iscsi_add_notunderstood_response\n- 被调用者: []\n\n7. 函数名: list_add_tail\n- 参数: [new, head]\n- 调用者: iscsi_add_notunderstood_response\n- 被调用者: []"
    },
    {
        "id": 247,
        "cwe": "CWE-119",
        "cve": "CVE-2013-2890",
        "purpose": "Code purpose:\"\"\"该代码用于初始化Buzz控制器的LED设备，包括分配内存、设置LED属性并注册LED设备，同时处理可能的错误情况。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证设备名称长度，导致在分配和格式化LED名称时可能发生堆溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: buzz_init\n- 参数: [struct hid_device *hdev]\n- 调用者: 未显示（由HID子系统调用）\n- 被调用者: [hid_get_drvdata, kzalloc, hid_err, buzz_set_leds, strlen, dev_name, snprintf, led_classdev_register, led_classdev_unregister, kfree]\n\n2. 函数名: hid_get_drvdata\n- 参数: [struct hid_device *hdev]\n- 调用者: buzz_init\n- 被调用者: 未显示\n\n3. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: buzz_init\n- 被调用者: 未显示\n\n4. 函数名: hid_err\n- 参数: [const struct hid_device *hdev, const char *fmt, ...]\n- 调用者: buzz_init\n- 被调用者: 未显示\n\n5. 函数名: buzz_set_leds\n- 参数: [struct hid_device *hdev, int value]\n- 调用者: buzz_init\n- 被调用者: 未显示\n\n6. 函数名: strlen\n- 参数: [const char *s]\n- 调用者: buzz_init\n- 被调用者: 未显示\n\n7. 函数名: dev_name\n- 参数: [const struct device *dev]\n- 调用者: buzz_init\n- 被调用者: 未显示\n\n8. 函数名: snprintf\n- 参数: [char *str, size_t size, const char *format, ...]\n- 调用者: buzz_init\n- 被调用者: 未显示\n\n9. 函数名: led_classdev_register\n- 参数: [struct device *parent, struct led_classdev *led_cdev]\n- 调用者: buzz_init\n- 被调用者: 未显示\n\n10. 函数名: led_classdev_unregister\n- 参数: [struct led_classdev *led_cdev]\n- 调用者: buzz_init\n- 被调用者: 未显示\n\n11. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: buzz_init\n- 被调用者: 未显示\n\n12. 函数名: buzz_led_get_brightness\n- 参数: 未显示（函数指针赋值）\n- 调用者: 未显示（通过led->brightness_get调用）\n- 被调用者: 未显示\n\n13. 函数名: buzz_led_set_brightness\n- 参数: 未显示（函数指针赋值）\n- 调用者: 未显示（通过led->brightness_set调用）\n- 被调用者: 未显示"
    },
    {
        "id": 248,
        "cwe": "CWE-119",
        "cve": "CVE-2013-2891",
        "purpose": "Code purpose:\"\"\"该代码用于实现SteelSeries SRW-S1设备的HID驱动，包括初始化设备、分配内存、注册LED子系统以及处理LED控制功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证设备唯一标识符(hdev->uniq)的长度，导致在分配内存和格式化字符串时可能发生堆溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: steelseries_srws1_probe\n- 参数: [struct hid_device *hdev, const struct hid_device_id *id]\n- 调用者: 内核HID子系统（驱动探测时调用）\n- 被调用者: [kzalloc, hid_err, hid_set_drvdata, hid_parse, hid_hw_start, steelseries_srws1_set_leds, strlen, snprintf, led_classdev_register, led_classdev_unregister, kfree]\n\n2. 函数名: steelseries_srws1_set_leds\n- 参数: [struct hid_device *hdev, int value]\n- 调用者: steelseries_srws1_probe\n- 被调用者: []\n\n3. 函数名: steelseries_srws1_led_all_get_brightness\n- 参数: [未显示完整参数]\n- 调用者: LED子系统（回调）\n- 被调用者: []\n\n4. 函数名: steelseries_srws1_led_all_set_brightness\n- 参数: [未显示完整参数]\n- 调用者: LED子系统（回调）\n- 被调用者: []\n\n5. 函数名: steelseries_srws1_led_get_brightness\n- 参数: [未显示完整参数]\n- 调用者: LED子系统（回调）\n- 被调用者: []\n\n6. 函数名: steelseries_srws1_led_set_brightness\n- 参数: [未显示完整参数]\n- 调用者: LED子系统（回调）\n- 被调用者: []"
    },
    {
        "id": 249,
        "cwe": "CWE-119",
        "cve": "CVE-2013-2893",
        "purpose": "Code purpose:\"\"\"初始化Logitech力反馈设备，设置力反馈参数并通过HID子系统与设备通信。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证输入设备的报告字段数量和大小，导致攻击者可通过特制设备触发堆越界写入漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: lg2ff_init\n- 参数: [struct hid_device *hid]\n- 调用者: 未明确（由HID子系统调用）\n- 被调用者: [list_entry, hid_err, kmalloc, set_bit, input_ff_create_memless, kfree, hid_hw_request, hid_info]\n\n2. 函数名: list_entry\n- 参数: [未明确（宏定义参数）]\n- 调用者: lg2ff_init\n- 被调用者: []\n\n3. 函数名: hid_err\n- 参数: [struct hid_device *hid, const char *fmt, ...]\n- 调用者: lg2ff_init\n- 被调用者: []\n\n4. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: lg2ff_init\n- 被调用者: []\n\n5. 函数名: set_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: lg2ff_init\n- 被调用者: []\n\n6. 函数名: input_ff_create_memless\n- 参数: [struct input_dev *dev, void *data, int (*play_effect)(struct input_dev *, void *, struct ff_effect *)]\n- 调用者: lg2ff_init\n- 被调用者: []\n\n7. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: lg2ff_init\n- 被调用者: []\n\n8. 函数名: hid_hw_request\n- 参数: [struct hid_device *hid, struct hid_report *report, enum hid_class_request reqtype]\n- 调用者: lg2ff_init\n- 被调用者: []\n\n9. 函数名: hid_info\n- 参数: [struct hid_device *hid, const char *fmt, ...]\n- 调用者: lg2ff_init\n- 被调用者: []"
    },
    {
        "id": 250,
        "cwe": "CWE-119",
        "cve": "CVE-2013-2893",
        "purpose": "Code purpose:\"\"\"处理来自Logitech力反馈设备的输入，并将力反馈效果转换为设备特定的输出报告\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证report->field[0]->maxusage的值，导致memset操作可能超出分配的堆内存边界，造成堆溢出漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: hid_lg3ff_play\n- 参数: [struct input_dev *dev, void *data, struct ff_effect *effect]\n- 调用者: 未明确显示（通常由输入子系统调用）\n- 被调用者: [input_get_drvdata, memset, hid_hw_request]\n\n2. 函数名: input_get_drvdata\n- 参数: [struct input_dev *dev]\n- 调用者: hid_lg3ff_play\n- 被调用者: []\n\n3. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: hid_lg3ff_play\n- 被调用者: []\n\n4. 函数名: hid_hw_request\n- 参数: [struct hid_device *hid, struct hid_report *report, enum hid_class_request reqtype]\n- 调用者: hid_lg3ff_play\n- 被调用者: []\n\n5. 函数名: list_entry\n- 参数: [struct list_head *ptr, type, member]\n- 调用者: hid_lg3ff_play\n- 被调用者: []"
    },
    {
        "id": 251,
        "cwe": "CWE-119",
        "cve": "CVE-2013-2893",
        "purpose": "Code purpose:\"\"\"该代码用于初始化Logitech游戏方向盘设备，包括检测设备兼容性、设置力反馈功能、创建sysfs接口以及LED子系统支持，以实现对设备的控制和反馈功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证来自物理设备的输入数据，导致堆基缓冲区溢出漏洞，允许攻击者通过特制设备触发越界写入。\"\"\"",
        "functions": "Functions:\n1. 函数名: lg4ff_init\n- 参数: [struct hid_device *hid]\n- 调用者: 无（驱动初始化函数）\n- 被调用者: [list_entry, hid_err, dbg_hid, hid_lg4ff_switch_native, hid_info, set_bit, input_ff_create_memless, test_bit, hid_get_drvdata, kzalloc, device_create_file, snprintf, lg4ff_set_leds, led_classdev_register, led_classdev_unregister, kfree]\n\n2. 函数名: list_entry\n- 参数: [pointer, type, member]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n3. 函数名: hid_err\n- 参数: [struct hid_device *hid, const char *fmt, ...]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n4. 函数名: dbg_hid\n- 参数: [const char *fmt, ...]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n5. 函数名: hid_lg4ff_switch_native\n- 参数: [struct hid_device *hid, __u8 command]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n6. 函数名: hid_info\n- 参数: [struct hid_device *hid, const char *fmt, ...]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n7. 函数名: set_bit\n- 参数: [int nr, volatile void *addr]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n8. 函数名: input_ff_create_memless\n- 参数: [struct input_dev *dev, void *data, int (*play)(struct input_dev *dev, void *data, struct ff_effect *effect)]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n9. 函数名: test_bit\n- 参数: [int nr, const volatile void *addr]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n10. 函数名: hid_get_drvdata\n- 参数: [struct hid_device *hid]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n11. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n12. 函数名: device_create_file\n- 参数: [struct device *dev, const struct device_attribute *attr]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n13. 函数名: snprintf\n- 参数: [char *str, size_t size, const char *format, ...]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n14. 函数名: lg4ff_set_leds\n- 参数: [struct hid_device *hid, __u8 value]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n15. 函数名: led_classdev_register\n- 参数: [struct device *parent, struct led_classdev *led_cdev]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n16. 函数名: led_classdev_unregister\n- 参数: [struct led_classdev *led_cdev]\n- 调用者: [lg4ff_init]\n- 被调用者: 无\n\n17. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: [lg4ff_init]\n- 被调用者: 无"
    },
    {
        "id": 252,
        "cwe": "CWE-119",
        "cve": "CVE-2013-2894",
        "purpose": "Code purpose:\"\"\"该代码用于探测并初始化联想ThinkPad键盘设备，包括创建sysfs属性组、分配内存存储设备数据、设置LED控制参数等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证设备名称长度，导致分配的内存不足，可能造成堆溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: tpkbd_probe_tp\n- 参数: [struct hid_device *hdev]\n- 调用者: 未显示（通常由HID子系统调用）\n- 被调用者: [dev_name, sysfs_create_group, kzalloc, hid_warn, hid_err, snprintf, hid_set_drvdata, led_classdev_register, tpkbd_features_set, kfree, tpkbd_led_brightness_get, tpkbd_led_brightness_set]\n\n2. 函数名: dev_name\n- 参数: [struct device *dev]\n- 调用者: [tpkbd_probe_tp]\n- 被调用者: []\n\n3. 函数名: sysfs_create_group\n- 参数: [struct kobject *kobj, const struct attribute_group *grp]\n- 调用者: [tpkbd_probe_tp]\n- 被调用者: []\n\n4. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: [tpkbd_probe_tp]\n- 被调用者: []\n\n5. 函数名: hid_warn\n- 参数: [struct hid_device *hdev, const char *fmt, ...]\n- 调用者: [tpkbd_probe_tp]\n- 被调用者: []\n\n6. 函数名: hid_err\n- 参数: [struct hid_device *hdev, const char *fmt, ...]\n- 调用者: [tpkbd_probe_tp]\n- 被调用者: []\n\n7. 函数名: snprintf\n- 参数: [char *str, size_t size, const char *format, ...]\n- 调用者: [tpkbd_probe_tp]\n- 被调用者: []\n\n8. 函数名: hid_set_drvdata\n- 参数: [struct hid_device *hdev, void *data]\n- 调用者: [tpkbd_probe_tp]\n- 被调用者: []\n\n9. 函数名: led_classdev_register\n- 参数: [struct device *parent, struct led_classdev *led_cdev]\n- 调用者: [tpkbd_probe_tp]\n- 被调用者: []\n\n10. 函数名: tpkbd_features_set\n- 参数: [struct hid_device *hdev]\n- 调用者: [tpkbd_probe_tp]\n- 被调用者: []\n\n11. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: [tpkbd_probe_tp]\n- 被调用者: []\n\n12. 函数名: tpkbd_led_brightness_get\n- 参数: [未显示]\n- 调用者: [tpkbd_probe_tp（通过函数指针）]\n- 被调用者: []\n\n13. 函数名: tpkbd_led_brightness_set\n- 参数: [未显示]\n- 调用者: [tpkbd_probe_tp（通过函数指针）]\n- 被调用者: []"
    },
    {
        "id": 253,
        "cwe": "CWE-119",
        "cve": "CVE-2013-2895",
        "purpose": "Code purpose:\"\"\"该代码用于处理Logitech无线接收器设备的探测和初始化，包括分配资源、解析HID描述符、启动硬件设备以及设置设备间的通信。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_HID_LOGITECH_DJ时，内核未正确处理来自恶意设备的异常输入，导致空指针解引用和内核内存信息泄露\"\"\"",
        "functions": "Functions:\n1. 函数名: logi_dj_probe\n- 参数: [struct hid_device *hdev, const struct hid_device_id *id]\n- 调用者: 内核HID子系统\n- 被调用者: [is_dj_device, kzalloc, INIT_WORK, spin_lock_init, kfifo_alloc, hid_set_drvdata, hid_parse, hid_hw_start, logi_dj_recv_switch_to_dj_mode, hid_hw_open, hid_device_io_start, logi_dj_recv_query_paired_devices, hid_hw_close, hid_hw_stop, kfifo_free, kfree]\n\n2. 函数名: is_dj_device\n- 参数: [struct dj_device *]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n3. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n4. 函数名: INIT_WORK\n- 参数: [struct work_struct *work, work_func_t func]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n5. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n6. 函数名: kfifo_alloc\n- 参数: [struct kfifo *fifo, unsigned int size, gfp_t gfp_mask]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n7. 函数名: hid_set_drvdata\n- 参数: [struct hid_device *hdev, void *data]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n8. 函数名: hid_parse\n- 参数: [struct hid_device *hdev]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n9. 函数名: hid_hw_start\n- 参数: [struct hid_device *hdev, unsigned int connect_mask]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n10. 函数名: logi_dj_recv_switch_to_dj_mode\n- 参数: [struct dj_receiver_dev *djrcv_dev, unsigned int timeout]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n11. 函数名: hid_hw_open\n- 参数: [struct hid_device *hdev]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n12. 函数名: hid_device_io_start\n- 参数: [struct hid_device *hdev]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n13. 函数名: logi_dj_recv_query_paired_devices\n- 参数: [struct dj_receiver_dev *djrcv_dev]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n14. 函数名: hid_hw_close\n- 参数: [struct hid_device *hdev]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n15. 函数名: hid_hw_stop\n- 参数: [struct hid_device *hdev]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n16. 函数名: kfifo_free\n- 参数: [struct kfifo *fifo]\n- 调用者: logi_dj_probe\n- 被调用者: []\n\n17. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: logi_dj_probe\n- 被调用者: []"
    },
    {
        "id": 254,
        "cwe": "CWE-119",
        "cve": "CVE-2013-2895",
        "purpose": "Code purpose:\"\"\"该代码用于处理Logitech无线设备的HID报告，将接收到的数据填充到输出报告中并发送给硬件设备。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对report->field[0]进行空指针检查，导致当其为NULL时可能引发空指针解引用，造成拒绝服务或内核信息泄露\"\"\"",
        "functions": "Functions:\n1. 函数名: logi_dj_recv_send_report\n- 参数: [djrcv_dev, dj_report]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [dev_err, hid_hw_request]\n\n2. 函数名: dev_err\n- 参数: [&hdev->dev, \"%s: unable to find dj report\\n\", __func__]\n- 调用者: logi_dj_recv_send_report\n- 被调用者: 未明确（内核函数）\n\n3. 函数名: hid_hw_request\n- 参数: [hdev, report, HID_REQ_SET_REPORT]\n- 调用者: logi_dj_recv_send_report\n- 被调用者: 未明确（内核函数）"
    },
    {
        "id": 259,
        "cwe": "CWE-119",
        "cve": "CVE-2013-2899",
        "purpose": "Code purpose:\"\"\"该代码用于处理PicoLCD设备操作模式的存储请求，根据输入内容切换设备模式并设置相关报告参数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当输入既不匹配'lcd'也不匹配'bootloader'时，report指针保持NULL，后续未检查就直接使用导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: picolcd_operation_mode_store\n- 参数: [struct device *dev, struct device_attribute *attr, const char *buf, size_t count]\n- 调用者: 未显示（由设备属性系统调用）\n- 被调用者: [dev_get_drvdata, strncmp, picolcd_out_report, hid_set_field, hid_hw_request, spin_lock_irqsave, spin_unlock_irqrestore]\n\n2. 函数名: dev_get_drvdata\n- 参数: [struct device *dev]\n- 调用者: picolcd_operation_mode_store\n- 被调用者: 未显示\n\n3. 函数名: strncmp\n- 参数: [const char *s1, const char *s2, size_t n]\n- 调用者: picolcd_operation_mode_store\n- 被调用者: 未显示\n\n4. 函数名: picolcd_out_report\n- 参数: [int report_type, struct hid_device *hdev]\n- 调用者: picolcd_operation_mode_store\n- 被调用者: 未显示\n\n5. 函数名: hid_set_field\n- 参数: [struct hid_field *field, unsigned offset, __s32 value]\n- 调用者: picolcd_operation_mode_store\n- 被调用者: 未显示\n\n6. 函数名: hid_hw_request\n- 参数: [struct hid_device *hdev, struct hid_report *report, enum hid_class_request reqtype]\n- 调用者: picolcd_operation_mode_store\n- 被调用者: 未显示\n\n7. 函数名: spin_lock_irqsave\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: picolcd_operation_mode_store\n- 被调用者: 未显示\n\n8. 函数名: spin_unlock_irqrestore\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: picolcd_operation_mode_store\n- 被调用者: 未显示"
    },
    {
        "id": 295,
        "cwe": "CWE-119",
        "cve": "CVE-2013-4312",
        "purpose": "Code purpose:\"\"\"该代码用于管理UNIX域套接字的引用计数并在引用计数为零时从垃圾回收链表中移除对应的套接字\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确维护UNIX套接字垃圾回收机制中的引用计数，导致本地用户可通过重复发送文件描述符绕过文件描述符限制，造成内存耗尽拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: unix_notinflight\n- 参数: [struct file *fp]\n- 调用者: 未指定（由外部调用）\n- 被调用者: [unix_get_socket, unix_sk, spin_lock, atomic_long_dec_and_test, list_del_init, spin_unlock]\n\n2. 函数名: unix_get_socket\n- 参数: [struct file *fp]\n- 调用者: unix_notinflight\n- 被调用者: 未指定\n\n3. 函数名: unix_sk\n- 参数: [struct sock *s]\n- 调用者: unix_notinflight\n- 被调用者: 未指定\n\n4. 函数名: spin_lock\n- 参数: [&unix_gc_lock]\n- 调用者: unix_notinflight\n- 被调用者: 未指定\n\n5. 函数名: atomic_long_dec_and_test\n- 参数: [&u->inflight]\n- 调用者: unix_notinflight\n- 被调用者: 未指定\n\n6. 函数名: list_del_init\n- 参数: [&u->link]\n- 调用者: unix_notinflight\n- 被调用者: 未指定\n\n7. 函数名: spin_unlock\n- 参数: [&unix_gc_lock]\n- 调用者: unix_notinflight\n- 被调用者: 未指定"
    },
    {
        "id": 296,
        "cwe": "CWE-119",
        "cve": "CVE-2013-4312",
        "purpose": "Code purpose:\"\"\"管理UNIX域套接字的引用计数，防止垃圾回收过早释放正在使用的套接字\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确限制UNIX套接字文件描述符的引用计数，导致本地用户可通过反复发送和关闭描述符绕过文件描述符限制，造成内存耗尽的服务拒绝\"\"\"",
        "functions": "Functions:\n1. 函数名: unix_inflight\n- 参数: [struct file *fp]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [unix_get_socket, unix_sk, atomic_long_inc_return, spin_lock, spin_unlock]\n\n2. 函数名: unix_get_socket\n- 参数: [struct file *fp]\n- 调用者: unix_inflight\n- 被调用者: []\n\n3. 函数名: unix_sk\n- 参数: [struct sock *s]\n- 调用者: unix_inflight\n- 被调用者: []\n\n4. 函数名: atomic_long_inc_return\n- 参数: [atomic_long_t *v]\n- 调用者: unix_inflight\n- 被调用者: []\n\n5. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: unix_inflight\n- 被调用者: []\n\n6. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: unix_inflight\n- 被调用者: []"
    },
    {
        "id": 302,
        "cwe": "CWE-119",
        "cve": "CVE-2013-4387",
        "purpose": "Code purpose:\"\"\"处理IPv6数据包的组装和分片，包括UDP分片卸载(UFO)功能，以支持大包传输\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理UDP Fragmentation Offload(UFO)时，未能正确处理大包之后小包的分片需求，导致内存损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: ip6_append_data\n- 参数: [struct sock *sk, int getfrag(void *from, char *to, int offset, int len, int odd, struct sk_buff *skb), void *from, int length, int transhdrlen, int hlimit, int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6, struct rt6_info *rt, unsigned int flags, int dontfrag]\n- 调用者: 未显示\n- 被调用者: [ip6_opt_dup, ip6_rthdr_dup, dst_hold, ipv6_local_error, sock_tx_timestamp, ipv6_local_rxpmtu, ip6_ufo_append_data, skb_peek_tail, ip6_append_data_mtu, sock_alloc_send_skb, sock_wmalloc, skb_put, skb_copy_and_csum_bits, csum_sub, pskb_trim_unique, __skb_queue_tail, sk_page_frag_refill, skb_can_coalesce, __skb_fill_page_desc, page_address]\n\n2. 函数名: getfrag\n- 参数: [void *from, char *to, int offset, int len, int odd, struct sk_buff *skb]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n3. 函数名: ip6_opt_dup\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n4. 函数名: ip6_rthdr_dup\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n5. 函数名: dst_hold\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n6. 函数名: ipv6_local_error\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n7. 函数名: sock_tx_timestamp\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n8. 函数名: ipv6_local_rxpmtu\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n9. 函数名: ip6_ufo_append_data\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n10. 函数名: skb_peek_tail\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n11. 函数名: ip6_append_data_mtu\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n12. 函数名: sock_alloc_send_skb\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n13. 函数名: sock_wmalloc\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n14. 函数名: skb_put\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n15. 函数名: skb_copy_and_csum_bits\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n16. 函数名: csum_sub\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n17. 函数名: pskb_trim_unique\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n18. 函数名: __skb_queue_tail\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n19. 函数名: sk_page_frag_refill\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n20. 函数名: skb_can_coalesce\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n21. 函数名: __skb_fill_page_desc\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示\n\n22. 函数名: page_address\n- 参数: [未显示完整参数]\n- 调用者: ip6_append_data\n- 被调用者: 未显示"
    },
    {
        "id": 322,
        "cwe": "CWE-119",
        "cve": "CVE-2013-4512",
        "purpose": "Code purpose:\"\"\"该代码用于处理用户空间传递的退出码，并将其转换为整型值存储在内核变量中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对用户输入的count参数进行边界检查，导致copy_from_user操作可能超出buf数组的固定大小，造成缓冲区溢出漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: exitcode_proc_write\n- 参数: [struct file *file, const char __user *buffer, size_t count, loff_t *pos]\n- 调用者: 未明确（由内核proc文件系统调用）\n- 被调用者: [copy_from_user, simple_strtol, isspace]\n\n2. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: exitcode_proc_write\n- 被调用者: []\n\n3. 函数名: simple_strtol\n- 参数: [const char *cp, char **endp, unsigned int base]\n- 调用者: exitcode_proc_write\n- 被调用者: []\n\n4. 函数名: isspace\n- 参数: [int c]\n- 调用者: exitcode_proc_write\n- 被调用者: []"
    },
    {
        "id": 323,
        "cwe": "CWE-119",
        "cve": "CVE-2013-4513",
        "purpose": "Code purpose:\"\"\"该代码实现了通过字符设备写入数据到OZWPAN协议栈的功能，处理来自用户空间的数据并将其封装为协议元素进行传输。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"oz_cdev_write函数在处理用户空间数据时未正确验证count参数的大小，导致缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: oz_cdev_write\n- 参数: [struct file *filp, const char __user *buf, size_t count, loff_t *fpos]\n- 调用者: 外部调用\n- 被调用者: [spin_lock_bh, oz_pd_get, spin_unlock_bh, oz_elt_info_alloc, copy_from_user, oz_queue_elt_info, oz_elt_info_free, oz_pd_put]\n\n2. 函数名: spin_lock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: oz_cdev_write\n- 被调用者: []\n\n3. 函数名: oz_pd_get\n- 参数: [struct oz_pd *pd]\n- 调用者: oz_cdev_write\n- 被调用者: []\n\n4. 函数名: spin_unlock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: oz_cdev_write\n- 被调用者: []\n\n5. 函数名: oz_elt_info_alloc\n- 参数: [struct oz_elt_buf *eb]\n- 调用者: oz_cdev_write\n- 被调用者: []\n\n6. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: oz_cdev_write\n- 被调用者: []\n\n7. 函数名: oz_queue_elt_info\n- 参数: [struct oz_elt_buf *eb, u8 isoc, u8 id, struct oz_elt_info *ei]\n- 调用者: oz_cdev_write\n- 被调用者: []\n\n8. 函数名: oz_elt_info_free\n- 参数: [struct oz_elt_buf *eb, struct oz_elt_info *ei]\n- 调用者: oz_cdev_write\n- 被调用者: []\n\n9. 函数名: oz_pd_put\n- 参数: [struct oz_pd *pd]\n- 调用者: oz_cdev_write\n- 被调用者: []\n\n10. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: oz_cdev_write\n- 被调用者: []\n\n11. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: oz_cdev_write\n- 被调用者: []"
    },
    {
        "id": 324,
        "cwe": "CWE-119",
        "cve": "CVE-2013-4514",
        "purpose": "Code purpose:\"\"\"处理无线网络配置请求，包括验证用户权限、复制用户数据到内核空间、处理不同类型的网络配置命令，并更新相应的网络参数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理用户提供的长字符串时，未正确验证输入长度，导致缓冲区溢出漏洞，攻击者可利用CAP_NET_ADMIN权限造成拒绝服务或其他影响。\"\"\"",
        "functions": "Functions:\n1. 函数名: wvlan_uil_put_info\n- 参数: [struct uilreq *urq, struct wl_private *lp]\n- 调用者: 未显示（外部调用）\n- 被调用者: [capable, verify_area, copy_from_user, kmalloc, kfree, CNV_INT_TO_LITTLE, memset, memcpy, strlen, strcmp, wl_wep_decode, hcf_cntl, wl_act_int_off, hcf_put_info, wl_act_int_on]\n\n2. 函数名: wl_wep_decode\n- 参数: 未显示完整（代码中调用时参数为CRYPT_CODE, &sEncryption, lp->szEncryption）\n- 调用者: wvlan_uil_put_info\n- 被调用者: 未显示\n\n3. 函数名: hcf_cntl\n- 参数: 未显示完整（代码中调用时参数为&(lp->hcfCtx), HCF_CNTL_ENABLE | HCF_PORT_0等）\n- 调用者: wvlan_uil_put_info\n- 被调用者: 未显示\n\n4. 函数名: wl_act_int_off\n- 参数: [struct wl_private *lp]\n- 调用者: wvlan_uil_put_info\n- 被调用者: 未显示\n\n5. 函数名: hcf_put_info\n- 参数: 未显示完整（代码中调用时参数为&(lp->hcfCtx), (LTVP) pLtv）\n- 调用者: wvlan_uil_put_info\n- 被调用者: 未显示\n\n6. 函数名: wl_act_int_on\n- 参数: [struct wl_private *lp]\n- 调用者: wvlan_uil_put_info\n- 被调用者: 未显示"
    },
    {
        "id": 325,
        "cwe": "CWE-119",
        "cve": "CVE-2013-4514",
        "purpose": "Code purpose:\"\"\"该代码用于设置无线网络设备的站点昵称，将用户提供的昵称字符串复制到设备驱动程序的缓冲区中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对用户输入的'wrqu->data.length'进行有效验证，导致memcpy操作可能超出目标缓冲区'lp->StationName'的大小限制，造成缓冲区溢出漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: wvlan_set_station_nickname\n- 参数: [struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra]\n- 调用者: 未明确（由内核网络子系统调用）\n- 被调用者: [wl_priv, DBG_FUNC, DBG_ENTER, wl_lock, memset, memcpy, wl_apply, wl_unlock, DBG_LEAVE]\n\n2. 函数名: wl_priv\n- 参数: [struct net_device *dev]\n- 调用者: wvlan_set_station_nickname\n- 被调用者: []\n\n3. 函数名: DBG_FUNC\n- 参数: [const char *]\n- 调用者: wvlan_set_station_nickname\n- 被调用者: []\n\n4. 函数名: DBG_ENTER\n- 参数: [DbgInfo]\n- 调用者: wvlan_set_station_nickname\n- 被调用者: []\n\n5. 函数名: wl_lock\n- 参数: [struct wl_private *lp, unsigned long *flags]\n- 调用者: wvlan_set_station_nickname\n- 被调用者: []\n\n6. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: wvlan_set_station_nickname\n- 被调用者: []\n\n7. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: wvlan_set_station_nickname\n- 被调用者: []\n\n8. 函数名: wl_apply\n- 参数: [struct wl_private *lp]\n- 调用者: wvlan_set_station_nickname\n- 被调用者: []\n\n9. 函数名: wl_unlock\n- 参数: [struct wl_private *lp, unsigned long *flags]\n- 调用者: wvlan_set_station_nickname\n- 被调用者: []\n\n10. 函数名: DBG_LEAVE\n- 参数: [DbgInfo]\n- 调用者: wvlan_set_station_nickname\n- 被调用者: []"
    },
    {
        "id": 333,
        "cwe": "CWE-119",
        "cve": "CVE-2013-4588",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中IP虚拟服务(IPVS)的控制功能，包括服务管理、超时设置、同步守护进程操作等，供具有CAP_NET_ADMIN权限的用户通过系统调用进行配置。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对用户输入的参数长度进行充分验证，导致在copy_from_user操作时可能发生栈缓冲区溢出，本地用户可利用CAP_NET_ADMIN权限提升特权。\"\"\"",
        "functions": "Functions:\n1. 函数名: do_ip_vs_set_ctl\n- 参数: [struct sock *sk, int cmd, void __user *user, unsigned int len]\n- 调用者: 未显示（应为系统调用处理函数）\n- 被调用者: [capable, copy_from_user, ip_vs_use_count_inc, mutex_lock_interruptible, ip_vs_flush, ip_vs_set_timeout, start_sync_thread, stop_sync_thread, ip_vs_copy_usvc_compat, ip_vs_copy_udest_compat, ip_vs_zero_all, __ip_vs_service_get, __ip_vs_svc_fwm_get, ip_vs_add_service, ip_vs_edit_service, ip_vs_del_service, ip_vs_zero_service, ip_vs_add_dest, ip_vs_edit_dest, ip_vs_del_dest, ip_vs_service_put, mutex_unlock, ip_vs_use_count_dec]\n\n2. 函数名: capable\n- 参数: [CAP_NET_ADMIN]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n3. 函数名: copy_from_user\n- 参数: [arg, user, len]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n4. 函数名: ip_vs_use_count_inc\n- 参数: []\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n5. 函数名: mutex_lock_interruptible\n- 参数: [&__ip_vs_mutex]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n6. 函数名: ip_vs_flush\n- 参数: []\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n7. 函数名: ip_vs_set_timeout\n- 参数: [(struct ip_vs_timeout_user *)arg]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n8. 函数名: start_sync_thread\n- 参数: [dm->state, dm->mcast_ifn, dm->syncid]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n9. 函数名: stop_sync_thread\n- 参数: [dm->state]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n10. 函数名: ip_vs_copy_usvc_compat\n- 参数: [&usvc, usvc_compat]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n11. 函数名: ip_vs_copy_udest_compat\n- 参数: [&udest, udest_compat]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n12. 函数名: ip_vs_zero_all\n- 参数: []\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n13. 函数名: __ip_vs_service_get\n- 参数: [usvc.af, usvc.protocol, &usvc.addr, usvc.port]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n14. 函数名: __ip_vs_svc_fwm_get\n- 参数: [usvc.af, usvc.fwmark]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n15. 函数名: ip_vs_add_service\n- 参数: [&usvc, &svc]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n16. 函数名: ip_vs_edit_service\n- 参数: [svc, &usvc]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n17. 函数名: ip_vs_del_service\n- 参数: [svc]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n18. 函数名: ip_vs_zero_service\n- 参数: [svc]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n19. 函数名: ip_vs_add_dest\n- 参数: [svc, &udest]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n20. 函数名: ip_vs_edit_dest\n- 参数: [svc, &udest]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n21. 函数名: ip_vs_del_dest\n- 参数: [svc, &udest]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n22. 函数名: ip_vs_service_put\n- 参数: [svc]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n23. 函数名: mutex_unlock\n- 参数: [&__ip_vs_mutex]\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []\n\n24. 函数名: ip_vs_use_count_dec\n- 参数: []\n- 调用者: do_ip_vs_set_ctl\n- 被调用者: []"
    },
    {
        "id": 334,
        "cwe": "CWE-119",
        "cve": "CVE-2013-4588",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中IP虚拟服务器(IPVS)的控制接口功能，允许具有CAP_NET_ADMIN权限的用户通过getsockopt系统调用获取IPVS相关配置信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对用户提供的参数进行充分验证，导致在do_ip_vs_get_ctl函数中存在栈缓冲区溢出漏洞，本地用户可利用CAP_NET_ADMIN权限提升特权\"\"\"",
        "functions": "Functions:\n1. 函数名: do_ip_vs_get_ctl\n- 参数: [struct sock *sk, int cmd, void __user *user, int *len]\n- 调用者: 未显示（应为系统调用处理函数）\n- 被调用者: [capable, copy_from_user, mutex_lock_interruptible, sprintf, copy_to_user, strlen, __ip_vs_get_service_entries, __ip_vs_svc_fwm_get, __ip_vs_service_get, ip_vs_copy_service, ip_vs_service_put, __ip_vs_get_dest_entries, __ip_vs_get_timeouts, memset, strlcpy, mutex_unlock]\n\n2. 函数名: capable\n- 参数: [CAP_NET_ADMIN]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n3. 函数名: copy_from_user\n- 参数: [arg, user, get_arglen[GET_CMDID(cmd)]]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n4. 函数名: mutex_lock_interruptible\n- 参数: [&__ip_vs_mutex]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n5. 函数名: sprintf\n- 参数: [buf, \"IP Virtual Server version %d.%d.%d (size=%d)\", NVERSION(IP_VS_VERSION_CODE), IP_VS_CONN_TAB_SIZE]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n6. 函数名: copy_to_user\n- 参数: [user, buf, strlen(buf)+1] 或 [user, &info, sizeof(info)] 或 [user, entry, sizeof(*entry)] 或 [user, &t, sizeof(t)] 或 [user, &d, sizeof(d)]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n7. 函数名: strlen\n- 参数: [buf]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n8. 函数名: __ip_vs_get_service_entries\n- 参数: [get, user]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n9. 函数名: __ip_vs_svc_fwm_get\n- 参数: [AF_INET, entry->fwmark]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n10. 函数名: __ip_vs_service_get\n- 参数: [AF_INET, entry->protocol, &addr, entry->port]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n11. 函数名: ip_vs_copy_service\n- 参数: [entry, svc]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n12. 函数名: ip_vs_service_put\n- 参数: [svc]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n13. 函数名: __ip_vs_get_dest_entries\n- 参数: [get, user]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n14. 函数名: __ip_vs_get_timeouts\n- 参数: [&t]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n15. 函数名: memset\n- 参数: [&d, 0, sizeof(d)]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n16. 函数名: strlcpy\n- 参数: [d[0].mcast_ifn, ip_vs_master_mcast_ifn, sizeof(d[0].mcast_ifn)] 或 [d[1].mcast_ifn, ip_vs_backup_mcast_ifn, sizeof(d[1].mcast_ifn)]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []\n\n17. 函数名: mutex_unlock\n- 参数: [&__ip_vs_mutex]\n- 调用者: do_ip_vs_get_ctl\n- 被调用者: []"
    },
    {
        "id": 335,
        "cwe": "CWE-119",
        "cve": "CVE-2013-4591",
        "purpose": "Code purpose:\"\"\"该代码用于从NFSv4文件系统获取未缓存的ACL(访问控制列表)数据，并将其写入指定缓冲区或返回ACL长度。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证用户提供的buflen参数，导致在分配内存页面时可能超出预设的NFS4ACL_MAXPAGES数组边界，造成缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: __nfs4_get_acl_uncached\n- 参数: [struct inode *inode, void *buf, size_t buflen]\n- 调用者: 未显示（应为外部调用）\n- 被调用者: [alloc_page, nfs4_call_sync, nfs4_write_cached_acl, _copy_from_pages, __free_page]\n\n2. 函数名: alloc_page\n- 参数: [GFP_KERNEL]\n- 调用者: __nfs4_get_acl_uncached\n- 被调用者: []\n\n3. 函数名: nfs4_call_sync\n- 参数: [NFS_SERVER(inode)->client, NFS_SERVER(inode), &msg, &args.seq_args, &res.seq_res, 0]\n- 调用者: __nfs4_get_acl_uncached\n- 被调用者: []\n\n4. 函数名: nfs4_write_cached_acl\n- 参数: [struct inode *inode, struct page **pages, res.acl_data_offset, res.acl_len]\n- 调用者: __nfs4_get_acl_uncached\n- 被调用者: []\n\n5. 函数名: _copy_from_pages\n- 参数: [buf, pages, res.acl_data_offset, res.acl_len]\n- 调用者: __nfs4_get_acl_uncached\n- 被调用者: []\n\n6. 函数名: __free_page\n- 参数: [pages[i]] 或 [res.acl_scratch]\n- 调用者: __nfs4_get_acl_uncached\n- 被调用者: []"
    },
    {
        "id": 348,
        "cwe": "CWE-119",
        "cve": "CVE-2013-6381",
        "purpose": "Code purpose:\"\"\"处理SNMP命令请求，包括从用户空间复制数据、分配内存、执行命令并将结果返回给用户空间\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证用户提供的req_len长度，导致在memcpy操作时可能发生缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: qeth_snmp_command\n- 参数: [struct qeth_card *card, char __user *udata]\n- 调用者: 未显示（应为外部调用）\n- 被调用者: [copy_from_user, memdup_user, kzalloc, kfree, qeth_get_adapter_cmd, memcpy, qeth_send_ipa_snmp_cmd, QETH_CARD_TEXT, QETH_DBF_MESSAGE, copy_to_user]\n\n2. 函数名: copy_from_user\n- 参数: [&req_len, udata + sizeof(int), sizeof(int)]\n- 调用者: qeth_snmp_command\n- 被调用者: 无（内核函数）\n\n3. 函数名: memdup_user\n- 参数: [udata, req_len + sizeof(struct qeth_snmp_ureq_hdr)]\n- 调用者: qeth_snmp_command\n- 被调用者: 无（内核函数）\n\n4. 函数名: kzalloc\n- 参数: [qinfo.udata_len, GFP_KERNEL]\n- 调用者: qeth_snmp_command\n- 被调用者: 无（内核函数）\n\n5. 函数名: kfree\n- 参数: [ureq], [qinfo.udata]\n- 调用者: qeth_snmp_command\n- 被调用者: 无（内核函数）\n\n6. 函数名: qeth_get_adapter_cmd\n- 参数: [card, IPA_SETADP_SET_SNMP_CONTROL, QETH_SNMP_SETADP_CMDLENGTH + req_len]\n- 调用者: qeth_snmp_command\n- 被调用者: 无（外部函数）\n\n7. 函数名: memcpy\n- 参数: [&cmd->data.setadapterparms.data.snmp, &ureq->cmd, req_len]\n- 调用者: qeth_snmp_command\n- 被调用者: 无（内核函数）\n\n8. 函数名: qeth_send_ipa_snmp_cmd\n- 参数: [card, iob, QETH_SETADP_BASE_LEN + req_len, qeth_snmp_command_cb, (void *)&qinfo]\n- 调用者: qeth_snmp_command\n- 被调用者: 无（外部函数）\n\n9. 函数名: QETH_CARD_TEXT\n- 参数: [card, 3, \"snmpcmd\"], [card, 2, \"snmpnome\"]\n- 调用者: qeth_snmp_command\n- 被调用者: 无（宏/外部函数）\n\n10. 函数名: QETH_DBF_MESSAGE\n- 参数: [2, \"SNMP command failed on %s: (0x%x)\\n\", QETH_CARD_IFNAME(card), rc]\n- 调用者: qeth_snmp_command\n- 被调用者: 无（宏/外部函数）\n\n11. 函数名: copy_to_user\n- 参数: [udata, qinfo.udata, qinfo.udata_len]\n- 调用者: qeth_snmp_command\n- 被调用者: 无（内核函数）"
    },
    {
        "id": 349,
        "cwe": "CWE-119",
        "cve": "CVE-2013-6382",
        "purpose": "Code purpose:\"\"\"该代码实现了XFS文件系统中通过句柄获取属性列表的功能，包括权限检查、参数验证、内存分配和属性列表拷贝等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证用户提供的buflen参数，导致在处理XFS_IOC_ATTRLIST_BY_HANDLE或XFS_IOC_ATTRLIST_BY_HANDLE_32 ioctl调用时可能发生缓冲区下溢，造成内存损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: xfs_attrlist_by_handle\n- 参数: [struct file *parfilp, void __user *arg]\n- 调用者: 未显示（由ioctl调用）\n- 被调用者: [capable, copy_from_user, xfs_handlereq_to_dentry, kmem_zalloc_large, xfs_attr_list, copy_to_user, kmem_free, dput]\n\n2. 函数名: capable\n- 参数: [CAP_SYS_ADMIN]\n- 调用者: xfs_attrlist_by_handle\n- 被调用者: []\n\n3. 函数名: copy_from_user\n- 参数: [&al_hreq, arg, sizeof(xfs_fsop_attrlist_handlereq_t)]\n- 调用者: xfs_attrlist_by_handle\n- 被调用者: []\n\n4. 函数名: xfs_handlereq_to_dentry\n- 参数: [parfilp, &al_hreq.hreq]\n- 调用者: xfs_attrlist_by_handle\n- 被调用者: []\n\n5. 函数名: kmem_zalloc_large\n- 参数: [al_hreq.buflen, KM_SLEEP]\n- 调用者: xfs_attrlist_by_handle\n- 被调用者: []\n\n6. 函数名: xfs_attr_list\n- 参数: [XFS_I(dentry->d_inode), kbuf, al_hreq.buflen, al_hreq.flags, cursor]\n- 调用者: xfs_attrlist_by_handle\n- 被调用者: []\n\n7. 函数名: copy_to_user\n- 参数: [al_hreq.buffer, kbuf, al_hreq.buflen]\n- 调用者: xfs_attrlist_by_handle\n- 被调用者: []\n\n8. 函数名: kmem_free\n- 参数: [kbuf]\n- 调用者: xfs_attrlist_by_handle\n- 被调用者: []\n\n9. 函数名: dput\n- 参数: [dentry]\n- 调用者: xfs_attrlist_by_handle\n- 被调用者: []"
    },
    {
        "id": 350,
        "cwe": "CWE-119",
        "cve": "CVE-2013-6382",
        "purpose": "Code purpose:\"\"\"该代码用于处理XFS文件系统中兼容模式下通过句柄获取属性列表的请求，涉及权限检查、内存分配和数据拷贝等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证用户提供的buflen参数，导致在处理XFS_IOC_ATTRLIST_BY_HANDLE或XFS_IOC_ATTRLIST_BY_HANDLE_32 ioctl调用时可能发生缓冲区下溢，造成内存损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: xfs_compat_attrlist_by_handle\n- 参数: [struct file *parfilp, void __user *arg]\n- 调用者: 未显示（应为ioctl调用者）\n- 被调用者: [capable, copy_from_user, xfs_compat_handlereq_to_dentry, IS_ERR, PTR_ERR, kmem_zalloc_large, xfs_attr_list, copy_to_user, kmem_free, dput]\n\n2. 函数名: capable\n- 参数: [CAP_SYS_ADMIN]\n- 调用者: xfs_compat_attrlist_by_handle\n- 被调用者: []\n\n3. 函数名: copy_from_user\n- 参数: [&al_hreq, arg, sizeof(compat_xfs_fsop_attrlist_handlereq_t)]\n- 调用者: xfs_compat_attrlist_by_handle\n- 被调用者: []\n\n4. 函数名: xfs_compat_handlereq_to_dentry\n- 参数: [parfilp, &al_hreq.hreq]\n- 调用者: xfs_compat_attrlist_by_handle\n- 被调用者: []\n\n5. 函数名: IS_ERR\n- 参数: [dentry]\n- 调用者: xfs_compat_attrlist_by_handle\n- 被调用者: []\n\n6. 函数名: PTR_ERR\n- 参数: [dentry]\n- 调用者: xfs_compat_attrlist_by_handle\n- 被调用者: []\n\n7. 函数名: kmem_zalloc_large\n- 参数: [al_hreq.buflen, KM_SLEEP]\n- 调用者: xfs_compat_attrlist_by_handle\n- 被调用者: []\n\n8. 函数名: xfs_attr_list\n- 参数: [XFS_I(dentry->d_inode), kbuf, al_hreq.buflen, al_hreq.flags, cursor]\n- 调用者: xfs_compat_attrlist_by_handle\n- 被调用者: []\n\n9. 函数名: copy_to_user\n- 参数: [compat_ptr(al_hreq.buffer), kbuf, al_hreq.buflen]\n- 调用者: xfs_compat_attrlist_by_handle\n- 被调用者: []\n\n10. 函数名: kmem_free\n- 参数: [kbuf]\n- 调用者: xfs_compat_attrlist_by_handle\n- 被调用者: []\n\n11. 函数名: dput\n- 参数: [dentry]\n- 调用者: xfs_compat_attrlist_by_handle\n- 被调用者: []"
    },
    {
        "id": 358,
        "cwe": "CWE-119",
        "cve": "CVE-2013-7027",
        "purpose": "Code purpose:\"\"\"初始化radiotap迭代器，用于解析无线网络数据包的radiotap头部信息，但不充分验证数据包是否包含超出头部的数据\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未验证帧数据是否超出头部范围，导致可能读取到非法内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: ieee80211_radiotap_iterator_init\n- 参数: [iterator, radiotap_header, max_length, vns]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [get_unaligned_le16, get_unaligned_le32]\n\n2. 函数名: get_unaligned_le16\n- 参数: [&radiotap_header->it_len]\n- 调用者: ieee80211_radiotap_iterator_init\n- 被调用者: []\n\n3. 函数名: get_unaligned_le32\n- 参数: [&radiotap_header->it_present, iterator->_arg]\n- 调用者: ieee80211_radiotap_iterator_init\n- 被调用者: []"
    },
    {
        "id": 426,
        "cwe": "CWE-119",
        "cve": "CVE-2014-0069",
        "purpose": "Code purpose:\"\"\"处理CIFS文件系统的非缓存写入操作，将用户空间的数据通过writev系统调用写入远程文件\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核未正确处理未缓存写入操作中拷贝字节数少于请求数的情况，导致内存泄露或破坏\"\"\"",
        "functions": "Functions:\n1. 函数名: cifs_iovec_write\n- 参数: [struct file *file, const struct iovec *iov, unsigned long nr_segs, loff_t *poffset]\n- 调用者: 未显示（系统调用层）\n- 被调用者: [iov_length, generic_write_checks, INIT_LIST_HEAD, tlink_tcon, iov_iter_init, get_numpages, cifs_writedata_alloc, cifs_write_allocate_pages, min_t, iov_iter_copy_from_user, iov_iter_advance, cifsFileInfo_get, cifs_uncached_retry_writev, kref_put, list_add_tail, wait_for_completion_killable, list_del_init, cifs_stats_bytes_written]\n\n2. 函数名: iov_length\n- 参数: [const struct iovec *iov, unsigned long nr_segs]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n3. 函数名: generic_write_checks\n- 参数: [struct file *file, loff_t *poffset, size_t *len, unsigned int flags]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n4. 函数名: INIT_LIST_HEAD\n- 参数: [struct list_head *list]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n5. 函数名: tlink_tcon\n- 参数: [struct tcon_link *tlink]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n6. 函数名: iov_iter_init\n- 参数: [struct iov_iter *iter, const struct iovec *iov, unsigned long nr_segs, size_t count, size_t written]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n7. 函数名: get_numpages\n- 参数: [size_t wsize, size_t len, size_t *cur_len]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n8. 函数名: cifs_writedata_alloc\n- 参数: [unsigned long nr_pages, work_func_t complete]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n9. 函数名: cifs_write_allocate_pages\n- 参数: [struct page **pages, unsigned long nr_pages]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n10. 函数名: min_t\n- 参数: [type, x, y]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n11. 函数名: iov_iter_copy_from_user\n- 参数: [struct page *page, struct iov_iter *i, unsigned long offset, size_t bytes]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n12. 函数名: iov_iter_advance\n- 参数: [struct iov_iter *i, size_t bytes]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n13. 函数名: cifsFileInfo_get\n- 参数: [struct cifsFileInfo *cifs_file]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n14. 函数名: cifs_uncached_retry_writev\n- 参数: [struct cifs_writedata *wdata]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n15. 函数名: kref_put\n- 参数: [struct kref *kref, void (*release)(struct kref *kref)]\n- 调用者: cifs_iovec_write\n- 被调用者: [cifs_uncached_writedata_release]\n\n16. 函数名: list_add_tail\n- 参数: [struct list_head *new, struct list_head *head]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n17. 函数名: wait_for_completion_killable\n- 参数: [struct completion *x]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n18. 函数名: list_del_init\n- 参数: [struct list_head *entry]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n19. 函数名: cifs_stats_bytes_written\n- 参数: [struct cifs_tcon *tcon, unsigned int bytes]\n- 调用者: cifs_iovec_write\n- 被调用者: 未显示\n\n20. 函数名: cifs_uncached_writedata_release\n- 参数: [struct kref *refcount]\n- 调用者: kref_put\n- 被调用者: 未显示"
    },
    {
        "id": 464,
        "cwe": "CWE-119",
        "cve": "CVE-2014-0205",
        "purpose": "Code purpose:\"\"\"该代码片段用于在futex操作中解锁队列并减少键的引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在requeue操作期间未能正确维护引用计数，导致引用计数可能为零，从而引发use-after-free问题\"\"\"",
        "functions": "Functions:\n1. 函数名: queue_unlock\n- 参数: [struct futex_q *q, struct futex_hash_bucket *hb]\n- 被调用者: [spin_unlock, drop_futex_key_refs]\n\n2. 函数名: spin_unlock\n- 参数: [&hb->lock]\n- 调用者: queue_unlock\n\n3. 函数名: drop_futex_key_refs\n- 参数: [&q->key]\n- 调用者: queue_unlock"
    },
    {
        "id": 465,
        "cwe": "CWE-119",
        "cve": "CVE-2014-0205",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中的futex_wait功能，用于在用户空间地址上等待特定条件满足或超时发生，支持可中断的等待操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在requeue操作期间未能正确维护引用计数，导致引用计数可能变为零，从而引发use-after-free问题\"\"\"",
        "functions": "Functions:\n1. 函数名: futex_wait\n- 参数: [u32 __user *uaddr, int fshared, u32 val, ktime_t *abs_time, u32 bitset, int clockrt]\n- 调用者: N/A (top-level function)\n- 被调用者: [futex_wait_setup, futex_wait_queue_me, unqueue_me, signal_pending, put_futex_key, hrtimer_init_on_stack, hrtimer_init_sleeper, hrtimer_set_expires_range_ns, hrtimer_cancel, destroy_hrtimer_on_stack]\n\n2. 函数名: futex_wait_setup\n- 参数: [u32 __user *uaddr, u32 val, int fshared, struct futex_q *q, struct futex_hash_bucket **hb]\n- 调用者: futex_wait\n- 被调用者: []\n\n3. 函数名: futex_wait_queue_me\n- 参数: [struct futex_hash_bucket *hb, struct futex_q *q, struct hrtimer_sleeper *to]\n- 调用者: futex_wait\n- 被调用者: []\n\n4. 函数名: unqueue_me\n- 参数: [struct futex_q *q]\n- 调用者: futex_wait\n- 被调用者: []\n\n5. 函数名: signal_pending\n- 参数: [struct task_struct *current]\n- 调用者: futex_wait\n- 被调用者: []\n\n6. 函数名: put_futex_key\n- 参数: [int fshared, struct futex_key *key]\n- 调用者: futex_wait\n- 被调用者: []\n\n7. 函数名: hrtimer_init_on_stack\n- 参数: [struct hrtimer *timer, clockid_t which_clock, enum hrtimer_mode mode]\n- 调用者: futex_wait\n- 被调用者: []\n\n8. 函数名: hrtimer_init_sleeper\n- 参数: [struct hrtimer_sleeper *sl, struct task_struct *task]\n- 调用者: futex_wait\n- 被调用者: []\n\n9. 函数名: hrtimer_set_expires_range_ns\n- 参数: [struct hrtimer *timer, ktime_t time, u64 delta]\n- 调用者: futex_wait\n- 被调用者: []\n\n10. 函数名: hrtimer_cancel\n- 参数: [struct hrtimer *timer]\n- 调用者: futex_wait\n- 被调用者: []\n\n11. 函数名: destroy_hrtimer_on_stack\n- 参数: [struct hrtimer *timer]\n- 调用者: futex_wait\n- 被调用者: []"
    },
    {
        "id": 466,
        "cwe": "CWE-119",
        "cve": "CVE-2014-0205",
        "purpose": "Code purpose:\"\"\"实现futex(快速用户空间互斥锁)的等待和重新排队功能，用于进程间同步和互斥操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在futex_wait函数中进行requeue操作时未正确维护引用计数，导致引用计数可能变为零，从而引发use-after-free问题\"\"\"",
        "functions": "Functions:\n1. 函数名: futex_wait_requeue_pi\n- 参数: [u32 __user *uaddr, int fshared, u32 val, ktime_t *abs_time, u32 bitset, int clockrt, u32 __user *uaddr2]\n- 调用者: 未显示\n- 被调用者: [hrtimer_init_on_stack, hrtimer_init_sleeper, hrtimer_set_expires_range_ns, debug_rt_mutex_init_waiter, get_futex_key, futex_wait_setup, futex_wait_queue_me, handle_early_requeue_pi_wakeup, fixup_pi_state_owner, rt_mutex_finish_proxy_lock, debug_rt_mutex_free_waiter, fixup_owner, unqueue_me_pi, rt_mutex_unlock, put_futex_key, hrtimer_cancel, destroy_hrtimer_on_stack]\n\n2. 函数名: hrtimer_init_on_stack\n- 参数: [&to->timer, clockrt ? CLOCK_REALTIME : CLOCK_MONOTONIC, HRTIMER_MODE_ABS]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n3. 函数名: hrtimer_init_sleeper\n- 参数: [to, current]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n4. 函数名: hrtimer_set_expires_range_ns\n- 参数: [&to->timer, *abs_time, current->timer_slack_ns]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n5. 函数名: debug_rt_mutex_init_waiter\n- 参数: [&rt_waiter]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n6. 函数名: get_futex_key\n- 参数: [uaddr2, fshared, &key2]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n7. 函数名: futex_wait_setup\n- 参数: [uaddr, val, fshared, &q, &hb]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n8. 函数名: futex_wait_queue_me\n- 参数: [hb, &q, to]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n9. 函数名: handle_early_requeue_pi_wakeup\n- 参数: [hb, &q, &key2, to]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n10. 函数名: fixup_pi_state_owner\n- 参数: [uaddr2, &q, current, fshared]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n11. 函数名: rt_mutex_finish_proxy_lock\n- 参数: [pi_mutex, to, &rt_waiter, 1]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n12. 函数名: debug_rt_mutex_free_waiter\n- 参数: [&rt_waiter]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n13. 函数名: fixup_owner\n- 参数: [uaddr2, fshared, &q, !ret]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n14. 函数名: unqueue_me_pi\n- 参数: [&q]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n15. 函数名: rt_mutex_unlock\n- 参数: [pi_mutex]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n16. 函数名: put_futex_key\n- 参数: [fshared, &q.key] 和 [fshared, &key2]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n17. 函数名: hrtimer_cancel\n- 参数: [&to->timer]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n18. 函数名: destroy_hrtimer_on_stack\n- 参数: [&to->timer]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示"
    },
    {
        "id": 467,
        "cwe": "CWE-119",
        "cve": "CVE-2014-0205",
        "purpose": "Code purpose:\"\"\"该代码片段用于在Linux内核的futex机制中获取并锁定与给定futex队列项相关联的哈希桶\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在requeue操作期间未能正确维护引用计数，导致引用计数可能为零，引发use-after-free问题\"\"\"",
        "functions": "Functions:\n1. 函数名: queue_lock\n- 参数: [struct futex_q *q]\n- 调用者: 未提供\n- 被调用者: [get_futex_key_refs, hash_futex, spin_lock]\n\n2. 函数名: get_futex_key_refs\n- 参数: [&q->key]\n- 调用者: queue_lock\n- 被调用者: 未提供\n\n3. 函数名: hash_futex\n- 参数: [&q->key]\n- 调用者: queue_lock\n- 被调用者: 未提供\n\n4. 函数名: spin_lock\n- 参数: [&hb->lock]\n- 调用者: queue_lock\n- 被调用者: 未提供"
    },
    {
        "id": 468,
        "cwe": "CWE-119",
        "cve": "CVE-2014-0205",
        "purpose": "Code purpose:\"\"\"该代码片段用于在Linux内核中处理futex队列的解除排队操作，释放相关资源并减少引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在requeue操作期间未能正确维护引用计数，导致引用计数可能为零，从而引发use-after-free问题\"\"\"",
        "functions": "Functions:\n1. 函数名: unqueue_me_pi\n- 参数: [struct futex_q *q]\n- 调用者: 未明确（由系统调用或内核其他部分调用）\n- 被调用者: [WARN_ON, plist_del, BUG_ON, free_pi_state, spin_unlock, drop_futex_key_refs]\n\n2. 函数名: WARN_ON\n- 参数: [plist_node_empty(&q->list)]\n- 调用者: unqueue_me_pi\n- 被调用者: [plist_node_empty]\n\n3. 函数名: plist_node_empty\n- 参数: [&q->list]\n- 调用者: WARN_ON\n- 被调用者: []\n\n4. 函数名: plist_del\n- 参数: [&q->list, &q->list.plist]\n- 调用者: unqueue_me_pi\n- 被调用者: []\n\n5. 函数名: BUG_ON\n- 参数: [!q->pi_state]\n- 调用者: unqueue_me_pi\n- 被调用者: []\n\n6. 函数名: free_pi_state\n- 参数: [q->pi_state]\n- 调用者: unqueue_me_pi\n- 被调用者: []\n\n7. 函数名: spin_unlock\n- 参数: [q->lock_ptr]\n- 调用者: unqueue_me_pi\n- 被调用者: []\n\n8. 函数名: drop_futex_key_refs\n- 参数: [&q->key]\n- 调用者: unqueue_me_pi\n- 被调用者: []"
    },
    {
        "id": 480,
        "cwe": "CWE-119",
        "cve": "CVE-2014-2309",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理IPv6路由的添加操作，包括验证配置参数、创建路由表项、设置路由属性和安装路由等功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中的ip6_route_add函数在处理ICMPv6路由器通告包时未正确限制路由添加数量，导致攻击者可通过洪水攻击造成内存耗尽\"\"\"",
        "functions": "Functions:\n1. 函数名: ip6_route_add\n- 参数: [struct fib6_config *cfg]\n- 调用者: 未显示（外部调用）\n- 被调用者: [dev_get_by_index, in6_dev_get, fib6_get_table, fib6_new_table, ip6_dst_alloc, rt6_set_expires, rt6_clean_expires, ipv6_addr_type, ipv6_addr_prefix, kzalloc, dst_init_metrics, dev_put, in6_dev_put, dev_hold, in6_dev_get, in6_dev_hold, rt6_lookup, ip6_rt_put, ipv6_chk_addr, dst_metric_set, dst_free, __ip6_ins_rt]\n\n2. 函数名: dev_get_by_index\n- 参数: [struct net *net, int ifindex]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n3. 函数名: in6_dev_get\n- 参数: [struct net_device *dev]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n4. 函数名: fib6_get_table\n- 参数: [struct net *net, u32 id]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n5. 函数名: fib6_new_table\n- 参数: [struct net *net, u32 id]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n6. 函数名: ip6_dst_alloc\n- 参数: [struct net *net, struct net_device *dev, int flags, struct fib6_table *table]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n7. 函数名: rt6_set_expires\n- 参数: [struct rt6_info *rt, unsigned long expires]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n8. 函数名: rt6_clean_expires\n- 参数: [struct rt6_info *rt]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n9. 函数名: ipv6_addr_type\n- 参数: [const struct in6_addr *addr]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n10. 函数名: ipv6_addr_prefix\n- 参数: [struct in6_addr *pfx, const struct in6_addr *addr, int plen]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n11. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n12. 函数名: dst_init_metrics\n- 参数: [struct dst_entry *dst, u32 *src_metrics, bool override]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n13. 函数名: dev_put\n- 参数: [struct net_device *dev]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n14. 函数名: in6_dev_put\n- 参数: [struct inet6_dev *idev]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n15. 函数名: dev_hold\n- 参数: [struct net_device *dev]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n16. 函数名: in6_dev_hold\n- 参数: [struct inet6_dev *idev]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n17. 函数名: rt6_lookup\n- 参数: [struct net *net, const struct in6_addr *daddr, const struct in6_addr *saddr, int oif, int strict]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n18. 函数名: ip6_rt_put\n- 参数: [struct rt6_info *rt]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n19. 函数名: ipv6_chk_addr\n- 参数: [struct net *net, const struct in6_addr *addr, const struct net_device *dev, int strict]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n20. 函数名: dst_metric_set\n- 参数: [struct dst_entry *dst, int metric, u32 val]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n21. 函数名: dst_free\n- 参数: [struct dst_entry *dst]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）\n\n22. 函数名: __ip6_ins_rt\n- 参数: [struct rt6_info *rt, struct nl_info *info]\n- 调用者: ip6_route_add\n- 被调用者: 未显示（内核函数）"
    },
    {
        "id": 511,
        "cwe": "CWE-119",
        "cve": "CVE-2014-3181",
        "purpose": "Code purpose:\"\"\"处理Magic Mouse和Magic Trackpad设备的原始输入数据，包括解析触摸点信息和按钮点击事件，并将这些事件报告给输入子系统。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"magicmouse_raw_event函数在处理来自设备的输入数据时，未充分验证数据大小，导致栈缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: magicmouse_raw_event\n- 参数: [struct hid_device *hdev, struct hid_report *report, u8 *data, int size]\n- 调用者: 外部调用（未在代码中显示）\n- 被调用者: [magicmouse_emit_touch, magicmouse_emit_buttons, input_report_rel, input_report_key, input_mt_report_pointer_emulation, input_sync, magicmouse_raw_event]\n\n2. 函数名: magicmouse_emit_touch\n- 参数: [struct magicmouse_sc *msc, int ii, u8 *data]\n- 调用者: magicmouse_raw_event\n- 被调用者: []\n\n3. 函数名: magicmouse_emit_buttons\n- 参数: [struct magicmouse_sc *msc, int clicks]\n- 调用者: magicmouse_raw_event\n- 被调用者: []\n\n4. 函数名: input_report_rel\n- 参数: [struct input_dev *input, int REL_X, int x]\n- 调用者: magicmouse_raw_event\n- 被调用者: []\n\n5. 函数名: input_report_key\n- 参数: [struct input_dev *input, int BTN_MOUSE, int clicks]\n- 调用者: magicmouse_raw_event\n- 被调用者: []\n\n6. 函数名: input_mt_report_pointer_emulation\n- 参数: [struct input_dev *input, bool true]\n- 调用者: magicmouse_raw_event\n- 被调用者: []\n\n7. 函数名: input_sync\n- 参数: [struct input_dev *input]\n- 调用者: magicmouse_raw_event\n- 被调用者: []"
    },
    {
        "id": 512,
        "cwe": "CWE-119",
        "cve": "CVE-2014-3182",
        "purpose": "Code purpose:\"\"\"该代码用于处理Logitech Unifying无线接收器接收到的设备配对报告，分配并初始化新的HID设备，并将其添加到系统中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理REPORT_TYPE_NOTIF_DEVICE_UNPAIRED报告时，由于未正确验证设备索引范围，导致数组越界访问和无效内存释放漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: logi_dj_recv_add_djhid_device\n- 参数: [djrcv_dev, dj_report]\n- 调用者: 未显示（应为外部调用）\n- 被调用者: [hid_allocate_device, IS_ERR, snprintf, usb_make_path, strlcat, kzalloc, get_unaligned_le32, hid_add_device, kfree, hid_destroy_device]\n\n2. 函数名: hid_allocate_device\n- 参数: []\n- 调用者: logi_dj_recv_add_djhid_device\n- 被调用者: []\n\n3. 函数名: IS_ERR\n- 参数: [dj_hiddev]\n- 调用者: logi_dj_recv_add_djhid_device\n- 被调用者: []\n\n4. 函数名: snprintf\n- 参数: [dj_hiddev->name, sizeof(dj_hiddev->name), \"Logitech Unifying Device. Wireless PID:%02x%02x\", dj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_MSB], dj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_LSB]]\n- 调用者: logi_dj_recv_add_djhid_device\n- 被调用者: []\n\n5. 函数名: usb_make_path\n- 参数: [usbdev, dj_hiddev->phys, sizeof(dj_hiddev->phys)]\n- 调用者: logi_dj_recv_add_djhid_device\n- 被调用者: []\n\n6. 函数名: strlcat\n- 参数: [dj_hiddev->phys, tmpstr, sizeof(dj_hiddev->phys)]\n- 调用者: logi_dj_recv_add_djhid_device\n- 被调用者: []\n\n7. 函数名: kzalloc\n- 参数: [sizeof(struct dj_device), GFP_KERNEL]\n- 调用者: logi_dj_recv_add_djhid_device\n- 被调用者: []\n\n8. 函数名: get_unaligned_le32\n- 参数: [dj_report->report_params + DEVICE_PAIRED_RF_REPORT_TYPE]\n- 调用者: logi_dj_recv_add_djhid_device\n- 被调用者: []\n\n9. 函数名: hid_add_device\n- 参数: [dj_hiddev]\n- 调用者: logi_dj_recv_add_djhid_device\n- 被调用者: []\n\n10. 函数名: kfree\n- 参数: [dj_dev]\n- 调用者: logi_dj_recv_add_djhid_device\n- 被调用者: []\n\n11. 函数名: hid_destroy_device\n- 参数: [dj_hiddev]\n- 调用者: logi_dj_recv_add_djhid_device\n- 被调用者: []"
    },
    {
        "id": 513,
        "cwe": "CWE-119",
        "cve": "CVE-2014-3182",
        "purpose": "Code purpose:\"\"\"处理来自Logitech DJ设备的原始HID报告数据，包括设备配对/取消配对通知、连接状态变化和输入事件转发等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理REPORT_TYPE_NOTIF_DEVICE_UNPAIRED类型的报告时，由于未对输入数据进行充分验证，导致数组索引错误或无效内存释放。\"\"\"",
        "functions": "Functions:\n1. 函数名: logi_dj_raw_event\n- 参数: [struct hid_device *hdev, struct hid_report *report, u8 *data, int size]\n- 调用者: hid-core (implied by raw event handling)\n- 被调用者: [hid_get_drvdata, logi_dj_recv_queue_notification, logi_dj_recv_forward_null_report, logi_dj_recv_forward_report]\n\n2. 函数名: hid_get_drvdata\n- 参数: [struct hid_device *hdev]\n- 调用者: logi_dj_raw_event\n- 被调用者: []\n\n3. 函数名: logi_dj_recv_queue_notification\n- 参数: [struct dj_receiver_dev *djrcv_dev, struct dj_report *dj_report]\n- 调用者: logi_dj_raw_event\n- 被调用者: []\n\n4. 函数名: logi_dj_recv_forward_null_report\n- 参数: [struct dj_receiver_dev *djrcv_dev, struct dj_report *dj_report]\n- 调用者: logi_dj_raw_event\n- 被调用者: []\n\n5. 函数名: logi_dj_recv_forward_report\n- 参数: [struct dj_receiver_dev *djrcv_dev, struct dj_report *dj_report]\n- 调用者: logi_dj_raw_event\n- 被调用者: []"
    },
    {
        "id": 514,
        "cwe": "CWE-119",
        "cve": "CVE-2014-3183",
        "purpose": "Code purpose:\"\"\"处理来自Logitech无线设备的HID原始请求，特别是LED报告类型的请求，并将请求转发给接收器设备。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证输入报告的大小，导致在memcpy操作时可能发生堆缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: logi_dj_ll_raw_request\n- 参数: [struct hid_device *hid, unsigned char reportnum, __u8 *buf, size_t count, unsigned char report_type, int reqtype]\n- 调用者: 未指定（由HID子系统调用）\n- 被调用者: [kzalloc, memcpy, hid_hw_raw_request, kfree]\n\n2. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: logi_dj_ll_raw_request\n- 被调用者: []\n\n3. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: logi_dj_ll_raw_request\n- 被调用者: []\n\n4. 函数名: hid_hw_raw_request\n- 参数: [struct hid_device *hdev, unsigned char reportnum, __u8 *buf, size_t count, unsigned char report_type, int reqtype]\n- 调用者: logi_dj_ll_raw_request\n- 被调用者: []\n\n5. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: logi_dj_ll_raw_request\n- 被调用者: []"
    },
    {
        "id": 515,
        "cwe": "CWE-119",
        "cve": "CVE-2014-3184",
        "purpose": "Code purpose:\"\"\"修复Cherry Cymotion设备的报告描述符，通过修改特定位置的字节值来纠正描述符格式。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证输入报告描述符的大小，导致在处理特定设备提供的过小报告描述符时可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: ch_report_fixup\n- 参数: [hdev, rdesc, rsize]\n- 调用者: HID subsystem in the Linux kernel\n- 被调用者: [hid_info]"
    },
    {
        "id": 516,
        "cwe": "CWE-119",
        "cve": "CVE-2014-3184",
        "purpose": "Code purpose:\"\"\"该代码用于修复特定USB设备（如KYE/Genius品牌的鼠标和键盘）的报告描述符，确保其与HID子系统兼容，但存在缓冲区溢出漏洞风险。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证输入报告描述符的大小，导致在处理小型报告描述符时可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: kye_report_fixup\n- 参数: [struct hid_device *hdev, __u8 *rdesc, unsigned int *rsize]\n- 调用者: 未显示（由HID子系统调用）\n- 被调用者: [kye_consumer_control_fixup]\n\n2. 函数名: kye_consumer_control_fixup\n- 参数: [struct hid_device *hdev, __u8 *rdesc, unsigned int *rsize, int value, char *name]\n- 调用者: kye_report_fixup\n- 被调用者: []"
    },
    {
        "id": 517,
        "cwe": "CWE-119",
        "cve": "CVE-2014-3184",
        "purpose": "Code purpose:\"\"\"该代码用于修正Logitech设备的HID报告描述符，处理不同型号设备的特定描述符格式问题，以防止设备通信异常。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证输入报告描述符的大小，导致在处理特定设备的小型报告描述符时可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: lg_report_fixup\n- 参数: [struct hid_device *hdev, __u8 *rdesc, unsigned int *rsize]\n- 调用者: 未显示（由HID子系统调用）\n- 被调用者: [hid_get_drvdata, hid_info, hid_err, le16_to_cpu]\n\n2. 函数名: hid_get_drvdata\n- 参数: [struct hid_device *hdev]\n- 调用者: lg_report_fixup\n- 被调用者: 未显示\n\n3. 函数名: hid_info\n- 参数: [struct hid_device *hdev, const char *fmt, ...]\n- 调用者: lg_report_fixup\n- 被调用者: 未显示\n\n4. 函数名: hid_err\n- 参数: [struct hid_device *hdev, const char *fmt, ...]\n- 调用者: lg_report_fixup\n- 被调用者: 未显示\n\n5. 函数名: le16_to_cpu\n- 参数: [__u16 val]\n- 调用者: lg_report_fixup\n- 被调用者: 未显示\n\n6. 函数名: hid_to_usb_dev\n- 参数: [struct hid_device *hdev]\n- 调用者: lg_report_fixup\n- 被调用者: 未显示"
    },
    {
        "id": 518,
        "cwe": "CWE-119",
        "cve": "CVE-2014-3184",
        "purpose": "Code purpose:\"\"\"修复HID报告描述符中的按钮/消费者控制项，防止设备提供不正确的描述符导致问题\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证输入报告描述符的大小，导致在处理小型报告描述符时可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: mr_report_fixup\n- 参数: [struct hid_device *hdev, __u8 *rdesc, unsigned int *rsize]\n- 调用者: HID子系统（具体调用者未在代码片段中显示）\n- 被调用者: [hid_info]"
    },
    {
        "id": 519,
        "cwe": "CWE-119",
        "cve": "CVE-2014-3184",
        "purpose": "Code purpose:\"\"\"修复Petalynx Maxter Remote设备的报告描述符中的特定字节值以防止越界写入漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证输入报告描述符的大小，导致在边界检查不足的情况下可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: pl_report_fixup\n- 参数: [struct hid_device *hdev, __u8 *rdesc, unsigned int *rsize]\n- 调用者: 未明确（由HID子系统调用）\n- 被调用者: [hid_info]"
    },
    {
        "id": 520,
        "cwe": "CWE-119",
        "cve": "CVE-2014-3184",
        "purpose": "Code purpose:\"\"\"修复Sunplus无线桌面设备的报告描述符，防止因描述符过小导致的越界写入问题\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证输入报告描述符的大小，导致在处理小型恶意描述符时可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: sp_report_fixup\n- 参数: [struct hid_device *hdev, __u8 *rdesc, unsigned int *rsize]\n- 调用者: 未明确显示（由HID子系统调用）\n- 被调用者: [hid_info]"
    },
    {
        "id": 521,
        "cwe": "CWE-119",
        "cve": "CVE-2014-3185",
        "purpose": "Code purpose:\"\"\"处理USB串行端口命令的回调函数，包括命令完成状态检查、事件处理和内存数据拷贝等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理USB设备返回的批量响应数据时，未对urb->actual_length进行有效验证，导致缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: command_port_read_callback\n- 参数: [struct urb *urb]\n- 调用者: 未被直接显示（由USB子系统调用）\n- 被调用者: [usb_get_serial_port_data, dev_dbg, wake_up, usb_serial_debug_data, memcpy, usb_submit_urb]\n\n2. 函数名: usb_get_serial_port_data\n- 参数: [struct usb_serial_port *command_port]\n- 调用者: command_port_read_callback\n- 被调用者: []\n\n3. 函数名: dev_dbg\n- 参数: [&urb->dev->dev, format_string, ...]\n- 调用者: command_port_read_callback\n- 被调用者: []\n\n4. 函数名: wake_up\n- 参数: [&command_info->wait_command]\n- 调用者: command_port_read_callback\n- 被调用者: []\n\n5. 函数名: usb_serial_debug_data\n- 参数: [&command_port->dev, __func__, urb->actual_length, data]\n- 调用者: command_port_read_callback\n- 被调用者: []\n\n6. 函数名: memcpy\n- 参数: [command_info->result_buffer, &data[1], urb->actual_length - 1]\n- 调用者: command_port_read_callback\n- 被调用者: []\n\n7. 函数名: usb_submit_urb\n- 参数: [command_port->read_urb, GFP_ATOMIC]\n- 调用者: command_port_read_callback\n- 被调用者: []"
    },
    {
        "id": 522,
        "cwe": "CWE-119",
        "cve": "CVE-2014-3186",
        "purpose": "Code purpose:\"\"\"处理来自PicoLCD HID设备的原始输入事件，包括按键状态、红外数据和其他报告类型的数据\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理来自PicoLCD设备的报告数据时，未对输入的raw_data+1和size-1进行边界检查，导致缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: picolcd_raw_event\n- 参数: [struct hid_device *hdev, struct hid_report *report, u8 *raw_data, int size]\n- 调用者: 未指定（由HID子系统调用）\n- 被调用者: [hid_get_drvdata, picolcd_raw_keypad, picolcd_raw_cir, spin_lock_irqsave, memcpy, complete, spin_unlock_irqrestore, picolcd_debug_raw_event]\n\n2. 函数名: hid_get_drvdata\n- 参数: [struct hid_device *hdev]\n- 调用者: picolcd_raw_event\n- 被调用者: []\n\n3. 函数名: picolcd_raw_keypad\n- 参数: [struct picolcd_data *data, struct hid_report *report, u8 *raw_data, int size]\n- 调用者: picolcd_raw_event\n- 被调用者: []\n\n4. 函数名: picolcd_raw_cir\n- 参数: [struct picolcd_data *data, struct hid_report *report, u8 *raw_data, int size]\n- 调用者: picolcd_raw_event\n- 被调用者: []\n\n5. 函数名: spin_lock_irqsave\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: picolcd_raw_event\n- 被调用者: []\n\n6. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: picolcd_raw_event\n- 被调用者: []\n\n7. 函数名: complete\n- 参数: [struct completion *x]\n- 调用者: picolcd_raw_event\n- 被调用者: []\n\n8. 函数名: spin_unlock_irqrestore\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: picolcd_raw_event\n- 被调用者: []\n\n9. 函数名: picolcd_debug_raw_event\n- 参数: [struct picolcd_data *data, struct hid_device *hdev, struct hid_report *report, u8 *raw_data, int size]\n- 调用者: picolcd_raw_event\n- 被调用者: []"
    },
    {
        "id": 581,
        "cwe": "CWE-119",
        "cve": "CVE-2014-6416",
        "purpose": "Code purpose:\"\"\"验证来自Ceph认证服务的授权回复消息的合法性，包括解密回复和检查nonce值是否正确\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对输入的auth ticket长度进行有效验证，导致缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ceph_x_verify_authorizer_reply\n- 参数: [struct ceph_auth_client *ac, struct ceph_authorizer *a, size_t len]\n- 调用者: 未显示\n- 被调用者: [get_ticket_handler, ceph_x_decrypt, le64_to_cpu]\n\n2. 函数名: get_ticket_handler\n- 参数: [struct ceph_auth_client *ac, au->service]\n- 调用者: ceph_x_verify_authorizer_reply\n- 被调用者: 未显示\n\n3. 函数名: ceph_x_decrypt\n- 参数: [&th->session_key, &p, end, &reply, sizeof(reply)]\n- 调用者: ceph_x_verify_authorizer_reply\n- 被调用者: 未显示\n\n4. 函数名: le64_to_cpu\n- 参数: [reply.nonce_plus_one]\n- 调用者: ceph_x_verify_authorizer_reply\n- 被调用者: 未显示"
    },
    {
        "id": 582,
        "cwe": "CWE-119",
        "cve": "CVE-2014-6416",
        "purpose": "Code purpose:\"\"\"处理来自Ceph认证服务器的票据回复，包括解码和验证票据信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理长认证票据时，由于未对输入数据进行有效长度检查，导致缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ceph_x_proc_ticket_reply\n- 参数: [struct ceph_auth_client *ac, struct ceph_crypto_key *secret, void *buf, void *end]\n- 调用者: 未显示（外部调用）\n- 被调用者: [kmalloc, kfree, ceph_decode_8_safe, ceph_decode_32_safe, process_one_ticket]\n\n2. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: [ceph_x_proc_ticket_reply]\n- 被调用者: 未显示（内核函数）\n\n3. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: [ceph_x_proc_ticket_reply]\n- 被调用者: 未显示（内核函数）\n\n4. 函数名: ceph_decode_8_safe\n- 参数: [void **p, void *end, u8 *v, label]\n- 调用者: [ceph_x_proc_ticket_reply]\n- 被调用者: 未显示（外部函数）\n\n5. 函数名: ceph_decode_32_safe\n- 参数: [void **p, void *end, u32 *v, label]\n- 调用者: [ceph_x_proc_ticket_reply]\n- 被调用者: 未显示（外部函数）\n\n6. 函数名: process_one_ticket\n- 参数: [struct ceph_auth_client *ac, struct ceph_crypto_key *secret, void **p, void *end, char *dbuf, char *ticket_buf]\n- 调用者: [ceph_x_proc_ticket_reply]\n- 被调用者: 未显示（外部函数）"
    },
    {
        "id": 622,
        "cwe": "CWE-119",
        "cve": "CVE-2014-8369",
        "purpose": "Code purpose:\"\"\"该代码用于在KVM虚拟化环境中将客户机的内存页映射到IOMMU域中，处理内存页的映射和错误情况\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理映射失败时，函数错误计算了需要取消映射的页面数量，导致可能解钉错误的页面或造成其他未指定影响\"\"\"",
        "functions": "Functions:\n1. 函数名: kvm_iommu_map_pages\n- 参数: [kvm, slot]\n- 调用者: 未显示（外部调用）\n- 被调用者: [iommu_iova_to_phys, gfn_to_gpa, kvm_host_page_size, __gfn_to_hva_memslot, kvm_pin_pages, is_error_noslot_pfn, iommu_map, pfn_to_hpa, kvm_unpin_pages, kvm_iommu_put_pages]\n\n2. 函数名: iommu_iova_to_phys\n- 参数: [domain, gfn_to_gpa(gfn)]\n- 调用者: kvm_iommu_map_pages\n- 被调用者: []\n\n3. 函数名: gfn_to_gpa\n- 参数: [gfn]\n- 调用者: kvm_iommu_map_pages\n- 被调用者: []\n\n4. 函数名: kvm_host_page_size\n- 参数: [kvm, gfn]\n- 调用者: kvm_iommu_map_pages\n- 被调用者: []\n\n5. 函数名: __gfn_to_hva_memslot\n- 参数: [slot, gfn]\n- 调用者: kvm_iommu_map_pages\n- 被调用者: []\n\n6. 函数名: kvm_pin_pages\n- 参数: [slot, gfn, page_size]\n- 调用者: kvm_iommu_map_pages\n- 被调用者: []\n\n7. 函数名: is_error_noslot_pfn\n- 参数: [pfn]\n- 调用者: kvm_iommu_map_pages\n- 被调用者: []\n\n8. 函数名: iommu_map\n- 参数: [domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn), page_size, flags]\n- 调用者: kvm_iommu_map_pages\n- 被调用者: []\n\n9. 函数名: pfn_to_hpa\n- 参数: [pfn]\n- 调用者: kvm_iommu_map_pages\n- 被调用者: []\n\n10. 函数名: kvm_unpin_pages\n- 参数: [kvm, pfn, page_size]\n- 调用者: kvm_iommu_map_pages\n- 被调用者: []\n\n11. 函数名: kvm_iommu_put_pages\n- 参数: [kvm, slot->base_gfn, gfn - slot->base_gfn]\n- 调用者: kvm_iommu_map_pages\n- 被调用者: []"
    },
    {
        "id": 676,
        "cwe": "CWE-119",
        "cve": "CVE-2014-8884",
        "purpose": "Code purpose:\"\"\"该代码用于处理DVB-S前端设备的DiSEqC主命令发送，将命令消息复制到缓冲区并通过配置的发送命令接口进行传输\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对cmd->msg_len进行边界检查，导致memcpy操作可能超出数组b的边界，造成栈缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: ttusbdecfe_dvbs_diseqc_send_master_cmd\n- 参数: [struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd]\n- 调用者: 外部调用（通过ioctl）\n- 被调用者: [memcpy, state->config->send_command]\n\n2. 函数名: memcpy\n- 参数: [void* dest, const void* src, size_t n]\n- 调用者: ttusbdecfe_dvbs_diseqc_send_master_cmd\n- 被调用者: []\n\n3. 函数名: send_command\n- 参数: [struct dvb_frontend* fe, u8 command, u16 param_length, u8* params, u32* result_length, u8* cmd_result]\n- 调用者: ttusbdecfe_dvbs_diseqc_send_master_cmd\n- 被调用者: []"
    },
    {
        "id": 693,
        "cwe": "CWE-119",
        "cve": "CVE-2014-9728",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中UDF文件系统的inode读取功能，用于处理文件系统中的元数据信息并构建内存中的inode结构\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中的UDF文件系统实现未对某些长度进行验证，导致可通过特制的文件系统映像触发缓冲区越界读取，造成系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: udf_read_inode\n- 参数: [struct inode *inode, bool hidden_inode]\n- 调用者: 未显示（通常是文件系统操作调用）\n- 被调用者: [udf_debug, udf_read_ptagged, udf_err, brelse, memcpy, udf_alloc_i_data, i_uid_write, i_gid_write, udf_convert_permissions, set_nlink, udf_disk_stamp_to_time, inc_nlink, init_special_inode, udf_get_extendedattr, le32_to_cpu, le16_to_cpu, le64_to_cpu, cpu_to_le16, MKDEV]\n\n2. 函数名: udf_read_ptagged\n- 参数: [struct super_block *sb, struct kernel_lb_addr *loc, int offset, uint16_t *ident]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n3. 函数名: udf_err\n- 参数: [struct super_block *sb, const char *fmt, ...]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n4. 函数名: udf_debug\n- 参数: [const char *fmt, ...]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n5. 函数名: udf_alloc_i_data\n- 参数: [struct inode *inode, int size]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n6. 函数名: udf_convert_permissions\n- 参数: [struct fileEntry *fe]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n7. 函数名: udf_disk_stamp_to_time\n- 参数: [struct timespec *dest, struct timestamp src]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n8. 函数名: udf_get_extendedattr\n- 参数: [struct inode *inode, int type, int subtype]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n9. 函数名: brelse\n- 参数: [struct buffer_head *bh]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n10. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n11. 函数名: i_uid_write\n- 参数: [struct inode *inode, uid_t uid]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n12. 函数名: i_gid_write\n- 参数: [struct inode *inode, gid_t gid]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n13. 函数名: set_nlink\n- 参数: [struct inode *inode, unsigned int nlink]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n14. 函数名: inc_nlink\n- 参数: [struct inode *inode]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n15. 函数名: init_special_inode\n- 参数: [struct inode *inode, umode_t mode, dev_t rdev]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n16. 函数名: le32_to_cpu\n- 参数: [__le32 val]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n17. 函数名: le16_to_cpu\n- 参数: [__le16 val]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n18. 函数名: le64_to_cpu\n- 参数: [__le64 val]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n19. 函数名: cpu_to_le16\n- 参数: [__u16 val]\n- 调用者: udf_read_inode\n- 被调用者: 未显示\n\n20. 函数名: MKDEV\n- 参数: [unsigned int major, unsigned int minor]\n- 调用者: udf_read_inode\n- 被调用者: 未显示"
    },
    {
        "id": 728,
        "cwe": "CWE-119",
        "cve": "CVE-2015-1333",
        "purpose": "Code purpose:\"\"\"在密钥环中完成密钥链接操作并释放相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在__key_link_end函数中，当edit存在且不是dead_leaf时，未能正确释放edit结构体导致内存泄漏\"\"\"",
        "functions": "Functions:\n1. 函数名: __key_link_end\n- 参数: [struct key *keyring, const struct keyring_index_key *index_key, struct assoc_array_edit *edit]\n- 调用者: 未明确（通常是keyring相关操作调用）\n- 被调用者: [kenter, up_write, key_payload_reserve, assoc_array_cancel_edit]\n\n2. 函数名: kenter\n- 参数: [格式化字符串, keyring->serial, index_key->type->name]\n- 调用者: __key_link_end\n- 被调用者: []\n\n3. 函数名: up_write\n- 参数: [&keyring_serialise_link_sem], [&keyring->sem]\n- 调用者: __key_link_end\n- 被调用者: []\n\n4. 函数名: key_payload_reserve\n- 参数: [keyring, keyring->datalen - KEYQUOTA_LINK_BYTES]\n- 调用者: __key_link_end\n- 被调用者: []\n\n5. 函数名: assoc_array_cancel_edit\n- 参数: [edit]\n- 调用者: __key_link_end\n- 被调用者: []"
    },
    {
        "id": 740,
        "cwe": "CWE-119",
        "cve": "CVE-2015-2666",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核启动早期阶段，根据CPU型号匹配并保存相应的微码更新补丁，以修复CPU漏洞或缺陷。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对mc_saved_tmp数组的索引进行边界检查，导致在_save_mc函数中可能发生栈缓冲区溢出，攻击者可利用特制的微代码头文件通过root权限提升权限。\"\"\"",
        "functions": "Functions:\n1. 函数名: get_matching_model_microcode\n- 参数: [cpu, start, data, size, mc_saved_data, mc_saved_in_initrd, uci]\n- 调用者: 未显示（外部调用）\n- 被调用者: [get_totalsize, microcode_sanity_check, matching_model_microcode, _save_mc]\n\n2. 函数名: get_totalsize\n- 参数: [mc_header]\n- 调用者: get_matching_model_microcode\n- 被调用者: []\n\n3. 函数名: microcode_sanity_check\n- 参数: [ucode_ptr, 0]\n- 调用者: get_matching_model_microcode\n- 被调用者: []\n\n4. 函数名: matching_model_microcode\n- 参数: [mc_header, uci->cpu_sig.sig]\n- 调用者: get_matching_model_microcode\n- 被调用者: []\n\n5. 函数名: _save_mc\n- 参数: [mc_saved_tmp, ucode_ptr, &mc_saved_count]\n- 调用者: get_matching_model_microcode\n- 被调用者: []"
    },
    {
        "id": 753,
        "cwe": "CWE-119",
        "cve": "CVE-2015-3214",
        "purpose": "Code purpose:\"\"\"该代码实现了从KVM虚拟机的PIT(可编程间隔定时器)读取端口数据的操作，包括处理状态锁存和计数锁存情况，并将读取的数据复制到输出缓冲区。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未正确验证输入的长度参数，导致可能使用无效索引访问内存，造成缓冲区溢出。\"\"\"",
        "functions": "Functions:\n1. 函数名: pit_ioport_read\n- 参数: [struct kvm_io_device *this, gpa_t addr, int len, void *data]\n- 调用者: 未明确（由KVM/QEMU的I/O端口读取机制调用）\n- 被调用者: [pit_in_range, dev_to_pit, mutex_lock, pit_get_count, memcpy, mutex_unlock]\n\n2. 函数名: pit_in_range\n- 参数: [gpa_t addr]\n- 调用者: pit_ioport_read\n- 被调用者: 未明确\n\n3. 函数名: dev_to_pit\n- 参数: [struct kvm_io_device *this]\n- 调用者: pit_ioport_read\n- 被调用者: 未明确\n\n4. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: pit_ioport_read\n- 被调用者: 未明确\n\n5. 函数名: pit_get_count\n- 参数: [struct kvm *kvm, int addr]\n- 调用者: pit_ioport_read\n- 被调用者: 未明确\n\n6. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: pit_ioport_read\n- 被调用者: 未明确\n\n7. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: pit_ioport_read\n- 被调用者: 未明确"
    },
    {
        "id": 757,
        "cwe": "CWE-119",
        "cve": "CVE-2015-3331",
        "purpose": "Code purpose:\"\"\"该代码实现了RFC4106标准的AES-GCM解密功能，用于处理加密数据的解密和认证。\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理加密数据时未正确计算关联数据(assoc)的内存位置，导致缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: __driver_rfc4106_decrypt\n- 参数: [struct aead_request *req]\n- 调用者: 未明确显示（由内核加密API调用）\n- 被调用者: [cpu_to_be32, crypto_aead_reqtfm, aesni_rfc4106_gcm_ctx_get, crypto_aead_authsize, PTR_ALIGN, scatterwalk_start, scatterwalk_map, sg_is_last, kmalloc, scatterwalk_map_and_copy, aesni_gcm_dec_tfm, crypto_memneq, scatterwalk_unmap, scatterwalk_done, kfree]\n\n2. 函数名: cpu_to_be32\n- 参数: [u32]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n3. 函数名: crypto_aead_reqtfm\n- 参数: [struct aead_request *]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n4. 函数名: aesni_rfc4106_gcm_ctx_get\n- 参数: [struct crypto_aead *]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n5. 函数名: crypto_aead_authsize\n- 参数: [struct crypto_aead *]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n6. 函数名: PTR_ALIGN\n- 参数: [u8 *, AESNI_ALIGN]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n7. 函数名: scatterwalk_start\n- 参数: [struct scatter_walk *, struct scatterlist *]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n8. 函数名: scatterwalk_map\n- 参数: [struct scatter_walk *]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n9. 函数名: sg_is_last\n- 参数: [struct scatterlist *]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n10. 函数名: kmalloc\n- 参数: [size_t, gfp_t]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n11. 函数名: scatterwalk_map_and_copy\n- 参数: [void *, struct scatterlist *, unsigned int, unsigned int, int]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n12. 函数名: aesni_gcm_dec_tfm\n- 参数: [void *, u8 *, u8 *, unsigned long, u8 *, u8 *, u8 *, unsigned long, u8 *, unsigned long]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n13. 函数名: crypto_memneq\n- 参数: [const void *, const void *, size_t]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n14. 函数名: scatterwalk_unmap\n- 参数: [void *]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n15. 函数名: scatterwalk_done\n- 参数: [struct scatter_walk *, int, int]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []\n\n16. 函数名: kfree\n- 参数: [const void *]\n- 调用者: __driver_rfc4106_decrypt\n- 被调用者: []"
    },
    {
        "id": 759,
        "cwe": "CWE-119",
        "cve": "CVE-2015-4002",
        "purpose": "Code purpose:\"\"\"处理USB设备接收到的数据包，包括描述符请求、配置设置、接口设置和端点数据传输等USB通信功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未对输入的elt->length进行充分验证，导致可能处理恶意构造的异常长度值，造成系统崩溃或任意代码执行\"\"\"",
        "functions": "Functions:\n1. 函数名: oz_usb_rx\n- 参数: [pd, elt]\n- 调用者: 未显示（外部调用）\n- 被调用者: [spin_lock_bh, oz_usb_get, spin_unlock_bh, le16_to_cpu, get_unaligned, oz_dbg, oz_hcd_get_desc_cnf, oz_hcd_control_cnf, oz_usb_handle_ep_data, oz_usb_put]\n\n2. 函数名: spin_lock_bh\n- 参数: [&pd->app_lock[OZ_APPID_USB]]\n- 调用者: oz_usb_rx\n- 被调用者: []\n\n3. 函数名: oz_usb_get\n- 参数: [usb_ctx]\n- 调用者: oz_usb_rx\n- 被调用者: []\n\n4. 函数名: spin_unlock_bh\n- 参数: [&pd->app_lock[OZ_APPID_USB]]\n- 调用者: oz_usb_rx\n- 被调用者: []\n\n5. 函数名: le16_to_cpu\n- 参数: [get_unaligned(&body->offset), get_unaligned(&body->total_size)]\n- 调用者: oz_usb_rx\n- 被调用者: []\n\n6. 函数名: get_unaligned\n- 参数: [&body->offset, &body->total_size]\n- 调用者: oz_usb_rx\n- 被调用者: []\n\n7. 函数名: oz_dbg\n- 参数: [ON, \"USB_REQ_GET_DESCRIPTOR - cnf\\n\"]\n- 调用者: oz_usb_rx\n- 被调用者: []\n\n8. 函数名: oz_hcd_get_desc_cnf\n- 参数: [usb_ctx->hport, body->req_id, body->rcode, body->data, data_len, offs, total_size]\n- 调用者: oz_usb_rx\n- 被调用者: []\n\n9. 函数名: oz_hcd_control_cnf\n- 参数: [usb_ctx->hport, body->req_id, body->rcode, NULL, 0] (多次调用)\n- 调用者: oz_usb_rx\n- 被调用者: []\n\n10. 函数名: oz_usb_handle_ep_data\n- 参数: [usb_ctx, usb_hdr, elt->length]\n- 调用者: oz_usb_rx\n- 被调用者: []\n\n11. 函数名: oz_usb_put\n- 参数: [usb_ctx]\n- 调用者: oz_usb_rx\n- 被调用者: []"
    },
    {
        "id": 761,
        "cwe": "CWE-119",
        "cve": "CVE-2015-4036",
        "purpose": "Code purpose:\"\"\"该代码用于在vhost_scsi驱动中创建并注册一个目标端口组(Target Portal Group, TPG)，处理用户提供的配置参数并初始化相关数据结构。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理VHOST_SCSI_SET_ENDPOINT ioctl调用时，vhost_scsi_make_tpg函数未能充分验证输入的'tpgt'参数，可能导致内存越界访问或内存损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: vhost_scsi_make_tpg\n- 参数: [struct se_wwn *wwn, struct config_group *group, const char *name]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [container_of, strstr, kstrtoul, kzalloc, pr_err, mutex_init, INIT_LIST_HEAD, core_tpg_register, kfree, mutex_lock, list_add_tail, mutex_unlock]\n\n2. 函数名: container_of\n- 参数: [未显示完整参数]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []\n\n3. 函数名: strstr\n- 参数: [const char *name, const char *\"tpgt_\"]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []\n\n4. 函数名: kstrtoul\n- 参数: [const char *name + 5, int 10, unsigned long *tpgt]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []\n\n5. 函数名: kzalloc\n- 参数: [sizeof(struct vhost_scsi_tpg), GFP_KERNEL]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []\n\n6. 函数名: pr_err\n- 参数: [const char *\"Unable to allocate struct vhost_scsi_tpg\"]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []\n\n7. 函数名: mutex_init\n- 参数: [&tpg->tv_tpg_mutex]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []\n\n8. 函数名: INIT_LIST_HEAD\n- 参数: [&tpg->tv_tpg_list]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []\n\n9. 函数名: core_tpg_register\n- 参数: [&vhost_scsi_fabric_configfs->tf_ops, wwn, &tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []\n\n10. 函数名: kfree\n- 参数: [tpg]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []\n\n11. 函数名: mutex_lock\n- 参数: [&vhost_scsi_mutex]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []\n\n12. 函数名: list_add_tail\n- 参数: [&tpg->tv_tpg_list, &vhost_scsi_list]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []\n\n13. 函数名: mutex_unlock\n- 参数: [&vhost_scsi_mutex]\n- 调用者: vhost_scsi_make_tpg\n- 被调用者: []"
    },
    {
        "id": 762,
        "cwe": "CWE-119",
        "cve": "CVE-2015-4036",
        "purpose": "Code purpose:\"\"\"该代码用于在vhost-scsi驱动中处理并发送SCSI事件通知，包括设置LUN信息并将其添加到事件列表中以供后续处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对lun->unpacked_lun的值进行充分验证，可能导致数组越界访问，造成内存损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: vhost_scsi_send_evt\n- 参数: [struct vhost_scsi *vs, struct vhost_scsi_tpg *tpg, struct se_lun *lun, u32 event, u32 reason]\n- 调用者: 未明确显示（由外部调用）\n- 被调用者: [vhost_scsi_allocate_evt, llist_add, vhost_work_queue]\n\n2. 函数名: vhost_scsi_allocate_evt\n- 参数: [struct vhost_scsi *vs, u32 event, u32 reason]\n- 调用者: vhost_scsi_send_evt\n- 被调用者: 未明确显示\n\n3. 函数名: llist_add\n- 参数: [&evt->list, &vs->vs_event_list]\n- 调用者: vhost_scsi_send_evt\n- 被调用者: 未明确显示\n\n4. 函数名: vhost_work_queue\n- 参数: [&vs->dev, &vs->vs_event_work]\n- 调用者: vhost_scsi_send_evt\n- 被调用者: 未明确显示"
    },
    {
        "id": 772,
        "cwe": "CWE-119",
        "cve": "CVE-2015-5156",
        "purpose": "Code purpose:\"\"\"该代码实现了virtio网络设备的探测和初始化功能，包括设备特性验证、网络设备分配、队列设置、特性协商和缓冲区管理等，用于支持虚拟化环境中的网络通信。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"virtnet_probe函数在支持FRAGLIST特性时未正确分配内存，导致恶意构造的分片数据包可能引发缓冲区溢出和内存破坏\"\"\"",
        "functions": "Functions:\n1. 函数名: virtnet_probe\n- 参数: [struct virtio_device *vdev]\n- 调用者: 内核驱动框架\n- 被调用者: [virtnet_validate_features, virtio_cread_feature, virtio_has_feature, alloc_etherdev_mq, eth_hw_addr_random, netdev_priv, alloc_percpu, per_cpu_ptr, u64_stats_init, INIT_WORK, init_vqs, register_netdev, virtio_device_ready, try_fill_recv, virtqueue_get_vring_size, free_unused_bufs, register_hotcpu_notifier, schedule_work, free_receive_bufs, unregister_netdev, cancel_delayed_work_sync, free_receive_page_frags, virtnet_del_vqs, free_percpu, free_netdev]\n\n2. 函数名: virtnet_validate_features\n- 参数: [struct virtio_device *vdev]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n3. 函数名: virtio_cread_feature\n- 参数: [struct virtio_device *vdev, unsigned int fbit, struct virtio_net_config, max_virtqueue_pairs, u16 *val]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n4. 函数名: virtio_has_feature\n- 参数: [struct virtio_device *vdev, unsigned int fbit]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n5. 函数名: alloc_etherdev_mq\n- 参数: [int sizeof_priv, unsigned int queue_count]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n6. 函数名: eth_hw_addr_random\n- 参数: [struct net_device *dev]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n7. 函数名: netdev_priv\n- 参数: [const struct net_device *dev]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n8. 函数名: alloc_percpu\n- 参数: [type]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n9. 函数名: per_cpu_ptr\n- 参数: [const void *ptr, int cpu]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n10. 函数名: u64_stats_init\n- 参数: [struct u64_stats_sync *syncp]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n11. 函数名: INIT_WORK\n- 参数: [struct work_struct *work, work_func_t func]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n12. 函数名: init_vqs\n- 参数: [struct virtnet_info *vi]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n13. 函数名: register_netdev\n- 参数: [struct net_device *dev]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n14. 函数名: virtio_device_ready\n- 参数: [struct virtio_device *dev]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n15. 函数名: try_fill_recv\n- 参数: [struct virtnet_info *vi, struct receive_queue *rq, gfp_t gfp]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n16. 函数名: virtqueue_get_vring_size\n- 参数: [struct virtqueue *vq]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n17. 函数名: free_unused_bufs\n- 参数: [struct virtnet_info *vi]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n18. 函数名: register_hotcpu_notifier\n- 参数: [struct notifier_block *nb]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n19. 函数名: schedule_work\n- 参数: [struct work_struct *work]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n20. 函数名: free_receive_bufs\n- 参数: [struct virtnet_info *vi]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n21. 函数名: unregister_netdev\n- 参数: [struct net_device *dev]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n22. 函数名: cancel_delayed_work_sync\n- 参数: [struct delayed_work *work]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n23. 函数名: free_receive_page_frags\n- 参数: [struct virtnet_info *vi]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n24. 函数名: virtnet_del_vqs\n- 参数: [struct virtnet_info *vi]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n25. 函数名: free_percpu\n- 参数: [void *__pdata]\n- 调用者: virtnet_probe\n- 被调用者: []\n\n26. 函数名: free_netdev\n- 参数: [struct net_device *dev]\n- 调用者: virtnet_probe\n- 被调用者: []"
    },
    {
        "id": 773,
        "cwe": "CWE-119",
        "cve": "CVE-2015-5283",
        "purpose": "Code purpose:\"\"\"初始化SCTP协议栈，包括分配内存、创建哈希表、设置系统参数等，以支持SCTP套接字通信功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"SCTP协议初始化步骤顺序不正确，在未完成所有初始化步骤前就允许创建SCTP套接字，导致本地用户可能引发拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: sctp_init\n- 参数: [void]\n- 调用者: 内核初始化\n- 被调用者: [kmem_cache_create, percpu_counter_init, idr_init, max, min, sysctl_sctp_register, INIT_LIST_HEAD, sctp_v4_pf_init, sctp_v6_pf_init, sctp_v4_protosw_init, sctp_v6_protosw_init, register_pernet_subsys, sctp_v4_add_protocol, sctp_v6_add_protocol, sctp_v4_del_protocol, unregister_pernet_subsys, sctp_v6_protosw_exit, sctp_v4_protosw_exit, sctp_v4_pf_exit, sctp_v6_pf_exit, sctp_sysctl_unregister, free_pages, kfree, percpu_counter_destroy, kmem_cache_destroy]\n\n2. 函数名: kmem_cache_create\n- 参数: [\"sctp_bind_bucket\", sizeof(struct sctp_bind_bucket), 0, SLAB_HWCACHE_ALIGN, NULL]\n- 调用者: sctp_init\n- 被调用者: []\n\n3. 函数名: percpu_counter_init\n- 参数: [&sctp_sockets_allocated, 0, GFP_KERNEL]\n- 调用者: sctp_init\n- 被调用者: []\n\n4. 函数名: idr_init\n- 参数: [&sctp_assocs_id]\n- 调用者: sctp_init\n- 被调用者: []\n\n5. 函数名: max\n- 参数: [limit, 128UL]\n- 调用者: sctp_init\n- 被调用者: []\n\n6. 函数名: min\n- 参数: [4UL*1024*1024, limit]\n- 调用者: sctp_init\n- 被调用者: []\n\n7. 函数名: sysctl_sctp_register\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n8. 函数名: INIT_LIST_HEAD\n- 参数: [&sctp_address_families]\n- 调用者: sctp_init\n- 被调用者: []\n\n9. 函数名: sctp_v4_pf_init\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n10. 函数名: sctp_v6_pf_init\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n11. 函数名: sctp_v4_protosw_init\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n12. 函数名: sctp_v6_protosw_init\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n13. 函数名: register_pernet_subsys\n- 参数: [&sctp_net_ops]\n- 调用者: sctp_init\n- 被调用者: []\n\n14. 函数名: sctp_v4_add_protocol\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n15. 函数名: sctp_v6_add_protocol\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n16. 函数名: sctp_v4_del_protocol\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n17. 函数名: unregister_pernet_subsys\n- 参数: [&sctp_net_ops]\n- 调用者: sctp_init\n- 被调用者: []\n\n18. 函数名: sctp_v6_protosw_exit\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n19. 函数名: sctp_v4_protosw_exit\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n20. 函数名: sctp_v4_pf_exit\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n21. 函数名: sctp_v6_pf_exit\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n22. 函数名: sctp_sysctl_unregister\n- 参数: []\n- 调用者: sctp_init\n- 被调用者: []\n\n23. 函数名: free_pages\n- 参数: [(unsigned long)sctp_port_hashtable, get_order(sctp_port_hashsize * sizeof(struct sctp_bind_hashbucket))]\n- 调用者: sctp_init\n- 被调用者: []\n\n24. 函数名: kfree\n- 参数: [sctp_ep_hashtable]\n- 调用者: sctp_init\n- 被调用者: []\n\n25. 函数名: percpu_counter_destroy\n- 参数: [&sctp_sockets_allocated]\n- 调用者: sctp_init\n- 被调用者: []\n\n26. 函数名: kmem_cache_destroy\n- 参数: [sctp_chunk_cachep]\n- 调用者: sctp_init\n- 被调用者: []"
    },
    {
        "id": 774,
        "cwe": "CWE-119",
        "cve": "CVE-2015-5283",
        "purpose": "Code purpose:\"\"\"该代码片段实现了SCTP协议栈的退出清理功能，包括注销协议处理、释放内存资源和销毁缓存等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"SCTP协议初始化步骤顺序不正确，导致在初始化完成前创建SCTP套接字可能引发拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: sctp_exit\n- 参数: [void]\n- 调用者: 无（静态函数，__exit修饰）\n- 被调用者: [sctp_v6_del_protocol, sctp_v4_del_protocol, unregister_pernet_subsys, sctp_v6_protosw_exit, sctp_v4_protosw_exit, sctp_v6_pf_exit, sctp_v4_pf_exit, sctp_sysctl_unregister, free_pages, get_order, kfree, percpu_counter_destroy, rcu_barrier, kmem_cache_destroy]\n\n2. 函数名: sctp_v6_del_protocol\n- 参数: []\n- 调用者: sctp_exit\n- 被调用者: []\n\n3. 函数名: sctp_v4_del_protocol\n- 参数: []\n- 调用者: sctp_exit\n- 被调用者: []\n\n4. 函数名: unregister_pernet_subsys\n- 参数: [&sctp_net_ops]\n- 调用者: sctp_exit\n- 被调用者: []\n\n5. 函数名: sctp_v6_protosw_exit\n- 参数: []\n- 调用者: sctp_exit\n- 被调用者: []\n\n6. 函数名: sctp_v4_protosw_exit\n- 参数: []\n- 调用者: sctp_exit\n- 被调用者: []\n\n7. 函数名: sctp_v6_pf_exit\n- 参数: []\n- 调用者: sctp_exit\n- 被调用者: []\n\n8. 函数名: sctp_v4_pf_exit\n- 参数: []\n- 调用者: sctp_exit\n- 被调用者: []\n\n9. 函数名: sctp_sysctl_unregister\n- 参数: []\n- 调用者: sctp_exit\n- 被调用者: []\n\n10. 函数名: free_pages\n- 参数: [(unsigned long)sctp_assoc_hashtable, get_order(...)]\n- 调用者: sctp_exit\n- 被调用者: []\n\n11. 函数名: get_order\n- 参数: [sctp_assoc_hashsize * sizeof(struct sctp_hashbucket)]\n- 调用者: sctp_exit\n- 被调用者: []\n\n12. 函数名: kfree\n- 参数: [sctp_ep_hashtable]\n- 调用者: sctp_exit\n- 被调用者: []\n\n13. 函数名: free_pages\n- 参数: [(unsigned long)sctp_port_hashtable, get_order(...)]\n- 调用者: sctp_exit\n- 被调用者: []\n\n14. 函数名: get_order\n- 参数: [sctp_port_hashsize * sizeof(struct sctp_bind_hashbucket)]\n- 调用者: sctp_exit\n- 被调用者: []\n\n15. 函数名: percpu_counter_destroy\n- 参数: [&sctp_sockets_allocated]\n- 调用者: sctp_exit\n- 被调用者: []\n\n16. 函数名: rcu_barrier\n- 参数: []\n- 调用者: sctp_exit\n- 被调用者: []\n\n17. 函数名: kmem_cache_destroy\n- 参数: [sctp_chunk_cachep]\n- 调用者: sctp_exit\n- 被调用者: []\n\n18. 函数名: kmem_cache_destroy\n- 参数: [sctp_bucket_cachep]\n- 调用者: sctp_exit\n- 被调用者: []"
    },
    {
        "id": 897,
        "cwe": "CWE-119",
        "cve": "CVE-2016-10154",
        "purpose": "Code purpose:\"\"\"该代码片段实现了SMB协议中的密码哈希加密功能，使用DES算法对输入数据进行加密处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，smbhash函数使用的scatterlist可能跨越多个虚拟页面，导致系统崩溃或内存损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: smbhash\n- 参数: [out, in, key]\n- 调用者: 未指定\n- 被调用者: [str_to_key, crypto_alloc_skcipher, skcipher_request_alloc, crypto_skcipher_setkey, sg_init_one, skcipher_request_set_callback, skcipher_request_set_crypt, crypto_skcipher_encrypt, skcipher_request_free, crypto_free_skcipher]\n\n2. 函数名: str_to_key\n- 参数: [key, key2]\n- 调用者: smbhash\n- 被调用者: 未指定\n\n3. 函数名: crypto_alloc_skcipher\n- 参数: [\"ecb(des)\", 0, CRYPTO_ALG_ASYNC]\n- 调用者: smbhash\n- 被调用者: 未指定\n\n4. 函数名: skcipher_request_alloc\n- 参数: [tfm_des, GFP_KERNEL]\n- 调用者: smbhash\n- 被调用者: 未指定\n\n5. 函数名: crypto_skcipher_setkey\n- 参数: [tfm_des, key2, 8]\n- 调用者: smbhash\n- 被调用者: 未指定\n\n6. 函数名: sg_init_one\n- 参数: [&sgin, in, 8]\n- 调用者: smbhash\n- 被调用者: 未指定\n\n7. 函数名: sg_init_one\n- 参数: [&sgout, out, 8]\n- 调用者: smbhash\n- 被调用者: 未指定\n\n8. 函数名: skcipher_request_set_callback\n- 参数: [req, 0, NULL, NULL]\n- 调用者: smbhash\n- 被调用者: 未指定\n\n9. 函数名: skcipher_request_set_crypt\n- 参数: [req, &sgin, &sgout, 8, NULL]\n- 调用者: smbhash\n- 被调用者: 未指定\n\n10. 函数名: crypto_skcipher_encrypt\n- 参数: [req]\n- 调用者: smbhash\n- 被调用者: 未指定\n\n11. 函数名: skcipher_request_free\n- 参数: [req]\n- 调用者: smbhash\n- 被调用者: 未指定\n\n12. 函数名: crypto_free_skcipher\n- 参数: [tfm_des]\n- 调用者: smbhash\n- 被调用者: 未指定"
    },
    {
        "id": 906,
        "cwe": "CWE-119",
        "cve": "CVE-2016-10764",
        "purpose": "Code purpose:\"\"\"该代码用于设置和管理SPI NOR闪存设备，包括初始化闪存参数、注册MTD设备以及处理芯片选择逻辑。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"数组索引越界漏洞，由于使用'>'而不是'>='来检查芯片选择值，导致可以访问超出数组边界的一个元素\"\"\"",
        "functions": "Functions:\n1. 函数名: cqspi_setup_flash\n- 参数: [struct cqspi_st *cqspi, struct device_node *np]\n- 调用者: 未显示（外部调用）\n- 被调用者: [of_property_read_u32, dev_err, cqspi_of_get_flash_pdata, spi_nor_set_flash_node, devm_kasprintf, spi_nor_scan, mtd_device_register, mtd_device_unregister]\n\n2. 函数名: of_property_read_u32\n- 参数: [struct device_node *np, const char *propname, u32 *out_value]\n- 调用者: cqspi_setup_flash\n- 被调用者: 未显示（内核API）\n\n3. 函数名: dev_err\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: cqspi_setup_flash\n- 被调用者: 未显示（内核API）\n\n4. 函数名: cqspi_of_get_flash_pdata\n- 参数: [struct platform_device *pdev, struct cqspi_flash_pdata *f_pdata, struct device_node *np]\n- 调用者: cqspi_setup_flash\n- 被调用者: 未显示（外部函数）\n\n5. 函数名: spi_nor_set_flash_node\n- 参数: [struct spi_nor *nor, struct device_node *np]\n- 调用者: cqspi_setup_flash\n- 被调用者: 未显示（外部函数）\n\n6. 函数名: devm_kasprintf\n- 参数: [struct device *dev, gfp_t gfp, const char *fmt, ...]\n- 调用者: cqspi_setup_flash\n- 被调用者: 未显示（内核API）\n\n7. 函数名: spi_nor_scan\n- 参数: [struct spi_nor *nor, const char *name, enum spi_nor_protocol proto]\n- 调用者: cqspi_setup_flash\n- 被调用者: 未显示（外部函数）\n\n8. 函数名: mtd_device_register\n- 参数: [struct mtd_info *mtd, const char * const *part_probe_types, struct mtd_part_parser_data *parser_data]\n- 调用者: cqspi_setup_flash\n- 被调用者: 未显示（内核API）\n\n9. 函数名: mtd_device_unregister\n- 参数: [struct mtd_info *master]\n- 调用者: cqspi_setup_flash\n- 被调用者: 未显示（内核API）"
    },
    {
        "id": 914,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1583",
        "purpose": "Code purpose:\"\"\"该代码实现了proc文件系统的挂载功能，包括权限检查、选项解析和超级块初始化等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确处理/proc路径名的mmap调用导致的递归页面错误处理，可能引发权限提升或拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: proc_mount\n- 参数: [struct file_system_type *fs_type, int flags, const char *dev_name, void *data]\n- 调用者: 未显示（应为文件系统挂载相关调用）\n- 被调用者: [task_active_pid_ns, ns_capable, sget, IS_ERR, ERR_CAST, proc_parse_options, deactivate_locked_super, ERR_PTR, proc_fill_super, dget]\n\n2. 函数名: task_active_pid_ns\n- 参数: [struct task_struct *current]\n- 调用者: proc_mount\n- 被调用者: []\n\n3. 函数名: ns_capable\n- 参数: [struct user_namespace *user_ns, int CAP_SYS_ADMIN]\n- 调用者: proc_mount\n- 被调用者: []\n\n4. 函数名: sget\n- 参数: [struct file_system_type *fs_type, proc_test_super, proc_set_super, int flags, struct pid_namespace *ns]\n- 调用者: proc_mount\n- 被调用者: []\n\n5. 函数名: IS_ERR\n- 参数: [struct super_block *sb]\n- 调用者: proc_mount\n- 被调用者: []\n\n6. 函数名: ERR_CAST\n- 参数: [struct super_block *sb]\n- 调用者: proc_mount\n- 被调用者: []\n\n7. 函数名: proc_parse_options\n- 参数: [char *options, struct pid_namespace *ns]\n- 调用者: proc_mount\n- 被调用者: []\n\n8. 函数名: deactivate_locked_super\n- 参数: [struct super_block *sb]\n- 调用者: proc_mount\n- 被调用者: []\n\n9. 函数名: ERR_PTR\n- 参数: [int err]\n- 调用者: proc_mount\n- 被调用者: []\n\n10. 函数名: proc_fill_super\n- 参数: [struct super_block *sb]\n- 调用者: proc_mount\n- 被调用者: []\n\n11. 函数名: dget\n- 参数: [struct dentry *sb->s_root]\n- 调用者: proc_mount\n- 被调用者: []"
    },
    {
        "id": 962,
        "cwe": "CWE-119",
        "cve": "CVE-2016-3134",
        "purpose": "Code purpose:\"\"\"验证和设置netfilter子系统中的ARP表条目，包括检查偏移量、钩子位置和下溢条件，以确保内存安全和规则有效性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统未充分验证arpt_entry结构中的next_offset字段，导致可通过IPT_SO_SET_REPLACE setsockopt调用触发堆内存破坏\"\"\"",
        "functions": "Functions:\n1. 函数名: check_entry_size_and_hooks\n- 参数: [struct arpt_entry *e, struct xt_table_info *newinfo, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, unsigned int valid_hooks]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [check_entry, check_underflow]\n\n2. 函数名: check_entry\n- 参数: [struct arpt_entry *e]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: 未显示\n\n3. 函数名: check_underflow\n- 参数: [struct arpt_entry *e]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: 未显示"
    },
    {
        "id": 963,
        "cwe": "CWE-119",
        "cve": "CVE-2016-3134",
        "purpose": "Code purpose:\"\"\"检查ARP表条目是否会导致下溢，防止内存损坏\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统中未对偏移量字段进行充分验证，导致通过IPT_SO_SET_REPLACE setsockopt调用可造成堆内存破坏\"\"\"",
        "functions": "Functions:\n1. 函数名: check_underflow\n- 参数: [const struct arpt_entry *e]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [unconditional, arpt_get_target_c, strcmp]\n\n2. 函数名: unconditional\n- 参数: [const struct arpt_entry *e]\n- 调用者: check_underflow\n- 被调用者: []\n\n3. 函数名: arpt_get_target_c\n- 参数: [const struct arpt_entry *e]\n- 调用者: check_underflow\n- 被调用者: []\n\n4. 函数名: strcmp\n- 参数: [const char *s1, const char *s2]\n- 调用者: check_underflow\n- 被调用者: []"
    },
    {
        "id": 964,
        "cwe": "CWE-119",
        "cve": "CVE-2016-3134",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的netfilter子系统中标记ARP表规则链的源路径，处理规则跳转和回溯，但未充分验证偏移字段导致安全漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统中未对某些偏移字段进行充分验证，导致通过IPT_SO_SET_REPLACE setsockopt调用可造成堆内存破坏\"\"\"",
        "functions": "Functions:\n1. 函数名: mark_source_chains\n- 参数: [const struct xt_table_info *newinfo, unsigned int valid_hooks, void *entry0]\n- 调用者: 未明确（由内核调用）\n- 被调用者: [arpt_get_target_c, unconditional, strcmp, duprintf, pr_notice]\n\n2. 函数名: arpt_get_target_c\n- 参数: [struct arpt_entry *e]\n- 调用者: mark_source_chains\n- 被调用者: 未明确\n\n3. 函数名: unconditional\n- 参数: [struct arpt_entry *e]\n- 调用者: mark_source_chains\n- 被调用者: 未明确\n\n4. 函数名: strcmp\n- 参数: [const char *s1, const char *s2]\n- 调用者: mark_source_chains\n- 被调用者: 未明确\n\n5. 函数名: duprintf\n- 参数: [const char *format, ...]\n- 调用者: mark_source_chains\n- 被调用者: 未明确\n\n6. 函数名: pr_notice\n- 参数: [const char *format, ...]\n- 调用者: mark_source_chains\n- 被调用者: 未明确"
    },
    {
        "id": 965,
        "cwe": "CWE-119",
        "cve": "CVE-2016-3134",
        "purpose": "Code purpose:\"\"\"验证ipt_entry结构体的偏移量和钩子设置，防止内存越界和非法访问\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统中未充分验证ipt_entry结构体的next_offset字段，导致可通过IPT_SO_SET_REPLACE setsockopt调用触发堆内存破坏\"\"\"",
        "functions": "Functions:\n1. 函数名: check_entry_size_and_hooks\n- 参数: [struct ipt_entry *e, struct xt_table_info *newinfo, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, unsigned int valid_hooks]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [check_entry, check_underflow]\n\n2. 函数名: check_entry\n- 参数: [struct ipt_entry *e]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: 未显示\n\n3. 函数名: check_underflow\n- 参数: [struct ipt_entry *e]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: 未显示"
    },
    {
        "id": 966,
        "cwe": "CWE-119",
        "cve": "CVE-2016-3134",
        "purpose": "Code purpose:\"\"\"该代码用于处理iptables规则链中的链名和规则编号，并在特定条件下设置注释信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统未验证某些偏移字段，导致通过IPT_SO_SET_REPLACE setsockopt调用可造成堆内存破坏\"\"\"",
        "functions": "Functions:\n1. 函数名: get_chainname_rulenum\n- 参数: [const struct ipt_entry *s, const struct ipt_entry *e, const char *hookname, const char **chainname, const char **comment, unsigned int *rulenum]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [ipt_get_target_c, strcmp, unconditional]\n\n2. 函数名: ipt_get_target_c\n- 参数: [const struct ipt_entry *s]\n- 调用者: get_chainname_rulenum\n- 被调用者: 未显示\n\n3. 函数名: strcmp\n- 参数: [const char *s1, const char *s2]\n- 调用者: get_chainname_rulenum\n- 被调用者: 未显示\n\n4. 函数名: unconditional\n- 参数: [const struct ipt_entry *s]\n- 调用者: get_chainname_rulenum\n- 被调用者: 未显示"
    },
    {
        "id": 967,
        "cwe": "CWE-119",
        "cve": "CVE-2016-3134",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的netfilter子系统中标记和验证iptables规则链的源跳转关系，防止规则循环并确保跳转目标的有效性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统中未对某些偏移字段进行充分验证，导致通过IPT_SO_SET_REPLACE setsockopt调用可造成堆内存破坏\"\"\"",
        "functions": "Functions:\n1. 函数名: mark_source_chains\n- 参数: [const struct xt_table_info *newinfo, unsigned int valid_hooks, void *entry0]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [ipt_get_target_c, unconditional, strcmp, duprintf, pr_err]\n\n2. 函数名: ipt_get_target_c\n- 参数: [struct ipt_entry *e]\n- 调用者: mark_source_chains\n- 被调用者: 未显示\n\n3. 函数名: unconditional\n- 参数: [struct ipt_entry *e]\n- 调用者: mark_source_chains\n- 被调用者: 未显示\n\n4. 函数名: strcmp\n- 参数: [const char *s1, const char *s2]\n- 调用者: mark_source_chains\n- 被调用者: 未显示\n\n5. 函数名: duprintf\n- 参数: [const char *format, ...]\n- 调用者: mark_source_chains\n- 被调用者: 未显示\n\n6. 函数名: pr_err\n- 参数: [const char *format, ...]\n- 调用者: mark_source_chains\n- 被调用者: 未显示"
    },
    {
        "id": 968,
        "cwe": "CWE-119",
        "cve": "CVE-2016-3134",
        "purpose": "Code purpose:\"\"\"检查iptables规则条目是否会导致下溢，防止内存损坏\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统中未对偏移量字段进行充分验证，导致通过IPT_SO_SET_REPLACE setsockopt调用可造成堆内存破坏\"\"\"",
        "functions": "Functions:\n1. 函数名: check_underflow\n- 参数: [const struct ipt_entry *e]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [unconditional, ipt_get_target_c, strcmp]\n\n2. 函数名: unconditional\n- 参数: [const struct ipt_entry *e]\n- 调用者: check_underflow\n- 被调用者: []\n\n3. 函数名: ipt_get_target_c\n- 参数: [const struct ipt_entry *e]\n- 调用者: check_underflow\n- 被调用者: []\n\n4. 函数名: strcmp\n- 参数: [const char *s1, const char *s2]\n- 调用者: check_underflow\n- 被调用者: []"
    },
    {
        "id": 969,
        "cwe": "CWE-119",
        "cve": "CVE-2016-3134",
        "purpose": "Code purpose:\"\"\"该代码用于处理IPv6防火墙规则链中的链名和规则编号，并检查特定目标类型以确定链的头部或尾部\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统未验证某些偏移字段，导致通过IPT_SO_SET_REPLACE setsockopt调用可造成堆内存破坏\"\"\"",
        "functions": "Functions:\n1. 函数名: get_chainname_rulenum\n- 参数: [const struct ip6t_entry *s, const struct ip6t_entry *e, const char *hookname, const char **chainname, const char **comment, unsigned int *rulenum]\n- 调用者: 未显示\n- 被调用者: [ip6t_get_target_c, strcmp, unconditional]\n\n2. 函数名: ip6t_get_target_c\n- 参数: [const struct ip6t_entry *s]\n- 调用者: get_chainname_rulenum\n- 被调用者: 未显示\n\n3. 函数名: strcmp\n- 参数: [const char *str1, const char *str2]\n- 调用者: get_chainname_rulenum\n- 被调用者: 未显示\n\n4. 函数名: unconditional\n- 参数: [const struct ip6t_entry *s]\n- 调用者: get_chainname_rulenum\n- 被调用者: 未显示"
    },
    {
        "id": 970,
        "cwe": "CWE-119",
        "cve": "CVE-2016-3134",
        "purpose": "Code purpose:\"\"\"检查IPv6数据包是否满足无条件规则并验证目标裁决是否为NF_DROP或NF_ACCEPT\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统中未对偏移字段进行充分验证，导致通过IPT_SO_SET_REPLACE setsockopt调用可造成堆内存破坏\"\"\"",
        "functions": "Functions:\n1. 函数名: check_underflow\n- 参数: [const struct ip6t_entry *e]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [unconditional, ip6t_get_target_c, strcmp]\n\n2. 函数名: unconditional\n- 参数: [const struct ip6t_entry *e]\n- 调用者: check_underflow\n- 被调用者: []\n\n3. 函数名: ip6t_get_target_c\n- 参数: [const struct ip6t_entry *e]\n- 调用者: check_underflow\n- 被调用者: []\n\n4. 函数名: strcmp\n- 参数: [const char *s1, const char *s2]\n- 调用者: check_underflow\n- 被调用者: []"
    },
    {
        "id": 971,
        "cwe": "CWE-119",
        "cve": "CVE-2016-3134",
        "purpose": "Code purpose:\"\"\"验证IP6表条目的大小和钩子位置，防止内存越界和无效偏移\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统中未充分验证IP6t_entry结构体的next_offset字段，导致可通过精心构造的IPT_SO_SET_REPLACE setsockopt调用触发堆内存破坏\"\"\"",
        "functions": "Functions:\n1. 函数名: check_entry_size_and_hooks\n- 参数: [struct ip6t_entry *e, struct xt_table_info *newinfo, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, unsigned int valid_hooks]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [check_entry, check_underflow]\n\n2. 函数名: check_entry\n- 参数: [struct ip6t_entry *e]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: 未显示\n\n3. 函数名: check_underflow\n- 参数: [struct ip6t_entry *e]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: 未显示"
    },
    {
        "id": 972,
        "cwe": "CWE-119",
        "cve": "CVE-2016-3134",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的netfilter子系统中标记和验证iptables规则链的源路径，防止规则循环并确保规则跳转的有效性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统中未正确验证偏移字段，导致通过IPT_SO_SET_REPLACE setsockopt调用可造成堆内存破坏\"\"\"",
        "functions": "Functions:\n1. 函数名: mark_source_chains\n- 参数: [const struct xt_table_info *newinfo, unsigned int valid_hooks, void *entry0]\n- 调用者: 未显示（由内核调用）\n- 被调用者: [ip6t_get_target_c, strcmp, unconditional, duprintf, pr_err]\n\n2. 函数名: ip6t_get_target_c\n- 参数: [struct ip6t_entry *e]\n- 调用者: mark_source_chains\n- 被调用者: 未显示\n\n3. 函数名: strcmp\n- 参数: [const char *s1, const char *s2]\n- 调用者: mark_source_chains\n- 被调用者: 未显示\n\n4. 函数名: unconditional\n- 参数: [struct ip6t_entry *e]\n- 调用者: mark_source_chains\n- 被调用者: 未显示\n\n5. 函数名: duprintf\n- 参数: [const char *format, ...]\n- 调用者: mark_source_chains\n- 被调用者: 未显示\n\n6. 函数名: pr_err\n- 参数: [const char *format, ...]\n- 调用者: mark_source_chains\n- 被调用者: 未显示"
    },
    {
        "id": 1013,
        "cwe": "CWE-119",
        "cve": "CVE-2016-3955",
        "purpose": "Code purpose:\"\"\"该代码用于在USB/IP协议中接收传输缓冲区数据，根据传输方向验证并处理接收到的数据长度\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证USB/IP数据包中的长度字段，导致可能发生越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: usbip_recv_xbuff\n- 参数: [struct usbip_device *ud, struct urb *urb]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [usb_pipein, usb_pipeout, usbip_recv, dev_err, usbip_event_add]\n\n2. 函数名: usb_pipein\n- 参数: [urb->pipe]\n- 调用者: usbip_recv_xbuff\n- 被调用者: []\n\n3. 函数名: usb_pipeout\n- 参数: [urb->pipe]\n- 调用者: usbip_recv_xbuff\n- 被调用者: []\n\n4. 函数名: usbip_recv\n- 参数: [ud->tcp_socket, urb->transfer_buffer, size]\n- 调用者: usbip_recv_xbuff\n- 被调用者: []\n\n5. 函数名: dev_err\n- 参数: [&urb->dev->dev, \"recv xbuf, %d\\n\", ret]\n- 调用者: usbip_recv_xbuff\n- 被调用者: []\n\n6. 函数名: usbip_event_add\n- 参数: [ud, SDEV_EVENT_ERROR_TCP] 或 [ud, VDEV_EVENT_ERROR_TCP]\n- 调用者: usbip_recv_xbuff\n- 被调用者: []"
    },
    {
        "id": 1045,
        "cwe": "CWE-119",
        "cve": "CVE-2016-4998",
        "purpose": "Code purpose:\"\"\"检查兼容性ARP表条目的大小和钩子函数，确保其符合规范并正确设置相关偏移量和目标信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核在处理IPT_SO_SET_REPLACE套接字选项时，未充分验证用户提供的偏移量，导致可以越界读取内核堆内存数据。\"\"\"",
        "functions": "Functions:\n1. 函数名: check_compat_entry_size_and_hooks\n- 参数: [struct compat_arpt_entry *e, struct xt_table_info *newinfo, unsigned int *size, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, const char *name]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [duprintf, arp_checkentry, xt_compat_check_entry_offsets, compat_arpt_get_target, xt_request_find_target, xt_compat_target_offset, xt_compat_add_offset, module_put]\n\n2. 函数名: duprintf\n- 参数: [const char *format, ...]\n- 调用者: [check_compat_entry_size_and_hooks]\n- 被调用者: []\n\n3. 函数名: arp_checkentry\n- 参数: [struct arpt_arp *arp]\n- 调用者: [check_compat_entry_size_and_hooks]\n- 被调用者: []\n\n4. 函数名: xt_compat_check_entry_offsets\n- 参数: [struct compat_arpt_entry *e, unsigned int target_offset, unsigned int next_offset]\n- 调用者: [check_compat_entry_size_and_hooks]\n- 被调用者: []\n\n5. 函数名: compat_arpt_get_target\n- 参数: [struct compat_arpt_entry *e]\n- 调用者: [check_compat_entry_size_and_hooks]\n- 被调用者: []\n\n6. 函数名: xt_request_find_target\n- 参数: [NFPROTO_ARP, const char *name, u8 revision]\n- 调用者: [check_compat_entry_size_and_hooks]\n- 被调用者: []\n\n7. 函数名: xt_compat_target_offset\n- 参数: [struct xt_target *target]\n- 调用者: [check_compat_entry_size_and_hooks]\n- 被调用者: []\n\n8. 函数名: xt_compat_add_offset\n- 参数: [NFPROTO_ARP, unsigned int offset, unsigned int delta]\n- 调用者: [check_compat_entry_size_and_hooks]\n- 被调用者: []\n\n9. 函数名: module_put\n- 参数: [struct module *module]\n- 调用者: [check_compat_entry_size_and_hooks]\n- 被调用者: []"
    },
    {
        "id": 1046,
        "cwe": "CWE-119",
        "cve": "CVE-2016-4998",
        "purpose": "Code purpose:\"\"\"检查并验证netfilter规则表条目的大小、偏移量和钩子位置，确保其符合安全边界和有效性要求\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证用户提供的offset值，导致可以越界读取内核堆内存数据\"\"\"",
        "functions": "Functions:\n1. 函数名: check_entry_size_and_hooks\n- 参数: [struct arpt_entry *e, struct xt_table_info *newinfo, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, unsigned int valid_hooks]\n- 调用者: 未明确显示（应为调用IPT_SO_SET_REPLACE的相关函数）\n- 被调用者: [arp_checkentry, xt_check_entry_offsets, check_underflow]\n\n2. 函数名: arp_checkentry\n- 参数: [struct arpt_entry *e]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n3. 函数名: xt_check_entry_offsets\n- 参数: [struct arpt_entry *e, unsigned int target_offset, unsigned int next_offset]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n4. 函数名: check_underflow\n- 参数: [struct arpt_entry *e]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n5. 函数名: duprintf\n- 参数: [const char *format, ...]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n6. 函数名: pr_debug\n- 参数: [const char *format, ...]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []"
    },
    {
        "id": 1047,
        "cwe": "CWE-119",
        "cve": "CVE-2016-4998",
        "purpose": "Code purpose:\"\"\"检查ipt_entry结构体的有效性，包括对齐、边界、偏移量和钩子设置，确保网络过滤规则的合法性和安全性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证用户提供的offset值，导致可以越界读取内核堆内存数据\"\"\"",
        "functions": "Functions:\n1. 函数名: check_entry_size_and_hooks\n- 参数: [struct ipt_entry *e, struct xt_table_info *newinfo, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, unsigned int valid_hooks]\n- 调用者: 未明确（由内核调用）\n- 被调用者: [duprintf, ip_checkentry, xt_check_entry_offsets, check_underflow, pr_debug]\n\n2. 函数名: duprintf\n- 参数: [const char *format, ...]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n3. 函数名: ip_checkentry\n- 参数: [struct ipt_entry *e]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n4. 函数名: xt_check_entry_offsets\n- 参数: [struct ipt_entry *e, unsigned int target_offset, unsigned int next_offset]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n5. 函数名: check_underflow\n- 参数: [struct ipt_entry *e]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n6. 函数名: pr_debug\n- 参数: [const char *format, ...]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []"
    },
    {
        "id": 1048,
        "cwe": "CWE-119",
        "cve": "CVE-2016-4998",
        "purpose": "Code purpose:\"\"\"检查兼容性iptables规则条目的尺寸和钩子位置，确保其不越界且符合格式要求\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理兼容性iptables规则时，未能充分验证用户提供的offset值，导致可以越界读取内核堆内存\"\"\"",
        "functions": "Functions:\n1. 函数名: check_compat_entry_size_and_hooks\n- 参数: [struct compat_ipt_entry *e, struct xt_table_info *newinfo, unsigned int *size, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, const char *name]\n- 调用者: 未明确显示（由内核调用）\n- 被调用者: [duprintf, ip_checkentry, xt_compat_check_entry_offsets, xt_ematch_foreach, compat_find_calc_match, compat_ipt_get_target, xt_request_find_target, xt_compat_target_offset, xt_compat_add_offset, module_put, memset]\n\n2. 函数名: duprintf\n- 参数: [const char *format, ...]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n3. 函数名: ip_checkentry\n- 参数: [struct compat_ipt_entry *e]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n4. 函数名: xt_compat_check_entry_offsets\n- 参数: [struct compat_ipt_entry *e, unsigned int target_offset, unsigned int next_offset]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n5. 函数名: xt_ematch_foreach\n- 参数: [struct xt_entry_match *ematch, struct compat_ipt_entry *e]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n6. 函数名: compat_find_calc_match\n- 参数: [struct xt_entry_match *ematch, const char *name, struct compat_ipt_entry *e, int *off]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n7. 函数名: compat_ipt_get_target\n- 参数: [struct compat_ipt_entry *e]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n8. 函数名: xt_request_find_target\n- 参数: [NFPROTO_IPV4, const char *name, unsigned int revision]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n9. 函数名: xt_compat_target_offset\n- 参数: [struct xt_target *target]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n10. 函数名: xt_compat_add_offset\n- 参数: [AF_INET, unsigned int entry_offset, unsigned int off]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n11. 函数名: module_put\n- 参数: [struct module *module]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n12. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []"
    },
    {
        "id": 1049,
        "cwe": "CWE-119",
        "cve": "CVE-2016-4998",
        "purpose": "Code purpose:\"\"\"检查IP6表条目的大小和钩子位置的有效性，防止越界访问和无效配置\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证用户提供的offset值，导致可以越界读取内核堆内存数据\"\"\"",
        "functions": "Functions:\n1. 函数名: check_entry_size_and_hooks\n- 参数: [struct ip6t_entry *e, struct xt_table_info *newinfo, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, unsigned int valid_hooks]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [ip6_checkentry, xt_check_entry_offsets, check_underflow]\n\n2. 函数名: ip6_checkentry\n- 参数: [struct ip6t_ip6 *]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n3. 函数名: xt_check_entry_offsets\n- 参数: [struct ip6t_entry *, unsigned int, unsigned int]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n4. 函数名: check_underflow\n- 参数: [struct ip6t_entry *]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n5. 函数名: duprintf\n- 参数: [const char *, ...]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []\n\n6. 函数名: pr_debug\n- 参数: [const char *, ...]\n- 调用者: check_entry_size_and_hooks\n- 被调用者: []"
    },
    {
        "id": 1050,
        "cwe": "CWE-119",
        "cve": "CVE-2016-4998",
        "purpose": "Code purpose:\"\"\"该代码用于检查和处理兼容模式的IPv6防火墙规则条目，验证其大小和偏移量，并设置相应的钩子和下溢点，同时防止越界访问。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核在处理IPT_SO_SET_REPLACE套接字选项时，未充分验证用户提供的偏移量，导致可以越界读取内核堆内存数据\"\"\"",
        "functions": "Functions:\n1. 函数名: check_compat_entry_size_and_hooks\n- 参数: [struct compat_ip6t_entry *e, struct xt_table_info *newinfo, unsigned int *size, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, const char *name]\n- 调用者: 未明确显示（由外部调用）\n- 被调用者: [ip6_checkentry, xt_compat_check_entry_offsets, xt_ematch_foreach, compat_find_calc_match, compat_ip6t_get_target, xt_request_find_target, xt_compat_target_offset, xt_compat_add_offset, module_put, memset]\n\n2. 函数名: ip6_checkentry\n- 参数: [struct ip6t_ip6 *]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n3. 函数名: xt_compat_check_entry_offsets\n- 参数: [struct compat_ip6t_entry *, unsigned int, unsigned int]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n4. 函数名: xt_ematch_foreach\n- 参数: [struct xt_entry_match *, struct compat_ip6t_entry *]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n5. 函数名: compat_find_calc_match\n- 参数: [struct xt_entry_match *, const char *, struct ip6t_ip6 *, int *]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n6. 函数名: compat_ip6t_get_target\n- 参数: [struct compat_ip6t_entry *]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n7. 函数名: xt_request_find_target\n- 参数: [NFPROTO_IPV6, char *, unsigned int]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n8. 函数名: xt_compat_target_offset\n- 参数: [struct xt_target *]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n9. 函数名: xt_compat_add_offset\n- 参数: [AF_INET6, unsigned int, unsigned int]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n10. 函数名: module_put\n- 参数: [struct module *]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []\n\n11. 函数名: memset\n- 参数: [void *, int, size_t]\n- 调用者: check_compat_entry_size_and_hooks\n- 被调用者: []"
    },
    {
        "id": 1055,
        "cwe": "CWE-119",
        "cve": "CVE-2016-5400",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中airspy USB驱动程序的探测功能，用于初始化设备、注册视频设备和控制处理程序，支持SDR(软件定义无线电)设备的连接和操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在airspy_probe函数中，当video_register_device注册失败时，未正确释放已分配的内存和控制句柄，导致内存泄漏\"\"\"",
        "functions": "Functions:\n1. 函数名: airspy_probe\n- 参数: [struct usb_interface *intf, const struct usb_device_id *id]\n- 调用者: 内核USB子系统\n- 被调用者: [kzalloc, dev_err, mutex_init, spin_lock_init, INIT_LIST_HEAD, interface_to_usbdev, airspy_ctrl_msg, dev_info, vb2_queue_init, video_set_drvdata, v4l2_device_register, v4l2_ctrl_handler_init, v4l2_ctrl_new_std, v4l2_ctrl_auto_cluster, v4l2_ctrl_handler_setup, video_register_device, video_device_node_name, v4l2_ctrl_handler_free, v4l2_device_unregister, kfree]\n\n2. 函数名: airspy_ctrl_msg\n- 参数: [struct airspy *s, CMD_BOARD_ID_READ, 0, 0, &u8tmp, 1] / [struct airspy *s, CMD_VERSION_STRING_READ, 0, 0, buf, BUF_SIZE]\n- 调用者: airspy_probe\n- 被调用者: []\n\n3. 函数名: kzalloc\n- 参数: [sizeof(struct airspy), GFP_KERNEL]\n- 调用者: airspy_probe\n- 被调用者: []\n\n4. 函数名: dev_err\n- 参数: [&intf->dev, \"Could not allocate memory for state\\n\"] / [s->dev, \"Could not detect board\\n\"] / [s->dev, \"Could not initialize vb2 queue\\n\"] / [s->dev, \"Failed to register v4l2-device (%d)\\n\", ret] / [s->dev, \"Could not initialize controls\\n\"] / [s->dev, \"Failed to register as video device (%d)\\n\", ret]\n- 调用者: airspy_probe\n- 被调用者: []\n\n5. 函数名: mutex_init\n- 参数: [&s->v4l2_lock] / [&s->vb_queue_lock]\n- 调用者: airspy_probe\n- 被调用者: []\n\n6. 函数名: spin_lock_init\n- 参数: [&s->queued_bufs_lock]\n- 调用者: airspy_probe\n- 被调用者: []\n\n7. 函数名: INIT_LIST_HEAD\n- 参数: [&s->queued_bufs]\n- 调用者: airspy_probe\n- 被调用者: []\n\n8. 函数名: interface_to_usbdev\n- 参数: [intf]\n- 调用者: airspy_probe\n- 被调用者: []\n\n9. 函数名: dev_info\n- 参数: [s->dev, \"Board ID: %02x\\n\", u8tmp] / [s->dev, \"Firmware version: %s\\n\", buf] / [s->dev, \"Registered as %s\\n\", video_device_node_name(&s->vdev)]\n- 调用者: airspy_probe\n- 被调用者: []\n\n10. 函数名: vb2_queue_init\n- 参数: [&s->vb_queue]\n- 调用者: airspy_probe\n- 被调用者: []\n\n11. 函数名: video_set_drvdata\n- 参数: [&s->vdev, s]\n- 调用者: airspy_probe\n- 被调用者: []\n\n12. 函数名: v4l2_device_register\n- 参数: [&intf->dev, &s->v4l2_dev]\n- 调用者: airspy_probe\n- 被调用者: []\n\n13. 函数名: v4l2_ctrl_handler_init\n- 参数: [&s->hdl, 5]\n- 调用者: airspy_probe\n- 被调用者: []\n\n14. 函数名: v4l2_ctrl_new_std\n- 参数: [&s->hdl, &airspy_ctrl_ops, V4L2_CID_RF_TUNER_LNA_GAIN_AUTO, 0, 1, 1, 0] / [&s->hdl, &airspy_ctrl_ops, V4L2_CID_RF_TUNER_LNA_GAIN, 0, 14, 1, 8] / [&s->hdl, &airspy_ctrl_ops, V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO, 0, 1, 1, 0] / [&s->hdl, &airspy_ctrl_ops, V4L2_CID_RF_TUNER_MIXER_GAIN, 0, 15, 1, 8] / [&s->hdl, &airspy_ctrl_ops, V4L2_CID_RF_TUNER_IF_GAIN, 0, 15, 1, 0]\n- 调用者: airspy_probe\n- 被调用者: []\n\n15. 函数名: v4l2_ctrl_auto_cluster\n- 参数: [2, &s->lna_gain_auto, 0, false] / [2, &s->mixer_gain_auto, 0, false]\n- 调用者: airspy_probe\n- 被调用者: []\n\n16. 函数名: v4l2_ctrl_handler_setup\n- 参数: [&s->hdl]\n- 调用者: airspy_probe\n- 被调用者: []\n\n17. 函数名: video_register_device\n- 参数: [&s->vdev, VFL_TYPE_SDR, -1]\n- 调用者: airspy_probe\n- 被调用者: []\n\n18. 函数名: video_device_node_name\n- 参数: [&s->vdev]\n- 调用者: airspy_probe\n- 被调用者: []\n\n19. 函数名: v4l2_ctrl_handler_free\n- 参数: [&s->hdl]\n- 调用者: airspy_probe\n- 被调用者: []\n\n20. 函数名: v4l2_device_unregister\n- 参数: [&s->v4l2_dev]\n- 调用者: airspy_probe\n- 被调用者: []\n\n21. 函数名: kfree\n- 参数: [s]\n- 调用者: airspy_probe\n- 被调用者: []"
    },
    {
        "id": 1056,
        "cwe": "CWE-119",
        "cve": "CVE-2016-5728",
        "purpose": "Code purpose:\"\"\"该代码实现了MIC VOP驱动中vop_ioctl函数的功能，用于处理虚拟设备的各种控制命令，包括添加设备、复制描述符和配置更改等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在vop_ioctl函数中存在对用户空间数据的多次读取（double fetch）而没有适当的同步保护，导致竞态条件下可能访问不一致的数据\"\"\"",
        "functions": "Functions:\n1. 函数名: vop_ioctl\n- 参数: [struct file *f, unsigned int cmd, unsigned long arg]\n- 调用者: 内核IOCTL处理机制\n- 被调用者: [copy_from_user, kzalloc, kfree, mutex_lock, mutex_unlock, vop_virtio_add_device, list_add_tail, vop_vdev_inited, vop_virtio_copy_desc, copy_to_user, vop_virtio_config_change]\n\n2. 函数名: mic_aligned_desc_size\n- 参数: [struct mic_device_desc *dd]\n- 调用者: vop_ioctl\n- 被调用者: []\n\n3. 函数名: mic_desc_size\n- 参数: [struct mic_device_desc *dd]\n- 调用者: vop_ioctl\n- 被调用者: []\n\n4. 函数名: vop_virtio_add_device\n- 参数: [struct vop_vdev *vdev, struct mic_device_desc *dd_config]\n- 调用者: vop_ioctl\n- 被调用者: []\n\n5. 函数名: vop_vdev_inited\n- 参数: [struct vop_vdev *vdev]\n- 调用者: vop_ioctl\n- 被调用者: []\n\n6. 函数名: vop_virtio_copy_desc\n- 参数: [struct vop_vdev *vdev, struct mic_copy_desc *copy]\n- 调用者: vop_ioctl\n- 被调用者: []\n\n7. 函数名: vop_virtio_config_change\n- 参数: [struct vop_vdev *vdev, void *buf]\n- 调用者: vop_ioctl\n- 被调用者: []"
    },
    {
        "id": 1058,
        "cwe": "CWE-119",
        "cve": "CVE-2016-5829",
        "purpose": "Code purpose:\"\"\"处理HID设备的用户空间ioctl请求，包括获取和设置HID设备的使用情况数据\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在HIDIOCGUSAGES或HIDIOCSUSAGES ioctl调用中，未充分验证用户提供的uref_multi->num_values参数，导致堆缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: hiddev_ioctl_usage\n- 参数: [struct hiddev *hiddev, unsigned int cmd, void __user *user_arg]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [kmalloc, copy_from_user, hiddev_lookup_report, hiddev_lookup_usage, copy_to_user, kfree]\n\n2. 函数名: hiddev_lookup_report\n- 参数: [struct hid_device *hid, struct hiddev_report_info *rinfo]\n- 调用者: hiddev_ioctl_usage\n- 被调用者: 未显示（可能为内核内部函数）\n\n3. 函数名: hiddev_lookup_usage\n- 参数: [struct hid_device *hid, struct hiddev_usage_ref *uref]\n- 调用者: hiddev_ioctl_usage\n- 被调用者: 未显示（可能为内核内部函数）\n\n4. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: hiddev_ioctl_usage\n- 被调用者: 未显示（内核内存分配函数）\n\n5. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: hiddev_ioctl_usage\n- 被调用者: 未显示（内核拷贝函数）\n\n6. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: hiddev_ioctl_usage\n- 被调用者: 未显示（内核拷贝函数）\n\n7. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: hiddev_ioctl_usage\n- 被调用者: 未显示（内核内存释放函数）"
    },
    {
        "id": 1064,
        "cwe": "CWE-119",
        "cve": "CVE-2016-6187",
        "purpose": "Code purpose:\"\"\"该代码用于处理AppArmor安全模块中进程属性的设置，包括权限检查和属性修改，但不正确地处理了缓冲区大小验证，可能导致权限提升漏洞。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未对用户提供的缓冲区大小进行充分验证，导致可以越界写入空字符\"\"\"",
        "functions": "Functions:\n1. 函数名: apparmor_setprocattr\n- 参数: [struct task_struct *task, char *name, void *value, size_t size]\n- 调用者: 未显示（内核调用）\n- 被调用者: [strim, strsep, skip_spaces, strcmp, aa_setprocattr_changehat, aa_setprocattr_changeprofile, aa_current_profile, aa_audit_msg]\n\n2. 函数名: strim\n- 参数: [char *args]\n- 调用者: apparmor_setprocattr\n- 被调用者: []\n\n3. 函数名: strsep\n- 参数: [char **args, const char *delim]\n- 调用者: apparmor_setprocattr\n- 被调用者: []\n\n4. 函数名: skip_spaces\n- 参数: [char *args]\n- 调用者: apparmor_setprocattr\n- 被调用者: []\n\n5. 函数名: strcmp\n- 参数: [const char *name, const char *command]\n- 调用者: apparmor_setprocattr\n- 被调用者: []\n\n6. 函数名: aa_setprocattr_changehat\n- 参数: [char *args, size_t arg_size, int test]\n- 调用者: apparmor_setprocattr\n- 被调用者: []\n\n7. 函数名: aa_setprocattr_changeprofile\n- 参数: [char *args, int onexec, int test]\n- 调用者: apparmor_setprocattr\n- 被调用者: []\n\n8. 函数名: aa_current_profile\n- 参数: []\n- 调用者: apparmor_setprocattr\n- 被调用者: []\n\n9. 函数名: aa_audit_msg\n- 参数: [int AUDIT_APPARMOR_DENIED, struct common_audit_data *sa, NULL]\n- 调用者: apparmor_setprocattr\n- 被调用者: []"
    },
    {
        "id": 1077,
        "cwe": "CWE-119",
        "cve": "CVE-2016-6516",
        "purpose": "Code purpose:\"\"\"该代码实现了通过ioctl系统调用进行文件去重范围操作的功能，包括从用户空间获取参数、分配内存、执行去重操作并将结果返回用户空间。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对用户空间传入的count值进行锁定或验证，导致在两次获取该值之间可能被恶意修改，造成堆缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ioctl_file_dedupe_range\n- 参数: [file, arg]\n- 调用者: 未明确显示（应为内核IOCTL处理流程）\n- 被调用者: [get_user, memdup_user, vfs_dedupe_file_range, copy_to_user, kfree]\n\n2. 函数名: get_user\n- 参数: [count, &argp->dest_count]\n- 调用者: ioctl_file_dedupe_range\n- 被调用者: []\n\n3. 函数名: memdup_user\n- 参数: [argp, size]\n- 调用者: ioctl_file_dedupe_range\n- 被调用者: []\n\n4. 函数名: vfs_dedupe_file_range\n- 参数: [file, same]\n- 调用者: ioctl_file_dedupe_range\n- 被调用者: []\n\n5. 函数名: copy_to_user\n- 参数: [argp, same, size]\n- 调用者: ioctl_file_dedupe_range\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [same]\n- 调用者: ioctl_file_dedupe_range\n- 被调用者: []"
    },
    {
        "id": 1092,
        "cwe": "CWE-119",
        "cve": "CVE-2016-7042",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中显示/proc/keys文件中的密钥信息，包括密钥序列号、标志位、权限、有效期等属性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"使用了不正确的缓冲区大小来处理超时数据，导致栈内存损坏\"\"\"",
        "functions": "Functions:\n1. 函数名: proc_keys_show\n- 参数: [struct seq_file *m, void *v]\n- 调用者: 未显示（由内核proc文件系统调用）\n- 被调用者: [rb_entry, current_cred, make_key_ref, search_my_process_keyrings, key_ref_put, key_task_permission, current_kernel_time, rcu_read_lock, memcpy, sprintf, test_bit, seq_printf, atomic_read, from_kuid_munged, from_kgid_munged, seq_putc, rcu_read_unlock]\n\n2. 函数名: rb_entry\n- 参数: [struct rb_node *_p, struct key, serial_node]\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n3. 函数名: current_cred\n- 参数: []\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n4. 函数名: make_key_ref\n- 参数: [struct key *key, int]\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n5. 函数名: search_my_process_keyrings\n- 参数: [struct keyring_search_context *ctx]\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n6. 函数名: key_ref_put\n- 参数: [key_ref_t skey_ref]\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n7. 函数名: key_task_permission\n- 参数: [key_ref_t key_ref, struct cred *cred, int KEY_NEED_VIEW]\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n8. 函数名: current_kernel_time\n- 参数: []\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n9. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n10. 函数名: memcpy\n- 参数: [char *xbuf, char *\"perm\"/\"expd\", size_t 5]\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n11. 函数名: sprintf\n- 参数: [char *xbuf, char *format, unsigned long timo]\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n12. 函数名: test_bit\n- 参数: [int FLAG, unsigned long *&(KEY)->flags]\n- 调用者: proc_keys_show (通过showflag宏)\n- 被调用者: 未显示\n\n13. 函数名: seq_printf\n- 参数: [struct seq_file *m, char *format, ...]\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n14. 函数名: atomic_read\n- 参数: [atomic_t *&key->usage]\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n15. 函数名: from_kuid_munged\n- 参数: [struct user_namespace *seq_user_ns(m), kuid_t key->uid]\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n16. 函数名: from_kgid_munged\n- 参数: [struct user_namespace *seq_user_ns(m), kgid_t key->gid]\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n17. 函数名: seq_putc\n- 参数: [struct seq_file *m, char '\\n']\n- 调用者: proc_keys_show\n- 被调用者: 未显示\n\n18. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: proc_keys_show\n- 被调用者: 未显示"
    },
    {
        "id": 1108,
        "cwe": "CWE-119",
        "cve": "CVE-2016-7425",
        "purpose": "Code purpose:\"\"\"该代码实现了SCSI适配器控制块与IOP(输入/输出处理器)之间的消息传输功能，包括读写缓冲区、清除缓冲区等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"arcmsr_iop_message_xfer函数在处理ARCMSR_MESSAGE_WRITE_WQBUFFER控制码时，未对用户提供的长度字段(pcmdmessagefld->cmdmessage.Length)进行有效限制，导致可能发生堆缓冲区溢出。\"\"\"",
        "functions": "Functions:\n1. 函数名: arcmsr_iop_message_xfer\n- 参数: [struct AdapterControlBlock *acb, struct scsi_cmnd *cmd]\n- 调用者: 未显示（应为SCSI子系统调用）\n- 被调用者: [scsi_sg_count, scsi_sglist, kmap_atomic, kunmap_atomic, kmalloc, kfree, spin_lock_irqsave, spin_unlock_irqrestore, memcpy, CIRC_CNT_TO_END, CIRC_CNT, arcmsr_get_iop_rqbuffer, arcmsr_Read_iop_rqbuffer_data, arcmsr_write_ioctldata2iop, arcmsr_clear_iop2drv_rqueue_buffer, arcmsr_iop_parking, arcmsr_flush_adapter_cache, pr_info]\n\n2. 函数名: scsi_sg_count\n- 参数: [struct scsi_cmnd *cmd]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n3. 函数名: scsi_sglist\n- 参数: [struct scsi_cmnd *cmd]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n4. 函数名: kmap_atomic\n- 参数: [sg_page(sg)]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n5. 函数名: kunmap_atomic\n- 参数: [buffer - sg->offset]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n6. 函数名: kmalloc\n- 参数: [ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n7. 函数名: kfree\n- 参数: [ver_addr]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n8. 函数名: spin_lock_irqsave\n- 参数: [&acb->rqbuffer_lock, flags], [&acb->wqbuffer_lock, flags]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n9. 函数名: spin_unlock_irqrestore\n- 参数: [&acb->rqbuffer_lock, flags], [&acb->wqbuffer_lock, flags]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n10. 函数名: memcpy\n- 参数: 多种参数组合\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n11. 函数名: CIRC_CNT_TO_END\n- 参数: [head, tail, ARCMSR_MAX_QBUFFER]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n12. 函数名: CIRC_CNT\n- 参数: [head, tail, ARCMSR_MAX_QBUFFER]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n13. 函数名: arcmsr_get_iop_rqbuffer\n- 参数: [acb]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n14. 函数名: arcmsr_Read_iop_rqbuffer_data\n- 参数: [acb, prbuffer]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n15. 函数名: arcmsr_write_ioctldata2iop\n- 参数: [acb]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n16. 函数名: arcmsr_clear_iop2drv_rqueue_buffer\n- 参数: [acb]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n17. 函数名: arcmsr_iop_parking\n- 参数: [acb]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n18. 函数名: arcmsr_flush_adapter_cache\n- 参数: [acb]\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无\n\n19. 函数名: pr_info\n- 参数: 格式化字符串和参数\n- 调用者: arcmsr_iop_message_xfer\n- 被调用者: 无"
    },
    {
        "id": 1120,
        "cwe": "CWE-119",
        "cve": "CVE-2016-8632",
        "purpose": "Code purpose:\"\"\"处理网络设备事件并更新TIPC（透明进程间通信）承载状态及相关参数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未验证最小片段长度与最大数据包大小之间的关系，导致堆缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: tipc_l2_device_event\n- 参数: [struct notifier_block *nb, unsigned long evt, void *ptr]\n- 调用者: 未显示（由内核通知链机制调用）\n- 被调用者: [netdev_notifier_info_to_dev, dev_net, rtnl_dereference, netif_carrier_ok, test_and_set_bit_lock, clear_bit_unlock, tipc_reset_bearer, bearer_disable]\n\n2. 函数名: netdev_notifier_info_to_dev\n- 参数: [void *ptr]\n- 调用者: tipc_l2_device_event\n- 被调用者: 未显示\n\n3. 函数名: dev_net\n- 参数: [struct net_device *dev]\n- 调用者: tipc_l2_device_event\n- 被调用者: 未显示\n\n4. 函数名: rtnl_dereference\n- 参数: [dev->tipc_ptr]\n- 调用者: tipc_l2_device_event\n- 被调用者: 未显示\n\n5. 函数名: netif_carrier_ok\n- 参数: [struct net_device *dev]\n- 调用者: tipc_l2_device_event\n- 被调用者: 未显示\n\n6. 函数名: test_and_set_bit_lock\n- 参数: [0, &b->up]\n- 调用者: tipc_l2_device_event\n- 被调用者: 未显示\n\n7. 函数名: clear_bit_unlock\n- 参数: [0, &b->up]\n- 调用者: tipc_l2_device_event\n- 被调用者: 未显示\n\n8. 函数名: tipc_reset_bearer\n- 参数: [struct net *net, struct tipc_bearer *b]\n- 调用者: tipc_l2_device_event\n- 被调用者: 未显示\n\n9. 函数名: bearer_disable\n- 参数: [dev_net(dev), struct tipc_bearer *b]\n- 调用者: tipc_l2_device_event\n- 被调用者: 未显示"
    },
    {
        "id": 1121,
        "cwe": "CWE-119",
        "cve": "CVE-2016-8632",
        "purpose": "Code purpose:\"\"\"将TIPC（透明进程间通信）承载与指定的L2网络设备关联，并配置相关网络参数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未验证最小片段长度与最大数据包大小之间的关系，导致堆缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: tipc_enable_l2_media\n- 参数: [net, b, attr]\n- 调用者: N/A\n- 被调用者: [strchr, dev_get_by_name, rcu_assign_pointer, memset, memcpy]\n\n2. 函数名: strchr\n- 参数: [(const char *)b->name, ':']\n- 调用者: tipc_enable_l2_media\n- 被调用者: N/A\n\n3. 函数名: dev_get_by_name\n- 参数: [net, driver_name]\n- 调用者: tipc_enable_l2_media\n- 被调用者: N/A\n\n4. 函数名: rcu_assign_pointer\n- 参数: [b->media_ptr, dev]\n- 调用者: tipc_enable_l2_media\n- 被调用者: N/A\n\n5. 函数名: memset\n- 参数: [&b->bcast_addr, 0, sizeof(b->bcast_addr)]\n- 调用者: tipc_enable_l2_media\n- 被调用者: N/A\n\n6. 函数名: memcpy\n- 参数: [b->bcast_addr.value, dev->broadcast, b->media->hwaddr_len]\n- 调用者: tipc_enable_l2_media\n- 被调用者: N/A\n\n7. 函数名: rcu_assign_pointer\n- 参数: [dev->tipc_ptr, b]\n- 调用者: tipc_enable_l2_media\n- 被调用者: N/A"
    },
    {
        "id": 1122,
        "cwe": "CWE-119",
        "cve": "CVE-2016-8632",
        "purpose": "Code purpose:\"\"\"该代码实现了TIPC协议中UDP承载的启用功能，包括配置本地和远程UDP地址、创建UDP套接字以及设置隧道接收回调等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未验证最小片段长度与最大数据包大小之间的关系，导致堆缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: tipc_udp_enable\n- 参数: [struct net *net, struct tipc_bearer *b, struct nlattr *attrs[]]\n- 调用者: (未在代码片段中显示)\n- 被调用者: [kzalloc, INIT_LIST_HEAD, nla_parse_nested, tipc_parse_udp_addr, htons, __ip_dev_find, udp_sock_create, setup_udp_tunnel_sock, memcpy, tipc_udp_is_mcast_addr, enable_mcast, tipc_udp_rcast_add, udp_tunnel_sock_release, kfree]\n\n2. 函数名: tipc_parse_udp_addr\n- 参数: (未完全显示，至少包含 struct nlattr *opts, struct udp_media_addr *addr, int *ifindex)\n- 调用者: tipc_udp_enable\n- 被调用者: (未在代码片段中显示)\n\n3. 函数名: __ip_dev_find\n- 参数: [struct net *net, u32 addr, bool devref]\n- 调用者: tipc_udp_enable\n- 被调用者: (未在代码片段中显示)\n\n4. 函数名: udp_sock_create\n- 参数: [struct net *net, struct udp_port_cfg *cfg, struct socket **sockp]\n- 调用者: tipc_udp_enable\n- 被调用者: (未在代码片段中显示)\n\n5. 函数名: setup_udp_tunnel_sock\n- 参数: [struct net *net, struct socket *sock, struct udp_tunnel_sock_cfg *cfg]\n- 调用者: tipc_udp_enable\n- 被调用者: (未在代码片段中显示)\n\n6. 函数名: tipc_udp_is_mcast_addr\n- 参数: [struct udp_media_addr *addr]\n- 调用者: tipc_udp_enable\n- 被调用者: (未在代码片段中显示)\n\n7. 函数名: enable_mcast\n- 参数: [struct udp_bearer *ub, struct udp_media_addr *remote]\n- 调用者: tipc_udp_enable\n- 被调用者: (未在代码片段中显示)\n\n8. 函数名: tipc_udp_rcast_add\n- 参数: [struct tipc_bearer *b, struct udp_media_addr *addr]\n- 调用者: tipc_udp_enable\n- 被调用者: (未在代码片段中显示)\n\n9. 函数名: udp_tunnel_sock_release\n- 参数: [struct socket *sock]\n- 调用者: tipc_udp_enable\n- 被调用者: (未在代码片段中显示)\n\n10. 函数名: tipc_udp_media_addr_set\n- 参数: [struct tipc_media_addr *addr, struct udp_media_addr *media]\n- 调用者: (未在代码片段中显示，但被tipc_udp_enable调用)\n- 被调用者: (未在代码片段中显示)"
    },
    {
        "id": 1123,
        "cwe": "CWE-119",
        "cve": "CVE-2016-8633",
        "purpose": "Code purpose:\"\"\"处理通过IEEE 1394总线接收的网络数据包，包括完整数据包和分片数据包的组装与转发\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理分片数据包时，由于缺乏对数据包大小和分片偏移量的充分验证，导致可能发生缓冲区溢出或内存损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: fwnet_incoming_packet\n- 参数: [dev, buf, len, source_node_id, generation, is_broadcast]\n- 调用者: 未显示\n- 被调用者: [fwnet_get_hdr_lf, be32_to_cpu, fwnet_get_hdr_ether_type, dev_alloc_skb, skb_reserve, skb_put, memcpy, fwnet_finish_incoming_packet, ntohl, fwnet_get_hdr_fg_off, fwnet_get_hdr_dgl, fwnet_get_hdr_dg_size, spin_lock_irqsave, fwnet_peer_find_by_node_id, fwnet_pd_find, fwnet_pd_delete, fwnet_pd_new, fwnet_frag_overlap, fwnet_pd_update, fwnet_pd_is_complete, skb_get, spin_unlock_irqrestore]\n\n2. 函数名: fwnet_get_hdr_lf\n- 参数: [hdr]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n3. 函数名: fwnet_get_hdr_ether_type\n- 参数: [hdr]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n4. 函数名: fwnet_get_hdr_fg_off\n- 参数: [hdr]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n5. 函数名: fwnet_get_hdr_dgl\n- 参数: [hdr]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n6. 函数名: fwnet_get_hdr_dg_size\n- 参数: [hdr]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n7. 函数名: fwnet_peer_find_by_node_id\n- 参数: [dev, source_node_id, generation]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n8. 函数名: fwnet_pd_find\n- 参数: [peer, datagram_label]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n9. 函数名: fwnet_pd_delete\n- 参数: [pd]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n10. 函数名: fwnet_pd_new\n- 参数: [net, peer, datagram_label, dg_size, buf, fg_off, len]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n11. 函数名: fwnet_frag_overlap\n- 参数: [pd, fg_off, len]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n12. 函数名: fwnet_pd_update\n- 参数: [peer, pd, buf, fg_off, len]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n13. 函数名: fwnet_pd_is_complete\n- 参数: [pd]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示\n\n14. 函数名: fwnet_finish_incoming_packet\n- 参数: [net, skb, source_node_id, is_broadcast, ether_type]\n- 调用者: fwnet_incoming_packet\n- 被调用者: 未显示"
    },
    {
        "id": 1124,
        "cwe": "CWE-119",
        "cve": "CVE-2016-8633",
        "purpose": "Code purpose:\"\"\"处理FireWire网络设备接收的广播数据包，包括解析包头、验证数据并转发有效数据包\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理特定硬件配置下的分段广播数据包时，由于缺乏对数据包长度的充分验证，导致缓冲区溢出漏洞，允许远程攻击者执行任意代码。\"\"\"",
        "functions": "Functions:\n1. 函数名: fwnet_receive_broadcast\n- 参数: [struct fw_iso_context *context, u32 cycle, size_t header_length, void *header, void *data]\n- 调用者: 未显示（由内核事件触发）\n- 被调用者: [be16_to_cpup, spin_lock_irqsave, spin_unlock_irqrestore, be32_to_cpu, fwnet_incoming_packet, fw_iso_context_queue, fw_iso_context_queue_flush, dev_err]\n\n2. 函数名: be16_to_cpup\n- 参数: [__be16 *hdr_ptr]\n- 调用者: fwnet_receive_broadcast\n- 被调用者: []\n\n3. 函数名: spin_lock_irqsave\n- 参数: [&dev->lock, flags]\n- 调用者: fwnet_receive_broadcast\n- 被调用者: []\n\n4. 函数名: spin_unlock_irqrestore\n- 参数: [&dev->lock, flags]\n- 调用者: fwnet_receive_broadcast\n- 被调用者: []\n\n5. 函数名: be32_to_cpu\n- 参数: [buf_ptr[0], buf_ptr[1]]\n- 调用者: fwnet_receive_broadcast\n- 被调用者: []\n\n6. 函数名: fwnet_incoming_packet\n- 参数: [dev, buf_ptr, length, source_node_id, context->card->generation, true]\n- 调用者: fwnet_receive_broadcast\n- 被调用者: []\n\n7. 函数名: fw_iso_context_queue\n- 参数: [dev->broadcast_rcv_context, &packet, &dev->broadcast_rcv_buffer, offset]\n- 调用者: fwnet_receive_broadcast\n- 被调用者: []\n\n8. 函数名: fw_iso_context_queue_flush\n- 参数: [dev->broadcast_rcv_context]\n- 调用者: fwnet_receive_broadcast\n- 被调用者: []\n\n9. 函数名: dev_err\n- 参数: [&dev->netdev->dev, \"requeue failed\\n\"]\n- 调用者: fwnet_receive_broadcast\n- 被调用者: []"
    },
    {
        "id": 1133,
        "cwe": "CWE-119",
        "cve": "CVE-2016-8658",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中Broadcom无线网卡驱动创建和配置AP(接入点)模式的功能，包括处理SSID、安全设置、信道配置等参数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SSID信息元素时未正确验证长度，导致栈缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: brcmf_cfg80211_start_ap\n- 参数: [wiphy, ndev, settings]\n- 调用者: N/A (kernel function)\n- 被调用者: [wiphy_to_cfg, netdev_priv, chandef_to_chanspec, brcmf_dbg, brcmf_fil_cmd_int_get, brcmf_parse_tlvs, memset, memcpy, cpu_to_le32, brcmf_set_mpc, brcmf_configure_arp_nd_offload, brcmf_find_wpaie, brcmf_configure_wpaie, brcmf_configure_opensecurity, brcmf_config_ap_mgmt_ie, brcmf_fil_cmd_int_set, brcmf_fil_iovar_int_set, brcmf_feat_is_enabled, brcmf_fil_iovar_data_set, brcmf_cfg80211_reconfigure_wep, brcmf_fil_cmd_data_set, brcmf_fil_bsscfg_data_set, brcmf_net_setcarrier]\n\n2. 函数名: wiphy_to_cfg\n- 参数: [wiphy]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n3. 函数名: netdev_priv\n- 参数: [ndev]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n4. 函数名: chandef_to_chanspec\n- 参数: [&cfg->d11inf, &settings->chandef]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n5. 函数名: brcmf_dbg\n- 参数: [TRACE, format_string, ...]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n6. 函数名: brcmf_fil_cmd_int_get\n- 参数: [ifp, BRCMF_C_GET_REGULATORY, &ifp->vif->is_11d]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n7. 函数名: brcmf_parse_tlvs\n- 参数: [(u8 *)settings->beacon.tail, settings->beacon.tail_len, WLAN_EID_COUNTRY], [(u8 *)&settings->beacon.head[ie_offset], settings->beacon.head_len - ie_offset, WLAN_EID_SSID], [(u8 *)settings->beacon.tail, settings->beacon.tail_len, WLAN_EID_RSN]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n8. 函数名: memset\n- 参数: [&ssid_le, 0, sizeof(ssid_le)], [&join_params, 0, sizeof(join_params)]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n9. 函数名: memcpy\n- 参数: [ssid_le.SSID, ssid_ie->data, ssid_ie->len], [ssid_le.SSID, settings->ssid, settings->ssid_len], [&join_params.ssid_le, &ssid_le, sizeof(ssid_le)]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n10. 函数名: cpu_to_le32\n- 参数: [ssid_ie->len], [(u32)settings->ssid_len]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n11. 函数名: brcmf_set_mpc\n- 参数: [ifp, 0], [ifp, 1]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n12. 函数名: brcmf_configure_arp_nd_offload\n- 参数: [ifp, false], [ifp, true]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n13. 函数名: brcmf_find_wpaie\n- 参数: [(u8 *)settings->beacon.tail, settings->beacon.tail_len]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n14. 函数名: brcmf_configure_wpaie\n- 参数: [ifp, wpa_ie, false], [ifp, tmp_ie, true]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n15. 函数名: brcmf_configure_opensecurity\n- 参数: [ifp]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n16. 函数名: brcmf_config_ap_mgmt_ie\n- 参数: [ifp->vif, &settings->beacon]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n17. 函数名: brcmf_fil_cmd_int_set\n- 参数: [ifp, BRCMF_C_SET_REGULATORY, is_11d], [ifp, BRCMF_C_SET_BCNPRD, settings->beacon_interval], [ifp, BRCMF_C_SET_DTIMPRD, settings->dtim_period], [ifp, BRCMF_C_DOWN, 1], [ifp, BRCMF_C_SET_INFRA, 1], [ifp, BRCMF_C_SET_AP, 1], [ifp, BRCMF_C_UP, 1]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n18. 函数名: brcmf_fil_iovar_int_set\n- 参数: [ifp, \"apsta\", 0], [ifp, \"mbss\", 1], [ifp, \"chanspec\", chanspec], [ifp, \"closednet\", 1]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n19. 函数名: brcmf_feat_is_enabled\n- 参数: [ifp, BRCMF_FEAT_RSDB], [ifp, BRCMF_FEAT_MBSS]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n20. 函数名: brcmf_cfg80211_reconfigure_wep\n- 参数: [ifp]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n21. 函数名: brcmf_fil_cmd_data_set\n- 参数: [ifp, BRCMF_C_SET_SSID, &join_params, sizeof(join_params)]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n22. 函数名: brcmf_fil_bsscfg_data_set\n- 参数: [ifp, \"ssid\", &ssid_le, sizeof(ssid_le)]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n23. 函数名: brcmf_fil_iovar_data_set\n- 参数: [ifp, \"bss\", &bss_enable, sizeof(bss_enable)]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []\n\n24. 函数名: brcmf_net_setcarrier\n- 参数: [ifp, true]\n- 调用者: brcmf_cfg80211_start_ap\n- 被调用者: []"
    },
    {
        "id": 1137,
        "cwe": "CWE-119",
        "cve": "CVE-2016-9083",
        "purpose": "Code purpose:\"\"\"该代码实现了VFIO PCI设备的IOCTL接口，用于处理设备信息查询、区域信息获取、中断设置、设备重置等操作，允许用户空间与PCI设备进行交互。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于VFIO_DEVICE_SET_IRQS ioctl调用中缺乏对整数溢出的充分检查，导致本地用户可通过精心构造的参数绕过安全检查，造成内存破坏或其他未明确影响。\"\"\"",
        "functions": "Functions:\n1. 函数名: vfio_pci_ioctl\n- 参数: [device_data, cmd, arg]\n- 调用者: 无（系统调用接口）\n- 被调用者: [copy_from_user, copy_to_user, vfio_pci_get_irq_count, vfio_pci_set_irqs_ioctl, pci_try_reset_function, vfio_pci_for_each_slot_or_bus, vfio_pci_count_devs, vfio_pci_fill_devs, vfio_pci_validate_devs, pci_try_reset_slot, pci_try_reset_bus, msix_sparse_mmap_cap, region_type_cap, vfio_info_cap_shift, memdup_user, kfree, mutex_lock, mutex_unlock, fdget, fdput, vfio_group_get_external_user, vfio_external_user_iommu_id, vfio_group_put_external_user]\n\n2. 函数名: vfio_pci_get_irq_count\n- 参数: [vdev, index]\n- 调用者: vfio_pci_ioctl\n- 被调用者: 无\n\n3. 函数名: vfio_pci_set_irqs_ioctl\n- 参数: [vdev, flags, index, start, count, data]\n- 调用者: vfio_pci_ioctl\n- 被调用者: 无\n\n4. 函数名: vfio_pci_for_each_slot_or_bus\n- 参数: [pdev, func, data, slot]\n- 调用者: vfio_pci_ioctl\n- 被调用者: 无\n\n5. 函数名: vfio_pci_count_devs\n- 参数: [pdev, data]\n- 调用者: vfio_pci_ioctl\n- 被调用者: 无\n\n6. 函数名: vfio_pci_fill_devs\n- 参数: [pdev, data]\n- 调用者: vfio_pci_ioctl\n- 被调用者: 无\n\n7. 函数名: vfio_pci_validate_devs\n- 参数: [pdev, data]\n- 调用者: vfio_pci_ioctl\n- 被调用者: 无\n\n8. 函数名: msix_sparse_mmap_cap\n- 参数: [vdev, caps]\n- 调用者: vfio_pci_ioctl\n- 被调用者: 无\n\n9. 函数名: region_type_cap\n- 参数: [vdev, caps, type, subtype]\n- 调用者: vfio_pci_ioctl\n- 被调用者: 无\n\n10. 函数名: vfio_info_cap_shift\n- 参数: [caps, offset]\n- 调用者: vfio_pci_ioctl\n- 被调用者: 无"
    },
    {
        "id": 1408,
        "cwe": "CWE-119",
        "cve": "CVE-2017-18222",
        "purpose": "Code purpose:\"\"\"获取网络子系统统计信息的数量，根据不同的字符串集类型返回相应的静态统计数量\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未处理ETH_SS_PRIV_FLAGS情况，导致缓冲区溢出和内存损坏\"\"\"",
        "functions": "Functions:\n1. 函数名: hns_ppe_get_sset_count\n- 参数: [stringset]\n- 调用者: 未明确（可能是内核中调用该函数的其他模块）\n- 被调用者: []"
    },
    {
        "id": 1409,
        "cwe": "CWE-119",
        "cve": "CVE-2017-18222",
        "purpose": "Code purpose:\"\"\"获取HNS网络子系统环形统计集的计数，仅处理ETH_SS_STATS情况而忽略其他可能的集合类型\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码在处理stringset参数时未考虑ETH_SS_PRIV_FLAGS情况，导致缓冲区溢出和内存损坏漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: hns_rcb_get_ring_sset_count\n- 参数: [stringset]\n- 调用者: 未提供（根据上下文可能由HNS驱动相关代码调用）\n- 被调用者: []"
    },
    {
        "id": 1410,
        "cwe": "CWE-119",
        "cve": "CVE-2017-18222",
        "purpose": "Code purpose:\"\"\"该代码用于获取Hisilicon网络子系统中XGMAC接口的统计信息字符串数量\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未处理ETH_SS_PRIV_FLAGS情况导致缓冲区溢出和内存损坏\"\"\"",
        "functions": "Functions:\n1. 函数名: hns_xgmac_get_sset_count\n- 参数: [stringset]\n- 调用者: 未明确显示（应为调用ETH_SS_STATS相关功能的代码）\n- 被调用者: [ARRAY_SIZE]"
    },
    {
        "id": 1434,
        "cwe": "CWE-119",
        "cve": "CVE-2017-18379",
        "purpose": "Code purpose:\"\"\"在NVMe over Fabrics目标端驱动中，根据连接ID查找对应的目标队列\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在访问关联队列数组时未对队列ID(qid)进行边界检查，导致可能发生越界访问\"\"\"",
        "functions": "Functions:\n1. 函数名: nvmet_fc_find_target_queue\n- 参数: [tgtport, connection_id]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [nvmet_fc_getassociationid, nvmet_fc_getqueueid, atomic_read, nvmet_fc_tgt_q_get]\n\n2. 函数名: nvmet_fc_getassociationid\n- 参数: [connection_id]\n- 调用者: nvmet_fc_find_target_queue\n- 被调用者: 未明确（可能为内联或宏）\n\n3. 函数名: nvmet_fc_getqueueid\n- 参数: [connection_id]\n- 调用者: nvmet_fc_find_target_queue\n- 被调用者: 未明确（可能为内联或宏）\n\n4. 函数名: atomic_read\n- 参数: [&queue->connected]\n- 调用者: nvmet_fc_find_target_queue\n- 被调用者: 未明确（内核原子操作API）\n\n5. 函数名: nvmet_fc_tgt_q_get\n- 参数: [queue]\n- 调用者: nvmet_fc_find_target_queue\n- 被调用者: 未明确（上下文未提供）"
    },
    {
        "id": 1460,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5547",
        "purpose": "Code purpose:\"\"\"该代码用于从Corsair K90键盘获取宏模式状态并通过sysfs接口返回给用户空间。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码在处理USB控制消息时使用了栈分配的缓冲区进行DMA操作，当启用CONFIG_VMAP_STACK配置时可能导致跨虚拟页面的DMA传输，引发系统崩溃或内存破坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: k90_show_macro_mode\n- 参数: [dev, attr, buf]\n- 调用者: 未显示（通常由设备属性系统调用）\n- 被调用者: [to_usb_interface, interface_to_usbdev, usb_control_msg, dev_warn, snprintf]\n\n2. 函数名: to_usb_interface\n- 参数: [dev->parent]\n- 调用者: k90_show_macro_mode\n- 被调用者: 未显示\n\n3. 函数名: interface_to_usbdev\n- 参数: [usbif]\n- 调用者: k90_show_macro_mode\n- 被调用者: 未显示\n\n4. 函数名: usb_control_msg\n- 参数: [usbdev, usb_rcvctrlpipe(usbdev, 0), K90_REQUEST_GET_MODE, USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE, 0, 0, data, 2, USB_CTRL_SET_TIMEOUT]\n- 调用者: k90_show_macro_mode\n- 被调用者: 未显示\n\n5. 函数名: dev_warn\n- 参数: [dev, \"Failed to get K90 initial mode (error %d).\\n\", ret] 和 [dev, \"K90 in unknown mode: %02hhx.\\n\", data[0]]\n- 调用者: k90_show_macro_mode\n- 被调用者: 未显示\n\n6. 函数名: snprintf\n- 参数: [buf, PAGE_SIZE, \"%s\\n\", macro_mode]\n- 调用者: k90_show_macro_mode\n- 被调用者: 未显示\n\n7. 函数名: usb_rcvctrlpipe\n- 参数: [usbdev, 0]\n- 调用者: k90_show_macro_mode (通过usb_control_msg间接调用)\n- 被调用者: 未显示"
    },
    {
        "id": 1461,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5547",
        "purpose": "Code purpose:\"\"\"该代码用于通过USB控制消息获取K90键盘背光亮度状态，并进行有效性检查后返回亮度值\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核驱动在处理DMA散射列表时未正确考虑CONFIG_VMAP_STACK配置，导致使用多个虚拟页时可能引发系统崩溃或内存损坏\"\"\"",
        "functions": "Functions:\n1. 函数名: k90_backlight_get\n- 参数: [struct led_classdev *led_cdev]\n- 调用者: 未明确显示（通常由LED子系统调用）\n- 被调用者: [container_of, to_usb_interface, interface_to_usbdev, usb_control_msg, dev_warn]\n\n2. 函数名: container_of\n- 参数: [ptr, type, member]（从调用上下文推断）\n- 调用者: k90_backlight_get\n- 被调用者: []\n\n3. 函数名: to_usb_interface\n- 参数: [struct device *dev]（从调用上下文推断）\n- 调用者: k90_backlight_get\n- 被调用者: []\n\n4. 函数名: interface_to_usbdev\n- 参数: [struct usb_interface *usbif]（从调用上下文推断）\n- 调用者: k90_backlight_get\n- 被调用者: []\n\n5. 函数名: usb_control_msg\n- 参数: [usbdev, usb_rcvctrlpipe(usbdev, 0), K90_REQUEST_STATUS, USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE, 0, 0, data, 8, USB_CTRL_SET_TIMEOUT]\n- 调用者: k90_backlight_get\n- 被调用者: [usb_rcvctrlpipe]\n\n6. 函数名: usb_rcvctrlpipe\n- 参数: [usbdev, 0]（从调用上下文推断）\n- 调用者: usb_control_msg\n- 被调用者: []\n\n7. 函数名: dev_warn\n- 参数: [dev, format_string, ret/data[4]]（从调用上下文推断）\n- 调用者: k90_backlight_get\n- 被调用者: []"
    },
    {
        "id": 1462,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5547",
        "purpose": "Code purpose:\"\"\"该代码用于通过USB控制消息获取K90设备的当前配置文件状态，并将其格式化输出到缓冲区中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，代码在栈上分配的data数组可能跨越多个虚拟内存页，而usb_control_msg()的DMA操作无法正确处理这种情况，导致系统崩溃或内存损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: k90_show_current_profile\n- 参数: [struct device *dev, struct device_attribute *attr, char *buf]\n- 调用者: 未显示（通常由设备属性子系统调用）\n- 被调用者: [to_usb_interface, interface_to_usbdev, usb_control_msg, dev_warn, snprintf]\n\n2. 函数名: to_usb_interface\n- 参数: [struct device *dev->parent]\n- 调用者: k90_show_current_profile\n- 被调用者: 未显示\n\n3. 函数名: interface_to_usbdev\n- 参数: [struct usb_interface *usbif]\n- 调用者: k90_show_current_profile\n- 被调用者: 未显示\n\n4. 函数名: usb_control_msg\n- 参数: [struct usb_device *usbdev, usb_rcvctrlpipe(usbdev, 0), K90_REQUEST_STATUS, USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE, 0, 0, data, 8, USB_CTRL_SET_TIMEOUT]\n- 调用者: k90_show_current_profile\n- 被调用者: 未显示\n\n5. 函数名: dev_warn\n- 参数: [struct device *dev, const char *fmt, ret/data[7]]\n- 调用者: k90_show_current_profile\n- 被调用者: 未显示\n\n6. 函数名: snprintf\n- 参数: [char *buf, PAGE_SIZE, \"%d\\n\", current_profile]\n- 调用者: k90_show_current_profile\n- 被调用者: 未显示"
    },
    {
        "id": 1463,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5548",
        "purpose": "Code purpose:\"\"\"该代码用于通过USB控制消息获取并显示ATUSB设备的固件版本和硬件类型信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，代码使用栈分配的缓冲区进行DMA操作，而虚拟内存映射的栈可能跨越多个物理页，导致DMA传输时出现内存损坏或系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: atusb_get_and_show_revision\n- 参数: [struct atusb *atusb]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [atusb_control_msg, dev_info]\n\n2. 函数名: atusb_control_msg\n- 参数: [struct atusb *atusb, usb_rcvctrlpipe(usb_dev, 0), ATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0, buffer, 3, 1000]\n- 调用者: atusb_get_and_show_revision\n- 被调用者: 未显示（可能是内核USB接口函数）\n\n3. 函数名: usb_rcvctrlpipe\n- 参数: [usb_dev, 0]\n- 调用者: atusb_get_and_show_revision\n- 被调用者: 未显示（可能是内核USB接口函数）\n\n4. 函数名: dev_info\n- 参数: [&usb_dev->dev, format string, ...]\n- 调用者: atusb_get_and_show_revision\n- 被调用者: 未显示（内核日志函数）"
    },
    {
        "id": 1464,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5548",
        "purpose": "Code purpose:\"\"\"该代码用于通过USB控制消息获取并显示设备的固件构建信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，代码在栈上分配的缓冲区build可能跨越多个虚拟内存页，而DMA操作无法正确处理这种跨页情况，导致系统崩溃或内存损坏\"\"\"",
        "functions": "Functions:\n1. 函数名: atusb_get_and_show_build\n- 参数: [struct atusb *atusb]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [atusb_control_msg, dev_info]\n\n2. 函数名: atusb_control_msg\n- 参数: [struct atusb *atusb, usb_rcvctrlpipe(usb_dev, 0), ATUSB_BUILD, ATUSB_REQ_FROM_DEV, 0, 0, build, ATUSB_BUILD_SIZE, 1000]\n- 调用者: atusb_get_and_show_build\n- 被调用者: 未显示（可能是内核USB核心函数）\n\n3. 函数名: usb_rcvctrlpipe\n- 参数: [usb_dev, 0]\n- 调用者: atusb_get_and_show_build\n- 被调用者: 未显示（内核USB核心函数）\n\n4. 函数名: dev_info\n- 参数: [&usb_dev->dev, \"Firmware: build %s\\n\", build]\n- 调用者: atusb_get_and_show_build\n- 被调用者: 未显示（内核打印函数）"
    },
    {
        "id": 1465,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5548",
        "purpose": "Code purpose:\"\"\"该代码用于通过USB控制消息读取ATUSB设备的寄存器值\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，代码使用栈分配的缓冲区进行DMA操作，而栈分配的内存可能跨越多个虚拟页面，导致系统崩溃或内存损坏\"\"\"",
        "functions": "Functions:\n1. 函数名: atusb_read_reg\n- 参数: [struct atusb *atusb, uint8_t reg]\n- 调用者: 未指定\n- 被调用者: [dev_dbg, atusb_control_msg, usb_rcvctrlpipe]\n\n2. 函数名: dev_dbg\n- 参数: [&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg]\n- 调用者: atusb_read_reg\n- 被调用者: 未指定\n\n3. 函数名: atusb_control_msg\n- 参数: [atusb, usb_rcvctrlpipe(usb_dev, 0), ATUSB_REG_READ, ATUSB_REQ_FROM_DEV, 0, reg, &value, 1, 1000]\n- 调用者: atusb_read_reg\n- 被调用者: 未指定\n\n4. 函数名: usb_rcvctrlpipe\n- 参数: [usb_dev, 0]\n- 调用者: atusb_control_msg\n- 被调用者: 未指定"
    },
    {
        "id": 1490,
        "cwe": "CWE-119",
        "cve": "CVE-2017-7187",
        "purpose": "Code purpose:\"\"\"处理SCSI通用设备(sg)的ioctl命令，包括设置/获取超时、DMA模式、包ID等参数，以及执行SCSI命令等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"SG_NEXT_CMD_LEN ioctl调用中未对用户提供的命令大小进行充分验证，导致sg_write函数中出现基于堆栈的缓冲区溢出。\"\"\"",
        "functions": "Functions:\n1. 函数名: sg_ioctl\n- 参数: [struct file *filp, unsigned int cmd_in, unsigned long arg]\n- 调用者: 内核IOCTL处理机制\n- 被调用者: [sg_printk, atomic_read, scsi_block_when_processing_errors, access_ok, sg_new_write, wait_event_interruptible, srp_done, sg_new_read, get_user, put_user, __put_user, sg_res_in_use, sg_remove_scat, sg_build_reserve, max_sectors_bytes, kmalloc, memset, __copy_to_user, kfree, copy_from_user, sg_allow_access, sg_scsi_ioctl, blk_trace_setup, blk_trace_startstop, blk_trace_remove, scsi_ioctl_block_when_processing_errors, scsi_ioctl]\n\n2. 函数名: sg_printk\n- 参数: [int level, Sg_device *sdp, const char *fmt, ...]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n3. 函数名: atomic_read\n- 参数: [atomic_t *v]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n4. 函数名: scsi_block_when_processing_errors\n- 参数: [struct scsi_device *sdev]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n5. 函数名: access_ok\n- 参数: [int type, const void __user *addr, unsigned long size]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n6. 函数名: sg_new_write\n- 参数: [Sg_fd *sfp, struct file *filp, void __user *buf, size_t count, int blocking, int read_only, int sg_io_owned, Sg_request **srpp]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n7. 函数名: wait_event_interruptible\n- 参数: [wait_queue_head_t *q, condition]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n8. 函数名: srp_done\n- 参数: [Sg_fd *sfp, Sg_request *srp]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n9. 函数名: sg_new_read\n- 参数: [Sg_fd *sfp, void __user *buf, size_t count, Sg_request *srp]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n10. 函数名: get_user\n- 参数: [x, ptr]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n11. 函数名: put_user\n- 参数: [x, ptr]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n12. 函数名: __put_user\n- 参数: [x, ptr]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n13. 函数名: sg_res_in_use\n- 参数: [Sg_fd *sfp]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n14. 函数名: sg_remove_scat\n- 参数: [Sg_fd *sfp, Sg_scatter_hold *schp]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n15. 函数名: sg_build_reserve\n- 参数: [Sg_fd *sfp, int size]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n16. 函数名: max_sectors_bytes\n- 参数: [struct request_queue *q]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n17. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n18. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n19. 函数名: __copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n20. 函数名: kfree\n- 参数: [const void *x]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n21. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n22. 函数名: sg_allow_access\n- 参数: [struct file *filp, unsigned char *cmd]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n23. 函数名: sg_scsi_ioctl\n- 参数: [struct request_queue *q, struct gendisk *disk, fmode_t mode, void __user *p]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n24. 函数名: blk_trace_setup\n- 参数: [struct request_queue *q, char *name, dev_t dev, struct block_device *bdev, char *arg]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n25. 函数名: blk_trace_startstop\n- 参数: [struct request_queue *q, int start]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n26. 函数名: blk_trace_remove\n- 参数: [struct request_queue *q]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n27. 函数名: scsi_ioctl_block_when_processing_errors\n- 参数: [struct scsi_device *sdev, int cmd, bool ndelay]\n- 调用者: sg_ioctl\n- 被调用者: []\n\n28. 函数名: scsi_ioctl\n- 参数: [struct scsi_device *sdev, int cmd, void __user *arg]\n- 调用者: sg_ioctl\n- 被调用者: []"
    },
    {
        "id": 1513,
        "cwe": "CWE-119",
        "cve": "CVE-2017-7541",
        "purpose": "Code purpose:\"\"\"处理无线网络管理帧的传输，包括探测响应和动作帧，并返回传输状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理NL80211_CMD_FRAME Netlink数据包时，未对用户提供的buf参数进行充分边界检查，导致缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: brcmf_cfg80211_mgmt_tx\n- 参数: [wiphy, wdev, params, cookie]\n- 调用者: 未显示（由NL80211_CMD_FRAME Netlink packet触发）\n- 被调用者: [wiphy_to_cfg, ieee80211_is_mgmt, container_of, ieee80211_is_probe_resp, brcmf_vif_set_mgmt_ie, cfg80211_mgmt_tx_status, ieee80211_is_action, kzalloc, memcpy, cpu_to_le32, cpu_to_le16, brcmf_fil_cmd_int_get, ieee80211_frequency_to_channel, le16_to_cpu, brcmf_p2p_send_action_frame, kfree, brcmf_dbg, brcmf_err, brcmf_dbg_hex_dump]\n\n2. 函数名: wiphy_to_cfg\n- 参数: [wiphy]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n3. 函数名: ieee80211_is_mgmt\n- 参数: [mgmt->frame_control]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n4. 函数名: container_of\n- 参数: [wdev, struct brcmf_cfg80211_vif, wdev]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n5. 函数名: ieee80211_is_probe_resp\n- 参数: [mgmt->frame_control]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n6. 函数名: brcmf_vif_set_mgmt_ie\n- 参数: [vif, BRCMF_VNDR_IE_PRBRSP_FLAG, &buf[ie_offset], ie_len]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n7. 函数名: cfg80211_mgmt_tx_status\n- 参数: [wdev, *cookie, buf, len, true/ack, GFP_KERNEL]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n8. 函数名: ieee80211_is_action\n- 参数: [mgmt->frame_control]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n9. 函数名: kzalloc\n- 参数: [sizeof(*af_params), GFP_KERNEL]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n10. 函数名: memcpy\n- 参数: [&action_frame->da[0], &mgmt->da[0], ETH_ALEN], [&af_params->bssid[0], &mgmt->bssid[0], ETH_ALEN], [action_frame->data, &buf[DOT11_MGMT_HDR_LEN], le16_to_cpu(action_frame->len)]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n11. 函数名: cpu_to_le32\n- 参数: [*cookie], [chan_nr]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n12. 函数名: cpu_to_le16\n- 参数: [len - DOT11_MGMT_HDR_LEN]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n13. 函数名: brcmf_fil_cmd_int_get\n- 参数: [vif->ifp, BRCMF_C_GET_CHANNEL, &freq]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n14. 函数名: ieee80211_frequency_to_channel\n- 参数: [freq]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n15. 函数名: le16_to_cpu\n- 参数: [action_frame->len]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n16. 函数名: brcmf_p2p_send_action_frame\n- 参数: [cfg, cfg_to_ndev(cfg), af_params]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n17. 函数名: kfree\n- 参数: [af_params]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n18. 函数名: brcmf_dbg\n- 参数: [TRACE, \"Enter\"], [TRACE, \"Action frame, cookie=%lld, len=%d, freq=%d\\n\", *cookie, le16_to_cpu(action_frame->len), freq], [TRACE, \"Unhandled, fc=%04x!!\\n\", mgmt->frame_control]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n19. 函数名: brcmf_err\n- 参数: [\"Driver only allows MGMT packet type\"], [\"unable to allocate frame\"]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []\n\n20. 函数名: brcmf_dbg_hex_dump\n- 参数: [true, buf, len, \"payload, len=%zu\\n\", len]\n- 调用者: brcmf_cfg80211_mgmt_tx\n- 被调用者: []"
    },
    {
        "id": 1531,
        "cwe": "CWE-119",
        "cve": "CVE-2017-7895",
        "purpose": "Code purpose:\"\"\"该代码用于解码NFSv3服务器接收到的符号链接创建请求参数，包括文件句柄、文件名、属性和目标路径名的处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码在处理NFS请求时未充分验证缓冲区边界，导致可能触发指针算术错误或缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: nfs3svc_decode_symlinkargs\n- 参数: [rqstp, p, args]\n- 调用者: 未显示（由NFS服务调用）\n- 被调用者: [decode_fh, decode_filename, decode_sattr3, ntohl, page_address, min_t]\n\n2. 函数名: decode_fh\n- 参数: [p, &args->ffh]\n- 调用者: nfs3svc_decode_symlinkargs\n- 被调用者: []\n\n3. 函数名: decode_filename\n- 参数: [p, &args->fname, &args->flen]\n- 调用者: nfs3svc_decode_symlinkargs\n- 被调用者: []\n\n4. 函数名: decode_sattr3\n- 参数: [p, &args->attrs]\n- 调用者: nfs3svc_decode_symlinkargs\n- 被调用者: []\n\n5. 函数名: ntohl\n- 参数: [*p++]\n- 调用者: nfs3svc_decode_symlinkargs\n- 被调用者: []\n\n6. 函数名: page_address\n- 参数: [*(rqstp->rq_next_page++)]\n- 调用者: nfs3svc_decode_symlinkargs\n- 被调用者: []\n\n7. 函数名: min_t\n- 参数: [unsigned int, rqstp->rq_arg.page_len, PAGE_SIZE]\n- 调用者: nfs3svc_decode_symlinkargs\n- 被调用者: []"
    },
    {
        "id": 1532,
        "cwe": "CWE-119",
        "cve": "CVE-2017-7895",
        "purpose": "Code purpose:\"\"\"该代码用于解码NFSv3服务器写入请求参数，并验证数据长度和缓冲区边界。\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码在处理NFS请求时未充分验证输入数据的边界，导致可能发生缓冲区溢出或指针算术错误\"\"\"",
        "functions": "Functions:\n1. 函数名: nfs3svc_decode_writeargs\n- 参数: [struct svc_rqst *rqstp, __be32 *p, struct nfsd3_writeargs *args]\n- 调用者: 未显示（由NFS服务调用）\n- 被调用者: [decode_fh, xdr_decode_hyper, ntohl, page_address]\n\n2. 函数名: decode_fh\n- 参数: [__be32 *p, struct nfsd3_writeargs *args]\n- 调用者: nfs3svc_decode_writeargs\n- 被调用者: 未显示\n\n3. 函数名: xdr_decode_hyper\n- 参数: [__be32 *p, &args->offset]\n- 调用者: nfs3svc_decode_writeargs\n- 被调用者: 未显示\n\n4. 函数名: ntohl\n- 参数: [*p++]\n- 调用者: nfs3svc_decode_writeargs\n- 被调用者: 未显示\n\n5. 函数名: page_address\n- 参数: [rqstp->rq_pages[v]]\n- 调用者: nfs3svc_decode_writeargs\n- 被调用者: 未显示\n\n6. 函数名: svc_max_payload\n- 参数: [rqstp]\n- 调用者: nfs3svc_decode_writeargs\n- 被调用者: 未显示"
    },
    {
        "id": 1533,
        "cwe": "CWE-119",
        "cve": "CVE-2017-7895",
        "purpose": "Code purpose:\"\"\"该代码用于解码NFS服务器接收到的写请求参数，包括文件句柄、偏移量和数据长度等，并进行相关验证处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核NFSv2和NFSv3服务器实现中缺少对缓冲区结束的充分检查，导致攻击者可通过精心构造的请求触发指针运算错误\"\"\"",
        "functions": "Functions:\n1. 函数名: nfssvc_decode_writeargs\n- 参数: [struct svc_rqst *rqstp, __be32 *p, struct nfsd_writeargs *args]\n- 调用者: 未明确显示（应为NFS服务处理流程中的调用）\n- 被调用者: [decode_fh, ntohl, page_address]\n\n2. 函数名: decode_fh\n- 参数: [__be32 *p, struct nfsd_writeargs *args->fh]\n- 调用者: nfssvc_decode_writeargs\n- 被调用者: 未明确显示\n\n3. 函数名: ntohl\n- 参数: [__be32 *p]\n- 调用者: nfssvc_decode_writeargs\n- 被调用者: 未明确显示\n\n4. 函数名: page_address\n- 参数: [rqstp->rq_pages[v]]\n- 调用者: nfssvc_decode_writeargs\n- 被调用者: 未明确显示"
    },
    {
        "id": 1535,
        "cwe": "CWE-119",
        "cve": "CVE-2017-8061",
        "purpose": "Code purpose:\"\"\"该代码用于通过USB接口向Cypress USB控制器加载固件，包括停止CPU、写入固件数据和重启CPU的过程。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，内核栈使用虚拟内存映射，而代码未正确处理DMA操作与虚拟内存栈的交互，导致可能使用超过一个虚拟页面的DMA分散列表，引发系统崩溃或内存损坏\"\"\"",
        "functions": "Functions:\n1. 函数名: usb_cypress_load_firmware\n- 参数: [struct usb_device *udev, const struct firmware *fw, int type]\n- 调用者: N/A (top-level function)\n- 被调用者: [kmalloc, usb_cypress_writemem, dvb_usb_get_hexline, kfree]\n\n2. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: usb_cypress_load_firmware\n- 被调用者: N/A\n\n3. 函数名: usb_cypress_writemem\n- 参数: [struct usb_device *udev, u16 addr, u8 *data, u16 len]\n- 调用者: usb_cypress_load_firmware\n- 被调用者: N/A\n\n4. 函数名: dvb_usb_get_hexline\n- 参数: [const struct firmware *fw, struct hexline *hx, int *pos]\n- 调用者: usb_cypress_load_firmware\n- 被调用者: N/A\n\n5. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: usb_cypress_load_firmware\n- 被调用者: N/A\n\n6. 函数名: err\n- 参数: [const char *fmt, ...]\n- 调用者: usb_cypress_load_firmware\n- 被调用者: N/A\n\n7. 函数名: deb_fw\n- 参数: [const char *fmt, ...]\n- 调用者: usb_cypress_load_firmware\n- 被调用者: N/A"
    },
    {
        "id": 1536,
        "cwe": "CWE-119",
        "cve": "CVE-2017-8062",
        "purpose": "Code purpose:\"\"\"该代码实现了DVB USB设备通过I2C总线进行数据传输的功能，包括流控制、远程控制查询和常规I2C读写操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，代码在DMA操作中错误地处理了跨多个虚拟页面的栈缓冲区，导致可能发生系统崩溃或内存损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: su3000_i2c_transfer\n- 参数: [struct i2c_adapter *adap, struct i2c_msg msg[], int num]\n- 调用者: 未显示（应为I2C子系统调用）\n- 被调用者: [i2c_get_adapdata, mutex_lock_interruptible, dvb_usb_generic_rw, memcpy, mutex_unlock, err, warn]\n\n2. 函数名: i2c_get_adapdata\n- 参数: [struct i2c_adapter *adap]\n- 调用者: su3000_i2c_transfer\n- 被调用者: 未显示\n\n3. 函数名: mutex_lock_interruptible\n- 参数: [&d->i2c_mutex]\n- 调用者: su3000_i2c_transfer\n- 被调用者: 未显示\n\n4. 函数名: dvb_usb_generic_rw\n- 参数: [d, obuf, size1, ibuf, size2, 0]（参数数量可变）\n- 调用者: su3000_i2c_transfer\n- 被调用者: 未显示\n\n5. 函数名: memcpy\n- 参数: [&obuf[3], msg[0].buf, msg[0].len] 或 [&obuf[4], msg[0].buf, msg[0].len] 或 [msg[1].buf, &ibuf[1], msg[1].len]\n- 调用者: su3000_i2c_transfer\n- 被调用者: 未显示\n\n6. 函数名: mutex_unlock\n- 参数: [&d->i2c_mutex]\n- 调用者: su3000_i2c_transfer\n- 被调用者: 未显示\n\n7. 函数名: err\n- 参数: [\"i2c transfer failed.\"]\n- 调用者: su3000_i2c_transfer\n- 被调用者: 未显示\n\n8. 函数名: warn\n- 参数: [\"more than 2 i2c messages at a time is not handled yet.\"]\n- 调用者: su3000_i2c_transfer\n- 被调用者: 未显示"
    },
    {
        "id": 1537,
        "cwe": "CWE-119",
        "cve": "CVE-2017-8062",
        "purpose": "Code purpose:\"\"\"控制DVB USB设备的电源状态并在未初始化时进行重置\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，代码在DMA操作中错误地使用了栈分配的缓冲区，导致可能跨越多个虚拟页面的DMA分散列表引发系统崩溃或内存损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: su3000_power_ctrl\n- 参数: [struct dvb_usb_device *d, int i]\n- 调用者: 未明确（由DVB USB子系统调用）\n- 被调用者: [dvb_usb_generic_rw, info]\n\n2. 函数名: dvb_usb_generic_rw\n- 参数: [struct dvb_usb_device *d, u8 *obuf, int obuf_len, u8 *ibuf, int ibuf_len, int delay_ms]\n- 调用者: su3000_power_ctrl\n- 被调用者: 未明确（底层USB通信函数）\n\n3. 函数名: info\n- 参数: [const char *fmt, ...]\n- 调用者: su3000_power_ctrl\n- 被调用者: 未明确（内核打印函数）"
    },
    {
        "id": 1538,
        "cwe": "CWE-119",
        "cve": "CVE-2017-8062",
        "purpose": "Code purpose:\"\"\"该代码实现了DVB USB设备的调谐器和解调器前端连接功能，包括设备初始化、I2C通信、模块加载和配置等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核在使用CONFIG_VMAP_STACK选项时，未能正确处理DMA scatterlist跨越多个虚拟页面的情况，导致本地用户可能引发系统崩溃或内存破坏\"\"\"",
        "functions": "Functions:\n1. 函数名: tt_s2_4600_frontend_attach\n- 参数: [struct dvb_usb_adapter *adap]\n- 调用者: 未显示\n- 被调用者: [dvb_usb_generic_rw, err, msleep, memset, strlcpy, request_module, i2c_new_device, try_module_get, i2c_unregister_device, m88ds3103_pdata.get_dvb_frontend, m88ds3103_pdata.get_i2c_adapter, dvb_frontend_detach]\n\n2. 函数名: dvb_usb_generic_rw\n- 参数: [struct dvb_usb_device *d, u8 *obuf, int olen, u8 *ibuf, int ilen, int delay]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n3. 函数名: err\n- 参数: [const char *fmt, ...]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n4. 函数名: msleep\n- 参数: [unsigned int msecs]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n5. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n6. 函数名: strlcpy\n- 参数: [char *dest, const char *src, size_t size]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n7. 函数名: request_module\n- 参数: [const char *fmt, ...]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n8. 函数名: i2c_new_device\n- 参数: [struct i2c_adapter *adap, struct i2c_board_info const *info]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n9. 函数名: try_module_get\n- 参数: [struct module *module]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n10. 函数名: i2c_unregister_device\n- 参数: [struct i2c_client *client]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n11. 函数名: m88ds3103_pdata.get_dvb_frontend\n- 参数: [struct i2c_client *client]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n12. 函数名: m88ds3103_pdata.get_i2c_adapter\n- 参数: [struct i2c_client *client]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n13. 函数名: dvb_frontend_detach\n- 参数: [struct dvb_frontend *fe]\n- 调用者: tt_s2_4600_frontend_attach\n- 被调用者: 未显示\n\n14. 函数名: tt_s2_4600_read_status\n- 参数: 未显示\n- 调用者: 未显示\n- 被调用者: tt_s2_4600_frontend_attach (通过函数指针赋值)"
    },
    {
        "id": 1539,
        "cwe": "CWE-119",
        "cve": "CVE-2017-8063",
        "purpose": "Code purpose:\"\"\"该代码用于处理DVB USB设备的控制消息，包括命令发送和数据读写操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，代码未正确处理虚拟内存页边界，导致DMA操作可能跨越多个虚拟页面，引发系统崩溃或其他未指定影响\"\"\"",
        "functions": "Functions:\n1. 函数名: cxusb_ctrl_msg\n- 参数: [struct dvb_usb_device *d, u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [memcpy, dvb_usb_generic_write, dvb_usb_generic_rw, mutex_lock, mutex_unlock]\n\n2. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: cxusb_ctrl_msg\n- 被调用者: []\n\n3. 函数名: dvb_usb_generic_write\n- 参数: [struct dvb_usb_device *d, u8 *buf, int len]\n- 调用者: cxusb_ctrl_msg\n- 被调用者: []\n\n4. 函数名: dvb_usb_generic_rw\n- 参数: [struct dvb_usb_device *d, u8 *wbuf, int wlen, u8 *rbuf, int rlen, int delay_ms]\n- 调用者: cxusb_ctrl_msg\n- 被调用者: []\n\n5. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: cxusb_ctrl_msg\n- 被调用者: []\n\n6. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: cxusb_ctrl_msg\n- 被调用者: []"
    },
    {
        "id": 1540,
        "cwe": "CWE-119",
        "cve": "CVE-2017-8066",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中GS USB CAN驱动程序的探测功能，用于初始化和配置USB接口的CAN设备。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，代码在DMA操作中错误地处理了多虚拟页面的scatterlist，导致可能的内存损坏或系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: gs_usb_probe\n- 参数: [struct usb_interface *intf, const struct usb_device_id *id]\n- 调用者: USB子系统（当设备匹配时）\n- 被调用者: [usb_control_msg, interface_to_usbdev, dev_err, dev_info, kzalloc, init_usb_anchor, atomic_set, usb_set_intfdata, gs_make_candev, IS_ERR_OR_NULL, PTR_ERR, gs_destroy_candev, usb_kill_anchored_urbs, kfree]\n\n2. 函数名: usb_control_msg\n- 参数: [struct usb_device *dev, unsigned int pipe, __u8 request, __u8 requesttype, __u16 value, __u16 index, void *data, __u16 size, int timeout]\n- 调用者: gs_usb_probe\n- 被调用者: USB核心驱动函数\n\n3. 函数名: interface_to_usbdev\n- 参数: [struct usb_interface *intf]\n- 调用者: gs_usb_probe\n- 被调用者: USB核心驱动函数\n\n4. 函数名: dev_err\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: gs_usb_probe\n- 被调用者: 内核日志系统\n\n5. 函数名: dev_info\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: gs_usb_probe\n- 被调用者: 内核日志系统\n\n6. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: gs_usb_probe\n- 被调用者: 内核内存分配系统\n\n7. 函数名: init_usb_anchor\n- 参数: [struct usb_anchor *anchor]\n- 调用者: gs_usb_probe\n- 被调用者: USB核心驱动函数\n\n8. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: gs_usb_probe\n- 被调用者: 内核原子操作函数\n\n9. 函数名: usb_set_intfdata\n- 参数: [struct usb_interface *intf, void *data]\n- 调用者: gs_usb_probe\n- 被调用者: USB核心驱动函数\n\n10. 函数名: gs_make_candev\n- 参数: [int i, struct usb_interface *intf, struct gs_device_config *dconf]\n- 调用者: gs_usb_probe\n- 被调用者: 未知（驱动特定函数）\n\n11. 函数名: IS_ERR_OR_NULL\n- 参数: [const void *ptr]\n- 调用者: gs_usb_probe\n- 被调用者: 内核错误处理宏\n\n12. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: gs_usb_probe\n- 被调用者: 内核错误处理宏\n\n13. 函数名: gs_destroy_candev\n- 参数: [struct gs_can *dev]\n- 调用者: gs_usb_probe\n- 被调用者: 未知（驱动特定函数）\n\n14. 函数名: usb_kill_anchored_urbs\n- 参数: [struct usb_anchor *anchor]\n- 调用者: gs_usb_probe\n- 被调用者: USB核心驱动函数\n\n15. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: gs_usb_probe\n- 被调用者: 内核内存释放函数"
    },
    {
        "id": 1542,
        "cwe": "CWE-119",
        "cve": "CVE-2017-8068",
        "purpose": "Code purpose:\"\"\"通过USB控制消息设置Pegasus USB网络适配器的寄存器值\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，代码未正确处理跨多个虚拟页面的DMA分散列表，导致可能的内存损坏或系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: set_register\n- 参数: [pegasus_t *pegasus, __u16 indx, __u8 data]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [usb_control_msg, netif_dbg]\n\n2. 函数名: usb_control_msg\n- 参数: [pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0), PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data, indx, &data, 1, 1000]\n- 调用者: set_register\n- 被调用者: 未明确（系统函数）\n\n3. 函数名: netif_dbg\n- 参数: [pegasus, drv, pegasus->net, \"%s returned %d\\n\", __func__, ret]\n- 调用者: set_register\n- 被调用者: 未明确（系统函数）\n\n4. 函数名: usb_sndctrlpipe\n- 参数: [pegasus->usb, 0]\n- 调用者: set_register\n- 被调用者: 未明确（系统函数）"
    },
    {
        "id": 1543,
        "cwe": "CWE-119",
        "cve": "CVE-2017-8068",
        "purpose": "Code purpose:\"\"\"通过USB控制消息从Pegasus设备读取寄存器数据\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，代码未正确处理跨多个虚拟页面的DMA分散列表，导致可能的内存损坏或系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: get_registers\n- 参数: [pegasus_t *pegasus, __u16 indx, __u16 size, void *data]\n- 调用者: 未明确（需查看完整代码）\n- 被调用者: [usb_control_msg, netif_dbg]\n\n2. 函数名: usb_control_msg\n- 参数: [pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0), PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0, indx, data, size, 1000]\n- 调用者: get_registers\n- 被调用者: 未明确（系统API）\n\n3. 函数名: usb_rcvctrlpipe\n- 参数: [pegasus->usb, 0]\n- 调用者: usb_control_msg\n- 被调用者: 未明确（系统API）\n\n4. 函数名: netif_dbg\n- 参数: [pegasus, drv, pegasus->net, \"%s returned %d\\n\", __func__, ret]\n- 调用者: get_registers\n- 被调用者: 未明确（内核API）"
    },
    {
        "id": 1544,
        "cwe": "CWE-119",
        "cve": "CVE-2017-8069",
        "purpose": "Code purpose:\"\"\"通过USB控制消息从设备获取寄存器数据\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，该代码未正确处理跨多个虚拟页面的DMA分散/聚集列表，可能导致系统崩溃或内存损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: get_registers\n- 参数: [rtl8150_t *dev, u16 indx, u16 size, void *data]\n- 调用者: 未指定\n- 被调用者: [usb_control_msg, usb_rcvctrlpipe]\n\n2. 函数名: usb_control_msg\n- 参数: [dev->udev, usb_rcvctrlpipe(dev->udev, 0), RTL8150_REQ_GET_REGS, RTL8150_REQT_READ, indx, 0, data, size, 500]\n- 调用者: get_registers\n- 被调用者: 未指定\n\n3. 函数名: usb_rcvctrlpipe\n- 参数: [dev->udev, 0]\n- 调用者: get_registers\n- 被调用者: 未指定"
    },
    {
        "id": 1577,
        "cwe": "CWE-119",
        "cve": "CVE-2018-1000199",
        "purpose": "Code purpose:\"\"\"修改用户硬件断点的属性并验证其有效性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在修改硬件断点属性时未正确验证输入参数，可能导致内存损坏或系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: modify_user_hw_breakpoint\n- 参数: [struct perf_event *bp, struct perf_event_attr *attr]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [perf_event_disable_local, perf_event_disable, validate_hw_breakpoint, perf_event_enable]\n\n2. 函数名: perf_event_disable_local\n- 参数: [struct perf_event *bp]\n- 调用者: modify_user_hw_breakpoint\n- 被调用者: 未明确\n\n3. 函数名: perf_event_disable\n- 参数: [struct perf_event *bp]\n- 调用者: modify_user_hw_breakpoint\n- 被调用者: 未明确\n\n4. 函数名: validate_hw_breakpoint\n- 参数: [struct perf_event *bp]\n- 调用者: modify_user_hw_breakpoint\n- 被调用者: 未明确\n\n5. 函数名: perf_event_enable\n- 参数: [struct perf_event *bp]\n- 调用者: modify_user_hw_breakpoint\n- 被调用者: 未明确"
    },
    {
        "id": 1586,
        "cwe": "CWE-119",
        "cve": "CVE-2018-10124",
        "purpose": "Code purpose:\"\"\"该代码用于向指定进程或进程组发送信号，根据不同的pid参数值执行不同的信号发送逻辑\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当传入的pid参数为INT_MIN时，由于整数溢出导致条件判断失效，可能引发拒绝服务攻击\"\"\"",
        "functions": "Functions:\n1. 函数名: kill_something_info\n- 参数: [sig, info, pid]\n- 调用者: 未指定\n- 被调用者: [kill_pid_info, find_vpid, __kill_pgrp_info, task_pgrp, for_each_process, task_pid_vnr, same_thread_group, group_send_sig_info]\n\n2. 函数名: kill_pid_info\n- 参数: [sig, info, pid]\n- 调用者: kill_something_info\n- 被调用者: 未指定\n\n3. 函数名: find_vpid\n- 参数: [pid]\n- 调用者: kill_something_info\n- 被调用者: 未指定\n\n4. 函数名: __kill_pgrp_info\n- 参数: [sig, info, pgrp]\n- 调用者: kill_something_info\n- 被调用者: 未指定\n\n5. 函数名: task_pgrp\n- 参数: [current]\n- 调用者: kill_something_info\n- 被调用者: 未指定\n\n6. 函数名: for_each_process\n- 参数: [p]\n- 调用者: kill_something_info\n- 被调用者: 未指定\n\n7. 函数名: task_pid_vnr\n- 参数: [p]\n- 调用者: kill_something_info\n- 被调用者: 未指定\n\n8. 函数名: same_thread_group\n- 参数: [p, current]\n- 调用者: kill_something_info\n- 被调用者: 未指定\n\n9. 函数名: group_send_sig_info\n- 参数: [sig, info, p]\n- 调用者: kill_something_info\n- 被调用者: 未指定"
    },
    {
        "id": 1629,
        "cwe": "CWE-119",
        "cve": "CVE-2018-10940",
        "purpose": "Code purpose:\"\"\"该代码用于处理CDROM设备中媒体变更的ioctl请求，检查媒体状态变化并返回结果。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在cdrom_ioctl_media_changed函数中，对参数arg的边界检查不充分，导致可以越界访问info->slots数组，从而读取内核内存\"\"\"",
        "functions": "Functions:\n1. 函数名: cdrom_ioctl_media_changed\n- 参数: [struct cdrom_device_info *cdi, unsigned long arg]\n- 调用者: 未指定（由内核IOCTL调用）\n- 被调用者: [media_changed, kmalloc, cdrom_read_mech_status, kfree]\n\n2. 函数名: media_changed\n- 参数: [struct cdrom_device_info *cdi, int arg]\n- 调用者: cdrom_ioctl_media_changed\n- 被调用者: 未指定\n\n3. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: cdrom_ioctl_media_changed\n- 被调用者: 未指定\n\n4. 函数名: cdrom_read_mech_status\n- 参数: [struct cdrom_device_info *cdi, struct cdrom_changer_info *info]\n- 调用者: cdrom_ioctl_media_changed\n- 被调用者: 未指定\n\n5. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: cdrom_ioctl_media_changed\n- 被调用者: 未指定"
    },
    {
        "id": 1635,
        "cwe": "CWE-119",
        "cve": "CVE-2018-1120",
        "purpose": "Code purpose:\"\"\"该代码用于读取并返回指定进程的命令行参数和环境变量信息，通过访问进程的内存空间来获取这些数据。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于内核在读取/proc/<pid>/cmdline文件时未正确处理FUSE-backed文件的mmap映射，导致攻击者可以通过精心构造的映射使读取操作无限期阻塞，造成拒绝服务。\"\"\"",
        "functions": "Functions:\n1. 函数名: proc_pid_cmdline_read\n- 参数: [struct file *file, char __user *buf, size_t _count, loff_t *pos]\n- 调用者: 内核proc文件系统\n- 被调用者: [get_proc_task, file_inode, get_task_mm, put_task_struct, __get_free_page, down_read, up_read, access_remote_vm, copy_to_user, free_page, mmput, min3, strnlen]\n\n2. 函数名: get_proc_task\n- 参数: [struct inode *inode]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n3. 函数名: file_inode\n- 参数: [struct file *file]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n4. 函数名: get_task_mm\n- 参数: [struct task_struct *task]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n5. 函数名: put_task_struct\n- 参数: [struct task_struct *tsk]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n6. 函数名: __get_free_page\n- 参数: [gfp_t gfp_mask]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n7. 函数名: down_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n8. 函数名: up_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n9. 函数名: access_remote_vm\n- 参数: [struct mm_struct *mm, unsigned long addr, void *buf, size_t len, int gup_flags]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n10. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n11. 函数名: free_page\n- 参数: [unsigned long addr]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n12. 函数名: mmput\n- 参数: [struct mm_struct *mm]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n13. 函数名: min3\n- 参数: [type x, type y, type z]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []\n\n14. 函数名: strnlen\n- 参数: [const char *s, size_t count]\n- 调用者: proc_pid_cmdline_read\n- 被调用者: []"
    },
    {
        "id": 1636,
        "cwe": "CWE-119",
        "cve": "CVE-2018-1120",
        "purpose": "Code purpose:\"\"\"该代码用于从进程的内存中读取环境变量数据并通过/proc文件系统提供给用户空间程序访问。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于未正确处理FUSE文件系统映射到进程内存环境变量时的访问控制，导致攻击者可以通过恶意构造的FUSE文件造成读取/proc/<pid>/environ时无限阻塞或延迟。\"\"\"",
        "functions": "Functions:\n1. 函数名: environ_read\n- 参数: [struct file *file, char __user *buf, size_t count, loff_t *ppos]\n- 调用者: 内核proc文件系统\n- 被调用者: [__get_free_page, mmget_not_zero, down_read, up_read, access_remote_vm, copy_to_user, mmput, free_page]\n\n2. 函数名: __get_free_page\n- 参数: [GFP_KERNEL]\n- 调用者: environ_read\n- 被调用者: []\n\n3. 函数名: mmget_not_zero\n- 参数: [mm]\n- 调用者: environ_read\n- 被调用者: []\n\n4. 函数名: down_read\n- 参数: [&mm->mmap_sem]\n- 调用者: environ_read\n- 被调用者: []\n\n5. 函数名: up_read\n- 参数: [&mm->mmap_sem]\n- 调用者: environ_read\n- 被调用者: []\n\n6. 函数名: access_remote_vm\n- 参数: [mm, (env_start + src), page, this_len, 0]\n- 调用者: environ_read\n- 被调用者: []\n\n7. 函数名: copy_to_user\n- 参数: [buf, page, retval]\n- 调用者: environ_read\n- 被调用者: []\n\n8. 函数名: mmput\n- 参数: [mm]\n- 调用者: environ_read\n- 被调用者: []\n\n9. 函数名: free_page\n- 参数: [(unsigned long) page]\n- 调用者: environ_read\n- 被调用者: []"
    },
    {
        "id": 1637,
        "cwe": "CWE-119",
        "cve": "CVE-2018-1120",
        "purpose": "Code purpose:\"\"\"检查虚拟内存区域(vma)的访问权限是否符合给定的标志位要求，确保内存访问的安全性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核在处理FUSE-backed文件的mmap映射时，未能正确处理/proc/<pid>/cmdline或/proc/<pid>/environ的读取操作，导致拒绝服务攻击\"\"\"",
        "functions": "Functions:\n1. 函数名: check_vma_flags\n- 参数: [struct vm_area_struct *vma, unsigned long gup_flags]\n- 调用者: 未在代码片段中显示\n- 被调用者: [is_cow_mapping, arch_vma_access_permitted]\n\n2. 函数名: is_cow_mapping\n- 参数: [vm_flags_t vm_flags]\n- 调用者: check_vma_flags\n- 被调用者: 未在代码片段中显示\n\n3. 函数名: arch_vma_access_permitted\n- 参数: [struct vm_area_struct *vma, int write, int execute, int foreign]\n- 调用者: check_vma_flags\n- 被调用者: 未在代码片段中显示"
    },
    {
        "id": 1652,
        "cwe": "CWE-119",
        "cve": "CVE-2018-12233",
        "purpose": "Code purpose:\"\"\"该代码用于处理JFS文件系统中扩展属性的获取操作，包括内存分配、属性读取和大小验证等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在JFS文件系统的ea_get函数中，当处理扩展属性时，kmalloc分配的内存大小计算不正确，导致内存越界访问\"\"\"",
        "functions": "Functions:\n1. 函数名: ea_get\n- 参数: [inode, ea_buf, min_size]\n- 调用者: N/A (系统调用或其它内核函数)\n- 被调用者: [jfs_error, kmalloc, kfree, ea_read, dquot_alloc_block, dbAlloc, get_metapage, dbFree, discard_metapage, read_metapage, ea_release, dquot_free_block]\n\n2. 函数名: jfs_error\n- 参数: [sb, error_message]\n- 调用者: ea_get\n- 被调用者: []\n\n3. 函数名: kmalloc\n- 参数: [size, flags]\n- 调用者: ea_get\n- 被调用者: []\n\n4. 函数名: kfree\n- 参数: [ptr]\n- 调用者: ea_get\n- 被调用者: []\n\n5. 函数名: ea_read\n- 参数: [inode, xattr]\n- 调用者: ea_get\n- 被调用者: []\n\n6. 函数名: dquot_alloc_block\n- 参数: [inode, blocks_needed]\n- 调用者: ea_get\n- 被调用者: []\n\n7. 函数名: dbAlloc\n- 参数: [inode, hint, blocks_needed, blkno]\n- 调用者: ea_get\n- 被调用者: []\n\n8. 函数名: get_metapage\n- 参数: [inode, blkno, size, flag]\n- 调用者: ea_get\n- 被调用者: []\n\n9. 函数名: dbFree\n- 参数: [inode, blkno, blocks_needed]\n- 调用者: ea_get\n- 被调用者: []\n\n10. 函数名: discard_metapage\n- 参数: [mp]\n- 调用者: ea_get\n- 被调用者: []\n\n11. 函数名: read_metapage\n- 参数: [inode, address, length, flag]\n- 调用者: ea_get\n- 被调用者: []\n\n12. 函数名: ea_release\n- 参数: [inode, ea_buf]\n- 调用者: ea_get\n- 被调用者: []\n\n13. 函数名: dquot_free_block\n- 参数: [inode, quota_allocation]\n- 调用者: ea_get\n- 被调用者: []"
    },
    {
        "id": 1686,
        "cwe": "CWE-119",
        "cve": "CVE-2018-14615",
        "purpose": "Code purpose:\"\"\"该代码用于检查F2FS文件系统中inode结构的完整性，验证各种可能损坏的情况并设置需要文件系统检查的标志\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在truncate_inline_inode()函数中处理f2fs镜像卸载时，由于未正确验证长度值可能为负数的情况，导致缓冲区溢出漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: sanity_check_inode\n- 参数: [struct inode *inode, struct page *node_page]\n- 调用者: 未明确显示（通常是文件系统操作相关函数）\n- 被调用者: [le64_to_cpu, set_sbi_flag, f2fs_msg, ino_of_node, nid_of_node, f2fs_sb_has_flexible_inline_xattr, f2fs_has_extra_attr, f2fs_sb_has_extra_attr, F2FS_I, f2fs_is_valid_blkaddr]\n\n2. 函数名: le64_to_cpu\n- 参数: [F2FS_INODE(node_page)->i_blocks]\n- 调用者: sanity_check_inode\n- 被调用者: []\n\n3. 函数名: set_sbi_flag\n- 参数: [struct f2fs_sb_info *sbi, SBI_NEED_FSCK]\n- 调用者: sanity_check_inode\n- 被调用者: []\n\n4. 函数名: f2fs_msg\n- 参数: [sbi->sb, KERN_WARNING, format_string, __func__, inode->i_ino, iblocks/ino_of_node(node_page), nid_of_node(node_page)/...]\n- 调用者: sanity_check_inode\n- 被调用者: []\n\n5. 函数名: ino_of_node\n- 参数: [node_page]\n- 调用者: sanity_check_inode\n- 被调用者: []\n\n6. 函数名: nid_of_node\n- 参数: [node_page]\n- 调用者: sanity_check_inode\n- 被调用者: []\n\n7. 函数名: f2fs_sb_has_flexible_inline_xattr\n- 参数: [sbi->sb]\n- 调用者: sanity_check_inode\n- 被调用者: []\n\n8. 函数名: f2fs_has_extra_attr\n- 参数: [inode]\n- 调用者: sanity_check_inode\n- 被调用者: []\n\n9. 函数名: f2fs_sb_has_extra_attr\n- 参数: [sbi->sb]\n- 调用者: sanity_check_inode\n- 被调用者: []\n\n10. 函数名: F2FS_I\n- 参数: [inode]\n- 调用者: sanity_check_inode\n- 被调用者: []\n\n11. 函数名: f2fs_is_valid_blkaddr\n- 参数: [sbi, ei->blk, DATA_GENERIC] 或 [sbi, ei->blk + ei->len - 1, DATA_GENERIC]\n- 调用者: sanity_check_inode\n- 被调用者: []"
    },
    {
        "id": 1786,
        "cwe": "CWE-119",
        "cve": "CVE-2018-20855",
        "purpose": "Code purpose:\"\"\"在Linux内核中创建和管理InfiniBand队列对(QP)，处理不同类型的QP创建请求和相关属性设置\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在create_qp_common函数中，结构体mlx5_ib_create_qp_resp resp未初始化就被使用，导致栈内存信息泄露到用户空间\"\"\"",
        "functions": "Functions:\n1. 函数名: create_qp_common\n- 参数: [struct mlx5_ib_dev *dev, struct ib_pd *pd, struct ib_qp_init_attr *init_attr, struct ib_udata *udata, struct mlx5_ib_qp *qp]\n- 调用者: N/A (顶层函数)\n- 被调用者: [to_mlx5_st, create_rss_raw_qp_tir, to_mlx5_st, ib_copy_from_udata, get_qp_user_index, tunnel_offload_supported, mlx5_get_flow_namespace, set_rq_size, create_user_qp, create_kernel_qp, kvzalloc, is_sqp, to_mpd, is_connected, mlx5_ib_get_cqe_size, get_rx_type, create_raw_packet_qp, mlx5_core_create_qp, kvfree, get_cqs, mlx5_ib_lock_cqs, mlx5_ib_unlock_cqs, destroy_qp_user, destroy_qp_kernel]\n\n2. 函数名: to_mlx5_st\n- 参数: [enum ib_qp_type qp_type]\n- 调用者: create_qp_common\n- 被调用者: []\n\n3. 函数名: create_rss_raw_qp_tir\n- 参数: [struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp, struct ib_pd *pd, struct ib_qp_init_attr *init_attr, struct ib_udata *udata]\n- 调用者: create_qp_common\n- 被调用者: []\n\n4. 函数名: ib_copy_from_udata\n- 参数: [struct mlx5_ib_create_qp *ucmd, struct ib_udata *udata, size_t len]\n- 调用者: create_qp_common\n- 被调用者: []\n\n5. 函数名: get_qp_user_index\n- 参数: [struct mlx5_ib_ucontext *context, struct mlx5_ib_create_qp *ucmd, size_t udata_inlen, u32 *uidx]\n- 调用者: create_qp_common\n- 被调用者: []\n\n6. 函数名: tunnel_offload_supported\n- 参数: [struct mlx5_core_dev *mdev]\n- 调用者: create_qp_common\n- 被调用者: []\n\n7. 函数名: mlx5_get_flow_namespace\n- 参数: [struct mlx5_core_dev *mdev, enum mlx5_flow_namespace_type type]\n- 调用者: create_qp_common\n- 被调用者: []\n\n8. 函数名: set_rq_size\n- 参数: [struct mlx5_ib_dev *dev, struct ib_qp_cap *cap, bool has_rq, struct mlx5_ib_qp *qp, struct mlx5_ib_create_qp *ucmd]\n- 调用者: create_qp_common\n- 被调用者: []\n\n9. 函数名: create_user_qp\n- 参数: [struct mlx5_ib_dev *dev, struct ib_pd *pd, struct mlx5_ib_qp *qp, struct ib_udata *udata, struct ib_qp_init_attr *init_attr, u32 **in, struct mlx5_ib_create_qp_resp *resp, int *inlen, struct mlx5_ib_qp_base *base]\n- 调用者: create_qp_common\n- 被调用者: []\n\n10. 函数名: create_kernel_qp\n- 参数: [struct mlx5_ib_dev *dev, struct ib_qp_init_attr *init_attr, struct mlx5_ib_qp *qp, u32 **in, int *inlen, struct mlx5_ib_qp_base *base]\n- 调用者: create_qp_common\n- 被调用者: []\n\n11. 函数名: kvzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: create_qp_common\n- 被调用者: []\n\n12. 函数名: is_sqp\n- 参数: [enum ib_qp_type qp_type]\n- 调用者: create_qp_common\n- 被调用者: []\n\n13. 函数名: to_mpd\n- 参数: [struct ib_pd *pd]\n- 调用者: create_qp_common\n- 被调用者: []\n\n14. 函数名: is_connected\n- 参数: [enum ib_qp_type qp_type]\n- 调用者: create_qp_common\n- 被调用者: []\n\n15. 函数名: mlx5_ib_get_cqe_size\n- 参数: [struct mlx5_ib_dev *dev, struct ib_cq *cq]\n- 调用者: create_qp_common\n- 被调用者: []\n\n16. 函数名: get_rx_type\n- 参数: [struct mlx5_ib_qp *qp, struct ib_qp_init_attr *init_attr]\n- 调用者: create_qp_common\n- 被调用者: []\n\n17. 函数名: create_raw_packet_qp\n- 参数: [struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp, u32 *in, int inlen, struct ib_pd *pd]\n- 调用者: create_qp_common\n- 被调用者: []\n\n18. 函数名: mlx5_core_create_qp\n- 参数: [struct mlx5_core_dev *mdev, struct mlx5_core_qp *qp, u32 *in, int inlen]\n- 调用者: create_qp_common\n- 被调用者: []\n\n19. 函数名: kvfree\n- 参数: [const void *addr]\n- 调用者: create_qp_common\n- 被调用者: []\n\n20. 函数名: get_cqs\n- 参数: [enum ib_qp_type qp_type, struct ib_cq *send_cq, struct ib_cq *recv_cq, struct mlx5_ib_cq **send_cq_out, struct mlx5_ib_cq **recv_cq_out]\n- 调用者: create_qp_common\n- 被调用者: []\n\n21. 函数名: mlx5_ib_lock_cqs\n- 参数: [struct mlx5_ib_cq *send_cq, struct mlx5_ib_cq *recv_cq]\n- 调用者: create_qp_common\n- 被调用者: []\n\n22. 函数名: mlx5_ib_unlock_cqs\n- 参数: [struct mlx5_ib_cq *send_cq, struct mlx5_ib_cq *recv_cq]\n- 调用者: create_qp_common\n- 被调用者: []\n\n23. 函数名: destroy_qp_user\n- 参数: [struct mlx5_ib_dev *dev, struct ib_pd *pd, struct mlx5_ib_qp *qp, struct mlx5_ib_qp_base *base]\n- 调用者: create_qp_common\n- 被调用者: []\n\n24. 函数名: destroy_qp_kernel\n- 参数: [struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp]\n- 调用者: create_qp_common\n- 被调用者: []"
    },
    {
        "id": 1839,
        "cwe": "CWE-119",
        "cve": "CVE-2018-5848",
        "purpose": "Code purpose:\"\"\"该代码用于设置无线管理信息元素(IE)，通过分配内存、填充命令结构体并发送给无线模块来实现，但存在长度验证不足导致的缓冲区溢出风险\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确处理'ie_len'参数的无符号整数溢出，导致分配的内存缓冲区可能不足，从而引发缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: wmi_set_ie\n- 参数: [struct wil6210_priv *wil, u8 type, u16 ie_len, const void *ie]\n- 调用者: 未明确（外部调用）\n- 被调用者: [kzalloc, cpu_to_le16, memcpy, wmi_send, kfree, wil_err]\n\n2. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: wmi_set_ie\n- 被调用者: []\n\n3. 函数名: cpu_to_le16\n- 参数: [__u16 val]\n- 调用者: wmi_set_ie\n- 被调用者: []\n\n4. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: wmi_set_ie\n- 被调用者: []\n\n5. 函数名: wmi_send\n- 参数: [struct wil6210_priv *wil, u16 cmdid, void *buf, u16 len]\n- 调用者: wmi_set_ie\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: wmi_set_ie\n- 被调用者: []\n\n7. 函数名: wil_err\n- 参数: [struct wil6210_priv *wil, const char *fmt, ...]\n- 调用者: wmi_set_ie\n- 被调用者: []"
    },
    {
        "id": 1847,
        "cwe": "CWE-119",
        "cve": "CVE-2018-7566",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中音序器设备的事件写入功能，处理用户空间传递的音频事件数据并将其加入队列。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理可变长度事件数据时，未能充分验证用户提供的扩展数据长度，导致缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_seq_write\n- 参数: [struct file *file, const char __user *buf, size_t count, loff_t *offset]\n- 调用者: 未显示（系统调用或驱动接口）\n- 被调用者: [snd_seq_file_flags, snd_BUG_ON, snd_seq_write_pool_allocated, snd_seq_pool_init, copy_from_user, check_event_type_and_length, snd_seq_ev_is_reserved, snd_seq_ev_is_variable, snd_seq_ev_is_varusr, snd_seq_client_enqueue_event]\n\n2. 函数名: snd_seq_file_flags\n- 参数: [struct file *file]\n- 调用者: snd_seq_write\n- 被调用者: []\n\n3. 函数名: snd_BUG_ON\n- 参数: [!client]\n- 调用者: snd_seq_write\n- 被调用者: []\n\n4. 函数名: snd_seq_write_pool_allocated\n- 参数: [struct snd_seq_client *client]\n- 调用者: snd_seq_write\n- 被调用者: []\n\n5. 函数名: snd_seq_pool_init\n- 参数: [client->pool]\n- 调用者: snd_seq_write\n- 被调用者: []\n\n6. 函数名: copy_from_user\n- 参数: [&event, buf, len]\n- 调用者: snd_seq_write\n- 被调用者: []\n\n7. 函数名: check_event_type_and_length\n- 参数: [&event]\n- 调用者: snd_seq_write\n- 被调用者: []\n\n8. 函数名: snd_seq_ev_is_reserved\n- 参数: [&event]\n- 调用者: snd_seq_write\n- 被调用者: []\n\n9. 函数名: snd_seq_ev_is_variable\n- 参数: [&event]\n- 调用者: snd_seq_write\n- 被调用者: []\n\n10. 函数名: snd_seq_ev_is_varusr\n- 参数: [&event]\n- 调用者: snd_seq_write\n- 被调用者: []\n\n11. 函数名: snd_seq_client_enqueue_event\n- 参数: [client, &event, file, !(file->f_flags & O_NONBLOCK), 0, 0]\n- 调用者: snd_seq_write\n- 被调用者: []"
    },
    {
        "id": 1848,
        "cwe": "CWE-119",
        "cve": "CVE-2018-7740",
        "purpose": "Code purpose:\"\"\"该代码实现了hugetlbfs文件的内存映射功能，处理大页面的映射请求并验证相关参数的有效性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理大页内存映射时，未充分验证remap_file_pages系统调用中的pgoff参数，导致本地用户可通过特制应用程序触发拒绝服务(BUG)。\"\"\"",
        "functions": "Functions:\n1. 函数名: hugetlbfs_file_mmap\n- 参数: [file, vma]\n- 调用者: 未显示（由内核mmap机制调用）\n- 被调用者: [file_inode, hstate_file, inode_lock, file_accessed, hugetlb_reserve_pages, i_size_write, inode_unlock]\n\n2. 函数名: file_inode\n- 参数: [file]\n- 调用者: hugetlbfs_file_mmap\n- 被调用者: []\n\n3. 函数名: hstate_file\n- 参数: [file]\n- 调用者: hugetlbfs_file_mmap\n- 被调用者: []\n\n4. 函数名: inode_lock\n- 参数: [inode]\n- 调用者: hugetlbfs_file_mmap\n- 被调用者: []\n\n5. 函数名: file_accessed\n- 参数: [file]\n- 调用者: hugetlbfs_file_mmap\n- 被调用者: []\n\n6. 函数名: hugetlb_reserve_pages\n- 参数: [inode, vma->vm_pgoff >> huge_page_order(h), len >> huge_page_shift(h), vma, vma->vm_flags]\n- 调用者: hugetlbfs_file_mmap\n- 被调用者: []\n\n7. 函数名: i_size_write\n- 参数: [inode, len]\n- 调用者: hugetlbfs_file_mmap\n- 被调用者: []\n\n8. 函数名: inode_unlock\n- 参数: [inode]\n- 调用者: hugetlbfs_file_mmap\n- 被调用者: []"
    },
    {
        "id": 1849,
        "cwe": "CWE-119",
        "cve": "CVE-2018-7740",
        "purpose": "Code purpose:\"\"\"该代码用于管理大页内存的预留和分配，处理共享和私有内存映射的预留页数计算和调整，确保有足够的大页内存满足映射需求。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理大页内存映射时，由于对remap_file_pages系统调用的pgoff参数缺乏充分验证，导致当传入过大的偏移值时可能触发内核BUG，造成拒绝服务。\"\"\"",
        "functions": "Functions:\n1. 函数名: hugetlb_reserve_pages\n- 参数: [inode, from, to, vma, vm_flags]\n- 调用者: N/A (系统调用或内核其他部分)\n- 被调用者: [hstate_inode, subpool_inode, region_chg, resv_map_alloc, set_vma_resv_map, set_vma_resv_flags, hugepage_subpool_get_pages, hugetlb_acct_memory, hugepage_subpool_put_pages, region_add, region_abort, is_vma_resv_set, kref_put, resv_map_release]\n\n2. 函数名: hstate_inode\n- 参数: [inode]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n3. 函数名: subpool_inode\n- 参数: [inode]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n4. 函数名: inode_resv_map\n- 参数: [inode]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n5. 函数名: region_chg\n- 参数: [resv_map, from, to]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n6. 函数名: resv_map_alloc\n- 参数: []\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n7. 函数名: set_vma_resv_map\n- 参数: [vma, resv_map]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n8. 函数名: set_vma_resv_flags\n- 参数: [vma, HPAGE_RESV_OWNER]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n9. 函数名: hugepage_subpool_get_pages\n- 参数: [spool, chg]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n10. 函数名: hugetlb_acct_memory\n- 参数: [h, gbl_reserve]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n11. 函数名: hugepage_subpool_put_pages\n- 参数: [spool, chg]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n12. 函数名: region_add\n- 参数: [resv_map, from, to]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n13. 函数名: region_abort\n- 参数: [resv_map, from, to]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n14. 函数名: is_vma_resv_set\n- 参数: [vma, HPAGE_RESV_OWNER]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: []\n\n15. 函数名: kref_put\n- 参数: [&resv_map->refs, resv_map_release]\n- 调用者: hugetlb_reserve_pages\n- 被调用者: [resv_map_release]\n\n16. 函数名: resv_map_release\n- 参数: []\n- 调用者: kref_put\n- 被调用者: []"
    },
    {
        "id": 1861,
        "cwe": "CWE-119",
        "cve": "CVE-2018-8822",
        "purpose": "Code purpose:\"\"\"该代码用于从NCP服务器读取指定文件的数据到内核缓冲区中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未正确验证服务器返回的bytes_read长度，导致memcpy操作可能引发缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: ncp_read_kernel\n- 参数: [struct ncp_server *server, const char *file_id, __u32 offset, __u16 to_read, char *target, int *bytes_read]\n- 调用者: 未指定\n- 被调用者: [ncp_init_request, ncp_add_byte, ncp_add_mem, ncp_add_be32, ncp_add_be16, ncp_request, ncp_reply_be16, ncp_reply_data, memcpy, ncp_unlock_server]\n\n2. 函数名: ncp_init_request\n- 参数: [struct ncp_server *server]\n- 调用者: ncp_read_kernel\n- 被调用者: 未指定\n\n3. 函数名: ncp_add_byte\n- 参数: [struct ncp_server *server, int value]\n- 调用者: ncp_read_kernel\n- 被调用者: 未指定\n\n4. 函数名: ncp_add_mem\n- 参数: [struct ncp_server *server, const char *data, int length]\n- 调用者: ncp_read_kernel\n- 被调用者: 未指定\n\n5. 函数名: ncp_add_be32\n- 参数: [struct ncp_server *server, __u32 value]\n- 调用者: ncp_read_kernel\n- 被调用者: 未指定\n\n6. 函数名: ncp_add_be16\n- 参数: [struct ncp_server *server, __u16 value]\n- 调用者: ncp_read_kernel\n- 被调用者: 未指定\n\n7. 函数名: ncp_request\n- 参数: [struct ncp_server *server, int function]\n- 调用者: ncp_read_kernel\n- 被调用者: 未指定\n\n8. 函数名: ncp_reply_be16\n- 参数: [struct ncp_server *server, int offset]\n- 调用者: ncp_read_kernel\n- 被调用者: 未指定\n\n9. 函数名: ncp_reply_data\n- 参数: [struct ncp_server *server, int offset]\n- 调用者: ncp_read_kernel\n- 被调用者: 未指定\n\n10. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: ncp_read_kernel\n- 被调用者: 未指定\n\n11. 函数名: ncp_unlock_server\n- 参数: [struct ncp_server *server]\n- 调用者: ncp_read_kernel\n- 被调用者: 未指定"
    },
    {
        "id": 1991,
        "cwe": "CWE-119",
        "cve": "CVE-2019-15117",
        "purpose": "Code purpose:\"\"\"该代码用于解析USB音频设备中的混音器单元描述符，获取混音器的通道数，并检查描述符的有效性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理音频混合单元描述符时，未充分验证描述符长度，导致可能访问超出边界的内存\"\"\"",
        "functions": "Functions:\n1. 函数名: uac_mixer_unit_get_channels\n- 参数: [state, desc]\n- 调用者: 未显示\n- 被调用者: [uac_mixer_unit_bNrChannels, get_cluster_channels_v3, uac3_mixer_unit_wClusterDescrID, uac_mixer_unit_bmControls]\n\n2. 函数名: uac_mixer_unit_bNrChannels\n- 参数: [desc]\n- 调用者: uac_mixer_unit_get_channels\n- 被调用者: []\n\n3. 函数名: get_cluster_channels_v3\n- 参数: [state, uac3_mixer_unit_wClusterDescrID(desc)]\n- 调用者: uac_mixer_unit_get_channels\n- 被调用者: []\n\n4. 函数名: uac3_mixer_unit_wClusterDescrID\n- 参数: [desc]\n- 调用者: uac_mixer_unit_get_channels\n- 被调用者: []\n\n5. 函数名: uac_mixer_unit_bmControls\n- 参数: [desc, state->mixer->protocol]\n- 调用者: uac_mixer_unit_get_channels\n- 被调用者: []"
    },
    {
        "id": 2222,
        "cwe": "CWE-119",
        "cve": "CVE-2019-19602",
        "purpose": "Code purpose:\"\"\"验证FPU寄存器状态是否有效，通过检查当前FPU上下文所有者是否为指定CPU且CPU编号匹配\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于GCC 9编译器下fpu_fpregs_owner_ctx缓存处理不当，导致在多核环境下信号抢占时可能引发内存损坏或未定义行为\"\"\"",
        "functions": "Functions:\n1. 函数名: fpregs_state_valid\n- 参数: [struct fpu *fpu, unsigned int cpu]\n- 调用者: 未明确（上下文缺失）\n- 被调用者: [this_cpu_read_stable]\n\n2. 函数名: this_cpu_read_stable\n- 参数: [fpu_fpregs_owner_ctx]\n- 调用者: fpregs_state_valid\n- 被调用者: 未明确（上下文缺失）"
    },
    {
        "id": 2414,
        "cwe": "CWE-119",
        "cve": "CVE-2020-10757",
        "purpose": "Code purpose:\"\"\"该代码用于在内存管理中移动页表，包括处理大页(PMD)的移动和拆分，以及普通页表的移动操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理DAX大页的mremap操作时，未能正确验证和限制内存页面的移动，导致权限提升漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: move_page_tables\n- 参数: [vma, old_addr, new_vma, new_addr, len, need_rmap_locks]\n- 调用者: 未显示\n- 被调用者: [flush_cache_range, mmu_notifier_range_init, mmu_notifier_invalidate_range_start, cond_resched, get_old_pmd, alloc_new_pmd, is_swap_pmd, pmd_trans_huge, take_rmap_locks, move_huge_pmd, drop_rmap_locks, split_huge_pmd, pmd_trans_unstable, move_normal_pmd, pte_alloc, move_ptes, mmu_notifier_invalidate_range_end]\n\n2. 函数名: flush_cache_range\n- 参数: [vma, old_addr, old_end]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n3. 函数名: mmu_notifier_range_init\n- 参数: [&range, MMU_NOTIFY_UNMAP, 0, vma, vma->vm_mm, old_addr, old_end]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n4. 函数名: mmu_notifier_invalidate_range_start\n- 参数: [&range]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n5. 函数名: cond_resched\n- 参数: []\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n6. 函数名: get_old_pmd\n- 参数: [vma->vm_mm, old_addr]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n7. 函数名: alloc_new_pmd\n- 参数: [vma->vm_mm, vma, new_addr]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n8. 函数名: is_swap_pmd\n- 参数: [*old_pmd]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n9. 函数名: pmd_trans_huge\n- 参数: [*old_pmd]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n10. 函数名: take_rmap_locks\n- 参数: [vma]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n11. 函数名: move_huge_pmd\n- 参数: [vma, old_addr, new_addr, old_end, old_pmd, new_pmd]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n12. 函数名: drop_rmap_locks\n- 参数: [vma]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n13. 函数名: split_huge_pmd\n- 参数: [vma, old_pmd, old_addr]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n14. 函数名: pmd_trans_unstable\n- 参数: [old_pmd]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n15. 函数名: move_normal_pmd\n- 参数: [vma, old_addr, new_addr, old_end, old_pmd, new_pmd]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n16. 函数名: pte_alloc\n- 参数: [new_vma->vm_mm, new_pmd]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n17. 函数名: move_ptes\n- 参数: [vma, old_pmd, old_addr, old_addr + extent, new_vma, new_pmd, new_addr, need_rmap_locks]\n- 调用者: move_page_tables\n- 被调用者: 未显示\n\n18. 函数名: mmu_notifier_invalidate_range_end\n- 参数: [&range]\n- 调用者: move_page_tables\n- 被调用者: 未显示"
    },
    {
        "id": 2880,
        "cwe": "CWE-119",
        "cve": "CVE-2021-22543",
        "purpose": "Code purpose:\"\"\"该代码用于将虚拟机的宿主虚拟地址(HVA)转换为物理页帧号(PFN)，同时处理可能的内存页错误和权限检查\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"KVM在处理VM_IO|VM_PFNMAP类型的虚拟内存区域时，未能正确实施只读权限检查，导致页面在被释放后仍可被VMM和客户机访问，从而引发内存安全问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: hva_to_pfn_remapped\n- 参数: [vma, addr, async, write_fault, writable, p_pfn]\n- 调用者: 未明确显示（通常是KVM相关调用）\n- 被调用者: [follow_pte, fixup_user_fault, pte_write, pte_pfn, kvm_get_pfn, pte_unmap_unlock]\n\n2. 函数名: follow_pte\n- 参数: [vma->vm_mm, addr, &ptep, &ptl]\n- 调用者: hva_to_pfn_remapped\n- 被调用者: 未显示（可能是底层页表操作函数）\n\n3. 函数名: fixup_user_fault\n- 参数: [current->mm, addr, (write_fault ? FAULT_FLAG_WRITE : 0), &unlocked]\n- 调用者: hva_to_pfn_remapped\n- 被调用者: 未显示（可能是内存管理相关函数）\n\n4. 函数名: pte_write\n- 参数: [*ptep]\n- 调用者: hva_to_pfn_remapped\n- 被调用者: 未显示（页表项检查函数）\n\n5. 函数名: pte_pfn\n- 参数: [*ptep]\n- 调用者: hva_to_pfn_remapped\n- 被调用者: 未显示（页表项转换函数）\n\n6. 函数名: kvm_get_pfn\n- 参数: [pfn]\n- 调用者: hva_to_pfn_remapped\n- 被调用者: 未显示（KVM PFN管理函数）\n\n7. 函数名: pte_unmap_unlock\n- 参数: [ptep, ptl]\n- 调用者: hva_to_pfn_remapped\n- 被调用者: 未显示（页表解锁/取消映射函数）"
    },
    {
        "id": 3025,
        "cwe": "CWE-119",
        "cve": "CVE-2021-3635",
        "purpose": "Code purpose:\"\"\"该代码用于清空netfilter表中的规则、集合、流表和对象，并最终删除整个表\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在nft_flush_table函数中，当处理flowtable时未检查nft_is_active_next状态就直接删除，可能导致空指针引用或无效操作引发系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_flush_table\n- 参数: [ctx]\n- 调用者: 无（顶级函数）\n- 被调用者: [nft_is_active_next, nft_delrule_by_chain, nft_delset, nft_delflowtable, nft_delobj, nft_delchain, nft_deltable]\n\n2. 函数名: nft_is_active_next\n- 参数: [ctx->net, chain/set]\n- 调用者: nft_flush_table\n- 被调用者: 无\n\n3. 函数名: nft_delrule_by_chain\n- 参数: [ctx]\n- 调用者: nft_flush_table\n- 被调用者: 无\n\n4. 函数名: nft_delset\n- 参数: [ctx, set]\n- 调用者: nft_flush_table\n- 被调用者: 无\n\n5. 函数名: nft_delflowtable\n- 参数: [ctx, flowtable]\n- 调用者: nft_flush_table\n- 被调用者: 无\n\n6. 函数名: nft_delobj\n- 参数: [ctx, obj]\n- 调用者: nft_flush_table\n- 被调用者: 无\n\n7. 函数名: nft_delchain\n- 参数: [ctx]\n- 调用者: nft_flush_table\n- 被调用者: 无\n\n8. 函数名: nft_deltable\n- 参数: [ctx]\n- 调用者: nft_flush_table\n- 被调用者: 无"
    },
    {
        "id": 3075,
        "cwe": "CWE-119",
        "cve": "CVE-2021-38201",
        "purpose": "Code purpose:\"\"\"该代码用于设置XDR流中基于页面的数据传输的起始位置和长度，并处理相关的边界检查\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证输入参数base和len的边界，导致在计算pgoff和pgend时可能超出页面边界，造成slab-out-of-bounds访问\"\"\"",
        "functions": "Functions:\n1. 函数名: xdr_set_page_base\n- 参数: [xdr, base, len]\n- 调用者: 未明确显示（由外部调用）\n- 被调用者: [xdr_stream_page_set_pos, page_address]\n\n2. 函数名: xdr_stream_page_set_pos\n- 参数: 未明确显示（应为xdr和base）\n- 调用者: xdr_set_page_base\n- 被调用者: []\n\n3. 函数名: page_address\n- 参数: 未明确显示（应为page指针）\n- 调用者: xdr_set_page_base\n- 被调用者: []"
    },
    {
        "id": 3091,
        "cwe": "CWE-119",
        "cve": "CVE-2021-39633",
        "purpose": "Code purpose:\"\"\"处理GRE协议的数据包卸载功能，根据校验和标志选择不同的分段卸载类型\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理GRE协议卸载操作时，由于对sk_buff内存访问不当，导致可能发生无效内存访问的页面错误\"\"\"",
        "functions": "Functions:\n1. 函数名: gre_handle_offloads\n- 参数: [struct sk_buff *skb, bool csum]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [iptunnel_handle_offloads]\n\n2. 函数名: iptunnel_handle_offloads\n- 参数: [struct sk_buff *skb, int gso_type]\n- 调用者: [gre_handle_offloads]\n- 被调用者: 未明确（可能调用内核网络处理相关函数）"
    },
    {
        "id": 3139,
        "cwe": "CWE-119",
        "cve": "CVE-2021-4157",
        "purpose": "Code purpose:\"\"\"解码NFS文件句柄并验证其大小是否合法，然后将数据复制到目标缓冲区\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在decode_nfs_fh函数中，未对fh->size进行足够严格的边界检查，导致可能发生1或2字节的内存越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: decode_nfs_fh\n- 参数: [struct xdr_stream *xdr, struct nfs_fh *fh]\n- 调用者: 未明确（由NFS子系统调用）\n- 被调用者: [xdr_inline_decode, be32_to_cpup, printk, memcpy, dprintk]\n\n2. 函数名: xdr_inline_decode\n- 参数: [struct xdr_stream *xdr, int size]\n- 调用者: decode_nfs_fh\n- 被调用者: 未明确（底层XDR解码函数）\n\n3. 函数名: be32_to_cpup\n- 参数: [__be32 *p]\n- 调用者: decode_nfs_fh\n- 被调用者: 未明确（字节序转换函数）\n\n4. 函数名: printk\n- 参数: [KERN_ERR, \"NFS flexfiles: Too big fh received %d\\n\", fh->size]\n- 调用者: decode_nfs_fh\n- 被调用者: 未明确（内核打印函数）\n\n5. 函数名: memcpy\n- 参数: [&fh->data, p, fh->size]\n- 调用者: decode_nfs_fh\n- 被调用者: 未明确（内存拷贝函数）\n\n6. 函数名: dprintk\n- 参数: [\"%s: fh len %d\\n\", __func__, fh->size]\n- 调用者: decode_nfs_fh\n- 被调用者: 未明确（调试打印函数）"
    },
    {
        "id": 3151,
        "cwe": "CWE-119",
        "cve": "CVE-2021-4204",
        "purpose": "Code purpose:\"\"\"该代码用于验证BPF函数参数类型与调用时实际传递的参数类型是否匹配，确保内核安全执行BPF程序\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于对函数参数数量和类型的输入验证不充分，导致在处理BPF函数参数时可能发生越界内存访问\"\"\"",
        "functions": "Functions:\n1. 函数名: btf_check_func_arg_match\n- 参数: [struct bpf_verifier_env *env, const struct btf *btf, u32 func_id, struct bpf_reg_state *regs, bool ptr_to_mem_ok]\n- 调用者: 未明确（由BPF验证器调用）\n- 被调用者: [btf_is_kernel, btf_type_by_id, btf_type_is_func, btf_name_by_offset, btf_type_is_func_proto, btf_type_skip_modifiers, btf_type_is_scalar, btf_type_is_ptr, btf_get_prog_ctx_type, check_ctx_reg, btf_type_is_struct, btf_struct_ids_match, __btf_type_is_scalar_struct, btf_resolve_size, check_mem_reg]\n\n2. 函数名: btf_is_kernel\n- 参数: [const struct btf *btf]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n3. 函数名: btf_type_by_id\n- 参数: [const struct btf *btf, u32 id]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n4. 函数名: btf_type_is_func\n- 参数: [const struct btf_type *t]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n5. 函数名: btf_name_by_offset\n- 参数: [const struct btf *btf, u32 offset]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n6. 函数名: btf_type_is_func_proto\n- 参数: [const struct btf_type *t]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n7. 函数名: btf_type_skip_modifiers\n- 参数: [const struct btf *btf, u32 id, u32 *res_id]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n8. 函数名: btf_type_is_scalar\n- 参数: [const struct btf_type *t]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n9. 函数名: btf_type_is_ptr\n- 参数: [const struct btf_type *t]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n10. 函数名: btf_get_prog_ctx_type\n- 参数: [struct bpf_verifier_log *log, const struct btf *btf, const struct btf_type *t, enum bpf_prog_type prog_type, int arg]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n11. 函数名: check_ctx_reg\n- 参数: [struct bpf_verifier_env *env, const struct bpf_reg_state *reg, int regno]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n12. 函数名: btf_type_is_struct\n- 参数: [const struct btf_type *t]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n13. 函数名: btf_struct_ids_match\n- 参数: [struct bpf_verifier_log *log, const struct btf *btf1, u32 id1, int off1, const struct btf *btf2, u32 id2]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n14. 函数名: __btf_type_is_scalar_struct\n- 参数: [struct bpf_verifier_log *log, const struct btf *btf, const struct btf_type *t, int depth]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n15. 函数名: btf_resolve_size\n- 参数: [const struct btf *btf, const struct btf_type *type, u32 *type_size]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []\n\n16. 函数名: check_mem_reg\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *reg, int regno, u32 mem_size]\n- 调用者: btf_check_func_arg_match\n- 被调用者: []"
    },
    {
        "id": 3152,
        "cwe": "CWE-119",
        "cve": "CVE-2021-4204",
        "purpose": "Code purpose:\"\"\"该代码用于验证eBPF程序中的函数调用参数，确保参数类型、内存访问权限和边界检查符合安全要求，防止越界访问和非法操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于对eBPF验证器中helper函数参数的内存访问边界检查不充分，导致存在越界内存访问漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: check_func_arg\n- 参数: [struct bpf_verifier_env *env, u32 arg, struct bpf_call_arg_meta *meta, const struct bpf_func_proto *fn]\n- 调用者: N/A (顶层函数)\n- 被调用者: [check_reg_arg, is_pointer_value, may_access_direct_pkt_data, resolve_map_arg_type, register_is_null, check_reg_type, check_ctx_reg, check_helper_mem_access, process_spin_lock, process_timer_func, check_ptr_alignment, check_map_access, map->ops->map_direct_value_addr, strnchr]\n\n2. 函数名: check_reg_arg\n- 参数: [struct bpf_verifier_env *env, u32 regno, int op]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n3. 函数名: is_pointer_value\n- 参数: [struct bpf_verifier_env *env, u32 regno]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n4. 函数名: may_access_direct_pkt_data\n- 参数: [struct bpf_verifier_env *env, struct bpf_call_arg_meta *meta, enum bpf_access_type type]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n5. 函数名: resolve_map_arg_type\n- 参数: [struct bpf_verifier_env *env, struct bpf_call_arg_meta *meta, enum bpf_arg_type *arg_type]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n6. 函数名: register_is_null\n- 参数: [struct bpf_reg_state *reg]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n7. 函数名: check_reg_type\n- 参数: [struct bpf_verifier_env *env, u32 regno, enum bpf_arg_type arg_type, u32 btf_id]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n8. 函数名: check_ctx_reg\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *reg, u32 regno]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n9. 函数名: check_helper_mem_access\n- 参数: [struct bpf_verifier_env *env, u32 regno, u32 access_size, bool zero_size_allowed, struct bpf_call_arg_meta *meta]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n10. 函数名: process_spin_lock\n- 参数: [struct bpf_verifier_env *env, u32 regno, bool is_lock]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n11. 函数名: process_timer_func\n- 参数: [struct bpf_verifier_env *env, u32 regno, struct bpf_call_arg_meta *meta]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n12. 函数名: check_ptr_alignment\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *reg, int off, int size, bool strict]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n13. 函数名: check_map_access\n- 参数: [struct bpf_verifier_env *env, u32 regno, int off, int size, bool zero_size_allowed]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n14. 函数名: map->ops->map_direct_value_addr\n- 参数: [struct bpf_map *map, u64 *addr, int offset]\n- 调用者: check_func_arg\n- 被调用者: N/A\n\n15. 函数名: strnchr\n- 参数: [const char *s, size_t count, int c]\n- 调用者: check_func_arg\n- 被调用者: N/A"
    },
    {
        "id": 3153,
        "cwe": "CWE-119",
        "cve": "CVE-2021-4204",
        "purpose": "Code purpose:\"\"\"该代码用于检查eBPF程序中对内存的各种访问操作是否合法，包括对齐检查、边界检查和权限验证，以防止越界访问或非法操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于对内存访问的边界检查不充分，导致在处理eBPF程序时可以触发越界内存访问漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: check_mem_access\n- 参数: [struct bpf_verifier_env *env, int insn_idx, u32 regno, int off, int bpf_size, enum bpf_access_type t, int value_regno, bool strict_alignment_once]\n- 调用者: N/A\n- 被调用者: [bpf_size_to_bytes, check_ptr_alignment, check_mem_region_access, mark_reg_unknown, check_map_access_type, check_map_access, bpf_map_is_rdonly, bpf_map_direct_read, __mark_reg_known, check_ctx_reg, check_ctx_access, check_stack_access_within_bounds, update_stack_depth, check_stack_read, check_stack_write, check_packet_access, check_flow_keys_access, check_sock_access, check_tp_buffer_access, check_ptr_to_btf_access, check_ptr_to_map_access, check_buffer_access, coerce_reg_to_size]\n\n2. 函数名: bpf_size_to_bytes\n- 参数: [int bpf_size]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n3. 函数名: check_ptr_alignment\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *reg, int off, int size, bool strict_alignment_once]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n4. 函数名: check_mem_region_access\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int size, int reg_size, bool zero_size_allowed]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n5. 函数名: mark_reg_unknown\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *regs, int regno]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n6. 函数名: check_map_access_type\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int size, enum bpf_access_type t]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n7. 函数名: check_map_access\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int size, bool zero_size_allowed]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n8. 函数名: bpf_map_is_rdonly\n- 参数: [struct bpf_map *map]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n9. 函数名: bpf_map_direct_read\n- 参数: [struct bpf_map *map, int map_off, int size, u64 *val]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n10. 函数名: __mark_reg_known\n- 参数: [struct bpf_reg_state *reg, u64 val]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n11. 函数名: check_ctx_reg\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *reg, int regno]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n12. 函数名: check_ctx_access\n- 参数: [struct bpf_verifier_env *env, int insn_idx, int off, int size, enum bpf_access_type t, enum bpf_reg_type *reg_type, struct btf **btf, u32 *btf_id]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n13. 函数名: check_stack_access_within_bounds\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int size, enum bpf_access_type type, enum bpf_access_type t]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n14. 函数名: update_stack_depth\n- 参数: [struct bpf_verifier_env *env, struct bpf_func_state *state, int off]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n15. 函数名: check_stack_read\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int size, int value_regno]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n16. 函数名: check_stack_write\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int size, int value_regno, int insn_idx]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n17. 函数名: check_packet_access\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int size, bool zero_size_allowed]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n18. 函数名: check_flow_keys_access\n- 参数: [struct bpf_verifier_env *env, int off, int size]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n19. 函数名: check_sock_access\n- 参数: [struct bpf_verifier_env *env, int insn_idx, int regno, int off, int size, enum bpf_access_type t]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n20. 函数名: check_tp_buffer_access\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *reg, int regno, int off, int size]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n21. 函数名: check_ptr_to_btf_access\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *regs, int regno, int off, int size, enum bpf_access_type t, int value_regno]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n22. 函数名: check_ptr_to_map_access\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *regs, int regno, int off, int size, enum bpf_access_type t, int value_regno]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n23. 函数名: check_buffer_access\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *reg, int regno, int off, int size, bool zero_size_allowed, const char *buf_info, u32 *max_access]\n- 调用者: check_mem_access\n- 被调用者: N/A\n\n24. 函数名: coerce_reg_to_size\n- 参数: [struct bpf_reg_state *reg, int size]\n- 调用者: check_mem_access\n- 被调用者: N/A"
    },
    {
        "id": 3154,
        "cwe": "CWE-119",
        "cve": "CVE-2021-4204",
        "purpose": "Code purpose:\"\"\"该代码用于验证eBPF程序中的LD_ABS/LD_IND指令的合法性，确保对网络数据包的安全访问，防止越界内存访问和引用泄漏等安全问题。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于对BPF_LD_[ABS|IND]指令的输入验证不充分，导致在处理eBPF程序时可能发生越界内存访问\"\"\"",
        "functions": "Functions:\n1. 函数名: check_ld_abs\n- 参数: [env, insn]\n- 调用者: 未明确（由BPF验证器调用）\n- 被调用者: [may_access_skb, resolve_prog_type, verbose, cur_regs, check_reg_arg, check_reference_leak, check_ctx_reg, mark_reg_not_init, mark_reg_unknown]\n\n2. 函数名: may_access_skb\n- 参数: [未明确]\n- 调用者: check_ld_abs\n- 被调用者: []\n\n3. 函数名: resolve_prog_type\n- 参数: [未明确]\n- 调用者: check_ld_abs\n- 被调用者: []\n\n4. 函数名: verbose\n- 参数: [env, message]\n- 调用者: check_ld_abs\n- 被调用者: []\n\n5. 函数名: cur_regs\n- 参数: [env]\n- 调用者: check_ld_abs\n- 被调用者: []\n\n6. 函数名: check_reg_arg\n- 参数: [env, reg, op]\n- 调用者: check_ld_abs\n- 被调用者: []\n\n7. 函数名: check_reference_leak\n- 参数: [env]\n- 调用者: check_ld_abs\n- 被调用者: []\n\n8. 函数名: check_ctx_reg\n- 参数: [env, reg, regno]\n- 调用者: check_ld_abs\n- 被调用者: []\n\n9. 函数名: mark_reg_not_init\n- 参数: [env, regs, reg]\n- 调用者: check_ld_abs\n- 被调用者: []\n\n10. 函数名: mark_reg_unknown\n- 参数: [env, regs, reg]\n- 调用者: check_ld_abs\n- 被调用者: []"
    },
    {
        "id": 3525,
        "cwe": "CWE-119",
        "cve": "CVE-2022-2964",
        "purpose": "Code purpose:\"\"\"处理ASIX AX88179_178A USB以太网设备接收到的网络数据包，包括解析包头、校验CRC、分割数据包等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理网络数据包时未充分验证hdr_off和pkt_len等参数的边界，导致可能发生越界读写\"\"\"",
        "functions": "Functions:\n1. 函数名: ax88179_rx_fixup\n- 参数: [dev, skb]\n- 调用者: 未明确显示（应为USB网络驱动框架）\n- 被调用者: [skb_trim, get_unaligned_le32, skb_tail_pointer, le32_to_cpus, skb_pull, skb_set_tail_pointer, ax88179_rx_checksum, skb_clone, usbnet_skb_return]\n\n2. 函数名: skb_trim\n- 参数: [skb, len]\n- 调用者: ax88179_rx_fixup\n- 被调用者: []\n\n3. 函数名: get_unaligned_le32\n- 参数: [pointer]\n- 调用者: ax88179_rx_fixup\n- 被调用者: []\n\n4. 函数名: skb_tail_pointer\n- 参数: [skb]\n- 调用者: ax88179_rx_fixup\n- 被调用者: []\n\n5. 函数名: le32_to_cpus\n- 参数: [pkt_hdr]\n- 调用者: ax88179_rx_fixup\n- 被调用者: []\n\n6. 函数名: skb_pull\n- 参数: [skb, len]\n- 调用者: ax88179_rx_fixup\n- 被调用者: []\n\n7. 函数名: skb_set_tail_pointer\n- 参数: [skb, len]\n- 调用者: ax88179_rx_fixup\n- 被调用者: []\n\n8. 函数名: ax88179_rx_checksum\n- 参数: [skb, pkt_hdr]\n- 调用者: ax88179_rx_fixup\n- 被调用者: []\n\n9. 函数名: skb_clone\n- 参数: [skb, GFP_ATOMIC]\n- 调用者: ax88179_rx_fixup\n- 被调用者: []\n\n10. 函数名: usbnet_skb_return\n- 参数: [dev, ax_skb]\n- 调用者: ax88179_rx_fixup\n- 被调用者: []"
    },
    {
        "id": 3599,
        "cwe": "CWE-119",
        "cve": "CVE-2022-3435",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的IPv4处理模块中比较和匹配网络路由配置信息与现有路由信息的差异，以确定是否需要更新路由表。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理多路径路由配置时，由于未充分验证rtnh_attrs返回的指针和attrlen长度，导致可能发生越界读取\"\"\"",
        "functions": "Functions:\n1. 函数名: fib_nh_match\n- 参数: [net, cfg, fi, extack]\n- 调用者: 未显示\n- 被调用者: [fib_info_nh, fib_encap_match, rtnh_ok, rtnh_attrlen, rtnh_attrs, nla_find, fib_gw_from_attr, fib_gw_from_via, nla_len, nla_get_u32, rtnh_next]\n\n2. 函数名: fib_info_nh\n- 参数: 未显示\n- 调用者: fib_nh_match\n- 被调用者: 未显示\n\n3. 函数名: fib_encap_match\n- 参数: [net, cfg->fc_encap_type, cfg->fc_encap, nh, cfg, extack]\n- 调用者: fib_nh_match\n- 被调用者: 未显示\n\n4. 函数名: rtnh_ok\n- 参数: [rtnh, remaining]\n- 调用者: fib_nh_match\n- 被调用者: 未显示\n\n5. 函数名: rtnh_attrlen\n- 参数: [rtnh]\n- 调用者: fib_nh_match\n- 被调用者: 未显示\n\n6. 函数名: rtnh_attrs\n- 参数: [rtnh]\n- 调用者: fib_nh_match\n- 被调用者: 未显示\n\n7. 函数名: nla_find\n- 参数: [attrs, attrlen, RTA_GATEWAY/RTA_VIA/RTA_FLOW]\n- 调用者: fib_nh_match\n- 被调用者: 未显示\n\n8. 函数名: fib_gw_from_attr\n- 参数: [&gw, nla, extack]\n- 调用者: fib_nh_match\n- 被调用者: 未显示\n\n9. 函数名: fib_gw_from_via\n- 参数: [&cfg2, nlav, extack]\n- 调用者: fib_nh_match\n- 被调用者: 未显示\n\n10. 函数名: nla_len\n- 参数: [nla]\n- 调用者: fib_nh_match\n- 被调用者: 未显示\n\n11. 函数名: nla_get_u32\n- 参数: [nla]\n- 调用者: fib_nh_match\n- 被调用者: 未显示\n\n12. 函数名: rtnh_next\n- 参数: [rtnh, &remaining]\n- 调用者: fib_nh_match\n- 被调用者: 未显示"
    },
    {
        "id": 3631,
        "cwe": "CWE-119",
        "cve": "CVE-2022-3541",
        "purpose": "Code purpose:\"\"\"从设备树节点中读取MAC地址并验证其有效性后复制到指定缓冲区\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在检查MAC地址有效性后释放了内存，但在打印无效MAC地址信息时又引用了已释放的内存，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: spl2sw_nvmem_get_mac_address\n- 参数: [dev, np, addrbuf]\n- 调用者: 未指定\n- 被调用者: [of_nvmem_cell_get, nvmem_cell_read, nvmem_cell_put, IS_ERR, kfree, spl2sw_check_mac_vendor_id_and_convert, is_valid_ether_addr, ether_addr_copy]\n\n2. 函数名: of_nvmem_cell_get\n- 参数: [np, \"mac-address\"]\n- 调用者: spl2sw_nvmem_get_mac_address\n- 被调用者: 未指定\n\n3. 函数名: nvmem_cell_read\n- 参数: [cell, &len]\n- 调用者: spl2sw_nvmem_get_mac_address\n- 被调用者: 未指定\n\n4. 函数名: nvmem_cell_put\n- 参数: [cell]\n- 调用者: spl2sw_nvmem_get_mac_address\n- 被调用者: 未指定\n\n5. 函数名: IS_ERR\n- 参数: [cell], [mac]\n- 调用者: spl2sw_nvmem_get_mac_address\n- 被调用者: 未指定\n\n6. 函数名: kfree\n- 参数: [mac]\n- 调用者: spl2sw_nvmem_get_mac_address\n- 被调用者: 未指定\n\n7. 函数名: spl2sw_check_mac_vendor_id_and_convert\n- 参数: [mac]\n- 调用者: spl2sw_nvmem_get_mac_address\n- 被调用者: 未指定\n\n8. 函数名: is_valid_ether_addr\n- 参数: [mac]\n- 调用者: spl2sw_nvmem_get_mac_address\n- 被调用者: 未指定\n\n9. 函数名: ether_addr_copy\n- 参数: [addrbuf, mac]\n- 调用者: spl2sw_nvmem_get_mac_address\n- 被调用者: 未指定"
    },
    {
        "id": 3635,
        "cwe": "CWE-119",
        "cve": "CVE-2022-3545",
        "purpose": "Code purpose:\"\"\"该代码用于管理NFP(Netronome Flow Processor)的CPP(Common Physical Port)区域缓存，处理内存区域的获取、匹配和初始化操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放缓存区域后未正确更新相关指针或引用，导致后续操作可能访问已释放的内存区域，造成use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: area_cache_get\n- 参数: [struct nfp_cpp *cpp, u32 id, u64 addr, unsigned long *offset, size_t length]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [nfp_target_cpp, mutex_lock, mutex_unlock, list_empty, list_for_each_entry, list_entry, round_down, nfp_cpp_area_release, nfp_cpp_area_acquire]\n\n2. 函数名: nfp_target_cpp\n- 参数: [u32 id, u64 addr, u32 *id_out, u64 *addr_out, void *imb_cat_table]\n- 调用者: area_cache_get\n- 被调用者: 未明确\n\n3. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: area_cache_get\n- 被调用者: 未明确\n\n4. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: area_cache_get\n- 被调用者: 未明确\n\n5. 函数名: list_empty\n- 参数: [struct list_head *head]\n- 调用者: area_cache_get\n- 被调用者: 未明确\n\n6. 函数名: list_for_each_entry\n- 参数: [struct nfp_cpp_area_cache *cache, struct list_head *head, struct list_head *entry]\n- 调用者: area_cache_get\n- 被调用者: 未明确\n\n7. 函数名: list_entry\n- 参数: [struct list_head *ptr, struct nfp_cpp_area_cache, struct list_head *entry]\n- 调用者: area_cache_get\n- 被调用者: 未明确\n\n8. 函数名: round_down\n- 参数: [u64 addr, size_t size]\n- 调用者: area_cache_get\n- 被调用者: 未明确\n\n9. 函数名: nfp_cpp_area_release\n- 参数: [struct nfp_cpp_area *area]\n- 调用者: area_cache_get\n- 被调用者: 未明确\n\n10. 函数名: nfp_cpp_area_acquire\n- 参数: [struct nfp_cpp_area *area]\n- 调用者: area_cache_get\n- 被调用者: 未明确"
    },
    {
        "id": 3660,
        "cwe": "CWE-119",
        "cve": "CVE-2022-3625",
        "purpose": "Code purpose:\"\"\"该代码片段实现了从devlink中获取参数值的功能，通过调用参数的回调函数get来完成参数查询操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在devlink_param_get函数中未对param指针进行有效性验证，可能导致在param已被释放后仍被访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: devlink_param_get\n- 参数: [struct devlink *devlink, const struct devlink_param *param, struct devlink_param_gset_ctx *ctx]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [param->get]\n\n2. 函数名: param->get\n- 参数: [struct devlink *devlink, param->id, struct devlink_param_gset_ctx *ctx]\n- 调用者: devlink_param_get\n- 被调用者: 未明确（由函数指针调用）"
    },
    {
        "id": 3661,
        "cwe": "CWE-119",
        "cve": "CVE-2022-3625",
        "purpose": "Code purpose:\"\"\"该代码片段实现了devlink参数的设置功能，通过调用参数提供的set回调函数来完成参数值的设置操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在devlink_param_set函数中未对参数进行充分验证，导致在调用param->set时可能发生释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: devlink_param_set\n- 参数: [devlink, param, ctx]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [param->set]"
    },
    {
        "id": 3669,
        "cwe": "CWE-119",
        "cve": "CVE-2022-3636",
        "purpose": "Code purpose:\"\"\"检查网络数据包并根据哈希值在流表中查找或更新对应的流条目\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放锁之前未正确验证entry指针的有效性，导致可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: __mtk_ppe_check_skb\n- 参数: [struct mtk_ppe *ppe, struct sk_buff *skb, u16 hash]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [FIELD_GET, eth_hdr, ether_addr_copy, get_unaligned_be16, rhashtable_lookup_fast, __mtk_foe_entry_clear, __mtk_foe_entry_commit, mtk_flow_entry_match, mtk_foe_entry_commit_subflow]\n\n2. 函数名: FIELD_GET\n- 参数: [未明确]\n- 调用者: __mtk_ppe_check_skb\n- 被调用者: []\n\n3. 函数名: eth_hdr\n- 参数: [struct sk_buff *skb]\n- 调用者: __mtk_ppe_check_skb\n- 被调用者: []\n\n4. 函数名: ether_addr_copy\n- 参数: [未明确]\n- 调用者: __mtk_ppe_check_skb\n- 被调用者: []\n\n5. 函数名: get_unaligned_be16\n- 参数: [未明确]\n- 调用者: __mtk_ppe_check_skb\n- 被调用者: []\n\n6. 函数名: rhashtable_lookup_fast\n- 参数: [未明确]\n- 调用者: __mtk_ppe_check_skb\n- 被调用者: []\n\n7. 函数名: __mtk_foe_entry_clear\n- 参数: [struct mtk_ppe *ppe, struct mtk_flow_entry *entry]\n- 调用者: __mtk_ppe_check_skb\n- 被调用者: []\n\n8. 函数名: __mtk_foe_entry_commit\n- 参数: [struct mtk_ppe *ppe, struct mtk_foe_entry *data, u16 hash]\n- 调用者: __mtk_ppe_check_skb\n- 被调用者: []\n\n9. 函数名: mtk_flow_entry_match\n- 参数: [struct mtk_flow_entry *entry, struct mtk_foe_entry *hwe]\n- 调用者: __mtk_ppe_check_skb\n- 被调用者: []\n\n10. 函数名: mtk_foe_entry_commit_subflow\n- 参数: [struct mtk_ppe *ppe, struct mtk_flow_entry *entry, u16 hash]\n- 调用者: __mtk_ppe_check_skb\n- 被调用者: []"
    },
    {
        "id": 3670,
        "cwe": "CWE-119",
        "cve": "CVE-2022-3640",
        "purpose": "Code purpose:\"\"\"处理蓝牙L2CAP协议中的数据通道通信，包括通道管理、数据接收和错误处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在蓝牙L2CAP协议处理过程中，当连接被删除时未能正确处理通道引用计数，导致释放后仍可能被使用的use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_data_channel\n- 参数: [conn, cid, skb]\n- 调用者: 未显示\n- 被调用者: [l2cap_get_chan_by_scid, a2mp_channel_create, kfree_skb, l2cap_chan_lock, BT_DBG, l2cap_chan_ready, l2cap_ecred_data_rcv, l2cap_data_rcv, BT_ERR, chan->ops->recv, l2cap_chan_unlock, l2cap_chan_put]\n\n2. 函数名: l2cap_get_chan_by_scid\n- 参数: [conn, cid]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示\n\n3. 函数名: a2mp_channel_create\n- 参数: [conn, skb]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示\n\n4. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示\n\n5. 函数名: l2cap_chan_lock\n- 参数: [chan]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示\n\n6. 函数名: BT_DBG\n- 参数: [format string, ...]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示\n\n7. 函数名: l2cap_chan_ready\n- 参数: [chan]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示\n\n8. 函数名: l2cap_ecred_data_rcv\n- 参数: [chan, skb]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示\n\n9. 函数名: l2cap_data_rcv\n- 参数: [chan, skb]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示\n\n10. 函数名: BT_ERR\n- 参数: [format string]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示\n\n11. 函数名: chan->ops->recv\n- 参数: [chan, skb]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示\n\n12. 函数名: l2cap_chan_unlock\n- 参数: [chan]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示\n\n13. 函数名: l2cap_chan_put\n- 参数: [chan]\n- 调用者: l2cap_data_channel\n- 被调用者: 未显示"
    },
    {
        "id": 3676,
        "cwe": "CWE-119",
        "cve": "CVE-2022-3649",
        "purpose": "Code purpose:\"\"\"该代码用于在NILFS2文件系统中创建新的inode节点并初始化相关属性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在nilfs_new_inode函数中，当初始化ACL失败时，错误处理路径可能导致已分配的inode资源被释放后仍被使用，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: nilfs_new_inode\n- 参数: [dir, mode]\n- 调用者: 未指定\n- 被调用者: [new_inode, mapping_set_gfp_mask, mapping_gfp_constraint, nilfs_ifile_create_inode, atomic64_inc, inode_init_owner, current_time, nilfs_bmap_read, nilfs_mask_flags, nilfs_set_inode_flags, nilfs_insert_inode_locked, nilfs_init_acl, clear_nlink, unlock_new_inode, iput, make_bad_inode, ERR_PTR]\n\n2. 函数名: new_inode\n- 参数: [sb]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n3. 函数名: mapping_set_gfp_mask\n- 参数: [inode->i_mapping, mapping_gfp_constraint(...)]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n4. 函数名: mapping_gfp_constraint\n- 参数: [inode->i_mapping, ~__GFP_FS]\n- 调用者: mapping_set_gfp_mask\n- 被调用者: 未指定\n\n5. 函数名: nilfs_ifile_create_inode\n- 参数: [root->ifile, &ino, &ii->i_bh]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n6. 函数名: atomic64_inc\n- 参数: [&root->inodes_count]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n7. 函数名: inode_init_owner\n- 参数: [&init_user_ns, inode, dir, mode]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n8. 函数名: current_time\n- 参数: [inode]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n9. 函数名: nilfs_bmap_read\n- 参数: [ii->i_bmap, NULL]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n10. 函数名: nilfs_mask_flags\n- 参数: [mode, NILFS_I(dir)->i_flags & NILFS_FL_INHERITED]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n11. 函数名: nilfs_set_inode_flags\n- 参数: [inode]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n12. 函数名: nilfs_insert_inode_locked\n- 参数: [inode, root, ino]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n13. 函数名: nilfs_init_acl\n- 参数: [inode, dir]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n14. 函数名: clear_nlink\n- 参数: [inode]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n15. 函数名: unlock_new_inode\n- 参数: [inode]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n16. 函数名: iput\n- 参数: [inode]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n17. 函数名: make_bad_inode\n- 参数: [inode]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定\n\n18. 函数名: ERR_PTR\n- 参数: [err]\n- 调用者: nilfs_new_inode\n- 被调用者: 未指定"
    },
    {
        "id": 3918,
        "cwe": "CWE-119",
        "cve": "CVE-2023-21264",
        "purpose": "Code purpose:\"\"\"检查页面状态并验证内存访问权限，确保只有允许的内存区域被访问\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内存访问检查位置不当导致可能访问到hypervisor内存\"\"\"",
        "functions": "Functions:\n1. 函数名: __check_page_state_visitor\n- 参数: [const struct kvm_pgtable_visit_ctx *ctx, enum kvm_pgtable_walk_flags visit]\n- 调用者: 未明确（可能是kvm_pgtable_walk相关函数）\n- 被调用者: [kvm_pte_valid, addr_is_allowed_memory, kvm_pte_to_phys]\n\n2. 函数名: kvm_pte_valid\n- 参数: [ctx->old]\n- 调用者: __check_page_state_visitor\n- 被调用者: []\n\n3. 函数名: addr_is_allowed_memory\n- 参数: [kvm_pte_to_phys(ctx->old)]\n- 调用者: __check_page_state_visitor\n- 被调用者: []\n\n4. 函数名: kvm_pte_to_phys\n- 参数: [ctx->old]\n- 调用者: __check_page_state_visitor\n- 被调用者: []"
    },
    {
        "id": 4303,
        "cwe": "CWE-119",
        "cve": "CVE-2023-6560",
        "purpose": "Code purpose:\"\"\"将用户空间的连续内存区域映射到内核空间，并确保其物理页面的连续性和可访问性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证用户空间提供的uaddr和size参数，导致在pin_user_pages_fast操作时可能发生越界内存访问\"\"\"",
        "functions": "Functions:\n1. 函数名: __io_uaddr_map\n- 参数: [struct page ***pages, unsigned short *npages, unsigned long uaddr, size_t size]\n- 调用者: 未显示（上下文缺失）\n- 被调用者: [ERR_PTR, kvmalloc_array, pin_user_pages_fast, io_pages_free, PageHighMem, page_to_virt]\n\n2. 函数名: ERR_PTR\n- 参数: [long error]\n- 调用者: __io_uaddr_map\n- 被调用者: 未显示（假设为内核API）\n\n3. 函数名: kvmalloc_array\n- 参数: [size_t n, size_t size, gfp_t flags]\n- 调用者: __io_uaddr_map\n- 被调用者: 未显示（内核内存分配API）\n\n4. 函数名: pin_user_pages_fast\n- 参数: [unsigned long start, unsigned long nr_pages, unsigned int gup_flags, struct page **pages]\n- 调用者: __io_uaddr_map\n- 被调用者: 未显示（内核页管理API）\n\n5. 函数名: io_pages_free\n- 参数: [struct page ***pages, int npages]\n- 调用者: __io_uaddr_map\n- 被调用者: 未显示（上下文缺失）\n\n6. 函数名: PageHighMem\n- 参数: [struct page *page]\n- 调用者: __io_uaddr_map\n- 被调用者: 未显示（内核页管理API）\n\n7. 函数名: page_to_virt\n- 参数: [struct page *page]\n- 调用者: __io_uaddr_map\n- 被调用者: 未显示（内核地址转换API）"
    },
    {
        "id": 63,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3511",
        "purpose": "Code purpose:\"\"\"该代码用于实现内存建议(madvise)功能中的移除操作，通过释放指定内存区域并打洞(punch hole)来优化内存使用，但存在竞争条件漏洞可能导致使用后释放问题。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放mmap_sem信号量后执行do_fallocate操作期间，存在竞争条件可能导致内存区域被munmap或close系统调用释放，造成后续使用已释放内存的use-after-free问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: madvise_remove\n- 参数: [struct vm_area_struct *vma, struct vm_area_struct **prev, unsigned long start, unsigned long end]\n- 调用者: sys_madvise\n- 被调用者: [do_fallocate, up_read, down_read]\n\n2. 函数名: do_fallocate\n- 参数: [struct file *file, int mode, loff_t offset, loff_t len]\n- 调用者: madvise_remove\n- 被调用者: []\n\n3. 函数名: up_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: madvise_remove\n- 被调用者: []\n\n4. 函数名: down_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: madvise_remove\n- 被调用者: []"
    },
    {
        "id": 64,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"处理DCCP协议IPv4连接请求，创建新的子socket并设置相关网络参数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理网络流量时，应用程序设置套接字选项的过程中存在竞争条件，可能导致slab损坏和系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: dccp_v4_request_recv_sock\n- 参数: [sk, skb, req, dst]\n- 调用者: 未显示（通常由网络协议栈调用）\n- 被调用者: [sk_acceptq_is_full, inet_csk_route_req, dccp_create_openreq_child, sk_setup_caps, inet_sk, inet_rsk, ip_hdr, dccp_sync_mss, __inet_inherit_port, sock_put, dst_release, NET_INC_STATS_BH, sock_net, __inet_hash_nolisten]\n\n2. 函数名: sk_acceptq_is_full\n- 参数: [sk]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n3. 函数名: inet_csk_route_req\n- 参数: [sk, req]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n4. 函数名: dccp_create_openreq_child\n- 参数: [sk, req, skb]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n5. 函数名: sk_setup_caps\n- 参数: [newsk, dst]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n6. 函数名: inet_sk\n- 参数: [newsk]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n7. 函数名: inet_rsk\n- 参数: [req]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n8. 函数名: ip_hdr\n- 参数: [skb]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n9. 函数名: dccp_sync_mss\n- 参数: [newsk, dst_mtu(dst)]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n10. 函数名: __inet_inherit_port\n- 参数: [sk, newsk]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n11. 函数名: sock_put\n- 参数: [newsk]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n12. 函数名: dst_release\n- 参数: [dst]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n13. 函数名: NET_INC_STATS_BH\n- 参数: [sock_net(sk), LINUX_MIB_LISTENOVERFLOWS/LINUX_MIB_LISTENDROPS]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n14. 函数名: sock_net\n- 参数: [sk]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []\n\n15. 函数名: __inet_hash_nolisten\n- 参数: [newsk, NULL]\n- 调用者: dccp_v4_request_recv_sock\n- 被调用者: []"
    },
    {
        "id": 65,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"实现DCCP协议在IPv4下的客户端连接功能，包括路由查找、端口绑定和连接建立等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理网络流量时，应用程序设置套接字选项的过程中存在竞态条件，可能导致slab损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: dccp_v4_connect\n- 参数: [struct sock *sk, struct sockaddr *uaddr, int addr_len]\n- 调用者: 无（顶层函数）\n- 被调用者: [inet_sk, dccp_sk, ip_route_connect, IS_ERR, PTR_ERR, ip_rt_put, inet_csk, dccp_set_state, inet_hash_connect, ip_route_newports, sk_setup_caps, secure_dccp_sequence_number, dccp_connect]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n3. 函数名: dccp_sk\n- 参数: [struct sock *sk]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n4. 函数名: ip_route_connect\n- 参数: [struct flowi4 *fl4, __be32 nexthop, __be32 saddr, unsigned int flags, int oif, u8 protocol, __be16 sport, __be16 dport, struct sock *sk, bool can_sleep]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n5. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n6. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n7. 函数名: ip_rt_put\n- 参数: [struct rtable *rt]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n8. 函数名: inet_csk\n- 参数: [struct sock *sk]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n9. 函数名: dccp_set_state\n- 参数: [struct sock *sk, enum dccp_state state]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n10. 函数名: inet_hash_connect\n- 参数: [struct inet_timewait_death_row *death_row, struct sock *sk]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n11. 函数名: ip_route_newports\n- 参数: [struct flowi4 *fl4, struct rtable *rt, __be16 orig_sport, __be16 orig_dport, __be16 sport, __be16 dport, struct sock *sk]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n12. 函数名: sk_setup_caps\n- 参数: [struct sock *sk, struct dst_entry *dst]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n13. 函数名: secure_dccp_sequence_number\n- 参数: [__be32 saddr, __be32 daddr, __be16 sport, __be16 dport]\n- 调用者: dccp_v4_connect\n- 被调用者: 无\n\n14. 函数名: dccp_connect\n- 参数: [struct sock *sk]\n- 调用者: dccp_v4_connect\n- 被调用者: 无"
    },
    {
        "id": 66,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"处理IPv6 DCCP协议的网络请求，创建新的子socket并继承父socket的相关配置，同时处理IPv4到IPv6的地址映射。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理网络流量时，应用程序设置套接字选项的操作与网络数据包处理之间存在竞争条件，导致slab损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: dccp_v6_request_recv_sock\n- 参数: [sk, skb, req, dst]\n- 调用者: 无（顶层函数）\n- 被调用者: [dccp_v4_request_recv_sock, inet6_rsk, inet_sk, inet6_sk, htons, memcpy, ipv6_addr_set_v4mapped, ipv6_addr_copy, inet_csk, dccp_v4_do_rcv, inet6_iif, ipv6_hdr, dccp_sync_mss, sk_acceptq_is_full, memset, fl6_update_dst, security_sk_classify_flow, ip6_dst_lookup_flow, IS_ERR, dccp_create_openreq_child, __ip6_dst_store, skb_clone, kfree_skb, skb_set_owner_r, ipv6_dup_options, sock_kfree_s, dst_mtu, __inet_inherit_port, sock_put, __inet6_hash, dst_release, NET_INC_STATS_BH]\n\n2. 函数名: dccp_v4_request_recv_sock\n- 参数: [sk, skb, req, dst]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n3. 函数名: inet6_rsk\n- 参数: [req]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n4. 函数名: inet_sk\n- 参数: [newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n5. 函数名: inet6_sk\n- 参数: [newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n6. 函数名: htons\n- 参数: [ETH_P_IP]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n7. 函数名: memcpy\n- 参数: [newnp, np, sizeof(struct ipv6_pinfo)]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（标准库函数）\n\n8. 函数名: ipv6_addr_set_v4mapped\n- 参数: [newinet->inet_daddr, &newnp->daddr]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n9. 函数名: ipv6_addr_copy\n- 参数: [&newnp->rcv_saddr, &newnp->saddr]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n10. 函数名: inet_csk\n- 参数: [newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n11. 函数名: dccp_v4_do_rcv\n- 参数: 无（函数指针）\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n12. 函数名: inet6_iif\n- 参数: [skb]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n13. 函数名: ipv6_hdr\n- 参数: [skb]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n14. 函数名: dccp_sync_mss\n- 参数: [newsk, inet_csk(newsk)->icsk_pmtu_cookie]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n15. 函数名: sk_acceptq_is_full\n- 参数: [sk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n16. 函数名: memset\n- 参数: [&fl6, 0, sizeof(fl6)]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（标准库函数）\n\n17. 函数名: fl6_update_dst\n- 参数: [&fl6, opt, &final]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n18. 函数名: security_sk_classify_flow\n- 参数: [sk, flowi6_to_flowi(&fl6)]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n19. 函数名: ip6_dst_lookup_flow\n- 参数: [sk, &fl6, final_p, false]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n20. 函数名: IS_ERR\n- 参数: [dst]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n21. 函数名: dccp_create_openreq_child\n- 参数: [sk, req, skb]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n22. 函数名: __ip6_dst_store\n- 参数: [newsk, dst, NULL, NULL]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n23. 函数名: skb_clone\n- 参数: [ireq6->pktopts, GFP_ATOMIC]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n24. 函数名: kfree_skb\n- 参数: [ireq6->pktopts]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n25. 函数名: skb_set_owner_r\n- 参数: [newnp->pktoptions, newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n26. 函数名: ipv6_dup_options\n- 参数: [newsk, opt]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n27. 函数名: sock_kfree_s\n- 参数: [sk, opt, opt->tot_len]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n28. 函数名: dst_mtu\n- 参数: [dst]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n29. 函数名: __inet_inherit_port\n- 参数: [sk, newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n30. 函数名: sock_put\n- 参数: [newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n31. 函数名: __inet6_hash\n- 参数: [newsk, NULL]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n32. 函数名: dst_release\n- 参数: [dst]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）\n\n33. 函数名: NET_INC_STATS_BH\n- 参数: [sock_net(sk), LINUX_MIB_LISTENOVERFLOWS]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 无（假设为外部函数）"
    },
    {
        "id": 67,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"重建IP套接字的网络路由信息，处理路由失败情况并返回错误码\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送数据包导致slab损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: inet_sk_rebuild_header\n- 参数: [struct sock *sk]\n- 调用者: 未指定\n- 被调用者: [inet_sk, __sk_dst_check, ip_route_output_ports, sock_net, sk_setup_caps, PTR_ERR, inet_sk_reselect_saddr]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: inet_sk_rebuild_header\n- 被调用者: 未指定\n\n3. 函数名: __sk_dst_check\n- 参数: [struct sock *sk, int cookie]\n- 调用者: inet_sk_rebuild_header\n- 被调用者: 未指定\n\n4. 函数名: ip_route_output_ports\n- 参数: [struct net *net, struct sock *sk, __be32 daddr, __be32 saddr, __be16 dport, __be16 sport, u8 proto, u32 flags, int ifindex]\n- 调用者: inet_sk_rebuild_header\n- 被调用者: 未指定\n\n5. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: inet_sk_rebuild_header\n- 被调用者: 未指定\n\n6. 函数名: sk_setup_caps\n- 参数: [struct sock *sk, struct dst_entry *dst]\n- 调用者: inet_sk_rebuild_header\n- 被调用者: 未指定\n\n7. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: inet_sk_rebuild_header\n- 被调用者: 未指定\n\n8. 函数名: inet_sk_reselect_saddr\n- 参数: [struct sock *sk]\n- 调用者: inet_sk_rebuild_header\n- 被调用者: 未指定"
    },
    {
        "id": 68,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"释放inet套接字资源并检查其状态是否合法\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送数据包导致slab损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: inet_sock_destruct\n- 参数: [struct sock *sk]\n- 调用者: 未显示（通常由内核网络子系统调用）\n- 被调用者: [inet_sk, __skb_queue_purge, sk_mem_reclaim, pr_err, atomic_read, WARN_ON, kfree, dst_release, rcu_dereference_check, sk_refcnt_debug_dec]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: inet_sock_destruct\n- 被调用者: []\n\n3. 函数名: __skb_queue_purge\n- 参数: [&sk->sk_receive_queue, &sk->sk_error_queue]\n- 调用者: inet_sock_destruct\n- 被调用者: []\n\n4. 函数名: sk_mem_reclaim\n- 参数: [struct sock *sk]\n- 调用者: inet_sock_destruct\n- 被调用者: []\n\n5. 函数名: pr_err\n- 参数: [\"Attempt to release TCP socket in state %d %p\", sk->sk_state, sk], [\"Attempt to release alive inet socket %p\", sk]\n- 调用者: inet_sock_destruct\n- 被调用者: []\n\n6. 函数名: atomic_read\n- 参数: [&sk->sk_rmem_alloc, &sk->sk_wmem_alloc]\n- 调用者: WARN_ON (通过inet_sock_destruct间接调用)\n- 被调用者: []\n\n7. 函数名: WARN_ON\n- 参数: [atomic_read(&sk->sk_rmem_alloc), atomic_read(&sk->sk_wmem_alloc), sk->sk_wmem_queued, sk->sk_forward_alloc]\n- 调用者: inet_sock_destruct\n- 被调用者: [atomic_read]\n\n8. 函数名: kfree\n- 参数: [inet->opt]\n- 调用者: inet_sock_destruct\n- 被调用者: []\n\n9. 函数名: dst_release\n- 参数: [rcu_dereference_check(sk->sk_dst_cache, 1)]\n- 调用者: inet_sock_destruct\n- 被调用者: [rcu_dereference_check]\n\n10. 函数名: rcu_dereference_check\n- 参数: [sk->sk_dst_cache, 1]\n- 调用者: dst_release (通过inet_sock_destruct间接调用)\n- 被调用者: []\n\n11. 函数名: sk_refcnt_debug_dec\n- 参数: [struct sock *sk]\n- 调用者: inet_sock_destruct\n- 被调用者: []"
    },
    {
        "id": 69,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"在Linux内核中动态改变套接字的源IP地址并重新建立路由\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可利用此条件导致拒绝服务（slab损坏和系统崩溃）。\"\"\"",
        "functions": "Functions:\n1. 函数名: inet_sk_reselect_saddr\n- 参数: [struct sock *sk]\n- 调用者: 未显示（由内核网络栈调用）\n- 被调用者: [inet_sk, ip_route_connect, IS_ERR, PTR_ERR, sk_setup_caps, printk, __sk_prot_rehash]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: inet_sk_reselect_saddr\n- 被调用者: 未显示（宏或内联函数）\n\n3. 函数名: ip_route_connect\n- 参数: [struct flowi4 *fl4, __be32 daddr, __be32 saddr, int flags, int bound_dev_if, u8 protocol, __be16 sport, __be16 dport, struct sock *sk, bool no_sport]\n- 调用者: inet_sk_reselect_saddr\n- 被调用者: 未显示\n\n4. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: inet_sk_reselect_saddr\n- 被调用者: 未显示（宏）\n\n5. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: inet_sk_reselect_saddr\n- 被调用者: 未显示（宏）\n\n6. 函数名: sk_setup_caps\n- 参数: [struct sock *sk, struct dst_entry *dst]\n- 调用者: inet_sk_reselect_saddr\n- 被调用者: 未显示\n\n7. 函数名: printk\n- 参数: [const char *fmt, ...]\n- 调用者: inet_sk_reselect_saddr\n- 被调用者: 未显示\n\n8. 函数名: __sk_prot_rehash\n- 参数: [struct sock *sk]\n- 调用者: inet_sk_reselect_saddr\n- 被调用者: 未显示"
    },
    {
        "id": 70,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"该代码用于在请求套接字中删除CIPSO选项，处理网络流量时可能存在的竞争条件会导致拒绝服务漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺乏适当的同步机制，在Linux内核处理网络流量时，远程攻击者可以通过发送数据包与应用程序设置套接字选项的操作产生竞争条件，导致slab损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: cipso_v4_req_delattr\n- 参数: [struct request_sock *req]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [inet_rsk, cipso_v4_delopt]\n\n2. 函数名: inet_rsk\n- 参数: [struct request_sock *req]\n- 调用者: cipso_v4_req_delattr\n- 被调用者: []\n\n3. 函数名: cipso_v4_delopt\n- 参数: [struct ip_options **opt]\n- 调用者: cipso_v4_req_delattr\n- 被调用者: []"
    },
    {
        "id": 71,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"该代码用于从套接字中删除CIPSO选项并调整相关头部长度，处理网络流量时可能存在的竞争条件漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送数据包导致slab损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: cipso_v4_sock_delattr\n- 参数: [struct sock *sk]\n- 调用者: 未显示\n- 被调用者: [inet_sk, cipso_v4_delopt, inet_csk]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: cipso_v4_sock_delattr\n- 被调用者: 未显示\n\n3. 函数名: cipso_v4_delopt\n- 参数: [&sk_inet->opt]\n- 调用者: cipso_v4_sock_delattr\n- 被调用者: 未显示\n\n4. 函数名: inet_csk\n- 参数: [struct sock *sk]\n- 调用者: cipso_v4_sock_delattr\n- 被调用者: 未显示"
    },
    {
        "id": 72,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"该代码用于获取套接字的CIPSO安全属性，但存在竞态条件漏洞可能导致内核内存损坏\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，可能导致slab损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: cipso_v4_sock_getattr\n- 参数: [sk, secattr]\n- 调用者: 未明确（由内核网络协议栈调用）\n- 被调用者: [inet_sk, cipso_v4_getattr]\n\n2. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: cipso_v4_sock_getattr\n- 被调用者: []\n\n3. 函数名: cipso_v4_getattr\n- 参数: [opt->__data + opt->cipso - sizeof(struct iphdr), secattr]\n- 调用者: cipso_v4_sock_getattr\n- 被调用者: []"
    },
    {
        "id": 73,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"该代码用于为IPv4套接字设置CIPSO安全标签属性，包括生成选项数据、分配内存并更新套接字选项。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，可能导致远程攻击者通过发送数据包造成拒绝服务（slab损坏和系统崩溃）。\"\"\"",
        "functions": "Functions:\n1. 函数名: cipso_v4_sock_setattr\n- 参数: [struct sock *sk, const struct cipso_v4_doi *doi_def, const struct netlbl_lsm_secattr *secattr]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [kmalloc, cipso_v4_genopt, kzalloc, memcpy, kfree, inet_sk, inet_csk, xchg]\n\n2. 函数名: kmalloc\n- 参数: [buf_len, GFP_ATOMIC]\n- 调用者: cipso_v4_sock_setattr\n- 被调用者: []\n\n3. 函数名: cipso_v4_genopt\n- 参数: [buf, buf_len, doi_def, secattr]\n- 调用者: cipso_v4_sock_setattr\n- 被调用者: []\n\n4. 函数名: kzalloc\n- 参数: [sizeof(*opt) + opt_len, GFP_ATOMIC]\n- 调用者: cipso_v4_sock_setattr\n- 被调用者: []\n\n5. 函数名: memcpy\n- 参数: [opt->__data, buf, buf_len]\n- 调用者: cipso_v4_sock_setattr\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [buf]\n- 调用者: cipso_v4_sock_setattr\n- 被调用者: []\n\n7. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: cipso_v4_sock_setattr\n- 被调用者: []\n\n8. 函数名: inet_csk\n- 参数: [sk]\n- 调用者: cipso_v4_sock_setattr\n- 被调用者: []\n\n9. 函数名: xchg\n- 参数: [&sk_inet->opt, opt]\n- 调用者: cipso_v4_sock_setattr\n- 被调用者: []\n\n10. 函数名: kfree\n- 参数: [opt]\n- 调用者: cipso_v4_sock_setattr\n- 被调用者: []"
    },
    {
        "id": 74,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理CIPSO网络标签的安全属性设置，包括内存分配、选项生成和套接字选项设置。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在设置socket选项时存在竞态条件，可能导致内核内存损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: cipso_v4_req_setattr\n- 参数: [struct request_sock *req, const struct cipso_v4_doi *doi_def, const struct netlbl_lsm_secattr *secattr]\n- 调用者: 未明确（由内核网络协议栈调用）\n- 被调用者: [kmalloc, cipso_v4_genopt, kzalloc, memcpy, kfree, inet_rsk, xchg]\n\n2. 函数名: kmalloc\n- 参数: [size_t buf_len, gfp_t GFP_ATOMIC]\n- 调用者: cipso_v4_req_setattr\n- 被调用者: []\n\n3. 函数名: cipso_v4_genopt\n- 参数: [unsigned char *buf, u32 buf_len, const struct cipso_v4_doi *doi_def, const struct netlbl_lsm_secattr *secattr]\n- 调用者: cipso_v4_req_setattr\n- 被调用者: []\n\n4. 函数名: kzalloc\n- 参数: [size_t sizeof(*opt) + opt_len, gfp_t GFP_ATOMIC]\n- 调用者: cipso_v4_req_setattr\n- 被调用者: []\n\n5. 函数名: memcpy\n- 参数: [void *opt->__data, const void *buf, size_t buf_len]\n- 调用者: cipso_v4_req_setattr\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [void *buf / void *opt]\n- 调用者: cipso_v4_req_setattr\n- 被调用者: []\n\n7. 函数名: inet_rsk\n- 参数: [struct request_sock *req]\n- 调用者: cipso_v4_req_setattr\n- 被调用者: []\n\n8. 函数名: xchg\n- 参数: [struct ip_options **req_inet->opt, struct ip_options *opt]\n- 调用者: cipso_v4_req_setattr\n- 被调用者: []"
    },
    {
        "id": 75,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中ICMP协议回复功能，处理接收到的ICMP请求并生成相应回复。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送数据包导致slab损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: icmp_reply\n- 参数: [struct icmp_bxm *icmp_param, struct sk_buff *skb]\n- 调用者: 未显示\n- 被调用者: [ip_options_echo, skb_rtable, dev_net, icmp_xmit_lock, inet_sk, ip_hdr, security_skb_classify_flow, ip_route_output_key, IS_ERR, icmpv4_xrlim_allow, icmp_push_reply, ip_rt_put, icmp_xmit_unlock]\n\n2. 函数名: ip_options_echo\n- 参数: [&icmp_param->replyopts, skb]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n3. 函数名: skb_rtable\n- 参数: [skb]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n4. 函数名: dev_net\n- 参数: [rt->dst.dev]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n5. 函数名: icmp_xmit_lock\n- 参数: [net]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n6. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n7. 函数名: ip_hdr\n- 参数: [skb]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n8. 函数名: security_skb_classify_flow\n- 参数: [skb, flowi4_to_flowi(&fl4)]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n9. 函数名: ip_route_output_key\n- 参数: [net, &fl4]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n10. 函数名: IS_ERR\n- 参数: [rt]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n11. 函数名: icmpv4_xrlim_allow\n- 参数: [net, rt, icmp_param->data.icmph.type, icmp_param->data.icmph.code]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n12. 函数名: icmp_push_reply\n- 参数: [icmp_param, &ipc, &rt]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n13. 函数名: ip_rt_put\n- 参数: [rt]\n- 调用者: icmp_reply\n- 被调用者: 未显示\n\n14. 函数名: icmp_xmit_unlock\n- 参数: [sk]\n- 调用者: icmp_reply\n- 被调用者: 未显示"
    },
    {
        "id": 76,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中ICMP协议的错误消息发送功能，用于处理并回复ICMP错误报文。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送特定数据包导致slab损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: icmp_send\n- 参数: [struct sk_buff *skb_in, int type, int code, __be32 info]\n- 调用者: 未显示\n- 被调用者: [dev_net, ip_hdr, skb_rtable, skb_header_pointer, icmp_xmit_lock, dev_get_by_index_rcu, inet_select_addr, ip_options_echo, icmp_route_lookup, icmpv4_xrlim_allow, icmp_push_reply, ip_rt_put, icmp_xmit_unlock]\n\n2. 函数名: dev_net\n- 参数: [struct device *dev]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n3. 函数名: ip_hdr\n- 参数: [const struct sk_buff *skb]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n4. 函数名: skb_rtable\n- 参数: [const struct sk_buff *skb]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n5. 函数名: skb_header_pointer\n- 参数: [const struct sk_buff *skb, int offset, int len, void *buffer]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n6. 函数名: icmp_xmit_lock\n- 参数: [struct net *net]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n7. 函数名: dev_get_by_index_rcu\n- 参数: [struct net *net, int ifindex]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n8. 函数名: inet_select_addr\n- 参数: [struct net_device *dev, __be32 dst, int scope]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n9. 函数名: ip_options_echo\n- 参数: [struct ip_options *dopt, struct sk_buff *skb]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n10. 函数名: icmp_route_lookup\n- 参数: [struct net *net, struct sk_buff *skb_in, struct iphdr *iph, __be32 saddr, u8 tos, int type, int code, struct icmp_bxm *param]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n11. 函数名: icmpv4_xrlim_allow\n- 参数: [struct net *net, struct rtable *rt, int type, int code]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n12. 函数名: icmp_push_reply\n- 参数: [struct icmp_bxm *icmp_param, struct ipcm_cookie *ipc, struct rtable **rt]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n13. 函数名: ip_rt_put\n- 参数: [struct rtable *rt]\n- 调用者: icmp_send\n- 被调用者: 未显示\n\n14. 函数名: icmp_xmit_unlock\n- 参数: [struct sock *sk]\n- 调用者: icmp_send\n- 被调用者: 未显示"
    },
    {
        "id": 77,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中实现ICMP消息的路由查找功能，处理ICMP请求的路由选择和反向会话解码。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，可能导致远程攻击者通过发送特定数据包造成slab损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: icmp_route_lookup\n- 参数: [net, skb_in, iph, saddr, tos, type, code, param]\n- 调用者: N/A (顶层函数)\n- 被调用者: [security_skb_classify_flow, __ip_route_output_key, xfrm_lookup, xfrm_decode_session_reverse, inet_addr_type, ip_route_output_key, ip_route_input, dst_release, skb_rtable, ERR_PTR]\n\n2. 函数名: security_skb_classify_flow\n- 参数: [skb_in, flowi4_to_flowi(&fl4)]\n- 调用者: icmp_route_lookup\n- 被调用者: []\n\n3. 函数名: __ip_route_output_key\n- 参数: [net, &fl4]\n- 调用者: icmp_route_lookup\n- 被调用者: []\n\n4. 函数名: xfrm_lookup\n- 参数: [net, &rt->dst, flowi4_to_flowi(&fl4), NULL, 0]\n- 调用者: icmp_route_lookup\n- 被调用者: []\n\n5. 函数名: xfrm_decode_session_reverse\n- 参数: [skb_in, flowi4_to_flowi(&fl4), AF_INET]\n- 调用者: icmp_route_lookup\n- 被调用者: []\n\n6. 函数名: inet_addr_type\n- 参数: [net, fl4.saddr]\n- 调用者: icmp_route_lookup\n- 被调用者: []\n\n7. 函数名: ip_route_output_key\n- 参数: [net, &fl4_2]\n- 调用者: icmp_route_lookup\n- 被调用者: []\n\n8. 函数名: ip_route_input\n- 参数: [skb_in, fl4.daddr, fl4.saddr, RT_TOS(tos), rt2->dst.dev]\n- 调用者: icmp_route_lookup\n- 被调用者: []\n\n9. 函数名: dst_release\n- 参数: [&rt2->dst]\n- 调用者: icmp_route_lookup\n- 被调用者: []\n\n10. 函数名: skb_rtable\n- 参数: [skb_in]\n- 调用者: icmp_route_lookup\n- 被调用者: []\n\n11. 函数名: ERR_PTR\n- 参数: [err]\n- 调用者: icmp_route_lookup\n- 被调用者: []"
    },
    {
        "id": 78,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"该代码用于为传入的连接请求创建并返回一个路由表项，处理网络流量的路由选择\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理网络流量时，应用程序设置套接字选项的操作与网络流量处理之间存在竞争条件，导致slab损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: inet_csk_route_req\n- 参数: [struct sock *sk, const struct request_sock *req]\n- 调用者: 未显示\n- 被调用者: [inet_rsk, flowi4_init_output, sock_net, inet_sk_flowi_flags, security_req_classify_flow, ip_route_output_flow, IS_ERR, ip_rt_put, IP_INC_STATS_BH]\n\n2. 函数名: inet_rsk\n- 参数: [const struct request_sock *req]\n- 调用者: inet_csk_route_req\n- 被调用者: 未显示\n\n3. 函数名: flowi4_init_output\n- 参数: [struct flowi4 *fl4, sk->sk_bound_dev_if, sk->sk_mark, RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE, sk->sk_protocol, inet_sk_flowi_flags(sk), (opt && opt->srr) ? opt->faddr : ireq->rmt_addr, ireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport]\n- 调用者: inet_csk_route_req\n- 被调用者: 未显示\n\n4. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: inet_csk_route_req\n- 被调用者: 未显示\n\n5. 函数名: inet_sk_flowi_flags\n- 参数: [struct sock *sk]\n- 调用者: inet_csk_route_req\n- 被调用者: 未显示\n\n6. 函数名: security_req_classify_flow\n- 参数: [const struct request_sock *req, flowi4_to_flowi(&fl4)]\n- 调用者: inet_csk_route_req\n- 被调用者: 未显示\n\n7. 函数名: ip_route_output_flow\n- 参数: [struct net *net, struct flowi4 *fl4, struct sock *sk]\n- 调用者: inet_csk_route_req\n- 被调用者: 未显示\n\n8. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: inet_csk_route_req\n- 被调用者: 未显示\n\n9. 函数名: ip_rt_put\n- 参数: [struct rtable *rt]\n- 调用者: inet_csk_route_req\n- 被调用者: 未显示\n\n10. 函数名: IP_INC_STATS_BH\n- 参数: [struct net *net, IPSTATS_MIB_OUTNOROUTES]\n- 调用者: inet_csk_route_req\n- 被调用者: 未显示"
    },
    {
        "id": 79,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"构建IP选项并将它们复制到网络数据包中，同时处理源路由、记录路由和时间戳等选项。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送数据包导致slab损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: ip_options_build\n- 参数: [struct sk_buff * skb, struct ip_options * opt, __be32 daddr, struct rtable *rt, int is_frag]\n- 调用者: 未显示（由内核网络栈调用）\n- 被调用者: [memcpy, ip_rt_get_source, getnstimeofday, htonl, memset]\n\n2. 函数名: memcpy\n- 参数: [void * dest, const void * src, size_t n]\n- 调用者: [ip_options_build]\n- 被调用者: []\n\n3. 函数名: ip_rt_get_source\n- 参数: [void * addr, struct rtable *rt]\n- 调用者: [ip_options_build]\n- 被调用者: []\n\n4. 函数名: getnstimeofday\n- 参数: [struct timespec * ts]\n- 调用者: [ip_options_build]\n- 被调用者: []\n\n5. 函数名: htonl\n- 参数: [uint32_t hostlong]\n- 调用者: [ip_options_build]\n- 被调用者: []\n\n6. 函数名: memset\n- 参数: [void * s, int c, size_t n]\n- 调用者: [ip_options_build]\n- 被调用者: []"
    },
    {
        "id": 80,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"分配并初始化一个IP选项结构体，其大小包括基础结构体大小和按4字节对齐的选项长度\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，可能导致远程攻击者通过发送数据包造成slab损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: ip_options_get_alloc\n- 参数: [optlen]\n- 调用者: 未指定（由描述可知可能被IP实现相关代码调用）\n- 被调用者: [kzalloc]"
    },
    {
        "id": 81,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"处理IP选项的回显功能，包括路由记录、时间戳和严格源路由等选项的复制和验证\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送特定数据包导致slab损坏和系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: ip_options_echo\n- 参数: [struct ip_options * dopt, struct sk_buff * skb]\n- 调用者: 未明确（由内核网络协议栈调用）\n- 被调用者: [memset, skb_network_header, skb_rtable, memcpy, inet_addr_type, memcmp, ip_hdr]\n\n2. 函数名: memset\n- 参数: [void * s, int c, size_t n]\n- 调用者: ip_options_echo\n- 被调用者: []\n\n3. 函数名: skb_network_header\n- 参数: [const struct sk_buff * skb]\n- 调用者: ip_options_echo\n- 被调用者: []\n\n4. 函数名: skb_rtable\n- 参数: [const struct sk_buff * skb]\n- 调用者: ip_options_echo\n- 被调用者: []\n\n5. 函数名: memcpy\n- 参数: [void * dest, const void * src, size_t n]\n- 调用者: ip_options_echo\n- 被调用者: []\n\n6. 函数名: inet_addr_type\n- 参数: [struct net * net, __be32 addr]\n- 调用者: ip_options_echo\n- 被调用者: []\n\n7. 函数名: memcmp\n- 参数: [const void * s1, const void * s2, size_t n]\n- 调用者: ip_options_echo\n- 被调用者: []\n\n8. 函数名: ip_hdr\n- 参数: [const struct sk_buff * skb]\n- 调用者: ip_options_echo\n- 被调用者: []\n\n9. 函数名: dev_net\n- 参数: [const struct net_device * dev]\n- 调用者: ip_options_echo\n- 被调用者: []\n\n10. 函数名: skb_dst\n- 参数: [const struct sk_buff * skb]\n- 调用者: ip_options_echo\n- 被调用者: []"
    },
    {
        "id": 82,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"设置IP层的corking选项，包括复制IP选项、计算分片大小并初始化相关结构体，用于网络数据包的处理和传输\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，可能导致远程攻击者通过发送数据包造成slab损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: ip_setup_cork\n- 参数: [struct sock *sk, struct inet_cork *cork, struct ipcm_cookie *ipc, struct rtable **rtp]\n- 调用者: 未指定（由内核网络栈调用）\n- 被调用者: [inet_sk, kmalloc, memcpy, dst_mtu]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: ip_setup_cork\n- 被调用者: 未指定\n\n3. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: ip_setup_cork\n- 被调用者: 未指定\n\n4. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: ip_setup_cork\n- 被调用者: 未指定\n\n5. 函数名: dst_mtu\n- 参数: [const struct dst_entry *dst]\n- 调用者: ip_setup_cork\n- 被调用者: 未指定"
    },
    {
        "id": 83,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"该代码用于处理IP层的回复数据包发送，包括路由选择、选项处理和套接字操作等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，可能导致远程攻击者通过发送特定数据包造成拒绝服务（slab损坏和系统崩溃）。\"\"\"",
        "functions": "Functions:\n1. 函数名: ip_send_reply\n- 参数: [sk, skb, arg, len]\n- 调用者: 未显示\n- 被调用者: [inet_sk, ip_options_echo, flowi4_init_output, security_skb_classify_flow, ip_route_output_key, sock_net, bh_lock_sock, ip_append_data, skb_peek, skb_transport_header, csum_fold, csum_add, ip_push_pending_frames, bh_unlock_sock, ip_rt_put]\n\n2. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n3. 函数名: ip_options_echo\n- 参数: [&replyopts.opt, skb]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n4. 函数名: flowi4_init_output\n- 参数: [&fl4, arg->bound_dev_if, 0, RT_TOS(ip_hdr(skb)->tos), RT_SCOPE_UNIVERSE, sk->sk_protocol, ip_reply_arg_flowi_flags(arg), daddr, rt->rt_spec_dst, tcp_hdr(skb)->source, tcp_hdr(skb)->dest]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n5. 函数名: security_skb_classify_flow\n- 参数: [skb, flowi4_to_flowi(&fl4)]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n6. 函数名: ip_route_output_key\n- 参数: [sock_net(sk), &fl4]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n7. 函数名: sock_net\n- 参数: [sk]\n- 调用者: ip_route_output_key\n- 被调用者: 未显示\n\n8. 函数名: bh_lock_sock\n- 参数: [sk]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n9. 函数名: ip_append_data\n- 参数: [sk, ip_reply_glue_bits, arg->iov->iov_base, len, 0, &ipc, &rt, MSG_DONTWAIT]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n10. 函数名: skb_peek\n- 参数: [&sk->sk_write_queue]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n11. 函数名: skb_transport_header\n- 参数: [skb]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n12. 函数名: csum_fold\n- 参数: [csum_add(skb->csum, arg->csum)]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n13. 函数名: csum_add\n- 参数: [skb->csum, arg->csum]\n- 调用者: csum_fold\n- 被调用者: 未显示\n\n14. 函数名: ip_push_pending_frames\n- 参数: [sk]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n15. 函数名: bh_unlock_sock\n- 参数: [sk]\n- 调用者: ip_send_reply\n- 被调用者: 未显示\n\n16. 函数名: ip_rt_put\n- 参数: [rt]\n- 调用者: ip_send_reply\n- 被调用者: 未显示"
    },
    {
        "id": 84,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中IP数据包的排队和发送功能，包括路由选择、IP头构建和选项处理等网络传输操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，可能导致远程攻击者通过发送特定数据包造成slab损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: ip_queue_xmit\n- 参数: [struct sk_buff *skb]\n- 调用者: N/A (top-level function)\n- 被调用者: [skb_rtable, __sk_dst_check, ip_route_output_ports, sock_net, sk_setup_caps, skb_dst_set_noref, skb_push, skb_reset_network_header, ip_hdr, htons, ip_dont_fragment, ip_select_ttl, ip_options_build, ip_select_ident_more, ip_local_out, rcu_read_unlock, IP_INC_STATS, kfree_skb]\n\n2. 函数名: skb_rtable\n- 参数: [struct sk_buff *skb]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n3. 函数名: __sk_dst_check\n- 参数: [struct sock *sk, int flag]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n4. 函数名: ip_route_output_ports\n- 参数: [sock_net(sk), sk, daddr, inet->inet_saddr, inet->inet_dport, inet->inet_sport, sk->sk_protocol, RT_CONN_FLAGS(sk), sk->sk_bound_dev_if]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n5. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n6. 函数名: sk_setup_caps\n- 参数: [struct sock *sk, &rt->dst]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n7. 函数名: skb_dst_set_noref\n- 参数: [struct sk_buff *skb, &rt->dst]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n8. 函数名: skb_push\n- 参数: [struct sk_buff *skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0)]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n9. 函数名: skb_reset_network_header\n- 参数: [struct sk_buff *skb]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n10. 函数名: ip_hdr\n- 参数: [struct sk_buff *skb]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n11. 函数名: htons\n- 参数: [(4 << 12) | (5 << 8) | (inet->tos & 0xff)]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n12. 函数名: ip_dont_fragment\n- 参数: [struct sock *sk, &rt->dst]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n13. 函数名: ip_select_ttl\n- 参数: [inet, &rt->dst]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n14. 函数名: ip_options_build\n- 参数: [skb, opt, inet->inet_daddr, rt, 0]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n15. 函数名: ip_select_ident_more\n- 参数: [iph, &rt->dst, sk, (skb_shinfo(skb)->gso_segs ?: 1) - 1]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n16. 函数名: ip_local_out\n- 参数: [struct sk_buff *skb]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n17. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n18. 函数名: IP_INC_STATS\n- 参数: [sock_net(sk), IPSTATS_MIB_OUTNOROUTES]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A\n\n19. 函数名: kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: ip_queue_xmit\n- 被调用者: N/A"
    },
    {
        "id": 85,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中IP套接字选项的获取功能，处理各种IP相关的socket选项请求并返回相应值。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，可能导致slab损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: do_ip_getsockopt\n- 参数: [struct sock *sk, int level, int optname, char __user *optval, int __user *optlen]\n- 调用者: 未明确显示（通常是内核网络栈调用）\n- 被调用者: [ip_mroute_getsockopt, get_user, lock_sock, memcpy, release_sock, put_user, ip_options_undo, min_t, copy_to_user, sk_dst_get, dst_mtu, dst_release, copy_from_user, ip_mc_msfget, ip_mc_gsfget, put_cmsg]\n\n2. 函数名: ip_mroute_getsockopt\n- 参数: [struct sock *sk, int optname, char __user *optval, int __user *optlen]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（代码片段外）\n\n3. 函数名: get_user\n- 参数: [int len, int __user *optlen]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核宏/函数）\n\n4. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核函数）\n\n5. 函数名: memcpy\n- 参数: [unsigned char *optbuf, struct ip_options *inet->opt, size_t sizeof(struct ip_options)+inet->opt->optlen]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（标准库函数）\n\n6. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核函数）\n\n7. 函数名: put_user\n- 参数: [int value, int __user *optlen] 或 [unsigned char ucval, char __user *optval]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核宏/函数）\n\n8. 函数名: ip_options_undo\n- 参数: [struct ip_options *opt]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核函数）\n\n9. 函数名: min_t\n- 参数: [unsigned int, int len, int opt->optlen] 或 [unsigned int, int len, sizeof(struct in_addr)]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核宏）\n\n10. 函数名: copy_to_user\n- 参数: [char __user *optval, void *src, int len]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核函数）\n\n11. 函数名: sk_dst_get\n- 参数: [struct sock *sk]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核函数）\n\n12. 函数名: dst_mtu\n- 参数: [struct dst_entry *dst]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核函数）\n\n13. 函数名: dst_release\n- 参数: [struct dst_entry *dst]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核函数）\n\n14. 函数名: copy_from_user\n- 参数: [struct ip_msfilter *msf, char __user *optval, size_t IP_MSFILTER_SIZE(0)] 或 [struct group_filter *gsf, char __user *optval, size_t GROUP_FILTER_SIZE(0)]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核函数）\n\n15. 函数名: ip_mc_msfget\n- 参数: [struct sock *sk, struct ip_msfilter *msf, struct ip_msfilter __user *optval, int __user *optlen]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核函数）\n\n16. 函数名: ip_mc_gsfget\n- 参数: [struct sock *sk, struct group_filter *gsf, struct group_filter __user *optval, int __user *optlen]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核函数）\n\n17. 函数名: put_cmsg\n- 参数: [struct msghdr *msg, int SOL_IP, int IP_PKTINFO/IP_TTL, size_t sizeof(info)/sizeof(hlim), void *info/hlim]\n- 调用者: do_ip_getsockopt\n- 被调用者: 未显示（内核函数）"
    },
    {
        "id": 86,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"处理IP层的套接字选项设置，包括各种IP相关参数的配置和组播功能的实现\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送数据包导致slab损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: do_ip_setsockopt\n- 参数: [struct sock *sk, int level, int optname, char __user *optval, unsigned int optlen]\n- 调用者: 未显示（由内核网络栈调用）\n- 被调用者: [get_user, ip_mroute_setsockopt, lock_sock, ip_options_get_from_user, xchg, kfree, ip_mc_join_group, ip_mc_leave_group, ip_mc_msfilter, ip_mc_source, ip_ra_control, xfrm_user_policy, release_sock, sk_dst_reset, skb_queue_purge, ip_dev_find, dev_get_by_index, dev_put, copy_from_user, kmalloc, kfree]\n\n2. 函数名: ip_mroute_setsockopt\n- 参数: [struct sock *sk, int optname, char __user *optval, unsigned int optlen]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n3. 函数名: ip_options_get_from_user\n- 参数: [struct net *net, struct ip_options **optptr, unsigned char __user *data, int optlen]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n4. 函数名: ip_mc_join_group\n- 参数: [struct sock *sk, struct ip_mreqn *mreq]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n5. 函数名: ip_mc_leave_group\n- 参数: [struct sock *sk, struct ip_mreqn *mreq]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n6. 函数名: ip_mc_msfilter\n- 参数: [struct sock *sk, struct ip_msfilter *msf, int ifindex]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n7. 函数名: ip_mc_source\n- 参数: [int add, int omode, struct sock *sk, struct ip_mreq_source *mreqs, int ifindex]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n8. 函数名: ip_ra_control\n- 参数: [struct sock *sk, int on, void (*destructor)(struct sock *)]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n9. 函数名: xfrm_user_policy\n- 参数: [struct sock *sk, int optname, char __user *optval, unsigned int optlen]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n10. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n11. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n12. 函数名: ip_dev_find\n- 参数: [struct net *net, __be32 addr]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n13. 函数名: dev_get_by_index\n- 参数: [struct net *net, int ifindex]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示\n\n14. 函数名: dev_put\n- 参数: [struct net_device *dev]\n- 调用者: do_ip_setsockopt\n- 被调用者: 未显示"
    },
    {
        "id": 87,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中原始套接字(raw socket)的发送消息功能，处理IP层数据包的构造和发送，包括地址验证、路由查找和数据处理等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，可能导致远程攻击者通过发送数据包造成拒绝服务（slab损坏和系统崩溃）。\"\"\"",
        "functions": "Functions:\n1. 函数名: raw_sendmsg\n- 参数: [struct kiocb *iocb, struct sock *sk, struct msghdr *msg, size_t len]\n- 调用者: 未显示\n- 被调用者: [inet_sk, ip_cmsg_send, sock_net, flowi4_init_output, raw_probe_proto_opt, security_sk_classify_flow, ip_route_output_flow, raw_send_hdrinc, ip_append_data, ip_flush_pending_frames, ip_push_pending_frames, kfree, ip_rt_put, dst_confirm]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n3. 函数名: ip_cmsg_send\n- 参数: [sock_net(sk), msg, &ipc]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n4. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n5. 函数名: flowi4_init_output\n- 参数: [&fl4, ipc.oif, sk->sk_mark, tos, RT_SCOPE_UNIVERSE, inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol, FLOWI_FLAG_CAN_SLEEP, daddr, saddr, 0, 0]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n6. 函数名: raw_probe_proto_opt\n- 参数: [&fl4, msg]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n7. 函数名: security_sk_classify_flow\n- 参数: [sk, flowi4_to_flowi(&fl4)]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n8. 函数名: ip_route_output_flow\n- 参数: [sock_net(sk), &fl4, sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n9. 函数名: raw_send_hdrinc\n- 参数: [sk, msg->msg_iov, len, &rt, msg->msg_flags]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n10. 函数名: ip_append_data\n- 参数: [sk, ip_generic_getfrag, msg->msg_iov, len, 0, &ipc, &rt, msg->msg_flags]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n11. 函数名: ip_flush_pending_frames\n- 参数: [sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n12. 函数名: ip_push_pending_frames\n- 参数: [sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n13. 函数名: kfree\n- 参数: [ipc.opt]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n14. 函数名: ip_rt_put\n- 参数: [rt]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n15. 函数名: dst_confirm\n- 参数: [&rt->dst]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示"
    },
    {
        "id": 88,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"处理TCP SYN cookie验证和连接请求，用于防御SYN flood攻击并建立合法连接\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理网络流量时，应用程序设置套接字选项的操作与IP实现之间存在竞争条件，可能导致slab损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: cookie_v4_check\n- 参数: [sk, skb, opt]\n- 调用者: 未显示\n- 被调用者: [tcp_sk, tcp_hdr, ntohl, tcp_synq_no_recent_overflow, cookie_check, NET_INC_STATS_BH, sock_net, memset, tcp_parse_options, cookie_check_timestamp, inet_reqsk_alloc, ip_hdr, kmalloc, ip_options_echo, kfree, security_inet_conn_request, reqsk_free, flowi4_init_output, security_req_classify_flow, ip_route_output_key, tcp_select_initial_window, get_cookie_sock]\n\n2. 函数名: tcp_sk\n- 参数: [sk]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n3. 函数名: tcp_hdr\n- 参数: [skb]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n4. 函数名: ntohl\n- 参数: [th->ack_seq]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n5. 函数名: tcp_synq_no_recent_overflow\n- 参数: [sk]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n6. 函数名: cookie_check\n- 参数: [skb, cookie]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n7. 函数名: NET_INC_STATS_BH\n- 参数: [sock_net(sk), LINUX_MIB_SYNCOOKIESFAILED/LINUX_MIB_SYNCOOKIESRECV]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n8. 函数名: sock_net\n- 参数: [sk]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n9. 函数名: memset\n- 参数: [&tcp_opt, 0, sizeof(tcp_opt)]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n10. 函数名: tcp_parse_options\n- 参数: [skb, &tcp_opt, &hash_location, 0]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n11. 函数名: cookie_check_timestamp\n- 参数: [&tcp_opt, &ecn_ok]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n12. 函数名: inet_reqsk_alloc\n- 参数: [&tcp_request_sock_ops]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n13. 函数名: ip_hdr\n- 参数: [skb]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n14. 函数名: kmalloc\n- 参数: [opt_size, GFP_ATOMIC]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n15. 函数名: ip_options_echo\n- 参数: [ireq->opt, skb]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n16. 函数名: kfree\n- 参数: [ireq->opt]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n17. 函数名: security_inet_conn_request\n- 参数: [sk, skb, req]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n18. 函数名: reqsk_free\n- 参数: [req]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n19. 函数名: flowi4_init_output\n- 参数: [&fl4, 0, sk->sk_mark, RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE, IPPROTO_TCP, inet_sk_flowi_flags(sk), (opt && opt->srr) ? opt->faddr : ireq->rmt_addr, ireq->loc_addr, th->source, th->dest]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n20. 函数名: security_req_classify_flow\n- 参数: [req, flowi4_to_flowi(&fl4)]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n21. 函数名: ip_route_output_key\n- 参数: [sock_net(sk), &fl4]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n22. 函数名: tcp_select_initial_window\n- 参数: [tcp_full_space(sk), req->mss, &req->rcv_wnd, &req->window_clamp, ireq->wscale_ok, &rcv_wscale, dst_metric(&rt->dst, RTAX_INITRWND)]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示\n\n23. 函数名: get_cookie_sock\n- 参数: [sk, skb, req, &rt->dst]\n- 调用者: cookie_v4_check\n- 被调用者: 未显示"
    },
    {
        "id": 89,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"保存并复制传入网络数据包的IP选项，以便后续处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送数据包导致slab损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: tcp_v4_save_options\n- 参数: [struct sock *sk, struct sk_buff *skb]\n- 调用者: 未显示（由内核网络协议栈调用）\n- 被调用者: [kmalloc, ip_options_echo, kfree]\n\n2. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: tcp_v4_save_options\n- 被调用者: []\n\n3. 函数名: ip_options_echo\n- 参数: [struct ip_options *dopt, struct sk_buff *skb]\n- 调用者: tcp_v4_save_options\n- 被调用者: []\n\n4. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: tcp_v4_save_options\n- 被调用者: []\n\n5. 函数名: optlength\n- 参数: [struct ip_options *opt]\n- 调用者: tcp_v4_save_options\n- 被调用者: []"
    },
    {
        "id": 90,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"实现TCP/IPv4连接的建立过程，包括路由查找、状态设置和连接初始化\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送数据包导致slab损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: tcp_v4_connect\n- 参数: [struct sock *sk, struct sockaddr *uaddr, int addr_len]\n- 调用者: N/A (系统调用或内核其他模块)\n- 被调用者: [inet_sk, tcp_sk, ip_route_connect, IP_INC_STATS_BH, sock_net, ip_rt_put, rt_get_peer, inet_peer_refcheck, get_seconds, inet_csk, tcp_set_state, inet_hash_connect, ip_route_newports, sk_setup_caps, secure_tcp_sequence_number, tcp_connect]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n3. 函数名: tcp_sk\n- 参数: [struct sock *sk]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n4. 函数名: ip_route_connect\n- 参数: [struct flowi4 *fl4, __be32 nexthop, __be32 saddr, unsigned int flags, int bound_dev_if, u8 protocol, __be16 sport, __be16 dport, struct sock *sk, bool no_sport]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n5. 函数名: IP_INC_STATS_BH\n- 参数: [struct net *net, int field]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n6. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n7. 函数名: ip_rt_put\n- 参数: [struct rtable *rt]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n8. 函数名: rt_get_peer\n- 参数: [struct rtable *rt]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n9. 函数名: inet_peer_refcheck\n- 参数: [struct inet_peer *peer]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n10. 函数名: get_seconds\n- 参数: []\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n11. 函数名: inet_csk\n- 参数: [struct sock *sk]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n12. 函数名: tcp_set_state\n- 参数: [struct sock *sk, int state]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n13. 函数名: inet_hash_connect\n- 参数: [struct inet_timewait_death_row *death_row, struct sock *sk]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n14. 函数名: ip_route_newports\n- 参数: [struct flowi4 *fl4, struct rtable *rt, __be16 orig_sport, __be16 orig_dport, __be16 sport, __be16 dport, struct sock *sk]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n15. 函数名: sk_setup_caps\n- 参数: [struct sock *sk, struct dst_entry *dst]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n16. 函数名: secure_tcp_sequence_number\n- 参数: [__be32 saddr, __be32 daddr, __be16 sport, __be16 dport]\n- 调用者: tcp_v4_connect\n- 被调用者: []\n\n17. 函数名: tcp_connect\n- 参数: [struct sock *sk]\n- 调用者: tcp_v4_connect\n- 被调用者: []"
    },
    {
        "id": 91,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"处理TCP IPv4连接请求并创建新的子套接字\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理网络流量时，应用程序设置套接字选项的过程中存在竞态条件，可能导致slab损坏和系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: tcp_v4_syn_recv_sock\n- 参数: [sk, skb, req, dst]\n- 调用者: 未显示（由TCP/IP协议栈调用）\n- 被调用者: [sk_acceptq_is_full, inet_csk_route_req, tcp_create_openreq_child, sk_setup_caps, tcp_sk, inet_sk, inet_rsk, ip_hdr, inet_csk, tcp_mtup_init, tcp_sync_mss, dst_mtu, dst_metric_advmss, tcp_initialize_rcv_mss, tcp_v4_md5_do_lookup, kmemdup, tcp_v4_md5_do_add, sk_nocaps_add, __inet_inherit_port, sock_put, dst_release, __inet_hash_nolisten, NET_INC_STATS_BH]\n\n2. 函数名: sk_acceptq_is_full\n- 参数: [sk]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n3. 函数名: inet_csk_route_req\n- 参数: [sk, req]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n4. 函数名: tcp_create_openreq_child\n- 参数: [sk, req, skb]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n5. 函数名: sk_setup_caps\n- 参数: [newsk, dst]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n6. 函数名: tcp_sk\n- 参数: [newsk]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n7. 函数名: inet_sk\n- 参数: [newsk]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n8. 函数名: inet_rsk\n- 参数: [req]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n9. 函数名: ip_hdr\n- 参数: [skb]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n10. 函数名: tcp_mtup_init\n- 参数: [newsk]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n11. 函数名: tcp_sync_mss\n- 参数: [newsk, dst_mtu(dst)]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n12. 函数名: dst_mtu\n- 参数: [dst]\n- 调用者: tcp_sync_mss\n- 被调用者: []\n\n13. 函数名: dst_metric_advmss\n- 参数: [dst]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n14. 函数名: tcp_initialize_rcv_mss\n- 参数: [newsk]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n15. 函数名: tcp_v4_md5_do_lookup\n- 参数: [sk, newinet->inet_daddr]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n16. 函数名: kmemdup\n- 参数: [key->key, key->keylen, GFP_ATOMIC]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n17. 函数名: tcp_v4_md5_do_add\n- 参数: [newsk, newinet->inet_daddr, newkey, key->keylen]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n18. 函数名: sk_nocaps_add\n- 参数: [newsk, NETIF_F_GSO_MASK]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n19. 函数名: __inet_inherit_port\n- 参数: [sk, newsk]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n20. 函数名: sock_put\n- 参数: [newsk]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n21. 函数名: dst_release\n- 参数: [dst]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n22. 函数名: __inet_hash_nolisten\n- 参数: [newsk, NULL]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n23. 函数名: NET_INC_STATS_BH\n- 参数: [sock_net(sk), LINUX_MIB_LISTENOVERFLOWS] 和 [sock_net(sk), LINUX_MIB_LISTENDROPS]\n- 调用者: tcp_v4_syn_recv_sock\n- 被调用者: []\n\n24. 函数名: sock_net\n- 参数: [sk]\n- 调用者: NET_INC_STATS_BH\n- 被调用者: []"
    },
    {
        "id": 92,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中UDP协议的发送消息功能，包括处理消息地址、路由选择、数据包构建和发送等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在3.0版本前的IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送数据包导致slab损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: udp_sendmsg\n- 参数: [struct kiocb *iocb, struct sock *sk, struct msghdr *msg, size_t len]\n- 调用者: 无（系统调用）\n- 被调用者: [inet_sk, udp_sk, lock_sock, release_sock, sock_tx_timestamp, ip_cmsg_send, sock_net, ip_route_output_flow, security_sk_classify_flow, ip_make_skb, udp_send_skb, ip_append_data, udp_flush_pending_frames, udp_push_pending_frames, ip_rt_put, kfree, dst_confirm]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n3. 函数名: udp_sk\n- 参数: [struct sock *sk]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n4. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n5. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n6. 函数名: sock_tx_timestamp\n- 参数: [struct sock *sk, u32 *tx_flags]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n7. 函数名: ip_cmsg_send\n- 参数: [struct net *net, struct msghdr *msg, struct ipcm_cookie *ipc]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n8. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n9. 函数名: ip_route_output_flow\n- 参数: [struct net *net, struct flowi4 *flp, struct sock *sk]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n10. 函数名: security_sk_classify_flow\n- 参数: [struct sock *sk, struct flowi *fl]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n11. 函数名: ip_make_skb\n- 参数: [struct sock *sk, int (*getfrag)(...), struct iovec *iov, unsigned int len, unsigned int transhdrlen, struct ipcm_cookie *ipc, struct rtable **rtp, unsigned int flags]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n12. 函数名: udp_send_skb\n- 参数: [struct sk_buff *skb, __be32 daddr, __be16 dport]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n13. 函数名: ip_append_data\n- 参数: [struct sock *sk, int (*getfrag)(...), struct iovec *iov, int len, int transhdrlen, struct ipcm_cookie *ipc, struct rtable **rt, unsigned int flags]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n14. 函数名: udp_flush_pending_frames\n- 参数: [struct sock *sk]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n15. 函数名: udp_push_pending_frames\n- 参数: [struct sock *sk]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n16. 函数名: ip_rt_put\n- 参数: [struct rtable *rt]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n17. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: udp_sendmsg\n- 被调用者: 无\n\n18. 函数名: dst_confirm\n- 参数: [struct dst_entry *dst]\n- 调用者: udp_sendmsg\n- 被调用者: 无"
    },
    {
        "id": 93,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"处理IPv6 TCP连接的同步接收套接字创建，包括IPv4映射地址的处理和套接字选项的继承\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，远程攻击者可能通过发送数据包导致slab损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: tcp_v6_syn_recv_sock\n- 参数: [sk, skb, req, dst]\n- 调用者: 未显示（由内核TCP/IP协议栈调用）\n- 被调用者: [tcp_v4_syn_recv_sock, inet6_sk, inet_sk, tcp_sk, memcpy, ipv6_addr_set_v4mapped, ipv6_addr_copy, inet_csk, tcp_v4_do_rcv, tcp_sync_mss, inet6_rsk, sk_acceptq_is_full, inet6_csk_route_req, tcp_create_openreq_child, __ip6_dst_store, skb_clone, kfree_skb, skb_set_owner_r, ipv6_dup_options, sock_kfree_s, tcp_mtup_init, dst_mtu, dst_metric_advmss, tcp_initialize_rcv_mss, tcp_v6_md5_do_lookup, kmemdup, tcp_v6_md5_do_add, __inet_inherit_port, sock_put, __inet6_hash, NET_INC_STATS_BH, dst_release]\n\n2. 函数名: tcp_v4_syn_recv_sock\n- 参数: [sk, skb, req, dst]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n3. 函数名: inet6_sk\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n4. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n5. 函数名: tcp_sk\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n6. 函数名: memcpy\n- 参数: [dest, src, n]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n7. 函数名: ipv6_addr_set_v4mapped\n- 参数: [addr, v4mapped]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n8. 函数名: ipv6_addr_copy\n- 参数: [dst, src]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n9. 函数名: inet_csk\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n10. 函数名: tcp_v4_do_rcv\n- 参数: [sk, skb]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n11. 函数名: tcp_sync_mss\n- 参数: [sk, pmtu]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n12. 函数名: inet6_rsk\n- 参数: [req]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n13. 函数名: sk_acceptq_is_full\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n14. 函数名: inet6_csk_route_req\n- 参数: [sk, req]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n15. 函数名: tcp_create_openreq_child\n- 参数: [sk, req, skb]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n16. 函数名: __ip6_dst_store\n- 参数: [sk, dst, saddr, daddr]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n17. 函数名: skb_clone\n- 参数: [skb, gfp_mask]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n18. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n19. 函数名: skb_set_owner_r\n- 参数: [skb, sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n20. 函数名: ipv6_dup_options\n- 参数: [sk, opt]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n21. 函数名: sock_kfree_s\n- 参数: [sk, mem, size]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n22. 函数名: tcp_mtup_init\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n23. 函数名: dst_mtu\n- 参数: [dst]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n24. 函数名: dst_metric_advmss\n- 参数: [dst]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n25. 函数名: tcp_initialize_rcv_mss\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n26. 函数名: tcp_v6_md5_do_lookup\n- 参数: [sk, addr]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n27. 函数名: kmemdup\n- 参数: [src, len, gfp]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n28. 函数名: tcp_v6_md5_do_add\n- 参数: [sk, addr, newkey, keylen]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n29. 函数名: __inet_inherit_port\n- 参数: [sk, newsk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n30. 函数名: sock_put\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n31. 函数名: __inet6_hash\n- 参数: [sk, NULL]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n32. 函数名: NET_INC_STATS_BH\n- 参数: [sock_net(sk), LINUX_MIB_LISTENOVERFLOWS/LINUX_MIB_LISTENDROPS]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n33. 函数名: dst_release\n- 参数: [dst]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示"
    },
    {
        "id": 94,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "purpose": "Code purpose:\"\"\"该代码实现了L2TP/IP协议中发送消息的功能，包括处理目标地址、分配套接字缓冲区、填充数据并通过IP层发送数据包。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IP实现中存在竞态条件，当应用程序在处理网络流量时设置套接字选项，可能导致远程攻击者通过发送数据包造成slab损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: l2tp_ip_sendmsg\n- 参数: [struct kiocb *iocb, struct sock *sk, struct msghdr *msg, size_t len]\n- 调用者: 未显示（内核网络栈调用）\n- 被调用者: [l2tp_ip_sk, inet_sk, sock_flag, sock_wmalloc, skb_reserve, skb_reset_network_header, skb_reset_transport_header, skb_put, memcpy_fromiovec, kfree_skb, __sk_dst_check, ip_route_output_ports, sk_setup_caps, dst_clone, skb_dst_set, ip_queue_xmit, IP_INC_STATS]\n\n2. 函数名: l2tp_ip_sk\n- 参数: [struct sock *sk]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n3. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n4. 函数名: sock_flag\n- 参数: [struct sock *sk, int flag]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n5. 函数名: sock_wmalloc\n- 参数: [struct sock *sk, int size, int force, gfp_t priority]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n6. 函数名: skb_reserve\n- 参数: [struct sk_buff *skb, int len]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n7. 函数名: skb_reset_network_header\n- 参数: [struct sk_buff *skb]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n8. 函数名: skb_reset_transport_header\n- 参数: [struct sk_buff *skb]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n9. 函数名: skb_put\n- 参数: [struct sk_buff *skb, unsigned int len]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n10. 函数名: memcpy_fromiovec\n- 参数: [void *kdata, struct iovec *iov, int len]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n11. 函数名: kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n12. 函数名: __sk_dst_check\n- 参数: [struct sock *sk, u32 cookie]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n13. 函数名: ip_route_output_ports\n- 参数: [struct net *net, struct sock *sk, __be32 daddr, __be32 saddr, __be16 dport, __be16 sport, u8 proto, u32 flags, int oif]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n14. 函数名: sk_setup_caps\n- 参数: [struct sock *sk, struct dst_entry *dst]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n15. 函数名: dst_clone\n- 参数: [struct dst_entry *dst]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n16. 函数名: skb_dst_set\n- 参数: [struct sk_buff *skb, struct dst_entry *dst]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n17. 函数名: ip_queue_xmit\n- 参数: [struct sk_buff *skb]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []\n\n18. 函数名: IP_INC_STATS\n- 参数: [struct net *net, int field]\n- 调用者: l2tp_ip_sendmsg\n- 被调用者: []"
    },
    {
        "id": 106,
        "cwe": "CWE-362",
        "cve": "CVE-2012-4508",
        "purpose": "Code purpose:\"\"\"该代码用于处理ext4文件系统中扩展区间的分割操作，确保文件数据在修改时能正确维护扩展的分配和初始化状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确标记未初始化的extent，导致在竞争条件下可以读取已删除文件的敏感信息\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_split_extent\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_ext_path *path, struct ext4_map_blocks *map, int split_flag, int flags]\n- 调用者: N/A\n- 被调用者: [ext_depth, le32_to_cpu, ext4_ext_get_actual_len, ext4_ext_is_uninitialized, ext4_split_extent_at, ext4_ext_drop_refs, ext4_ext_find_extent, IS_ERR, PTR_ERR, ext4_ext_show_leaf]\n\n2. 函数名: ext_depth\n- 参数: [struct inode *inode]\n- 调用者: ext4_split_extent\n- 被调用者: N/A\n\n3. 函数名: le32_to_cpu\n- 参数: [__le32]\n- 调用者: ext4_split_extent\n- 被调用者: N/A\n\n4. 函数名: ext4_ext_get_actual_len\n- 参数: [struct ext4_extent *ex]\n- 调用者: ext4_split_extent\n- 被调用者: N/A\n\n5. 函数名: ext4_ext_is_uninitialized\n- 参数: [struct ext4_extent *ex]\n- 调用者: ext4_split_extent\n- 被调用者: N/A\n\n6. 函数名: ext4_split_extent_at\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_ext_path *path, ext4_lblk_t lblk, int split_flag, int flags]\n- 调用者: ext4_split_extent\n- 被调用者: N/A\n\n7. 函数名: ext4_ext_drop_refs\n- 参数: [struct ext4_ext_path *path]\n- 调用者: ext4_split_extent\n- 被调用者: N/A\n\n8. 函数名: ext4_ext_find_extent\n- 参数: [struct inode *inode, ext4_lblk_t lblk, struct ext4_ext_path *path]\n- 调用者: ext4_split_extent\n- 被调用者: N/A\n\n9. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: ext4_split_extent\n- 被调用者: N/A\n\n10. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: ext4_split_extent\n- 被调用者: N/A\n\n11. 函数名: ext4_ext_show_leaf\n- 参数: [struct inode *inode, struct ext4_ext_path *path]\n- 调用者: ext4_split_extent\n- 被调用者: N/A"
    },
    {
        "id": 107,
        "cwe": "CWE-362",
        "cve": "CVE-2012-4508",
        "purpose": "Code purpose:\"\"\"该代码用于在ext4文件系统中处理文件扩展的分割操作，包括标记未初始化状态、合并扩展块以及在错误情况下恢复原始扩展长度。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4文件系统中处理extent分割时，未能正确标记未初始化的extent，导致竞态条件下可能泄露已删除文件的敏感信息\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_split_extent_at\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_ext_path *path, ext4_lblk_t split, int split_flag, int flags]\n- 调用者: N/A (top-level function)\n- 被调用者: [ext4_ext_show_leaf, ext_depth, ext4_ext_get_actual_len, ext4_ext_get_access, ext4_ext_mark_uninitialized, ext4_ext_mark_initialized, ext4_ext_try_to_merge, ext4_ext_dirty, memcpy, ext4_ext_insert_extent, ext4_ext_zeroout]\n\n2. 函数名: ext4_ext_show_leaf\n- 参数: [struct inode *inode, struct ext4_ext_path *path]\n- 调用者: ext4_split_extent_at\n- 被调用者: []\n\n3. 函数名: ext_depth\n- 参数: [struct inode *inode]\n- 调用者: ext4_split_extent_at\n- 被调用者: []\n\n4. 函数名: ext4_ext_get_actual_len\n- 参数: [struct ext4_extent *ex]\n- 调用者: ext4_split_extent_at\n- 被调用者: []\n\n5. 函数名: ext4_ext_get_access\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_ext_path *path]\n- 调用者: ext4_split_extent_at\n- 被调用者: []\n\n6. 函数名: ext4_ext_mark_uninitialized\n- 参数: [struct ext4_extent *ex]\n- 调用者: ext4_split_extent_at\n- 被调用者: []\n\n7. 函数名: ext4_ext_mark_initialized\n- 参数: [struct ext4_extent *ex]\n- 调用者: ext4_split_extent_at\n- 被调用者: []\n\n8. 函数名: ext4_ext_try_to_merge\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_ext_path *path, struct ext4_extent *ex]\n- 调用者: ext4_split_extent_at\n- 被调用者: []\n\n9. 函数名: ext4_ext_dirty\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_ext_path *path]\n- 调用者: ext4_split_extent_at\n- 被调用者: []\n\n10. 函数名: ext4_ext_insert_extent\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_ext_path *path, struct ext4_extent *newex, int flags]\n- 调用者: ext4_split_extent_at\n- 被调用者: []\n\n11. 函数名: ext4_ext_zeroout\n- 参数: [struct inode *inode, struct ext4_extent *orig_ex]\n- 调用者: ext4_split_extent_at\n- 被调用者: []"
    },
    {
        "id": 108,
        "cwe": "CWE-362",
        "cve": "CVE-2012-4508",
        "purpose": "Code purpose:\"\"\"处理ext4文件系统中未初始化区间的分配、转换和映射操作，包括处理预IO、转换已填充区间为写入状态以及缓冲IO等情况\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在ext4文件系统中处理未初始化extent时存在竞态条件，未能正确标记已删除文件的extent为未初始化状态，导致本地用户可读取敏感信息\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_ext_handle_uninitialized_extents\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_map_blocks *map, struct ext4_ext_path *path, int flags, unsigned int allocated, ext4_fsblk_t newblock]\n- 调用者: N/A (顶层函数)\n- 被调用者: [ext4_inode_aio, ext_debug, ext4_ext_show_leaf, trace_ext4_ext_handle_uninitialized_extents, ext4_split_unwritten_extents, ext4_set_io_unwritten_flag, ext4_set_inode_state, ext4_should_dioread_nolock, ext4_convert_unwritten_extents_endio, ext4_update_inode_fsync_trans, check_eofblocks_fl, ext4_ext_convert_to_initialized, unmap_underlying_metadata_blocks, get_reserved_cluster_alloc, ext4_da_update_reserve_space, ext4_ext_drop_refs, kfree]\n\n2. 函数名: ext4_inode_aio\n- 参数: [struct inode *inode]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n3. 函数名: ext_debug\n- 参数: [const char *fmt, ...]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n4. 函数名: ext4_ext_show_leaf\n- 参数: [struct inode *inode, struct ext4_ext_path *path]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n5. 函数名: trace_ext4_ext_handle_uninitialized_extents\n- 参数: [struct inode *inode, struct ext4_map_blocks *map, unsigned int allocated, ext4_fsblk_t newblock]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n6. 函数名: ext4_split_unwritten_extents\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_map_blocks *map, struct ext4_ext_path *path, int flags]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n7. 函数名: ext4_set_io_unwritten_flag\n- 参数: [struct inode *inode, ext4_io_end_t *io]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n8. 函数名: ext4_set_inode_state\n- 参数: [struct inode *inode, unsigned int state]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n9. 函数名: ext4_should_dioread_nolock\n- 参数: [struct inode *inode]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n10. 函数名: ext4_convert_unwritten_extents_endio\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_ext_path *path]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n11. 函数名: ext4_update_inode_fsync_trans\n- 参数: [handle_t *handle, struct inode *inode, int update_tx]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n12. 函数名: check_eofblocks_fl\n- 参数: [handle_t *handle, struct inode *inode, ext4_lblk_t lblk, struct ext4_ext_path *path, unsigned int len]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n13. 函数名: ext4_ext_convert_to_initialized\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_map_blocks *map, struct ext4_ext_path *path]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n14. 函数名: unmap_underlying_metadata_blocks\n- 参数: [struct block_device *bdev, sector_t block, unsigned int count]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n15. 函数名: get_reserved_cluster_alloc\n- 参数: [struct inode *inode, ext4_lblk_t lblk, unsigned int len]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n16. 函数名: ext4_da_update_reserve_space\n- 参数: [struct inode *inode, int reserved_clusters, int used_clusters]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n17. 函数名: ext4_ext_drop_refs\n- 参数: [struct ext4_ext_path *path]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A\n\n18. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: ext4_ext_handle_uninitialized_extents\n- 被调用者: N/A"
    },
    {
        "id": 109,
        "cwe": "CWE-362",
        "cve": "CVE-2012-4508",
        "purpose": "Code purpose:\"\"\"处理未初始化extent的分割操作，确保在文件大小范围内正确标记和转换extent状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确标记未初始化的extent，导致在竞争条件下可以读取已删除文件的敏感信息\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_split_unwritten_extents\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_map_blocks *map, struct ext4_ext_path *path, int flags]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [ext_depth, le32_to_cpu, ext4_ext_get_actual_len, ext4_split_extent]\n\n2. 函数名: ext_depth\n- 参数: [struct inode *inode]\n- 调用者: ext4_split_unwritten_extents\n- 被调用者: 未显示\n\n3. 函数名: le32_to_cpu\n- 参数: [未显示（参数应为32位小端值）]\n- 调用者: ext4_split_unwritten_extents\n- 被调用者: 未显示\n\n4. 函数名: ext4_ext_get_actual_len\n- 参数: [struct ext4_extent *ex]\n- 调用者: ext4_split_unwritten_extents\n- 被调用者: 未显示\n\n5. 函数名: ext4_split_extent\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_ext_path *path, struct ext4_map_blocks *map, int split_flag, int flags]\n- 调用者: ext4_split_unwritten_extents\n- 被调用者: 未显示"
    },
    {
        "id": 162,
        "cwe": "CWE-362",
        "cve": "CVE-2013-0871",
        "purpose": "Code purpose:\"\"\"实现Linux内核中ptrace系统调用的功能，用于进程间调试和控制，包括读取/写入内存、获取/设置寄存器、控制子进程执行等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核ptrace功能中存在竞争条件，允许本地用户通过精心构造的PTRACE_SETREGS系统调用在进程跟踪期间获取特权。\"\"\"",
        "functions": "Functions:\n1. 函数名: ptrace_request\n- 参数: [struct task_struct *child, long request, unsigned long addr, unsigned long data]\n- 调用者: 无（系统调用入口）\n- 被调用者: [generic_ptrace_peekdata, generic_ptrace_pokedata, ptrace_setoptions, put_user, ptrace_getsiginfo, copy_siginfo_to_user, copy_from_user, ptrace_setsiginfo, lock_task_sighand, task_set_jobctl_pending, signal_wake_up, unlock_task_sighand, ptrace_detach, get_task_mm, mmput, ptrace_resume, access_ok, __get_user, ptrace_regset, __put_user]\n\n2. 函数名: generic_ptrace_peekdata\n- 参数: [struct task_struct *child, unsigned long addr, unsigned long data]\n- 调用者: ptrace_request\n- 被调用者: []\n\n3. 函数名: generic_ptrace_pokedata\n- 参数: [struct task_struct *child, unsigned long addr, unsigned long data]\n- 调用者: ptrace_request\n- 被调用者: []\n\n4. 函数名: ptrace_setoptions\n- 参数: [struct task_struct *child, unsigned long data]\n- 调用者: ptrace_request\n- 被调用者: []\n\n5. 函数名: put_user\n- 参数: [unsigned long x, unsigned long __user *ptr]\n- 调用者: ptrace_request\n- 被调用者: []\n\n6. 函数名: ptrace_getsiginfo\n- 参数: [struct task_struct *child, siginfo_t *siginfo]\n- 调用者: ptrace_request\n- 被调用者: []\n\n7. 函数名: copy_siginfo_to_user\n- 参数: [void __user *datavp, siginfo_t *siginfo]\n- 调用者: ptrace_request\n- 被调用者: []\n\n8. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: ptrace_request\n- 被调用者: []\n\n9. 函数名: ptrace_setsiginfo\n- 参数: [struct task_struct *child, siginfo_t *siginfo]\n- 调用者: ptrace_request\n- 被调用者: []\n\n10. 函数名: lock_task_sighand\n- 参数: [struct task_struct *tsk, unsigned long *flags]\n- 调用者: ptrace_request\n- 被调用者: []\n\n11. 函数名: task_set_jobctl_pending\n- 参数: [struct task_struct *task, unsigned int mask]\n- 调用者: ptrace_request\n- 被调用者: []\n\n12. 函数名: signal_wake_up\n- 参数: [struct task_struct *t, bool resume]\n- 调用者: ptrace_request\n- 被调用者: []\n\n13. 函数名: unlock_task_sighand\n- 参数: [struct task_struct *tsk, unsigned long *flags]\n- 调用者: ptrace_request\n- 被调用者: []\n\n14. 函数名: ptrace_detach\n- 参数: [struct task_struct *child, unsigned long data]\n- 调用者: ptrace_request\n- 被调用者: []\n\n15. 函数名: get_task_mm\n- 参数: [struct task_struct *task]\n- 调用者: ptrace_request\n- 被调用者: []\n\n16. 函数名: mmput\n- 参数: [struct mm_struct *mm]\n- 调用者: ptrace_request\n- 被调用者: []\n\n17. 函数名: ptrace_resume\n- 参数: [struct task_struct *child, long request, unsigned long data]\n- 调用者: ptrace_request\n- 被调用者: []\n\n18. 函数名: access_ok\n- 参数: [int type, const void __user *addr, unsigned long size]\n- 调用者: ptrace_request\n- 被调用者: []\n\n19. 函数名: __get_user\n- 参数: [x, ptr]\n- 调用者: ptrace_request\n- 被调用者: []\n\n20. 函数名: ptrace_regset\n- 参数: [struct task_struct *child, int request, unsigned int addr, struct iovec *kiov]\n- 调用者: ptrace_request\n- 被调用者: []\n\n21. 函数名: __put_user\n- 参数: [x, ptr]\n- 调用者: ptrace_request\n- 被调用者: []"
    },
    {
        "id": 163,
        "cwe": "CWE-362",
        "cve": "CVE-2013-0871",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理进程跟踪(ptrace)的解除链接操作，包括清理跟踪状态、恢复父进程关系和处理任务停止信号。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ptrace_unlink函数中存在竞争条件，当PTRACE_SETREGS系统调用在特定时机执行时，可能导致权限提升漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: __ptrace_unlink\n- 参数: [struct task_struct *child]\n- 调用者: 未明确显示（通常是内核中的ptrace相关函数）\n- 被调用者: [BUG_ON, list_del_init, spin_lock, task_clear_jobctl_pending, task_clear_jobctl_trapping, spin_unlock, signal_wake_up]\n\n2. 函数名: BUG_ON\n- 参数: [!child->ptrace]\n- 调用者: __ptrace_unlink\n- 被调用者: []\n\n3. 函数名: list_del_init\n- 参数: [&child->ptrace_entry]\n- 调用者: __ptrace_unlink\n- 被调用者: []\n\n4. 函数名: spin_lock\n- 参数: [&child->sighand->siglock]\n- 调用者: __ptrace_unlink\n- 被调用者: []\n\n5. 函数名: task_clear_jobctl_pending\n- 参数: [child, JOBCTL_TRAP_MASK]\n- 调用者: __ptrace_unlink\n- 被调用者: []\n\n6. 函数名: task_clear_jobctl_trapping\n- 参数: [child]\n- 调用者: __ptrace_unlink\n- 被调用者: []\n\n7. 函数名: spin_unlock\n- 参数: [&child->sighand->siglock]\n- 调用者: __ptrace_unlink\n- 被调用者: []\n\n8. 函数名: signal_wake_up\n- 参数: [child, task_is_traced(child)]\n- 调用者: __ptrace_unlink\n- 被调用者: []\n\n9. 函数名: task_is_traced\n- 参数: [child]\n- 调用者: signal_wake_up\n- 被调用者: []"
    },
    {
        "id": 164,
        "cwe": "CWE-362",
        "cve": "CVE-2013-0871",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中ptrace系统调用的附加(attach)功能，用于允许一个进程跟踪和控制另一个进程的执行状态。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核ptrace功能中存在竞争条件，允许本地用户通过精心构造的PTRACE_SETREGS系统调用在进程跟踪过程中获取特权。\"\"\"",
        "functions": "Functions:\n1. 函数名: ptrace_attach\n- 参数: [struct task_struct *task, long request, unsigned long addr, unsigned long flags]\n- 调用者: N/A (kernel-level function)\n- 被调用者: [audit_ptrace, same_thread_group, mutex_lock_interruptible, __ptrace_may_access, ns_capable, __ptrace_link, send_sig_info, task_is_stopped, task_set_jobctl_pending, signal_wake_up, wait_on_bit, proc_ptrace_connector]\n\n2. 函数名: audit_ptrace\n- 参数: [struct task_struct *task]\n- 调用者: ptrace_attach\n- 被调用者: []\n\n3. 函数名: same_thread_group\n- 参数: [struct task_struct *task, struct task_struct *current]\n- 调用者: ptrace_attach\n- 被调用者: []\n\n4. 函数名: mutex_lock_interruptible\n- 参数: [struct mutex *task->signal->cred_guard_mutex]\n- 调用者: ptrace_attach\n- 被调用者: []\n\n5. 函数名: __ptrace_may_access\n- 参数: [struct task_struct *task, PTRACE_MODE_ATTACH]\n- 调用者: ptrace_attach\n- 被调用者: []\n\n6. 函数名: ns_capable\n- 参数: [__task_cred(task)->user_ns, CAP_SYS_PTRACE]\n- 调用者: ptrace_attach\n- 被调用者: []\n\n7. 函数名: __ptrace_link\n- 参数: [struct task_struct *task, struct task_struct *current]\n- 调用者: ptrace_attach\n- 被调用者: []\n\n8. 函数名: send_sig_info\n- 参数: [SIGSTOP, SEND_SIG_FORCED, task]\n- 调用者: ptrace_attach\n- 被调用者: []\n\n9. 函数名: task_is_stopped\n- 参数: [struct task_struct *task]\n- 调用者: ptrace_attach\n- 被调用者: []\n\n10. 函数名: task_set_jobctl_pending\n- 参数: [struct task_struct *task, JOBCTL_TRAP_STOP | JOBCTL_TRAPPING]\n- 调用者: ptrace_attach\n- 被调用者: []\n\n11. 函数名: signal_wake_up\n- 参数: [struct task_struct *task, 1]\n- 调用者: ptrace_attach\n- 被调用者: []\n\n12. 函数名: wait_on_bit\n- 参数: [&task->jobctl, JOBCTL_TRAPPING_BIT, ptrace_trapping_sleep_fn, TASK_UNINTERRUPTIBLE]\n- 调用者: ptrace_attach\n- 被调用者: []\n\n13. 函数名: proc_ptrace_connector\n- 参数: [struct task_struct *task, PTRACE_ATTACH]\n- 调用者: ptrace_attach\n- 被调用者: []"
    },
    {
        "id": 165,
        "cwe": "CWE-362",
        "cve": "CVE-2013-0871",
        "purpose": "Code purpose:\"\"\"该代码用于在ptrace调试过程中处理被调试进程的陷阱通知，通过设置任务控制标志和唤醒信号来实现调试器与被调试进程间的同步\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在ptrace功能中存在竞争条件，允许本地用户通过精心设计的PTRACE_SETREGS系统调用在错误时机修改寄存器状态，从而提升权限\"\"\"",
        "functions": "Functions:\n1. 函数名: ptrace_trap_notify\n- 参数: [struct task_struct *t]\n- 调用者: 不适用（未在代码片段中显示）\n- 被调用者: [WARN_ON_ONCE, assert_spin_locked, task_set_jobctl_pending, signal_wake_up]\n\n2. 函数名: WARN_ON_ONCE\n- 参数: [! (t->ptrace & PT_SEIZED)]\n- 调用者: ptrace_trap_notify\n- 被调用者: []\n\n3. 函数名: assert_spin_locked\n- 参数: [&t->sighand->siglock]\n- 调用者: ptrace_trap_notify\n- 被调用者: []\n\n4. 函数名: task_set_jobctl_pending\n- 参数: [t, JOBCTL_TRAP_NOTIFY]\n- 调用者: ptrace_trap_notify\n- 被调用者: []\n\n5. 函数名: signal_wake_up\n- 参数: [t, t->jobctl & JOBCTL_LISTENING]\n- 调用者: ptrace_trap_notify\n- 被调用者: []"
    },
    {
        "id": 184,
        "cwe": "CWE-362",
        "cve": "CVE-2013-1792",
        "purpose": "Code purpose:\"\"\"该代码用于为Linux系统中的用户安装UID特定的密钥环和会话密钥环，以管理用户的密钥权限和会话安全。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在多线程环境下，install_user_keyrings函数未正确处理用户密钥环的并发创建和访问，导致竞态条件下可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: install_user_keyrings\n- 参数: []\n- 调用者: \n- 被调用者: [current_cred, from_kuid, kenter, kleave, mutex_lock, sprintf, find_keyring_by_name, keyring_alloc, IS_ERR, PTR_ERR, key_link, key_put, mutex_unlock]\n\n2. 函数名: current_cred\n- 参数: []\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n3. 函数名: from_kuid\n- 参数: [cred->user_ns, user->uid]\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n4. 函数名: kenter\n- 参数: [\"%p{%u}\", user, uid]\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n5. 函数名: kleave\n- 参数: [\" = 0 [exist]\"] 和 [\" = %d\", ret]\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n6. 函数名: mutex_lock\n- 参数: [&key_user_keyring_mutex]\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n7. 函数名: sprintf\n- 参数: [buf, \"_uid.%u\", uid] 和 [buf, \"_uid_ses.%u\", uid]\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n8. 函数名: find_keyring_by_name\n- 参数: [buf, true]\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n9. 函数名: keyring_alloc\n- 参数: [buf, user->uid, INVALID_GID, cred, user_keyring_perm, KEY_ALLOC_IN_QUOTA, NULL]\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n10. 函数名: IS_ERR\n- 参数: [uid_keyring] 和 [session_keyring]\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n11. 函数名: PTR_ERR\n- 参数: [uid_keyring] 和 [session_keyring]\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n12. 函数名: key_link\n- 参数: [session_keyring, uid_keyring]\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n13. 函数名: key_put\n- 参数: [session_keyring] 和 [uid_keyring]\n- 调用者: install_user_keyrings\n- 被调用者: []\n\n14. 函数名: mutex_unlock\n- 参数: [&key_user_keyring_mutex]\n- 调用者: install_user_keyrings\n- 被调用者: []"
    },
    {
        "id": 206,
        "cwe": "CWE-362",
        "cve": "CVE-2013-1935",
        "purpose": "Code purpose:\"\"\"该代码实现了KVM虚拟化环境中虚拟机控制块(VCpu)进入客户机模式的处理流程，包括请求处理、MMU重载、模式切换、中断处理以及退出处理等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在禁用中断的时间窗口内未正确处理PV EOI特性，导致guest OS用户可通过copy_to_user调用造成host OS崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: vcpu_enter_guest\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: N/A\n- 被调用者: [irqchip_in_kernel, kvm_check_request, kvm_mmu_unload, __kvm_migrate_timers, kvm_write_guest_time, kvm_mmu_sync_roots, kvm_x86_ops->tlb_flush, kvm_x86_ops->fpu_deactivate, kvm_mmu_reload, preempt_disable, kvm_x86_ops->prepare_guest_switch, kvm_load_guest_fpu, kvm_load_guest_xcr0, atomic_set, smp_wmb, local_irq_disable, atomic_read, need_resched, signal_pending, kvm_make_request, local_irq_enable, preempt_enable, inject_pending_event, kvm_x86_ops->enable_nmi_window, kvm_cpu_has_interrupt, kvm_x86_ops->enable_irq_window, kvm_lapic_enabled, update_cr8_intercept, kvm_lapic_sync_to_vapic, srcu_read_unlock, kvm_guest_enter, set_debugreg, trace_kvm_entry, kvm_x86_ops->run, hw_breakpoint_active, hw_breakpoint_restore, kvm_get_msr, barrier, kvm_guest_exit, srcu_read_lock, profile_hit, kvm_lapic_sync_from_vapic, kvm_x86_ops->handle_exit, kvm_rip_read]\n\n2. 函数名: irqchip_in_kernel\n- 参数: [struct kvm *kvm]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n3. 函数名: kvm_check_request\n- 参数: [int req, struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n4. 函数名: kvm_mmu_unload\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n5. 函数名: __kvm_migrate_timers\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n6. 函数名: kvm_write_guest_time\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n7. 函数名: kvm_mmu_sync_roots\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n8. 函数名: kvm_mmu_reload\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n9. 函数名: kvm_make_request\n- 参数: [int req, struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n10. 函数名: inject_pending_event\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n11. 函数名: kvm_cpu_has_interrupt\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n12. 函数名: update_cr8_intercept\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n13. 函数名: kvm_lapic_sync_to_vapic\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n14. 函数名: kvm_lapic_sync_from_vapic\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A\n\n15. 函数名: kvm_rip_read\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: vcpu_enter_guest\n- 被调用者: N/A"
    },
    {
        "id": 277,
        "cwe": "CWE-362",
        "cve": "CVE-2013-3302",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中通过SMB协议发送请求到服务器，处理数据分片发送和错误恢复\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在smb_send_rqst函数中处理重新连接事件时存在竞态条件，可能导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: smb_send_rqst\n- 参数: [struct TCP_Server_Info *server, struct smb_rqst *rqst]\n- 调用者: N/A (top-level function)\n- 被调用者: [get_rfc1002_length, dump_smb, kernel_setsockopt, smb_send_kvec, cifs_rqst_page_to_kvec, kunmap]\n\n2. 函数名: get_rfc1002_length\n- 参数: [iov[0].iov_base]\n- 调用者: smb_send_rqst\n- 被调用者: N/A\n\n3. 函数名: dump_smb\n- 参数: [iov[0].iov_base, iov[0].iov_len]\n- 调用者: smb_send_rqst\n- 被调用者: N/A\n\n4. 函数名: kernel_setsockopt\n- 参数: [ssocket, SOL_TCP, TCP_CORK, (char *)&val, sizeof(val)]\n- 调用者: smb_send_rqst\n- 被调用者: N/A\n\n5. 函数名: smb_send_kvec\n- 参数: [server, iov, n_vec, &sent] and [server, &p_iov, 1, &sent]\n- 调用者: smb_send_rqst\n- 被调用者: N/A\n\n6. 函数名: cifs_rqst_page_to_kvec\n- 参数: [rqst, i, &p_iov]\n- 调用者: smb_send_rqst\n- 被调用者: N/A\n\n7. 函数名: kunmap\n- 参数: [rqst->rq_pages[i]]\n- 调用者: smb_send_rqst\n- 被调用者: N/A"
    },
    {
        "id": 278,
        "cwe": "CWE-362",
        "cve": "CVE-2013-3302",
        "purpose": "Code purpose:\"\"\"该代码实现了SMB协议中通过TCP套接字发送数据块的功能，包括处理阻塞/非阻塞发送、重试机制和错误处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在重新连接事件中，由于竞争条件导致ssocket指针可能被置为NULL，从而引发空指针解引用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: smb_send_kvec\n- 参数: [struct TCP_Server_Info *server, struct kvec *iov, size_t n_vec, size_t *sent]\n- 调用者: 未明确显示（可能是smb_send_rqst等上层函数）\n- 被调用者: [kernel_sendmsg, msleep]\n\n2. 函数名: kernel_sendmsg\n- 参数: [struct socket *ssocket, struct msghdr *smb_msg, struct kvec *iov, size_t n_vec, unsigned int remaining]\n- 调用者: smb_send_kvec\n- 被调用者: 未显示（内核底层函数）\n\n3. 函数名: msleep\n- 参数: [unsigned int msecs]\n- 调用者: smb_send_kvec\n- 被调用者: 未显示（内核调度函数）\n\n4. 函数名: WARN_ON_ONCE\n- 参数: [bool condition]\n- 调用者: smb_send_kvec\n- 被调用者: 未显示（内核调试宏）\n\n5. 函数名: cERROR\n- 参数: [int level, const char *format, ...]\n- 调用者: smb_send_kvec\n- 被调用者: 未显示（日志记录函数）"
    },
    {
        "id": 355,
        "cwe": "CWE-362",
        "cve": "CVE-2013-7026",
        "purpose": "Code purpose:\"\"\"该代码用于销毁共享内存段，包括资源计数调整、内存解锁和文件引用释放等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在共享内存操作中存在竞态条件，当使用shmctl IPC_RMID操作与其他shm系统调用同时执行时，可能导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: shm_destroy\n- 参数: [ns, shp]\n- 调用者: 未显示\n- 被调用者: [shm_rmid, shm_unlock, is_file_hugepages, shmem_lock, user_shm_unlock, file_inode, fput, ipc_rcu_putref, shm_rcu_free]\n\n2. 函数名: shm_rmid\n- 参数: [ns, shp]\n- 调用者: shm_destroy\n- 被调用者: 未显示\n\n3. 函数名: shm_unlock\n- 参数: [shp]\n- 调用者: shm_destroy\n- 被调用者: 未显示\n\n4. 函数名: is_file_hugepages\n- 参数: [shp->shm_file]\n- 调用者: shm_destroy\n- 被调用者: 未显示\n\n5. 函数名: shmem_lock\n- 参数: [shp->shm_file, 0, shp->mlock_user]\n- 调用者: shm_destroy\n- 被调用者: 未显示\n\n6. 函数名: user_shm_unlock\n- 参数: [file_inode(shp->shm_file)->i_size, shp->mlock_user]\n- 调用者: shm_destroy\n- 被调用者: 未显示\n\n7. 函数名: file_inode\n- 参数: [shp->shm_file]\n- 调用者: user_shm_unlock\n- 被调用者: 未显示\n\n8. 函数名: fput\n- 参数: [shp->shm_file]\n- 调用者: shm_destroy\n- 被调用者: 未显示\n\n9. 函数名: ipc_rcu_putref\n- 参数: [shp, shm_rcu_free]\n- 调用者: shm_destroy\n- 被调用者: [shm_rcu_free]\n\n10. 函数名: shm_rcu_free\n- 参数: 未显示\n- 调用者: ipc_rcu_putref\n- 被调用者: 未显示"
    },
    {
        "id": 356,
        "cwe": "CWE-362",
        "cve": "CVE-2013-7026",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中对共享内存区域的控制操作，包括查询状态、设置属性、锁定/解锁以及删除等功能的系统调用处理。\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核的共享内存控制(shmctl)实现中，存在多个竞态条件，当本地用户在使用IPC_RMID操作删除共享内存段的同时并发执行其他shm系统调用时，会导致释放后使用(use-after-free)问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: SYSCALL_DEFINE3(shmctl)\n- 参数: [int shmid, int cmd, struct shmid_ds __user *buf]\n- 调用者: 系统调用\n- 被调用者: [ipc_parse_version, shmctl_nolock, shmctl_down, shm_obtain_object_check, audit_ipc_obj, security_shm_shmctl, ipc_lock_object, ns_capable, current_euid, uid_eq, rlimit, is_file_hugepages, shmem_lock, get_file, ipc_unlock_object, shmem_unlock_mapping, fput]\n\n2. 函数名: ipc_parse_version\n- 参数: [int *cmd]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n3. 函数名: shmctl_nolock\n- 参数: [struct ipc_namespace *ns, int shmid, int cmd, int version, struct shmid_ds __user *buf]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n4. 函数名: shmctl_down\n- 参数: [struct ipc_namespace *ns, int shmid, int cmd, struct shmid_ds __user *buf, int version]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n5. 函数名: shm_obtain_object_check\n- 参数: [struct ipc_namespace *ns, int shmid]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n6. 函数名: audit_ipc_obj\n- 参数: [struct kern_ipc_perm *perm]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n7. 函数名: security_shm_shmctl\n- 参数: [struct shmid_kernel *shp, int cmd]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n8. 函数名: ipc_lock_object\n- 参数: [struct kern_ipc_perm *perm]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n9. 函数名: ns_capable\n- 参数: [struct user_namespace *user_ns, int cap]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n10. 函数名: current_euid\n- 参数: []\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n11. 函数名: uid_eq\n- 参数: [kuid_t left, kuid_t right]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n12. 函数名: rlimit\n- 参数: [int limit]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n13. 函数名: is_file_hugepages\n- 参数: [struct file *file]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n14. 函数名: shmem_lock\n- 参数: [struct file *file, int lock, struct user_struct *user]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n15. 函数名: get_file\n- 参数: [struct file *file]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n16. 函数名: ipc_unlock_object\n- 参数: [struct kern_ipc_perm *perm]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n17. 函数名: shmem_unlock_mapping\n- 参数: [struct address_space *mapping]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []\n\n18. 函数名: fput\n- 参数: [struct file *file]\n- 调用者: SYSCALL_DEFINE3(shmctl)\n- 被调用者: []"
    },
    {
        "id": 357,
        "cwe": "CWE-362",
        "cve": "CVE-2013-7026",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中共享内存(SHM)的附加(shmat)功能，允许进程将共享内存段附加到其地址空间，并处理相关的权限检查、内存映射和并发访问控制。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在shmctl IPC_RMID操作与其他共享内存系统调用并发时存在竞争条件，导致使用已释放的内存引发拒绝服务或潜在的其他影响\"\"\"",
        "functions": "Functions:\n1. 函数名: do_shmat\n- 参数: [shmid, shmaddr, shmflg, raddr, shmlba]\n- 调用者: N/A (系统调用)\n- 被调用者: [shm_obtain_object_check, ipcperms, security_shm_shmat, ipc_lock_object, path_get, i_size_read, ipc_unlock_object, kzalloc, path_put, alloc_file, kfree, get_ipc_ns, security_mmap_file, down_write, find_vma_intersection, do_mmap_pgoff, up_write, mm_populate, fput, shm_lock, shm_may_destroy, shm_destroy, shm_unlock]\n\n2. 函数名: shm_obtain_object_check\n- 参数: [ns, shmid]\n- 调用者: do_shmat\n- 被调用者: []\n\n3. 函数名: ipcperms\n- 参数: [ns, shm_perm, acc_mode]\n- 调用者: do_shmat\n- 被调用者: []\n\n4. 函数名: security_shm_shmat\n- 参数: [shp, shmaddr, shmflg]\n- 调用者: do_shmat\n- 被调用者: []\n\n5. 函数名: ipc_lock_object\n- 参数: [shm_perm]\n- 调用者: do_shmat\n- 被调用者: []\n\n6. 函数名: path_get\n- 参数: [path]\n- 调用者: do_shmat\n- 被调用者: []\n\n7. 函数名: i_size_read\n- 参数: [dentry->d_inode]\n- 调用者: do_shmat\n- 被调用者: []\n\n8. 函数名: ipc_unlock_object\n- 参数: [shm_perm]\n- 调用者: do_shmat\n- 被调用者: []\n\n9. 函数名: kzalloc\n- 参数: [sizeof(*sfd), GFP_KERNEL]\n- 调用者: do_shmat\n- 被调用者: []\n\n10. 函数名: path_put\n- 参数: [path]\n- 调用者: do_shmat\n- 被调用者: []\n\n11. 函数名: alloc_file\n- 参数: [path, f_mode, shm_file_operations_huge/shm_file_operations]\n- 调用者: do_shmat\n- 被调用者: []\n\n12. 函数名: kfree\n- 参数: [sfd]\n- 调用者: do_shmat\n- 被调用者: []\n\n13. 函数名: get_ipc_ns\n- 参数: [ns]\n- 调用者: do_shmat\n- 被调用者: []\n\n14. 函数名: security_mmap_file\n- 参数: [file, prot, flags]\n- 调用者: do_shmat\n- 被调用者: []\n\n15. 函数名: down_write\n- 参数: [current->mm->mmap_sem]\n- 调用者: do_shmat\n- 被调用者: []\n\n16. 函数名: find_vma_intersection\n- 参数: [current->mm, addr, addr + size]\n- 调用者: do_shmat\n- 被调用者: []\n\n17. 函数名: do_mmap_pgoff\n- 参数: [file, addr, size, prot, flags, 0, populate]\n- 调用者: do_shmat\n- 被调用者: []\n\n18. 函数名: up_write\n- 参数: [current->mm->mmap_sem]\n- 调用者: do_shmat\n- 被调用者: []\n\n19. 函数名: mm_populate\n- 参数: [addr, populate]\n- 调用者: do_shmat\n- 被调用者: []\n\n20. 函数名: fput\n- 参数: [file]\n- 调用者: do_shmat\n- 被调用者: []\n\n21. 函数名: shm_lock\n- 参数: [ns, shmid]\n- 调用者: do_shmat\n- 被调用者: []\n\n22. 函数名: shm_may_destroy\n- 参数: [ns, shp]\n- 调用者: do_shmat\n- 被调用者: []\n\n23. 函数名: shm_destroy\n- 参数: [ns, shp]\n- 调用者: do_shmat\n- 被调用者: []\n\n24. 函数名: shm_unlock\n- 参数: [shp]\n- 调用者: do_shmat\n- 被调用者: []"
    },
    {
        "id": 428,
        "cwe": "CWE-362",
        "cve": "CVE-2014-0100",
        "purpose": "Code purpose:\"\"\"该代码用于在网络碎片重组过程中管理碎片队列，通过哈希表查找或创建新的队列项，并处理并发访问时的竞争条件\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在inet_frag_intern函数中存在竞争条件，当系统CPU负载高时，攻击者通过发送大量分片ICMP Echo请求包可能导致使用后释放错误\"\"\"",
        "functions": "Functions:\n1. 函数名: inet_frag_intern\n- 参数: [struct netns_frags *nf, struct inet_frag_queue *qp_in, struct inet_frags *f, void *arg]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [atomic_inc, mod_timer, hlist_add_head, inet_frag_put, inet_frag_lru_add, read_lock, read_unlock, spin_lock, spin_unlock]\n\n2. 函数名: atomic_inc\n- 参数: [atomic_t *v]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n3. 函数名: mod_timer\n- 参数: [struct timer_list *timer, unsigned long expires]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n4. 函数名: hlist_add_head\n- 参数: [struct hlist_node *n, struct hlist_head *h]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n5. 函数名: inet_frag_put\n- 参数: [struct inet_frag_queue *q, struct inet_frags *f]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n6. 函数名: inet_frag_lru_add\n- 参数: [struct netns_frags *nf, struct inet_frag_queue *q]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n7. 函数名: read_lock\n- 参数: [rwlock_t *lock]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n8. 函数名: read_unlock\n- 参数: [rwlock_t *lock]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n9. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n10. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: inet_frag_intern\n- 被调用者: []"
    },
    {
        "id": 461,
        "cwe": "CWE-362",
        "cve": "CVE-2014-0196",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中tty设备的写入功能，处理来自用户空间的数据写入操作，包括作业控制检查、字符回显处理和输出缓冲管理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核n_tty_write函数在处理'LECHO & !OPOST'情况时未能正确管理tty驱动访问，导致竞争条件可能引发内存破坏或权限提升\"\"\"",
        "functions": "Functions:\n1. 函数名: n_tty_write\n- 参数: [tty, file, buf, nr]\n- 调用者: 未明确（通常是tty子系统调用）\n- 被调用者: [L_TOSTOP, redirected_tty_write, tty_check_change, down_read, process_echoes, add_wait_queue, set_current_state, signal_pending, tty_hung_up_p, O_OPOST, process_output_block, process_output, flush_chars, write, up_read, schedule, __set_current_state, remove_wait_queue, set_bit]\n\n2. 函数名: L_TOSTOP\n- 参数: [tty]\n- 调用者: n_tty_write\n- 被调用者: []\n\n3. 函数名: redirected_tty_write\n- 参数: 未明确（通过file->f_op->write调用）\n- 调用者: n_tty_write\n- 被调用者: []\n\n4. 函数名: tty_check_change\n- 参数: [tty]\n- 调用者: n_tty_write\n- 被调用者: []\n\n5. 函数名: down_read\n- 参数: [&tty->termios_rwsem]\n- 调用者: n_tty_write\n- 被调用者: []\n\n6. 函数名: process_echoes\n- 参数: [tty]\n- 调用者: n_tty_write\n- 被调用者: []\n\n7. 函数名: add_wait_queue\n- 参数: [&tty->write_wait, &wait]\n- 调用者: n_tty_write\n- 被调用者: []\n\n8. 函数名: set_current_state\n- 参数: [TASK_INTERRUPTIBLE]\n- 调用者: n_tty_write\n- 被调用者: []\n\n9. 函数名: signal_pending\n- 参数: [current]\n- 调用者: n_tty_write\n- 被调用者: []\n\n10. 函数名: tty_hung_up_p\n- 参数: [file]\n- 调用者: n_tty_write\n- 被调用者: []\n\n11. 函数名: O_OPOST\n- 参数: [tty]\n- 调用者: n_tty_write\n- 被调用者: []\n\n12. 函数名: process_output_block\n- 参数: [tty, b, nr]\n- 调用者: n_tty_write\n- 被调用者: []\n\n13. 函数名: process_output\n- 参数: [c, tty]\n- 调用者: n_tty_write\n- 被调用者: []\n\n14. 函数名: flush_chars\n- 参数: [tty]\n- 调用者: n_tty_write\n- 被调用者: []\n\n15. 函数名: write\n- 参数: [tty, b, nr]\n- 调用者: n_tty_write\n- 被调用者: []\n\n16. 函数名: up_read\n- 参数: [&tty->termios_rwsem]\n- 调用者: n_tty_write\n- 被调用者: []\n\n17. 函数名: schedule\n- 参数: []\n- 调用者: n_tty_write\n- 被调用者: []\n\n18. 函数名: __set_current_state\n- 参数: [TASK_RUNNING]\n- 调用者: n_tty_write\n- 被调用者: []\n\n19. 函数名: remove_wait_queue\n- 参数: [&tty->write_wait, &wait]\n- 调用者: n_tty_write\n- 被调用者: []\n\n20. 函数名: set_bit\n- 参数: [TTY_DO_WRITE_WAKEUP, &tty->flags]\n- 调用者: n_tty_write\n- 被调用者: []"
    },
    {
        "id": 491,
        "cwe": "CWE-362",
        "cve": "CVE-2014-2672",
        "purpose": "Code purpose:\"\"\"该代码用于在无线网络传输中处理聚合帧的休眠状态，通过遍历传输标识列表来管理调度状态和缓冲数据，并在适当时解除调度和清理列表项\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在ath_tx_aggr_sleep函数中对共享资源（tid->list和ac->list）的访问缺乏足够的同步保护，导致在多线程环境下可能发生竞态条件，从而引发系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: ath_tx_aggr_sleep\n- 参数: [sta, sc, an]\n- 调用者: N/A\n- 被调用者: [ath_txq_lock, ath_tid_has_buffered, list_del, ath_txq_unlock, ieee80211_sta_set_buffered]\n\n2. 函数名: ath_txq_lock\n- 参数: [sc, txq]\n- 调用者: ath_tx_aggr_sleep\n- 被调用者: N/A\n\n3. 函数名: ath_tid_has_buffered\n- 参数: [tid]\n- 调用者: ath_tx_aggr_sleep\n- 被调用者: N/A\n\n4. 函数名: list_del\n- 参数: [&tid->list]\n- 调用者: ath_tx_aggr_sleep\n- 被调用者: N/A\n\n5. 函数名: list_del\n- 参数: [&ac->list]\n- 调用者: ath_tx_aggr_sleep\n- 被调用者: N/A\n\n6. 函数名: ath_txq_unlock\n- 参数: [sc, txq]\n- 调用者: ath_tx_aggr_sleep\n- 被调用者: N/A\n\n7. 函数名: ieee80211_sta_set_buffered\n- 参数: [sta, tidno, buffered]\n- 调用者: ath_tx_aggr_sleep\n- 被调用者: N/A"
    },
    {
        "id": 494,
        "cwe": "CWE-362",
        "cve": "CVE-2014-2706",
        "purpose": "Code purpose:\"\"\"分配并初始化一个无线网络站点(STA)的信息结构体，包括内存分配、状态设置和统计信息初始化等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"竞争条件漏洞源于内核mac80211子系统中对WLAN_STA_PS_STA(节能模式)状态的处理不当，导致远程攻击者可通过特制网络流量触发系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: sta_info_alloc\n- 参数: [struct ieee80211_sub_if_data *sdata, const u8 *addr, gfp_t gfp]\n- 调用者: 未显示\n- 被调用者: [kzalloc, rcu_read_lock, rcu_dereference, kzalloc, rcu_read_unlock, kcalloc, spin_lock_init, INIT_WORK, mutex_init, init_timer, memcpy, jiffies, do_posix_clock_monotonic_gettime, ewma_init, sta_prepare_rate_control, skb_queue_head_init, cpu_to_le16, sta_dbg, kfree]\n\n2. 函数名: sta_unblock\n- 参数: 未显示\n- 调用者: INIT_WORK\n- 被调用者: 未显示\n\n3. 函数名: ieee80211_ba_session_work\n- 参数: 未显示\n- 调用者: INIT_WORK\n- 被调用者: 未显示\n\n4. 函数名: sta_rx_agg_session_timer_expired\n- 参数: 未显示\n- 调用者: 未显示（仅在注释中提到）\n- 被调用者: 未显示\n\n5. 函数名: sta_prepare_rate_control\n- 参数: [struct ieee80211_local *local, struct sta_info *sta, gfp_t gfp]\n- 调用者: sta_info_alloc\n- 被调用者: 未显示\n\n6. 函数名: sta_dbg\n- 参数: [struct ieee80211_sub_if_data *sdata, const char *fmt, ...]\n- 调用者: sta_info_alloc\n- 被调用者: 未显示"
    },
    {
        "id": 495,
        "cwe": "CWE-362",
        "cve": "CVE-2014-2706",
        "purpose": "Code purpose:\"\"\"该代码用于处理无线客户端从省电模式唤醒时的数据帧传输和状态更新，包括将缓冲的帧发送给客户端并更新其电源管理状态。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在sta_info.c和tx.c中处理WLAN_STA_PS_STA状态(节能模式)时存在竞态条件，远程攻击者可通过网络流量不当交互导致系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: ieee80211_sta_ps_deliver_wakeup\n- 参数: [struct sta_info *sta]\n- 调用者: 未显示\n- 被调用者: [clear_sta_flag, BUILD_BUG_ON, drv_sta_notify, skb_queue_head_init, skb_queue_len, spin_lock_irqsave, skb_queue_splice_tail_init, spin_unlock_irqrestore, ieee80211_add_pending_skbs_fn, ieee80211_smps_is_restrictive, sta_info_tx_streams, ht_dbg, ieee80211_send_smps_action, sta_info_recalc_tim, ps_dbg]\n\n2. 函数名: clear_sta_flag\n- 参数: [struct sta_info *sta, WLAN_STA_SP]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n3. 函数名: BUILD_BUG_ON\n- 参数: [BITS_TO_LONGS(IEEE80211_NUM_TIDS) > 1]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n4. 函数名: drv_sta_notify\n- 参数: [local, sdata, STA_NOTIFY_AWAKE, &sta->sta]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n5. 函数名: skb_queue_head_init\n- 参数: [&pending]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n6. 函数名: skb_queue_len\n- 参数: [&pending], [&pending]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n7. 函数名: spin_lock_irqsave\n- 参数: [&sta->tx_filtered[ac].lock, flags], [&sta->ps_tx_buf[ac].lock, flags]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n8. 函数名: skb_queue_splice_tail_init\n- 参数: [&sta->tx_filtered[ac], &pending], [&sta->ps_tx_buf[ac], &pending]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n9. 函数名: spin_unlock_irqrestore\n- 参数: [&sta->tx_filtered[ac].lock, flags], [&sta->ps_tx_buf[ac].lock, flags]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n10. 函数名: ieee80211_add_pending_skbs_fn\n- 参数: [local, &pending, clear_sta_ps_flags, sta]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n11. 函数名: ieee80211_smps_is_restrictive\n- 参数: [sta->known_smps_mode, sdata->smps_mode]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n12. 函数名: sta_info_tx_streams\n- 参数: [sta]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n13. 函数名: ht_dbg\n- 参数: [sdata, \"%pM just woke up and MIMO capable - update SMPS\\n\", sta->sta.addr]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n14. 函数名: ieee80211_send_smps_action\n- 参数: [sdata, sdata->bss->req_smps, sta->sta.addr, sdata->vif.bss_conf.bssid]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n15. 函数名: sta_info_recalc_tim\n- 参数: [sta]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示\n\n16. 函数名: ps_dbg\n- 参数: [sdata, \"STA %pM aid %d sending %d filtered/%d PS frames since STA not sleeping anymore\\n\", sta->sta.addr, sta->sta.aid, filtered, buffered]\n- 调用者: ieee80211_sta_ps_deliver_wakeup\n- 被调用者: 未显示"
    },
    {
        "id": 496,
        "cwe": "CWE-362",
        "cve": "CVE-2014-2706",
        "purpose": "Code purpose:\"\"\"处理无线网络单播数据帧在电源节省模式下的缓冲和传输\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核mac80211子系统中存在竞态条件，当网络流量与WLAN_STA_PS_STA(节能模式)状态异常交互时，导致系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: ieee80211_tx_h_unicast_ps_buf\n- 参数: [struct ieee80211_tx_data *tx]\n- 调用者: 未显示\n- 被调用者: [test_sta_flag, skb_get_queue_mapping, ps_dbg, purge_old_ps_buffers, skb_queue_len, skb_dequeue, ieee80211_free_txskb, timer_pending, mod_timer, round_jiffies, sta_info_recalc_tim]\n\n2. 函数名: test_sta_flag\n- 参数: [struct sta_info *sta, int flag]\n- 调用者: ieee80211_tx_h_unicast_ps_buf\n- 被调用者: 未显示\n\n3. 函数名: skb_get_queue_mapping\n- 参数: [struct sk_buff *skb]\n- 调用者: ieee80211_tx_h_unicast_ps_buf\n- 被调用者: 未显示\n\n4. 函数名: ps_dbg\n- 参数: [struct ieee80211_sub_if_data *sdata, const char *fmt, ...]\n- 调用者: ieee80211_tx_h_unicast_ps_buf\n- 被调用者: 未显示\n\n5. 函数名: purge_old_ps_buffers\n- 参数: [struct ieee80211_local *local]\n- 调用者: ieee80211_tx_h_unicast_ps_buf\n- 被调用者: 未显示\n\n6. 函数名: skb_queue_len\n- 参数: [struct sk_buff_head *list]\n- 调用者: ieee80211_tx_h_unicast_ps_buf\n- 被调用者: 未显示\n\n7. 函数名: skb_dequeue\n- 参数: [struct sk_buff_head *list]\n- 调用者: ieee80211_tx_h_unicast_ps_buf\n- 被调用者: 未显示\n\n8. 函数名: ieee80211_free_txskb\n- 参数: [struct ieee80211_hw *hw, struct sk_buff *skb]\n- 调用者: ieee80211_tx_h_unicast_ps_buf\n- 被调用者: 未显示\n\n9. 函数名: timer_pending\n- 参数: [const struct timer_list *timer]\n- 调用者: ieee80211_tx_h_unicast_ps_buf\n- 被调用者: 未显示\n\n10. 函数名: mod_timer\n- 参数: [struct timer_list *timer, unsigned long expires]\n- 调用者: ieee80211_tx_h_unicast_ps_buf\n- 被调用者: 未显示\n\n11. 函数名: round_jiffies\n- 参数: [unsigned long j]\n- 调用者: ieee80211_tx_h_unicast_ps_buf\n- 被调用者: 未显示\n\n12. 函数名: sta_info_recalc_tim\n- 参数: [struct sta_info *sta]\n- 调用者: ieee80211_tx_h_unicast_ps_buf\n- 被调用者: 未显示"
    },
    {
        "id": 528,
        "cwe": "CWE-362",
        "cve": "CVE-2014-3611",
        "purpose": "Code purpose:\"\"\"在KVM虚拟化环境中迁移PIT(可编程间隔定时器)定时器时处理定时器的取消和重新启动\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于__kvm_migrate_pit_timer函数中缺乏适当的锁机制，导致在PIT定时器迁移过程中存在竞争条件，可能造成主机系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: __kvm_migrate_pit_timer\n- 参数: [vcpu]\n- 调用者: 未明确（由KVM子系统调用）\n- 被调用者: [kvm_vcpu_is_bsp, hrtimer_cancel, hrtimer_start_expires]\n\n2. 函数名: kvm_vcpu_is_bsp\n- 参数: [vcpu]\n- 调用者: __kvm_migrate_pit_timer\n- 被调用者: []\n\n3. 函数名: hrtimer_cancel\n- 参数: [timer]\n- 调用者: __kvm_migrate_pit_timer\n- 被调用者: []\n\n4. 函数名: hrtimer_start_expires\n- 参数: [timer, HRTIMER_MODE_ABS]\n- 调用者: __kvm_migrate_pit_timer\n- 被调用者: []"
    },
    {
        "id": 549,
        "cwe": "CWE-362",
        "cve": "CVE-2014-3940",
        "purpose": "Code purpose:\"\"\"该代码用于处理hugetlb页面的队列操作，包括检查节点设置、迁移条件判断以及隔离大页面的功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理hugetlb大页迁移时未正确考虑并发访问情况，导致在numa_maps读取操作期间可能触发竞争条件，造成内存损坏或系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: queue_pages_hugetlb_pmd_range\n- 参数: [vma, pmd, nodes, flags, private]\n- 调用者: 未明确（可能是NUMA内存策略相关调用）\n- 被调用者: [huge_pte_lock, hstate_vma, pte_page, huge_ptep_get, page_to_nid, node_isset, page_mapcount, isolate_huge_page, spin_unlock]\n\n2. 函数名: huge_pte_lock\n- 参数: [hstate_vma(vma), vma->vm_mm, (pte_t *)pmd]\n- 调用者: queue_pages_hugetlb_pmd_range\n- 被调用者: []\n\n3. 函数名: hstate_vma\n- 参数: [vma]\n- 调用者: queue_pages_hugetlb_pmd_range\n- 被调用者: []\n\n4. 函数名: pte_page\n- 参数: [huge_ptep_get((pte_t *)pmd)]\n- 调用者: queue_pages_hugetlb_pmd_range\n- 被调用者: []\n\n5. 函数名: huge_ptep_get\n- 参数: [(pte_t *)pmd]\n- 调用者: queue_pages_hugetlb_pmd_range\n- 被调用者: []\n\n6. 函数名: page_to_nid\n- 参数: [page]\n- 调用者: queue_pages_hugetlb_pmd_range\n- 被调用者: []\n\n7. 函数名: node_isset\n- 参数: [nid, *nodes]\n- 调用者: queue_pages_hugetlb_pmd_range\n- 被调用者: []\n\n8. 函数名: page_mapcount\n- 参数: [page]\n- 调用者: queue_pages_hugetlb_pmd_range\n- 被调用者: []\n\n9. 函数名: isolate_huge_page\n- 参数: [page, private]\n- 调用者: queue_pages_hugetlb_pmd_range\n- 被调用者: []\n\n10. 函数名: spin_unlock\n- 参数: [ptl]\n- 调用者: queue_pages_hugetlb_pmd_range\n- 被调用者: []"
    },
    {
        "id": 563,
        "cwe": "CWE-362",
        "cve": "CVE-2014-4652",
        "purpose": "Code purpose:\"\"\"将用户元素数据从内核空间复制到用户空间的控制元素值中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺少对用户空间元素数据访问的同步保护，导致竞态条件下内核敏感信息可能被泄露\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_ctl_elem_user_get\n- 参数: [struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol]\n- 调用者: 未明确（由ALSA控制接口调用）\n- 被调用者: [memcpy]"
    },
    {
        "id": 564,
        "cwe": "CWE-362",
        "cve": "CVE-2014-4652",
        "purpose": "Code purpose:\"\"\"该代码片段实现了ALSA控制接口中用户空间元素值的更新功能，通过比较并复制控制元素值来更新内核中的对应数据。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺少适当的同步机制，snd_ctl_elem_user_put函数在处理TLV数据时存在竞态条件，导致本地用户可能通过/dev/snd/controlCX访问获取内核敏感信息\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_ctl_elem_user_put\n- 参数: [struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol]\n- 调用者: 未明确（由ALSA控制接口调用）\n- 被调用者: [memcmp, memcpy]\n\n2. 函数名: memcmp\n- 参数: [const void *s1, const void *s2, size_t n]\n- 调用者: snd_ctl_elem_user_put\n- 被调用者: []\n\n3. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: snd_ctl_elem_user_put\n- 被调用者: []"
    },
    {
        "id": 565,
        "cwe": "CWE-362",
        "cve": "CVE-2014-4652",
        "purpose": "Code purpose:\"\"\"处理ALSA控制元素的TLV(Type-Length-Value)数据，包括从用户空间复制数据到内核空间以及反向操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺少对共享资源ue->tlv_data和ue->tlv_data_size的同步保护，导致竞争条件可能使内核敏感信息泄露。\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_ctl_elem_user_tlv\n- 参数: [struct snd_kcontrol *kcontrol, int op_flag, unsigned int size, unsigned int __user *tlv]\n- 调用者: 未明确（由内核调用）\n- 被调用者: [memdup_user, IS_ERR, PTR_ERR, memcmp, kfree, copy_to_user]\n\n2. 函数名: memdup_user\n- 参数: [unsigned int __user *tlv, unsigned int size]\n- 调用者: snd_ctl_elem_user_tlv\n- 被调用者: []\n\n3. 函数名: IS_ERR\n- 参数: [void *new_data]\n- 调用者: snd_ctl_elem_user_tlv\n- 被调用者: []\n\n4. 函数名: PTR_ERR\n- 参数: [void *new_data]\n- 调用者: snd_ctl_elem_user_tlv\n- 被调用者: []\n\n5. 函数名: memcmp\n- 参数: [ue->tlv_data, new_data, size]\n- 调用者: snd_ctl_elem_user_tlv\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [ue->tlv_data]\n- 调用者: snd_ctl_elem_user_tlv\n- 被调用者: []\n\n7. 函数名: copy_to_user\n- 参数: [tlv, ue->tlv_data, ue->tlv_data_size]\n- 调用者: snd_ctl_elem_user_tlv\n- 被调用者: []"
    },
    {
        "id": 566,
        "cwe": "CWE-362",
        "cve": "CVE-2014-4652",
        "purpose": "Code purpose:\"\"\"该代码用于创建并初始化一个声卡设备结构体，包括分配内存、设置属性、创建控制接口等操作，最终返回声卡对象供系统使用。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于ALSA控制实现中的tlv处理功能存在竞态条件，本地用户可通过访问/dev/snd/controlCX利用该条件获取内核内存中的敏感信息\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_card_new\n- 参数: [struct device *parent, int idx, const char *xid, struct module *module, int extra_size, struct snd_card **card_ret]\n- 调用者: N/A (顶级函数)\n- 被调用者: [kzalloc, strlcpy, mutex_lock, get_slot_from_bitmask, test_bit, mutex_unlock, dev_err, kfree, set_bit, device_initialize, kobject_set_name, snd_ctl_create, snd_info_card_create, snd_device_free_all, put_device]\n\n2. 函数名: get_slot_from_bitmask\n- 参数: [int idx, module_slot_match/check_empty_slot, struct module *module]\n- 调用者: snd_card_new\n- 被调用者: N/A (假设是内部实现)\n\n3. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: snd_card_new\n- 被调用者: N/A (内核内存分配函数)\n\n4. 函数名: strlcpy\n- 参数: [char *dest, const char *src, size_t size]\n- 调用者: snd_card_new\n- 被调用者: N/A (字符串操作函数)\n\n5. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: snd_card_new\n- 被调用者: N/A (同步原语)\n\n6. 函数名: test_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: snd_card_new\n- 被调用者: N/A (位操作函数)\n\n7. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: snd_card_new\n- 被调用者: N/A (同步原语)\n\n8. 函数名: dev_err\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: snd_card_new\n- 被调用者: N/A (日志打印函数)\n\n9. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: snd_card_new\n- 被调用者: N/A (内存释放函数)\n\n10. 函数名: set_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: snd_card_new\n- 被调用者: N/A (位操作函数)\n\n11. 函数名: device_initialize\n- 参数: [struct device *dev]\n- 调用者: snd_card_new\n- 被调用者: N/A (设备初始化函数)\n\n12. 函数名: kobject_set_name\n- 参数: [struct kobject *kobj, const char *fmt, ...]\n- 调用者: snd_card_new\n- 被调用者: N/A (内核对象命名函数)\n\n13. 函数名: snd_ctl_create\n- 参数: [struct snd_card *card]\n- 调用者: snd_card_new\n- 被调用者: N/A (假设是ALSA控制接口创建函数)\n\n14. 函数名: snd_info_card_create\n- 参数: [struct snd_card *card]\n- 调用者: snd_card_new\n- 被调用者: N/A (假设是ALSA信息创建函数)\n\n15. 函数名: snd_device_free_all\n- 参数: [struct snd_card *card]\n- 调用者: snd_card_new\n- 被调用者: N/A (假设是ALSA设备释放函数)\n\n16. 函数名: put_device\n- 参数: [struct device *dev]\n- 调用者: snd_card_new\n- 被调用者: N/A (设备引用计数减少函数)"
    },
    {
        "id": 598,
        "cwe": "CWE-362",
        "cve": "CVE-2014-7842",
        "purpose": "Code purpose:\"\"\"处理KVM虚拟化环境中指令模拟失败的情况，包括统计失败次数、设置退出原因和错误码，并向客户机队列异常\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理模拟失败时存在竞态条件，允许恶意客户机通过MMIO或PIO事务触发用户空间模拟错误报告，导致拒绝服务。\"\"\"",
        "functions": "Functions:\n1. 函数名: handle_emulation_failure\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: 未明确显示（由KVM虚拟化模块调用）\n- 被调用者: [is_guest_mode, trace_kvm_emulate_insn_failed, kvm_queue_exception]\n\n2. 函数名: is_guest_mode\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: handle_emulation_failure\n- 被调用者: []\n\n3. 函数名: trace_kvm_emulate_insn_failed\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: handle_emulation_failure\n- 被调用者: []\n\n4. 函数名: kvm_queue_exception\n- 参数: [struct kvm_vcpu *vcpu, UD_VECTOR]\n- 调用者: handle_emulation_failure\n- 被调用者: []"
    },
    {
        "id": 601,
        "cwe": "CWE-362",
        "cve": "CVE-2014-8086",
        "purpose": "Code purpose:\"\"\"该代码实现了ext4文件系统中文件写入操作的迭代处理，包括处理直接I/O、追加写入、文件大小限制检查等功能，并处理了相关的并发控制和同步问题。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4_file_write_iter函数中，由于对O_DIRECT标志的检查和修改缺乏适当的同步机制，导致在并发执行写操作和fcntl F_SETFL操作时可能引发竞态条件，造成文件不可用。\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_file_write_iter\n- 参数: [struct kiocb *iocb, struct iov_iter *from]\n- 调用者: N/A (kernel-level function)\n- 被调用者: [file_inode, ext4_test_inode_flag, is_sync_kiocb, ext4_unaligned_aio, ext4_aio_mutex, mutex_lock, ext4_unwritten_wait, i_size_read, EXT4_SB, mutex_unlock, iov_iter_truncate, blk_start_plug, ext4_should_dioread_nolock, ext4_map_blocks, __generic_file_write_iter, generic_write_sync, blk_finish_plug]\n\n2. 函数名: file_inode\n- 参数: [struct file *file]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n3. 函数名: ext4_test_inode_flag\n- 参数: [struct inode *inode, int flag]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n4. 函数名: is_sync_kiocb\n- 参数: [struct kiocb *iocb]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n5. 函数名: ext4_unaligned_aio\n- 参数: [struct inode *inode, struct iov_iter *from, loff_t pos]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n6. 函数名: ext4_aio_mutex\n- 参数: [struct inode *inode]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n7. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n8. 函数名: ext4_unwritten_wait\n- 参数: [struct inode *inode]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n9. 函数名: i_size_read\n- 参数: [struct inode *inode]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n10. 函数名: EXT4_SB\n- 参数: [struct super_block *sb]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n11. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n12. 函数名: iov_iter_truncate\n- 参数: [struct iov_iter *i, size_t count]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n13. 函数名: blk_start_plug\n- 参数: [struct blk_plug *plug]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n14. 函数名: ext4_should_dioread_nolock\n- 参数: [struct inode *inode]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n15. 函数名: ext4_map_blocks\n- 参数: [NULL, struct inode *inode, struct ext4_map_blocks *map, int flags]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n16. 函数名: __generic_file_write_iter\n- 参数: [struct kiocb *iocb, struct iov_iter *from]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n17. 函数名: generic_write_sync\n- 参数: [struct file *file, loff_t pos, ssize_t count]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A\n\n18. 函数名: blk_finish_plug\n- 参数: [struct blk_plug *plug]\n- 调用者: ext4_file_write_iter\n- 被调用者: N/A"
    },
    {
        "id": 683,
        "cwe": "CWE-362",
        "cve": "CVE-2014-9529",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中安全地回收和销毁不再使用的密钥结构，处理相关的用户配额和引用计数，并释放相关内存资源。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在key_gc_unused_keys函数处理密钥垃圾回收时，存在竞态条件，导致本地用户可通过keyctl命令在密钥结构成员被垃圾回收期间访问它，从而引发内存损坏或系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: key_gc_unused_keys\n- 参数: [struct list_head *keys]\n- 调用者: 未明确（由内核调用）\n- 被调用者: [list_entry, list_del, kdebug, key_check, security_key_free, test_bit, spin_lock, spin_unlock, atomic_dec, key_user_put, key->type->destroy, kfree, kmem_cache_free]\n\n2. 函数名: list_entry\n- 参数: [keys->next, struct key, graveyard_link]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n3. 函数名: list_del\n- 参数: [&key->graveyard_link]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n4. 函数名: kdebug\n- 参数: [\"- %u\", key->serial]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n5. 函数名: key_check\n- 参数: [key]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n6. 函数名: security_key_free\n- 参数: [key]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n7. 函数名: test_bit\n- 参数: [KEY_FLAG_IN_QUOTA, &key->flags]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n8. 函数名: spin_lock\n- 参数: [&key->user->lock]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n9. 函数名: spin_unlock\n- 参数: [&key->user->lock]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n10. 函数名: atomic_dec\n- 参数: [&key->user->nkeys]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n11. 函数名: key_user_put\n- 参数: [key->user]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n12. 函数名: key->type->destroy\n- 参数: [key]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n13. 函数名: kfree\n- 参数: [key->description]\n- 调用者: key_gc_unused_keys\n- 被调用者: []\n\n14. 函数名: kmem_cache_free\n- 参数: [key_jar, key]\n- 调用者: key_gc_unused_keys\n- 被调用者: []"
    },
    {
        "id": 688,
        "cwe": "CWE-362",
        "cve": "CVE-2014-9710",
        "purpose": "Code purpose:\"\"\"该代码实现了Btrfs文件系统中搜索树节点槽位的功能，处理了节点锁定、路径管理以及在插入或删除操作时的树结构调整。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中Btrfs实现未确保可见xattr状态与请求替换的一致性，导致本地用户可通过文件系统操作绕过ACL设置，存在竞争条件或替换失败后的权限提升漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: btrfs_search_slot\n- 参数: [trans, root, key, p, ins_len, cow]\n- 调用者: N/A (顶层函数)\n- 被调用者: [WARN_ON, BUG_ON, extent_buffer_get, btrfs_tree_read_lock, btrfs_root_node, btrfs_read_lock_root_node, btrfs_tree_read_unlock, free_extent_buffer, btrfs_lock_root_node, should_cow_block, btrfs_release_path, btrfs_set_path_blocking, btrfs_cow_block, btrfs_clear_path_blocking, btrfs_tree_unlock_rw, key_search, setup_nodes_for_search, unlock_up, read_block_for_search, btrfs_try_tree_write_lock, btrfs_tree_lock, btrfs_try_tree_read_lock, btrfs_tree_read_lock, btrfs_leaf_free_space, split_leaf]\n\n2. 函数名: WARN_ON\n- 参数: [condition]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n3. 函数名: BUG_ON\n- 参数: [condition]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n4. 函数名: extent_buffer_get\n- 参数: [b]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n5. 函数名: btrfs_tree_read_lock\n- 参数: [b]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n6. 函数名: btrfs_root_node\n- 参数: [root]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n7. 函数名: btrfs_read_lock_root_node\n- 参数: [root]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n8. 函数名: btrfs_tree_read_unlock\n- 参数: [b]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n9. 函数名: free_extent_buffer\n- 参数: [b]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n10. 函数名: btrfs_lock_root_node\n- 参数: [root]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n11. 函数名: should_cow_block\n- 参数: [trans, root, b]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n12. 函数名: btrfs_release_path\n- 参数: [p]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n13. 函数名: btrfs_set_path_blocking\n- 参数: [p]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n14. 函数名: btrfs_cow_block\n- 参数: [trans, root, b, p->nodes[level + 1], p->slots[level + 1], &b]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n15. 函数名: btrfs_clear_path_blocking\n- 参数: [p, NULL, 0] or [p, b, BTRFS_WRITE_LOCK] or [p, b, BTRFS_READ_LOCK]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n16. 函数名: btrfs_tree_unlock_rw\n- 参数: [p->nodes[u], p->locks[u]]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n17. 函数名: key_search\n- 参数: [b, key, level, &prev_cmp, &slot]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n18. 函数名: setup_nodes_for_search\n- 参数: [trans, root, p, b, level, ins_len, &write_lock_level]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n19. 函数名: unlock_up\n- 参数: [p, level, lowest_unlock, min_write_lock_level, &write_lock_level]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n20. 函数名: read_block_for_search\n- 参数: [trans, root, p, &b, level, slot, key, 0]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n21. 函数名: btrfs_try_tree_write_lock\n- 参数: [b]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n22. 函数名: btrfs_tree_lock\n- 参数: [b]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n23. 函数名: btrfs_try_tree_read_lock\n- 参数: [b]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n24. 函数名: btrfs_tree_read_lock\n- 参数: [b]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n25. 函数名: btrfs_leaf_free_space\n- 参数: [root, b]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A\n\n26. 函数名: split_leaf\n- 参数: [trans, root, key, p, ins_len, ret == 0]\n- 调用者: btrfs_search_slot\n- 被调用者: N/A"
    },
    {
        "id": 689,
        "cwe": "CWE-362",
        "cve": "CVE-2014-9710",
        "purpose": "Code purpose:\"\"\"在Btrfs文件系统中匹配指定名称的目录项\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中Btrfs实现未确保可见的xattr状态与请求的替换操作保持一致，存在竞争条件或替换失败后的不一致状态，导致本地用户可绕过ACL设置获取权限\"\"\"",
        "functions": "Functions:\n1. 函数名: btrfs_match_dir_item_name\n- 参数: [struct btrfs_root *root, struct btrfs_path *path, const char *name, int name_len]\n- 调用者: N/A\n- 被调用者: [verify_dir_item, btrfs_item_size_nr, btrfs_dir_name_len, btrfs_dir_data_len, memcmp_extent_buffer]\n\n2. 函数名: verify_dir_item\n- 参数: [struct btrfs_root *root, struct extent_buffer *leaf, struct btrfs_dir_item *dir_item]\n- 调用者: btrfs_match_dir_item_name\n- 被调用者: N/A\n\n3. 函数名: btrfs_item_size_nr\n- 参数: [struct extent_buffer *leaf, int slot]\n- 调用者: btrfs_match_dir_item_name\n- 被调用者: N/A\n\n4. 函数名: btrfs_dir_name_len\n- 参数: [struct extent_buffer *leaf, struct btrfs_dir_item *dir_item]\n- 调用者: btrfs_match_dir_item_name\n- 被调用者: N/A\n\n5. 函数名: btrfs_dir_data_len\n- 参数: [struct extent_buffer *leaf, struct btrfs_dir_item *dir_item]\n- 调用者: btrfs_match_dir_item_name\n- 被调用者: N/A\n\n6. 函数名: memcmp_extent_buffer\n- 参数: [struct extent_buffer *eb, const void *ptr, unsigned long start, unsigned long len]\n- 调用者: btrfs_match_dir_item_name\n- 被调用者: N/A"
    },
    {
        "id": 690,
        "cwe": "CWE-362",
        "cve": "CVE-2014-9710",
        "purpose": "Code purpose:\"\"\"该代码实现了Btrfs文件系统中扩展属性(xattr)的设置功能，包括创建、替换和删除操作，并处理相关错误情况。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Btrfs在替换xattr属性时存在竞态条件，未能确保可见的xattr状态与请求的替换操作保持一致性，导致本地用户可以在替换操作的时间窗口内绕过ACL设置或利用替换失败的情况获取权限。\"\"\"",
        "functions": "Functions:\n1. 函数名: do_setxattr\n- 参数: [struct btrfs_trans_handle *trans, struct inode *inode, const char *name, const void *value, size_t size, int flags]\n- 调用者: 未显示\n- 被调用者: [btrfs_alloc_path, btrfs_lookup_xattr, btrfs_delete_one_dir_name, btrfs_release_path, btrfs_insert_xattr_item, btrfs_free_path]\n\n2. 函数名: btrfs_alloc_path\n- 参数: []\n- 调用者: do_setxattr\n- 被调用者: 未显示\n\n3. 函数名: btrfs_lookup_xattr\n- 参数: [struct btrfs_trans_handle *trans, struct btrfs_root *root, struct btrfs_path *path, u64 ino, const char *name, int name_len, int mod]\n- 调用者: do_setxattr\n- 被调用者: 未显示\n\n4. 函数名: btrfs_delete_one_dir_name\n- 参数: [struct btrfs_trans_handle *trans, struct btrfs_root *root, struct btrfs_path *path, struct btrfs_dir_item *di]\n- 调用者: do_setxattr\n- 被调用者: 未显示\n\n5. 函数名: btrfs_release_path\n- 参数: [struct btrfs_path *path]\n- 调用者: do_setxattr\n- 被调用者: 未显示\n\n6. 函数名: btrfs_insert_xattr_item\n- 参数: [struct btrfs_trans_handle *trans, struct btrfs_root *root, struct btrfs_path *path, u64 ino, const char *name, int name_len, const void *data, int data_len]\n- 调用者: do_setxattr\n- 被调用者: 未显示\n\n7. 函数名: btrfs_free_path\n- 参数: [struct btrfs_path *path]\n- 调用者: do_setxattr\n- 被调用者: 未显示"
    },
    {
        "id": 711,
        "cwe": "CWE-362",
        "cve": "CVE-2014-9914",
        "purpose": "Code purpose:\"\"\"该代码用于在IPv4 UDP套接字释放时处理路由缓存更新，确保数据包能正确路由到目标地址\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在多线程环境下对IPv4 UDP套接字内部数据结构访问时，由于缺乏适当的锁定机制导致竞态条件，可能引发释放后重用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: ip4_datagram_release_cb\n- 参数: [struct sock *sk]\n- 调用者: 未明确显示（由内核调用）\n- 被调用者: [inet_sk, __sk_dst_get, __sk_dst_check, rcu_read_lock, rcu_dereference, ip_route_output_ports, sock_net, IS_ERR, __sk_dst_set, rcu_read_unlock]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: []\n\n3. 函数名: __sk_dst_get\n- 参数: [struct sock *sk]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: []\n\n4. 函数名: __sk_dst_check\n- 参数: [struct sock *sk, int 0]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: []\n\n5. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: ip4_datagram_release_cb\n- 被调用者: []\n\n6. 函数名: rcu_dereference\n- 参数: [inet->inet_opt]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: []\n\n7. 函数名: ip_route_output_ports\n- 参数: [sock_net(sk), &fl4, sk, daddr, inet->inet_saddr, inet->inet_dport, inet->inet_sport, sk->sk_protocol, RT_CONN_FLAGS(sk), sk->sk_bound_dev_if]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: []\n\n8. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: []\n\n9. 函数名: IS_ERR\n- 参数: [rt]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: []\n\n10. 函数名: __sk_dst_set\n- 参数: [struct sock *sk, &rt->dst]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: []\n\n11. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: ip4_datagram_release_cb\n- 被调用者: []"
    },
    {
        "id": 732,
        "cwe": "CWE-362",
        "cve": "CVE-2015-1420",
        "purpose": "Code purpose:\"\"\"该代码用于根据文件句柄获取对应的文件路径，并进行权限检查和内存分配等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在验证handle_bytes大小后未重新检查其值，导致竞争条件下攻击者可以修改该值从而绕过内存访问限制\"\"\"",
        "functions": "Functions:\n1. 函数名: handle_to_path\n- 参数: [mountdirfd, ufh, path]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [capable, copy_from_user, kmalloc, do_handle_to_path, kfree]\n\n2. 函数名: capable\n- 参数: [CAP_DAC_READ_SEARCH]\n- 调用者: handle_to_path\n- 被调用者: 未明确（内核能力检查函数）\n\n3. 函数名: copy_from_user\n- 参数: [&f_handle, ufh, sizeof(struct file_handle)] 和 [handle, ufh, sizeof(struct file_handle) + f_handle.handle_bytes]\n- 调用者: handle_to_path\n- 被调用者: 未明确（内核内存复制函数）\n\n4. 函数名: kmalloc\n- 参数: [sizeof(struct file_handle) + f_handle.handle_bytes, GFP_KERNEL]\n- 调用者: handle_to_path\n- 被调用者: 未明确（内核内存分配函数）\n\n5. 函数名: do_handle_to_path\n- 参数: [mountdirfd, handle, path]\n- 调用者: handle_to_path\n- 被调用者: 未明确（内核路径处理函数）\n\n6. 函数名: kfree\n- 参数: [handle]\n- 调用者: handle_to_path\n- 被调用者: 未明确（内核内存释放函数）"
    },
    {
        "id": 749,
        "cwe": "CWE-362",
        "cve": "CVE-2015-3212",
        "purpose": "Code purpose:\"\"\"将SCTP套接字从旧套接字迁移到新套接字，包括复制选项、绑定信息、接收队列和关联状态等\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多线程环境下对共享数据结构(如bind_hash链表)的访问缺乏适当的同步保护，导致并发操作可能引发链表损坏，造成系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: sctp_sock_migrate\n- 参数: [struct sock *oldsk, struct sock *newsk, struct sctp_association *assoc, sctp_socket_type_t type]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [sctp_sk, sock_net, inet_sk_copy_descendant, sk_add_bind_node, sctp_bind_addr_dup, sctp_skb_for_each, __skb_unlink, __skb_queue_tail, sctp_skb_set_owner_r_frag, sctp_clear_pd, lock_sock_nested, sctp_assoc_migrate, sctp_state, sctp_style, release_sock]\n\n2. 函数名: sctp_sk\n- 参数: [struct sock *sk]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n3. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n4. 函数名: inet_sk_copy_descendant\n- 参数: [struct sock *newsk, struct sock *oldsk]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n5. 函数名: sk_add_bind_node\n- 参数: [struct sock *sk, struct list_head *list]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n6. 函数名: sctp_bind_addr_dup\n- 参数: [struct sctp_bind_addr *dest, struct sctp_bind_addr *src, gfp_t gfp]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n7. 函数名: sctp_skb_for_each\n- 参数: [struct sk_buff *skb, struct sk_buff_head *list, struct sk_buff *tmp]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n8. 函数名: __skb_unlink\n- 参数: [struct sk_buff *skb, struct sk_buff_head *list]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n9. 函数名: __skb_queue_tail\n- 参数: [struct sk_buff_head *list, struct sk_buff *skb]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n10. 函数名: sctp_skb_set_owner_r_frag\n- 参数: [struct sk_buff *skb, struct sock *sk]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n11. 函数名: sctp_clear_pd\n- 参数: [struct sock *sk, struct sctp_association *asoc]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n12. 函数名: lock_sock_nested\n- 参数: [struct sock *sk, int subclass]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n13. 函数名: sctp_assoc_migrate\n- 参数: [struct sctp_association *assoc, struct sock *newsk]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n14. 函数名: sctp_state\n- 参数: [struct sctp_association *asoc, sctp_state_t state]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n15. 函数名: sctp_style\n- 参数: [struct sock *sk, sctp_socket_type_t style]\n- 调用者: sctp_sock_migrate\n- 被调用者: []\n\n16. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_sock_migrate\n- 被调用者: []"
    },
    {
        "id": 750,
        "cwe": "CWE-362",
        "cve": "CVE-2015-3212",
        "purpose": "Code purpose:\"\"\"初始化SCTP套接字的相关参数和结构，为后续的SCTP协议通信做准备\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在sctp_init_sock函数中缺乏适当的同步机制，导致在多线程环境下快速连续调用系统调用时可能引发竞态条件，造成链表损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: sctp_init_sock\n- 参数: [struct sock *sk]\n- 调用者: 未显示（通常由内核网络栈调用）\n- 被调用者: [sock_net, sctp_sk, sctp_endpoint_new, atomic_set, skb_queue_head_init, local_bh_disable, percpu_counter_inc, sock_prot_inuse_add, list_add_tail, local_bh_enable]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n3. 函数名: sctp_sk\n- 参数: [struct sock *sk]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n4. 函数名: sctp_endpoint_new\n- 参数: [struct sock *sk, GFP_KERNEL]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n5. 函数名: atomic_set\n- 参数: [&sp->pd_mode, 0]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n6. 函数名: skb_queue_head_init\n- 参数: [&sp->pd_lobby]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n7. 函数名: local_bh_disable\n- 参数: []\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n8. 函数名: percpu_counter_inc\n- 参数: [&sctp_sockets_allocated]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n9. 函数名: sock_prot_inuse_add\n- 参数: [net, sk->sk_prot, 1]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n10. 函数名: list_add_tail\n- 参数: [&sp->auto_asconf_list, &net->sctp.auto_asconf_splist]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n11. 函数名: local_bh_enable\n- 参数: []\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n12. 函数名: sctp_get_pf_specific\n- 参数: [sk->sk_family]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n13. 函数名: sctp_destruct_sock\n- 参数: []\n- 调用者: sctp_init_sock (通过赋值给sk->sk_destruct)\n- 被调用者: []"
    },
    {
        "id": 751,
        "cwe": "CWE-362",
        "cve": "CVE-2015-3212",
        "purpose": "Code purpose:\"\"\"该代码用于设置SCTP套接字的自动ASCONF(Address Configuration Change)功能，允许或禁止自动地址配置更改。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺乏适当的同步机制，在多线程环境下快速连续调用setsockopt相关系统调用时，会导致对auto_asconf_list的并发访问，引发链表损坏和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: sctp_setsockopt_auto_asconf\n- 参数: [struct sock *sk, char __user *optval, unsigned int optlen]\n- 调用者: 未指定（由系统调用触发）\n- 被调用者: [sctp_sk, sctp_is_ep_boundall, get_user, list_del, list_add_tail, sock_net]\n\n2. 函数名: sctp_sk\n- 参数: [struct sock *sk]\n- 调用者: sctp_setsockopt_auto_asconf\n- 被调用者: []\n\n3. 函数名: sctp_is_ep_boundall\n- 参数: [struct sock *sk]\n- 调用者: sctp_setsockopt_auto_asconf\n- 被调用者: []\n\n4. 函数名: get_user\n- 参数: [int val, int __user *optval]\n- 调用者: sctp_setsockopt_auto_asconf\n- 被调用者: []\n\n5. 函数名: list_del\n- 参数: [&sp->auto_asconf_list]\n- 调用者: sctp_setsockopt_auto_asconf\n- 被调用者: []\n\n6. 函数名: list_add_tail\n- 参数: [&sp->auto_asconf_list, &sock_net(sk)->sctp.auto_asconf_splist]\n- 调用者: sctp_setsockopt_auto_asconf\n- 被调用者: []\n\n7. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sctp_setsockopt_auto_asconf\n- 被调用者: []"
    },
    {
        "id": 752,
        "cwe": "CWE-362",
        "cve": "CVE-2015-3212",
        "purpose": "Code purpose:\"\"\"该代码实现了SCTP协议的socket关闭功能，包括清理接收队列、终止关联(association)以及处理TCP风格的socket关闭等待等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核的SCTP实现中，由于缺乏适当的锁保护，当多个系统调用快速连续操作socket时，会导致关联列表(list corruption)被破坏，引发竞争条件问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: sctp_close\n- 参数: [struct sock *sk, long timeout]\n- 调用者: 无（系统调用）\n- 被调用者: [sock_net, lock_sock, sctp_sk, sctp_queue_purge_ulpevents, list_for_each_safe, list_entry, sctp_style, sctp_state, sctp_unhash_established, sctp_association_free, skb_queue_empty, sock_flag, sctp_make_abort_user, sctp_primitive_ABORT, sctp_primitive_SHUTDOWN, sctp_wait_for_close, release_sock, local_bh_disable, bh_lock_sock, sock_hold, sk_common_release, bh_unlock_sock, local_bh_enable, sock_put, SCTP_DBG_OBJCNT_DEC]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n3. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n4. 函数名: sctp_sk\n- 参数: [struct sock *sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n5. 函数名: sctp_queue_purge_ulpevents\n- 参数: [&sk->sk_receive_queue], [&sctp_sk(sk)->pd_lobby]\n- 调用者: sctp_close\n- 被调用者: 无\n\n6. 函数名: list_for_each_safe\n- 参数: [pos, temp, &ep->asocs]\n- 调用者: sctp_close\n- 被调用者: 无\n\n7. 函数名: list_entry\n- 参数: [pos, struct sctp_association, asocs]\n- 调用者: sctp_close\n- 被调用者: 无\n\n8. 函数名: sctp_style\n- 参数: [sk, TCP]\n- 调用者: sctp_close\n- 被调用者: 无\n\n9. 函数名: sctp_state\n- 参数: [asoc, CLOSED]\n- 调用者: sctp_close\n- 被调用者: 无\n\n10. 函数名: sctp_unhash_established\n- 参数: [asoc]\n- 调用者: sctp_close\n- 被调用者: 无\n\n11. 函数名: sctp_association_free\n- 参数: [asoc]\n- 调用者: sctp_close\n- 被调用者: 无\n\n12. 函数名: skb_queue_empty\n- 参数: [&asoc->ulpq.lobby], [&asoc->ulpq.reasm]\n- 调用者: sctp_close\n- 被调用者: 无\n\n13. 函数名: sock_flag\n- 参数: [sk, SOCK_LINGER]\n- 调用者: sctp_close\n- 被调用者: 无\n\n14. 函数名: sctp_make_abort_user\n- 参数: [asoc, NULL, 0]\n- 调用者: sctp_close\n- 被调用者: 无\n\n15. 函数名: sctp_primitive_ABORT\n- 参数: [net, asoc, chunk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n16. 函数名: sctp_primitive_SHUTDOWN\n- 参数: [net, asoc, NULL]\n- 调用者: sctp_close\n- 被调用者: 无\n\n17. 函数名: sctp_wait_for_close\n- 参数: [sk, timeout]\n- 调用者: sctp_close\n- 被调用者: 无\n\n18. 函数名: release_sock\n- 参数: [sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n19. 函数名: local_bh_disable\n- 参数: 无\n- 调用者: sctp_close\n- 被调用者: 无\n\n20. 函数名: bh_lock_sock\n- 参数: [sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n21. 函数名: sock_hold\n- 参数: [sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n22. 函数名: sk_common_release\n- 参数: [sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n23. 函数名: bh_unlock_sock\n- 参数: [sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n24. 函数名: local_bh_enable\n- 参数: 无\n- 调用者: sctp_close\n- 被调用者: 无\n\n25. 函数名: sock_put\n- 参数: [sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n26. 函数名: SCTP_DBG_OBJCNT_DEC\n- 参数: [sock]\n- 调用者: sctp_close\n- 被调用者: 无"
    },
    {
        "id": 758,
        "cwe": "CWE-362",
        "cve": "CVE-2015-3339",
        "purpose": "Code purpose:\"\"\"该代码用于准备执行二进制程序时的权限凭证，包括处理setuid/setgid权限，确保程序以正确的用户/组权限运行\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在文件所有权被更改为root但setuid位尚未被清除的竞态条件窗口期，攻击者可执行setuid程序以提升权限\"\"\"",
        "functions": "Functions:\n1. 函数名: prepare_binprm\n- 参数: [struct linux_binprm *bprm]\n- 调用者: N/A (顶级函数)\n- 被调用者: [file_inode, current_euid, current_egid, kuid_has_mapping, kgid_has_mapping, security_bprm_set_creds, memset, kernel_read]\n\n2. 函数名: file_inode\n- 参数: [struct file *file]\n- 调用者: prepare_binprm\n- 被调用者: N/A\n\n3. 函数名: current_euid\n- 参数: []\n- 调用者: prepare_binprm\n- 被调用者: N/A\n\n4. 函数名: current_egid\n- 参数: []\n- 调用者: prepare_binprm\n- 被调用者: N/A\n\n5. 函数名: kuid_has_mapping\n- 参数: [struct user_namespace *ns, kuid_t uid]\n- 调用者: prepare_binprm\n- 被调用者: N/A\n\n6. 函数名: kgid_has_mapping\n- 参数: [struct user_namespace *ns, kgid_t gid]\n- 调用者: prepare_binprm\n- 被调用者: N/A\n\n7. 函数名: security_bprm_set_creds\n- 参数: [struct linux_binprm *bprm]\n- 调用者: prepare_binprm\n- 被调用者: N/A\n\n8. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: prepare_binprm\n- 被调用者: N/A\n\n9. 函数名: kernel_read\n- 参数: [struct file *file, loff_t offset, char *addr, unsigned long count]\n- 调用者: prepare_binprm\n- 被调用者: N/A"
    },
    {
        "id": 764,
        "cwe": "CWE-362",
        "cve": "CVE-2015-4170",
        "purpose": "Code purpose:\"\"\"该代码实现了一个原子比较交换操作，用于在信号量计数更新时检查并防止竞态条件。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于ldsem_cmpxchg函数中的竞态条件，当新tty线程在旧tty线程关闭期间建立时，会导致ldsem_down_read和ldsem_down_write死锁。\"\"\"",
        "functions": "Functions:\n1. 函数名: ldsem_cmpxchg\n- 参数: [old, new, sem]\n- 调用者: 未提供（代码片段中未显示）\n- 被调用者: [atomic_long_cmpxchg]"
    },
    {
        "id": 786,
        "cwe": "CWE-362",
        "cve": "CVE-2015-7550",
        "purpose": "Code purpose:\"\"\"该代码用于读取指定密钥的内容并返回给用户空间，同时进行权限验证和并发控制\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于keyctl_read_key函数在读取key时未正确处理信号量，导致在keyctl_revoke和keyctl_read并发调用时可能引发竞态条件，造成空指针解引用或系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: keyctl_read_key\n- 参数: [key_serial_t keyid, char __user *buffer, size_t buflen]\n- 调用者: 未指定\n- 被调用者: [lookup_user_key, key_ref_to_ptr, key_permission, is_key_possessed, key_validate, down_read, up_read, key_put]\n\n2. 函数名: lookup_user_key\n- 参数: [key_serial_t keyid, int create, int update]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定\n\n3. 函数名: key_ref_to_ptr\n- 参数: [key_ref_t key_ref]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定\n\n4. 函数名: key_permission\n- 参数: [key_ref_t key_ref, key_perm_t perm]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定\n\n5. 函数名: is_key_possessed\n- 参数: [key_ref_t key_ref]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定\n\n6. 函数名: key_validate\n- 参数: [struct key *key]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定\n\n7. 函数名: down_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定\n\n8. 函数名: up_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定\n\n9. 函数名: key_put\n- 参数: [struct key *key]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定"
    },
    {
        "id": 788,
        "cwe": "CWE-362",
        "cve": "CVE-2015-7613",
        "purpose": "Code purpose:\"\"\"在Linux内核中创建并初始化一个新的消息队列IPC对象\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPC对象实现中存在竞态条件，导致ipc_addid调用时对未初始化数据的uid和gid进行比较，可能被本地用户利用来提升权限\"\"\"",
        "functions": "Functions:\n1. 函数名: newque\n- 参数: [ns, params]\n- 调用者: 未显示\n- 被调用者: [ipc_rcu_alloc, ipc_rcu_putref, ipc_rcu_free, security_msg_queue_alloc, ipc_addid, msg_rcu_free, get_seconds, INIT_LIST_HEAD, ipc_unlock_object, rcu_read_unlock]\n\n2. 函数名: ipc_rcu_alloc\n- 参数: [sizeof(*msq)]\n- 调用者: newque\n- 被调用者: 未显示\n\n3. 函数名: ipc_rcu_putref\n- 参数: [msq, ipc_rcu_free]\n- 调用者: newque\n- 被调用者: 未显示\n\n4. 函数名: ipc_rcu_free\n- 参数: 未显示\n- 调用者: newque (通过ipc_rcu_putref)\n- 被调用者: 未显示\n\n5. 函数名: security_msg_queue_alloc\n- 参数: [msq]\n- 调用者: newque\n- 被调用者: 未显示\n\n6. 函数名: ipc_addid\n- 参数: [&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni]\n- 调用者: newque\n- 被调用者: 未显示\n\n7. 函数名: msg_rcu_free\n- 参数: 未显示\n- 调用者: newque (通过ipc_rcu_putref)\n- 被调用者: 未显示\n\n8. 函数名: get_seconds\n- 参数: []\n- 调用者: newque\n- 被调用者: 未显示\n\n9. 函数名: INIT_LIST_HEAD\n- 参数: [&msq->q_messages], [&msq->q_receivers], [&msq->q_senders]\n- 调用者: newque\n- 被调用者: 未显示\n\n10. 函数名: ipc_unlock_object\n- 参数: [&msq->q_perm]\n- 调用者: newque\n- 被调用者: 未显示\n\n11. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: newque\n- 被调用者: 未显示"
    },
    {
        "id": 789,
        "cwe": "CWE-362",
        "cve": "CVE-2015-7613",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中创建和管理System V共享内存段的功能，包括内存大小验证、权限设置和资源分配等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPC对象实现中存在竞态条件，导致ipc_addid调用时对未初始化数据的uid和gid进行比较，可能被本地用户利用来提升权限\"\"\"",
        "functions": "Functions:\n1. 函数名: newseg\n- 参数: [ns, params]\n- 调用者: N/A (top-level function)\n- 被调用者: [ipc_rcu_alloc, security_shm_alloc, ipc_rcu_putref, hstate_sizelog, huge_page_size, hugetlb_file_setup, shmem_kernel_file_setup, ipc_addid, task_tgid_vnr, get_seconds, file_inode, ipc_unlock_object, rcu_read_unlock, is_file_hugepages, user_shm_unlock, fput, shm_rcu_free]\n\n2. 函数名: ipc_rcu_alloc\n- 参数: [sizeof(*shp)]\n- 调用者: newseg\n- 被调用者: []\n\n3. 函数名: security_shm_alloc\n- 参数: [shp]\n- 调用者: newseg\n- 被调用者: []\n\n4. 函数名: ipc_rcu_putref\n- 参数: [shp, ipc_rcu_free]\n- 调用者: newseg\n- 被调用者: []\n\n5. 函数名: hstate_sizelog\n- 参数: [(shmflg >> SHM_HUGE_SHIFT) & SHM_HUGE_MASK]\n- 调用者: newseg\n- 被调用者: []\n\n6. 函数名: huge_page_size\n- 参数: [hs]\n- 调用者: newseg\n- 被调用者: []\n\n7. 函数名: hugetlb_file_setup\n- 参数: [name, hugesize, acctflag, &shp->mlock_user, HUGETLB_SHMFS_INODE, (shmflg >> SHM_HUGE_SHIFT) & SHM_HUGE_MASK]\n- 调用者: newseg\n- 被调用者: []\n\n8. 函数名: shmem_kernel_file_setup\n- 参数: [name, size, acctflag]\n- 调用者: newseg\n- 被调用者: []\n\n9. 函数名: ipc_addid\n- 参数: [&shm_ids(ns), &shp->shm_perm, ns->shm_ctlmni]\n- 调用者: newseg\n- 被调用者: []\n\n10. 函数名: task_tgid_vnr\n- 参数: [current]\n- 调用者: newseg\n- 被调用者: []\n\n11. 函数名: get_seconds\n- 参数: []\n- 调用者: newseg\n- 被调用者: []\n\n12. 函数名: file_inode\n- 参数: [file]\n- 调用者: newseg\n- 被调用者: []\n\n13. 函数名: ipc_unlock_object\n- 参数: [&shp->shm_perm]\n- 调用者: newseg\n- 被调用者: []\n\n14. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: newseg\n- 被调用者: []\n\n15. 函数名: is_file_hugepages\n- 参数: [file]\n- 调用者: newseg\n- 被调用者: []\n\n16. 函数名: user_shm_unlock\n- 参数: [size, shp->mlock_user]\n- 调用者: newseg\n- 被调用者: []\n\n17. 函数名: fput\n- 参数: [file]\n- 调用者: newseg\n- 被调用者: []\n\n18. 函数名: shm_rcu_free\n- 参数: []\n- 调用者: newseg (via ipc_rcu_putref)\n- 被调用者: []"
    },
    {
        "id": 790,
        "cwe": "CWE-362",
        "cve": "CVE-2015-7613",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中为IPC(进程间通信)对象分配ID并初始化权限信息，包括UID和GID的设置\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"竞态条件下，ipc_addid函数在未初始化数据的情况下进行uid和gid的比较，导致本地用户可能提升权限\"\"\"",
        "functions": "Functions:\n1. 函数名: ipc_addid\n- 参数: [struct ipc_ids *ids, struct kern_ipc_perm *new, int size]\n- 调用者: 未指定\n- 被调用者: [idr_preload, spin_lock_init, rcu_read_lock, spin_lock, idr_alloc, idr_preload_end, spin_unlock, rcu_read_unlock, current_euid_egid, ipcid_to_idx, ipcid_to_seqx, ipc_buildid]\n\n2. 函数名: idr_preload\n- 参数: [GFP_KERNEL]\n- 调用者: ipc_addid\n- 被调用者: 未指定\n\n3. 函数名: spin_lock_init\n- 参数: [&new->lock]\n- 调用者: ipc_addid\n- 被调用者: 未指定\n\n4. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: ipc_addid\n- 被调用者: 未指定\n\n5. 函数名: spin_lock\n- 参数: [&new->lock]\n- 调用者: ipc_addid\n- 被调用者: 未指定\n\n6. 函数名: idr_alloc\n- 参数: [&ids->ipcs_idr, new, (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0, GFP_NOWAIT]\n- 调用者: ipc_addid\n- 被调用者: 未指定\n\n7. 函数名: idr_preload_end\n- 参数: []\n- 调用者: ipc_addid\n- 被调用者: 未指定\n\n8. 函数名: spin_unlock\n- 参数: [&new->lock]\n- 调用者: ipc_addid\n- 被调用者: 未指定\n\n9. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: ipc_addid\n- 被调用者: 未指定\n\n10. 函数名: current_euid_egid\n- 参数: [&euid, &egid]\n- 调用者: ipc_addid\n- 被调用者: 未指定\n\n11. 函数名: ipcid_to_idx\n- 参数: [next_id]\n- 调用者: ipc_addid\n- 被调用者: 未指定\n\n12. 函数名: ipcid_to_seqx\n- 参数: [next_id]\n- 调用者: ipc_addid\n- 被调用者: 未指定\n\n13. 函数名: ipc_buildid\n- 参数: [id, new->seq]\n- 调用者: ipc_addid\n- 被调用者: 未指定"
    },
    {
        "id": 796,
        "cwe": "CWE-362",
        "cve": "CVE-2015-7990",
        "purpose": "Code purpose:\"\"\"创建和管理RDS(Reliable Datagram Sockets)连接，包括处理本地和远程地址的连接查找、分配和初始化，并处理可能的竞争条件\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在创建RDS连接时未正确处理并发情况下的竞态条件，导致未正确绑定的socket可能引发空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: __rds_conn_create\n- 参数: [net, laddr, faddr, trans, gfp, is_outgoing]\n- 调用者: 未显示（应为外部调用）\n- 被调用者: [rds_conn_bucket, rds_conn_lookup, rds_trans_get_preferred, rds_trans_put, trans->conn_alloc, trans->conn_free, rds_cong_get_maps, kmem_cache_zalloc, kmem_cache_free, rds_conn_net_set, rds_cong_add_conn, INIT_HLIST_NODE, spin_lock_init, init_waitqueue_head, INIT_LIST_HEAD, atomic_set, INIT_DELAYED_WORK, INIT_WORK, mutex_init, spin_lock_irqsave, spin_unlock_irqrestore, hlist_add_head_rcu]\n\n2. 函数名: rds_conn_bucket\n- 参数: [laddr, faddr]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n3. 函数名: rds_conn_lookup\n- 参数: [net, head, laddr, faddr, trans]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n4. 函数名: rds_trans_get_preferred\n- 参数: [net, faddr]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n5. 函数名: rds_trans_put\n- 参数: [loop_trans]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n6. 函数名: trans->conn_alloc\n- 参数: [conn, gfp]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n7. 函数名: trans->conn_free\n- 参数: [conn->c_transport_data]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n8. 函数名: rds_cong_get_maps\n- 参数: [conn]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n9. 函数名: kmem_cache_zalloc\n- 参数: [rds_conn_slab, gfp]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n10. 函数名: kmem_cache_free\n- 参数: [rds_conn_slab, conn]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n11. 函数名: rds_conn_net_set\n- 参数: [conn, net]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n12. 函数名: rds_cong_add_conn\n- 参数: [conn]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n13. 函数名: INIT_HLIST_NODE\n- 参数: [&conn->c_hash_node]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n14. 函数名: spin_lock_init\n- 参数: [&conn->c_lock]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n15. 函数名: init_waitqueue_head\n- 参数: [&conn->c_waitq]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n16. 函数名: INIT_LIST_HEAD\n- 参数: [&conn->c_send_queue, &conn->c_retrans]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n17. 函数名: atomic_set\n- 参数: [&conn->c_state, RDS_CONN_DOWN]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n18. 函数名: INIT_DELAYED_WORK\n- 参数: [&conn->c_send_w, rds_send_worker], [&conn->c_recv_w, rds_recv_worker], [&conn->c_conn_w, rds_connect_worker]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n19. 函数名: INIT_WORK\n- 参数: [&conn->c_down_w, rds_shutdown_worker]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n20. 函数名: mutex_init\n- 参数: [&conn->c_cm_lock]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n21. 函数名: spin_lock_irqsave\n- 参数: [&rds_conn_lock, flags]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n22. 函数名: spin_unlock_irqrestore\n- 参数: [&rds_conn_lock, flags]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示\n\n23. 函数名: hlist_add_head_rcu\n- 参数: [&conn->c_hash_node, head]\n- 调用者: __rds_conn_create\n- 被调用者: 未显示"
    },
    {
        "id": 797,
        "cwe": "CWE-362",
        "cve": "CVE-2015-7990",
        "purpose": "Code purpose:\"\"\"该代码实现了RDS(Reliable Datagram Sockets)协议中发送消息的功能，处理用户空间的消息发送请求，包括地址验证、连接管理、消息分配和传输等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于rds_sendmsg函数在未正确绑定套接字的情况下存在竞态条件，导致可能发生空指针解引用和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: rds_sendmsg\n- 参数: [struct socket *sock, struct msghdr *msg, size_t payload_len]\n- 调用者: 无（系统调用）\n- 被调用者: [rds_sk_to_rs, sock_sndtimeo, rds_rm_size, rds_message_alloc, ceil, rds_message_alloc_sgs, rds_message_copy_from_user, rds_conn_create_outgoing, sock_net, rds_cmsg_send, rds_conn_connect_if_down, rds_cong_wait, rds_send_queue_rm, rds_stats_inc, wait_event_interruptible_timeout, sk_sleep, rds_send_xmit, queue_delayed_work, rds_message_put, rds_rdma_unuse, rds_rdma_cookie_key]\n\n2. 函数名: rds_sk_to_rs\n- 参数: [struct sock *sk]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n3. 函数名: sock_sndtimeo\n- 参数: [struct sock *sk, int nonblock]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n4. 函数名: rds_rm_size\n- 参数: [struct msghdr *msg, size_t payload_len]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n5. 函数名: rds_message_alloc\n- 参数: [int ret, GFP_KERNEL]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n6. 函数名: ceil\n- 参数: [payload_len, PAGE_SIZE]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n7. 函数名: rds_message_alloc_sgs\n- 参数: [struct rds_message *rm, ceil(payload_len, PAGE_SIZE)]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n8. 函数名: rds_message_copy_from_user\n- 参数: [struct rds_message *rm, &msg->msg_iter]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n9. 函数名: rds_conn_create_outgoing\n- 参数: [sock_net(sock->sk), rs->rs_bound_addr, daddr, rs->rs_transport, sock->sk->sk_allocation]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n10. 函数名: sock_net\n- 参数: [sock->sk]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n11. 函数名: rds_cmsg_send\n- 参数: [rs, rm, msg, &allocated_mr]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n12. 函数名: rds_conn_connect_if_down\n- 参数: [conn]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n13. 函数名: rds_cong_wait\n- 参数: [conn->c_fcong, dport, nonblock, rs]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n14. 函数名: rds_send_queue_rm\n- 参数: [rs, conn, rm, rs->rs_bound_port, dport, &queued]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n15. 函数名: rds_stats_inc\n- 参数: [s_send_queue_full]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n16. 函数名: wait_event_interruptible_timeout\n- 参数: [*sk_sleep(sk), rds_send_queue_rm(rs, conn, rm, rs->rs_bound_port, dport, &queued), timeo]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n17. 函数名: sk_sleep\n- 参数: [sk]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n18. 函数名: rds_send_xmit\n- 参数: [conn]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n19. 函数名: queue_delayed_work\n- 参数: [rds_wq, &conn->c_send_w, 1]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n20. 函数名: rds_message_put\n- 参数: [rm]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n21. 函数名: rds_rdma_unuse\n- 参数: [rs, rds_rdma_cookie_key(rm->m_rdma_cookie), 1]\n- 调用者: rds_sendmsg\n- 被调用者: 无\n\n22. 函数名: rds_rdma_cookie_key\n- 参数: [rm->m_rdma_cookie]\n- 调用者: rds_sendmsg\n- 被调用者: 无"
    },
    {
        "id": 840,
        "cwe": "CWE-362",
        "cve": "CVE-2015-8767",
        "purpose": "Code purpose:\"\"\"该代码用于处理SCTP协议中T3重传定时器到期事件，包括检查socket状态、执行状态机处理以及释放相关资源。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中sctp_generate_t3_rtx_event函数未正确处理锁与socket之间的关系，导致在特定条件下可能引发死锁\"\"\"",
        "functions": "Functions:\n1. 函数名: sctp_generate_t3_rtx_event\n- 参数: [unsigned long peer]\n- 调用者: N/A (top-level function)\n- 被调用者: [sock_net, bh_lock_sock, sock_owned_by_user, pr_debug, mod_timer, sctp_transport_hold, sctp_do_sm, bh_unlock_sock, sctp_transport_put]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_t3_rtx_event\n- 被调用者: []\n\n3. 函数名: bh_lock_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_t3_rtx_event\n- 被调用者: []\n\n4. 函数名: sock_owned_by_user\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_t3_rtx_event\n- 被调用者: []\n\n5. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: sctp_generate_t3_rtx_event\n- 被调用者: []\n\n6. 函数名: mod_timer\n- 参数: [struct timer_list *timer, unsigned long expires]\n- 调用者: sctp_generate_t3_rtx_event\n- 被调用者: []\n\n7. 函数名: sctp_transport_hold\n- 参数: [struct sctp_transport *transport]\n- 调用者: sctp_generate_t3_rtx_event\n- 被调用者: []\n\n8. 函数名: sctp_do_sm\n- 参数: [struct net *net, sctp_event_t event_type, sctp_subtype_t subtype, int state, struct sctp_endpoint *ep, struct sctp_association *asoc, void *event_arg, gfp_t gfp]\n- 调用者: sctp_generate_t3_rtx_event\n- 被调用者: []\n\n9. 函数名: bh_unlock_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_t3_rtx_event\n- 被调用者: []\n\n10. 函数名: sctp_transport_put\n- 参数: [struct sctp_transport *transport]\n- 调用者: sctp_generate_t3_rtx_event\n- 被调用者: []"
    },
    {
        "id": 841,
        "cwe": "CWE-362",
        "cve": "CVE-2015-8767",
        "purpose": "Code purpose:\"\"\"处理SCTP协议中ICMP协议不可达事件，包括锁管理和定时器重试机制\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确处理锁与socket之间的关系，在sock_owned_by_user检查后仍可能发生竞争条件，导致死锁\"\"\"",
        "functions": "Functions:\n1. 函数名: sctp_generate_proto_unreach_event\n- 参数: [unsigned long data]\n- 调用者: 未显示（由定时器或其他上下文调用）\n- 被调用者: [sock_net, bh_lock_sock, sock_owned_by_user, pr_debug, mod_timer, sctp_association_hold, sctp_do_sm, bh_unlock_sock, sctp_association_put]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_proto_unreach_event\n- 被调用者: []\n\n3. 函数名: bh_lock_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_proto_unreach_event\n- 被调用者: []\n\n4. 函数名: sock_owned_by_user\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_proto_unreach_event\n- 被调用者: []\n\n5. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: sctp_generate_proto_unreach_event\n- 被调用者: []\n\n6. 函数名: mod_timer\n- 参数: [struct timer_list *timer, unsigned long expires]\n- 调用者: sctp_generate_proto_unreach_event\n- 被调用者: []\n\n7. 函数名: sctp_association_hold\n- 参数: [struct sctp_association *asoc]\n- 调用者: sctp_generate_proto_unreach_event\n- 被调用者: []\n\n8. 函数名: sctp_do_sm\n- 参数: [struct net *net, enum sctp_event_type event_type, union sctp_subtype subtype, enum sctp_state state, struct sctp_endpoint *ep, struct sctp_association *asoc, void *event_arg, gfp_t gfp]\n- 调用者: sctp_generate_proto_unreach_event\n- 被调用者: []\n\n9. 函数名: bh_unlock_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_proto_unreach_event\n- 被调用者: []\n\n10. 函数名: sctp_association_put\n- 参数: [struct sctp_association *asoc]\n- 调用者: sctp_generate_proto_unreach_event\n- 被调用者: []"
    },
    {
        "id": 842,
        "cwe": "CWE-362",
        "cve": "CVE-2015-8767",
        "purpose": "Code purpose:\"\"\"该代码用于处理SCTP协议关联中的超时事件，包括锁定套接字、检查关联状态、执行状态机处理以及释放资源等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在SCTP协议实现中，未能正确处理锁与socket之间的关系，导致在特定情况下(如sctp_accept调用)可能引发死锁\"\"\"",
        "functions": "Functions:\n1. 函数名: sctp_generate_timeout_event\n- 参数: [struct sctp_association *asoc, sctp_event_timeout_t timeout_type]\n- 调用者: 未显示（由定时器或事件触发）\n- 被调用者: [sock_net, bh_lock_sock, sock_owned_by_user, pr_debug, mod_timer, sctp_association_hold, sctp_do_sm, bh_unlock_sock, sctp_association_put]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_timeout_event\n- 被调用者: []\n\n3. 函数名: bh_lock_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_timeout_event\n- 被调用者: []\n\n4. 函数名: sock_owned_by_user\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_timeout_event\n- 被调用者: []\n\n5. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: sctp_generate_timeout_event\n- 被调用者: []\n\n6. 函数名: mod_timer\n- 参数: [struct timer_list *timer, unsigned long expires]\n- 调用者: sctp_generate_timeout_event\n- 被调用者: []\n\n7. 函数名: sctp_association_hold\n- 参数: [struct sctp_association *asoc]\n- 调用者: sctp_generate_timeout_event\n- 被调用者: []\n\n8. 函数名: sctp_do_sm\n- 参数: [struct net *net, sctp_event_t event_type, sctp_subtype_t subtype, int state, struct sctp_endpoint *ep, struct sctp_association *asoc, void *event_arg, gfp_t gfp]\n- 调用者: sctp_generate_timeout_event\n- 被调用者: []\n\n9. 函数名: bh_unlock_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_timeout_event\n- 被调用者: []\n\n10. 函数名: sctp_association_put\n- 参数: [struct sctp_association *asoc]\n- 调用者: sctp_generate_timeout_event\n- 被调用者: []"
    },
    {
        "id": 843,
        "cwe": "CWE-362",
        "cve": "CVE-2015-8767",
        "purpose": "Code purpose:\"\"\"该代码用于处理SCTP协议中的心跳事件，包括心跳超时检测和关联状态管理，但存在锁与socket关系管理不当的问题\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在4.3之前版本中，SCTP协议实现未能正确处理锁与套接字之间的关系，导致本地用户可通过特制的sctp_accept调用造成死锁\"\"\"",
        "functions": "Functions:\n1. 函数名: sctp_generate_heartbeat_event\n- 参数: [unsigned long data]\n- 调用者: N/A (timer callback)\n- 被调用者: [sock_net, bh_lock_sock, sock_owned_by_user, pr_debug, mod_timer, sctp_transport_hold, sctp_do_sm, bh_unlock_sock, sctp_transport_put]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_heartbeat_event\n- 被调用者: []\n\n3. 函数名: bh_lock_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_heartbeat_event\n- 被调用者: []\n\n4. 函数名: sock_owned_by_user\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_heartbeat_event\n- 被调用者: []\n\n5. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: sctp_generate_heartbeat_event\n- 被调用者: []\n\n6. 函数名: mod_timer\n- 参数: [struct timer_list *timer, unsigned long expires]\n- 调用者: sctp_generate_heartbeat_event\n- 被调用者: []\n\n7. 函数名: sctp_transport_hold\n- 参数: [struct sctp_transport *transport]\n- 调用者: sctp_generate_heartbeat_event\n- 被调用者: []\n\n8. 函数名: sctp_do_sm\n- 参数: [struct net *net, sctp_event_t event_type, sctp_subtype_t subtype, int state, struct sctp_endpoint *ep, struct sctp_association *asoc, void *event_arg, gfp_t gfp]\n- 调用者: sctp_generate_heartbeat_event\n- 被调用者: []\n\n9. 函数名: bh_unlock_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_generate_heartbeat_event\n- 被调用者: []\n\n10. 函数名: sctp_transport_put\n- 参数: [struct sctp_transport *transport]\n- 调用者: sctp_generate_heartbeat_event\n- 被调用者: []"
    },
    {
        "id": 850,
        "cwe": "CWE-362",
        "cve": "CVE-2015-8839",
        "purpose": "Code purpose:\"\"\"该代码实现了ext4文件系统中对文件指定范围进行清零操作的功能，包括处理未对齐的边缘、预分配空间、转换未写入的块以及更新inode信息等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于ext4_zero_range函数在处理文件空洞和页面错误时存在未同步的竞争条件，导致本地用户可能写入其他用户文件的关联页面，造成磁盘损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_zero_range\n- 参数: [file, offset, len, mode]\n- 调用者: N/A (系统调用或文件操作接口)\n- 被调用者: [file_inode, trace_ext4_zero_range, ext4_should_journal_data, ext4_force_commit, mapping_tagged, filemap_write_and_wait_range, round_up, round_down, ext4_test_inode_flag, i_size_read, inode_newsize_ok, ext4_alloc_file_blocks, truncate_pagecache_range, ext4_current_time, ext4_inode_block_unlocked_dio, inode_dio_wait, ext4_ext_index_trans_blocks, ext4_journal_start, ext4_std_error, ext4_update_inode_size, ext4_set_inode_flag, ext4_mark_inode_dirty, ext4_zero_partial_blocks, ext4_handle_sync, ext4_journal_stop, ext4_inode_resume_unlocked_dio, mutex_unlock]\n\n2. 函数名: file_inode\n- 参数: [file]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n3. 函数名: trace_ext4_zero_range\n- 参数: [inode, offset, len, mode]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n4. 函数名: ext4_should_journal_data\n- 参数: [inode]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n5. 函数名: ext4_force_commit\n- 参数: [inode->i_sb]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n6. 函数名: mapping_tagged\n- 参数: [mapping, PAGECACHE_TAG_DIRTY]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n7. 函数名: filemap_write_and_wait_range\n- 参数: [mapping, offset, offset + len - 1]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n8. 函数名: round_up\n- 参数: [offset, 1 << blkbits]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n9. 函数名: round_down\n- 参数: [offset + len, 1 << blkbits]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n10. 函数名: ext4_test_inode_flag\n- 参数: [inode, EXT4_INODE_EXTENTS]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n11. 函数名: i_size_read\n- 参数: [inode]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n12. 函数名: inode_newsize_ok\n- 参数: [inode, new_size]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n13. 函数名: ext4_alloc_file_blocks\n- 参数: [file, lblk, max_blocks, new_size, flags, mode]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n14. 函数名: truncate_pagecache_range\n- 参数: [inode, start, end - 1]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n15. 函数名: ext4_current_time\n- 参数: [inode]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n16. 函数名: ext4_inode_block_unlocked_dio\n- 参数: [inode]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n17. 函数名: inode_dio_wait\n- 参数: [inode]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n18. 函数名: ext4_ext_index_trans_blocks\n- 参数: [inode, 2]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n19. 函数名: ext4_journal_start\n- 参数: [inode, EXT4_HT_MISC, credits]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n20. 函数名: ext4_std_error\n- 参数: [inode->i_sb, ret]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n21. 函数名: ext4_update_inode_size\n- 参数: [inode, new_size]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n22. 函数名: ext4_set_inode_flag\n- 参数: [inode, EXT4_INODE_EOFBLOCKS]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n23. 函数名: ext4_mark_inode_dirty\n- 参数: [handle, inode]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n24. 函数名: ext4_zero_partial_blocks\n- 参数: [handle, inode, offset, len]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n25. 函数名: ext4_handle_sync\n- 参数: [handle]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n26. 函数名: ext4_journal_stop\n- 参数: [handle]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n27. 函数名: ext4_inode_resume_unlocked_dio\n- 参数: [inode]\n- 调用者: ext4_zero_range\n- 被调用者: N/A\n\n28. 函数名: mutex_unlock\n- 参数: [&inode->i_mutex]\n- 调用者: ext4_zero_range\n- 被调用者: N/A"
    },
    {
        "id": 851,
        "cwe": "CWE-362",
        "cve": "CVE-2015-8839",
        "purpose": "Code purpose:\"\"\"该代码实现了ext4文件系统中折叠范围(fcollapse)的功能，用于将文件指定范围内的数据块移除并将后续数据前移，从而减少文件大小。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核ext4文件系统在处理空洞打孔和页面错误时存在未同步的竞争条件，导致不同用户的文件页面可能被错误写入，造成磁盘损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_collapse_range\n- 参数: [struct inode *inode, loff_t offset, loff_t len]\n- 调用者: N/A\n- 被调用者: [ext4_test_inode_flag, ext4_force_commit, filemap_write_and_wait_range, mutex_lock, i_size_read, truncate_pagecache, ext4_inode_block_unlocked_dio, inode_dio_wait, ext4_writepage_trans_blocks, ext4_journal_start, ext4_discard_preallocations, ext4_es_remove_extent, ext4_ext_remove_space, ext4_ext_shift_extents, i_size_write, ext4_handle_sync, ext4_current_time, ext4_mark_inode_dirty, ext4_journal_stop, ext4_inode_resume_unlocked_dio, mutex_unlock]\n\n2. 函数名: ext4_test_inode_flag\n- 参数: [struct inode *inode, int flag]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n3. 函数名: ext4_force_commit\n- 参数: [struct super_block *sb]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n4. 函数名: filemap_write_and_wait_range\n- 参数: [struct address_space *mapping, loff_t start, loff_t end]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n5. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n6. 函数名: i_size_read\n- 参数: [struct inode *inode]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n7. 函数名: truncate_pagecache\n- 参数: [struct inode *inode, loff_t newsize]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n8. 函数名: ext4_inode_block_unlocked_dio\n- 参数: [struct inode *inode]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n9. 函数名: inode_dio_wait\n- 参数: [struct inode *inode]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n10. 函数名: ext4_writepage_trans_blocks\n- 参数: [struct inode *inode]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n11. 函数名: ext4_journal_start\n- 参数: [struct inode *inode, int type, int nblocks]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n12. 函数名: ext4_discard_preallocations\n- 参数: [struct inode *inode]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n13. 函数名: ext4_es_remove_extent\n- 参数: [struct inode *inode, ext4_lblk_t lblk, ext4_lblk_t len]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n14. 函数名: ext4_ext_remove_space\n- 参数: [struct inode *inode, ext4_lblk_t start, ext4_lblk_t end]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n15. 函数名: ext4_ext_shift_extents\n- 参数: [struct inode *inode, handle_t *handle, ext4_lblk_t start, ext4_lblk_t shift, enum SHIFT_DIRECTION direction]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n16. 函数名: i_size_write\n- 参数: [struct inode *inode, loff_t newsize]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n17. 函数名: ext4_handle_sync\n- 参数: [handle_t *handle]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n18. 函数名: ext4_current_time\n- 参数: [struct inode *inode]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n19. 函数名: ext4_mark_inode_dirty\n- 参数: [handle_t *handle, struct inode *inode]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n20. 函数名: ext4_journal_stop\n- 参数: [handle_t *handle]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n21. 函数名: ext4_inode_resume_unlocked_dio\n- 参数: [struct inode *inode]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A\n\n22. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: ext4_collapse_range\n- 被调用者: N/A"
    },
    {
        "id": 852,
        "cwe": "CWE-362",
        "cve": "CVE-2015-8839",
        "purpose": "Code purpose:\"\"\"该代码实现了ext4文件系统中插入范围(insert range)的功能，用于在文件中插入空白空间而不覆盖现有数据，同时处理相关的文件系统操作和同步问题。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于ext4文件系统在处理空洞打孔和页面错误时存在未同步的竞争条件，导致本地用户可能写入其他用户文件关联的页面，造成磁盘损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_insert_range\n- 参数: [struct inode *inode, loff_t offset, loff_t len]\n- 调用者: N/A (top-level function)\n- 被调用者: [ext4_test_inode_flag, ext4_force_commit, filemap_write_and_wait_range, mutex_lock, i_size_read, truncate_pagecache, ext4_inode_block_unlocked_dio, inode_dio_wait, ext4_writepage_trans_blocks, ext4_journal_start, ext4_current_time, ext4_mark_inode_dirty, down_write, ext4_discard_preallocations, ext4_find_extent, ext_depth, ext4_ext_get_actual_len, ext4_ext_is_unwritten, ext4_split_extent_at, ext4_ext_drop_refs, kfree, ext4_es_remove_extent, ext4_ext_shift_extents, ext4_handle_sync, ext4_journal_stop, ext4_inode_resume_unlocked_dio, mutex_unlock]\n\n2. 函数名: ext4_test_inode_flag\n- 参数: [struct inode *inode, int flag]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n3. 函数名: ext4_force_commit\n- 参数: [struct super_block *sb]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n4. 函数名: filemap_write_and_wait_range\n- 参数: [struct address_space *mapping, loff_t start, loff_t end]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n5. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n6. 函数名: i_size_read\n- 参数: [struct inode *inode]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n7. 函数名: truncate_pagecache\n- 参数: [struct inode *inode, loff_t new]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n8. 函数名: ext4_inode_block_unlocked_dio\n- 参数: [struct inode *inode]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n9. 函数名: inode_dio_wait\n- 参数: [struct inode *inode]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n10. 函数名: ext4_writepage_trans_blocks\n- 参数: [struct inode *inode]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n11. 函数名: ext4_journal_start\n- 参数: [struct inode *inode, int type, int nblocks]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n12. 函数名: ext4_current_time\n- 参数: [struct inode *inode]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n13. 函数名: ext4_mark_inode_dirty\n- 参数: [handle_t *handle, struct inode *inode]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n14. 函数名: down_write\n- 参数: [struct rw_semaphore *sem]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n15. 函数名: ext4_discard_preallocations\n- 参数: [struct inode *inode]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n16. 函数名: ext4_find_extent\n- 参数: [struct inode *inode, ext4_lblk_t block, struct ext4_ext_path **path, int flags]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n17. 函数名: ext_depth\n- 参数: [struct inode *inode]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n18. 函数名: ext4_ext_get_actual_len\n- 参数: [struct ext4_extent *extent]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n19. 函数名: ext4_ext_is_unwritten\n- 参数: [struct ext4_extent *extent]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n20. 函数名: ext4_split_extent_at\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_ext_path **path, ext4_lblk_t split, int split_flag, int flags]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n21. 函数名: ext4_ext_drop_refs\n- 参数: [struct ext4_ext_path *path]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n22. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n23. 函数名: ext4_es_remove_extent\n- 参数: [struct inode *inode, ext4_lblk_t lblk, ext4_lblk_t len]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n24. 函数名: ext4_ext_shift_extents\n- 参数: [struct inode *inode, handle_t *handle, ext4_lblk_t start, ext4_lblk_t len, int mode]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n25. 函数名: ext4_handle_sync\n- 参数: [handle_t *handle]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n26. 函数名: ext4_journal_stop\n- 参数: [handle_t *handle]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n27. 函数名: ext4_inode_resume_unlocked_dio\n- 参数: [struct inode *inode]\n- 调用者: ext4_insert_range\n- 被调用者: N/A\n\n28. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: ext4_insert_range\n- 被调用者: N/A"
    },
    {
        "id": 853,
        "cwe": "CWE-362",
        "cve": "CVE-2015-8839",
        "purpose": "Code purpose:\"\"\"处理ext4文件系统中DAX(Direct Access)模式下的页面错误，包括写入时的日志记录和块分配操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于ext4文件系统在处理写操作和页错误时存在未同步的竞争条件，导致不同用户的文件页面可能被错误写入，从而引发磁盘损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_dax_fault\n- 参数: [vma, vmf]\n- 调用者: 未显示\n- 被调用者: [file_inode, sb_start_pagefault, file_update_time, ext4_journal_start_sb, IS_ERR, __dax_fault, ext4_journal_stop, sb_end_pagefault]\n\n2. 函数名: file_inode\n- 参数: [vma->vm_file]\n- 调用者: ext4_dax_fault\n- 被调用者: 未显示\n\n3. 函数名: sb_start_pagefault\n- 参数: [sb]\n- 调用者: ext4_dax_fault\n- 被调用者: 未显示\n\n4. 函数名: file_update_time\n- 参数: [vma->vm_file]\n- 调用者: ext4_dax_fault\n- 被调用者: 未显示\n\n5. 函数名: ext4_journal_start_sb\n- 参数: [sb, EXT4_HT_WRITE_PAGE, EXT4_DATA_TRANS_BLOCKS(sb)]\n- 调用者: ext4_dax_fault\n- 被调用者: 未显示\n\n6. 函数名: IS_ERR\n- 参数: [handle]\n- 调用者: ext4_dax_fault\n- 被调用者: 未显示\n\n7. 函数名: __dax_fault\n- 参数: [vma, vmf, ext4_get_block_dax, ext4_end_io_unwritten]\n- 调用者: ext4_dax_fault\n- 被调用者: 未显示\n\n8. 函数名: ext4_journal_stop\n- 参数: [handle]\n- 调用者: ext4_dax_fault\n- 被调用者: 未显示\n\n9. 函数名: sb_end_pagefault\n- 参数: [sb]\n- 调用者: ext4_dax_fault\n- 被调用者: 未显示"
    },
    {
        "id": 854,
        "cwe": "CWE-362",
        "cve": "CVE-2015-8839",
        "purpose": "Code purpose:\"\"\"该代码实现了ext4文件系统中DAX(Direct Access)模式下处理写时复制(COW)页面错误的mkwrite操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于ext4文件系统在处理写操作时存在竞争条件，导致不同用户的文件页面在未同步的洞打孔和页面错误处理后被错误写入，从而引发磁盘损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_dax_mkwrite\n- 参数: [vma, vmf]\n- 调用者: 未显示\n- 被调用者: [dax_mkwrite, ext4_get_block_dax, ext4_end_io_unwritten]\n\n2. 函数名: dax_mkwrite\n- 参数: [vma, vmf, ext4_get_block_dax, ext4_end_io_unwritten]\n- 调用者: ext4_dax_mkwrite\n- 被调用者: 未显示\n\n3. 函数名: ext4_get_block_dax\n- 参数: 未显示\n- 调用者: dax_mkwrite\n- 被调用者: 未显示\n\n4. 函数名: ext4_end_io_unwritten\n- 参数: 未显示\n- 调用者: dax_mkwrite\n- 被调用者: 未显示"
    },
    {
        "id": 855,
        "cwe": "CWE-362",
        "cve": "CVE-2015-8839",
        "purpose": "Code purpose:\"\"\"处理ext4文件系统中DAX(直接访问)模式下的大页(PMD)页面错误，包括写入时的日志记录和块分配\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4文件系统中，由于未正确处理页面错误和空洞打孔操作之间的竞争条件，导致本地用户可能通过写入与不同用户文件关联的页面造成磁盘损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_dax_pmd_fault\n- 参数: [struct vm_area_struct *vma, unsigned long addr, pmd_t *pmd, unsigned int flags]\n- 调用者: 未指定\n- 被调用者: [file_inode, sb_start_pagefault, file_update_time, ext4_journal_start_sb, ext4_chunk_trans_blocks, IS_ERR, __dax_pmd_fault, ext4_get_block_dax, ext4_end_io_unwritten, ext4_journal_stop, sb_end_pagefault]\n\n2. 函数名: file_inode\n- 参数: [struct file *file]\n- 调用者: ext4_dax_pmd_fault\n- 被调用者: 未指定\n\n3. 函数名: sb_start_pagefault\n- 参数: [struct super_block *sb]\n- 调用者: ext4_dax_pmd_fault\n- 被调用者: 未指定\n\n4. 函数名: file_update_time\n- 参数: [struct file *file]\n- 调用者: ext4_dax_pmd_fault\n- 被调用者: 未指定\n\n5. 函数名: ext4_journal_start_sb\n- 参数: [struct super_block *sb, int type, int nblocks]\n- 调用者: ext4_dax_pmd_fault\n- 被调用者: 未指定\n\n6. 函数名: ext4_chunk_trans_blocks\n- 参数: [struct inode *inode, int nrblocks]\n- 调用者: ext4_dax_pmd_fault\n- 被调用者: 未指定\n\n7. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: ext4_dax_pmd_fault\n- 被调用者: 未指定\n\n8. 函数名: __dax_pmd_fault\n- 参数: [struct vm_area_struct *vma, unsigned long addr, pmd_t *pmd, unsigned int flags, get_block_t get_block, dax_iodone_t complete_unwritten]\n- 调用者: ext4_dax_pmd_fault\n- 被调用者: 未指定\n\n9. 函数名: ext4_get_block_dax\n- 参数: 未指定\n- 调用者: ext4_dax_pmd_fault (通过参数传递)\n- 被调用者: 未指定\n\n10. 函数名: ext4_end_io_unwritten\n- 参数: 未指定\n- 调用者: ext4_dax_pmd_fault (通过参数传递)\n- 被调用者: 未指定\n\n11. 函数名: ext4_journal_stop\n- 参数: [handle_t *handle]\n- 调用者: ext4_dax_pmd_fault\n- 被调用者: 未指定\n\n12. 函数名: sb_end_pagefault\n- 参数: [struct super_block *sb]\n- 调用者: ext4_dax_pmd_fault\n- 被调用者: 未指定"
    },
    {
        "id": 856,
        "cwe": "CWE-362",
        "cve": "CVE-2015-8839",
        "purpose": "Code purpose:\"\"\"该代码实现了ext4文件系统中打孔(hole punching)功能，用于在文件中创建空洞，释放指定偏移量和长度的磁盘空间。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4文件系统中，由于未正确处理hole punching操作与页面错误处理之间的同步问题，导致不同用户的文件写入操作可能发生竞争条件，从而引发磁盘损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_punch_hole\n- 参数: [inode, offset, length]\n- 调用者: N/A (top-level function)\n- 被调用者: [S_ISREG, trace_ext4_punch_hole, filemap_write_and_wait_range, mutex_lock, ext4_inode_attach_jinode, round_up, round_down, truncate_pagecache_range, ext4_inode_block_unlocked_dio, inode_dio_wait, ext4_test_inode_flag, ext4_writepage_trans_blocks, ext4_blocks_for_truncate, ext4_journal_start, ext4_zero_partial_blocks, ext4_journal_stop, ext4_std_error, ext4_discard_preallocations, ext4_es_remove_extent, ext4_ext_remove_space, ext4_ind_remove_space, ext4_handle_sync, ext4_current_time, ext4_mark_inode_dirty, ext4_inode_resume_unlocked_dio, mutex_unlock]\n\n2. 函数名: S_ISREG\n- 参数: [inode->i_mode]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n3. 函数名: trace_ext4_punch_hole\n- 参数: [inode, offset, length, 0]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n4. 函数名: filemap_write_and_wait_range\n- 参数: [mapping, offset, offset + length - 1]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n5. 函数名: mutex_lock\n- 参数: [&inode->i_mutex]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n6. 函数名: ext4_inode_attach_jinode\n- 参数: [inode]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n7. 函数名: round_up\n- 参数: [offset, sb->s_blocksize]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n8. 函数名: round_down\n- 参数: [(offset + length), sb->s_blocksize]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n9. 函数名: truncate_pagecache_range\n- 参数: [inode, first_block_offset, last_block_offset]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n10. 函数名: ext4_inode_block_unlocked_dio\n- 参数: [inode]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n11. 函数名: inode_dio_wait\n- 参数: [inode]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n12. 函数名: ext4_test_inode_flag\n- 参数: [inode, EXT4_INODE_EXTENTS]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n13. 函数名: ext4_writepage_trans_blocks\n- 参数: [inode]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n14. 函数名: ext4_blocks_for_truncate\n- 参数: [inode]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n15. 函数名: ext4_journal_start\n- 参数: [inode, EXT4_HT_TRUNCATE, credits]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n16. 函数名: ext4_zero_partial_blocks\n- 参数: [handle, inode, offset, length]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n17. 函数名: ext4_journal_stop\n- 参数: [handle]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n18. 函数名: ext4_std_error\n- 参数: [sb, ret]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n19. 函数名: ext4_discard_preallocations\n- 参数: [inode]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n20. 函数名: ext4_es_remove_extent\n- 参数: [inode, first_block, stop_block - first_block]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n21. 函数名: ext4_ext_remove_space\n- 参数: [inode, first_block, stop_block - 1]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n22. 函数名: ext4_ind_remove_space\n- 参数: [handle, inode, first_block, stop_block]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n23. 函数名: ext4_handle_sync\n- 参数: [handle]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n24. 函数名: ext4_current_time\n- 参数: [inode]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n25. 函数名: ext4_mark_inode_dirty\n- 参数: [handle, inode]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n26. 函数名: ext4_inode_resume_unlocked_dio\n- 参数: [inode]\n- 调用者: ext4_punch_hole\n- 被调用者: []\n\n27. 函数名: mutex_unlock\n- 参数: [&inode->i_mutex]\n- 调用者: ext4_punch_hole\n- 被调用者: []"
    },
    {
        "id": 857,
        "cwe": "CWE-362",
        "cve": "CVE-2015-8839",
        "purpose": "Code purpose:\"\"\"该代码实现了ext4文件系统中文件属性修改的功能，包括权限、所有者、文件大小等属性的变更处理，并涉及磁盘空间管理和日志记录等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核ext4文件系统中存在未同步的页错误处理和空洞打孔操作，导致不同用户的文件页面写入竞争条件，可能引发磁盘损坏\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_setattr\n- 参数: [struct dentry *dentry, struct iattr *attr]\n- 调用者: N/A (kernel-level function)\n- 被调用者: [d_inode, inode_change_ok, is_quota_modification, dquot_initialize, uid_eq, gid_eq, ext4_journal_start, PTR_ERR, dquot_transfer, ext4_journal_stop, ext4_mark_inode_dirty, ext4_test_inode_flag, ext4_should_order_data, ext4_begin_ordered_truncate, ext4_orphan_add, ext4_current_time, down_write, up_write, i_size_write, ext4_orphan_del, pagecache_isize_extended, ext4_should_journal_data, ext4_inode_block_unlocked_dio, inode_dio_wait, ext4_inode_resume_unlocked_dio, ext4_wait_for_tail_page_commit, truncate_pagecache, ext4_truncate, setattr_copy, mark_inode_dirty, posix_acl_chmod, ext4_std_error]\n\n2. 函数名: d_inode\n- 参数: [struct dentry *dentry]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n3. 函数名: inode_change_ok\n- 参数: [struct inode *inode, struct iattr *attr]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n4. 函数名: is_quota_modification\n- 参数: [struct inode *inode, struct iattr *attr]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n5. 函数名: dquot_initialize\n- 参数: [struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n6. 函数名: uid_eq\n- 参数: [kuid_t left, kuid_t right]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n7. 函数名: gid_eq\n- 参数: [kgid_t left, kgid_t right]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n8. 函数名: ext4_journal_start\n- 参数: [struct inode *inode, int type, int nblocks]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n9. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n10. 函数名: dquot_transfer\n- 参数: [struct inode *inode, struct iattr *attr]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n11. 函数名: ext4_journal_stop\n- 参数: [handle_t *handle]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n12. 函数名: ext4_mark_inode_dirty\n- 参数: [handle_t *handle, struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n13. 函数名: ext4_test_inode_flag\n- 参数: [struct inode *inode, int flag]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n14. 函数名: ext4_should_order_data\n- 参数: [struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n15. 函数名: ext4_begin_ordered_truncate\n- 参数: [struct inode *inode, loff_t new_size]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n16. 函数名: ext4_orphan_add\n- 参数: [handle_t *handle, struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n17. 函数名: ext4_current_time\n- 参数: [struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n18. 函数名: down_write\n- 参数: [struct rw_semaphore *sem]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n19. 函数名: up_write\n- 参数: [struct rw_semaphore *sem]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n20. 函数名: i_size_write\n- 参数: [struct inode *inode, loff_t i_size]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n21. 函数名: ext4_orphan_del\n- 参数: [handle_t *handle, struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n22. 函数名: pagecache_isize_extended\n- 参数: [struct inode *inode, loff_t from, loff_t to]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n23. 函数名: ext4_should_journal_data\n- 参数: [struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n24. 函数名: ext4_inode_block_unlocked_dio\n- 参数: [struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n25. 函数名: inode_dio_wait\n- 参数: [struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n26. 函数名: ext4_inode_resume_unlocked_dio\n- 参数: [struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n27. 函数名: ext4_wait_for_tail_page_commit\n- 参数: [struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n28. 函数名: truncate_pagecache\n- 参数: [struct inode *inode, loff_t new]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n29. 函数名: ext4_truncate\n- 参数: [struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n30. 函数名: setattr_copy\n- 参数: [struct inode *inode, const struct iattr *attr]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n31. 函数名: mark_inode_dirty\n- 参数: [struct inode *inode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n32. 函数名: posix_acl_chmod\n- 参数: [struct inode *inode, umode_t mode]\n- 调用者: ext4_setattr\n- 被调用者: N/A\n\n33. 函数名: ext4_std_error\n- 参数: [struct super_block *sb, int error]\n- 调用者: ext4_setattr\n- 被调用者: N/A"
    },
    {
        "id": 858,
        "cwe": "CWE-362",
        "cve": "CVE-2015-8839",
        "purpose": "Code purpose:\"\"\"处理ext4文件系统中页面写入请求，确保在页面写入时正确处理文件大小变化和缓冲区映射，防止数据损坏。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于ext4文件系统在处理页面写入和空洞打孔操作时存在竞争条件，导致不同用户的文件页面可能被错误写入，造成磁盘数据损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_page_mkwrite\n- 参数: [struct vm_area_struct *vma, struct vm_fault *vmf]\n- 调用者: N/A (内核调用)\n- 被调用者: [sb_start_pagefault, file_update_time, test_opt, ext4_should_journal_data, ext4_nonda_switch, block_page_mkwrite, ext4_should_retry_alloc, i_size_read, page_has_buffers, ext4_walk_page_buffers, wait_for_stable_page, ext4_should_dioread_nolock, ext4_journal_start, ext4_writepage_trans_blocks, ext4_set_inode_state, ext4_journal_stop, block_page_mkwrite_return, sb_end_pagefault]\n\n2. 函数名: sb_start_pagefault\n- 参数: [struct super_block *sb]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n3. 函数名: file_update_time\n- 参数: [struct file *file]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n4. 函数名: test_opt\n- 参数: [struct super_block *sb, int opt]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n5. 函数名: ext4_should_journal_data\n- 参数: [struct inode *inode]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n6. 函数名: ext4_nonda_switch\n- 参数: [struct super_block *sb]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n7. 函数名: block_page_mkwrite\n- 参数: [struct vm_area_struct *vma, struct vm_fault *vmf, get_block_t *get_block]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n8. 函数名: ext4_should_retry_alloc\n- 参数: [struct super_block *sb, int *retries]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n9. 函数名: i_size_read\n- 参数: [struct inode *inode]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n10. 函数名: page_has_buffers\n- 参数: [struct page *page]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n11. 函数名: ext4_walk_page_buffers\n- 参数: [handle_t *handle, struct buffer_head *head, unsigned from, unsigned to, int *partial, int (*fn)(handle_t *, struct buffer_head *, int))]\n- 调用者: ext4_page_mkwrite\n- 被调用者: [ext4_bh_unmapped, do_journal_get_write_access]\n\n12. 函数名: wait_for_stable_page\n- 参数: [struct page *page]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n13. 函数名: ext4_should_dioread_nolock\n- 参数: [struct inode *inode]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n14. 函数名: ext4_journal_start\n- 参数: [struct inode *inode, int type, int nblocks]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n15. 函数名: ext4_writepage_trans_blocks\n- 参数: [struct inode *inode]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n16. 函数名: ext4_set_inode_state\n- 参数: [struct inode *inode, unsigned int state]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n17. 函数名: ext4_journal_stop\n- 参数: [handle_t *handle]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n18. 函数名: block_page_mkwrite_return\n- 参数: [int ret]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n19. 函数名: sb_end_pagefault\n- 参数: [struct super_block *sb]\n- 调用者: ext4_page_mkwrite\n- 被调用者: []\n\n20. 函数名: ext4_bh_unmapped\n- 参数: [handle_t *handle, struct buffer_head *bh, int flags]\n- 调用者: ext4_walk_page_buffers\n- 被调用者: []\n\n21. 函数名: do_journal_get_write_access\n- 参数: [handle_t *handle, struct buffer_head *bh, int flags]\n- 调用者: ext4_walk_page_buffers\n- 被调用者: []"
    },
    {
        "id": 859,
        "cwe": "CWE-362",
        "cve": "CVE-2015-8839",
        "purpose": "Code purpose:\"\"\"初始化ext4文件系统中inode信息结构体的各个成员，包括孤儿链表、读写信号量和虚拟文件系统inode\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核ext4文件系统中存在竞争条件，允许本地用户通过未同步的空洞打孔和页面错误处理操作，写入与其他用户文件关联的页面，导致磁盘损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: init_once\n- 参数: [void *foo]\n- 调用者: 不适用（静态函数，通常由内核初始化机制调用）\n- 被调用者: [INIT_LIST_HEAD, init_rwsem, inode_init_once]\n\n2. 函数名: INIT_LIST_HEAD\n- 参数: [&ei->i_orphan]\n- 调用者: init_once\n- 被调用者: []\n\n3. 函数名: init_rwsem\n- 参数: [&ei->xattr_sem]\n- 调用者: init_once\n- 被调用者: []\n\n4. 函数名: init_rwsem\n- 参数: [&ei->i_data_sem]\n- 调用者: init_once\n- 被调用者: []\n\n5. 函数名: inode_init_once\n- 参数: [&ei->vfs_inode]\n- 调用者: init_once\n- 被调用者: []"
    },
    {
        "id": 860,
        "cwe": "CWE-362",
        "cve": "CVE-2015-8839",
        "purpose": "Code purpose:\"\"\"在ext4文件系统中处理写入失败时截断文件以防止数据损坏\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核ext4文件系统实现中存在多个竞态条件，导致不同用户的文件页面在未同步的洞打孔和页面错误处理后被错误写入，从而引发磁盘损坏\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_truncate_failed_write\n- 参数: [struct inode *inode]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [truncate_inode_pages, ext4_truncate]\n\n2. 函数名: truncate_inode_pages\n- 参数: [inode->i_mapping, inode->i_size]\n- 调用者: ext4_truncate_failed_write\n- 被调用者: 未明确（可能为内核内部函数）\n\n3. 函数名: ext4_truncate\n- 参数: [struct inode *inode]\n- 调用者: ext4_truncate_failed_write\n- 被调用者: 未明确（可能为内核内部函数）"
    },
    {
        "id": 871,
        "cwe": "CWE-362",
        "cve": "CVE-2015-8963",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的性能事件子系统中添加软件事件，处理事件采样和周期设置，并将事件添加到哈希表中进行管理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在CPU热插拔操作期间，对swevent数据结构的处理不当导致竞态条件，可能引发权限提升或拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: perf_swevent_add\n- 参数: [event, flags]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [this_cpu_ptr, is_sampling_event, perf_swevent_set_period, find_swevent_head, WARN_ON_ONCE, hlist_add_head_rcu, perf_event_update_userpage]\n\n2. 函数名: this_cpu_ptr\n- 参数: [&swevent_htable]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n3. 函数名: is_sampling_event\n- 参数: [event]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n4. 函数名: perf_swevent_set_period\n- 参数: [event]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n5. 函数名: find_swevent_head\n- 参数: [swhash, event]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n6. 函数名: WARN_ON_ONCE\n- 参数: [swhash->online]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n7. 函数名: hlist_add_head_rcu\n- 参数: [&event->hlist_entry, head]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n8. 函数名: perf_event_update_userpage\n- 参数: [event]\n- 调用者: perf_swevent_add\n- 被调用者: []"
    },
    {
        "id": 872,
        "cwe": "CWE-362",
        "cve": "CVE-2015-8963",
        "purpose": "Code purpose:\"\"\"在CPU初始化时设置软件事件哈希表，并在引用计数大于0时分配新的软件事件链表\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在CPU热插拔操作期间，由于对swevent数据结构的处理不当导致竞态条件，可能引发权限提升或拒绝服务(use-after-free)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: perf_event_init_cpu\n- 参数: [cpu]\n- 调用者: 未显示（通常由CPU热插拔相关代码调用）\n- 被调用者: [mutex_lock, kzalloc_node, WARN_ON, rcu_assign_pointer, mutex_unlock, cpu_to_node]\n\n2. 函数名: mutex_lock\n- 参数: [&swhash->hlist_mutex]\n- 调用者: perf_event_init_cpu\n- 被调用者: []\n\n3. 函数名: kzalloc_node\n- 参数: [sizeof(*hlist), GFP_KERNEL, cpu_to_node(cpu)]\n- 调用者: perf_event_init_cpu\n- 被调用者: []\n\n4. 函数名: WARN_ON\n- 参数: [!hlist]\n- 调用者: perf_event_init_cpu\n- 被调用者: []\n\n5. 函数名: rcu_assign_pointer\n- 参数: [swhash->swevent_hlist, hlist]\n- 调用者: perf_event_init_cpu\n- 被调用者: []\n\n6. 函数名: mutex_unlock\n- 参数: [&swhash->hlist_mutex]\n- 调用者: perf_event_init_cpu\n- 被调用者: []\n\n7. 函数名: cpu_to_node\n- 参数: [cpu]\n- 调用者: perf_event_init_cpu\n- 被调用者: []"
    },
    {
        "id": 873,
        "cwe": "CWE-362",
        "cve": "CVE-2015-8963",
        "purpose": "Code purpose:\"\"\"该代码用于在多核环境下安全地获取和引用指定CPU上的软件事件哈希表，并在需要时分配内存初始化新的哈希表条目。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在CPU热拔插操作期间，由于对swevent数据结构的处理不当，导致竞态条件可能引发权限提升或拒绝服务(use-after-free)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: swevent_hlist_get_cpu\n- 参数: [struct perf_event *event, int cpu]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [swevent_hlist_deref, cpu_online, kzalloc, rcu_assign_pointer, mutex_lock, mutex_unlock]\n\n2. 函数名: swevent_hlist_deref\n- 参数: [struct swevent_htable *swhash]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: 未明确\n\n3. 函数名: cpu_online\n- 参数: [int cpu]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: 未明确\n\n4. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: 未明确\n\n5. 函数名: rcu_assign_pointer\n- 参数: [struct swevent_hlist *hlist]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: 未明确\n\n6. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: 未明确\n\n7. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: 未明确"
    },
    {
        "id": 881,
        "cwe": "CWE-362",
        "cve": "CVE-2015-9016",
        "purpose": "Code purpose:\"\"\"处理块设备队列中的刷新请求完成后的清理工作，包括释放资源、推进等待请求到下一阶段，并防止队列停滞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在blk_mq_tag_to_rq中存在竞态条件，当请求已被blk_mq_complete_request释放后仍可能被使用，导致释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: flush_end_io\n- 参数: [struct request *flush_rq, int error]\n- 调用者: 未明确显示（通常由块设备层调用）\n- 被调用者: [blk_get_flush_queue, spin_lock_irqsave, elv_completed_request, blk_flush_cur_seq, blk_flush_complete_seq, blk_run_queue_async, spin_unlock_irqrestore]\n\n2. 函数名: blk_get_flush_queue\n- 参数: [struct request_queue *q, struct blk_mq_ctx *ctx]\n- 调用者: flush_end_io\n- 被调用者: []\n\n3. 函数名: spin_lock_irqsave\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: flush_end_io\n- 被调用者: []\n\n4. 函数名: elv_completed_request\n- 参数: [struct request_queue *q, struct request *rq]\n- 调用者: flush_end_io\n- 被调用者: []\n\n5. 函数名: blk_flush_cur_seq\n- 参数: [struct request *rq]\n- 调用者: flush_end_io\n- 被调用者: []\n\n6. 函数名: blk_flush_complete_seq\n- 参数: [struct request *rq, struct blk_flush_queue *fq, unsigned int seq, int error]\n- 调用者: flush_end_io\n- 被调用者: []\n\n7. 函数名: blk_run_queue_async\n- 参数: [struct request_queue *q]\n- 调用者: flush_end_io\n- 被调用者: []\n\n8. 函数名: spin_unlock_irqrestore\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: flush_end_io\n- 被调用者: []"
    },
    {
        "id": 882,
        "cwe": "CWE-362",
        "cve": "CVE-2015-9016",
        "purpose": "Code purpose:\"\"\"该代码用于管理块设备队列中的刷新请求，处理刷新操作的并发控制和资源分配，确保数据一致性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于blk_mq_tag_to_rq中存在竞态条件，当请求已被blk_mq_complete_request释放后仍可能被访问，导致释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: blk_kick_flush\n- 参数: [struct request_queue *q, struct blk_flush_queue *fq]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [list_first_entry, blk_rq_init, blk_flush_queue_rq]\n\n2. 函数名: list_first_entry\n- 参数: [pending, struct request, flush.list]\n- 调用者: blk_kick_flush\n- 被调用者: []\n\n3. 函数名: blk_rq_init\n- 参数: [q, flush_rq]\n- 调用者: blk_kick_flush\n- 被调用者: []\n\n4. 函数名: blk_flush_queue_rq\n- 参数: [flush_rq, false]\n- 调用者: blk_kick_flush\n- 被调用者: []\n\n5. 函数名: time_before\n- 参数: [jiffies, fq->flush_pending_since + FLUSH_PENDING_TIMEOUT]\n- 调用者: blk_kick_flush\n- 被调用者: []\n\n6. 函数名: flush_end_io\n- 参数: 未明确（作为回调函数指针赋值）\n- 调用者: 未明确（通过flush_rq->end_io调用）\n- 被调用者: []"
    },
    {
        "id": 883,
        "cwe": "CWE-362",
        "cve": "CVE-2015-9016",
        "purpose": "Code purpose:\"\"\"遍历块设备多队列标签中的请求并执行回调函数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在blk_mq_tag_to_rq函数中存在竞态条件，当请求已被blk_mq_complete_request释放后仍可能被访问，导致释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: bt_for_each\n- 参数: [struct blk_mq_hw_ctx *hctx, struct blk_mq_bitmap_tags *bt, unsigned int off, busy_iter_fn *fn, void *data, bool reserved]\n- 调用者: N/A\n- 被调用者: [find_first_bit, find_next_bit, blk_mq_tag_to_rq]\n\n2. 函数名: find_first_bit\n- 参数: [&bm->word, bm->depth]\n- 调用者: bt_for_each\n- 被调用者: N/A\n\n3. 函数名: find_next_bit\n- 参数: [&bm->word, bm->depth, bit + 1]\n- 调用者: bt_for_each\n- 被调用者: N/A\n\n4. 函数名: blk_mq_tag_to_rq\n- 参数: [hctx->tags, off + bit]\n- 调用者: bt_for_each\n- 被调用者: N/A\n\n5. 函数名: fn\n- 参数: [hctx, rq, data, reserved]\n- 调用者: bt_for_each\n- 被调用者: N/A"
    },
    {
        "id": 884,
        "cwe": "CWE-362",
        "cve": "CVE-2015-9016",
        "purpose": "Code purpose:\"\"\"遍历块设备多队列标签中的请求并执行回调函数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在blk_mq_tag_to_rq函数中存在竞态条件，当请求已被blk_mq_complete_request释放后仍可能被访问，导致释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: bt_tags_for_each\n- 参数: [struct blk_mq_tags *tags, struct blk_mq_bitmap_tags *bt, unsigned int off, busy_tag_iter_fn *fn, void *data, bool reserved]\n- 调用者: 未显示\n- 被调用者: [find_first_bit, find_next_bit, blk_mq_tag_to_rq, fn]\n\n2. 函数名: find_first_bit\n- 参数: [&bm->word, bm->depth]\n- 调用者: bt_tags_for_each\n- 被调用者: 未显示\n\n3. 函数名: find_next_bit\n- 参数: [&bm->word, bm->depth, bit + 1]\n- 调用者: bt_tags_for_each\n- 被调用者: 未显示\n\n4. 函数名: blk_mq_tag_to_rq\n- 参数: [tags, off + bit]\n- 调用者: bt_tags_for_each\n- 被调用者: 未显示\n\n5. 函数名: fn\n- 参数: [rq, data, reserved]\n- 调用者: bt_tags_for_each\n- 被调用者: 未显示"
    },
    {
        "id": 885,
        "cwe": "CWE-362",
        "cve": "CVE-2015-9016",
        "purpose": "Code purpose:\"\"\"该代码用于根据标签从块多队列标签系统中获取对应的请求结构体，并处理刷新请求的特殊情况\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于blk_mq_tag_to_rq函数在访问已被blk_mq_complete_request释放的请求结构体时存在竞态条件，导致使用后释放漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: blk_mq_tag_to_rq\n- 参数: [struct blk_mq_tags *tags, unsigned int tag]\n- 调用者: 未指定\n- 被调用者: [blk_get_flush_queue, is_flush_request]\n\n2. 函数名: blk_get_flush_queue\n- 参数: [struct request_queue *q, struct blk_mq_hw_ctx *hctx]\n- 调用者: blk_mq_tag_to_rq\n- 被调用者: 未指定\n\n3. 函数名: is_flush_request\n- 参数: [struct request *rq, struct blk_flush_queue *fq, unsigned int tag]\n- 调用者: blk_mq_tag_to_rq\n- 被调用者: 未指定"
    },
    {
        "id": 888,
        "cwe": "CWE-362",
        "cve": "CVE-2016-0723",
        "purpose": "Code purpose:\"\"\"处理终端设备的输入输出控制命令(ioctl)，包括设置和获取终端参数、控制终端行为等功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在TIOCSETD和TIOCGETD ioctl调用之间存在竞争条件，导致内核内存信息泄露或使用后释放的系统崩溃漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: tty_ioctl\n- 参数: [struct file *file, unsigned int cmd, unsigned long arg]\n- 调用者: N/A\n- 被调用者: [file_tty, tty_paranoia_check, tty_pair_get_tty, tty_check_change, tty_wait_until_sent, signal_pending, tiocsti, tiocgwinsz, tiocswinsz, tioccons, fionbio, put_user, no_tty, tiocsctty, tiocgpgrp, tiocspgrp, tiocgsid, tiocsetd, tty_vhangup, new_encode_dev, tty_devnum, send_break, tty_tiocmget, tty_tiocmset, tty_tiocgicount, tty_buffer_flush, tty_warn_deprecated_flags, tty_ldisc_ref_wait, tty_ldisc_deref]\n\n2. 函数名: file_tty\n- 参数: [struct file *file]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n3. 函数名: tty_paranoia_check\n- 参数: [struct tty_struct *tty, struct inode *inode, const char *routine]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n4. 函数名: tty_pair_get_tty\n- 参数: [struct tty_struct *tty]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n5. 函数名: tty_check_change\n- 参数: [struct tty_struct *tty]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n6. 函数名: tty_wait_until_sent\n- 参数: [struct tty_struct *tty, long timeout]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n7. 函数名: signal_pending\n- 参数: [struct task_struct *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n8. 函数名: tiocsti\n- 参数: [struct tty_struct *tty, void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n9. 函数名: tiocgwinsz\n- 参数: [struct tty_struct *real_tty, void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n10. 函数名: tiocswinsz\n- 参数: [struct tty_struct *real_tty, void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n11. 函数名: tioccons\n- 参数: [struct file *file]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n12. 函数名: fionbio\n- 参数: [struct file *file, void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n13. 函数名: put_user\n- 参数: [type x, type __user *ptr]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n14. 函数名: no_tty\n- 参数: []\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n15. 函数名: tiocsctty\n- 参数: [struct tty_struct *real_tty, struct file *file, unsigned long arg]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n16. 函数名: tiocgpgrp\n- 参数: [struct tty_struct *tty, struct tty_struct *real_tty, void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n17. 函数名: tiocspgrp\n- 参数: [struct tty_struct *tty, struct tty_struct *real_tty, void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n18. 函数名: tiocgsid\n- 参数: [struct tty_struct *tty, struct tty_struct *real_tty, void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n19. 函数名: tiocsetd\n- 参数: [struct tty_struct *tty, void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n20. 函数名: tty_vhangup\n- 参数: [struct tty_struct *tty]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n21. 函数名: new_encode_dev\n- 参数: [dev_t dev]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n22. 函数名: tty_devnum\n- 参数: [struct tty_struct *tty]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n23. 函数名: send_break\n- 参数: [struct tty_struct *tty, unsigned int duration]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n24. 函数名: tty_tiocmget\n- 参数: [struct tty_struct *tty, void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n25. 函数名: tty_tiocmset\n- 参数: [struct tty_struct *tty, unsigned int cmd, void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n26. 函数名: tty_tiocgicount\n- 参数: [struct tty_struct *tty, void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n27. 函数名: tty_buffer_flush\n- 参数: [struct tty_struct *tty, struct tty_ldisc *ld]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n28. 函数名: tty_warn_deprecated_flags\n- 参数: [void __user *p]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n29. 函数名: tty_ldisc_ref_wait\n- 参数: [struct tty_struct *tty]\n- 调用者: tty_ioctl\n- 被调用者: N/A\n\n30. 函数名: tty_ldisc_deref\n- 参数: [struct tty_ldisc *ld]\n- 调用者: tty_ioctl\n- 被调用者: N/A"
    },
    {
        "id": 898,
        "cwe": "CWE-362",
        "cve": "CVE-2016-10200",
        "purpose": "Code purpose:\"\"\"实现L2TPv3 IP封装功能中的socket绑定操作，包括地址验证、状态检查和绑定表管理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在检查SOCK_ZAPPED状态和实际绑定操作之间存在竞争条件，导致多个bind系统调用可能绕过状态检查，引发权限提升或拒绝服务漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: l2tp_ip_bind\n- 参数: [sk, uaddr, addr_len]\n- 调用者: 未显示（系统调用）\n- 被调用者: [inet_sk, sock_net, sock_flag, __l2tp_ip_bind_lookup, read_lock_bh, read_unlock_bh, lock_sock, inet_addr_type, sk_dst_reset, l2tp_ip_sk, write_lock_bh, sk_add_bind_node, sk_del_node_init, write_unlock_bh, sock_reset_flag, release_sock]\n\n2. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n3. 函数名: sock_net\n- 参数: [sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n4. 函数名: sock_flag\n- 参数: [sk, SOCK_ZAPPED]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n5. 函数名: __l2tp_ip_bind_lookup\n- 参数: [net, addr->l2tp_addr.s_addr, sk->sk_bound_dev_if, addr->l2tp_conn_id]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n6. 函数名: read_lock_bh\n- 参数: [&l2tp_ip_lock]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n7. 函数名: read_unlock_bh\n- 参数: [&l2tp_ip_lock]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n8. 函数名: lock_sock\n- 参数: [sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n9. 函数名: inet_addr_type\n- 参数: [net, addr->l2tp_addr.s_addr]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n10. 函数名: sk_dst_reset\n- 参数: [sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n11. 函数名: l2tp_ip_sk\n- 参数: [sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n12. 函数名: write_lock_bh\n- 参数: [&l2tp_ip_lock]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n13. 函数名: sk_add_bind_node\n- 参数: [sk, &l2tp_ip_bind_table]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n14. 函数名: sk_del_node_init\n- 参数: [sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n15. 函数名: write_unlock_bh\n- 参数: [&l2tp_ip_lock]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n16. 函数名: sock_reset_flag\n- 参数: [sk, SOCK_ZAPPED]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n17. 函数名: release_sock\n- 参数: [sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []"
    },
    {
        "id": 899,
        "cwe": "CWE-362",
        "cve": "CVE-2016-10200",
        "purpose": "Code purpose:\"\"\"该代码实现了L2TPv3协议在IPv6环境下的socket绑定功能，包括地址类型检查、绑定状态验证和地址归属确认等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多次bind系统调用时未能正确检查SOCK_ZAPPED状态，导致竞争条件可能引发权限提升或拒绝服务(use-after-free)。\"\"\"",
        "functions": "Functions:\n1. 函数名: l2tp_ip6_bind\n- 参数: [sk, uaddr, addr_len]\n- 调用者: 未显示（应为系统调用或其他内核模块）\n- 被调用者: [inet_sk, inet6_sk, sock_net, ipv6_addr_type, __l2tp_ip6_bind_lookup, lock_sock, rcu_read_lock, dev_get_by_index_rcu, ipv6_chk_addr, rcu_read_unlock, sk_add_bind_node, sk_del_node_init, sock_reset_flag, release_sock, read_unlock_bh, write_lock_bh, write_unlock_bh]\n\n2. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n3. 函数名: inet6_sk\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n4. 函数名: sock_net\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n5. 函数名: ipv6_addr_type\n- 参数: [&addr->l2tp_addr]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n6. 函数名: __l2tp_ip6_bind_lookup\n- 参数: [net, &addr->l2tp_addr, sk->sk_bound_dev_if, addr->l2tp_conn_id]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n7. 函数名: lock_sock\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n8. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n9. 函数名: dev_get_by_index_rcu\n- 参数: [sock_net(sk), sk->sk_bound_dev_if]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n10. 函数名: ipv6_chk_addr\n- 参数: [sock_net(sk), &addr->l2tp_addr, dev, 0]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n11. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n12. 函数名: sk_add_bind_node\n- 参数: [sk, &l2tp_ip6_bind_table]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n13. 函数名: sk_del_node_init\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n14. 函数名: sock_reset_flag\n- 参数: [sk, SOCK_ZAPPED]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n15. 函数名: release_sock\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n16. 函数名: read_unlock_bh\n- 参数: [&l2tp_ip6_lock]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n17. 函数名: write_lock_bh\n- 参数: [&l2tp_ip6_lock]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n18. 函数名: write_unlock_bh\n- 参数: [&l2tp_ip6_lock]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []"
    },
    {
        "id": 905,
        "cwe": "CWE-362",
        "cve": "CVE-2016-10741",
        "purpose": "Code purpose:\"\"\"处理XFS文件系统中获取数据块的操作，包括直接I/O和内存映射I/O，并管理相关的块映射和分配\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核XFS文件系统中处理直接I/O和内存映射I/O时存在竞争条件，当遇到空洞(hole)时使用BUG_ON而非I/O错误处理导致系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: __xfs_get_blocks\n- 参数: [struct inode *inode, sector_t iblock, struct buffer_head *bh_result, int create, bool direct, bool dax_fault]\n- 调用者: N/A (kernel internal function)\n- 被调用者: [XFS_I, xfs_ilock_data_map_shared, xfs_is_reflink_inode, xfs_reflink_find_cow_mapping, xfs_bmapi_read, xfs_reflink_trim_irec_to_next_cow, xfs_ilock_demote, xfs_iomap_write_direct, xfs_iunlock, xfs_bounce_unaligned_dio_write, xfs_map_buffer, xfs_map_direct, xfs_find_bdev_for_inode]\n\n2. 函数名: XFS_I\n- 参数: [struct inode *inode]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n3. 函数名: xfs_ilock_data_map_shared\n- 参数: [struct xfs_inode *ip]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n4. 函数名: xfs_is_reflink_inode\n- 参数: [struct xfs_inode *ip]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n5. 函数名: xfs_reflink_find_cow_mapping\n- 参数: [struct xfs_inode *ip, xfs_off_t offset, struct xfs_bmbt_irec *imap, bool *need_alloc]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n6. 函数名: xfs_bmapi_read\n- 参数: [struct xfs_inode *ip, xfs_fileoff_t bno, xfs_filblks_t len, struct xfs_bmbt_irec *mval, int *nmap, int flags]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n7. 函数名: xfs_reflink_trim_irec_to_next_cow\n- 参数: [struct xfs_inode *ip, xfs_fileoff_t offset_fsb, struct xfs_bmbt_irec *imap]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n8. 函数名: xfs_ilock_demote\n- 参数: [struct xfs_inode *ip, int lock_flags]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n9. 函数名: xfs_iomap_write_direct\n- 参数: [struct xfs_inode *ip, xfs_off_t offset, size_t count, struct xfs_bmbt_irec *imap, int *nimaps]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n10. 函数名: xfs_iunlock\n- 参数: [struct xfs_inode *ip, int lock_flags]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n11. 函数名: xfs_bounce_unaligned_dio_write\n- 参数: [struct xfs_inode *ip, xfs_fileoff_t offset_fsb, struct xfs_bmbt_irec *imap]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n12. 函数名: xfs_map_buffer\n- 参数: [struct inode *inode, struct buffer_head *bh_result, struct xfs_bmbt_irec *imap, xfs_off_t offset]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n13. 函数名: xfs_map_direct\n- 参数: [struct inode *inode, struct buffer_head *bh_result, struct xfs_bmbt_irec *imap, xfs_off_t offset, bool is_cow]\n- 调用者: __xfs_get_blocks\n- 被调用者: []\n\n14. 函数名: xfs_find_bdev_for_inode\n- 参数: [struct inode *inode]\n- 调用者: __xfs_get_blocks\n- 被调用者: []"
    },
    {
        "id": 909,
        "cwe": "CWE-362",
        "cve": "CVE-2016-10906",
        "purpose": "Code purpose:\"\"\"该代码实现了ARC EMAC网络设备驱动中的数据包发送功能，包括数据包填充、DMA映射、环形缓冲区管理和传输状态更新等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于arc_emac_tx和arc_emac_tx_clean函数之间的竞争条件导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: arc_emac_tx\n- 参数: [struct sk_buff *skb, struct net_device *ndev]\n- 调用者: 未显示（通常由网络子系统调用）\n- 被调用者: [skb_padto, max_t, arc_emac_tx_avail, netif_stop_queue, netdev_err, dma_map_single, dma_mapping_error, dev_kfree_skb, dma_unmap_addr_set, dma_unmap_len_set, cpu_to_le32, wmb, skb_tx_timestamp, smp_mb, netif_start_queue, arc_reg_set]\n\n2. 函数名: skb_padto\n- 参数: [struct sk_buff *skb, int len]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n3. 函数名: max_t\n- 参数: [type, unsigned int, unsigned int]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n4. 函数名: arc_emac_tx_avail\n- 参数: [struct arc_emac_priv *priv]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n5. 函数名: netif_stop_queue\n- 参数: [struct net_device *dev]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n6. 函数名: netdev_err\n- 参数: [const struct net_device *dev, const char *fmt, ...]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n7. 函数名: dma_map_single\n- 参数: [struct device *dev, void *ptr, size_t size, enum dma_data_direction dir]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n8. 函数名: dma_mapping_error\n- 参数: [struct device *dev, dma_addr_t dma_addr]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n9. 函数名: dev_kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n10. 函数名: dma_unmap_addr_set\n- 参数: [struct buffer *buf, dma_addr_t addr, dma_addr_t val]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n11. 函数名: dma_unmap_len_set\n- 参数: [struct buffer *buf, size_t len, size_t val]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n12. 函数名: cpu_to_le32\n- 参数: [__u32 val]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n13. 函数名: wmb\n- 参数: []\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n14. 函数名: skb_tx_timestamp\n- 参数: [struct sk_buff *skb]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n15. 函数名: smp_mb\n- 参数: []\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n16. 函数名: netif_start_queue\n- 参数: [struct net_device *dev]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n17. 函数名: arc_reg_set\n- 参数: [struct arc_emac_priv *priv, int reg, u32 value]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示"
    },
    {
        "id": 910,
        "cwe": "CWE-362",
        "cve": "CVE-2016-10906",
        "purpose": "Code purpose:\"\"\"该代码用于清理网络设备发送缓冲区中的已完成传输的数据包，并更新相关统计信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于arc_emac_tx和arc_emac_tx_clean函数之间的竞争条件导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: arc_emac_tx_clean\n- 参数: [struct net_device *ndev]\n- 调用者: 未明确显示（通常由网络子系统调用）\n- 被调用者: [le32_to_cpu, dma_unmap_single, dev_kfree_skb_irq, smp_mb, netif_queue_stopped, arc_emac_tx_avail, netif_wake_queue]\n\n2. 函数名: le32_to_cpu\n- 参数: [unsigned int info]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n3. 函数名: dma_unmap_single\n- 参数: [&ndev->dev, dma_unmap_addr(tx_buff, addr), dma_unmap_len(tx_buff, len), DMA_TO_DEVICE]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n4. 函数名: dev_kfree_skb_irq\n- 参数: [struct sk_buff *skb]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n5. 函数名: smp_mb\n- 参数: []\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n6. 函数名: netif_queue_stopped\n- 参数: [struct net_device *ndev]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n7. 函数名: arc_emac_tx_avail\n- 参数: [struct arc_emac_priv *priv]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n8. 函数名: netif_wake_queue\n- 参数: [struct net_device *ndev]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []"
    },
    {
        "id": 916,
        "cwe": "CWE-362",
        "cve": "CVE-2016-2069",
        "purpose": "Code purpose:\"\"\"在进程切换时处理内存管理单元(MMU)状态，包括页表加载、TLB刷新和LDT加载等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在多核环境下，由于TLB状态管理和页表切换存在竞态条件，导致不同CPU可能同时访问同一分页结构，从而引发权限提升漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: switch_mm\n- 参数: [prev, next, tsk]\n- 调用者: 未显示（通常是进程调度相关代码）\n- 被调用者: [smp_processor_id, this_cpu_write, cpumask_set_cpu, load_cr3, trace_tlb_flush, cpumask_clear_cpu, load_mm_cr4, load_mm_ldt, this_cpu_read, cpumask_test_cpu]\n\n2. 函数名: smp_processor_id\n- 参数: []\n- 调用者: switch_mm\n- 被调用者: []\n\n3. 函数名: this_cpu_write\n- 参数: [cpu_tlbstate.state, TLBSTATE_OK] 和 [cpu_tlbstate.active_mm, next]\n- 调用者: switch_mm\n- 被调用者: []\n\n4. 函数名: cpumask_set_cpu\n- 参数: [cpu, mm_cpumask(next)]\n- 调用者: switch_mm\n- 被调用者: []\n\n5. 函数名: load_cr3\n- 参数: [next->pgd]\n- 调用者: switch_mm\n- 被调用者: []\n\n6. 函数名: trace_tlb_flush\n- 参数: [TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL]\n- 调用者: switch_mm\n- 被调用者: []\n\n7. 函数名: cpumask_clear_cpu\n- 参数: [cpu, mm_cpumask(prev)]\n- 调用者: switch_mm\n- 被调用者: []\n\n8. 函数名: load_mm_cr4\n- 参数: [next]\n- 调用者: switch_mm\n- 被调用者: []\n\n9. 函数名: load_mm_ldt\n- 参数: [next]\n- 调用者: switch_mm\n- 被调用者: []\n\n10. 函数名: this_cpu_read\n- 参数: [cpu_tlbstate.active_mm]\n- 调用者: switch_mm\n- 被调用者: []\n\n11. 函数名: cpumask_test_cpu\n- 参数: [cpu, mm_cpumask(next)]\n- 调用者: switch_mm\n- 被调用者: []"
    },
    {
        "id": 917,
        "cwe": "CWE-362",
        "cve": "CVE-2016-2069",
        "purpose": "Code purpose:\"\"\"在多核系统中刷新当前任务的TLB(Translation Lookaside Buffer)条目，包括本地CPU和其他CPU上的相关条目\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在多核环境下，由于缺乏对CPU间TLB刷新操作的同步保护，导致竞争条件可能被利用来提升权限\"\"\"",
        "functions": "Functions:\n1. 函数名: flush_tlb_current_task\n- 参数: []\n- 调用者: N/A\n- 被调用者: [preempt_disable, count_vm_tlb_event, local_flush_tlb, trace_tlb_flush, cpumask_any_but, smp_processor_id, flush_tlb_others, preempt_enable]\n\n2. 函数名: preempt_disable\n- 参数: []\n- 调用者: flush_tlb_current_task\n- 被调用者: []\n\n3. 函数名: count_vm_tlb_event\n- 参数: [NR_TLB_LOCAL_FLUSH_ALL]\n- 调用者: flush_tlb_current_task\n- 被调用者: []\n\n4. 函数名: local_flush_tlb\n- 参数: []\n- 调用者: flush_tlb_current_task\n- 被调用者: []\n\n5. 函数名: trace_tlb_flush\n- 参数: [TLB_LOCAL_SHOOTDOWN, TLB_FLUSH_ALL]\n- 调用者: flush_tlb_current_task\n- 被调用者: []\n\n6. 函数名: cpumask_any_but\n- 参数: [mm_cpumask(mm), smp_processor_id()]\n- 调用者: flush_tlb_current_task\n- 被调用者: []\n\n7. 函数名: smp_processor_id\n- 参数: []\n- 调用者: cpumask_any_but\n- 被调用者: []\n\n8. 函数名: flush_tlb_others\n- 参数: [mm_cpumask(mm), mm, 0UL, TLB_FLUSH_ALL]\n- 调用者: flush_tlb_current_task\n- 被调用者: []\n\n9. 函数名: preempt_enable\n- 参数: []\n- 调用者: flush_tlb_current_task\n- 被调用者: []\n\n10. 函数名: mm_cpumask\n- 参数: [mm]\n- 调用者: cpumask_any_but, flush_tlb_others\n- 被调用者: []"
    },
    {
        "id": 918,
        "cwe": "CWE-362",
        "cve": "CVE-2016-2069",
        "purpose": "Code purpose:\"\"\"在多核系统中刷新指定虚拟内存页的TLB条目，确保内存访问一致性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多CPU环境下缺乏足够的同步机制，导致不同CPU可能同时访问页表结构，产生竞争条件漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: flush_tlb_page\n- 参数: [vma, start]\n- 调用者: N/A\n- 被调用者: [preempt_disable, __flush_tlb_one, leave_mm, smp_processor_id, cpumask_any_but, mm_cpumask, nr_cpu_ids, flush_tlb_others, preempt_enable]\n\n2. 函数名: preempt_disable\n- 参数: []\n- 调用者: flush_tlb_page\n- 被调用者: []\n\n3. 函数名: __flush_tlb_one\n- 参数: [start]\n- 调用者: flush_tlb_page\n- 被调用者: []\n\n4. 函数名: leave_mm\n- 参数: [smp_processor_id()]\n- 调用者: flush_tlb_page\n- 被调用者: []\n\n5. 函数名: smp_processor_id\n- 参数: []\n- 调用者: flush_tlb_page, leave_mm\n- 被调用者: []\n\n6. 函数名: cpumask_any_but\n- 参数: [mm_cpumask(mm), smp_processor_id()]\n- 调用者: flush_tlb_page\n- 被调用者: []\n\n7. 函数名: mm_cpumask\n- 参数: [mm]\n- 调用者: flush_tlb_page, cpumask_any_but\n- 被调用者: []\n\n8. 函数名: flush_tlb_others\n- 参数: [mm_cpumask(mm), mm, start, 0UL]\n- 调用者: flush_tlb_page\n- 被调用者: []\n\n9. 函数名: preempt_enable\n- 参数: []\n- 调用者: flush_tlb_page\n- 被调用者: []"
    },
    {
        "id": 919,
        "cwe": "CWE-362",
        "cve": "CVE-2016-2069",
        "purpose": "Code purpose:\"\"\"该代码用于在多核系统中刷新指定内存地址范围的TLB(Translation Lookaside Buffer)条目，以保持内存一致性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多CPU环境下缺乏适当的同步机制，导致不同CPU可能同时访问和修改页表结构，从而引发竞争条件漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: flush_tlb_mm_range\n- 参数: [struct mm_struct *mm, unsigned long start, unsigned long end, unsigned long vmflag]\n- 调用者: 未明确（系统调用或其他内核代码）\n- 被调用者: [preempt_disable, leave_mm, count_vm_tlb_event, local_flush_tlb, __flush_tlb_single, trace_tlb_flush, cpumask_any_but, flush_tlb_others, preempt_enable]\n\n2. 函数名: preempt_disable\n- 参数: []\n- 调用者: flush_tlb_mm_range\n- 被调用者: []\n\n3. 函数名: leave_mm\n- 参数: [smp_processor_id()]\n- 调用者: flush_tlb_mm_range\n- 被调用者: []\n\n4. 函数名: count_vm_tlb_event\n- 参数: [NR_TLB_LOCAL_FLUSH_ALL] 或 [NR_TLB_LOCAL_FLUSH_ONE]\n- 调用者: flush_tlb_mm_range\n- 被调用者: []\n\n5. 函数名: local_flush_tlb\n- 参数: []\n- 调用者: flush_tlb_mm_range\n- 被调用者: []\n\n6. 函数名: __flush_tlb_single\n- 参数: [addr]\n- 调用者: flush_tlb_mm_range\n- 被调用者: []\n\n7. 函数名: trace_tlb_flush\n- 参数: [TLB_LOCAL_MM_SHOOTDOWN, base_pages_to_flush]\n- 调用者: flush_tlb_mm_range\n- 被调用者: []\n\n8. 函数名: cpumask_any_but\n- 参数: [mm_cpumask(mm), smp_processor_id()]\n- 调用者: flush_tlb_mm_range\n- 被调用者: []\n\n9. 函数名: flush_tlb_others\n- 参数: [mm_cpumask(mm), mm, start, end]\n- 调用者: flush_tlb_mm_range\n- 被调用者: []\n\n10. 函数名: preempt_enable\n- 参数: []\n- 调用者: flush_tlb_mm_range\n- 被调用者: []\n\n11. 函数名: smp_processor_id\n- 参数: []\n- 调用者: leave_mm, cpumask_any_but\n- 被调用者: []\n\n12. 函数名: mm_cpumask\n- 参数: [mm]\n- 调用者: cpumask_any_but, flush_tlb_others\n- 被调用者: []"
    },
    {
        "id": 934,
        "cwe": "CWE-362",
        "cve": "CVE-2016-2544",
        "purpose": "Code purpose:\"\"\"该代码用于删除音频序列队列并释放相关资源，包括停止定时器、等待访问锁释放、删除优先级队列和定时器，最后释放队列内存。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在queue_delete函数中存在竞态条件，当ioctl调用在释放资源和使用锁同步之间发生时，会导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: queue_delete\n- 参数: [struct snd_seq_queue *q]\n- 调用者: 未显示\n- 被调用者: [snd_seq_timer_stop, snd_seq_timer_close, snd_use_lock_sync, snd_seq_prioq_delete, snd_seq_timer_delete, kfree]\n\n2. 函数名: snd_seq_timer_stop\n- 参数: [q->timer]\n- 调用者: queue_delete\n- 被调用者: 未显示\n\n3. 函数名: snd_seq_timer_close\n- 参数: [q]\n- 调用者: queue_delete\n- 被调用者: 未显示\n\n4. 函数名: snd_use_lock_sync\n- 参数: [&q->use_lock]\n- 调用者: queue_delete\n- 被调用者: 未显示\n\n5. 函数名: snd_seq_prioq_delete\n- 参数: [&q->tickq]\n- 调用者: queue_delete\n- 被调用者: 未显示\n\n6. 函数名: snd_seq_prioq_delete\n- 参数: [&q->timeq]\n- 调用者: queue_delete\n- 被调用者: 未显示\n\n7. 函数名: snd_seq_timer_delete\n- 参数: [&q->timer]\n- 调用者: queue_delete\n- 被调用者: 未显示\n\n8. 函数名: kfree\n- 参数: [q]\n- 调用者: queue_delete\n- 被调用者: 未显示"
    },
    {
        "id": 935,
        "cwe": "CWE-362",
        "cve": "CVE-2016-2545",
        "purpose": "Code purpose:\"\"\"处理音频定时器中断事件，管理定时器实例列表并执行相应的回调函数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在snd_timer_interrupt函数中处理定时器中断时，未能正确维护active_list和ack_list等链表结构，导致在多线程环境下可能发生竞态条件，造成链表损坏或系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_timer_interrupt\n- 参数: [timer, ticks_left]\n- 调用者: 未显示（通常是内核中断处理程序）\n- 被调用者: [snd_timer_reschedule, list_for_each_entry_safe, list_for_each_entry, list_del, list_add_tail, list_empty, list_del_init, tasklet_schedule]\n\n2. 函数名: snd_timer_reschedule\n- 参数: [timer, timer->sticks]\n- 调用者: snd_timer_interrupt\n- 被调用者: 未显示\n\n3. 函数名: list_for_each_entry_safe\n- 参数: [ti, tmp, &timer->active_list_head, active_list]\n- 调用者: snd_timer_interrupt\n- 被调用者: 未显示\n\n4. 函数名: list_for_each_entry\n- 参数: [ts, &ti->slave_active_head, active_list]\n- 调用者: snd_timer_interrupt\n- 被调用者: 未显示\n\n5. 函数名: list_del\n- 参数: [&ti->active_list]\n- 调用者: snd_timer_interrupt\n- 被调用者: 未显示\n\n6. 函数名: list_add_tail\n- 参数: [&ti->ack_list, ack_list_head], [&ts->ack_list, ack_list_head]\n- 调用者: snd_timer_interrupt\n- 被调用者: 未显示\n\n7. 函数名: list_empty\n- 参数: [&ti->ack_list], [&timer->ack_list_head], [&timer->sack_list_head]\n- 调用者: snd_timer_interrupt\n- 被调用者: 未显示\n\n8. 函数名: list_del_init\n- 参数: [p]\n- 调用者: snd_timer_interrupt\n- 被调用者: 未显示\n\n9. 函数名: tasklet_schedule\n- 参数: [&timer->task_queue]\n- 调用者: snd_timer_interrupt\n- 被调用者: 未显示"
    },
    {
        "id": 936,
        "cwe": "CWE-362",
        "cve": "CVE-2016-2546",
        "purpose": "Code purpose:\"\"\"该代码用于处理用户空间对音频定时器的选择请求，包括打开定时器、分配队列内存以及设置回调函数等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"使用了不正确的互斥锁类型导致竞态条件，可能引发释放后使用和系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_timer_user_tselect\n- 参数: [struct file *file, struct snd_timer_select __user *_tselect]\n- 调用者: 未显示（应为ioctl调用）\n- 被调用者: [mutex_lock, snd_timer_close, copy_from_user, sprintf, snd_timer_open, kfree, kmalloc, mutex_unlock]\n\n2. 函数名: mutex_lock\n- 参数: [&tu->tread_sem]\n- 调用者: snd_timer_user_tselect\n- 被调用者: []\n\n3. 函数名: snd_timer_close\n- 参数: [tu->timeri]\n- 调用者: snd_timer_user_tselect\n- 被调用者: []\n\n4. 函数名: copy_from_user\n- 参数: [&tselect, _tselect, sizeof(tselect)]\n- 调用者: snd_timer_user_tselect\n- 被调用者: []\n\n5. 函数名: sprintf\n- 参数: [str, \"application %i\", current->pid]\n- 调用者: snd_timer_user_tselect\n- 被调用者: []\n\n6. 函数名: snd_timer_open\n- 参数: [&tu->timeri, str, &tselect.id, current->pid]\n- 调用者: snd_timer_user_tselect\n- 被调用者: []\n\n7. 函数名: kfree\n- 参数: [tu->queue], [tu->tqueue]\n- 调用者: snd_timer_user_tselect\n- 被调用者: []\n\n8. 函数名: kmalloc\n- 参数: [tu->queue_size * sizeof(struct snd_timer_tread), GFP_KERNEL], [tu->queue_size * sizeof(struct snd_timer_read), GFP_KERNEL]\n- 调用者: snd_timer_user_tselect\n- 被调用者: []\n\n9. 函数名: mutex_unlock\n- 参数: [&tu->tread_sem]\n- 调用者: snd_timer_user_tselect\n- 被调用者: []"
    },
    {
        "id": 937,
        "cwe": "CWE-362",
        "cve": "CVE-2016-2546",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中声音定时器的用户空间ioctl接口，用于处理各种定时器控制命令。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"使用了不正确的互斥锁类型导致竞态条件，可能引发释放后使用和系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_timer_user_ioctl\n- 参数: [struct file *file, unsigned int cmd, unsigned long arg]\n- 调用者: 内核IOCTL处理机制\n- 被调用者: [put_user, snd_timer_user_next_device, mutex_lock, mutex_unlock, get_user, snd_timer_user_ginfo, snd_timer_user_gparams, snd_timer_user_gstatus, snd_timer_user_tselect, snd_timer_user_info, snd_timer_user_params, snd_timer_user_status, snd_timer_user_start, snd_timer_user_stop, snd_timer_user_continue, snd_timer_user_pause]\n\n2. 函数名: snd_timer_user_next_device\n- 参数: [void __user *argp]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []\n\n3. 函数名: snd_timer_user_ginfo\n- 参数: [struct file *file, void __user *argp]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []\n\n4. 函数名: snd_timer_user_gparams\n- 参数: [struct file *file, void __user *argp]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []\n\n5. 函数名: snd_timer_user_gstatus\n- 参数: [struct file *file, void __user *argp]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []\n\n6. 函数名: snd_timer_user_tselect\n- 参数: [struct file *file, void __user *argp]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []\n\n7. 函数名: snd_timer_user_info\n- 参数: [struct file *file, void __user *argp]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []\n\n8. 函数名: snd_timer_user_params\n- 参数: [struct file *file, void __user *argp]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []\n\n9. 函数名: snd_timer_user_status\n- 参数: [struct file *file, void __user *argp]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []\n\n10. 函数名: snd_timer_user_start\n- 参数: [struct file *file]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []\n\n11. 函数名: snd_timer_user_stop\n- 参数: [struct file *file]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []\n\n12. 函数名: snd_timer_user_continue\n- 参数: [struct file *file]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []\n\n13. 函数名: snd_timer_user_pause\n- 参数: [struct file *file]\n- 调用者: snd_timer_user_ioctl\n- 被调用者: []"
    },
    {
        "id": 938,
        "cwe": "CWE-362",
        "cve": "CVE-2016-2546",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中声音定时器设备的用户空间打开操作，包括初始化定时器用户数据结构、分配内存和设置相关同步机制。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"使用了不正确的互斥锁类型导致竞态条件，可能引发释放后使用和系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_timer_user_open\n- 参数: [struct inode *inode, struct file *file]\n- 调用者: 未显示（通常由文件操作结构体调用）\n- 被调用者: [nonseekable_open, kzalloc, spin_lock_init, init_waitqueue_head, mutex_init, kmalloc, kfree]\n\n2. 函数名: nonseekable_open\n- 参数: [struct inode *inode, struct file *file]\n- 调用者: snd_timer_user_open\n- 被调用者: []\n\n3. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: snd_timer_user_open\n- 被调用者: []\n\n4. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: snd_timer_user_open\n- 被调用者: []\n\n5. 函数名: init_waitqueue_head\n- 参数: [wait_queue_head_t *q]\n- 调用者: snd_timer_user_open\n- 被调用者: []\n\n6. 函数名: mutex_init\n- 参数: [struct mutex *lock]\n- 调用者: snd_timer_user_open\n- 被调用者: []\n\n7. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: snd_timer_user_open\n- 被调用者: []\n\n8. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: snd_timer_user_open\n- 被调用者: []"
    },
    {
        "id": 939,
        "cwe": "CWE-362",
        "cve": "CVE-2016-2546",
        "purpose": "Code purpose:\"\"\"释放与定时器用户相关的资源，包括关闭定时器并释放分配的内存\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"使用了不正确的互斥锁类型导致竞态条件，可能引发释放后重用和系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_timer_user_release\n- 参数: [struct inode *inode, struct file *file]\n- 调用者: 内核文件操作接口\n- 被调用者: [snd_timer_close, kfree]\n\n2. 函数名: snd_timer_close\n- 参数: [struct snd_timer_instance *timeri]\n- 调用者: snd_timer_user_release\n- 被调用者: []\n\n3. 函数名: kfree\n- 参数: [void *obj]\n- 调用者: snd_timer_user_release\n- 被调用者: []"
    },
    {
        "id": 940,
        "cwe": "CWE-362",
        "cve": "CVE-2016-2547",
        "purpose": "Code purpose:\"\"\"检查并管理主定时器实例与其从属定时器实例之间的关联关系，包括将符合条件的从属定时器移动到主定时器的列表中并更新其状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未考虑从属定时器实例的锁定机制导致竞态条件，可能引发释放后使用和系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_timer_check_master\n- 参数: [struct snd_timer_instance *master]\n- 调用者: 未明确显示（通常是外部调用）\n- 被调用者: [list_for_each_entry_safe, list_move_tail, spin_lock_irq, spin_unlock_irq, list_add_tail]\n\n2. 函数名: list_for_each_entry_safe\n- 参数: [slave, tmp, &snd_timer_slave_list, open_list]\n- 调用者: snd_timer_check_master\n- 被调用者: []\n\n3. 函数名: list_move_tail\n- 参数: [&slave->open_list, &master->slave_list_head]\n- 调用者: snd_timer_check_master\n- 被调用者: []\n\n4. 函数名: spin_lock_irq\n- 参数: [&slave_active_lock]\n- 调用者: snd_timer_check_master\n- 被调用者: []\n\n5. 函数名: spin_unlock_irq\n- 参数: [&slave_active_lock]\n- 调用者: snd_timer_check_master\n- 被调用者: []\n\n6. 函数名: list_add_tail\n- 参数: [&slave->active_list, &master->slave_active_head]\n- 调用者: snd_timer_check_master\n- 被调用者: []"
    },
    {
        "id": 941,
        "cwe": "CWE-362",
        "cve": "CVE-2016-2547",
        "purpose": "Code purpose:\"\"\"启动从属定时器实例并将其添加到主定时器的活动列表中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该代码在处理从属定时器实例时未充分考虑竞态条件，导致在锁定机制上存在缺陷，可能引发使用后释放和系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_timer_start_slave\n- 参数: [struct snd_timer_instance *timeri]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [spin_lock_irqsave, spin_unlock_irqrestore, list_add_tail]"
    },
    {
        "id": 942,
        "cwe": "CWE-362",
        "cve": "CVE-2016-2547",
        "purpose": "Code purpose:\"\"\"该代码用于停止一个定时器实例，处理主定时器和从定时器的不同情况，并确保正确的同步和资源释放。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码在处理从属定时器实例时未正确考虑锁定机制，导致竞态条件和释放后使用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: _snd_timer_stop\n- 参数: [struct snd_timer_instance *timeri, int keep_flag, int event]\n- 调用者: 未明确显示（通常由外部IOCTL调用）\n- 被调用者: [spin_lock_irqsave, spin_unlock_irqrestore, list_del_init, snd_timer_reschedule, snd_timer_notify1]\n\n2. 函数名: spin_lock_irqsave\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: _snd_timer_stop\n- 被调用者: []\n\n3. 函数名: spin_unlock_irqrestore\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: _snd_timer_stop\n- 被调用者: []\n\n4. 函数名: list_del_init\n- 参数: [struct list_head *entry]\n- 调用者: _snd_timer_stop\n- 被调用者: []\n\n5. 函数名: snd_timer_reschedule\n- 参数: [struct snd_timer *timer, int ticks]\n- 调用者: _snd_timer_stop\n- 被调用者: []\n\n6. 函数名: snd_timer_notify1\n- 参数: [struct snd_timer_instance *timeri, int event]\n- 调用者: _snd_timer_stop\n- 被调用者: []\n\n7. 函数名: timer->hw.stop\n- 参数: [struct snd_timer *timer]\n- 调用者: _snd_timer_stop\n- 被调用者: []\n\n8. 函数名: timer->hw.start\n- 参数: [struct snd_timer *timer]\n- 调用者: _snd_timer_stop\n- 被调用者: []"
    },
    {
        "id": 943,
        "cwe": "CWE-362",
        "cve": "CVE-2016-2547",
        "purpose": "Code purpose:\"\"\"该代码用于处理Linux内核中声音定时器的关闭操作，包括主定时器和从定时器的资源释放和同步处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理从属定时器实例时，代码未正确考虑并发情况下的锁保护机制，导致竞态条件和释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_timer_close\n- 参数: [struct snd_timer_instance *timeri]\n- 调用者: 未明确（通常是外部调用）\n- 被调用者: [snd_BUG_ON, snd_timer_stop, spin_lock_irq, spin_unlock_irq, udelay, mutex_lock, list_del, mutex_unlock, _snd_timer_stop, list_move_tail, list_for_each_entry_safe, module_put, kfree]\n\n2. 函数名: snd_BUG_ON\n- 参数: [condition]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n3. 函数名: snd_timer_stop\n- 参数: [struct snd_timer_instance *timeri]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n4. 函数名: spin_lock_irq\n- 参数: [spinlock_t *lock]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n5. 函数名: spin_unlock_irq\n- 参数: [spinlock_t *lock]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n6. 函数名: udelay\n- 参数: [unsigned long usecs]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n7. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n8. 函数名: list_del\n- 参数: [struct list_head *entry]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n9. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n10. 函数名: _snd_timer_stop\n- 参数: [struct snd_timer_instance *timeri, int event, int resolution]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n11. 函数名: list_move_tail\n- 参数: [struct list_head *list, struct list_head *head]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n12. 函数名: list_for_each_entry_safe\n- 参数: [pos, n, head, member]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n13. 函数名: module_put\n- 参数: [struct module *module]\n- 调用者: snd_timer_close\n- 被调用者: []\n\n14. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: snd_timer_close\n- 被调用者: []"
    },
    {
        "id": 1051,
        "cwe": "CWE-362",
        "cve": "CVE-2016-5195",
        "purpose": "Code purpose:\"\"\"处理内存页错误，包括处理写时复制(COW)情况，并返回相应的错误码或状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理写时复制(COW)时存在竞态条件，允许本地用户通过利用对只读内存映射的错误处理来提升权限。\"\"\"",
        "functions": "Functions:\n1. 函数名: faultin_page\n- 参数: [struct task_struct *tsk, struct vm_area_struct *vma, unsigned long address, unsigned int *flags, int *nonblocking]\n- 调用者: 未明确（通常是内核中处理内存页错误的调用链）\n- 被调用者: [handle_mm_fault, stack_guard_page_start, stack_guard_page_end]\n\n2. 函数名: handle_mm_fault\n- 参数: [struct vm_area_struct *vma, unsigned long address, unsigned int fault_flags]\n- 调用者: faultin_page\n- 被调用者: 未明确（内核内存管理相关函数）\n\n3. 函数名: stack_guard_page_start\n- 参数: [struct vm_area_struct *vma, unsigned long address]\n- 调用者: faultin_page\n- 被调用者: 未明确\n\n4. 函数名: stack_guard_page_end\n- 参数: [struct vm_area_struct *vma, unsigned long address]\n- 调用者: faultin_page\n- 被调用者: 未明确"
    },
    {
        "id": 1052,
        "cwe": "CWE-362",
        "cve": "CVE-2016-5195",
        "purpose": "Code purpose:\"\"\"该代码用于处理虚拟内存区域中的页表项跟踪和页面获取操作，包括处理写时复制(COW)场景、页面迁移和设备映射等特殊情况。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理写时复制(COW)时存在竞态条件，允许本地用户通过利用对只读内存映射的错误处理来提升权限\"\"\"",
        "functions": "Functions:\n1. 函数名: follow_page_pte\n- 参数: [vma, address, pmd, flags]\n- 调用者: N/A\n- 被调用者: [pmd_bad, no_page_table, pte_offset_map_lock, pte_present, pte_none, pte_to_swp_entry, is_migration_entry, pte_unmap_unlock, migration_entry_wait, pte_write, vm_normal_page, pte_devmap, get_dev_pagemap, pte_page, follow_pfn_pte, PageTransCompound, get_page, split_huge_page, put_page, put_dev_pagemap, pte_dirty, PageDirty, set_page_dirty, mark_page_accessed, trylock_page, lru_add_drain, mlock_vma_page, unlock_page]\n\n2. 函数名: pmd_bad\n- 参数: [pmd]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n3. 函数名: no_page_table\n- 参数: [vma, flags]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n4. 函数名: pte_offset_map_lock\n- 参数: [mm, pmd, address, ptl]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n5. 函数名: pte_present\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n6. 函数名: pte_none\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n7. 函数名: pte_to_swp_entry\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n8. 函数名: is_migration_entry\n- 参数: [entry]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n9. 函数名: pte_unmap_unlock\n- 参数: [ptep, ptl]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n10. 函数名: migration_entry_wait\n- 参数: [mm, pmd, address]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n11. 函数名: pte_write\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n12. 函数名: vm_normal_page\n- 参数: [vma, address, pte]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n13. 函数名: pte_devmap\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n14. 函数名: get_dev_pagemap\n- 参数: [pte_pfn(pte), NULL]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n15. 函数名: pte_page\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n16. 函数名: follow_pfn_pte\n- 参数: [vma, address, ptep, flags]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n17. 函数名: PageTransCompound\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n18. 函数名: get_page\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n19. 函数名: split_huge_page\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n20. 函数名: put_page\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n21. 函数名: put_dev_pagemap\n- 参数: [pgmap]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n22. 函数名: pte_dirty\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n23. 函数名: PageDirty\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n24. 函数名: set_page_dirty\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n25. 函数名: mark_page_accessed\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n26. 函数名: trylock_page\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n27. 函数名: lru_add_drain\n- 参数: []\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n28. 函数名: mlock_vma_page\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: N/A\n\n29. 函数名: unlock_page\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: N/A"
    },
    {
        "id": 1059,
        "cwe": "CWE-362",
        "cve": "CVE-2016-6130",
        "purpose": "Code purpose:\"\"\"该代码用于通过ioctl系统调用处理用户空间传递的SCCB(系统控制块)数据，包括验证、拷贝和执行相关命令，并将结果返回用户空间。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在验证sccb长度后未锁定内存，导致攻击者可以在两次fetch之间修改长度值，造成内核信息泄露的双取漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: sclp_ctl_ioctl_sccb\n- 参数: [void __user *user_area]\n- 调用者: 未显示（由系统调用触发）\n- 被调用者: [copy_from_user, sclp_ctl_cmdw_supported, get_zeroed_page, u64_to_uptr, sclp_sync_request, copy_to_user, free_page]\n\n2. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: sclp_ctl_ioctl_sccb\n- 被调用者: []\n\n3. 函数名: sclp_ctl_cmdw_supported\n- 参数: [unsigned int cmdw]\n- 调用者: sclp_ctl_ioctl_sccb\n- 被调用者: []\n\n4. 函数名: get_zeroed_page\n- 参数: [gfp_t gfp_mask]\n- 调用者: sclp_ctl_ioctl_sccb\n- 被调用者: []\n\n5. 函数名: u64_to_uptr\n- 参数: [u64 x]\n- 调用者: sclp_ctl_ioctl_sccb\n- 被调用者: []\n\n6. 函数名: sclp_sync_request\n- 参数: [unsigned int cmdw, struct sccb_header *sccb]\n- 调用者: sclp_ctl_ioctl_sccb\n- 被调用者: []\n\n7. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: sclp_ctl_ioctl_sccb\n- 被调用者: []\n\n8. 函数名: free_page\n- 参数: [unsigned long addr]\n- 调用者: sclp_ctl_ioctl_sccb\n- 被调用者: []"
    },
    {
        "id": 1060,
        "cwe": "CWE-362",
        "cve": "CVE-2016-6136",
        "purpose": "Code purpose:\"\"\"记录执行execve系统调用时的参数信息用于审计\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在audit_log_execve_info函数中存在竞态条件，用户可以在内核两次获取字符串之间修改字符串内容，导致绕过字符集限制或破坏系统调用审计\"\"\"",
        "functions": "Functions:\n1. 函数名: audit_log_execve_info\n- 参数: [struct audit_context *context, struct audit_buffer **ab]\n- 调用者: 未显示\n- 被调用者: [audit_log_format, kmalloc, audit_panic, audit_log_single_execve_arg, kfree]\n\n2. 函数名: audit_log_format\n- 参数: [struct audit_buffer **ab, const char *fmt, ...]\n- 调用者: audit_log_execve_info\n- 被调用者: 未显示\n\n3. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: audit_log_execve_info\n- 被调用者: 未显示\n\n4. 函数名: audit_panic\n- 参数: [const char *message]\n- 调用者: audit_log_execve_info\n- 被调用者: 未显示\n\n5. 函数名: audit_log_single_execve_arg\n- 参数: [struct audit_context *context, struct audit_buffer **ab, int i, size_t *len_sent, const char __user *p, char *buf]\n- 调用者: audit_log_execve_info\n- 被调用者: 未显示\n\n6. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: audit_log_execve_info\n- 被调用者: 未显示"
    },
    {
        "id": 1061,
        "cwe": "CWE-362",
        "cve": "CVE-2016-6156",
        "purpose": "Code purpose:\"\"\"该代码实现了通过ioctl接口与Chrome OS嵌入式控制器(EC)进行命令交互的功能，包括从用户空间获取命令、执行命令并将结果返回给用户空间。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在检查用户空间数据大小后未保持数据一致性，导致竞争条件下可修改大小值造成越界访问\"\"\"",
        "functions": "Functions:\n1. 函数名: ec_device_ioctl_xcmd\n- 参数: [struct cros_ec_dev *ec, void __user *arg]\n- 调用者: 未明确（应为ioctl处理函数）\n- 被调用者: [copy_from_user, kmalloc, cros_ec_cmd_xfer, copy_to_user, kfree]\n\n2. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: ec_device_ioctl_xcmd\n- 被调用者: []\n\n3. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: ec_device_ioctl_xcmd\n- 被调用者: []\n\n4. 函数名: cros_ec_cmd_xfer\n- 参数: [struct cros_ec_dev *ec, struct cros_ec_command *cmd]\n- 调用者: ec_device_ioctl_xcmd\n- 被调用者: []\n\n5. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: ec_device_ioctl_xcmd\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: ec_device_ioctl_xcmd\n- 被调用者: []"
    },
    {
        "id": 1076,
        "cwe": "CWE-362",
        "cve": "CVE-2016-6480",
        "purpose": "Code purpose:\"\"\"该代码实现了通过ioctl接口发送FIB(光纤接口块)到AACRAID设备的功能，包括内存分配、数据拷贝和命令处理等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在检查用户提供的size值和后续使用该值之间存在竞争条件，攻击者可以在检查后修改size值，导致越界访问或系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: ioctl_send_fib\n- 参数: [struct aac_dev * dev, void __user *arg]\n- 调用者: 未指定（由外部调用）\n- 被调用者: [aac_fib_alloc, copy_from_user, aac_fib_free, le16_to_cpu, pci_alloc_consistent, memset, memcpy, aac_adapter_interrupt, cpu_to_le16, aac_fib_send, aac_fib_complete, copy_to_user, pci_free_consistent]\n\n2. 函数名: aac_fib_alloc\n- 参数: [struct aac_dev * dev]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n3. 函数名: copy_from_user\n- 参数: [void *kfib, void __user *arg, sizeof(struct aac_fibhdr)]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n4. 函数名: aac_fib_free\n- 参数: [struct fib *fibptr]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n5. 函数名: le16_to_cpu\n- 参数: [kfib->header.Size, kfib->header.SenderSize]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n6. 函数名: pci_alloc_consistent\n- 参数: [dev->pdev, size, &daddr]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n7. 函数名: memset\n- 参数: [((char *)kfib) + dev->max_fib_size, 0, size - dev->max_fib_size]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n8. 函数名: memcpy\n- 参数: [kfib, hw_fib, dev->max_fib_size]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n9. 函数名: aac_adapter_interrupt\n- 参数: [dev]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n10. 函数名: cpu_to_le16\n- 参数: [TakeABreakPt, kfib->header.Command]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n11. 函数名: aac_fib_send\n- 参数: [le16_to_cpu(kfib->header.Command), fibptr, le16_to_cpu(kfib->header.Size), FsaNormal, 1, 1, NULL, NULL]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n12. 函数名: aac_fib_complete\n- 参数: [fibptr]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n13. 函数名: copy_to_user\n- 参数: [arg, (void *)kfib, size]\n- 调用者: ioctl_send_fib\n- 被调用者: []\n\n14. 函数名: pci_free_consistent\n- 参数: [dev->pdev, size, kfib, fibptr->hw_fib_pa]\n- 调用者: ioctl_send_fib\n- 被调用者: []"
    },
    {
        "id": 1077,
        "cwe": "CWE-362",
        "cve": "CVE-2016-6516",
        "purpose": "Code purpose:\"\"\"该代码实现了通过ioctl系统调用进行文件去重范围操作的功能，包括从用户空间获取参数、分配内存、执行去重操作并将结果返回用户空间。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在获取用户空间参数count后未进行同步验证，导致在后续操作中可能因竞争条件而使用被修改的count值，造成堆缓冲区溢出。\"\"\"",
        "functions": "Functions:\n1. 函数名: ioctl_file_dedupe_range\n- 参数: [struct file *file, void __user *arg]\n- 调用者: 未指定（由内核IOCTL调用）\n- 被调用者: [get_user, memdup_user, vfs_dedupe_file_range, copy_to_user, kfree]\n\n2. 函数名: get_user\n- 参数: [u16 count, &argp->dest_count]\n- 调用者: ioctl_file_dedupe_range\n- 被调用者: []\n\n3. 函数名: memdup_user\n- 参数: [argp, size]\n- 调用者: ioctl_file_dedupe_range\n- 被调用者: []\n\n4. 函数名: vfs_dedupe_file_range\n- 参数: [file, same]\n- 调用者: ioctl_file_dedupe_range\n- 被调用者: []\n\n5. 函数名: copy_to_user\n- 参数: [argp, same, size]\n- 调用者: ioctl_file_dedupe_range\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [same]\n- 调用者: ioctl_file_dedupe_range\n- 被调用者: []"
    },
    {
        "id": 1110,
        "cwe": "CWE-362",
        "cve": "CVE-2016-7911",
        "purpose": "Code purpose:\"\"\"获取指定任务的I/O优先级值，包括安全检查并返回默认或任务特定的I/O优先级\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺乏适当的同步机制，在检查p->io_context和使用p->io_context->ioprio之间存在竞态条件，可能导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: get_task_ioprio\n- 参数: [struct task_struct *p]\n- 调用者: 未明确显示（由系统调用ioprio_get触发）\n- 被调用者: [security_task_getioprio, IOPRIO_PRIO_VALUE]\n\n2. 函数名: security_task_getioprio\n- 参数: [struct task_struct *p]\n- 调用者: get_task_ioprio\n- 被调用者: []\n\n3. 函数名: IOPRIO_PRIO_VALUE\n- 参数: [IOPRIO_CLASS_NONE, IOPRIO_NORM]\n- 调用者: get_task_ioprio\n- 被调用者: []"
    },
    {
        "id": 1114,
        "cwe": "CWE-362",
        "cve": "CVE-2016-7916",
        "purpose": "Code purpose:\"\"\"该代码用于读取进程的环境变量信息并通过/proc文件系统提供给用户空间，存在竞争条件漏洞可能导致内核敏感信息泄露\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在进程设置期间，环境变量复制未完成时，environ_read函数存在竞态条件，导致本地用户可能通过读取/proc/*/environ文件获取内核内存中的敏感信息。\"\"\"",
        "functions": "Functions:\n1. 函数名: environ_read\n- 参数: [struct file *file, char __user *buf, size_t count, loff_t *ppos]\n- 调用者: 未显示（由文件系统调用触发）\n- 被调用者: [__get_free_page, atomic_inc_not_zero, down_read, up_read, access_remote_vm, copy_to_user, mmput, free_page]\n\n2. 函数名: __get_free_page\n- 参数: [GFP_TEMPORARY]\n- 调用者: environ_read\n- 被调用者: []\n\n3. 函数名: atomic_inc_not_zero\n- 参数: [&mm->mm_users]\n- 调用者: environ_read\n- 被调用者: []\n\n4. 函数名: down_read\n- 参数: [&mm->mmap_sem]\n- 调用者: environ_read\n- 被调用者: []\n\n5. 函数名: up_read\n- 参数: [&mm->mmap_sem]\n- 调用者: environ_read\n- 被调用者: []\n\n6. 函数名: access_remote_vm\n- 参数: [mm, (env_start + src), page, this_len, 0]\n- 调用者: environ_read\n- 被调用者: []\n\n7. 函数名: copy_to_user\n- 参数: [buf, page, retval]\n- 调用者: environ_read\n- 被调用者: []\n\n8. 函数名: mmput\n- 参数: [mm]\n- 调用者: environ_read\n- 被调用者: []\n\n9. 函数名: free_page\n- 参数: [(unsigned long) page]\n- 调用者: environ_read\n- 被调用者: []"
    },
    {
        "id": 1131,
        "cwe": "CWE-362",
        "cve": "CVE-2016-8655",
        "purpose": "Code purpose:\"\"\"该代码用于设置和管理Linux内核中AF_PACKET套接字的环形缓冲区，处理数据包的接收和发送环形缓冲区的配置和切换操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在修改socket版本时存在竞态条件，导致在packet_set_ring和packet_setsockopt函数之间可能发生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: packet_set_ring\n- 参数: [struct sock *sk, union tpacket_req_u *req_u, int closing, int tx_ring]\n- 调用者: N/A (系统调用或内核其他部分)\n- 被调用者: [packet_read_pending, alloc_pg_vec, init_prb_bdqc, lock_sock, __unregister_prot_hook, synchronize_net, mutex_lock, spin_lock_bh, spin_unlock_bh, mutex_unlock, register_prot_hook, release_sock, free_pg_vec, prb_shutdown_retire_blk_timer, skb_queue_purge]\n\n2. 函数名: packet_read_pending\n- 参数: [struct packet_ring_buffer *rb]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n3. 函数名: alloc_pg_vec\n- 参数: [struct tpacket_req *req, int order]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n4. 函数名: init_prb_bdqc\n- 参数: [struct packet_sock *po, struct packet_ring_buffer *rb, struct pgv *pg_vec, union tpacket_req_u *req_u]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n5. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n6. 函数名: __unregister_prot_hook\n- 参数: [struct sock *sk, bool sync]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n7. 函数名: synchronize_net\n- 参数: []\n- 调用者: packet_set_ring\n- 被调用者: []\n\n8. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n9. 函数名: spin_lock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n10. 函数名: spin_unlock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n11. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n12. 函数名: register_prot_hook\n- 参数: [struct sock *sk]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n13. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n14. 函数名: free_pg_vec\n- 参数: [struct pgv *pg_vec, int order, int tp_block_nr]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n15. 函数名: prb_shutdown_retire_blk_timer\n- 参数: [struct packet_sock *po, struct sk_buff_head *rb_queue]\n- 调用者: packet_set_ring\n- 被调用者: []\n\n16. 函数名: skb_queue_purge\n- 参数: [struct sk_buff_head *list]\n- 调用者: packet_set_ring\n- 被调用者: []"
    },
    {
        "id": 1132,
        "cwe": "CWE-362",
        "cve": "CVE-2016-8655",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中AF_PACKET套接字的选项设置功能，包括成员管理、环形缓冲区配置、版本控制等网络包处理相关操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中的packet_setsockopt函数存在竞态条件漏洞，当本地用户利用CAP_NET_RAW能力更改socket版本时，可能导致use-after-free问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: packet_setsockopt\n- 参数: [struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen]\n- 调用者: 未显示（系统调用）\n- 被调用者: [pkt_sk, memset, copy_from_user, packet_mc_add, packet_mc_drop, packet_set_ring, fanout_add, fanout_set_data]\n\n2. 函数名: pkt_sk\n- 参数: [struct sock *sk]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n3. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n4. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n5. 函数名: packet_mc_add\n- 参数: [struct sock *sk, struct packet_mreq_max *mreq]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n6. 函数名: packet_mc_drop\n- 参数: [struct sock *sk, struct packet_mreq_max *mreq]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n7. 函数名: packet_set_ring\n- 参数: [struct sock *sk, union tpacket_req_u *req_u, int closing, int tx_ring]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n8. 函数名: fanout_add\n- 参数: [struct sock *sk, int val, int val_high]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n9. 函数名: fanout_set_data\n- 参数: [struct packet_sock *po, char __user *optval, unsigned int optlen]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示"
    },
    {
        "id": 1168,
        "cwe": "CWE-362",
        "cve": "CVE-2016-9794",
        "purpose": "Code purpose:\"\"\"该代码用于处理音频PCM子流周期中断事件，更新硬件指针状态并触发定时器中断，同时通知异步I/O事件\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于snd_pcm_period_elapsed函数中存在竞态条件，当处理SNDRV_PCM_TRIGGER_START命令时可能导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_pcm_period_elapsed\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: 未显示\n- 被调用者: [PCM_RUNTIME_CHECK, snd_pcm_stream_lock_irqsave, snd_pcm_running, snd_pcm_update_hw_ptr0, snd_timer_interrupt, snd_pcm_stream_unlock_irqrestore, kill_fasync]\n\n2. 函数名: PCM_RUNTIME_CHECK\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n3. 函数名: snd_pcm_stream_lock_irqsave\n- 参数: [struct snd_pcm_substream *substream, unsigned long flags]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n4. 函数名: snd_pcm_running\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n5. 函数名: snd_pcm_update_hw_ptr0\n- 参数: [struct snd_pcm_substream *substream, int in_interrupt]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n6. 函数名: snd_timer_interrupt\n- 参数: [struct snd_timer *timer, int ticks]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n7. 函数名: snd_pcm_stream_unlock_irqrestore\n- 参数: [struct snd_pcm_substream *substream, unsigned long flags]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n8. 函数名: kill_fasync\n- 参数: [struct fasync_struct **fp, int sig, int band]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []"
    },
    {
        "id": 1169,
        "cwe": "CWE-362",
        "cve": "CVE-2016-9806",
        "purpose": "Code purpose:\"\"\"该代码用于处理netlink套接字的数据转储(dump)操作，包括分配缓冲区、执行转储回调、发送结果等，但存在竞争条件可能导致双重释放漏洞。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于netlink_dump函数中存在竞态条件，当新的dump操作过早开始时会导致双重释放问题\"\"\"",
        "functions": "Functions:\n1. 函数名: netlink_dump\n- 参数: [struct sock *sk]\n- 调用者: 未明确显示（应为内核中调用netlink_dump的代码）\n- 被调用者: [nlk_sk, mutex_lock, atomic_read, max_t, alloc_skb, skb_reserve, skb_tailroom, netlink_skb_set_owner_r, cb->dump, mutex_unlock, sk_filter, kfree_skb, __netlink_sendskb, nlmsg_put_answer, nl_dump_check_consistent, nlmsg_data, memcpy, cb->done, module_put, consume_skb]\n\n2. 函数名: nlk_sk\n- 参数: [struct sock *sk]\n- 调用者: netlink_dump\n- 被调用者: []\n\n3. 函数名: mutex_lock\n- 参数: [nlk->cb_mutex]\n- 调用者: netlink_dump\n- 被调用者: []\n\n4. 函数名: atomic_read\n- 参数: [&sk->sk_rmem_alloc]\n- 调用者: netlink_dump\n- 被调用者: []\n\n5. 函数名: max_t\n- 参数: [int, cb->min_dump_alloc, NLMSG_GOODSIZE]\n- 调用者: netlink_dump\n- 被调用者: []\n\n6. 函数名: alloc_skb\n- 参数: [alloc_size, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY], [alloc_size, GFP_KERNEL]\n- 调用者: netlink_dump\n- 被调用者: []\n\n7. 函数名: skb_reserve\n- 参数: [skb, skb_tailroom(skb) - alloc_size]\n- 调用者: netlink_dump\n- 被调用者: []\n\n8. 函数名: skb_tailroom\n- 参数: [skb]\n- 调用者: netlink_dump\n- 被调用者: []\n\n9. 函数名: netlink_skb_set_owner_r\n- 参数: [skb, sk]\n- 调用者: netlink_dump\n- 被调用者: []\n\n10. 函数名: cb->dump\n- 参数: [skb, cb]\n- 调用者: netlink_dump\n- 被调用者: []\n\n11. 函数名: mutex_unlock\n- 参数: [nlk->cb_mutex]\n- 调用者: netlink_dump\n- 被调用者: []\n\n12. 函数名: sk_filter\n- 参数: [sk, skb]\n- 调用者: netlink_dump\n- 被调用者: []\n\n13. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: netlink_dump\n- 被调用者: []\n\n14. 函数名: __netlink_sendskb\n- 参数: [sk, skb]\n- 调用者: netlink_dump\n- 被调用者: []\n\n15. 函数名: nlmsg_put_answer\n- 参数: [skb, cb, NLMSG_DONE, sizeof(len), NLM_F_MULTI]\n- 调用者: netlink_dump\n- 被调用者: []\n\n16. 函数名: nl_dump_check_consistent\n- 参数: [cb, nlh]\n- 调用者: netlink_dump\n- 被调用者: []\n\n17. 函数名: nlmsg_data\n- 参数: [nlh]\n- 调用者: netlink_dump\n- 被调用者: []\n\n18. 函数名: memcpy\n- 参数: [nlmsg_data(nlh), &len, sizeof(len)]\n- 调用者: netlink_dump\n- 被调用者: []\n\n19. 函数名: cb->done\n- 参数: [cb]\n- 调用者: netlink_dump\n- 被调用者: []\n\n20. 函数名: module_put\n- 参数: [cb->module]\n- 调用者: netlink_dump\n- 被调用者: []\n\n21. 函数名: consume_skb\n- 参数: [cb->skb]\n- 调用者: netlink_dump\n- 被调用者: []"
    },
    {
        "id": 1181,
        "cwe": "CWE-362",
        "cve": "CVE-2017-1000112",
        "purpose": "Code purpose:\"\"\"该代码用于处理IP数据包的构建和分段，支持UFO(Unfragmented Offload)和非UFO路径的数据追加，确保数据在网络传输中正确分片和重组。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在UFO到非UFO路径切换时，由于负值计算导致内存越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: __ip_append_data\n- 参数: [sk, fl4, queue, cork, pfrag, getfrag, from, length, transhdrlen, flags]\n- 调用者: 未显示\n- 被调用者: [inet_sk, skb_peek_tail, ip_local_error, ip_ufo_append_data, sock_alloc_send_skb, refcount_read, sock_wmalloc, skb_reserve, skb_shinfo, skb_put, skb_set_network_header, skb_copy_and_csum_bits, csum_sub, pskb_trim_unique, getfrag, kfree_skb, __skb_queue_tail, skb_put, sk_page_frag_refill, skb_can_coalesce, __skb_fill_page_desc, get_page, page_address, skb_frag_size_add, refcount_add, IP_INC_STATS]\n\n2. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n3. 函数名: skb_peek_tail\n- 参数: [queue]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n4. 函数名: ip_local_error\n- 参数: [sk, EMSGSIZE, fl4->daddr, inet->inet_dport, mtu - (opt ? opt->optlen : 0)]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n5. 函数名: ip_ufo_append_data\n- 参数: [sk, queue, getfrag, from, length, hh_len, fragheaderlen, transhdrlen, maxfraglen, flags]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n6. 函数名: sock_alloc_send_skb\n- 参数: [sk, alloclen + hh_len + 15, (flags & MSG_DONTWAIT), &err]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n7. 函数名: refcount_read\n- 参数: [&sk->sk_wmem_alloc]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n8. 函数名: sock_wmalloc\n- 参数: [sk, alloclen + hh_len + 15, 1, sk->sk_allocation]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n9. 函数名: skb_reserve\n- 参数: [skb, hh_len]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n10. 函数名: skb_shinfo\n- 参数: [skb]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n11. 函数名: skb_put\n- 参数: [skb, fraglen + exthdrlen]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n12. 函数名: skb_set_network_header\n- 参数: [skb, exthdrlen]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n13. 函数名: skb_copy_and_csum_bits\n- 参数: [skb_prev, maxfraglen, data + transhdrlen, fraggap, 0]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n14. 函数名: csum_sub\n- 参数: [skb_prev->csum, skb->csum]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n15. 函数名: pskb_trim_unique\n- 参数: [skb_prev, maxfraglen]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n16. 函数名: getfrag\n- 参数: [from, data + transhdrlen, offset, copy, fraggap, skb]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n17. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n18. 函数名: __skb_queue_tail\n- 参数: [queue, skb]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n19. 函数名: sk_page_frag_refill\n- 参数: [sk, pfrag]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n20. 函数名: skb_can_coalesce\n- 参数: [skb, i, pfrag->page, pfrag->offset]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n21. 函数名: __skb_fill_page_desc\n- 参数: [skb, i, pfrag->page, pfrag->offset, 0]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n22. 函数名: get_page\n- 参数: [pfrag->page]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n23. 函数名: page_address\n- 参数: [pfrag->page]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n24. 函数名: skb_frag_size_add\n- 参数: [&skb_shinfo(skb)->frags[i - 1], copy]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n25. 函数名: refcount_add\n- 参数: [copy, &sk->sk_wmem_alloc]\n- 调用者: __ip_append_data\n- 被调用者: 未显示\n\n26. 函数名: IP_INC_STATS\n- 参数: [sock_net(sk), IPSTATS_MIB_OUTDISCARDS]\n- 调用者: __ip_append_data\n- 被调用者: 未显示"
    },
    {
        "id": 1182,
        "cwe": "CWE-362",
        "cve": "CVE-2017-1000112",
        "purpose": "Code purpose:\"\"\"处理IP数据包的分片和组装，支持UFO(Unfragmented Offload)和非UFO路径的数据追加\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当UFO路径切换到非UFO路径时，由于数据包长度计算错误导致负值，进而引发内存越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: ip_append_page\n- 参数: [sk, fl4, page, offset, size, flags]\n- 调用者: N/A\n- 被调用者: [inet_sk, ip_sk_ignore_df, ip_local_error, skb_peek_tail, skb_shinfo, skb_is_gso, sock_wmalloc, skb_copy_and_csum_bits, csum_sub, pskb_trim_unique, __skb_queue_tail, skb_append_pagefrags, csum_page, csum_block_add, sock_net, IP_INC_STATS]\n\n2. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n3. 函数名: ip_sk_ignore_df\n- 参数: [sk]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n4. 函数名: ip_local_error\n- 参数: [sk, EMSGSIZE, fl4->daddr, inet->inet_dport, mtu - (opt ? opt->optlen : 0)]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n5. 函数名: skb_peek_tail\n- 参数: [&sk->sk_write_queue]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n6. 函数名: skb_shinfo\n- 参数: [skb]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n7. 函数名: skb_is_gso\n- 参数: [skb]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n8. 函数名: sock_wmalloc\n- 参数: [sk, alloclen, 1, sk->sk_allocation]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n9. 函数名: skb_copy_and_csum_bits\n- 参数: [skb_prev, maxfraglen, skb_transport_header(skb), fraggap, 0]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n10. 函数名: csum_sub\n- 参数: [skb_prev->csum, skb->csum]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n11. 函数名: pskb_trim_unique\n- 参数: [skb_prev, maxfraglen]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n12. 函数名: __skb_queue_tail\n- 参数: [&sk->sk_write_queue, skb]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n13. 函数名: skb_append_pagefrags\n- 参数: [skb, page, offset, len]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n14. 函数名: csum_page\n- 参数: [page, offset, len]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n15. 函数名: csum_block_add\n- 参数: [skb->csum, csum, skb->len]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n16. 函数名: sock_net\n- 参数: [sk]\n- 调用者: ip_append_page\n- 被调用者: N/A\n\n17. 函数名: IP_INC_STATS\n- 参数: [sock_net(sk), IPSTATS_MIB_OUTDISCARDS]\n- 调用者: ip_append_page\n- 被调用者: N/A"
    },
    {
        "id": 1183,
        "cwe": "CWE-362",
        "cve": "CVE-2017-1000112",
        "purpose": "Code purpose:\"\"\"该代码实现了UDP数据包的构建和发送功能，包括UDP头部的创建、校验和计算以及通过IP层发送数据包\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于UFO到非UFO路径切换时未正确处理数据包长度，导致负值计算引发内存越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: udp_send_skb\n- 参数: [skb, fl4]\n- 调用者: 未明确（应为上层UDP发送函数）\n- 被调用者: [udp_hdr, htons, udplite_csum, udp4_hwcsum, udp_csum, csum_tcpudp_magic, ip_send_skb, sock_net, UDP_INC_STATS]\n\n2. 函数名: udp_hdr\n- 参数: [skb]\n- 调用者: udp_send_skb\n- 被调用者: []\n\n3. 函数名: htons\n- 参数: [len]\n- 调用者: udp_send_skb\n- 被调用者: []\n\n4. 函数名: udplite_csum\n- 参数: [skb]\n- 调用者: udp_send_skb\n- 被调用者: []\n\n5. 函数名: udp4_hwcsum\n- 参数: [skb, fl4->saddr, fl4->daddr]\n- 调用者: udp_send_skb\n- 被调用者: []\n\n6. 函数名: udp_csum\n- 参数: [skb]\n- 调用者: udp_send_skb\n- 被调用者: []\n\n7. 函数名: csum_tcpudp_magic\n- 参数: [fl4->saddr, fl4->daddr, len, sk->sk_protocol, csum]\n- 调用者: udp_send_skb\n- 被调用者: []\n\n8. 函数名: ip_send_skb\n- 参数: [sock_net(sk), skb]\n- 调用者: udp_send_skb\n- 被调用者: []\n\n9. 函数名: sock_net\n- 参数: [sk]\n- 调用者: udp_send_skb\n- 被调用者: []\n\n10. 函数名: UDP_INC_STATS\n- 参数: [sock_net(sk), UDP_MIB_SNDBUFERRORS/UDP_MIB_OUTDATAGRAMS, is_udplite]\n- 调用者: udp_send_skb\n- 被调用者: []"
    },
    {
        "id": 1184,
        "cwe": "CWE-362",
        "cve": "CVE-2017-1000112",
        "purpose": "Code purpose:\"\"\"处理IPv6数据包的构建和分片，包括UFO(Unfragmentable Option)路径和非UFO路径的数据追加和内存管理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当UFO路径切换到非UFO路径时，由于数据包长度超过MTU导致负值计算，进而引发内存越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: __ip6_append_data\n- 参数: [sk, fl6, queue, cork, v6_cork, pfrag, getfrag, from, length, transhdrlen, flags, ipc6, sockc]\n- 调用者: 未显示（由内核网络栈调用）\n- 被调用者: [ipv6_local_rxpmtu, ipv6_local_error, sock_tx_timestamp, ip6_ufo_append_data, ip6_append_data_mtu, sock_alloc_send_skb, sock_wmalloc, skb_copy_and_csum_bits, pskb_trim_unique, __skb_queue_tail, sk_page_frag_refill, skb_can_coalesce, __skb_fill_page_desc]\n\n2. 函数名: ipv6_local_rxpmtu\n- 参数: [sk, fl6, mtu]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n3. 函数名: ipv6_local_error\n- 参数: [sk, EMSGSIZE, fl6, mtu]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n4. 函数名: sock_tx_timestamp\n- 参数: [sk, sockc->tsflags, &tx_flags]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n5. 函数名: ip6_ufo_append_data\n- 参数: [sk, queue, getfrag, from, length, hh_len, fragheaderlen, exthdrlen, transhdrlen, mtu, flags, fl6]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n6. 函数名: ip6_append_data_mtu\n- 参数: [&mtu, &maxfraglen, fragheaderlen, skb, rt, orig_mtu]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n7. 函数名: sock_alloc_send_skb\n- 参数: [sk, alloclen + hh_len, (flags & MSG_DONTWAIT), &err]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n8. 函数名: sock_wmalloc\n- 参数: [sk, alloclen + hh_len, 1, sk->sk_allocation]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n9. 函数名: skb_copy_and_csum_bits\n- 参数: [skb_prev, maxfraglen, data + transhdrlen, fraggap, 0]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n10. 函数名: pskb_trim_unique\n- 参数: [skb_prev, maxfraglen]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n11. 函数名: __skb_queue_tail\n- 参数: [queue, skb]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n12. 函数名: sk_page_frag_refill\n- 参数: [sk, pfrag]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n13. 函数名: skb_can_coalesce\n- 参数: [skb, i, pfrag->page, pfrag->offset]\n- 调用者: __ip6_append_data\n- 被调用者: []\n\n14. 函数名: __skb_fill_page_desc\n- 参数: [skb, i, pfrag->page, pfrag->offset, 0]\n- 调用者: __ip6_append_data\n- 被调用者: []"
    },
    {
        "id": 1238,
        "cwe": "CWE-362",
        "cve": "CVE-2017-1000405",
        "purpose": "Code purpose:\"\"\"该代码片段实现了通过虚拟内存区域和页表项跟踪设备映射页面的功能，包括权限检查、页面获取和引用计数管理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在THP实现中，touch_pmd()函数错误地使用了pmd_mkdirty()，使得通过get_user_pages()访问的pmd会被标记为脏页，绕过了COW机制，导致只读大页可被覆盖。\"\"\"",
        "functions": "Functions:\n1. 函数名: follow_devmap_pud\n- 参数: [struct vm_area_struct *vma, unsigned long addr, pud_t *pud, int flags]\n- 调用者: 未明确（由内核调用）\n- 被调用者: [pud_pfn, pud_write, pud_present, pud_devmap, touch_pud, get_dev_pagemap, pfn_to_page, get_page, put_dev_pagemap, ERR_PTR]\n\n2. 函数名: pud_pfn\n- 参数: [pud_t *pud]\n- 调用者: follow_devmap_pud\n- 被调用者: []\n\n3. 函数名: pud_write\n- 参数: [pud_t *pud]\n- 调用者: follow_devmap_pud\n- 被调用者: []\n\n4. 函数名: pud_present\n- 参数: [pud_t *pud]\n- 调用者: follow_devmap_pud\n- 被调用者: []\n\n5. 函数名: pud_devmap\n- 参数: [pud_t *pud]\n- 调用者: follow_devmap_pud\n- 被调用者: []\n\n6. 函数名: touch_pud\n- 参数: [struct vm_area_struct *vma, unsigned long addr, pud_t *pud]\n- 调用者: follow_devmap_pud\n- 被调用者: []\n\n7. 函数名: get_dev_pagemap\n- 参数: [unsigned long pfn, NULL]\n- 调用者: follow_devmap_pud\n- 被调用者: []\n\n8. 函数名: pfn_to_page\n- 参数: [unsigned long pfn]\n- 调用者: follow_devmap_pud\n- 被调用者: []\n\n9. 函数名: get_page\n- 参数: [struct page *page]\n- 调用者: follow_devmap_pud\n- 被调用者: []\n\n10. 函数名: put_dev_pagemap\n- 参数: [struct dev_pagemap *pgmap]\n- 调用者: follow_devmap_pud\n- 被调用者: []\n\n11. 函数名: ERR_PTR\n- 参数: [long error]\n- 调用者: follow_devmap_pud\n- 被调用者: []"
    },
    {
        "id": 1239,
        "cwe": "CWE-362",
        "cve": "CVE-2017-1000405",
        "purpose": "Code purpose:\"\"\"该代码用于处理设备映射的大页(THP)的页表项(PMD)跟随操作，包括权限检查、脏页标记和页面引用管理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在THP实现中，touch_pmd()函数被get_user_pages()调用时会使pmd变为dirty状态，绕过了COW机制，导致可以覆盖只读大页。\"\"\"",
        "functions": "Functions:\n1. 函数名: follow_devmap_pmd\n- 参数: [struct vm_area_struct *vma, unsigned long addr, pmd_t *pmd, int flags]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [assert_spin_locked, pmd_lockptr, pmd_pfn, WARN_ONCE, pmd_write, pmd_present, pmd_devmap, touch_pmd, get_dev_pagemap, pfn_to_page, get_page, put_dev_pagemap]\n\n2. 函数名: assert_spin_locked\n- 参数: [spinlock_t *lock]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n3. 函数名: pmd_lockptr\n- 参数: [struct mm_struct *mm, pmd_t *pmd]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n4. 函数名: pmd_pfn\n- 参数: [pmd_t pmd]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n5. 函数名: WARN_ONCE\n- 参数: [bool condition, const char *format]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n6. 函数名: pmd_write\n- 参数: [pmd_t pmd]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n7. 函数名: pmd_present\n- 参数: [pmd_t pmd]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n8. 函数名: pmd_devmap\n- 参数: [pmd_t pmd]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n9. 函数名: touch_pmd\n- 参数: [struct vm_area_struct *vma, unsigned long addr, pmd_t *pmd]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n10. 函数名: get_dev_pagemap\n- 参数: [unsigned long pfn, struct dev_pagemap **pgmap]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n11. 函数名: pfn_to_page\n- 参数: [unsigned long pfn]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n12. 函数名: get_page\n- 参数: [struct page *page]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n13. 函数名: put_dev_pagemap\n- 参数: [struct dev_pagemap *pgmap]\n- 调用者: follow_devmap_pmd\n- 被调用者: []"
    },
    {
        "id": 1240,
        "cwe": "CWE-362",
        "cve": "CVE-2017-1000405",
        "purpose": "Code purpose:\"\"\"该代码用于处理透明大页(THP)的页表项(pmd)跟踪操作，包括权限检查、NUMA提示、内存锁定(mlock)以及获取页面引用等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在THP实现中，touch_pmd()函数被get_user_pages()调用时会使pmd变为dirty状态，绕过了can_follow_write_pmd()的COW检查逻辑，导致可以覆盖只读大页。\"\"\"",
        "functions": "Functions:\n1. 函数名: follow_trans_huge_pmd\n- 参数: [vma, addr, pmd, flags]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [assert_spin_locked, can_follow_write_pmd, is_huge_zero_pmd, pmd_protnone, pmd_page, touch_pmd, PageAnon, compound_mapcount, PageDoubleMap, trylock_page, lru_add_drain, mlock_vma_page, unlock_page, get_page]\n\n2. 函数名: assert_spin_locked\n- 参数: [pmd_lockptr(mm, pmd)]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n3. 函数名: can_follow_write_pmd\n- 参数: [*pmd, flags]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n4. 函数名: is_huge_zero_pmd\n- 参数: [*pmd]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n5. 函数名: pmd_protnone\n- 参数: [*pmd]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n6. 函数名: pmd_page\n- 参数: [*pmd]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n7. 函数名: touch_pmd\n- 参数: [vma, addr, pmd]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n8. 函数名: PageAnon\n- 参数: [page]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n9. 函数名: compound_mapcount\n- 参数: [page]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n10. 函数名: PageDoubleMap\n- 参数: [page]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n11. 函数名: trylock_page\n- 参数: [page]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n12. 函数名: lru_add_drain\n- 参数: []\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n13. 函数名: mlock_vma_page\n- 参数: [page]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n14. 函数名: unlock_page\n- 参数: [page]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n15. 函数名: get_page\n- 参数: [page]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []"
    },
    {
        "id": 1254,
        "cwe": "CWE-362",
        "cve": "CVE-2017-12146",
        "purpose": "Code purpose:\"\"\"该代码用于处理设备驱动覆盖的存储操作，允许通过用户空间输入来设置或清除平台设备的driver_override属性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中driver_override实现存在竞态条件漏洞，允许本地用户通过读写操作间的竞争条件利用不同覆盖值来提升权限\"\"\"",
        "functions": "Functions:\n1. 函数名: driver_override_store\n- 参数: [dev, attr, buf, count]\n- 调用者: 未明确显示（通常由设备属性操作调用）\n- 被调用者: [to_platform_device, kstrndup, strchr, strlen, kfree]\n\n2. 函数名: to_platform_device\n- 参数: [dev]\n- 调用者: driver_override_store\n- 被调用者: []\n\n3. 函数名: kstrndup\n- 参数: [buf, count, GFP_KERNEL]\n- 调用者: driver_override_store\n- 被调用者: []\n\n4. 函数名: strchr\n- 参数: [driver_override, '\\n']\n- 调用者: driver_override_store\n- 被调用者: []\n\n5. 函数名: strlen\n- 参数: [driver_override]\n- 调用者: driver_override_store\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [driver_override] 和 [old]\n- 调用者: driver_override_store\n- 被调用者: []"
    },
    {
        "id": 1255,
        "cwe": "CWE-362",
        "cve": "CVE-2017-12146",
        "purpose": "Code purpose:\"\"\"该代码用于显示平台设备(platform device)的driver_override属性值到用户提供的缓冲区中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中driver_override的实现存在竞态条件漏洞，允许本地用户通过读写操作间的竞争来提升权限\"\"\"",
        "functions": "Functions:\n1. 函数名: driver_override_show\n- 参数: [struct device *dev, struct device_attribute *attr, char *buf]\n- 调用者: 未明确显示（通常由设备属性子系统调用）\n- 被调用者: [to_platform_device, sprintf]\n\n2. 函数名: to_platform_device\n- 参数: [struct device *dev]\n- 调用者: driver_override_show\n- 被调用者: []\n\n3. 函数名: sprintf\n- 参数: [char *buf, const char *format, ...]\n- 调用者: driver_override_show\n- 被调用者: []"
    },
    {
        "id": 1299,
        "cwe": "CWE-362",
        "cve": "CVE-2017-15129",
        "purpose": "Code purpose:\"\"\"通过ID查找并获取对应的网络命名空间引用，但不充分检查引用计数可能导致释放后使用漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"函数get_net_ns_by_id()在找到peer网络后未检查net::count值，导致可能发生use-after-free和内存损坏\"\"\"",
        "functions": "Functions:\n1. 函数名: get_net_ns_by_id\n- 参数: [net, id]\n- 调用者: 不适用（未在代码片段中显示）\n- 被调用者: [rcu_read_lock, spin_lock_bh, idr_find, get_net, spin_unlock_bh, rcu_read_unlock]\n\n2. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: get_net_ns_by_id\n- 被调用者: []\n\n3. 函数名: spin_lock_bh\n- 参数: [&net->nsid_lock]\n- 调用者: get_net_ns_by_id\n- 被调用者: []\n\n4. 函数名: idr_find\n- 参数: [&net->netns_ids, id]\n- 调用者: get_net_ns_by_id\n- 被调用者: []\n\n5. 函数名: get_net\n- 参数: [peer]\n- 调用者: get_net_ns_by_id\n- 被调用者: []\n\n6. 函数名: spin_unlock_bh\n- 参数: [&net->nsid_lock]\n- 调用者: get_net_ns_by_id\n- 被调用者: []\n\n7. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: get_net_ns_by_id\n- 被调用者: []"
    },
    {
        "id": 1300,
        "cwe": "CWE-362",
        "cve": "CVE-2017-15265",
        "purpose": "Code purpose:\"\"\"该代码用于在ALSA子系统中创建序列端口，处理用户空间和内核空间客户端的端口创建请求，并设置相应的端口属性和回调函数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于ALSA子系统中创建端口时存在竞态条件，导致在ioctl调用过程中可能发生use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_seq_ioctl_create_port\n- 参数: [struct snd_seq_client *client, void *arg]\n- 调用者: 未指定（由ioctl调用触发）\n- 被调用者: [snd_seq_create_port, snd_seq_delete_port, snd_seq_set_port_info, snd_seq_system_client_ev_port_start]\n\n2. 函数名: snd_seq_create_port\n- 参数: [struct snd_seq_client *client, int port]\n- 调用者: snd_seq_ioctl_create_port\n- 被调用者: 未指定\n\n3. 函数名: snd_seq_delete_port\n- 参数: [struct snd_seq_client *client, int port]\n- 调用者: snd_seq_ioctl_create_port\n- 被调用者: 未指定\n\n4. 函数名: snd_seq_set_port_info\n- 参数: [struct snd_seq_client_port *port, struct snd_seq_port_info *info]\n- 调用者: snd_seq_ioctl_create_port\n- 被调用者: 未指定\n\n5. 函数名: snd_seq_system_client_ev_port_start\n- 参数: [int client, int port]\n- 调用者: snd_seq_ioctl_create_port\n- 被调用者: 未指定"
    },
    {
        "id": 1301,
        "cwe": "CWE-362",
        "cve": "CVE-2017-15265",
        "purpose": "Code purpose:\"\"\"创建一个新的ALSA序列端口并初始化其相关数据结构\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在ALSA子系统中对端口列表的操作缺乏适当的同步保护，导致在并发ioctl调用时可能发生竞态条件，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_seq_create_port\n- 参数: [struct snd_seq_client *client, int port]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [snd_BUG_ON, pr_warn, kzalloc, sprintf, snd_use_lock_init, port_subs_info_init, mutex_lock, write_lock_irqsave, list_for_each_entry, list_add_tail, write_unlock_irqrestore, mutex_unlock]\n\n2. 函数名: snd_BUG_ON\n- 参数: [!client]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n3. 函数名: pr_warn\n- 参数: [\"ALSA: seq: too many ports for client %d\\n\", client->number]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n4. 函数名: kzalloc\n- 参数: [sizeof(*new_port), GFP_KERNEL]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n5. 函数名: sprintf\n- 参数: [new_port->name, \"port-%d\", num]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n6. 函数名: snd_use_lock_init\n- 参数: [&new_port->use_lock]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n7. 函数名: port_subs_info_init\n- 参数: [&new_port->c_src]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n8. 函数名: port_subs_info_init\n- 参数: [&new_port->c_dest]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n9. 函数名: mutex_lock\n- 参数: [&client->ports_mutex]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n10. 函数名: write_lock_irqsave\n- 参数: [&client->ports_lock, flags]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n11. 函数名: list_for_each_entry\n- 参数: [p, &client->ports_list_head, list]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n12. 函数名: list_add_tail\n- 参数: [&new_port->list, &p->list]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n13. 函数名: write_unlock_irqrestore\n- 参数: [&client->ports_lock, flags]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n14. 函数名: mutex_unlock\n- 参数: [&client->ports_mutex]\n- 调用者: snd_seq_create_port\n- 被调用者: []"
    },
    {
        "id": 1366,
        "cwe": "CWE-362",
        "cve": "CVE-2017-17712",
        "purpose": "Code purpose:\"\"\"处理原始套接字发送消息的请求，包括地址验证、路由查找和数据发送等功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中的raw_sendmsg()函数存在竞争条件，导致inet->hdrincl状态不一致，从而引发未初始化的栈指针使用，允许本地用户执行代码并提升权限。\"\"\"",
        "functions": "Functions:\n1. 函数名: raw_sendmsg\n- 参数: [struct sock *sk, struct msghdr *msg, size_t len]\n- 调用者: 未显示\n- 被调用者: [inet_sk, sock_net, ip_cmsg_send, kfree, rcu_read_lock, rcu_dereference, memcpy, rcu_read_unlock, get_rtconn_flags, ipv4_is_multicast, flowi4_init_output, raw_probe_proto_opt, security_sk_classify_flow, ip_route_output_flow, sock_flag, raw_send_hdrinc, sock_tx_timestamp, lock_sock, ip_append_data, ip_flush_pending_frames, ip_push_pending_frames, release_sock, ip_rt_put, dst_confirm_neigh]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n3. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n4. 函数名: ip_cmsg_send\n- 参数: [struct sock *sk, struct msghdr *msg, struct ipcm_cookie *ipc, bool false]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n5. 函数名: kfree\n- 参数: [void *ptr]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n6. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n7. 函数名: rcu_dereference\n- 参数: [struct ip_options_rcu *inet_opt]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n8. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n9. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n10. 函数名: get_rtconn_flags\n- 参数: [struct ipcm_cookie *ipc, struct sock *sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n11. 函数名: ipv4_is_multicast\n- 参数: [__be32 addr]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n12. 函数名: flowi4_init_output\n- 参数: [struct flowi4 *fl4, int oif, __u32 mark, __u8 tos, __u8 scope, __u8 proto, __u8 flags, __be32 daddr, __be32 saddr, __be16 sport, __be16 dport, kuid_t uid]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n13. 函数名: raw_probe_proto_opt\n- 参数: [struct raw_frag_vec *rfv, struct flowi4 *fl4]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n14. 函数名: security_sk_classify_flow\n- 参数: [struct sock *sk, struct flowi *fl]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n15. 函数名: ip_route_output_flow\n- 参数: [struct net *net, struct flowi4 *flp, struct sock *sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n16. 函数名: sock_flag\n- 参数: [struct sock *sk, enum sock_flags flag]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n17. 函数名: raw_send_hdrinc\n- 参数: [struct sock *sk, struct flowi4 *fl4, struct msghdr *msg, size_t len, struct rtable **rtp, unsigned int flags, struct sockcm_cookie *sockc]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n18. 函数名: sock_tx_timestamp\n- 参数: [struct sock *sk, __u16 tsflags, __u8 *tx_flags]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n19. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n20. 函数名: ip_append_data\n- 参数: [struct sock *sk, struct flowi4 *fl4, int (*getfrag)(void *from, char *to, int offset, int len, int odd, struct sk_buff *skb), void *from, int length, int transhdrlen, struct ipcm_cookie *ipc, struct rtable **rtp, unsigned int flags]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n21. 函数名: ip_flush_pending_frames\n- 参数: [struct sock *sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n22. 函数名: ip_push_pending_frames\n- 参数: [struct sock *sk, struct flowi4 *fl4]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n23. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n24. 函数名: ip_rt_put\n- 参数: [struct rtable *rt]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示\n\n25. 函数名: dst_confirm_neigh\n- 参数: [struct dst_entry *dst, const void *daddr]\n- 调用者: raw_sendmsg\n- 被调用者: 未显示"
    },
    {
        "id": 1411,
        "cwe": "CWE-362",
        "cve": "CVE-2017-18224",
        "purpose": "Code purpose:\"\"\"该代码实现了OCFS2文件系统中直接I/O(DIRECT I/O)操作的功能，包括处理内联数据、追加写入检查以及根据读写操作选择不同的块获取方法。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在DIRECT模式读取操作中，由于未使用信号量保护对extent树的访问，导致存在竞争条件，可能被本地用户利用修改e_cpos字段造成拒绝服务。\"\"\"",
        "functions": "Functions:\n1. 函数名: ocfs2_direct_IO\n- 参数: [struct kiocb *iocb, struct iov_iter *iter]\n- 调用者: 未显示（由文件系统调用）\n- 被调用者: [OCFS2_I, i_size_read, ocfs2_supports_append_dio, iov_iter_rw, ocfs2_get_block, ocfs2_dio_get_block, __blockdev_direct_IO]\n\n2. 函数名: OCFS2_I\n- 参数: [struct inode *inode]\n- 调用者: ocfs2_direct_IO\n- 被调用者: []\n\n3. 函数名: i_size_read\n- 参数: [struct inode *inode]\n- 调用者: ocfs2_direct_IO\n- 被调用者: []\n\n4. 函数名: ocfs2_supports_append_dio\n- 参数: [struct ocfs2_super *osb]\n- 调用者: ocfs2_direct_IO\n- 被调用者: []\n\n5. 函数名: iov_iter_rw\n- 参数: [struct iov_iter *iter]\n- 调用者: ocfs2_direct_IO\n- 被调用者: []\n\n6. 函数名: ocfs2_get_block\n- 参数: 未显示（函数指针）\n- 调用者: ocfs2_direct_IO\n- 被调用者: []\n\n7. 函数名: ocfs2_dio_get_block\n- 参数: 未显示（函数指针）\n- 调用者: ocfs2_direct_IO\n- 被调用者: []\n\n8. 函数名: __blockdev_direct_IO\n- 参数: [struct kiocb *iocb, struct inode *inode, struct block_device *bdev, struct iov_iter *iter, get_block_t *get_block, dio_iodone_t *end_io, dio_submit_t *submit_io, int flags]\n- 调用者: ocfs2_direct_IO\n- 被调用者: []\n\n9. 函数名: ocfs2_dio_end_io\n- 参数: 未显示（函数指针）\n- 调用者: __blockdev_direct_IO\n- 被调用者: []"
    },
    {
        "id": 1425,
        "cwe": "CWE-362",
        "cve": "CVE-2017-18249",
        "purpose": "Code purpose:\"\"\"该代码用于在F2FS文件系统中添加空闲节点ID到空闲列表，并处理相关的并发控制和内存管理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在多线程并发环境下，未对nid分配进行适当的同步保护，导致竞争条件可能引发拒绝服务或其他未定义行为\"\"\"",
        "functions": "Functions:\n1. 函数名: add_free_nid\n- 参数: [struct f2fs_sb_info *sbi, nid_t nid, bool build]\n- 调用者: 未指定\n- 被调用者: [__lookup_nat_cache, get_nat_flag, nat_get_blkaddr, f2fs_kmem_cache_alloc, radix_tree_preload, kmem_cache_free, __insert_nid_to_list, spin_lock, spin_unlock, radix_tree_preload_end]\n\n2. 函数名: __lookup_nat_cache\n- 参数: [struct f2fs_nm_info *nm_i, nid_t nid]\n- 调用者: add_free_nid\n- 被调用者: 未指定\n\n3. 函数名: get_nat_flag\n- 参数: [struct nat_entry *ne, IS_CHECKPOINTED]\n- 调用者: add_free_nid\n- 被调用者: 未指定\n\n4. 函数名: nat_get_blkaddr\n- 参数: [struct nat_entry *ne]\n- 调用者: add_free_nid\n- 被调用者: 未指定\n\n5. 函数名: f2fs_kmem_cache_alloc\n- 参数: [free_nid_slab, GFP_NOFS]\n- 调用者: add_free_nid\n- 被调用者: 未指定\n\n6. 函数名: radix_tree_preload\n- 参数: [GFP_NOFS]\n- 调用者: add_free_nid\n- 被调用者: 未指定\n\n7. 函数名: kmem_cache_free\n- 参数: [free_nid_slab, struct free_nid *i]\n- 调用者: add_free_nid\n- 被调用者: 未指定\n\n8. 函数名: __insert_nid_to_list\n- 参数: [struct f2fs_sb_info *sbi, struct free_nid *i, FREE_NID_LIST, bool true]\n- 调用者: add_free_nid\n- 被调用者: 未指定\n\n9. 函数名: spin_lock\n- 参数: [&nm_i->nid_list_lock]\n- 调用者: add_free_nid\n- 被调用者: 未指定\n\n10. 函数名: spin_unlock\n- 参数: [&nm_i->nid_list_lock]\n- 调用者: add_free_nid\n- 被调用者: 未指定\n\n11. 函数名: radix_tree_preload_end\n- 参数: []\n- 调用者: add_free_nid\n- 被调用者: 未指定"
    },
    {
        "id": 1477,
        "cwe": "CWE-362",
        "cve": "CVE-2017-6001",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中的perf_event_open系统调用，用于创建和管理性能监控事件，支持硬件和软件事件的配置、分组及上下文切换等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在将软件事件组移动到硬件上下文时存在竞态条件，导致本地用户可以通过并发调用perf_event_open系统调用来提升权限。\"\"\"",
        "functions": "Functions:\n1. 函数名: SYSCALL_DEFINE5(perf_event_open)\n- 参数: [struct perf_event_attr __user *attr_uptr, pid_t pid, int cpu, int group_fd, unsigned long flags]\n- 调用者: 系统调用\n- 被调用者: [perf_copy_attr, perf_paranoid_kernel, capable, get_unused_fd_flags, perf_fget_light, find_lively_task_by_vpid, mutex_lock_interruptible, ptrace_may_access, perf_event_alloc, perf_event_set_clock, find_get_context, perf_event_set_output, anon_inode_getfile, mutex_lock_double, mutex_lock, perf_event_validate_size, exclusive_event_installable, perf_remove_from_context, synchronize_rcu, perf_event__state_init, perf_install_in_context, perf_event__header_size, perf_event__id_header_size, perf_unpin_context, mutex_unlock, put_task_struct, put_online_cpus, list_add_tail, fdput, fd_install, fput, perf_unpin_context, put_ctx, free_event, put_unused_fd]\n\n2. 函数名: perf_copy_attr\n- 参数: [struct perf_event_attr __user *uattr, struct perf_event_attr *attr]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n3. 函数名: perf_paranoid_kernel\n- 参数: []\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n4. 函数名: capable\n- 参数: [int cap]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n5. 函数名: get_unused_fd_flags\n- 参数: [int flags]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n6. 函数名: perf_fget_light\n- 参数: [int fd, struct fd *fget]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n7. 函数名: find_lively_task_by_vpid\n- 参数: [pid_t vpid]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n8. 函数名: mutex_lock_interruptible\n- 参数: [struct mutex *lock]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n9. 函数名: ptrace_may_access\n- 参数: [struct task_struct *task, unsigned int mode]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n10. 函数名: perf_event_alloc\n- 参数: [struct perf_event_attr *attr, int cpu, struct task_struct *task, struct perf_event *group_leader, perf_overflow_handler_t overflow_handler, void *context, int cgroup_fd]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n11. 函数名: perf_event_set_clock\n- 参数: [struct perf_event *event, clockid_t clockid]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n12. 函数名: find_get_context\n- 参数: [struct pmu *pmu, struct task_struct *task, struct perf_event *event]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n13. 函数名: perf_event_set_output\n- 参数: [struct perf_event *event, struct perf_event *output_event]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n14. 函数名: anon_inode_getfile\n- 参数: [const char *name, const struct file_operations *fops, void *priv, int flags]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n15. 函数名: mutex_lock_double\n- 参数: [struct mutex *lock1, struct mutex *lock2]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n16. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n17. 函数名: perf_event_validate_size\n- 参数: [struct perf_event *event]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n18. 函数名: exclusive_event_installable\n- 参数: [struct perf_event *event, struct perf_event_context *ctx]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n19. 函数名: perf_remove_from_context\n- 参数: [struct perf_event *event, unsigned long flags]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n20. 函数名: synchronize_rcu\n- 参数: []\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n21. 函数名: perf_event__state_init\n- 参数: [struct perf_event *event]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n22. 函数名: perf_install_in_context\n- 参数: [struct perf_event_context *ctx, struct perf_event *event, int cpu]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n23. 函数名: perf_event__header_size\n- 参数: [struct perf_event *event]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n24. 函数名: perf_event__id_header_size\n- 参数: [struct perf_event *event]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n25. 函数名: perf_unpin_context\n- 参数: [struct perf_event_context *ctx]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n26. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n27. 函数名: put_task_struct\n- 参数: [struct task_struct *t]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n28. 函数名: put_online_cpus\n- 参数: []\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n29. 函数名: list_add_tail\n- 参数: [struct list_head *new, struct list_head *head]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n30. 函数名: fdput\n- 参数: [struct fd fd]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n31. 函数名: fd_install\n- 参数: [int fd, struct file *file]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n32. 函数名: fput\n- 参数: [struct file *file]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n33. 函数名: put_ctx\n- 参数: [struct perf_event_context *ctx]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n34. 函数名: free_event\n- 参数: [struct perf_event *event]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []\n\n35. 函数名: put_unused_fd\n- 参数: [int fd]\n- 调用者: SYSCALL_DEFINE5(perf_event_open)\n- 被调用者: []"
    },
    {
        "id": 1482,
        "cwe": "CWE-362",
        "cve": "CVE-2017-6346",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中PACKET_FANOUT套接字选项的功能，用于将多个套接字绑定到一个fanout组以实现数据包的多线程处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多线程环境下对fanout_list的访问缺乏足够的同步保护，导致竞争条件可能引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: fanout_add\n- 参数: [struct sock *sk, u16 id, u16 type_flags]\n- 调用者: 未显示（应为系统调用处理函数）\n- 被调用者: [pkt_sk, kzalloc, atomic_long_set, mutex_lock, list_for_each_entry, read_pnet, sock_net, write_pnet, spin_lock_init, atomic_set, fanout_init_data, dev_add_pack, list_add, atomic_read, __dev_remove_pack, atomic_inc, __fanout_link, mutex_unlock, kfree]\n\n2. 函数名: pkt_sk\n- 参数: [struct sock *sk]\n- 调用者: fanout_add\n- 被调用者: []\n\n3. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: fanout_add\n- 被调用者: []\n\n4. 函数名: atomic_long_set\n- 参数: [atomic_long_t *v, long i]\n- 调用者: fanout_add\n- 被调用者: []\n\n5. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: fanout_add\n- 被调用者: []\n\n6. 函数名: list_for_each_entry\n- 参数: [type *pos, struct list_head *head, member]\n- 调用者: fanout_add\n- 被调用者: []\n\n7. 函数名: read_pnet\n- 参数: [possible_net_t *net]\n- 调用者: fanout_add\n- 被调用者: []\n\n8. 函数名: sock_net\n- 参数: [const struct sock *sk]\n- 调用者: fanout_add\n- 被调用者: []\n\n9. 函数名: write_pnet\n- 参数: [possible_net_t *net, struct net *net]\n- 调用者: fanout_add\n- 被调用者: []\n\n10. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: fanout_add\n- 被调用者: []\n\n11. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: fanout_add\n- 被调用者: []\n\n12. 函数名: fanout_init_data\n- 参数: [struct packet_fanout *f]\n- 调用者: fanout_add\n- 被调用者: []\n\n13. 函数名: dev_add_pack\n- 参数: [struct packet_type *pt]\n- 调用者: fanout_add\n- 被调用者: []\n\n14. 函数名: list_add\n- 参数: [struct list_head *new, struct list_head *head]\n- 调用者: fanout_add\n- 被调用者: []\n\n15. 函数名: atomic_read\n- 参数: [const atomic_t *v]\n- 调用者: fanout_add\n- 被调用者: []\n\n16. 函数名: __dev_remove_pack\n- 参数: [struct packet_type *pt]\n- 调用者: fanout_add\n- 被调用者: []\n\n17. 函数名: atomic_inc\n- 参数: [atomic_t *v]\n- 调用者: fanout_add\n- 被调用者: []\n\n18. 函数名: __fanout_link\n- 参数: [struct sock *sk, struct packet_sock *po]\n- 调用者: fanout_add\n- 被调用者: []\n\n19. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: fanout_add\n- 被调用者: []\n\n20. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: fanout_add\n- 被调用者: []"
    },
    {
        "id": 1483,
        "cwe": "CWE-362",
        "cve": "CVE-2017-6346",
        "purpose": "Code purpose:\"\"\"管理PACKET_FANOUT套接字组的引用计数和资源释放，处理多线程环境下的竞争条件问题\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多线程环境下对fanout结构的引用计数和释放操作存在竞争条件，导致可能发生use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: fanout_release\n- 参数: [struct sock *sk]\n- 调用者: 未明确显示（由系统调用触发）\n- 被调用者: [pkt_sk, mutex_lock, atomic_dec_and_test, list_del, dev_remove_pack, fanout_release_data, kfree, mutex_unlock, kfree_rcu]\n\n2. 函数名: pkt_sk\n- 参数: [struct sock *sk]\n- 调用者: fanout_release\n- 被调用者: []\n\n3. 函数名: mutex_lock\n- 参数: [&fanout_mutex]\n- 调用者: fanout_release\n- 被调用者: []\n\n4. 函数名: atomic_dec_and_test\n- 参数: [&f->sk_ref]\n- 调用者: fanout_release\n- 被调用者: []\n\n5. 函数名: list_del\n- 参数: [&f->list]\n- 调用者: fanout_release\n- 被调用者: []\n\n6. 函数名: dev_remove_pack\n- 参数: [&f->prot_hook]\n- 调用者: fanout_release\n- 被调用者: []\n\n7. 函数名: fanout_release_data\n- 参数: [f]\n- 调用者: fanout_release\n- 被调用者: []\n\n8. 函数名: kfree\n- 参数: [f]\n- 调用者: fanout_release\n- 被调用者: []\n\n9. 函数名: mutex_unlock\n- 参数: [&fanout_mutex]\n- 调用者: fanout_release\n- 被调用者: []\n\n10. 函数名: kfree_rcu\n- 参数: [po->rollover, rcu]\n- 调用者: fanout_release\n- 被调用者: []"
    },
    {
        "id": 1487,
        "cwe": "CWE-362",
        "cve": "CVE-2017-6874",
        "purpose": "Code purpose:\"\"\"该代码用于在原子计数器减至零时安全释放ucounts结构体，但存在竞态条件可能导致释放后使用问题\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于原子递减操作和链表删除操作之间存在竞争条件，导致在并发场景下可能出现引用计数错误和释放后使用的问题\"\"\"",
        "functions": "Functions:\n1. 函数名: put_ucounts\n- 参数: [struct ucounts *ucounts]\n- 调用者: 未明确（由系统调用触发）\n- 被调用者: [atomic_dec_and_test, spin_lock_irqsave, hlist_del_init, spin_unlock_irqrestore, kfree]\n\n2. 函数名: atomic_dec_and_test\n- 参数: [&ucounts->count]\n- 调用者: put_ucounts\n- 被调用者: []\n\n3. 函数名: spin_lock_irqsave\n- 参数: [&ucounts_lock, flags]\n- 调用者: put_ucounts\n- 被调用者: []\n\n4. 函数名: hlist_del_init\n- 参数: [&ucounts->node]\n- 调用者: put_ucounts\n- 被调用者: []\n\n5. 函数名: spin_unlock_irqrestore\n- 参数: [&ucounts_lock, flags]\n- 调用者: put_ucounts\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [ucounts]\n- 调用者: put_ucounts\n- 被调用者: []"
    },
    {
        "id": 1488,
        "cwe": "CWE-362",
        "cve": "CVE-2017-6874",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中管理用户命名空间的引用计数，通过哈希表查找或创建ucounts结构体来跟踪特定用户命名空间和用户ID的使用情况。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在释放锁后重新获取锁的过程中存在竞争条件，导致可能发生use-after-free错误。\"\"\"",
        "functions": "Functions:\n1. 函数名: get_ucounts\n- 参数: [struct user_namespace *ns, kuid_t uid]\n- 调用者: 未指定\n- 被调用者: [ucounts_hashentry, find_ucounts, spin_lock_irq, spin_unlock_irq, kzalloc, kfree, atomic_set, hlist_add_head, atomic_add_unless]\n\n2. 函数名: ucounts_hashentry\n- 参数: [struct user_namespace *ns, kuid_t uid]\n- 调用者: get_ucounts\n- 被调用者: 未指定\n\n3. 函数名: find_ucounts\n- 参数: [struct user_namespace *ns, kuid_t uid, struct hlist_head *hashent]\n- 调用者: get_ucounts\n- 被调用者: 未指定\n\n4. 函数名: spin_lock_irq\n- 参数: [spinlock_t *lock]\n- 调用者: get_ucounts\n- 被调用者: 未指定\n\n5. 函数名: spin_unlock_irq\n- 参数: [spinlock_t *lock]\n- 调用者: get_ucounts\n- 被调用者: 未指定\n\n6. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: get_ucounts\n- 被调用者: 未指定\n\n7. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: get_ucounts\n- 被调用者: 未指定\n\n8. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: get_ucounts\n- 被调用者: 未指定\n\n9. 函数名: hlist_add_head\n- 参数: [struct hlist_node *n, struct hlist_head *h]\n- 调用者: get_ucounts\n- 被调用者: 未指定\n\n10. 函数名: atomic_add_unless\n- 参数: [atomic_t *v, int a, int u]\n- 调用者: get_ucounts\n- 被调用者: 未指定"
    },
    {
        "id": 1510,
        "cwe": "CWE-362",
        "cve": "CVE-2017-7533",
        "purpose": "Code purpose:\"\"\"该代码实现了debugfs文件系统中重命名文件或目录的功能，包括检查源目录和目标目录的有效性、处理重命名操作以及相关的文件系统通知。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于fsnotify实现中存在竞态条件，当inotify_handle_event和vfs_rename函数同时执行时，可能导致内存损坏或权限提升。\"\"\"",
        "functions": "Functions:\n1. 函数名: debugfs_rename\n- 参数: [struct dentry *old_dir, struct dentry *old_dentry, struct dentry *new_dir, const char *new_name]\n- 调用者: N/A (top-level function)\n- 被调用者: [lock_rename, d_really_is_negative, d_mountpoint, lookup_one_len, IS_ERR, d_really_is_positive, fsnotify_oldname_init, simple_rename, fsnotify_oldname_free, d_move, fsnotify_move, unlock_rename, dput]\n\n2. 函数名: lock_rename\n- 参数: [struct dentry *new_dir, struct dentry *old_dir]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n3. 函数名: d_really_is_negative\n- 参数: [struct dentry *dentry]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n4. 函数名: d_mountpoint\n- 参数: [struct dentry *dentry]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n5. 函数名: lookup_one_len\n- 参数: [const char *name, struct dentry *base, int len]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n6. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n7. 函数名: d_really_is_positive\n- 参数: [struct dentry *dentry]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n8. 函数名: fsnotify_oldname_init\n- 参数: [const char *name]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n9. 函数名: simple_rename\n- 参数: [struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry, unsigned int flags]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n10. 函数名: fsnotify_oldname_free\n- 参数: [const char *old_name]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n11. 函数名: d_move\n- 参数: [struct dentry *old_dentry, struct dentry *new_dentry]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n12. 函数名: fsnotify_move\n- 参数: [struct inode *old_dir, struct inode *new_dir, const char *old_name, int is_dir, struct inode *target, struct dentry *moved]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n13. 函数名: unlock_rename\n- 参数: [struct dentry *new_dir, struct dentry *old_dir]\n- 调用者: debugfs_rename\n- 被调用者: []\n\n14. 函数名: dput\n- 参数: [struct dentry *dentry]\n- 调用者: debugfs_rename\n- 被调用者: []"
    },
    {
        "id": 1511,
        "cwe": "CWE-362",
        "cve": "CVE-2017-7533",
        "purpose": "Code purpose:\"\"\"实现文件系统重命名操作，包括权限检查、目录处理、文件系统通知和并发控制等功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中fsnotify实现存在竞态条件，当inotify_handle_event和vfs_rename函数同时执行时，可能导致内存损坏或权限提升。\"\"\"",
        "functions": "Functions:\n1. 函数名: vfs_rename\n- 参数: [struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry, struct inode **delegated_inode, unsigned int flags]\n- 调用者: N/A (系统调用)\n- 被调用者: [may_delete, may_create, inode_permission, security_inode_rename, fsnotify_oldname_init, dget, lock_two_nondirectories, inode_lock, is_local_mountpoint, try_break_deleg, shrink_dcache_parent, dont_mount, detach_mounts, d_move, d_exchange, inode_unlock, dput, fsnotify_move, fsnotify_oldname_free]\n\n2. 函数名: may_delete\n- 参数: [struct inode *dir, struct dentry *victim, int is_dir]\n- 调用者: vfs_rename\n- 被调用者: []\n\n3. 函数名: may_create\n- 参数: [struct inode *dir, struct dentry *dentry]\n- 调用者: vfs_rename\n- 被调用者: []\n\n4. 函数名: inode_permission\n- 参数: [struct inode *inode, int mask]\n- 调用者: vfs_rename\n- 被调用者: []\n\n5. 函数名: security_inode_rename\n- 参数: [struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry, unsigned int flags]\n- 调用者: vfs_rename\n- 被调用者: []\n\n6. 函数名: fsnotify_oldname_init\n- 参数: [const char *name]\n- 调用者: vfs_rename\n- 被调用者: []\n\n7. 函数名: dget\n- 参数: [struct dentry *dentry]\n- 调用者: vfs_rename\n- 被调用者: []\n\n8. 函数名: lock_two_nondirectories\n- 参数: [struct inode *inode1, struct inode *inode2]\n- 调用者: vfs_rename\n- 被调用者: []\n\n9. 函数名: inode_lock\n- 参数: [struct inode *inode]\n- 调用者: vfs_rename\n- 被调用者: []\n\n10. 函数名: is_local_mountpoint\n- 参数: [struct dentry *dentry]\n- 调用者: vfs_rename\n- 被调用者: []\n\n11. 函数名: try_break_deleg\n- 参数: [struct inode *inode, struct inode **delegated_inode]\n- 调用者: vfs_rename\n- 被调用者: []\n\n12. 函数名: shrink_dcache_parent\n- 参数: [struct dentry *parent]\n- 调用者: vfs_rename\n- 被调用者: []\n\n13. 函数名: dont_mount\n- 参数: [struct dentry *dentry]\n- 调用者: vfs_rename\n- 被调用者: []\n\n14. 函数名: detach_mounts\n- 参数: [struct dentry *dentry]\n- 调用者: vfs_rename\n- 被调用者: []\n\n15. 函数名: d_move\n- 参数: [struct dentry *old_dentry, struct dentry *new_dentry]\n- 调用者: vfs_rename\n- 被调用者: []\n\n16. 函数名: d_exchange\n- 参数: [struct dentry *old_dentry, struct dentry *new_dentry]\n- 调用者: vfs_rename\n- 被调用者: []\n\n17. 函数名: inode_unlock\n- 参数: [struct inode *inode]\n- 调用者: vfs_rename\n- 被调用者: []\n\n18. 函数名: dput\n- 参数: [struct dentry *dentry]\n- 调用者: vfs_rename\n- 被调用者: []\n\n19. 函数名: fsnotify_move\n- 参数: [struct inode *old_dir, struct inode *new_dir, const char *old_name, int is_dir, struct inode *target, struct dentry *moved]\n- 调用者: vfs_rename\n- 被调用者: []\n\n20. 函数名: fsnotify_oldname_free\n- 参数: [const unsigned char *old_name]\n- 调用者: vfs_rename\n- 被调用者: []"
    },
    {
        "id": 1512,
        "cwe": "CWE-362",
        "cve": "CVE-2017-7533",
        "purpose": "Code purpose:\"\"\"监控文件系统事件并通知父目录，处理来自子目录的事件通知\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于fsnotify_parent函数在处理文件系统通知时存在竞态条件，当inotify_handle_event和vfs_rename函数同时执行时可能导致内存损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: __fsnotify_parent\n- 参数: [const struct path *path, struct dentry *dentry, __u32 mask]\n- 调用者: N/A\n- 被调用者: [dget_parent, fsnotify_inode_watches_children, __fsnotify_update_child_dentry_flags, fsnotify, dput]\n\n2. 函数名: dget_parent\n- 参数: [struct dentry *dentry]\n- 调用者: __fsnotify_parent\n- 被调用者: N/A\n\n3. 函数名: fsnotify_inode_watches_children\n- 参数: [struct inode *p_inode]\n- 调用者: __fsnotify_parent\n- 被调用者: N/A\n\n4. 函数名: __fsnotify_update_child_dentry_flags\n- 参数: [struct inode *p_inode]\n- 调用者: __fsnotify_parent\n- 被调用者: N/A\n\n5. 函数名: fsnotify\n- 参数: [struct inode *p_inode, __u32 mask, const struct path *path, enum fsnotify_event_type type, const char *name, u32 cookie]\n- 调用者: __fsnotify_parent\n- 被调用者: N/A\n\n6. 函数名: dput\n- 参数: [struct dentry *parent]\n- 调用者: __fsnotify_parent\n- 被调用者: N/A"
    },
    {
        "id": 1573,
        "cwe": "CWE-362",
        "cve": "CVE-2018-1000004",
        "purpose": "Code purpose:\"\"\"处理ALSA音序器的IOCTL命令，包括从用户空间复制数据、执行相应操作以及将结果返回给用户空间\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于Linux内核声音子系统中存在竞态条件，导致在处理序列IOCTL操作时可能引发死锁和拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_seq_ioctl\n- 参数: [struct file *file, unsigned int cmd, unsigned long arg]\n- 调用者: 未指定（由内核IOCTL机制调用）\n- 被调用者: [copy_from_user, copy_to_user, handler->func]\n\n2. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: snd_seq_ioctl\n- 被调用者: []\n\n3. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: snd_seq_ioctl\n- 被调用者: []\n\n4. 函数名: handler->func\n- 参数: [struct snd_seq_client *client, union {...} *buf]\n- 调用者: snd_seq_ioctl\n- 被调用者: []\n\n5. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: snd_seq_ioctl\n- 被调用者: []"
    },
    {
        "id": 1574,
        "cwe": "CWE-362",
        "cve": "CVE-2018-1000004",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核声音子系统中创建并初始化一个新的序列客户端，管理客户端资源分配和并发访问\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在客户端表操作时未正确处理自旋锁和资源释放的顺序，导致可能发生竞争条件从而引发死锁\"\"\"",
        "functions": "Functions:\n1. 函数名: seq_create_client1\n- 参数: [client_index, poolsize]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [kzalloc, kfree, snd_seq_pool_new, snd_seq_pool_delete, snd_use_lock_init, rwlock_init, mutex_init, INIT_LIST_HEAD, spin_lock_irqsave, spin_unlock_irqrestore]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*client), GFP_KERNEL]\n- 调用者: seq_create_client1\n- 被调用者: 未明确（内核内存分配函数）\n\n3. 函数名: kfree\n- 参数: [client]\n- 调用者: seq_create_client1\n- 被调用者: 未明确（内核内存释放函数）\n\n4. 函数名: snd_seq_pool_new\n- 参数: [poolsize]\n- 调用者: seq_create_client1\n- 被调用者: 未明确\n\n5. 函数名: snd_seq_pool_delete\n- 参数: [&client->pool]\n- 调用者: seq_create_client1\n- 被调用者: 未明确\n\n6. 函数名: snd_use_lock_init\n- 参数: [&client->use_lock]\n- 调用者: seq_create_client1\n- 被调用者: 未明确\n\n7. 函数名: rwlock_init\n- 参数: [&client->ports_lock]\n- 调用者: seq_create_client1\n- 被调用者: 未明确\n\n8. 函数名: mutex_init\n- 参数: [&client->ports_mutex]\n- 调用者: seq_create_client1\n- 被调用者: 未明确\n\n9. 函数名: INIT_LIST_HEAD\n- 参数: [&client->ports_list_head]\n- 调用者: seq_create_client1\n- 被调用者: 未明确\n\n10. 函数名: spin_lock_irqsave\n- 参数: [&clients_lock, flags]\n- 调用者: seq_create_client1\n- 被调用者: 未明确\n\n11. 函数名: spin_unlock_irqrestore\n- 参数: [&clients_lock, flags]\n- 调用者: seq_create_client1\n- 被调用者: 未明确"
    },
    {
        "id": 1649,
        "cwe": "CWE-362",
        "cve": "CVE-2018-12232",
        "purpose": "Code purpose:\"\"\"该代码用于设置socket文件属性，包括修改socket所属用户的UID，但在处理过程中存在竞态条件漏洞。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于fchownat操作未增加文件描述符引用计数，导致在并发执行close操作时可能将socket置为NULL，从而引发空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: sockfs_setattr\n- 参数: [struct dentry *dentry, struct iattr *iattr]\n- 调用者: 未明确（通常由文件系统操作调用）\n- 被调用者: [simple_setattr, SOCKET_I, d_inode]\n\n2. 函数名: simple_setattr\n- 参数: [struct dentry *dentry, struct iattr *iattr]\n- 调用者: sockfs_setattr\n- 被调用者: 未明确\n\n3. 函数名: SOCKET_I\n- 参数: [struct inode *inode]\n- 调用者: sockfs_setattr\n- 被调用者: 未明确\n\n4. 函数名: d_inode\n- 参数: [struct dentry *dentry]\n- 调用者: sockfs_setattr\n- 被调用者: 未明确"
    },
    {
        "id": 1650,
        "cwe": "CWE-362",
        "cve": "CVE-2018-12232",
        "purpose": "Code purpose:\"\"\"释放与inode关联的socket资源并关闭文件\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"fchownat操作未增加文件描述符引用计数，导致close操作在fchownat执行期间将socket置为NULL，引发空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: sock_close\n- 参数: [struct inode *inode, struct file *filp]\n- 调用者: 未明确（通常是文件操作关闭时的回调）\n- 被调用者: [SOCKET_I, sock_release]\n\n2. 函数名: SOCKET_I\n- 参数: [struct inode *inode]\n- 调用者: sock_close\n- 被调用者: []\n\n3. 函数名: sock_release\n- 参数: [socket结构体指针（由SOCKET_I返回）]\n- 调用者: sock_close\n- 被调用者: []"
    },
    {
        "id": 1651,
        "cwe": "CWE-362",
        "cve": "CVE-2018-12232",
        "purpose": "Code purpose:\"\"\"释放socket资源并处理相关清理操作，包括调用release函数、释放模块引用计数、检查fasync列表以及处理inode和文件描述符\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"fchownat未增加文件描述符引用计数导致与close并发操作时可能引发空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: sock_release\n- 参数: [struct socket *sock]\n- 调用者: 未明确（通常是socket关闭相关操作）\n- 被调用者: [sock->ops->release, module_put, rcu_dereference_protected, pr_err, iput]\n\n2. 函数名: sock->ops->release\n- 参数: [struct socket *sock]\n- 调用者: sock_release\n- 被调用者: 未明确（由具体socket操作实现决定）\n\n3. 函数名: module_put\n- 参数: [struct module *owner]\n- 调用者: sock_release\n- 被调用者: 未明确（内核模块相关函数）\n\n4. 函数名: rcu_dereference_protected\n- 参数: [sock->wq, 1]\n- 调用者: sock_release\n- 被调用者: 未明确（RCU相关函数）\n\n5. 函数名: pr_err\n- 参数: [\"%s: fasync list not empty!\\n\", __func__]\n- 调用者: sock_release\n- 被调用者: 未明确（内核打印函数）\n\n6. 函数名: iput\n- 参数: [SOCK_INODE(sock)]\n- 调用者: sock_release\n- 被调用者: 未明确（inode相关函数）"
    },
    {
        "id": 1653,
        "cwe": "CWE-362",
        "cve": "CVE-2018-12633",
        "purpose": "Code purpose:\"\"\"处理虚拟设备(VirtualBox Guest Additions)的IOCTL请求，包括验证请求头、分配缓冲区、数据拷贝和核心IOCTL操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于代码两次从用户空间读取相同数据且未加锁保护，导致恶意用户可利用竞争条件在两次读取之间篡改关键变量，造成双重获取漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: vbg_misc_device_ioctl\n- 参数: [struct file *filp, unsigned int req, unsigned long arg]\n- 调用者: 内核IOCTL处理机制\n- 被调用者: [copy_from_user, max, vbg_req_alloc, kmalloc, memset, vbg_core_ioctl, vbg_debug, copy_to_user, vbg_req_free, kfree]\n\n2. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: vbg_misc_device_ioctl\n- 被调用者: []\n\n3. 函数名: max\n- 参数: [long x, long y]\n- 调用者: vbg_misc_device_ioctl\n- 被调用者: []\n\n4. 函数名: vbg_req_alloc\n- 参数: [size_t size, int type]\n- 调用者: vbg_misc_device_ioctl\n- 被调用者: []\n\n5. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: vbg_misc_device_ioctl\n- 被调用者: []\n\n6. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: vbg_misc_device_ioctl\n- 被调用者: []\n\n7. 函数名: vbg_core_ioctl\n- 参数: [struct vbg_session *session, unsigned int req, void *buf]\n- 调用者: vbg_misc_device_ioctl\n- 被调用者: []\n\n8. 函数名: vbg_debug\n- 参数: [const char *fmt, ...]\n- 调用者: vbg_misc_device_ioctl\n- 被调用者: []\n\n9. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: vbg_misc_device_ioctl\n- 被调用者: []\n\n10. 函数名: vbg_req_free\n- 参数: [void *buf, size_t size]\n- 调用者: vbg_misc_device_ioctl\n- 被调用者: []\n\n11. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: vbg_misc_device_ioctl\n- 被调用者: []"
    },
    {
        "id": 1728,
        "cwe": "CWE-362",
        "cve": "CVE-2018-17972",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中通过proc文件系统展示指定进程的内核栈调用跟踪信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该函数未对调用者权限进行充分验证，允许非root用户检查任意任务的内核堆栈，导致竞争条件下的堆栈展开可能泄露内核堆栈内容\"\"\"",
        "functions": "Functions:\n1. 函数名: proc_pid_stack\n- 参数: [struct seq_file *m, struct pid_namespace *ns, struct pid *pid, struct task_struct *task]\n- 调用者: N/A\n- 被调用者: [kmalloc_array, lock_trace, save_stack_trace_tsk, seq_printf, unlock_trace, kfree]\n\n2. 函数名: kmalloc_array\n- 参数: [MAX_STACK_TRACE_DEPTH, sizeof(*entries), GFP_KERNEL]\n- 调用者: proc_pid_stack\n- 被调用者: N/A\n\n3. 函数名: lock_trace\n- 参数: [struct task_struct *task]\n- 调用者: proc_pid_stack\n- 被调用者: N/A\n\n4. 函数名: save_stack_trace_tsk\n- 参数: [struct task_struct *task, struct stack_trace *trace]\n- 调用者: proc_pid_stack\n- 被调用者: N/A\n\n5. 函数名: seq_printf\n- 参数: [struct seq_file *m, \"[<0>] %pB\\n\", (void *)entries[i]]\n- 调用者: proc_pid_stack\n- 被调用者: N/A\n\n6. 函数名: unlock_trace\n- 参数: [struct task_struct *task]\n- 调用者: proc_pid_stack\n- 被调用者: N/A\n\n7. 函数名: kfree\n- 参数: [entries]\n- 调用者: proc_pid_stack\n- 被调用者: N/A"
    },
    {
        "id": 1739,
        "cwe": "CWE-362",
        "cve": "CVE-2018-18559",
        "purpose": "Code purpose:\"\"\"该代码实现了AF_PACKET套接字的绑定功能，处理网络设备与协议的绑定关系，并管理相关的资源引用计数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多线程环境下对AF_PACKET套接字的fanout_add和bind操作存在竞争条件，导致未正确处理解注册和重新注册操作，从而引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: packet_do_bind\n- 参数: [sk, name, ifindex, proto]\n- 调用者: 未明确（应为外部调用）\n- 被调用者: [pkt_sk, lock_sock, spin_lock, rcu_read_lock, dev_get_by_name_rcu, dev_get_by_index_rcu, dev_hold, __unregister_prot_hook, dev_get_by_index_rcu, dev_put, packet_cached_dev_reset, packet_cached_dev_assign, register_prot_hook, rcu_read_unlock, spin_unlock, release_sock]\n\n2. 函数名: pkt_sk\n- 参数: [sk]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n3. 函数名: lock_sock\n- 参数: [sk]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n4. 函数名: spin_lock\n- 参数: [&po->bind_lock]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n5. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: packet_do_bind\n- 被调用者: []\n\n6. 函数名: dev_get_by_name_rcu\n- 参数: [sock_net(sk), name]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n7. 函数名: dev_get_by_index_rcu\n- 参数: [sock_net(sk), ifindex]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n8. 函数名: dev_hold\n- 参数: [dev]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n9. 函数名: __unregister_prot_hook\n- 参数: [sk, true]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n10. 函数名: dev_put\n- 参数: [dev_curr]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n11. 函数名: packet_cached_dev_reset\n- 参数: [po]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n12. 函数名: packet_cached_dev_assign\n- 参数: [po, dev]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n13. 函数名: register_prot_hook\n- 参数: [sk]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n14. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: packet_do_bind\n- 被调用者: []\n\n15. 函数名: spin_unlock\n- 参数: [&po->bind_lock]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n16. 函数名: release_sock\n- 参数: [sk]\n- 调用者: packet_do_bind\n- 被调用者: []"
    },
    {
        "id": 1782,
        "cwe": "CWE-362",
        "cve": "CVE-2018-20836",
        "purpose": "Code purpose:\"\"\"该代码用于处理SAS任务超时情况，在任务未完成时将其标记为已中止，并通过完成机制通知等待的进程。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于smp_task_timedout()和smp_task_done()之间存在竞争条件，导致在任务状态检查和处理完成时可能发生use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: smp_task_timedout\n- 参数: [struct timer_list *t]\n- 调用者: 内核定时器子系统\n- 被调用者: [from_timer, spin_lock_irqsave, spin_unlock_irqrestore, complete]\n\n2. 函数名: from_timer\n- 参数: [slow, t, timer]\n- 调用者: smp_task_timedout\n- 被调用者: []\n\n3. 函数名: spin_lock_irqsave\n- 参数: [&task->task_state_lock, flags]\n- 调用者: smp_task_timedout\n- 被调用者: []\n\n4. 函数名: spin_unlock_irqrestore\n- 参数: [&task->task_state_lock, flags]\n- 调用者: smp_task_timedout\n- 被调用者: []\n\n5. 函数名: complete\n- 参数: [&task->slow_task->completion]\n- 调用者: smp_task_timedout\n- 被调用者: []"
    },
    {
        "id": 1783,
        "cwe": "CWE-362",
        "cve": "CVE-2018-20836",
        "purpose": "Code purpose:\"\"\"在SAS扩展器驱动中处理慢速任务的完成，包括取消定时器和通知任务完成\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于smp_task_done()和smp_task_timedout()之间存在竞争条件，导致在定时器未被成功删除时可能发生释放后使用(UAF)问题\"\"\"",
        "functions": "Functions:\n1. 函数名: smp_task_done\n- 参数: [struct sas_task *task]\n- 调用者: 未明确（由系统或外部调用）\n- 被调用者: [del_timer, complete]\n\n2. 函数名: del_timer\n- 参数: [&task->slow_task->timer]\n- 调用者: smp_task_done\n- 被调用者: []\n\n3. 函数名: complete\n- 参数: [&task->slow_task->completion]\n- 调用者: smp_task_done\n- 被调用者: []"
    },
    {
        "id": 1821,
        "cwe": "CWE-362",
        "cve": "CVE-2018-5344",
        "purpose": "Code purpose:\"\"\"该代码用于管理loop设备的释放操作，包括处理引用计数、自动清除模式下的设备清理以及保持绑定状态时的队列刷新。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于lo_release函数中的互斥锁管理不当，导致在竞态条件下可能发生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: lo_release\n- 参数: [disk, mode]\n- 调用者: 未明确显示（通常由块设备子系统调用）\n- 被调用者: [atomic_dec_return, mutex_lock, loop_clr_fd, blk_mq_freeze_queue, blk_mq_unfreeze_queue, mutex_unlock]\n\n2. 函数名: atomic_dec_return\n- 参数: [&lo->lo_refcnt]\n- 调用者: lo_release\n- 被调用者: []\n\n3. 函数名: mutex_lock\n- 参数: [&lo->lo_ctl_mutex]\n- 调用者: lo_release\n- 被调用者: []\n\n4. 函数名: loop_clr_fd\n- 参数: [lo]\n- 调用者: lo_release\n- 被调用者: []\n\n5. 函数名: blk_mq_freeze_queue\n- 参数: [lo->lo_queue]\n- 调用者: lo_release\n- 被调用者: []\n\n6. 函数名: blk_mq_unfreeze_queue\n- 参数: [lo->lo_queue]\n- 调用者: lo_release\n- 被调用者: []\n\n7. 函数名: mutex_unlock\n- 参数: [&lo->lo_ctl_mutex]\n- 调用者: lo_release\n- 被调用者: []"
    },
    {
        "id": 1829,
        "cwe": "CWE-362",
        "cve": "CVE-2018-5814",
        "purpose": "Code purpose:\"\"\"该代码用于处理USB设备的探测(probe)过程，包括设备验证、资源分配和端口声明，是Linux内核中USB/IP功能的一部分。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核处理USB over IP设备的probe、disconnect和rebind操作时存在多个竞态条件，导致可能发生释放后使用或空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: stub_probe\n- 参数: [struct usb_device *udev]\n- 调用者: 未被显示（由USB驱动框架调用）\n- 被调用者: [dev_name, get_busid_priv, dev_dbg, dev_info, strcmp, stub_device_alloc, dev_set_drvdata, usb_hub_claim_port, stub_add_files, usb_hub_release_port, usb_put_dev, stub_device_free]\n\n2. 函数名: dev_name\n- 参数: [struct device *dev]\n- 调用者: stub_probe\n- 被调用者: []\n\n3. 函数名: get_busid_priv\n- 参数: [const char *udev_busid]\n- 调用者: stub_probe\n- 被调用者: []\n\n4. 函数名: dev_dbg\n- 参数: [struct device *dev, const char *fmt, ...]\n- 调用者: stub_probe\n- 被调用者: []\n\n5. 函数名: dev_info\n- 参数: [struct device *dev, const char *fmt, ...]\n- 调用者: stub_probe\n- 被调用者: []\n\n6. 函数名: strcmp\n- 参数: [const char *s1, const char *s2]\n- 调用者: stub_probe\n- 被调用者: []\n\n7. 函数名: stub_device_alloc\n- 参数: [struct usb_device *udev]\n- 调用者: stub_probe\n- 被调用者: []\n\n8. 函数名: dev_set_drvdata\n- 参数: [struct device *dev, void *data]\n- 调用者: stub_probe\n- 被调用者: []\n\n9. 函数名: usb_hub_claim_port\n- 参数: [struct usb_device *hdev, unsigned port1, struct usb_dev_state *owner]\n- 调用者: stub_probe\n- 被调用者: []\n\n10. 函数名: stub_add_files\n- 参数: [struct device *dev]\n- 调用者: stub_probe\n- 被调用者: []\n\n11. 函数名: usb_hub_release_port\n- 参数: [struct usb_device *hdev, unsigned port1, struct usb_dev_state *owner]\n- 调用者: stub_probe\n- 被调用者: []\n\n12. 函数名: usb_put_dev\n- 参数: [struct usb_device *udev]\n- 调用者: stub_probe\n- 被调用者: []\n\n13. 函数名: stub_device_free\n- 参数: [struct stub_device *sdev]\n- 调用者: stub_probe\n- 被调用者: []"
    },
    {
        "id": 1830,
        "cwe": "CWE-362",
        "cve": "CVE-2018-5814",
        "purpose": "Code purpose:\"\"\"处理USB/IP设备的断开连接操作，包括释放资源、关闭连接和清理设备状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核处理USB over IP设备的探测、断开和重新绑定时，存在多个竞态条件，导致可能发生释放后使用或空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: stub_disconnect\n- 参数: [struct usb_device *udev]\n- 调用者: 未显示\n- 被调用者: [dev_name, get_busid_priv, dev_get_drvdata, dev_set_drvdata, stub_remove_files, usb_hub_release_port, usbip_in_eh, shutdown_busid, usb_put_dev, stub_device_free]\n\n2. 函数名: dev_name\n- 参数: [&udev->dev]\n- 调用者: stub_disconnect\n- 被调用者: 未显示\n\n3. 函数名: get_busid_priv\n- 参数: [udev_busid]\n- 调用者: stub_disconnect\n- 被调用者: 未显示\n\n4. 函数名: dev_get_drvdata\n- 参数: [&udev->dev]\n- 调用者: stub_disconnect\n- 被调用者: 未显示\n\n5. 函数名: dev_set_drvdata\n- 参数: [&udev->dev, NULL]\n- 调用者: stub_disconnect\n- 被调用者: 未显示\n\n6. 函数名: stub_remove_files\n- 参数: [&udev->dev]\n- 调用者: stub_disconnect\n- 被调用者: 未显示\n\n7. 函数名: usb_hub_release_port\n- 参数: [udev->parent, udev->portnum, (struct usb_dev_state *) udev]\n- 调用者: stub_disconnect\n- 被调用者: 未显示\n\n8. 函数名: usbip_in_eh\n- 参数: [current]\n- 调用者: stub_disconnect\n- 被调用者: 未显示\n\n9. 函数名: shutdown_busid\n- 参数: [busid_priv]\n- 调用者: stub_disconnect\n- 被调用者: 未显示\n\n10. 函数名: usb_put_dev\n- 参数: [sdev->udev]\n- 调用者: stub_disconnect\n- 被调用者: 未显示\n\n11. 函数名: stub_device_free\n- 参数: [sdev]\n- 调用者: stub_disconnect\n- 被调用者: 未显示"
    },
    {
        "id": 1831,
        "cwe": "CWE-362",
        "cve": "CVE-2018-5814",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理USB over IP设备的busid匹配删除操作，包括状态检查和清理工作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在USB over IP处理过程中，由于缺乏对busid_table_lock锁的适当保护，导致多个线程在并发访问busid_table时可能引发竞态条件，从而造成使用后释放或空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: del_match_busid\n- 参数: [char *busid]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [get_busid_idx, memset, spin_lock, spin_unlock]\n\n2. 函数名: get_busid_idx\n- 参数: [char *busid]\n- 调用者: del_match_busid\n- 被调用者: 未明确（上下文未提供）\n\n3. 函数名: spin_lock\n- 参数: [&busid_table_lock]\n- 调用者: del_match_busid\n- 被调用者: 未明确（上下文未提供）\n\n4. 函数名: spin_unlock\n- 参数: [&busid_table_lock]\n- 调用者: del_match_busid\n- 被调用者: 未明确（上下文未提供）\n\n5. 函数名: memset\n- 参数: [busid_table[idx].name, 0, BUSID_SIZE]\n- 调用者: del_match_busid\n- 被调用者: 未明确（上下文未提供）"
    },
    {
        "id": 1832,
        "cwe": "CWE-362",
        "cve": "CVE-2018-5814",
        "purpose": "Code purpose:\"\"\"该代码用于显示总线ID表中所有非空名称的总线ID，并将它们格式化为字符串输出到缓冲区\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确处理多线程竞争条件，导致在访问busid_table时可能发生竞态条件，从而引发使用后释放或空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: match_busid_show\n- 参数: [struct device_driver *drv, char *buf]\n- 调用者: 未明确显示（通常由设备驱动框架调用）\n- 被调用者: [spin_lock, spin_unlock, sprintf]\n\n2. 函数名: spin_lock\n- 参数: [&busid_table_lock]\n- 调用者: match_busid_show\n- 被调用者: []\n\n3. 函数名: spin_unlock\n- 参数: [&busid_table_lock]\n- 调用者: match_busid_show\n- 被调用者: []\n\n4. 函数名: sprintf\n- 参数: [out, \"%s \", busid_table[i].name] 和 [out, \"\\n\"]\n- 调用者: match_busid_show\n- 被调用者: []"
    },
    {
        "id": 1833,
        "cwe": "CWE-362",
        "cve": "CVE-2018-5814",
        "purpose": "Code purpose:\"\"\"通过总线ID获取对应的总线私有数据结构，并在操作期间使用自旋锁保护共享资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在获取总线ID私有结构时未正确处理竞态条件，导致在锁释放后可能发生引用已释放内存或空指针解引用的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: get_busid_priv\n- 参数: [busid]\n- 调用者: 未明确（上下文不足）\n- 被调用者: [spin_lock, get_busid_idx, spin_unlock]\n\n2. 函数名: spin_lock\n- 参数: [&busid_table_lock]\n- 调用者: get_busid_priv\n- 被调用者: 未明确（内核内部函数）\n\n3. 函数名: get_busid_idx\n- 参数: [busid]\n- 调用者: get_busid_priv\n- 被调用者: 未明确（上下文不足）\n\n4. 函数名: spin_unlock\n- 参数: [&busid_table_lock]\n- 调用者: get_busid_priv\n- 被调用者: 未明确（内核内部函数）"
    },
    {
        "id": 1834,
        "cwe": "CWE-362",
        "cve": "CVE-2018-5814",
        "purpose": "Code purpose:\"\"\"在USB/IP主机模式下处理设备重新绑定的操作，包括更新设备状态和执行重新绑定\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在USB over IP处理probe、disconnect和rebind操作时存在多个竞态条件，导致可能发生use-after-free或空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: stub_device_rebind\n- 参数: []\n- 调用者: N/A (static function, called externally but caller not shown in snippet)\n- 被调用者: [do_rebind]\n\n2. 函数名: do_rebind\n- 参数: [busid_table[i].name, busid_priv]\n- 调用者: stub_device_rebind\n- 被调用者: [] (not shown in snippet)"
    },
    {
        "id": 1835,
        "cwe": "CWE-362",
        "cve": "CVE-2018-5814",
        "purpose": "Code purpose:\"\"\"初始化USB over IP总线ID表并设置自旋锁\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确处理USB over IP设备在多线程环境下的探测、断开和重新绑定操作的竞争条件，导致可能发生释放后使用或空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: init_busid_table\n- 参数: []\n- 调用者: 未显示（上下文不足）\n- 被调用者: [memset, spin_lock_init]\n\n2. 函数名: memset\n- 参数: [busid_table, 0, sizeof(busid_table)]\n- 调用者: init_busid_table\n- 被调用者: []\n\n3. 函数名: spin_lock_init\n- 参数: [&busid_table_lock]\n- 调用者: init_busid_table\n- 被调用者: []"
    },
    {
        "id": 1836,
        "cwe": "CWE-362",
        "cve": "CVE-2018-5814",
        "purpose": "Code purpose:\"\"\"处理USB over IP设备的重新绑定操作，包括验证输入、标记设备状态、执行重新绑定以及从总线ID表中删除设备\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在USB over IP处理probe、disconnect和rebind操作时存在竞态条件，导致可能发生use-after-free或空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: rebind_store\n- 参数: [struct device_driver *dev, const char *buf, size_t count]\n- 调用者: 未明确（通常由设备驱动框架调用）\n- 被调用者: [strnlen, get_busid_priv, do_rebind, del_match_busid]\n\n2. 函数名: strnlen\n- 参数: [const char *buf, size_t BUSID_SIZE]\n- 调用者: rebind_store\n- 被调用者: []\n\n3. 函数名: get_busid_priv\n- 参数: [const char *buf]\n- 调用者: rebind_store\n- 被调用者: []\n\n4. 函数名: do_rebind\n- 参数: [char *buf, struct bus_id_priv *bid]\n- 调用者: rebind_store\n- 被调用者: []\n\n5. 函数名: del_match_busid\n- 参数: [char *buf]\n- 调用者: rebind_store\n- 被调用者: []"
    },
    {
        "id": 1837,
        "cwe": "CWE-362",
        "cve": "CVE-2018-5814",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中管理USB over IP设备的busid表，实现busid的添加和状态管理功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在USB over IP处理过程中存在竞态条件，导致在探测、断开和重新绑定操作时可能引发使用后释放或空指针解引用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: add_match_busid\n- 参数: [char *busid]\n- 调用者: 未明确（上下文不足）\n- 被调用者: [get_busid_idx, strlcpy]\n\n2. 函数名: get_busid_idx\n- 参数: [char *busid]（根据调用上下文推断）\n- 调用者: add_match_busid\n- 被调用者: 未明确（上下文不足）\n\n3. 函数名: strlcpy\n- 参数: [char *dest, const char *src, size_t size]（标准库函数参数）\n- 调用者: add_match_busid\n- 被调用者: 无（标准库函数）\n\n4. 函数名: spin_lock\n- 参数: [spinlock_t *lock]（标准内核函数参数）\n- 调用者: add_match_busid\n- 被调用者: 无（内核API）\n\n5. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]（标准内核函数参数）\n- 调用者: add_match_busid\n- 被调用者: 无（内核API）"
    },
    {
        "id": 1838,
        "cwe": "CWE-362",
        "cve": "CVE-2018-5814",
        "purpose": "Code purpose:\"\"\"在总线ID表中查找与给定总线ID匹配的索引\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在处理USB over IP设备的探测、断开和重新绑定时存在竞态条件，导致在并发操作时可能发生使用后释放或空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: get_busid_idx\n- 参数: [const char *busid]\n- 调用者: 未提供（上下文不足）\n- 被调用者: [strncmp]"
    },
    {
        "id": 1840,
        "cwe": "CWE-362",
        "cve": "CVE-2018-5873",
        "purpose": "Code purpose:\"\"\"该代码用于获取命名空间文件的路径，处理命名空间文件系统的挂载点和目录项，并管理相关资源的引用计数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在访问文件时存在竞态条件，导致在__ns_get_path函数中可能发生释放后使用(UAF)的情况。\"\"\"",
        "functions": "Functions:\n1. 函数名: __ns_get_path\n- 参数: [struct path *path, struct ns_common *ns]\n- 调用者: N/A\n- 被调用者: [atomic_long_read, lockref_get_not_dead, mntget, new_inode_pseudo, current_time, d_alloc_pseudo, iput, d_instantiate, atomic_long_cmpxchg, d_delete, dput, cpu_relax]\n\n2. 函数名: atomic_long_read\n- 参数: [&ns->stashed]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n3. 函数名: lockref_get_not_dead\n- 参数: [&dentry->d_lockref]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n4. 函数名: mntget\n- 参数: [mnt]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n5. 函数名: new_inode_pseudo\n- 参数: [mnt->mnt_sb]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n6. 函数名: current_time\n- 参数: [inode]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n7. 函数名: d_alloc_pseudo\n- 参数: [mnt->mnt_sb, &qname]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n8. 函数名: iput\n- 参数: [inode]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n9. 函数名: d_instantiate\n- 参数: [dentry, inode]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n10. 函数名: atomic_long_cmpxchg\n- 参数: [&ns->stashed, 0, (unsigned long)dentry]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n11. 函数名: d_delete\n- 参数: [dentry]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n12. 函数名: dput\n- 参数: [dentry]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n13. 函数名: cpu_relax\n- 参数: []\n- 调用者: __ns_get_path\n- 被调用者: N/A"
    },
    {
        "id": 1847,
        "cwe": "CWE-362",
        "cve": "CVE-2018-7566",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中音序器设备(/dev/snd/seq)的事件写入功能，处理用户空间传递的MIDI事件数据并将其加入客户端队列。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证用户提供的输入数据长度，导致在SNDRV_SEQ_IOCTL_SET_CLIENT_POOL ioctl操作中可能发生缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_seq_write\n- 参数: [struct file *file, const char __user *buf, size_t count, loff_t *offset]\n- 调用者: 无（系统调用接口）\n- 被调用者: [snd_seq_file_flags, snd_BUG_ON, snd_seq_write_pool_allocated, snd_seq_pool_init, copy_from_user, check_event_type_and_length, snd_seq_ev_is_reserved, snd_seq_ev_is_variable, snd_seq_ev_is_varusr, snd_seq_client_enqueue_event]\n\n2. 函数名: snd_seq_file_flags\n- 参数: [struct file *file]\n- 调用者: snd_seq_write\n- 被调用者: 无\n\n3. 函数名: snd_BUG_ON\n- 参数: [!client]\n- 调用者: snd_seq_write\n- 被调用者: 无\n\n4. 函数名: snd_seq_write_pool_allocated\n- 参数: [struct snd_seq_client *client]\n- 调用者: snd_seq_write\n- 被调用者: 无\n\n5. 函数名: snd_seq_pool_init\n- 参数: [client->pool]\n- 调用者: snd_seq_write\n- 被调用者: 无\n\n6. 函数名: copy_from_user\n- 参数: [&event, buf, len]\n- 调用者: snd_seq_write\n- 被调用者: 无\n\n7. 函数名: check_event_type_and_length\n- 参数: [&event]\n- 调用者: snd_seq_write\n- 被调用者: 无\n\n8. 函数名: snd_seq_ev_is_reserved\n- 参数: [&event]\n- 调用者: snd_seq_write\n- 被调用者: 无\n\n9. 函数名: snd_seq_ev_is_variable\n- 参数: [&event]\n- 调用者: snd_seq_write\n- 被调用者: 无\n\n10. 函数名: snd_seq_ev_is_varusr\n- 参数: [&event]\n- 调用者: snd_seq_write\n- 被调用者: 无\n\n11. 函数名: snd_seq_client_enqueue_event\n- 参数: [client, &event, file, !(file->f_flags & O_NONBLOCK), 0, 0]\n- 调用者: snd_seq_write\n- 被调用者: 无"
    },
    {
        "id": 1855,
        "cwe": "CWE-362",
        "cve": "CVE-2018-7995",
        "purpose": "Code purpose:\"\"\"该代码用于在存储整数值后重启机器检查异常(MCE)功能，但存在竞态条件漏洞可能导致拒绝服务\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于store_int_with_restart函数中存在竞态条件，当本地用户以root权限写入check_interval文件时可能导致拒绝服务(系统崩溃)。\"\"\"",
        "functions": "Functions:\n1. 函数名: store_int_with_restart\n- 参数: [struct device *s, struct device_attribute *attr, const char *buf, size_t size]\n- 调用者: 未明确（由系统调用触发）\n- 被调用者: [device_store_int, mce_restart]\n\n2. 函数名: device_store_int\n- 参数: [struct device *s, struct device_attribute *attr, const char *buf, size_t size]\n- 调用者: store_int_with_restart\n- 被调用者: 未明确\n\n3. 函数名: mce_restart\n- 参数: []\n- 调用者: store_int_with_restart\n- 被调用者: 未明确"
    },
    {
        "id": 1856,
        "cwe": "CWE-362",
        "cve": "CVE-2018-7995",
        "purpose": "Code purpose:\"\"\"该代码用于设置和切换CMCI(Corrected Machine Check Interrupt)的启用或禁用状态，通过系统调用接口修改配置并同步到所有CPU核心。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在修改CMCI(Corrected Machine Check Interrupt)状态时存在竞态条件，导致本地用户可能通过写入/sys文件系统触发拒绝服务(panic)。\"\"\"",
        "functions": "Functions:\n1. 函数名: set_cmci_disabled\n- 参数: [struct device *s, struct device_attribute *attr, const char *buf, size_t size]\n- 调用者: 未明确（由设备属性文件操作触发）\n- 被调用者: [kstrtou64, on_each_cpu, mce_disable_cmci, mce_enable_ce]\n\n2. 函数名: kstrtou64\n- 参数: [const char *buf, 0, u64 *new]\n- 调用者: set_cmci_disabled\n- 被调用者: 未明确（内核函数）\n\n3. 函数名: on_each_cpu\n- 参数: [mce_disable_cmci, NULL, 1] 或 [mce_enable_ce, NULL, 1]\n- 调用者: set_cmci_disabled\n- 被调用者: [mce_disable_cmci, mce_enable_ce]\n\n4. 函数名: mce_disable_cmci\n- 参数: [NULL]\n- 调用者: on_each_cpu\n- 被调用者: 未明确\n\n5. 函数名: mce_enable_ce\n- 参数: [NULL]\n- 调用者: on_each_cpu\n- 被调用者: 未明确"
    },
    {
        "id": 1857,
        "cwe": "CWE-362",
        "cve": "CVE-2018-7995",
        "purpose": "Code purpose:\"\"\"该代码用于设置是否忽略CPU的可纠正错误(CE)功能，通过sysfs接口允许root用户动态启用或禁用CE相关特性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在修改mca_cfg.ignore_ce标志时缺乏适当的同步机制，导致竞争条件可能引发系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: set_ignore_ce\n- 参数: [s, attr, buf, size]\n- 调用者: 未明确（通常由sysfs调用）\n- 被调用者: [kstrtou64, mce_timer_delete_all, on_each_cpu, mce_disable_cmci, mce_enable_ce]\n\n2. 函数名: kstrtou64\n- 参数: [buf, 0, &new]\n- 调用者: set_ignore_ce\n- 被调用者: 无（内核基础函数）\n\n3. 函数名: mce_timer_delete_all\n- 参数: []\n- 调用者: set_ignore_ce\n- 被调用者: 无\n\n4. 函数名: on_each_cpu\n- 参数: [mce_disable_cmci, NULL, 1] 或 [mce_enable_ce, (void *)1, 1]\n- 调用者: set_ignore_ce\n- 被调用者: [mce_disable_cmci, mce_enable_ce]\n\n5. 函数名: mce_disable_cmci\n- 参数: [NULL]\n- 调用者: on_each_cpu\n- 被调用者: 无\n\n6. 函数名: mce_enable_ce\n- 参数: [(void *)1]\n- 调用者: on_each_cpu\n- 被调用者: 无"
    },
    {
        "id": 1862,
        "cwe": "CWE-362",
        "cve": "CVE-2018-8897",
        "purpose": "Code purpose:\"\"\"处理x86架构下的int3断点中断，包括动态ftrace、kgdb调试、kprobes探测等多种情况的处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"操作系统内核在处理MOV SS或POP SS指令后的调试异常时，未能正确处理异常延迟传递的情况，导致在特权级别切换时出现意外的调试异常处理顺序。\"\"\"",
        "functions": "Functions:\n1. 函数名: do_int3\n- 参数: [struct pt_regs *regs, long error_code]\n- 调用者: 未显示（中断处理入口）\n- 被调用者: [atomic_read, ftrace_int3_handler, poke_int3_handler, ist_enter, rcu_is_watching, RCU_LOCKDEP_WARN, kgdb_ll_trap, kprobe_int3_handler, notify_die, debug_stack_usage_inc, cond_local_irq_enable, do_trap, cond_local_irq_disable, debug_stack_usage_dec, ist_exit]\n\n2. 函数名: ftrace_int3_handler\n- 参数: [struct pt_regs *regs]\n- 调用者: do_int3\n- 被调用者: 未显示\n\n3. 函数名: poke_int3_handler\n- 参数: [struct pt_regs *regs]\n- 调用者: do_int3\n- 被调用者: 未显示\n\n4. 函数名: ist_enter\n- 参数: [struct pt_regs *regs]\n- 调用者: do_int3\n- 被调用者: 未显示\n\n5. 函数名: rcu_is_watching\n- 参数: []\n- 调用者: do_int3\n- 被调用者: 未显示\n\n6. 函数名: RCU_LOCKDEP_WARN\n- 参数: [!rcu_is_watching(), \"entry code didn't wake RCU\"]\n- 调用者: do_int3\n- 被调用者: 未显示\n\n7. 函数名: kgdb_ll_trap\n- 参数: [DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP, SIGTRAP]\n- 调用者: do_int3\n- 被调用者: 未显示\n\n8. 函数名: kprobe_int3_handler\n- 参数: [struct pt_regs *regs]\n- 调用者: do_int3\n- 被调用者: 未显示\n\n9. 函数名: notify_die\n- 参数: [DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP, SIGTRAP]\n- 调用者: do_int3\n- 被调用者: 未显示\n\n10. 函数名: debug_stack_usage_inc\n- 参数: []\n- 调用者: do_int3\n- 被调用者: 未显示\n\n11. 函数名: cond_local_irq_enable\n- 参数: [struct pt_regs *regs]\n- 调用者: do_int3\n- 被调用者: 未显示\n\n12. 函数名: do_trap\n- 参数: [X86_TRAP_BP, SIGTRAP, \"int3\", regs, error_code, NULL]\n- 调用者: do_int3\n- 被调用者: 未显示\n\n13. 函数名: cond_local_irq_disable\n- 参数: [struct pt_regs *regs]\n- 调用者: do_int3\n- 被调用者: 未显示\n\n14. 函数名: debug_stack_usage_dec\n- 参数: []\n- 调用者: do_int3\n- 被调用者: 未显示\n\n15. 函数名: ist_exit\n- 参数: [struct pt_regs *regs]\n- 调用者: do_int3\n- 被调用者: 未显示"
    },
    {
        "id": 1935,
        "cwe": "CWE-362",
        "cve": "CVE-2019-11815",
        "purpose": "Code purpose:\"\"\"该代码用于在网络命名空间清理时停止RDS-TCP监听并销毁相关连接，但存在竞态条件导致释放后使用漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在清理网络命名空间时，由于缺乏适当的同步机制，导致竞态条件下可能发生对已释放内存的访问，形成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: rds_tcp_kill_sock\n- 参数: [net]\n- 调用者: N/A\n- 被调用者: [net_generic, rds_tcp_listen_stop, read_pnet, list_has_conn, list_move_tail, list_del, spin_lock_irq, spin_unlock_irq, list_for_each_entry_safe, rds_conn_destroy]\n\n2. 函数名: net_generic\n- 参数: [net, rds_tcp_netid]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n3. 函数名: rds_tcp_listen_stop\n- 参数: [lsock, &rtn->rds_tcp_accept_w]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n4. 函数名: read_pnet\n- 参数: [&tc->t_cpath->cp_conn->c_net]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n5. 函数名: list_has_conn\n- 参数: [&tmp_list, tc->t_cpath->cp_conn]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n6. 函数名: list_move_tail\n- 参数: [&tc->t_tcp_node, &tmp_list]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n7. 函数名: list_del\n- 参数: [&tc->t_tcp_node]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n8. 函数名: spin_lock_irq\n- 参数: [&rds_tcp_conn_lock]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n9. 函数名: spin_unlock_irq\n- 参数: [&rds_tcp_conn_lock]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n10. 函数名: list_for_each_entry_safe\n- 参数: [tc, _tc, &rds_tcp_conn_list, t_tcp_node]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n11. 函数名: rds_conn_destroy\n- 参数: [tc->t_cpath->cp_conn]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A"
    },
    {
        "id": 1957,
        "cwe": "CWE-362",
        "cve": "CVE-2019-13233",
        "purpose": "Code purpose:\"\"\"获取指定段寄存器的段限制值，考虑段描述符的粒度标志位并进行相应计算\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于modify_ldt()和#BR异常处理之间存在竞争条件，导致对LDT条目的访问出现释放后使用(UAF)问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: get_seg_limit\n- 参数: [struct pt_regs *regs, int seg_reg_idx]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [get_segment_selector, user_64bit_mode, v8086_mode, get_desc, get_desc_limit]\n\n2. 函数名: get_segment_selector\n- 参数: [struct pt_regs *regs, int seg_reg_idx]\n- 调用者: get_seg_limit\n- 被调用者: 未明确\n\n3. 函数名: user_64bit_mode\n- 参数: [struct pt_regs *regs]\n- 调用者: get_seg_limit\n- 被调用者: 未明确\n\n4. 函数名: v8086_mode\n- 参数: [struct pt_regs *regs]\n- 调用者: get_seg_limit\n- 被调用者: 未明确\n\n5. 函数名: get_desc\n- 参数: [short sel]\n- 调用者: get_seg_limit\n- 被调用者: 未明确\n\n6. 函数名: get_desc_limit\n- 参数: [struct desc_struct *desc]\n- 调用者: get_seg_limit\n- 被调用者: 未明确"
    },
    {
        "id": 1958,
        "cwe": "CWE-362",
        "cve": "CVE-2019-13233",
        "purpose": "Code purpose:\"\"\"该代码用于获取x86架构下代码段的相关参数，包括地址大小和操作数大小，并处理不同模式下的段描述符设置。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于modify_ldt()和#BR异常处理之间存在竞争条件，导致对LDT条目的访问出现释放后使用(UAF)问题\"\"\"",
        "functions": "Functions:\n1. 函数名: insn_get_code_seg_params\n- 参数: [struct pt_regs *regs]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [v8086_mode, get_segment_selector, get_desc]\n\n2. 函数名: v8086_mode\n- 参数: [struct pt_regs *regs]\n- 调用者: insn_get_code_seg_params\n- 被调用者: []\n\n3. 函数名: get_segment_selector\n- 参数: [struct pt_regs *regs, INAT_SEG_REG_CS]\n- 调用者: insn_get_code_seg_params\n- 被调用者: []\n\n4. 函数名: get_desc\n- 参数: [short sel]\n- 调用者: insn_get_code_seg_params\n- 被调用者: []"
    },
    {
        "id": 1959,
        "cwe": "CWE-362",
        "cve": "CVE-2019-13233",
        "purpose": "Code purpose:\"\"\"获取指定段寄存器的基地址，处理不同模式下的段选择子并返回对应的基地址\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于modify_ldt()和#BR异常处理之间存在竞争条件，导致对LDT条目的访问出现释放后使用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: insn_get_seg_base\n- 参数: [struct pt_regs *regs, int seg_reg_idx]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [get_segment_selector, v8086_mode, user_64bit_mode, rdmsrl, get_desc, get_desc_base]\n\n2. 函数名: get_segment_selector\n- 参数: [struct pt_regs *regs, int seg_reg_idx]\n- 调用者: insn_get_seg_base\n- 被调用者: 未明确\n\n3. 函数名: v8086_mode\n- 参数: [struct pt_regs *regs]\n- 调用者: insn_get_seg_base\n- 被调用者: 未明确\n\n4. 函数名: user_64bit_mode\n- 参数: [struct pt_regs *regs]\n- 调用者: insn_get_seg_base\n- 被调用者: 未明确\n\n5. 函数名: rdmsrl\n- 参数: [MSR_FS_BASE/MSR_KERNEL_GS_BASE, unsigned long base]\n- 调用者: insn_get_seg_base\n- 被调用者: 未明确\n\n6. 函数名: get_desc\n- 参数: [short sel]\n- 调用者: insn_get_seg_base\n- 被调用者: 未明确\n\n7. 函数名: get_desc_base\n- 参数: [struct desc_struct *desc]\n- 调用者: insn_get_seg_base\n- 被调用者: 未明确"
    },
    {
        "id": 2091,
        "cwe": "CWE-362",
        "cve": "CVE-2019-18683",
        "purpose": "Code purpose:\"\"\"停止视频捕获流并释放相关资源，处理多个流类型的活动缓冲区，确保在停止所有流后关闭控制线程。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在停止视频流生成时存在多个竞态条件，由于vivid_stop_generating_vid_cap()等函数中错误的互斥锁使用导致使用后释放漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: vivid_stop_generating_vid_cap\n- 参数: [struct vivid_dev *dev, bool *pstreaming]\n- 调用者: 未显示\n- 被调用者: [list_empty, list_entry, list_del, v4l2_ctrl_request_complete, vb2_buffer_done, dprintk, vivid_grab_controls, mutex_unlock, kthread_stop, mutex_lock]\n\n2. 函数名: dprintk\n- 参数: [struct vivid_dev *dev, int level, const char *fmt, ...]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示\n\n3. 函数名: list_empty\n- 参数: [struct list_head *list]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示\n\n4. 函数名: list_entry\n- 参数: [struct list_head *ptr, type, member]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示\n\n5. 函数名: list_del\n- 参数: [struct list_head *entry]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示\n\n6. 函数名: v4l2_ctrl_request_complete\n- 参数: [struct v4l2_ctrl_handler *hdl, struct v4l2_ctrl_handler *parent]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示\n\n7. 函数名: vb2_buffer_done\n- 参数: [struct vb2_buffer *vb, enum vb2_buffer_state state]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示\n\n8. 函数名: vivid_grab_controls\n- 参数: [struct vivid_dev *dev, bool grab]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示\n\n9. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示\n\n10. 函数名: kthread_stop\n- 参数: [struct task_struct *k]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示\n\n11. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示"
    },
    {
        "id": 2092,
        "cwe": "CWE-362",
        "cve": "CVE-2019-18683",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中V4L2子系统vivid驱动程序的视频捕获线程功能，负责管理视频流捕获过程中的帧计数、时间计算和缓冲区同步等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在视频流停止过程中存在多个竞态条件，由于vivid_stop_generating_vid_cap()等函数及其对应的kthreads中错误的互斥锁使用导致使用后释放漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: vivid_thread_vid_cap\n- 参数: [data]\n- 调用者: 未被显示（通常由kthread_create或类似函数调用）\n- 被调用者: [dprintk, set_freezable, ktime_get_ns, vivid_cap_update_frame_period, try_to_freeze, kthread_should_stop, mutex_lock, vivid_thread_vid_cap_tick, mutex_unlock, schedule_timeout_interruptible]\n\n2. 函数名: dprintk\n- 参数: [dev, 1, format_string]\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n3. 函数名: set_freezable\n- 参数: []\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n4. 函数名: ktime_get_ns\n- 参数: []\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n5. 函数名: vivid_cap_update_frame_period\n- 参数: [dev]\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n6. 函数名: try_to_freeze\n- 参数: []\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n7. 函数名: kthread_should_stop\n- 参数: []\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n8. 函数名: mutex_lock\n- 参数: [&dev->mutex]\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n9. 函数名: vivid_thread_vid_cap_tick\n- 参数: [dev, dropped_bufs]\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n10. 函数名: mutex_unlock\n- 参数: [&dev->mutex]\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n11. 函数名: schedule_timeout_interruptible\n- 参数: [wait_jiffies ? wait_jiffies : 1]\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n12. 函数名: do_div\n- 参数: [buffers_since_start, HZ * numerator]\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []"
    },
    {
        "id": 2093,
        "cwe": "CWE-362",
        "cve": "CVE-2019-18683",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中V4L2子系统vivid驱动视频输出线程的功能，负责管理视频流的帧同步和时间计算，但存在竞争条件导致可能的使用后释放漏洞。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在视频输出线程中存在竞态条件，由于错误的互斥锁使用导致在停止流媒体时可能发生use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: vivid_thread_vid_out\n- 参数: [data]\n- 调用者: 未知（由内核线程调用）\n- 被调用者: [dprintk, set_freezable, try_to_freeze, kthread_should_stop, mutex_lock, mutex_unlock, vivid_thread_vid_out_tick, do_div, schedule_timeout_interruptible]\n\n2. 函数名: dprintk\n- 参数: [dev, 1, format_string]\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n3. 函数名: set_freezable\n- 参数: []\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n4. 函数名: try_to_freeze\n- 参数: []\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n5. 函数名: kthread_should_stop\n- 参数: []\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n6. 函数名: mutex_lock\n- 参数: [&dev->mutex]\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n7. 函数名: mutex_unlock\n- 参数: [&dev->mutex]\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n8. 函数名: vivid_thread_vid_out_tick\n- 参数: [dev]\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n9. 函数名: do_div\n- 参数: [buffers_since_start, HZ * numerator]\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n10. 函数名: schedule_timeout_interruptible\n- 参数: [wait_jiffies ? wait_jiffies : 1]\n- 调用者: vivid_thread_vid_out\n- 被调用者: []"
    },
    {
        "id": 2094,
        "cwe": "CWE-362",
        "cve": "CVE-2019-18683",
        "purpose": "Code purpose:\"\"\"停止视频输出流并释放相关资源，处理不同流类型的缓冲区清理工作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在停止视频流生成时存在多个竞态条件，由于错误的互斥锁锁定机制导致可能发生释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: vivid_stop_generating_vid_out\n- 参数: [dev, pstreaming]\n- 调用者: 未明确显示（应为外部调用）\n- 被调用者: [dprintk, list_empty, list_entry, list_del, v4l2_ctrl_request_complete, vb2_buffer_done, vivid_grab_controls, mutex_unlock, kthread_stop, mutex_lock]\n\n2. 函数名: dprintk\n- 参数: [dev, level, format, ...]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n3. 函数名: list_empty\n- 参数: [list_head]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n4. 函数名: list_entry\n- 参数: [ptr, type, member]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n5. 函数名: list_del\n- 参数: [entry]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n6. 函数名: v4l2_ctrl_request_complete\n- 参数: [req, hdl]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n7. 函数名: vb2_buffer_done\n- 参数: [vb, state]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n8. 函数名: vivid_grab_controls\n- 参数: [dev, grab]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n9. 函数名: mutex_unlock\n- 参数: [lock]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n10. 函数名: kthread_stop\n- 参数: [kthread]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n11. 函数名: mutex_lock\n- 参数: [lock]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []"
    },
    {
        "id": 2095,
        "cwe": "CWE-362",
        "cve": "CVE-2019-18683",
        "purpose": "Code purpose:\"\"\"停止SDR捕获流并清理相关资源，包括处理活动缓冲区列表和控制线程的关闭\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在停止流媒体时存在竞态条件，由于错误的互斥锁锁定机制导致可能发生释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: sdr_cap_stop_streaming\n- 参数: [struct vb2_queue *vq]\n- 调用者: 未明确（由V4L2子系统调用）\n- 被调用者: [vb2_get_drv_priv, list_empty, list_entry, list_del, v4l2_ctrl_request_complete, vb2_buffer_done, mutex_unlock, kthread_stop, mutex_lock]\n\n2. 函数名: vb2_get_drv_priv\n- 参数: [struct vb2_queue *vq]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n3. 函数名: list_empty\n- 参数: [&dev->sdr_cap_active]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n4. 函数名: list_entry\n- 参数: [dev->sdr_cap_active.next, struct vivid_buffer, list]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n5. 函数名: list_del\n- 参数: [&buf->list]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n6. 函数名: v4l2_ctrl_request_complete\n- 参数: [buf->vb.vb2_buf.req_obj.req, &dev->ctrl_hdl_sdr_cap]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n7. 函数名: vb2_buffer_done\n- 参数: [&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n8. 函数名: mutex_unlock\n- 参数: [&dev->mutex]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n9. 函数名: kthread_stop\n- 参数: [dev->kthread_sdr_cap]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n10. 函数名: mutex_lock\n- 参数: [&dev->mutex]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []"
    },
    {
        "id": 2096,
        "cwe": "CWE-362",
        "cve": "CVE-2019-18683",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中V4L2子系统vivid驱动程序的SDR捕获线程功能，用于处理软件定义无线电(SDR)的数据流捕获，包括时间计算、缓冲区管理和序列同步等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在vivid驱动程序的流停止过程中存在多个竞态条件，由于vivid_stop_generating_vid_cap()等函数及其对应的kthread中错误的互斥锁使用导致使用后释放问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: vivid_thread_sdr_cap\n- 参数: [data]\n- 调用者: 未知（由内核线程调用）\n- 被调用者: [dprintk, set_freezable, try_to_freeze, kthread_should_stop, mutex_lock, mutex_unlock, vivid_thread_sdr_cap_tick, do_div, schedule_timeout_interruptible]\n\n2. 函数名: dprintk\n- 参数: [dev, 1, format_string]\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n3. 函数名: set_freezable\n- 参数: []\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n4. 函数名: try_to_freeze\n- 参数: []\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n5. 函数名: kthread_should_stop\n- 参数: []\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n6. 函数名: mutex_lock\n- 参数: [&dev->mutex]\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n7. 函数名: mutex_unlock\n- 参数: [&dev->mutex]\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n8. 函数名: vivid_thread_sdr_cap_tick\n- 参数: [dev]\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n9. 函数名: do_div\n- 参数: [buffers_since_start, HZ * SDR_CAP_SAMPLES_PER_BUF]\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n10. 函数名: schedule_timeout_interruptible\n- 参数: [wait_jiffies ? wait_jiffies : 1]\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []"
    },
    {
        "id": 2219,
        "cwe": "CWE-362",
        "cve": "CVE-2019-19537",
        "purpose": "Code purpose:\"\"\"该代码用于注销USB设备的字符设备驱动，释放分配的次设备号并销毁相关设备节点和类结构。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核USB字符设备驱动层中存在竞态条件漏洞，恶意USB设备可在usb_deregister_dev函数执行期间通过竞争条件操作已被释放的minor号资源。\"\"\"",
        "functions": "Functions:\n1. 函数名: usb_deregister_dev\n- 参数: [struct usb_interface *intf, struct usb_class_driver *class_driver]\n- 调用者: 未明确显示（通常由USB设备驱动相关代码调用）\n- 被调用者: [dev_dbg, down_write, up_write, device_destroy, destroy_usb_class]\n\n2. 函数名: dev_dbg\n- 参数: [&intf->dev, \"removing %d minor\\n\", intf->minor]\n- 调用者: usb_deregister_dev\n- 被调用者: []\n\n3. 函数名: down_write\n- 参数: [&minor_rwsem]\n- 调用者: usb_deregister_dev\n- 被调用者: []\n\n4. 函数名: up_write\n- 参数: [&minor_rwsem]\n- 调用者: usb_deregister_dev\n- 被调用者: []\n\n5. 函数名: device_destroy\n- 参数: [usb_class->class, MKDEV(USB_MAJOR, intf->minor)]\n- 调用者: usb_deregister_dev\n- 被调用者: []\n\n6. 函数名: destroy_usb_class\n- 参数: []\n- 调用者: usb_deregister_dev\n- 被调用者: []"
    },
    {
        "id": 2220,
        "cwe": "CWE-362",
        "cve": "CVE-2019-19537",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中注册USB设备并分配次设备号，管理USB字符设备驱动层的设备接口\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在USB字符设备驱动层中存在竞争条件，恶意USB设备可能利用minor号分配时的同步不足导致安全问题\"\"\"",
        "functions": "Functions:\n1. 函数名: usb_register_dev\n- 参数: [struct usb_interface *intf, struct usb_class_driver *class_driver]\n- 调用者: N/A (top-level function)\n- 被调用者: [mutex_lock, init_usb_class, mutex_unlock, dev_dbg, down_write, up_write, snprintf, device_create, kbasename, IS_ERR, PTR_ERR]\n\n2. 函数名: mutex_lock\n- 参数: [&init_usb_class_mutex]\n- 调用者: usb_register_dev\n- 被调用者: []\n\n3. 函数名: init_usb_class\n- 参数: []\n- 调用者: usb_register_dev\n- 被调用者: []\n\n4. 函数名: mutex_unlock\n- 参数: [&init_usb_class_mutex]\n- 调用者: usb_register_dev\n- 被调用者: []\n\n5. 函数名: dev_dbg\n- 参数: [&intf->dev, \"looking for a minor, starting at %d\\n\", minor_base]\n- 调用者: usb_register_dev\n- 被调用者: []\n\n6. 函数名: down_write\n- 参数: [&minor_rwsem]\n- 调用者: usb_register_dev\n- 被调用者: []\n\n7. 函数名: up_write\n- 参数: [&minor_rwsem]\n- 调用者: usb_register_dev\n- 被调用者: []\n\n8. 函数名: snprintf\n- 参数: [name, sizeof(name), class_driver->name, minor - minor_base]\n- 调用者: usb_register_dev\n- 被调用者: []\n\n9. 函数名: device_create\n- 参数: [usb_class->class, &intf->dev, MKDEV(USB_MAJOR, minor), class_driver, \"%s\", kbasename(name)]\n- 调用者: usb_register_dev\n- 被调用者: []\n\n10. 函数名: kbasename\n- 参数: [name]\n- 调用者: usb_register_dev\n- 被调用者: []\n\n11. 函数名: IS_ERR\n- 参数: [intf->usb_dev]\n- 调用者: usb_register_dev\n- 被调用者: []\n\n12. 函数名: PTR_ERR\n- 参数: [intf->usb_dev]\n- 调用者: usb_register_dev\n- 被调用者: []"
    },
    {
        "id": 2294,
        "cwe": "CWE-362",
        "cve": "CVE-2019-2213",
        "purpose": "Code purpose:\"\"\"释放binder事务结构体并处理相关资源，包括解除buffer关联、释放修复项和内存空间\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放binder_transaction结构体时存在竞态条件，导致可能在其他线程仍访问该结构体时被释放，从而引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_free_transaction\n- 参数: [struct binder_transaction *t]\n- 调用者: 未指定\n- 被调用者: [binder_free_txn_fixups, kfree, binder_stats_deleted]\n\n2. 函数名: binder_free_txn_fixups\n- 参数: [struct binder_transaction *t]\n- 调用者: binder_free_transaction\n- 被调用者: 未指定\n\n3. 函数名: kfree\n- 参数: [void *ptr] (此处为 struct binder_transaction *t)\n- 调用者: binder_free_transaction\n- 被调用者: 未指定\n\n4. 函数名: binder_stats_deleted\n- 参数: [BINDER_STAT_TRANSACTION]\n- 调用者: binder_free_transaction\n- 被调用者: 未指定"
    },
    {
        "id": 2295,
        "cwe": "CWE-362",
        "cve": "CVE-2019-2213",
        "purpose": "Code purpose:\"\"\"释放Binder进程间通信中的缓冲区资源并处理相关事务的清理工作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于竞态条件导致在释放binder事务缓冲区时可能发生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_free_buf\n- 参数: [proc, buffer]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [binder_node_inner_lock, BUG_ON, binder_dequeue_work_head_ilocked, binder_enqueue_work_ilocked, binder_wakeup_proc_ilocked, binder_node_inner_unlock, trace_binder_transaction_buffer_release, binder_transaction_buffer_release, binder_alloc_free_buf]\n\n2. 函数名: binder_node_inner_lock\n- 参数: [buf_node]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n3. 函数名: BUG_ON\n- 参数: [condition]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n4. 函数名: binder_dequeue_work_head_ilocked\n- 参数: [&buf_node->async_todo]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n5. 函数名: binder_enqueue_work_ilocked\n- 参数: [w, &proc->todo]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n6. 函数名: binder_wakeup_proc_ilocked\n- 参数: [proc]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n7. 函数名: binder_node_inner_unlock\n- 参数: [buf_node]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n8. 函数名: trace_binder_transaction_buffer_release\n- 参数: [buffer]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n9. 函数名: binder_transaction_buffer_release\n- 参数: [proc, buffer, 0, false]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n10. 函数名: binder_alloc_free_buf\n- 参数: [&proc->alloc, buffer]\n- 调用者: binder_free_buf\n- 被调用者: []"
    },
    {
        "id": 2306,
        "cwe": "CWE-362",
        "cve": "CVE-2019-3016",
        "purpose": "Code purpose:\"\"\"在启用PV TLB的KVM虚拟机中，设置虚拟CPU的抢占状态并将其写入客户机内存\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于KVM客户机中PV TLB启用时缺乏适当的同步机制，导致一个进程可以读取同一客户机中另一个进程的内存内容\"\"\"",
        "functions": "Functions:\n1. 函数名: kvm_steal_time_set_preempted\n- 参数: [vcpu]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [kvm_write_guest_offset_cached]\n\n2. 函数名: kvm_write_guest_offset_cached\n- 参数: [vcpu->kvm, &vcpu->arch.st.stime, &vcpu->arch.st.steal.preempted, offsetof(struct kvm_steal_time, preempted), sizeof(vcpu->arch.st.steal.preempted)]\n- 调用者: kvm_steal_time_set_preempted\n- 被调用者: 未明确（可能是底层KVM函数）"
    },
    {
        "id": 2341,
        "cwe": "CWE-362",
        "cve": "CVE-2019-6133",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中进程复制(fork)的核心功能copy_process，负责创建新进程并设置其各种属性和资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于fork()操作的非原子性，导致进程启动时间保护机制被绕过，使得授权决策被错误地缓存，且缺乏对用户ID的检查\"\"\"",
        "functions": "Functions:\n1. 函数名: copy_process\n- 参数: [clone_flags, stack_start, stack_size, child_tidptr, pid, trace, tls, node]\n- 调用者: N/A (kernel fork operation)\n- 被调用者: [ERR_PTR, dup_task_struct, ftrace_graph_init_task, rt_mutex_init_task, copy_creds, delayacct_tsk_init, init_sigpending, posix_cpu_timers_init, ktime_get_ns, ktime_get_boot_ns, audit_set_context, cgroup_fork, mpol_dup, sched_fork, perf_event_init_task, audit_alloc, shm_init_task, security_task_alloc, copy_semundo, copy_files, copy_fs, copy_sighand, copy_signal, copy_mm, copy_namespaces, copy_io, copy_thread_tls, stackleak_task_init, alloc_pid, user_disable_single_step, clear_tsk_thread_flag, clear_all_latency_tracing, pid_nr, cgroup_threadgroup_change_begin, cgroup_can_fork, klp_copy_process, copy_seccomp, rseq_fork, ptrace_init_task, init_task_pid, is_child_reaper, tty_kref_get, attach_pid, __this_cpu_inc, task_join_group_stop, hlist_del_init, syscall_tracepoint_update, proc_fork_connector, cgroup_post_fork, perf_event_fork, trace_task_newtask, uprobe_copy_process, free_pid, exit_thread, exit_io_context, exit_task_namespaces, mmput, free_signal_struct, __cleanup_sighand, exit_fs, exit_files, exit_sem, security_task_free, audit_free, perf_event_free_task, lockdep_free_task, mpol_put, delayacct_tsk_free, atomic_dec, exit_creds, put_task_stack, free_task]\n\n2. 函数名: dup_task_struct\n- 参数: [current, node]\n- 调用者: copy_process\n- 被调用者: N/A\n\n3. 函数名: ftrace_graph_init_task\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n4. 函数名: rt_mutex_init_task\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n5. 函数名: copy_creds\n- 参数: [p, clone_flags]\n- 调用者: copy_process\n- 被调用者: N/A\n\n6. 函数名: delayacct_tsk_init\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n7. 函数名: init_sigpending\n- 参数: [&p->pending]\n- 调用者: copy_process\n- 被调用者: N/A\n\n8. 函数名: posix_cpu_timers_init\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n9. 函数名: ktime_get_ns\n- 参数: []\n- 调用者: copy_process\n- 被调用者: N/A\n\n10. 函数名: ktime_get_boot_ns\n- 参数: []\n- 调用者: copy_process\n- 被调用者: N/A\n\n11. 函数名: audit_set_context\n- 参数: [p, NULL]\n- 调用者: copy_process\n- 被调用者: N/A\n\n12. 函数名: cgroup_fork\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n13. 函数名: mpol_dup\n- 参数: [p->mempolicy]\n- 调用者: copy_process\n- 被调用者: N/A\n\n14. 函数名: sched_fork\n- 参数: [clone_flags, p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n15. 函数名: perf_event_init_task\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n16. 函数名: audit_alloc\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n17. 函数名: shm_init_task\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n18. 函数名: security_task_alloc\n- 参数: [p, clone_flags]\n- 调用者: copy_process\n- 被调用者: N/A\n\n19. 函数名: copy_semundo\n- 参数: [clone_flags, p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n20. 函数名: copy_files\n- 参数: [clone_flags, p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n21. 函数名: copy_fs\n- 参数: [clone_flags, p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n22. 函数名: copy_sighand\n- 参数: [clone_flags, p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n23. 函数名: copy_signal\n- 参数: [clone_flags, p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n24. 函数名: copy_mm\n- 参数: [clone_flags, p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n25. 函数名: copy_namespaces\n- 参数: [clone_flags, p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n26. 函数名: copy_io\n- 参数: [clone_flags, p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n27. 函数名: copy_thread_tls\n- 参数: [clone_flags, stack_start, stack_size, p, tls]\n- 调用者: copy_process\n- 被调用者: N/A\n\n28. 函数名: stackleak_task_init\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n29. 函数名: alloc_pid\n- 参数: [p->nsproxy->pid_ns_for_children]\n- 调用者: copy_process\n- 被调用者: N/A\n\n30. 函数名: user_disable_single_step\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n31. 函数名: clear_tsk_thread_flag\n- 参数: [p, TIF_SYSCALL_TRACE]\n- 调用者: copy_process\n- 被调用者: N/A\n\n32. 函数名: clear_all_latency_tracing\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n33. 函数名: pid_nr\n- 参数: [pid]\n- 调用者: copy_process\n- 被调用者: N/A\n\n34. 函数名: cgroup_threadgroup_change_begin\n- 参数: [current]\n- 调用者: copy_process\n- 被调用者: N/A\n\n35. 函数名: cgroup_can_fork\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n36. 函数名: klp_copy_process\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n37. 函数名: copy_seccomp\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n38. 函数名: rseq_fork\n- 参数: [p, clone_flags]\n- 调用者: copy_process\n- 被调用者: N/A\n\n39. 函数名: ptrace_init_task\n- 参数: [p, (clone_flags & CLONE_PTRACE) || trace]\n- 调用者: copy_process\n- 被调用者: N/A\n\n40. 函数名: init_task_pid\n- 参数: [p, PIDTYPE_PID, pid]\n- 调用者: copy_process\n- 被调用者: N/A\n\n41. 函数名: is_child_reaper\n- 参数: [pid]\n- 调用者: copy_process\n- 被调用者: N/A\n\n42. 函数名: tty_kref_get\n- 参数: [current->signal->tty]\n- 调用者: copy_process\n- 被调用者: N/A\n\n43. 函数名: attach_pid\n- 参数: [p, PIDTYPE_TGID]\n- 调用者: copy_process\n- 被调用者: N/A\n\n44. 函数名: __this_cpu_inc\n- 参数: [process_counts]\n- 调用者: copy_process\n- 被调用者: N/A\n\n45. 函数名: task_join_group_stop\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n46. 函数名: hlist_del_init\n- 参数: [&delayed.node]\n- 调用者: copy_process\n- 被调用者: N/A\n\n47. 函数名: syscall_tracepoint_update\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n48. 函数名: proc_fork_connector\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n49. 函数名: cgroup_post_fork\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n50. 函数名: perf_event_fork\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n51. 函数名: trace_task_newtask\n- 参数: [p, clone_flags]\n- 调用者: copy_process\n- 被调用者: N/A\n\n52. 函数名: uprobe_copy_process\n- 参数: [p, clone_flags]\n- 调用者: copy_process\n- 被调用者: N/A\n\n53. 函数名: free_pid\n- 参数: [pid]\n- 调用者: copy_process\n- 被调用者: N/A\n\n54. 函数名: exit_thread\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n55. 函数名: exit_io_context\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n56. 函数名: exit_task_namespaces\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n57. 函数名: mmput\n- 参数: [p->mm]\n- 调用者: copy_process\n- 被调用者: N/A\n\n58. 函数名: free_signal_struct\n- 参数: [p->signal]\n- 调用者: copy_process\n- 被调用者: N/A\n\n59. 函数名: __cleanup_sighand\n- 参数: [p->sighand]\n- 调用者: copy_process\n- 被调用者: N/A\n\n60. 函数名: exit_fs\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n61. 函数名: exit_files\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n62. 函数名: exit_sem\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n63. 函数名: security_task_free\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n64. 函数名: audit_free\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n65. 函数名: perf_event_free_task\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n66. 函数名: lockdep_free_task\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n67. 函数名: mpol_put\n- 参数: [p->mempolicy]\n- 调用者: copy_process\n- 被调用者: N/A\n\n68. 函数名: delayacct_tsk_free\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n69. 函数名: atomic_dec\n- 参数: [&p->cred->user->processes]\n- 调用者: copy_process\n- 被调用者: N/A\n\n70. 函数名: exit_creds\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n71. 函数名: put_task_stack\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A\n\n72. 函数名: free_task\n- 参数: [p]\n- 调用者: copy_process\n- 被调用者: N/A"
    },
    {
        "id": 2342,
        "cwe": "CWE-362",
        "cve": "CVE-2019-6974",
        "purpose": "Code purpose:\"\"\"该代码用于在KVM虚拟化环境中创建并管理虚拟设备，处理设备创建、初始化和文件描述符分配等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于存在竞态条件导致引用计数处理不当，从而引发释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: kvm_ioctl_create_device\n- 参数: [struct kvm *kvm, struct kvm_create_device *cd]\n- 调用者: 未显示（由KVM子系统调用）\n- 被调用者: [kzalloc, mutex_lock, mutex_unlock, kfree, list_add, anon_inode_getfd, list_del, ops->create, ops->init, ops->destroy, kvm_get_kvm]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*dev), GFP_KERNEL]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: 内核内存分配函数\n\n3. 函数名: mutex_lock\n- 参数: [&kvm->lock]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: 内核互斥锁函数\n\n4. 函数名: mutex_unlock\n- 参数: [&kvm->lock]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: 内核互斥锁函数\n\n5. 函数名: kfree\n- 参数: [dev]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: 内核内存释放函数\n\n6. 函数名: list_add\n- 参数: [&dev->vm_node, &kvm->devices]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: 内核链表函数\n\n7. 函数名: anon_inode_getfd\n- 参数: [ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: 内核匿名inode函数\n\n8. 函数名: list_del\n- 参数: [&dev->vm_node]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: 内核链表函数\n\n9. 函数名: kvm_get_kvm\n- 参数: [kvm]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: KVM引用计数函数"
    },
    {
        "id": 2372,
        "cwe": "CWE-362",
        "cve": "CVE-2020-0030",
        "purpose": "Code purpose:\"\"\"释放Binder线程资源并处理相关事务，包括清理线程的事务栈、发送失败回复以及减少临时引用计数。\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在binder_thread_release函数中存在竞态条件，导致线程释放后仍可能被访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_thread_release\n- 参数: [struct binder_proc *proc, struct binder_thread *thread]\n- 调用者: 未指定\n- 被调用者: [binder_inner_proc_lock, atomic_inc, rb_erase, spin_lock, binder_debug, spin_unlock, wake_up_poll, binder_inner_proc_unlock, binder_send_failed_reply, binder_release_work, binder_thread_dec_tmpref]\n\n2. 函数名: binder_inner_proc_lock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_thread_release\n- 被调用者: 未指定\n\n3. 函数名: atomic_inc\n- 参数: [atomic_t *v]\n- 调用者: binder_thread_release\n- 被调用者: 未指定\n\n4. 函数名: rb_erase\n- 参数: [struct rb_node *node, struct rb_root *root]\n- 调用者: binder_thread_release\n- 被调用者: 未指定\n\n5. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: binder_thread_release\n- 被调用者: 未指定\n\n6. 函数名: binder_debug\n- 参数: [unsigned int mask, const char *fmt, ...]\n- 调用者: binder_thread_release\n- 被调用者: 未指定\n\n7. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: binder_thread_release\n- 被调用者: 未指定\n\n8. 函数名: wake_up_poll\n- 参数: [wait_queue_head_t *wq_head, unsigned int key]\n- 调用者: binder_thread_release\n- 被调用者: 未指定\n\n9. 函数名: binder_inner_proc_unlock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_thread_release\n- 被调用者: 未指定\n\n10. 函数名: binder_send_failed_reply\n- 参数: [struct binder_transaction *t, uint32_t error_code]\n- 调用者: binder_thread_release\n- 被调用者: 未指定\n\n11. 函数名: binder_release_work\n- 参数: [struct binder_proc *proc, struct list_head *list]\n- 调用者: binder_thread_release\n- 被调用者: 未指定\n\n12. 函数名: binder_thread_dec_tmpref\n- 参数: [struct binder_thread *thread]\n- 调用者: binder_thread_release\n- 被调用者: 未指定"
    },
    {
        "id": 2374,
        "cwe": "CWE-362",
        "cve": "CVE-2020-0066",
        "purpose": "Code purpose:\"\"\"该代码实现了netlink套接字的数据转储功能，处理网络链接消息的接收和发送，包括内存分配、消息处理和回调机制。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于netlink驱动中存在竞态条件，导致可能发生越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: netlink_dump\n- 参数: [struct sock *sk]\n- 调用者: 未显示\n- 被调用者: [nlk_sk, mutex_lock, max_t, netlink_rx_is_mmaped, atomic_read, netlink_alloc_skb, skb_reserve, netlink_skb_set_owner_r, cb->dump, mutex_unlock, sk_filter, kfree_skb, __netlink_sendskb, nlmsg_put_answer, nl_dump_check_consistent, memcpy, cb->done, module_put, consume_skb]\n\n2. 函数名: nlk_sk\n- 参数: [struct sock *sk]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n3. 函数名: mutex_lock\n- 参数: [nlk->cb_mutex]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n4. 函数名: max_t\n- 参数: [int, cb->min_dump_alloc, NLMSG_GOODSIZE]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n5. 函数名: netlink_rx_is_mmaped\n- 参数: [struct sock *sk]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n6. 函数名: atomic_read\n- 参数: [&sk->sk_rmem_alloc]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n7. 函数名: netlink_alloc_skb\n- 参数: [struct sock *sk, nlk->max_recvmsg_len, nlk->portid, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY] 和 [struct sock *sk, alloc_size, nlk->portid, GFP_KERNEL]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n8. 函数名: skb_reserve\n- 参数: [skb, skb_tailroom(skb) - nlk->max_recvmsg_len]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n9. 函数名: netlink_skb_set_owner_r\n- 参数: [skb, sk]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n10. 函数名: cb->dump\n- 参数: [skb, cb]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n11. 函数名: mutex_unlock\n- 参数: [nlk->cb_mutex]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n12. 函数名: sk_filter\n- 参数: [sk, skb]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n13. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n14. 函数名: __netlink_sendskb\n- 参数: [sk, skb]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n15. 函数名: nlmsg_put_answer\n- 参数: [skb, cb, NLMSG_DONE, sizeof(len), NLM_F_MULTI]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n16. 函数名: nl_dump_check_consistent\n- 参数: [cb, nlh]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n17. 函数名: memcpy\n- 参数: [nlmsg_data(nlh), &len, sizeof(len)]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n18. 函数名: cb->done\n- 参数: [cb]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n19. 函数名: module_put\n- 参数: [cb->module]\n- 调用者: netlink_dump\n- 被调用者: 未显示\n\n20. 函数名: consume_skb\n- 参数: [cb->skb]\n- 调用者: netlink_dump\n- 被调用者: 未显示"
    },
    {
        "id": 2377,
        "cwe": "CWE-362",
        "cve": "CVE-2020-0305",
        "purpose": "Code purpose:\"\"\"获取字符设备对应的kobject对象并增加模块引用计数，同时处理可能的竞态条件\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在cdev_get函数中存在竞态条件，可能导致模块引用计数管理不当，从而引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: cdev_get\n- 参数: [struct cdev *p]\n- 调用者: 未明确（通常是外部调用）\n- 被调用者: [try_module_get, kobject_get, module_put]\n\n2. 函数名: try_module_get\n- 参数: [struct module *owner]\n- 调用者: cdev_get\n- 被调用者: []\n\n3. 函数名: kobject_get\n- 参数: [struct kobject *kobj]\n- 调用者: cdev_get\n- 被调用者: []\n\n4. 函数名: module_put\n- 参数: [struct module *owner]\n- 调用者: cdev_get\n- 被调用者: []"
    },
    {
        "id": 2436,
        "cwe": "CWE-362",
        "cve": "CVE-2020-11884",
        "purpose": "Code purpose:\"\"\"该代码片段用于在s390平台上启用用户空间访问的内核功能，同时处理地址空间控制寄存器的切换操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于enable_sacf_uaccess函数未能防止并发页表升级导致的竞争条件，可能引发代码执行或系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: enable_sacf_uaccess\n- 参数: []\n- 调用者: 未明确（由系统调用或内核其他部分调用）\n- 被调用者: [__ctl_store, __ctl_load, set_cpu_flag]\n\n2. 函数名: __ctl_store\n- 参数: [cr, 1, 1] 和 [cr, 7, 7]\n- 调用者: enable_sacf_uaccess\n- 被调用者: []\n\n3. 函数名: __ctl_load\n- 参数: [S390_lowcore.kernel_asce, 1, 1] 和 [asce, 7, 7]\n- 调用者: enable_sacf_uaccess\n- 被调用者: []\n\n4. 函数名: set_cpu_flag\n- 参数: [CIF_ASCE_PRIMARY] 和 [CIF_ASCE_SECONDARY]\n- 调用者: enable_sacf_uaccess\n- 被调用者: []"
    },
    {
        "id": 2437,
        "cwe": "CWE-362",
        "cve": "CVE-2020-11884",
        "purpose": "Code purpose:\"\"\"在s390平台上处理内存管理单元(MMU)的页表升级操作，并刷新TLB缓存\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于s390平台上的Linux内核在并发页面表升级时缺乏适当的保护机制，导致存在竞争条件漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: __crst_table_upgrade\n- 参数: [arg]\n- 调用者: 未明确（可能是内核其他模块或并发操作）\n- 被调用者: [set_user_asce, __tlb_flush_local]\n\n2. 函数名: set_user_asce\n- 参数: [mm]\n- 调用者: __crst_table_upgrade\n- 被调用者: 未明确\n\n3. 函数名: __tlb_flush_local\n- 参数: []\n- 调用者: __crst_table_upgrade\n- 被调用者: 未明确"
    },
    {
        "id": 2438,
        "cwe": "CWE-362",
        "cve": "CVE-2020-12114",
        "purpose": "Code purpose:\"\"\"该代码用于解除文件系统挂载点的关联并释放相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于detach_mnt函数中未正确处理挂载点引用计数器的并发访问，导致竞争条件下引用计数器可能被破坏\"\"\"",
        "functions": "Functions:\n1. 函数名: detach_mnt\n- 参数: [struct mount *mnt, struct path *old_path]\n- 调用者: 未提供（上下文缺失）\n- 被调用者: [put_mountpoint, unhash_mnt]\n\n2. 函数名: unhash_mnt\n- 参数: [struct mount *mnt]（根据上下文推断）\n- 调用者: detach_mnt\n- 被调用者: 未提供（上下文缺失）\n\n3. 函数名: put_mountpoint\n- 参数: [未提供]（根据上下文推断应接收unhash_mnt的返回值）\n- 调用者: detach_mnt\n- 被调用者: 未提供（上下文缺失）"
    },
    {
        "id": 2439,
        "cwe": "CWE-362",
        "cve": "CVE-2020-12114",
        "purpose": "Code purpose:\"\"\"该代码用于在卸载挂载点时释放相关资源并减少引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在drop_mountpoint函数中存在竞态条件，导致挂载点引用计数器被错误修改，可能引发拒绝服务(系统崩溃)。\"\"\"",
        "functions": "Functions:\n1. 函数名: drop_mountpoint\n- 参数: [struct fs_pin *p]\n- 调用者: 未明确（上下文不足）\n- 被调用者: [container_of, dput, pin_remove, mntput]\n\n2. 函数名: container_of\n- 参数: [p, struct mount, mnt_umount]（推断）\n- 调用者: drop_mountpoint\n- 被调用者: 无（宏函数）\n\n3. 函数名: dput\n- 参数: [m->mnt_ex_mountpoint]\n- 调用者: drop_mountpoint\n- 被调用者: 无（上下文不足）\n\n4. 函数名: pin_remove\n- 参数: [p]\n- 调用者: drop_mountpoint\n- 被调用者: 无（上下文不足）\n\n5. 函数名: mntput\n- 参数: [&m->mnt]\n- 调用者: drop_mountpoint\n- 被调用者: 无（上下文不足）"
    },
    {
        "id": 2440,
        "cwe": "CWE-362",
        "cve": "CVE-2020-12114",
        "purpose": "Code purpose:\"\"\"该代码用于获取或创建指定目录项的挂载点结构，并管理挂载点引用计数以防止竞争条件。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在竞争条件下未能正确管理挂载点引用计数器，导致本地用户可能通过破坏挂载点引用计数器引发拒绝服务(panic)。\"\"\"",
        "functions": "Functions:\n1. 函数名: get_mountpoint\n- 参数: [struct dentry *dentry]\n- 调用者: 未明确（通常是内核中处理挂载点的相关函数）\n- 被调用者: [d_mountpoint, d_unlinked, ERR_PTR, lookup_mountpoint, read_seqlock_excl, read_sequnlock_excl, kmalloc, d_set_mounted, hlist_add_head, INIT_HLIST_HEAD, kfree]\n\n2. 函数名: d_mountpoint\n- 参数: [struct dentry *dentry]\n- 调用者: get_mountpoint\n- 被调用者: []\n\n3. 函数名: d_unlinked\n- 参数: [struct dentry *dentry]\n- 调用者: get_mountpoint\n- 被调用者: []\n\n4. 函数名: ERR_PTR\n- 参数: [long error]\n- 调用者: get_mountpoint\n- 被调用者: []\n\n5. 函数名: lookup_mountpoint\n- 参数: [struct dentry *dentry]\n- 调用者: get_mountpoint\n- 被调用者: []\n\n6. 函数名: read_seqlock_excl\n- 参数: [seqlock_t *sl]\n- 调用者: get_mountpoint\n- 被调用者: []\n\n7. 函数名: read_sequnlock_excl\n- 参数: [seqlock_t *sl]\n- 调用者: get_mountpoint\n- 被调用者: []\n\n8. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: get_mountpoint\n- 被调用者: []\n\n9. 函数名: d_set_mounted\n- 参数: [struct dentry *dentry]\n- 调用者: get_mountpoint\n- 被调用者: []\n\n10. 函数名: hlist_add_head\n- 参数: [struct hlist_node *n, struct hlist_head *h]\n- 调用者: get_mountpoint\n- 被调用者: []\n\n11. 函数名: INIT_HLIST_HEAD\n- 参数: [struct hlist_head *h]\n- 调用者: get_mountpoint\n- 被调用者: []\n\n12. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: get_mountpoint\n- 被调用者: []"
    },
    {
        "id": 2441,
        "cwe": "CWE-362",
        "cve": "CVE-2020-12114",
        "purpose": "Code purpose:\"\"\"设置挂载点并更新相关挂载结构的引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺少对mountpoint引用计数器的适当同步保护，导致在竞争条件下可能被破坏，引发拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: mnt_set_mountpoint\n- 参数: [struct mount *mnt, struct mountpoint *mp, struct mount *child_mnt]\n- 调用者: 未指定（由内核其他部分调用）\n- 被调用者: [dget, mnt_add_count, hlist_add_head]\n\n2. 函数名: dget\n- 参数: [struct dentry *dentry]\n- 调用者: mnt_set_mountpoint\n- 被调用者: 未指定\n\n3. 函数名: mnt_add_count\n- 参数: [struct mount *mnt, int count]\n- 调用者: mnt_set_mountpoint\n- 被调用者: 未指定\n\n4. 函数名: hlist_add_head\n- 参数: [struct hlist_node *n, struct hlist_head *h]\n- 调用者: mnt_set_mountpoint\n- 被调用者: 未指定"
    },
    {
        "id": 2442,
        "cwe": "CWE-362",
        "cve": "CVE-2020-12114",
        "purpose": "Code purpose:\"\"\"该代码用于安全地减少挂载点的引用计数并在引用计数归零时清理挂载点资源，防止竞争条件下的引用计数器损坏。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在mount引用计数器递减操作中存在竞态条件，导致本地用户可能通过pivot_root操作破坏挂载点引用计数器，引发拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: mntput_no_expire\n- 参数: [struct mount *mnt]\n- 调用者: 未明确（外部调用）\n- 被调用者: [READ_ONCE, mnt_add_count, rcu_read_lock, rcu_read_unlock, lock_mount_hash, smp_mb, mnt_get_count, unlock_mount_hash, list_del, list_empty, list_for_each_entry_safe, umount_mnt, init_task_work, task_work_add, llist_add, schedule_delayed_work, cleanup_mnt]\n\n2. 函数名: mnt_add_count\n- 参数: [struct mount *mnt, int value]\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n3. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n4. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n5. 函数名: lock_mount_hash\n- 参数: []\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n6. 函数名: smp_mb\n- 参数: []\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n7. 函数名: mnt_get_count\n- 参数: [struct mount *mnt]\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n8. 函数名: unlock_mount_hash\n- 参数: []\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n9. 函数名: list_del\n- 参数: [struct list_head *entry]\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n10. 函数名: list_empty\n- 参数: [const struct list_head *head]\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n11. 函数名: list_for_each_entry_safe\n- 参数: [struct mount *p, struct mount *tmp, struct list_head *head, struct list_head *mnt_child]\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n12. 函数名: umount_mnt\n- 参数: [struct mount *p]\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n13. 函数名: init_task_work\n- 参数: [struct task_work *task_work, task_work_func_t func]\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n14. 函数名: task_work_add\n- 参数: [struct task_struct *task, struct task_work *task_work, bool notify]\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n15. 函数名: llist_add\n- 参数: [struct llist_node *new, struct llist_head *head]\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n16. 函数名: schedule_delayed_work\n- 参数: [struct delayed_work *dwork, unsigned long delay]\n- 调用者: mntput_no_expire\n- 被调用者: 未明确\n\n17. 函数名: cleanup_mnt\n- 参数: [struct mount *mnt]\n- 调用者: mntput_no_expire\n- 被调用者: 未明确"
    },
    {
        "id": 2443,
        "cwe": "CWE-362",
        "cve": "CVE-2020-12114",
        "purpose": "Code purpose:\"\"\"处理文件系统卸载操作，保存旧的挂载点信息并释放相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在umount_mnt函数中存在竞态条件，未能正确处理挂载点引用计数器的同步问题，导致本地用户可能通过破坏挂载点引用计数器引发拒绝服务(panic)。\"\"\"",
        "functions": "Functions:\n1. 函数名: umount_mnt\n- 参数: [struct mount *mnt]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [put_mountpoint, unhash_mnt]\n\n2. 函数名: put_mountpoint\n- 参数: [未明确（上下文未提供）]\n- 调用者: umount_mnt\n- 被调用者: []\n\n3. 函数名: unhash_mnt\n- 参数: [struct mount *mnt]\n- 调用者: umount_mnt\n- 被调用者: []"
    },
    {
        "id": 2444,
        "cwe": "CWE-362",
        "cve": "CVE-2020-12114",
        "purpose": "Code purpose:\"\"\"减少挂载点引用计数并在计数归零时清理相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于mountpoint引用计数器在竞态条件下被错误递减，导致可能被提前释放，从而引发系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: put_mountpoint\n- 参数: [struct mountpoint *mp]\n- 调用者: 未明确显示（通常是内核中处理挂载点的相关函数）\n- 被调用者: [hlist_empty, spin_lock, spin_unlock, hlist_del, kfree]\n\n2. 函数名: hlist_empty\n- 参数: [&mp->m_list]\n- 调用者: put_mountpoint\n- 被调用者: []\n\n3. 函数名: spin_lock\n- 参数: [&dentry->d_lock]\n- 调用者: put_mountpoint\n- 被调用者: []\n\n4. 函数名: spin_unlock\n- 参数: [&dentry->d_lock]\n- 调用者: put_mountpoint\n- 被调用者: []\n\n5. 函数名: hlist_del\n- 参数: [&mp->m_hash]\n- 调用者: put_mountpoint\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [mp]\n- 调用者: put_mountpoint\n- 被调用者: []"
    },
    {
        "id": 2445,
        "cwe": "CWE-362",
        "cve": "CVE-2020-12114",
        "purpose": "Code purpose:\"\"\"该代码用于在解除命名空间锁时处理未挂载的挂载点列表，确保在释放锁后安全地清理相关资源。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在释放命名空间锁后未正确处理挂载点引用计数器的同步问题，导致竞争条件下可能引发引用计数器损坏\"\"\"",
        "functions": "Functions:\n1. 函数名: namespace_unlock\n- 参数: []\n- 调用者: \n- 被调用者: [hlist_move_list, up_write, hlist_empty, synchronize_rcu_expedited, group_pin_kill]\n\n2. 函数名: hlist_move_list\n- 参数: [&unmounted, &head]\n- 调用者: namespace_unlock\n- 被调用者: []\n\n3. 函数名: up_write\n- 参数: [&namespace_sem]\n- 调用者: namespace_unlock\n- 被调用者: []\n\n4. 函数名: hlist_empty\n- 参数: [&head]\n- 调用者: namespace_unlock\n- 被调用者: []\n\n5. 函数名: synchronize_rcu_expedited\n- 参数: []\n- 调用者: namespace_unlock\n- 被调用者: []\n\n6. 函数名: group_pin_kill\n- 参数: [&head]\n- 调用者: namespace_unlock\n- 被调用者: []"
    },
    {
        "id": 2446,
        "cwe": "CWE-362",
        "cve": "CVE-2020-12114",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中安全地更改挂载点的父挂载和挂载点位置，同时管理相关引用计数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在修改挂载点时未能正确处理挂载点引用计数器的竞态条件，导致本地用户可能通过竞争操作使引用计数器损坏，从而引发拒绝服务。\"\"\"",
        "functions": "Functions:\n1. 函数名: mnt_change_mountpoint\n- 参数: [struct mount *parent, struct mountpoint *mp, struct mount *mnt]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [list_del_init, hlist_del_init, hlist_del_init_rcu, attach_mnt, put_mountpoint, spin_lock, spin_unlock, mnt_add_count]\n\n2. 函数名: list_del_init\n- 参数: [&mnt->mnt_child]\n- 调用者: mnt_change_mountpoint\n- 被调用者: []\n\n3. 函数名: hlist_del_init\n- 参数: [&mnt->mnt_mp_list]\n- 调用者: mnt_change_mountpoint\n- 被调用者: []\n\n4. 函数名: hlist_del_init_rcu\n- 参数: [&mnt->mnt_hash]\n- 调用者: mnt_change_mountpoint\n- 被调用者: []\n\n5. 函数名: attach_mnt\n- 参数: [mnt, parent, mp]\n- 调用者: mnt_change_mountpoint\n- 被调用者: []\n\n6. 函数名: put_mountpoint\n- 参数: [old_mp]\n- 调用者: mnt_change_mountpoint\n- 被调用者: []\n\n7. 函数名: spin_lock\n- 参数: [&old_mountpoint->d_lock]\n- 调用者: mnt_change_mountpoint\n- 被调用者: []\n\n8. 函数名: spin_unlock\n- 参数: [&old_mountpoint->d_lock]\n- 调用者: mnt_change_mountpoint\n- 被调用者: []\n\n9. 函数名: mnt_add_count\n- 参数: [old_parent, -1]\n- 调用者: mnt_change_mountpoint\n- 被调用者: []"
    },
    {
        "id": 2472,
        "cwe": "CWE-362",
        "cve": "CVE-2020-12652",
        "purpose": "Code purpose:\"\"\"该代码实现了兼容模式下MPT控制命令的ioctl操作处理，包括参数验证、适配器锁定和命令执行等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ioctl操作期间持有不正确的锁导致竞态条件，即存在'双重获取'漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: compat_mpt_command\n- 参数: [struct file *filp, unsigned int cmd, unsigned long arg]\n- 调用者: 未明确（可能是系统调用或上层IOCTL处理函数）\n- 被调用者: [copy_from_user, mpt_verify_adapter, mptctl_syscall_down, printk, dctlprintk, mptctl_do_mpt_command, mutex_unlock]\n\n2. 函数名: copy_from_user\n- 参数: [&karg32, (char __user *)arg, sizeof(karg32)]\n- 调用者: compat_mpt_command\n- 被调用者: []\n\n3. 函数名: mpt_verify_adapter\n- 参数: [iocnumX, &iocp]\n- 调用者: compat_mpt_command\n- 被调用者: []\n\n4. 函数名: mptctl_syscall_down\n- 参数: [iocp, nonblock]\n- 调用者: compat_mpt_command\n- 被调用者: []\n\n5. 函数名: printk\n- 参数: [KERN_DEBUG MYNAM \"::compat_mpt_command @%d - ioc%d not found!\\n\", __LINE__, iocnumX]\n- 调用者: compat_mpt_command\n- 被调用者: []\n\n6. 函数名: dctlprintk\n- 参数: [iocp, printk(MYIOC_s_DEBUG_FMT \"compat_mpt_command() called\\n\", iocp->name)]\n- 调用者: compat_mpt_command\n- 被调用者: [printk]\n\n7. 函数名: mptctl_do_mpt_command\n- 参数: [karg, &uarg->MF]\n- 调用者: compat_mpt_command\n- 被调用者: []\n\n8. 函数名: mutex_unlock\n- 参数: [&iocp->ioctl_cmds.mutex]\n- 调用者: compat_mpt_command\n- 被调用者: []"
    },
    {
        "id": 2473,
        "cwe": "CWE-362",
        "cve": "CVE-2020-12652",
        "purpose": "Code purpose:\"\"\"处理来自用户空间的ioctl请求，执行与MPT适配器相关的各种控制操作，包括信息查询、事件处理和固件管理等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ioctl操作期间持有错误的锁导致竞态条件，造成双重获取漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: __mptctl_ioctl\n- 参数: [struct file *file, unsigned int cmd, unsigned long arg]\n- 调用者: 未显示（应为内核ioctl调用）\n- 被调用者: [copy_from_user, mpt_verify_adapter, mptctl_getiocinfo, mptctl_gettargetinfo, mptctl_readtest, mptctl_eventquery, mptctl_eventenable, mptctl_eventreport, mptctl_replace_fw, mptctl_syscall_down, mptctl_fw_download, mptctl_mpt_command, mptctl_do_reset, mptctl_hp_hostinfo, mptctl_hp_targetinfo, mutex_unlock]\n\n2. 函数名: copy_from_user\n- 参数: [&khdr, uhdr, sizeof(khdr)]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n3. 函数名: mpt_verify_adapter\n- 参数: [iocnumX, &iocp]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n4. 函数名: mptctl_getiocinfo\n- 参数: [arg, _IOC_SIZE(cmd)]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n5. 函数名: mptctl_gettargetinfo\n- 参数: [arg]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n6. 函数名: mptctl_readtest\n- 参数: [arg]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n7. 函数名: mptctl_eventquery\n- 参数: [arg]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n8. 函数名: mptctl_eventenable\n- 参数: [arg]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n9. 函数名: mptctl_eventreport\n- 参数: [arg]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n10. 函数名: mptctl_replace_fw\n- 参数: [arg]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n11. 函数名: mptctl_syscall_down\n- 参数: [iocp, nonblock]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n12. 函数名: mptctl_fw_download\n- 参数: [arg]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n13. 函数名: mptctl_mpt_command\n- 参数: [arg]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n14. 函数名: mptctl_do_reset\n- 参数: [arg]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n15. 函数名: mptctl_hp_hostinfo\n- 参数: [arg, _IOC_SIZE(cmd)]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n16. 函数名: mptctl_hp_targetinfo\n- 参数: [arg]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无\n\n17. 函数名: mutex_unlock\n- 参数: [&iocp->ioctl_cmds.mutex]\n- 调用者: __mptctl_ioctl\n- 被调用者: 无"
    },
    {
        "id": 2474,
        "cwe": "CWE-362",
        "cve": "CVE-2020-12652",
        "purpose": "Code purpose:\"\"\"处理兼容模式下MPT控制器固件下载的ioctl请求，包括验证适配器、获取用户空间数据并执行固件下载操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ioctl操作期间持有不正确的锁导致竞态条件，造成'双重获取'漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: compat_mptfwxfer_ioctl\n- 参数: [struct file *filp, unsigned int cmd, unsigned long arg]\n- 调用者: 未显示（由系统调用触发）\n- 被调用者: [copy_from_user, mpt_verify_adapter, mptctl_syscall_down, dctlprintk, compat_ptr, mptctl_do_fw_download, mutex_unlock]\n\n2. 函数名: copy_from_user\n- 参数: [&kfw32, (char __user *)arg, sizeof(kfw32)]\n- 调用者: compat_mptfwxfer_ioctl\n- 被调用者: []\n\n3. 函数名: mpt_verify_adapter\n- 参数: [iocnumX, &iocp]\n- 调用者: compat_mptfwxfer_ioctl\n- 被调用者: []\n\n4. 函数名: mptctl_syscall_down\n- 参数: [iocp, nonblock]\n- 调用者: compat_mptfwxfer_ioctl\n- 被调用者: []\n\n5. 函数名: dctlprintk\n- 参数: [iocp, printk(MYIOC_s_DEBUG_FMT \"compat_mptfwxfer_ioctl() called\", iocp->name)]\n- 调用者: compat_mptfwxfer_ioctl\n- 被调用者: [printk]\n\n6. 函数名: printk\n- 参数: [MYIOC_s_DEBUG_FMT \"compat_mptfwxfer_ioctl() called\", iocp->name]\n- 调用者: dctlprintk\n- 被调用者: []\n\n7. 函数名: compat_ptr\n- 参数: [kfw32.bufp]\n- 调用者: compat_mptfwxfer_ioctl\n- 被调用者: []\n\n8. 函数名: mptctl_do_fw_download\n- 参数: [kfw.iocnum, kfw.bufp, kfw.fwlen]\n- 调用者: compat_mptfwxfer_ioctl\n- 被调用者: []\n\n9. 函数名: mutex_unlock\n- 参数: [&iocp->ioctl_cmds.mutex]\n- 调用者: compat_mptfwxfer_ioctl\n- 被调用者: []"
    },
    {
        "id": 2540,
        "cwe": "CWE-362",
        "cve": "CVE-2020-14416",
        "purpose": "Code purpose:\"\"\"该代码片段实现了slcan线路规程的关闭功能，包括断开tty连接、清理网络设备注册等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在slcan_close函数中存在竞态条件，当处理tty->disc_data时未充分保护，可能导致在释放资源后仍被访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: slcan_close\n- 参数: [struct tty_struct *tty]\n- 调用者: 未明确显示（通常由TTY子系统调用）\n- 被调用者: [spin_lock_bh, spin_unlock_bh, flush_work, unregister_netdev]\n\n2. 函数名: spin_lock_bh\n- 参数: [&sl->lock]\n- 调用者: slcan_close\n- 被调用者: []\n\n3. 函数名: spin_unlock_bh\n- 参数: [&sl->lock]\n- 调用者: slcan_close\n- 被调用者: []\n\n4. 函数名: flush_work\n- 参数: [&sl->tx_work]\n- 调用者: slcan_close\n- 被调用者: []\n\n5. 函数名: unregister_netdev\n- 参数: [sl->dev]\n- 调用者: slcan_close\n- 被调用者: []"
    },
    {
        "id": 2541,
        "cwe": "CWE-362",
        "cve": "CVE-2020-14416",
        "purpose": "Code purpose:\"\"\"在Linux内核中调度slcan设备的传输工作队列任务\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在slcan_write_wakeup函数中未对tty->disc_data进行同步保护，导致竞态条件下可能发生use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: slcan_write_wakeup\n- 参数: [struct tty_struct *tty]\n- 调用者: 未明确（通常由TTY子系统调用）\n- 被调用者: [schedule_work]\n\n2. 函数名: schedule_work\n- 参数: [&sl->tx_work]\n- 调用者: slcan_write_wakeup\n- 被调用者: 未明确（内核工作队列机制）"
    },
    {
        "id": 2586,
        "cwe": "CWE-362",
        "cve": "CVE-2020-25285",
        "purpose": "Code purpose:\"\"\"该代码用于处理hugetlb（大页内存）的超量提交设置，通过proc文件系统接口允许读取或修改超量提交的大页数量\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在hugetlb_overcommit_handler函数中处理sysctl操作时存在竞态条件，多个处理器同时访问和修改h->nr_overcommit_huge_pages变量时缺乏足够的同步保护，导致内存损坏或空指针解引用等问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: hugetlb_overcommit_handler\n- 参数: [struct ctl_table *table, int write, void *buffer, size_t *length, loff_t *ppos]\n- 调用者: 未明确显示（通常由内核sysctl处理机制调用）\n- 被调用者: [hugepages_supported, hstate_is_gigantic, proc_doulongvec_minmax]\n\n2. 函数名: hugepages_supported\n- 参数: []\n- 调用者: hugetlb_overcommit_handler\n- 被调用者: []\n\n3. 函数名: hstate_is_gigantic\n- 参数: [struct hstate *h]\n- 调用者: hugetlb_overcommit_handler\n- 被调用者: []\n\n4. 函数名: proc_doulongvec_minmax\n- 参数: [struct ctl_table *table, int write, void *buffer, size_t *length, loff_t *ppos]\n- 调用者: hugetlb_overcommit_handler\n- 被调用者: []"
    },
    {
        "id": 2587,
        "cwe": "CWE-362",
        "cve": "CVE-2020-25285",
        "purpose": "Code purpose:\"\"\"该代码用于处理hugetlb系统控制参数的读写操作，包括设置最大大页数量并确保操作符合内存策略。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于hugetlb_sysctl_handler_common函数在处理sysctl操作时存在竞态条件，多个处理器同时访问和修改共享数据(tmp变量)导致内存损坏或空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: hugetlb_sysctl_handler_common\n- 参数: [obey_mempolicy, table, write, buffer, length, ppos]\n- 调用者: 未明确（应为内核sysctl处理框架）\n- 被调用者: [hugepages_supported, proc_doulongvec_minmax, __nr_hugepages_store_common]\n\n2. 函数名: hugepages_supported\n- 参数: []\n- 调用者: hugetlb_sysctl_handler_common\n- 被调用者: []\n\n3. 函数名: proc_doulongvec_minmax\n- 参数: [table, write, buffer, length, ppos]\n- 调用者: hugetlb_sysctl_handler_common\n- 被调用者: []\n\n4. 函数名: __nr_hugepages_store_common\n- 参数: [obey_mempolicy, h, NUMA_NO_NODE, tmp, *length]\n- 调用者: hugetlb_sysctl_handler_common\n- 被调用者: []"
    },
    {
        "id": 2611,
        "cwe": "CWE-362",
        "cve": "CVE-2020-27067",
        "purpose": "Code purpose:\"\"\"该代码片段用于在L2TP以太网设备取消初始化时，从网络设备列表中删除私有数据并释放设备引用。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在l2tp_eth_dev_uninit函数中存在竞态条件，导致在释放设备资源后可能仍被访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: l2tp_eth_dev_uninit\n- 参数: [struct net_device *dev]\n- 调用者: 未显示（由系统调用）\n- 被调用者: [netdev_priv, l2tp_eth_pernet, dev_net, spin_lock, list_del_init, spin_unlock, dev_put]\n\n2. 函数名: netdev_priv\n- 参数: [struct net_device *dev]\n- 调用者: l2tp_eth_dev_uninit\n- 被调用者: 未显示\n\n3. 函数名: l2tp_eth_pernet\n- 参数: [struct net *net]\n- 调用者: l2tp_eth_dev_uninit\n- 被调用者: 未显示\n\n4. 函数名: dev_net\n- 参数: [struct net_device *dev]\n- 调用者: l2tp_eth_dev_uninit\n- 被调用者: 未显示\n\n5. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: l2tp_eth_dev_uninit\n- 被调用者: 未显示\n\n6. 函数名: list_del_init\n- 参数: [struct list_head *entry]\n- 调用者: l2tp_eth_dev_uninit\n- 被调用者: 未显示\n\n7. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: l2tp_eth_dev_uninit\n- 被调用者: 未显示\n\n8. 函数名: dev_put\n- 参数: [struct net_device *dev]\n- 调用者: l2tp_eth_dev_uninit\n- 被调用者: 未显示"
    },
    {
        "id": 2612,
        "cwe": "CWE-362",
        "cve": "CVE-2020-27067",
        "purpose": "Code purpose:\"\"\"创建一个L2TP以太网会话并初始化相关网络设备\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于l2tp_eth_create函数中存在竞态条件，可能导致会话资源在使用后被释放，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: l2tp_eth_create\n- 参数: [struct net *net, struct l2tp_tunnel *tunnel, u32 session_id, u32 peer_session_id, struct l2tp_session_cfg *cfg]\n- 调用者: 未显示\n- 被调用者: [strlcpy, strcpy, l2tp_session_create, alloc_netdev, dev_net_set, l2tp_eth_adjust_mtu, netdev_priv, INIT_LIST_HEAD, l2tp_session_priv, register_netdev, __module_get, dev_hold, l2tp_eth_pernet, spin_lock, list_add, spin_unlock, free_netdev, l2tp_session_delete]\n\n2. 函数名: l2tp_session_create\n- 参数: [size_t priv_size, struct l2tp_tunnel *tunnel, u32 session_id, u32 peer_session_id, struct l2tp_session_cfg *cfg]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n3. 函数名: alloc_netdev\n- 参数: [int sizeof_priv, const char *name, unsigned char name_assign_type, void (*setup)(struct net_device *)]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n4. 函数名: dev_net_set\n- 参数: [struct net_device *dev, struct net *net]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n5. 函数名: l2tp_eth_adjust_mtu\n- 参数: [struct l2tp_tunnel *tunnel, struct l2tp_session *session, struct net_device *dev]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n6. 函数名: netdev_priv\n- 参数: [const struct net_device *dev]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n7. 函数名: INIT_LIST_HEAD\n- 参数: [struct list_head *list]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n8. 函数名: l2tp_session_priv\n- 参数: [struct l2tp_session *session]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n9. 函数名: register_netdev\n- 参数: [struct net_device *dev]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n10. 函数名: __module_get\n- 参数: [struct module *module]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n11. 函数名: dev_hold\n- 参数: [struct net_device *dev]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n12. 函数名: l2tp_eth_pernet\n- 参数: [struct net *net]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n13. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n14. 函数名: list_add\n- 参数: [struct list_head *new, struct list_head *head]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n15. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n16. 函数名: free_netdev\n- 参数: [struct net_device *dev]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n17. 函数名: l2tp_session_delete\n- 参数: [struct l2tp_session *session]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示"
    },
    {
        "id": 2613,
        "cwe": "CWE-362",
        "cve": "CVE-2020-27067",
        "purpose": "Code purpose:\"\"\"初始化L2TP以太网伪线支持，注册网络操作和网络命名空间设备\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于l2tp子系统中存在竞争条件，导致在注销操作后仍可能被使用，从而引发释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: l2tp_eth_init\n- 参数: [void]\n- 调用者: __init\n- 被调用者: [l2tp_nl_register_ops, register_pernet_device, l2tp_nl_unregister_ops]\n\n2. 函数名: l2tp_nl_register_ops\n- 参数: [L2TP_PWTYPE_ETH, &l2tp_eth_nl_cmd_ops]\n- 调用者: l2tp_eth_init\n- 被调用者: []\n\n3. 函数名: register_pernet_device\n- 参数: [&l2tp_eth_net_ops]\n- 调用者: l2tp_eth_init\n- 被调用者: []\n\n4. 函数名: l2tp_nl_unregister_ops\n- 参数: [L2TP_PWTYPE_ETH]\n- 调用者: l2tp_eth_init\n- 被调用者: []"
    },
    {
        "id": 2614,
        "cwe": "CWE-362",
        "cve": "CVE-2020-27067",
        "purpose": "Code purpose:\"\"\"注销L2TP以太网模块时，卸载网络命名空间操作并取消注册L2TP网络层操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于l2tp子系统中存在竞态条件导致的使用后释放问题\"\"\"",
        "functions": "Functions:\n1. 函数名: l2tp_eth_exit\n- 参数: [void]\n- 调用者: __exit\n- 被调用者: [unregister_pernet_device, l2tp_nl_unregister_ops]\n\n2. 函数名: unregister_pernet_device\n- 参数: [&l2tp_eth_net_ops]\n- 调用者: l2tp_eth_exit\n- 被调用者: []\n\n3. 函数名: l2tp_nl_unregister_ops\n- 参数: [L2TP_PWTYPE_ETH]\n- 调用者: l2tp_eth_exit\n- 被调用者: []"
    },
    {
        "id": 2621,
        "cwe": "CWE-362",
        "cve": "CVE-2020-27675",
        "purpose": "Code purpose:\"\"\"该代码用于根据事件通道号(evtchn)获取对应的中断号(irq)，并进行边界和空指针检查\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环中存在竞态条件，允许在事件处理期间移除事件通道，导致可能发生释放后使用或空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: get_evtchn_to_irq\n- 参数: [evtchn_port_t evtchn]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [xen_evtchn_max_channels]\n\n2. 函数名: xen_evtchn_max_channels\n- 参数: []\n- 调用者: [get_evtchn_to_irq]\n- 被调用者: 未明确"
    },
    {
        "id": 2622,
        "cwe": "CWE-362",
        "cve": "CVE-2020-27675",
        "purpose": "Code purpose:\"\"\"清除事件通道到中断号映射表中指定行的所有列的值\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环中存在竞态条件，允许在事件处理过程中移除事件通道，导致可能发生释放后使用或空指针解引用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: clear_evtchn_to_irq_row\n- 参数: [row]\n- 调用者: 未提供（代码片段中未显示）\n- 被调用者: []"
    },
    {
        "id": 2623,
        "cwe": "CWE-362",
        "cve": "CVE-2020-27675",
        "purpose": "Code purpose:\"\"\"该代码用于在Xen虚拟化环境中释放中断请求(IRQ)资源，包括从链表中删除中断信息、释放内存以及处理传统中断描述符。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环中存在竞态条件，允许在事件处理过程中删除事件通道，导致可能发生释放后使用或空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: xen_free_irq\n- 参数: [unsigned irq]\n- 调用者: 未显示\n- 被调用者: [info_for_irq, WARN_ON, list_del, set_info_for_irq, kfree, nr_legacy_irqs, irq_free_desc]\n\n2. 函数名: info_for_irq\n- 参数: [unsigned irq]\n- 调用者: xen_free_irq\n- 被调用者: 未显示\n\n3. 函数名: WARN_ON\n- 参数: [condition]\n- 调用者: xen_free_irq\n- 被调用者: 未显示\n\n4. 函数名: list_del\n- 参数: [struct list_head *entry]\n- 调用者: xen_free_irq\n- 被调用者: 未显示\n\n5. 函数名: set_info_for_irq\n- 参数: [unsigned irq, struct irq_info *info]\n- 调用者: xen_free_irq\n- 被调用者: 未显示\n\n6. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: xen_free_irq\n- 被调用者: 未显示\n\n7. 函数名: nr_legacy_irqs\n- 参数: []\n- 调用者: xen_free_irq\n- 被调用者: 未显示\n\n8. 函数名: irq_free_desc\n- 参数: [unsigned int irq]\n- 调用者: xen_free_irq\n- 被调用者: 未显示"
    },
    {
        "id": 2624,
        "cwe": "CWE-362",
        "cve": "CVE-2020-27675",
        "purpose": "Code purpose:\"\"\"将Xen事件通道(evtchn)映射到对应的中断号(irq)\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环中存在竞态条件，允许在事件处理过程中删除事件通道，导致可能发生释放后使用或空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: set_evtchn_to_irq\n- 参数: [evtchn_port_t evtchn, unsigned int irq]\n- 调用者: 未提供\n- 被调用者: [xen_evtchn_max_channels, EVTCHN_ROW, EVTCHN_COL, get_zeroed_page, clear_evtchn_to_irq_row]\n\n2. 函数名: xen_evtchn_max_channels\n- 参数: []\n- 调用者: set_evtchn_to_irq\n- 被调用者: 未提供\n\n3. 函数名: EVTCHN_ROW\n- 参数: [evtchn_port_t evtchn]\n- 调用者: set_evtchn_to_irq\n- 被调用者: 未提供\n\n4. 函数名: EVTCHN_COL\n- 参数: [evtchn_port_t evtchn]\n- 调用者: set_evtchn_to_irq\n- 被调用者: 未提供\n\n5. 函数名: get_zeroed_page\n- 参数: [GFP_KERNEL]\n- 调用者: set_evtchn_to_irq\n- 被调用者: 未提供\n\n6. 函数名: clear_evtchn_to_irq_row\n- 参数: [unsigned row]\n- 调用者: set_evtchn_to_irq\n- 被调用者: 未提供"
    },
    {
        "id": 2625,
        "cwe": "CWE-362",
        "cve": "CVE-2020-27675",
        "purpose": "Code purpose:\"\"\"处理Xen事件通道的上调调用，循环检查并处理挂起的事件\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环中允许移除事件通道，导致竞态条件可能引发释放后使用或空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: __xen_evtchn_do_upcall\n- 参数: []\n- 调用者: N/A\n- 被调用者: [__this_cpu_read, smp_processor_id, xen_evtchn_handle_events, BUG_ON, virt_rmb]\n\n2. 函数名: __this_cpu_read\n- 参数: [xen_vcpu]\n- 调用者: __xen_evtchn_do_upcall\n- 被调用者: []\n\n3. 函数名: smp_processor_id\n- 参数: []\n- 调用者: __xen_evtchn_do_upcall\n- 被调用者: []\n\n4. 函数名: xen_evtchn_handle_events\n- 参数: [cpu]\n- 调用者: __xen_evtchn_do_upcall\n- 被调用者: []\n\n5. 函数名: BUG_ON\n- 参数: [!irqs_disabled()]\n- 调用者: __xen_evtchn_do_upcall\n- 被调用者: []\n\n6. 函数名: virt_rmb\n- 参数: []\n- 调用者: __xen_evtchn_do_upcall\n- 被调用者: []"
    },
    {
        "id": 2626,
        "cwe": "CWE-362",
        "cve": "CVE-2020-27675",
        "purpose": "Code purpose:\"\"\"该代码用于根据给定的IRQ号获取对应的事件通道(evtchn)，并进行有效性检查\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环中存在竞态条件，允许在事件处理过程中移除事件通道，导致可能发生释放后使用或空指针解引用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: evtchn_from_irq\n- 参数: [unsigned irq]\n- 调用者: 未在代码片段中显示\n- 被调用者: [WARN, info_for_irq]\n\n2. 函数名: WARN\n- 参数: [irq >= nr_irqs, \"Invalid irq %d!\\n\", irq]\n- 调用者: evtchn_from_irq\n- 被调用者: 未在代码片段中显示\n\n3. 函数名: info_for_irq\n- 参数: [irq]\n- 调用者: evtchn_from_irq\n- 被调用者: 未在代码片段中显示"
    },
    {
        "id": 2637,
        "cwe": "CWE-362",
        "cve": "CVE-2020-27825",
        "purpose": "Code purpose:\"\"\"在多CPU环境下安全重置指定CPU的环形缓冲区，防止并行操作导致的数据竞争问题\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在多CPU并行环境下，trace_open和cpu缓冲区resize操作存在竞争条件，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ring_buffer_reset_cpu\n- 参数: [struct trace_buffer *buffer, int cpu]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [cpumask_test_cpu, atomic_inc, synchronize_rcu, reset_disabled_cpu_buffer, atomic_dec]\n\n2. 函数名: cpumask_test_cpu\n- 参数: [int cpu, buffer->cpumask]\n- 调用者: ring_buffer_reset_cpu\n- 被调用者: []\n\n3. 函数名: atomic_inc\n- 参数: [&cpu_buffer->resize_disabled, &cpu_buffer->record_disabled]\n- 调用者: ring_buffer_reset_cpu\n- 被调用者: []\n\n4. 函数名: synchronize_rcu\n- 参数: []\n- 调用者: ring_buffer_reset_cpu\n- 被调用者: []\n\n5. 函数名: reset_disabled_cpu_buffer\n- 参数: [struct ring_buffer_per_cpu *cpu_buffer]\n- 调用者: ring_buffer_reset_cpu\n- 被调用者: []\n\n6. 函数名: atomic_dec\n- 参数: [&cpu_buffer->record_disabled, &cpu_buffer->resize_disabled]\n- 调用者: ring_buffer_reset_cpu\n- 被调用者: []"
    },
    {
        "id": 2638,
        "cwe": "CWE-362",
        "cve": "CVE-2020-27825",
        "purpose": "Code purpose:\"\"\"该代码用于重置在线CPU的环形缓冲区，通过禁用记录和调整大小操作来确保缓冲区重置的安全性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在多CPU并行环境下，trace_open和缓冲区resize操作之间存在竞争条件，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ring_buffer_reset_online_cpus\n- 参数: [struct trace_buffer *buffer]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [for_each_online_buffer_cpu, atomic_inc, synchronize_rcu, reset_disabled_cpu_buffer, atomic_dec]\n\n2. 函数名: for_each_online_buffer_cpu\n- 参数: [struct trace_buffer *buffer, int cpu]\n- 调用者: ring_buffer_reset_online_cpus\n- 被调用者: 未明确（可能是宏或内联函数）\n\n3. 函数名: atomic_inc\n- 参数: [atomic_t *v]（根据上下文推断）\n- 调用者: ring_buffer_reset_online_cpus\n- 被调用者: 未明确（原子操作函数）\n\n4. 函数名: synchronize_rcu\n- 参数: []\n- 调用者: ring_buffer_reset_online_cpus\n- 被调用者: 未明确（RCU同步函数）\n\n5. 函数名: reset_disabled_cpu_buffer\n- 参数: [struct ring_buffer_per_cpu *cpu_buffer]\n- 调用者: ring_buffer_reset_online_cpus\n- 被调用者: 未明确（上下文未提供）\n\n6. 函数名: atomic_dec\n- 参数: [atomic_t *v]（根据上下文推断）\n- 调用者: ring_buffer_reset_online_cpus\n- 被调用者: 未明确（原子操作函数）"
    },
    {
        "id": 2662,
        "cwe": "CWE-362",
        "cve": "CVE-2020-29368",
        "purpose": "Code purpose:\"\"\"该代码用于处理大页(THP)的分裂操作，确保在分裂过程中正确处理内存映射通知和锁机制，但存在竞态条件可能导致意外的写权限授予问题。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于THP mapcount检查中存在竞态条件，导致写时复制实现可能授予非预期的写访问权限\"\"\"",
        "functions": "Functions:\n1. 函数名: __split_huge_pmd\n- 参数: [vma, pmd, address, freeze, page]\n- 调用者: 未显示\n- 被调用者: [mmu_notifier_range_init, mmu_notifier_invalidate_range_start, pmd_lock, pmd_page, pmd_trans_huge, PageMlocked, clear_page_mlock, pmd_devmap, is_pmd_migration_entry, __split_huge_pmd_locked, spin_unlock, mmu_notifier_invalidate_range_only_end]\n\n2. 函数名: mmu_notifier_range_init\n- 参数: [range, MMU_NOTIFY_CLEAR, 0, vma, vma->vm_mm, address & HPAGE_PMD_MASK, (address & HPAGE_PMD_MASK) + HPAGE_PMD_SIZE]\n- 调用者: __split_huge_pmd\n- 被调用者: 无\n\n3. 函数名: mmu_notifier_invalidate_range_start\n- 参数: [range]\n- 调用者: __split_huge_pmd\n- 被调用者: 无\n\n4. 函数名: pmd_lock\n- 参数: [vma->vm_mm, pmd]\n- 调用者: __split_huge_pmd\n- 被调用者: 无\n\n5. 函数名: pmd_page\n- 参数: [*pmd]\n- 调用者: __split_huge_pmd\n- 被调用者: 无\n\n6. 函数名: pmd_trans_huge\n- 参数: [*pmd]\n- 调用者: __split_huge_pmd\n- 被调用者: 无\n\n7. 函数名: PageMlocked\n- 参数: [page]\n- 调用者: __split_huge_pmd\n- 被调用者: 无\n\n8. 函数名: clear_page_mlock\n- 参数: [page]\n- 调用者: __split_huge_pmd\n- 被调用者: 无\n\n9. 函数名: pmd_devmap\n- 参数: [*pmd]\n- 调用者: __split_huge_pmd\n- 被调用者: 无\n\n10. 函数名: is_pmd_migration_entry\n- 参数: [*pmd]\n- 调用者: __split_huge_pmd\n- 被调用者: 无\n\n11. 函数名: __split_huge_pmd_locked\n- 参数: [vma, pmd, range.start, freeze]\n- 调用者: __split_huge_pmd\n- 被调用者: 无\n\n12. 函数名: spin_unlock\n- 参数: [ptl]\n- 调用者: __split_huge_pmd\n- 被调用者: 无\n\n13. 函数名: mmu_notifier_invalidate_range_only_end\n- 参数: [range]\n- 调用者: __split_huge_pmd\n- 被调用者: 无"
    },
    {
        "id": 2663,
        "cwe": "CWE-362",
        "cve": "CVE-2020-29369",
        "purpose": "Code purpose:\"\"\"该代码用于在内存映射解除时，安全地分离并更新虚拟内存区域(VMA)结构，确保内存管理的正确性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中mm/mmap.c存在竞争条件，特定扩展函数(expand_downwards和expand_upwards)与munmap调用的页表释放操作之间未正确同步\"\"\"",
        "functions": "Functions:\n1. 函数名: detach_vmas_to_be_unmapped\n- 参数: [struct mm_struct *mm, struct vm_area_struct *vma, struct vm_area_struct *prev, unsigned long end]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [vma_rb_erase, vma_gap_update, vmacache_invalidate, vm_end_gap]\n\n2. 函数名: vma_rb_erase\n- 参数: [struct vm_area_struct *vma, &mm->mm_rb]\n- 调用者: detach_vmas_to_be_unmapped\n- 被调用者: 未显示\n\n3. 函数名: vma_gap_update\n- 参数: [struct vm_area_struct *vma]\n- 调用者: detach_vmas_to_be_unmapped\n- 被调用者: 未显示\n\n4. 函数名: vmacache_invalidate\n- 参数: [struct mm_struct *mm]\n- 调用者: detach_vmas_to_be_unmapped\n- 被调用者: 未显示\n\n5. 函数名: vm_end_gap\n- 参数: [struct vm_area_struct *prev]\n- 调用者: detach_vmas_to_be_unmapped\n- 被调用者: 未显示"
    },
    {
        "id": 2664,
        "cwe": "CWE-362",
        "cve": "CVE-2020-29369",
        "purpose": "Code purpose:\"\"\"该代码用于实现Linux内核中内存映射区域的解除映射(munmap)功能，处理虚拟内存区域的拆分、解锁和释放操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核中，expand_downwards和expand_upwards函数与munmap调用中的页表释放操作之间存在竞争条件，导致内存管理异常。\"\"\"",
        "functions": "Functions:\n1. 函数名: __do_munmap\n- 参数: [struct mm_struct *mm, unsigned long start, size_t len, struct list_head *uf, bool downgrade]\n- 调用者: 未明确（通常是系统调用munmap或其他内存管理函数）\n- 被调用者: [find_vma, __split_vma, userfaultfd_unmap_prep, munlock_vma_pages_all, detach_vmas_to_be_unmapped, mmap_write_downgrade, unmap_region, remove_vma_list]\n\n2. 函数名: find_vma\n- 参数: [struct mm_struct *mm, unsigned long addr]\n- 调用者: __do_munmap\n- 被调用者: []\n\n3. 函数名: __split_vma\n- 参数: [struct mm_struct *mm, struct vm_area_struct *vma, unsigned long addr, int new_below]\n- 调用者: __do_munmap\n- 被调用者: []\n\n4. 函数名: userfaultfd_unmap_prep\n- 参数: [struct vm_area_struct *vma, unsigned long start, unsigned long end, struct list_head *uf]\n- 调用者: __do_munmap\n- 被调用者: []\n\n5. 函数名: munlock_vma_pages_all\n- 参数: [struct vm_area_struct *vma]\n- 调用者: __do_munmap\n- 被调用者: []\n\n6. 函数名: detach_vmas_to_be_unmapped\n- 参数: [struct mm_struct *mm, struct vm_area_struct *vma, struct vm_area_struct *prev, unsigned long end]\n- 调用者: __do_munmap\n- 被调用者: []\n\n7. 函数名: mmap_write_downgrade\n- 参数: [struct mm_struct *mm]\n- 调用者: __do_munmap\n- 被调用者: []\n\n8. 函数名: unmap_region\n- 参数: [struct mm_struct *mm, struct vm_area_struct *vma, struct vm_area_struct *prev, unsigned long start, unsigned long end]\n- 调用者: __do_munmap\n- 被调用者: []\n\n9. 函数名: remove_vma_list\n- 参数: [struct mm_struct *mm, struct vm_area_struct *vma]\n- 调用者: __do_munmap\n- 被调用者: []\n\n10. 函数名: arch_unmap\n- 参数: [struct mm_struct *mm, unsigned long start, unsigned long end]\n- 调用者: __do_munmap\n- 被调用者: []"
    },
    {
        "id": 2665,
        "cwe": "CWE-362",
        "cve": "CVE-2020-29370",
        "purpose": "Code purpose:\"\"\"该代码用于从指定的内存缓存中批量分配对象，处理快速路径和慢速路径的内存分配，并确保在多核环境下的线程安全\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在慢路径处理中未正确增加事务ID(TID)，导致并发操作时可能出现竞争条件\"\"\"",
        "functions": "Functions:\n1. 函数名: kmem_cache_alloc_bulk\n- 参数: [struct kmem_cache *s, gfp_t flags, size_t size, void **p]\n- 调用者: N/A\n- 被调用者: [slab_pre_alloc_hook, local_irq_disable, this_cpu_ptr, ___slab_alloc, get_freepointer, maybe_wipe_obj_freeptr, next_tid, local_irq_enable, slab_want_init_on_alloc, memset, slab_post_alloc_hook, __kmem_cache_free_bulk]\n\n2. 函数名: slab_pre_alloc_hook\n- 参数: [struct kmem_cache *s, gfp_t flags]\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A\n\n3. 函数名: local_irq_disable\n- 参数: []\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A\n\n4. 函数名: this_cpu_ptr\n- 参数: [s->cpu_slab]\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A\n\n5. 函数名: ___slab_alloc\n- 参数: [s, flags, NUMA_NO_NODE, _RET_IP_, c]\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A\n\n6. 函数名: get_freepointer\n- 参数: [s, object]\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A\n\n7. 函数名: maybe_wipe_obj_freeptr\n- 参数: [s, p[i]]\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A\n\n8. 函数名: next_tid\n- 参数: [c->tid]\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A\n\n9. 函数名: local_irq_enable\n- 参数: []\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A\n\n10. 函数名: slab_want_init_on_alloc\n- 参数: [flags, s]\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A\n\n11. 函数名: memset\n- 参数: [p[j], 0, s->object_size]\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A\n\n12. 函数名: slab_post_alloc_hook\n- 参数: [s, flags, size, p]\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A\n\n13. 函数名: __kmem_cache_free_bulk\n- 参数: [s, i, p]\n- 调用者: kmem_cache_alloc_bulk\n- 被调用者: N/A"
    },
    {
        "id": 2667,
        "cwe": "CWE-362",
        "cve": "CVE-2020-29372",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中的madvise系统调用功能，用于向内核提供内存使用建议，优化内存管理行为。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中do_madvise函数存在竞争条件，当与coredump操作同时进行IORING_OP_MADVISE操作时，由于缺乏适当的同步机制导致漏洞产生。\"\"\"",
        "functions": "Functions:\n1. 函数名: do_madvise\n- 参数: [unsigned long start, size_t len_in, int behavior]\n- 调用者: N/A (系统调用或内核其他部分)\n- 被调用者: [madvise_behavior_valid, madvise_inject_error, madvise_need_mmap_write, down_write_killable, down_read, find_vma_prev, blk_start_plug, madvise_vma, find_vma, blk_finish_plug, up_write, up_read]\n\n2. 函数名: madvise_behavior_valid\n- 参数: [int behavior]\n- 调用者: do_madvise\n- 被调用者: []\n\n3. 函数名: madvise_inject_error\n- 参数: [int behavior, unsigned long start, unsigned long end]\n- 调用者: do_madvise\n- 被调用者: []\n\n4. 函数名: madvise_need_mmap_write\n- 参数: [int behavior]\n- 调用者: do_madvise\n- 被调用者: []\n\n5. 函数名: down_write_killable\n- 参数: [struct rw_semaphore *sem]\n- 调用者: do_madvise\n- 被调用者: []\n\n6. 函数名: down_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: do_madvise\n- 被调用者: []\n\n7. 函数名: find_vma_prev\n- 参数: [struct mm_struct *mm, unsigned long addr, struct vm_area_struct **pprev]\n- 调用者: do_madvise\n- 被调用者: []\n\n8. 函数名: blk_start_plug\n- 参数: [struct blk_plug *plug]\n- 调用者: do_madvise\n- 被调用者: []\n\n9. 函数名: madvise_vma\n- 参数: [struct vm_area_struct *vma, struct vm_area_struct **prev, unsigned long start, unsigned long end, int behavior]\n- 调用者: do_madvise\n- 被调用者: []\n\n10. 函数名: find_vma\n- 参数: [struct mm_struct *mm, unsigned long addr]\n- 调用者: do_madvise\n- 被调用者: []\n\n11. 函数名: blk_finish_plug\n- 参数: [struct blk_plug *plug]\n- 调用者: do_madvise\n- 被调用者: []\n\n12. 函数名: up_write\n- 参数: [struct rw_semaphore *sem]\n- 调用者: do_madvise\n- 被调用者: []\n\n13. 函数名: up_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: do_madvise\n- 被调用者: []"
    },
    {
        "id": 2670,
        "cwe": "CWE-362",
        "cve": "CVE-2020-29374",
        "purpose": "Code purpose:\"\"\"该代码用于处理用户空间指针到内核页面的映射，包括获取页面、处理写时复制情况以及管理页面活动状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当处理写时复制(COW)页面时，get_user_pages实现未能正确处理读操作的语义，导致可能意外授予写访问权限\"\"\"",
        "functions": "Functions:\n1. 函数名: i915_gem_userptr_get_pages\n- 参数: [struct drm_i915_gem_object *obj]\n- 调用者: N/A\n- 被调用者: [IS_ERR, PTR_ERR, kvmalloc_array, __get_user_pages_fast, i915_gem_object_is_readonly, ERR_PTR, __i915_gem_userptr_get_pages_schedule, __i915_gem_userptr_alloc_pages, __i915_gem_userptr_set_active, release_pages, kvfree, PTR_ERR_OR_ZERO]\n\n2. 函数名: __get_user_pages_fast\n- 参数: [obj->userptr.ptr, num_pages, !i915_gem_object_is_readonly(obj), pvec]\n- 调用者: i915_gem_userptr_get_pages\n- 被调用者: N/A\n\n3. 函数名: i915_gem_object_is_readonly\n- 参数: [obj]\n- 调用者: i915_gem_userptr_get_pages\n- 被调用者: N/A\n\n4. 函数名: __i915_gem_userptr_get_pages_schedule\n- 参数: [obj]\n- 调用者: i915_gem_userptr_get_pages\n- 被调用者: N/A\n\n5. 函数名: __i915_gem_userptr_alloc_pages\n- 参数: [obj, pvec, num_pages]\n- 调用者: i915_gem_userptr_get_pages\n- 被调用者: N/A\n\n6. 函数名: __i915_gem_userptr_set_active\n- 参数: [obj, true]\n- 调用者: i915_gem_userptr_get_pages\n- 被调用者: N/A\n\n7. 函数名: release_pages\n- 参数: [pvec, pinned]\n- 调用者: i915_gem_userptr_get_pages\n- 被调用者: N/A\n\n8. 函数名: kvfree\n- 参数: [pvec]\n- 调用者: i915_gem_userptr_get_pages\n- 被调用者: N/A"
    },
    {
        "id": 2671,
        "cwe": "CWE-362",
        "cve": "CVE-2020-29374",
        "purpose": "Code purpose:\"\"\"该代码实现了获取用户空间页面的功能，用于处理用户空间内存页面的映射和访问权限控制\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当处理写时复制(COW)页面时，get_user_pages实现未能正确处理读操作的语义，导致可能授予非预期的写访问权限\"\"\"",
        "functions": "Functions:\n1. 函数名: __get_user_pages\n- 参数: [tsk, mm, start, nr_pages, gup_flags, pages, vmas, locked]\n- 调用者: N/A (static函数，调用者未在代码片段中显示)\n- 被调用者: [untagged_addr, find_extend_vma, in_gate_area, get_gate_page, check_vma_flags, is_vm_hugetlb_page, follow_hugetlb_page, fatal_signal_pending, cond_resched, follow_page_mask, faultin_page, flush_anon_page, flush_dcache_page, put_dev_pagemap]\n\n2. 函数名: untagged_addr\n- 参数: [start]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n3. 函数名: find_extend_vma\n- 参数: [mm, start]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n4. 函数名: in_gate_area\n- 参数: [mm, start]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n5. 函数名: get_gate_page\n- 参数: [mm, start & PAGE_MASK, gup_flags, vma, pages ? &pages[i] : NULL]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n6. 函数名: check_vma_flags\n- 参数: [vma, gup_flags]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n7. 函数名: is_vm_hugetlb_page\n- 参数: [vma]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n8. 函数名: follow_hugetlb_page\n- 参数: [mm, vma, pages, vmas, start, nr_pages, i, gup_flags, locked]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n9. 函数名: fatal_signal_pending\n- 参数: [current]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n10. 函数名: cond_resched\n- 参数: []\n- 调用者: __get_user_pages\n- 被调用者: []\n\n11. 函数名: follow_page_mask\n- 参数: [vma, start, foll_flags, ctx]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n12. 函数名: faultin_page\n- 参数: [tsk, vma, start, foll_flags, locked]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n13. 函数名: flush_anon_page\n- 参数: [vma, page, start]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n14. 函数名: flush_dcache_page\n- 参数: [page]\n- 调用者: __get_user_pages\n- 被调用者: []\n\n15. 函数名: put_dev_pagemap\n- 参数: [ctx.pgmap]\n- 调用者: __get_user_pages\n- 被调用者: []"
    },
    {
        "id": 2672,
        "cwe": "CWE-362",
        "cve": "CVE-2020-29374",
        "purpose": "Code purpose:\"\"\"检查是否可以跟随写页表项(PTE)，考虑写权限、强制获取标志和写时复制(COW)情况下的脏页标志\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核的get_user_pages实现中，当处理写时复制(COW)页面时，未能正确处理读操作的语义，导致可能意外授予写访问权限。\"\"\"",
        "functions": "Functions:\n1. 函数名: can_follow_write_pte\n- 参数: [pte_t pte, unsigned int flags]\n- 调用者: 未明确（应为get_user_pages相关调用链）\n- 被调用者: [pte_write, pte_dirty]\n\n2. 函数名: pte_write\n- 参数: [pte_t pte]\n- 调用者: can_follow_write_pte\n- 被调用者: []\n\n3. 函数名: pte_dirty\n- 参数: [pte_t pte]\n- 调用者: can_follow_write_pte\n- 被调用者: []"
    },
    {
        "id": 2673,
        "cwe": "CWE-362",
        "cve": "CVE-2020-29374",
        "purpose": "Code purpose:\"\"\"快速获取用户空间页面的函数，用于将用户空间的页面固定到内存中并返回页面的引用\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核的get_user_pages实现中，当处理写时复制(COW)页面时，未能正确处理读操作的语义，导致可能意外授予写访问权限。\"\"\"",
        "functions": "Functions:\n1. 函数名: __get_user_pages_fast\n- 参数: [unsigned long start, int nr_pages, int write, struct page **pages]\n- 调用者: 未明确显示（通常是内核中需要快速获取用户页面的代码）\n- 被调用者: [untagged_addr, access_ok, local_irq_save, gup_pgd_range, local_irq_restore]\n\n2. 函数名: untagged_addr\n- 参数: [unsigned long start]\n- 调用者: __get_user_pages_fast\n- 被调用者: []\n\n3. 函数名: access_ok\n- 参数: [void __user *start, unsigned long len]\n- 调用者: __get_user_pages_fast\n- 被调用者: []\n\n4. 函数名: local_irq_save\n- 参数: [unsigned long flags]\n- 调用者: __get_user_pages_fast\n- 被调用者: []\n\n5. 函数名: gup_pgd_range\n- 参数: [unsigned long start, unsigned long end, unsigned int gup_flags, struct page **pages, int *nr_pinned]\n- 调用者: __get_user_pages_fast\n- 被调用者: []\n\n6. 函数名: local_irq_restore\n- 参数: [unsigned long flags]\n- 调用者: __get_user_pages_fast\n- 被调用者: []\n\n7. 函数名: gup_fast_permitted\n- 参数: [unsigned long start, unsigned long end]\n- 调用者: 未直接显示（通过IS_ENABLED宏条件调用）\n- 被调用者: []"
    },
    {
        "id": 2674,
        "cwe": "CWE-362",
        "cve": "CVE-2020-29374",
        "purpose": "Code purpose:\"\"\"该代码用于快速获取用户空间页面的物理页框，支持写时复制(COW)场景下的页面获取\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当处理写时复制(COW)页面时，get_user_pages实现未能正确处理读操作的语义，导致可能授予非预期的写访问权限\"\"\"",
        "functions": "Functions:\n1. 函数名: internal_get_user_pages_fast\n- 参数: [start, nr_pages, gup_flags, pages]\n- 调用者: 未明确（可能是外部调用）\n- 被调用者: [untagged_addr, access_ok, gup_fast_permitted, local_irq_disable, gup_pgd_range, local_irq_enable, __gup_longterm_unlocked]\n\n2. 函数名: untagged_addr\n- 参数: [start]\n- 调用者: internal_get_user_pages_fast\n- 被调用者: []\n\n3. 函数名: access_ok\n- 参数: [(void __user *)start, len]\n- 调用者: internal_get_user_pages_fast\n- 被调用者: []\n\n4. 函数名: gup_fast_permitted\n- 参数: [start, end]\n- 调用者: internal_get_user_pages_fast\n- 被调用者: []\n\n5. 函数名: local_irq_disable\n- 参数: []\n- 调用者: internal_get_user_pages_fast\n- 被调用者: []\n\n6. 函数名: gup_pgd_range\n- 参数: [addr, end, gup_flags, pages, &nr_pinned]\n- 调用者: internal_get_user_pages_fast\n- 被调用者: []\n\n7. 函数名: local_irq_enable\n- 参数: []\n- 调用者: internal_get_user_pages_fast\n- 被调用者: []\n\n8. 函数名: __gup_longterm_unlocked\n- 参数: [start, nr_pages - nr_pinned, gup_flags, pages]\n- 调用者: internal_get_user_pages_fast\n- 被调用者: []"
    },
    {
        "id": 2675,
        "cwe": "CWE-362",
        "cve": "CVE-2020-29374",
        "purpose": "Code purpose:\"\"\"判断是否可以跟随写入PMD（页中间目录）条目，考虑写权限、强制访问和写时复制标志\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在实现get_user_pages时，对写时复制页面的读操作语义考虑不周，导致可能授予非预期的写访问权限\"\"\"",
        "functions": "Functions:\n1. 函数名: can_follow_write_pmd\n- 参数: [pmd_t pmd, unsigned int flags]\n- 调用者: 未提供（根据上下文推测可能是get_user_pages相关函数）\n- 被调用者: [pmd_write, pmd_dirty]\n\n2. 函数名: pmd_write\n- 参数: [pmd_t pmd]\n- 调用者: can_follow_write_pmd\n- 被调用者: []\n\n3. 函数名: pmd_dirty\n- 参数: [pmd_t pmd]\n- 调用者: can_follow_write_pmd\n- 被调用者: []"
    },
    {
        "id": 2763,
        "cwe": "CWE-362",
        "cve": "CVE-2020-36557",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中安装控制台终端，处理终端分配、端口安装及终端属性设置等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在VT_DISALLOCATE ioctl操作与tty设备关闭/打开之间存在竞争条件，导致对已释放的vc_data结构体的访问，引发use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: con_install\n- 参数: [driver, tty]\n- 调用者: 未明确（应为tty子系统调用）\n- 被调用者: [console_lock, vc_allocate, tty_port_install, console_unlock]\n\n2. 函数名: console_lock\n- 参数: []\n- 调用者: con_install\n- 被调用者: []\n\n3. 函数名: vc_allocate\n- 参数: [currcons]\n- 调用者: con_install\n- 被调用者: []\n\n4. 函数名: tty_port_install\n- 参数: [&vc->port, driver, tty]\n- 调用者: con_install\n- 被调用者: []\n\n5. 函数名: console_unlock\n- 参数: []\n- 调用者: con_install\n- 被调用者: []"
    },
    {
        "id": 2764,
        "cwe": "CWE-362",
        "cve": "CVE-2020-36557",
        "purpose": "Code purpose:\"\"\"管理虚拟控制台(VT)的分配和初始化，包括内存分配、数据结构初始化和系统通知等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在VT_DISALLOCATE ioctl操作与tty设备关闭/打开之间存在竞态条件，导致内核在释放虚拟控制台资源后可能被错误地继续访问\"\"\"",
        "functions": "Functions:\n1. 函数名: vc_allocate\n- 参数: [unsigned int currcons]\n- 调用者: 未显示\n- 被调用者: [WARN_CONSOLE_UNLOCKED, kzalloc, tty_port_init, INIT_WORK, visual_init, con_set_default_unimap, kzalloc, vc_init, vcs_make_sysfs, atomic_notifier_call_chain, visual_deinit, kfree]\n\n2. 函数名: WARN_CONSOLE_UNLOCKED\n- 参数: []\n- 调用者: vc_allocate\n- 被调用者: []\n\n3. 函数名: kzalloc\n- 参数: [sizeof(struct vc_data), GFP_KERNEL] 和 [vc->vc_screenbuf_size, GFP_KERNEL]\n- 调用者: vc_allocate\n- 被调用者: []\n\n4. 函数名: tty_port_init\n- 参数: [&vc->port]\n- 调用者: vc_allocate\n- 被调用者: []\n\n5. 函数名: INIT_WORK\n- 参数: [&vc_cons[currcons].SAK_work, vc_SAK]\n- 调用者: vc_allocate\n- 被调用者: []\n\n6. 函数名: visual_init\n- 参数: [vc, currcons, 1]\n- 调用者: vc_allocate\n- 被调用者: []\n\n7. 函数名: con_set_default_unimap\n- 参数: [vc]\n- 调用者: vc_allocate\n- 被调用者: []\n\n8. 函数名: vc_init\n- 参数: [vc, vc->vc_rows, vc->vc_cols, 1]\n- 调用者: vc_allocate\n- 被调用者: []\n\n9. 函数名: vcs_make_sysfs\n- 参数: [currcons]\n- 调用者: vc_allocate\n- 被调用者: []\n\n10. 函数名: atomic_notifier_call_chain\n- 参数: [&vt_notifier_list, VT_ALLOCATE, &param]\n- 调用者: vc_allocate\n- 被调用者: []\n\n11. 函数名: visual_deinit\n- 参数: [vc]\n- 调用者: vc_allocate\n- 被调用者: []\n\n12. 函数名: kfree\n- 参数: [vc]\n- 调用者: vc_allocate\n- 被调用者: []"
    },
    {
        "id": 2765,
        "cwe": "CWE-362",
        "cve": "CVE-2020-36557",
        "purpose": "Code purpose:\"\"\"该代码用于释放指定的虚拟控制台资源，包括检查控制台是否繁忙、解除分配以及清理相关数据结构。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在VT_DISALLOCATE ioctl操作与tty设备关闭/打开之间存在竞态条件，导致在释放vc结构后可能被错误地继续使用\"\"\"",
        "functions": "Functions:\n1. 函数名: vt_disallocate\n- 参数: [unsigned int vc_num]\n- 调用者: 不适用（由外部调用）\n- 被调用者: [console_lock, vt_busy, vc_deallocate, console_unlock, tty_port_destroy, kfree]\n\n2. 函数名: console_lock\n- 参数: []\n- 调用者: vt_disallocate\n- 被调用者: []\n\n3. 函数名: vt_busy\n- 参数: [unsigned int vc_num]\n- 调用者: vt_disallocate\n- 被调用者: []\n\n4. 函数名: vc_deallocate\n- 参数: [unsigned int vc_num]\n- 调用者: vt_disallocate\n- 被调用者: []\n\n5. 函数名: console_unlock\n- 参数: []\n- 调用者: vt_disallocate\n- 被调用者: []\n\n6. 函数名: tty_port_destroy\n- 参数: [&vc->port]\n- 调用者: vt_disallocate\n- 被调用者: []\n\n7. 函数名: kfree\n- 参数: [vc]\n- 调用者: vt_disallocate\n- 被调用者: []"
    },
    {
        "id": 2766,
        "cwe": "CWE-362",
        "cve": "CVE-2020-36557",
        "purpose": "Code purpose:\"\"\"该代码用于释放所有未使用的虚拟控制台资源，包括销毁端口和释放内存\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放虚拟终端(vc)资源时，由于缺少适当的同步机制，导致在VT_DISALLOCATE ioctl操作与tty设备的关闭/打开之间存在竞争条件，可能引发释放后重用(UAF)问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: vt_disallocate_all\n- 参数: []\n- 调用者: N/A\n- 被调用者: [console_lock, vt_busy, vc_deallocate, console_unlock, tty_port_destroy, kfree]\n\n2. 函数名: console_lock\n- 参数: []\n- 调用者: vt_disallocate_all\n- 被调用者: []\n\n3. 函数名: vt_busy\n- 参数: [i]\n- 调用者: vt_disallocate_all\n- 被调用者: []\n\n4. 函数名: vc_deallocate\n- 参数: [i]\n- 调用者: vt_disallocate_all\n- 被调用者: []\n\n5. 函数名: console_unlock\n- 参数: []\n- 调用者: vt_disallocate_all\n- 被调用者: []\n\n6. 函数名: tty_port_destroy\n- 参数: [&vc[i]->port]\n- 调用者: vt_disallocate_all\n- 被调用者: []\n\n7. 函数名: kfree\n- 参数: [vc[i]]\n- 调用者: vt_disallocate_all\n- 被调用者: []"
    },
    {
        "id": 2767,
        "cwe": "CWE-362",
        "cve": "CVE-2020-36558",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中虚拟终端(VT)的多种控制功能，包括终端模式设置、字体操作、屏幕大小调整、信号处理等，通过ioctl系统调用提供用户空间与虚拟终端设备的交互接口。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"VT_RESIZEX操作在处理虚拟终端控制台时存在竞态条件，可能导致对空指针的解引用和一般保护错误。\"\"\"",
        "functions": "Functions:\n1. 函数名: vt_ioctl\n- 参数: [struct tty_struct *tty, unsigned int cmd, unsigned long arg]\n- 调用者: N/A (kernel-level function)\n- 被调用者: [vc_cons_allocated, tioclinux, kd_mksound, msecs_to_jiffies, put_user, ksys_ioperm, copy_from_user, kbd_rate, copy_to_user, vt_do_kdskbmode, tty_ldisc_flush, vt_do_kdgkbmode, vt_do_kdskbmeta, vt_do_kdgkbmeta, vt_do_kbkeycode_ioctl, vt_do_kdsk_ioctl, vt_do_kdgkb_ioctl, vt_do_diacrit, vt_do_kdskled, valid_signal, put_pid, get_pid, task_pid, vc_allocate, set_console, vt_waitactive, complete_change_console, vt_disallocate, vt_disallocate_all, vc_resize, con_font_op, con_set_cmap, con_get_cmap, do_fontx_ioctl, con_set_default_unimap, con_set_trans_old, con_get_trans_old, con_set_trans_new, con_get_trans_new, con_clear_unimap, do_unimap_ioctl, vt_event_wait_ioctl]\n\n2. 函数名: tioclinux\n- 参数: [struct tty_struct *tty, unsigned long arg]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n3. 函数名: kd_mksound\n- 参数: [unsigned long arg, int ticks]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n4. 函数名: msecs_to_jiffies\n- 参数: [unsigned int msecs]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n5. 函数名: put_user\n- 参数: [type val, type __user *ptr]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n6. 函数名: ksys_ioperm\n- 参数: [unsigned long from, unsigned long num, int turn_on]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n7. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n8. 函数名: kbd_rate\n- 参数: [struct kbd_repeat *kbrep]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n9. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n10. 函数名: vt_do_kdskbmode\n- 参数: [unsigned int console, unsigned int arg]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n11. 函数名: tty_ldisc_flush\n- 参数: [struct tty_struct *tty]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n12. 函数名: vt_do_kdgkbmode\n- 参数: [unsigned int console]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n13. 函数名: vt_do_kdskbmeta\n- 参数: [unsigned int console, unsigned int arg]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n14. 函数名: vt_do_kdgkbmeta\n- 参数: [unsigned int console]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n15. 函数名: vt_do_kbkeycode_ioctl\n- 参数: [unsigned int cmd, void __user *up, int perm]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n16. 函数名: vt_do_kdsk_ioctl\n- 参数: [unsigned int cmd, void __user *up, int perm, unsigned int console]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n17. 函数名: vt_do_kdgkb_ioctl\n- 参数: [unsigned int cmd, void __user *up, int perm]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n18. 函数名: vt_do_diacrit\n- 参数: [unsigned int cmd, void __user *up, int perm]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n19. 函数名: vt_do_kdskled\n- 参数: [unsigned int console, unsigned int cmd, unsigned long arg, int perm]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n20. 函数名: valid_signal\n- 参数: [unsigned long sig]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n21. 函数名: put_pid\n- 参数: [struct pid *pid]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n22. 函数名: get_pid\n- 参数: [struct pid *pid]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n23. 函数名: task_pid\n- 参数: [struct task_struct *task]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n24. 函数名: vc_allocate\n- 参数: [unsigned int console]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n25. 函数名: set_console\n- 参数: [int nr]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n26. 函数名: vt_waitactive\n- 参数: [int arg]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n27. 函数名: complete_change_console\n- 参数: [struct vc_data *vc]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n28. 函数名: vt_disallocate\n- 参数: [int arg]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n29. 函数名: vt_disallocate_all\n- 参数: []\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n30. 函数名: vc_resize\n- 参数: [struct vc_data *vc, unsigned int cols, unsigned int rows]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n31. 函数名: con_font_op\n- 参数: [struct vc_data *vc, struct console_font_op *op]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n32. 函数名: con_set_cmap\n- 参数: [unsigned char __user *arg]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n33. 函数名: con_get_cmap\n- 参数: [unsigned char __user *arg]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n34. 函数名: do_fontx_ioctl\n- 参数: [unsigned int cmd, void __user *up, int perm, struct console_font_op *op]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n35. 函数名: con_set_default_unimap\n- 参数: [struct vc_data *vc]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n36. 函数名: con_set_trans_old\n- 参数: [unsigned char __user *arg]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n37. 函数名: con_get_trans_old\n- 参数: [unsigned char __user *arg]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n38. 函数名: con_set_trans_new\n- 参数: [unsigned short __user *arg]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n39. 函数名: con_get_trans_new\n- 参数: [unsigned short __user *arg]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n40. 函数名: con_clear_unimap\n- 参数: [struct vc_data *vc]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n41. 函数名: do_unimap_ioctl\n- 参数: [unsigned int cmd, void __user *up, int perm, struct vc_data *vc]\n- 调用者: vt_ioctl\n- 被调用者: N/A\n\n42. 函数名: vt_event_wait_ioctl\n- 参数: [struct vt_event __user *event]\n- 调用者: vt_ioctl\n- 被调用者: N/A"
    },
    {
        "id": 2830,
        "cwe": "CWE-362",
        "cve": "CVE-2021-0920",
        "purpose": "Code purpose:\"\"\"该代码实现了Unix域套接字流式数据的读取功能，处理接收队列中的数据包并将内容复制到用户空间\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在unix_stream_read_generic函数中存在竞态条件，导致在释放skb后可能被并发访问，造成use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: unix_stream_read_generic\n- 参数: [struct unix_stream_read_state *state, bool freezable]\n- 调用者: N/A (顶层函数)\n- 被调用者: [unix_sk, sock_rcvlowat, sock_rcvtimeo, memset, mutex_lock, sk_peek_offset, unix_state_lock, sock_error, mutex_unlock, unix_stream_data_wait, signal_pending, sock_intr_errno, scm_destroy, unix_skb_len, skb_peek_next, unix_skb_scm_eq, scm_set_cred, unix_set_secdata, DECLARE_SOCKADDR, unix_copy_addr, min_t, skb_get, consume_skb, sk_peek_offset_bwd, scm_stat_del, unix_detach_fds, skb_unlink, scm_fp_dup, sk_peek_offset_fwd, scm_recv]\n\n2. 函数名: unix_sk\n- 参数: [struct sock *sk]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n3. 函数名: sock_rcvlowat\n- 参数: [struct sock *sk, int flags, size_t size]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n4. 函数名: sock_rcvtimeo\n- 参数: [struct sock *sk, int noblock]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n5. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n6. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n7. 函数名: sk_peek_offset\n- 参数: [struct sock *sk, int flags]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n8. 函数名: unix_state_lock\n- 参数: [struct sock *sk]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n9. 函数名: sock_error\n- 参数: [struct sock *sk]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n10. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n11. 函数名: unix_stream_data_wait\n- 参数: [struct sock *sk, long timeo, struct sk_buff *last, unsigned int last_len, bool freezable]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n12. 函数名: signal_pending\n- 参数: [struct task_struct *p]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n13. 函数名: sock_intr_errno\n- 参数: [long timeo]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n14. 函数名: scm_destroy\n- 参数: [struct scm_cookie *scm]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n15. 函数名: unix_skb_len\n- 参数: [struct sk_buff *skb]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n16. 函数名: skb_peek_next\n- 参数: [struct sk_buff *skb, struct sk_buff_head *list]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n17. 函数名: unix_skb_scm_eq\n- 参数: [struct sk_buff *skb, struct scm_cookie *scm]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n18. 函数名: scm_set_cred\n- 参数: [struct scm_cookie *scm, pid_t pid, kuid_t uid, kgid_t gid]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n19. 函数名: unix_set_secdata\n- 参数: [struct scm_cookie *scm, struct sk_buff *skb]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n20. 函数名: unix_copy_addr\n- 参数: [struct msghdr *msg, struct sock *sk]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n21. 函数名: min_t\n- 参数: [type, x, y]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n22. 函数名: skb_get\n- 参数: [struct sk_buff *skb]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n23. 函数名: consume_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n24. 函数名: sk_peek_offset_bwd\n- 参数: [struct sock *sk, int len]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n25. 函数名: scm_stat_del\n- 参数: [struct sock *sk, struct sk_buff *skb]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n26. 函数名: unix_detach_fds\n- 参数: [struct scm_cookie *scm, struct sk_buff *skb]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n27. 函数名: skb_unlink\n- 参数: [struct sk_buff *skb, struct sk_buff_head *list]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n28. 函数名: scm_fp_dup\n- 参数: [struct scm_fp_list *fp]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n29. 函数名: sk_peek_offset_fwd\n- 参数: [struct sock *sk, int len]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A\n\n30. 函数名: scm_recv\n- 参数: [struct socket *sock, struct msghdr *msg, struct scm_cookie *scm, int flags]\n- 调用者: unix_stream_read_generic\n- 被调用者: N/A"
    },
    {
        "id": 2831,
        "cwe": "CWE-362",
        "cve": "CVE-2021-0920",
        "purpose": "Code purpose:\"\"\"该代码实现了Unix域数据报套接字的接收消息功能，包括处理消息队列、数据拷贝、控制消息传递以及文件描述符的传递等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在unix_dgram_recvmsg函数中存在竞态条件，导致在释放skb后仍可能被访问，造成use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: unix_dgram_recvmsg\n- 参数: [struct socket *sock, struct msghdr *msg, size_t size, int flags]\n- 调用者: 外部调用\n- 被调用者: [unix_sk, sock_rcvtimeo, mutex_lock, sk_peek_offset, __skb_try_recv_datagram, scm_stat_del, mutex_unlock, __skb_wait_for_more_packets, unix_state_lock, unix_state_unlock, wake_up_interruptible_sync_poll, unix_copy_addr, skb_copy_datagram_msg, __sock_recv_timestamp, scm_set_cred, unix_set_secdata, unix_detach_fds, sk_peek_offset_bwd, sk_peek_offset_fwd, scm_fp_dup, scm_recv, skb_free_datagram]\n\n2. 函数名: unix_sk\n- 参数: [struct sock *sk]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n3. 函数名: sock_rcvtimeo\n- 参数: [struct sock *sk, int flags]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n4. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n5. 函数名: sk_peek_offset\n- 参数: [struct sock *sk, int flags]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n6. 函数名: __skb_try_recv_datagram\n- 参数: [struct sock *sk, struct sk_buff_head *queue, int flags, int *peek_offset, int *err, struct sk_buff **last]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n7. 函数名: scm_stat_del\n- 参数: [struct sock *sk, struct sk_buff *skb]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n8. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n9. 函数名: __skb_wait_for_more_packets\n- 参数: [struct sock *sk, struct sk_buff_head *queue, int *err, long *timeo, struct sk_buff *last]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n10. 函数名: unix_state_lock\n- 参数: [struct sock *sk]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n11. 函数名: unix_state_unlock\n- 参数: [struct sock *sk]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n12. 函数名: wake_up_interruptible_sync_poll\n- 参数: [wait_queue_head_t *wq_head, unsigned int mode]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n13. 函数名: unix_copy_addr\n- 参数: [struct msghdr *msg, struct sock *sk]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n14. 函数名: skb_copy_datagram_msg\n- 参数: [struct sk_buff *skb, int offset, struct msghdr *msg, int size]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n15. 函数名: __sock_recv_timestamp\n- 参数: [struct msghdr *msg, struct sock *sk, struct sk_buff *skb]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n16. 函数名: scm_set_cred\n- 参数: [struct scm_cookie *scm, pid_t pid, kuid_t uid, kgid_t gid]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n17. 函数名: unix_set_secdata\n- 参数: [struct scm_cookie *scm, struct sk_buff *skb]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n18. 函数名: unix_detach_fds\n- 参数: [struct scm_cookie *scm, struct sk_buff *skb]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n19. 函数名: sk_peek_offset_bwd\n- 参数: [struct sock *sk, int len]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n20. 函数名: sk_peek_offset_fwd\n- 参数: [struct sock *sk, int len]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n21. 函数名: scm_fp_dup\n- 参数: [struct scm_fp_list *fpl]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n22. 函数名: scm_recv\n- 参数: [struct socket *sock, struct msghdr *msg, struct scm_cookie *scm, int flags]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []\n\n23. 函数名: skb_free_datagram\n- 参数: [struct sock *sk, struct sk_buff *skb]\n- 调用者: unix_dgram_recvmsg\n- 被调用者: []"
    },
    {
        "id": 2861,
        "cwe": "CWE-362",
        "cve": "CVE-2021-20261",
        "purpose": "Code purpose:\"\"\"该代码用于处理软盘驱动器的格式化请求，包括参数验证和格式化操作执行，并存在竞争条件漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于Linux内核软盘控制器驱动程序中存在竞争条件，当多个进程同时访问floppy设备时可能导致未预期的行为。\"\"\"",
        "functions": "Functions:\n1. 函数名: do_format\n- 参数: [drive, tmp_format_req]\n- 调用者: 未显示（外部调用）\n- 被调用者: [lock_fdc, set_floppy, process_fd_request, wait_til_done]\n\n2. 函数名: lock_fdc\n- 参数: [drive, true]\n- 调用者: do_format\n- 被调用者: 未显示\n\n3. 函数名: set_floppy\n- 参数: [drive]\n- 调用者: do_format\n- 被调用者: 未显示\n\n4. 函数名: process_fd_request\n- 参数: []\n- 调用者: do_format\n- 被调用者: 未显示\n\n5. 函数名: wait_til_done\n- 参数: [redo_format, true]\n- 调用者: do_format\n- 被调用者: 未显示"
    },
    {
        "id": 2862,
        "cwe": "CWE-362",
        "cve": "CVE-2021-20261",
        "purpose": "Code purpose:\"\"\"检查软盘驱动器状态并返回媒体变更事件\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于Linux内核软盘驱动控制器中存在竞态条件，当检查磁盘状态时未正确同步对共享资源(UDRS->flags)的访问，导致可能发生条件竞争。\"\"\"",
        "functions": "Functions:\n1. 函数名: floppy_check_events\n- 参数: [struct gendisk *disk, unsigned int clearing]\n- 调用者: 未明确（通常是内核其他模块调用）\n- 被调用者: [test_bit, time_after, lock_fdc, poll_drive, process_fd_request, drive_no_geom]\n\n2. 函数名: test_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: floppy_check_events\n- 被调用者: []\n\n3. 函数名: time_after\n- 参数: [unsigned long a, unsigned long b]\n- 调用者: floppy_check_events\n- 被调用者: []\n\n4. 函数名: lock_fdc\n- 参数: [int drive, bool interruptible]\n- 调用者: floppy_check_events\n- 被调用者: []\n\n5. 函数名: poll_drive\n- 参数: [bool interruptible, int flag]\n- 调用者: floppy_check_events\n- 被调用者: []\n\n6. 函数名: process_fd_request\n- 参数: []\n- 调用者: floppy_check_events\n- 被调用者: []\n\n7. 函数名: drive_no_geom\n- 参数: [int drive]\n- 调用者: floppy_check_events\n- 被调用者: []"
    },
    {
        "id": 2863,
        "cwe": "CWE-362",
        "cve": "CVE-2021-20261",
        "purpose": "Code purpose:\"\"\"该代码用于实现软盘驱动器控制器的用户重置功能，包括锁定控制器、处理重置请求和执行后续操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在floppy磁盘驱动控制器驱动程序中存在竞态条件，当设备权限被修改时可能导致未授权的访问或操作\"\"\"",
        "functions": "Functions:\n1. 函数名: user_reset_fdc\n- 参数: [drive, arg, interruptible]\n- 调用者: 未明确（外部调用）\n- 被调用者: [lock_fdc, wait_til_done, process_fd_request]\n\n2. 函数名: lock_fdc\n- 参数: [drive, interruptible]\n- 调用者: user_reset_fdc\n- 被调用者: 未明确\n\n3. 函数名: wait_til_done\n- 参数: [reset_fdc, interruptible]\n- 调用者: user_reset_fdc\n- 被调用者: 未明确\n\n4. 函数名: process_fd_request\n- 参数: []\n- 调用者: user_reset_fdc\n- 被调用者: 未明确\n\n5. 函数名: reset_fdc\n- 参数: 未明确（作为回调函数传递给wait_til_done）\n- 调用者: wait_til_done（间接）\n- 被调用者: 未明确"
    },
    {
        "id": 2864,
        "cwe": "CWE-362",
        "cve": "CVE-2021-20261",
        "purpose": "Code purpose:\"\"\"获取指定软盘驱动器的几何结构信息，并根据类型参数返回对应的结构体指针\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于Linux内核软盘控制器驱动中存在的竞态条件问题，在获取软盘几何参数时未正确处理并发访问，可能导致数据竞争。\"\"\"",
        "functions": "Functions:\n1. 函数名: get_floppy_geometry\n- 参数: [drive, type, g]\n- 调用者: 未指定\n- 被调用者: [lock_fdc, poll_drive, process_fd_request]\n\n2. 函数名: lock_fdc\n- 参数: [drive, false]\n- 调用者: get_floppy_geometry\n- 被调用者: 未指定\n\n3. 函数名: poll_drive\n- 参数: [false, 0]\n- 调用者: get_floppy_geometry\n- 被调用者: 未指定\n\n4. 函数名: process_fd_request\n- 参数: []\n- 调用者: get_floppy_geometry\n- 被调用者: 未指定"
    },
    {
        "id": 2865,
        "cwe": "CWE-362",
        "cve": "CVE-2021-20261",
        "purpose": "Code purpose:\"\"\"该代码用于重新验证和更新软盘驱动器的状态，包括处理磁盘变更、几何信息检测和请求处理等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于floppy_revalidate函数中存在竞态条件，多个线程可能同时访问和修改共享资源UDRS->flags等状态，导致数据不一致或意外行为。\"\"\"",
        "functions": "Functions:\n1. 函数名: floppy_revalidate\n- 参数: [struct gendisk *disk]\n- 调用者: 未显示（由内核调用）\n- 被调用者: [test_bit, WARN, atomic_read, lock_fdc, process_fd_request, clear_bit, __floppy_read_block_0, poll_drive, set_capacity]\n\n2. 函数名: test_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: floppy_revalidate\n- 被调用者: []\n\n3. 函数名: WARN\n- 参数: [int condition, const char *fmt, ...]\n- 调用者: floppy_revalidate\n- 被调用者: []\n\n4. 函数名: atomic_read\n- 参数: [atomic_t *v]\n- 调用者: floppy_revalidate\n- 被调用者: []\n\n5. 函数名: lock_fdc\n- 参数: [int drive, bool interruptible]\n- 调用者: floppy_revalidate\n- 被调用者: []\n\n6. 函数名: process_fd_request\n- 参数: []\n- 调用者: floppy_revalidate\n- 被调用者: []\n\n7. 函数名: clear_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: floppy_revalidate\n- 被调用者: []\n\n8. 函数名: __floppy_read_block_0\n- 参数: [struct block_device *bdev, int drive]\n- 调用者: floppy_revalidate\n- 被调用者: []\n\n9. 函数名: poll_drive\n- 参数: [bool interruptible, int flag]\n- 调用者: floppy_revalidate\n- 被调用者: []\n\n10. 函数名: set_capacity\n- 参数: [struct gendisk *disk, sector_t size]\n- 调用者: floppy_revalidate\n- 被调用者: []\n\n11. 函数名: drive_no_geom\n- 参数: [int drive]\n- 调用者: floppy_revalidate\n- 被调用者: []"
    },
    {
        "id": 2877,
        "cwe": "CWE-362",
        "cve": "CVE-2021-20321",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核OverlayFS子系统中文件重命名的功能，处理不同目录间的文件移动和重命名操作，包括处理白名单、目录合并等特殊情况。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核OverlayFS子系统中存在竞态条件漏洞，当用户以特定方式执行重命名操作时，可能导致系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: ovl_rename\n- 参数: [mnt_userns, olddir, old, newdir, new, flags]\n- 调用者: N/A (kernel function)\n- 被调用者: [ovl_can_move, ovl_pure_upper, ovl_check_empty_dir, ovl_lower_positive, ovl_dentry_is_whiteout, ovl_want_write, ovl_copy_up, ovl_nlink_start, ovl_override_creds, ovl_clear_empty, ovl_dentry_upper, ovl_type_origin, ovl_set_impure, lock_rename, lookup_one_len, ovl_matches_upper, ovl_dentry_is_opaque, ovl_is_whiteout, ovl_type_merge_or_lower, ovl_set_redirect, ovl_type_merge, ovl_set_opaque_xerr, ovl_do_rename, ovl_cleanup, clear_nlink, ovl_drop_nlink, ovl_dir_modified, ovl_copyattr, dput, unlock_rename, revert_creds, ovl_nlink_end, ovl_drop_write, ovl_cache_free]\n\n2. 函数名: ovl_can_move\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n3. 函数名: ovl_pure_upper\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n4. 函数名: ovl_check_empty_dir\n- 参数: [dentry, list]\n- 调用者: ovl_rename\n- 被调用者: []\n\n5. 函数名: ovl_lower_positive\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n6. 函数名: ovl_dentry_is_whiteout\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n7. 函数名: ovl_want_write\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n8. 函数名: ovl_copy_up\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n9. 函数名: ovl_nlink_start\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n10. 函数名: ovl_override_creds\n- 参数: [sb]\n- 调用者: ovl_rename\n- 被调用者: []\n\n11. 函数名: ovl_clear_empty\n- 参数: [dentry, list]\n- 调用者: ovl_rename\n- 被调用者: []\n\n12. 函数名: ovl_dentry_upper\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n13. 函数名: ovl_type_origin\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n14. 函数名: ovl_set_impure\n- 参数: [dentry, upper]\n- 调用者: ovl_rename\n- 被调用者: []\n\n15. 函数名: lock_rename\n- 参数: [new_upperdir, old_upperdir]\n- 调用者: ovl_rename\n- 被调用者: []\n\n16. 函数名: lookup_one_len\n- 参数: [name, base, len]\n- 调用者: ovl_rename\n- 被调用者: []\n\n17. 函数名: ovl_matches_upper\n- 参数: [dentry, upper]\n- 调用者: ovl_rename\n- 被调用者: []\n\n18. 函数名: ovl_dentry_is_opaque\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n19. 函数名: ovl_is_whiteout\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n20. 函数名: ovl_type_merge_or_lower\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n21. 函数名: ovl_set_redirect\n- 参数: [dentry, samedir]\n- 调用者: ovl_rename\n- 被调用者: []\n\n22. 函数名: ovl_type_merge\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n23. 函数名: ovl_set_opaque_xerr\n- 参数: [dentry, upper, err]\n- 调用者: ovl_rename\n- 被调用者: []\n\n24. 函数名: ovl_do_rename\n- 参数: [old_dir, old_dentry, new_dir, new_dentry, flags]\n- 调用者: ovl_rename\n- 被调用者: []\n\n25. 函数名: ovl_cleanup\n- 参数: [dir, dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n26. 函数名: clear_nlink\n- 参数: [inode]\n- 调用者: ovl_rename\n- 被调用者: []\n\n27. 函数名: ovl_drop_nlink\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n28. 函数名: ovl_dir_modified\n- 参数: [dentry, origin]\n- 调用者: ovl_rename\n- 被调用者: []\n\n29. 函数名: ovl_copyattr\n- 参数: [inode, inode]\n- 调用者: ovl_rename\n- 被调用者: []\n\n30. 函数名: dput\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n31. 函数名: unlock_rename\n- 参数: [new_upperdir, old_upperdir]\n- 调用者: ovl_rename\n- 被调用者: []\n\n32. 函数名: revert_creds\n- 参数: [old_cred]\n- 调用者: ovl_rename\n- 被调用者: []\n\n33. 函数名: ovl_nlink_end\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n34. 函数名: ovl_drop_write\n- 参数: [dentry]\n- 调用者: ovl_rename\n- 被调用者: []\n\n35. 函数名: ovl_cache_free\n- 参数: [list]\n- 调用者: ovl_rename\n- 被调用者: []"
    },
    {
        "id": 2887,
        "cwe": "CWE-362",
        "cve": "CVE-2021-23133",
        "purpose": "Code purpose:\"\"\"释放SCTP套接字资源并处理自动配置列表的清理工作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在sctp_destroy_sock函数中，当处理auto_asconf_list列表时未获取addr_wq_lock锁，导致竞态条件可能被利用进行权限提升\"\"\"",
        "functions": "Functions:\n1. 函数名: sctp_destroy_sock\n- 参数: [struct sock *sk]\n- 调用者: 未明确显示（通常是内核中销毁socket的调用链）\n- 被调用者: [sctp_sk, sctp_endpoint_free, local_bh_disable, sk_sockets_allocated_dec, sock_prot_inuse_add, sock_net, local_bh_enable]\n\n2. 函数名: sctp_sk\n- 参数: [struct sock *sk]\n- 调用者: sctp_destroy_sock\n- 被调用者: []\n\n3. 函数名: sctp_endpoint_free\n- 参数: [struct sctp_endpoint *ep]\n- 调用者: sctp_destroy_sock\n- 被调用者: []\n\n4. 函数名: local_bh_disable\n- 参数: []\n- 调用者: sctp_destroy_sock\n- 被调用者: []\n\n5. 函数名: sk_sockets_allocated_dec\n- 参数: [struct sock *sk]\n- 调用者: sctp_destroy_sock\n- 被调用者: []\n\n6. 函数名: sock_prot_inuse_add\n- 参数: [struct net *net, struct proto *prot, int val]\n- 调用者: sctp_destroy_sock\n- 被调用者: []\n\n7. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sctp_destroy_sock\n- 被调用者: []\n\n8. 函数名: local_bh_enable\n- 参数: []\n- 调用者: sctp_destroy_sock\n- 被调用者: []\n\n9. 函数名: list_del\n- 参数: [struct list_head *entry]\n- 调用者: sctp_destroy_sock\n- 被调用者: []\n\n10. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: sctp_destroy_sock\n- 被调用者: []"
    },
    {
        "id": 2888,
        "cwe": "CWE-362",
        "cve": "CVE-2021-23133",
        "purpose": "Code purpose:\"\"\"初始化SCTP套接字并设置相关参数，包括默认发送参数、关联参数、事件订阅等，同时处理自动配置列表的并发访问问题\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在SCTP套接字销毁时未正确获取addr_wq_lock锁的情况下修改auto_asconf_splist链表，导致竞态条件可能被利用进行权限提升\"\"\"",
        "functions": "Functions:\n1. 函数名: sctp_init_sock\n- 参数: [struct sock *sk]\n- 调用者: 未显示（通常由socket创建流程调用）\n- 被调用者: [sock_net, sctp_sk, pr_debug, htons, sctp_endpoint_new, sctp_get_pf_specific, atomic_set, skb_queue_head_init, local_bh_disable, sk_sockets_allocated_inc, sock_prot_inuse_add, spin_lock, list_add_tail, spin_unlock, local_bh_enable]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n3. 函数名: sctp_sk\n- 参数: [struct sock *sk]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n4. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n5. 函数名: htons\n- 参数: [uint16_t hostshort]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n6. 函数名: sctp_endpoint_new\n- 参数: [struct sock *sk, gfp_t gfp]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n7. 函数名: sctp_get_pf_specific\n- 参数: [int family]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n8. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n9. 函数名: skb_queue_head_init\n- 参数: [struct sk_buff_head *list]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n10. 函数名: local_bh_disable\n- 参数: []\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n11. 函数名: sk_sockets_allocated_inc\n- 参数: [struct sock *sk]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n12. 函数名: sock_prot_inuse_add\n- 参数: [struct net *net, struct proto *prot, int val]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n13. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n14. 函数名: list_add_tail\n- 参数: [struct list_head *new, struct list_head *head]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n15. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: sctp_init_sock\n- 被调用者: []\n\n16. 函数名: local_bh_enable\n- 参数: []\n- 调用者: sctp_init_sock\n- 被调用者: []"
    },
    {
        "id": 2889,
        "cwe": "CWE-362",
        "cve": "CVE-2021-23133",
        "purpose": "Code purpose:\"\"\"该代码实现了SCTP套接字的关闭功能，包括清理接收队列、处理关联状态以及释放相关资源，但存在竞争条件漏洞可能导致权限提升。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在调用sctp_destroy_sock时未正确获取addr_wq_lock锁，导致auto_asconf_splist列表元素在无锁保护情况下被移除，引发竞争条件漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: sctp_close\n- 参数: [struct sock *sk, long timeout]\n- 调用者: 无（系统调用或内核其他部分）\n- 被调用者: [sock_net, lock_sock_nested, inet_sk_set_state, sctp_sk, sctp_queue_purge_ulpevents, list_for_each_safe, list_entry, sctp_style, sctp_state, sctp_association_free, skb_queue_empty, sock_flag, sctp_make_abort_user, sctp_primitive_ABORT, sctp_primitive_SHUTDOWN, sctp_wait_for_close, release_sock, spin_lock_bh, bh_lock_sock_nested, sock_hold, sk_common_release, bh_unlock_sock, spin_unlock_bh, sock_put]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n3. 函数名: lock_sock_nested\n- 参数: [struct sock *sk, int subclass]\n- 调用者: sctp_close\n- 被调用者: 无\n\n4. 函数名: inet_sk_set_state\n- 参数: [struct sock *sk, int state]\n- 调用者: sctp_close\n- 被调用者: 无\n\n5. 函数名: sctp_sk\n- 参数: [struct sock *sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n6. 函数名: sctp_queue_purge_ulpevents\n- 参数: [struct sk_buff_head *list]\n- 调用者: sctp_close\n- 被调用者: 无\n\n7. 函数名: list_for_each_safe\n- 参数: [struct list_head *pos, struct list_head *temp, struct list_head *head]\n- 调用者: sctp_close\n- 被调用者: 无\n\n8. 函数名: list_entry\n- 参数: [struct list_head *ptr, type, member]\n- 调用者: sctp_close\n- 被调用者: 无\n\n9. 函数名: sctp_style\n- 参数: [struct sock *sk, int style]\n- 调用者: sctp_close\n- 被调用者: 无\n\n10. 函数名: sctp_state\n- 参数: [struct sctp_association *asoc, int state]\n- 调用者: sctp_close\n- 被调用者: 无\n\n11. 函数名: sctp_association_free\n- 参数: [struct sctp_association *asoc]\n- 调用者: sctp_close\n- 被调用者: 无\n\n12. 函数名: skb_queue_empty\n- 参数: [struct sk_buff_head *list]\n- 调用者: sctp_close\n- 被调用者: 无\n\n13. 函数名: sock_flag\n- 参数: [struct sock *sk, int flag]\n- 调用者: sctp_close\n- 被调用者: 无\n\n14. 函数名: sctp_make_abort_user\n- 参数: [struct sctp_association *asoc, void *payload, size_t paylen]\n- 调用者: sctp_close\n- 被调用者: 无\n\n15. 函数名: sctp_primitive_ABORT\n- 参数: [struct net *net, struct sctp_association *asoc, struct sctp_chunk *chunk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n16. 函数名: sctp_primitive_SHUTDOWN\n- 参数: [struct net *net, struct sctp_association *asoc, struct sctp_chunk *chunk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n17. 函数名: sctp_wait_for_close\n- 参数: [struct sock *sk, long timeout]\n- 调用者: sctp_close\n- 被调用者: 无\n\n18. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n19. 函数名: spin_lock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: sctp_close\n- 被调用者: 无\n\n20. 函数名: bh_lock_sock_nested\n- 参数: [struct sock *sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n21. 函数名: sock_hold\n- 参数: [struct sock *sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n22. 函数名: sk_common_release\n- 参数: [struct sock *sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n23. 函数名: bh_unlock_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_close\n- 被调用者: 无\n\n24. 函数名: spin_unlock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: sctp_close\n- 被调用者: 无\n\n25. 函数名: sock_put\n- 参数: [struct sock *sk]\n- 调用者: sctp_close\n- 被调用者: 无"
    },
    {
        "id": 2939,
        "cwe": "CWE-362",
        "cve": "CVE-2021-28964",
        "purpose": "Code purpose:\"\"\"该代码用于在Btrfs文件系统中获取旧的根节点，处理树修改日志以支持时间序列查询，但存在竞态条件漏洞可能导致拒绝服务。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在克隆操作前未对extent buffer进行适当的锁定，导致竞态条件可能引发拒绝服务(BUG)。\"\"\"",
        "functions": "Functions:\n1. 函数名: get_old_root\n- 参数: [struct btrfs_root *root, u64 time_seq]\n- 调用者: N/A\n- 被调用者: [btrfs_read_lock_root_node, __tree_mod_log_oldest_root, btrfs_header_level, tree_mod_log_search, btrfs_tree_read_unlock, free_extent_buffer, read_tree_block, WARN_ON, IS_ERR, extent_buffer_uptodate, btrfs_warn, btrfs_clone_extent_buffer, btrfs_header_owner, alloc_dummy_extent_buffer, btrfs_set_header_bytenr, btrfs_set_header_backref_rev, btrfs_set_header_owner, btrfs_set_header_level, btrfs_set_header_generation, btrfs_set_buffer_lockdep_class, btrfs_tree_read_lock, __tree_mod_log_rewind, btrfs_header_nritems, BTRFS_NODEPTRS_PER_BLOCK]\n\n2. 函数名: btrfs_read_lock_root_node\n- 参数: [struct btrfs_root *root]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n3. 函数名: __tree_mod_log_oldest_root\n- 参数: [struct extent_buffer *eb_root, u64 time_seq]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n4. 函数名: btrfs_header_level\n- 参数: [struct extent_buffer *eb]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n5. 函数名: tree_mod_log_search\n- 参数: [struct btrfs_fs_info *fs_info, u64 logical, u64 time_seq]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n6. 函数名: btrfs_tree_read_unlock\n- 参数: [struct extent_buffer *eb]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n7. 函数名: free_extent_buffer\n- 参数: [struct extent_buffer *eb]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n8. 函数名: read_tree_block\n- 参数: [struct btrfs_fs_info *fs_info, u64 logical, u64 objectid, u64 parent_transid, int level, struct btrfs_key *first_key]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n9. 函数名: WARN_ON\n- 参数: [condition]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n10. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n11. 函数名: extent_buffer_uptodate\n- 参数: [struct extent_buffer *eb]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n12. 函数名: btrfs_warn\n- 参数: [struct btrfs_fs_info *fs_info, const char *fmt, ...]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n13. 函数名: btrfs_clone_extent_buffer\n- 参数: [struct extent_buffer *src]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n14. 函数名: btrfs_header_owner\n- 参数: [struct extent_buffer *eb]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n15. 函数名: alloc_dummy_extent_buffer\n- 参数: [struct btrfs_fs_info *fs_info, u64 start]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n16. 函数名: btrfs_set_header_bytenr\n- 参数: [struct extent_buffer *eb, u64 bytenr]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n17. 函数名: btrfs_set_header_backref_rev\n- 参数: [struct extent_buffer *eb, int rev]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n18. 函数名: btrfs_set_header_owner\n- 参数: [struct extent_buffer *eb, u64 owner]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n19. 函数名: btrfs_set_header_level\n- 参数: [struct extent_buffer *eb, int level]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n20. 函数名: btrfs_set_header_generation\n- 参数: [struct extent_buffer *eb, u64 generation]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n21. 函数名: btrfs_set_buffer_lockdep_class\n- 参数: [u64 owner, struct extent_buffer *eb, int level]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n22. 函数名: btrfs_tree_read_lock\n- 参数: [struct extent_buffer *eb]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n23. 函数名: __tree_mod_log_rewind\n- 参数: [struct btrfs_fs_info *fs_info, struct extent_buffer *eb, u64 time_seq, struct tree_mod_elem *tm]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n24. 函数名: btrfs_header_nritems\n- 参数: [struct extent_buffer *eb]\n- 调用者: get_old_root\n- 被调用者: N/A\n\n25. 函数名: BTRFS_NODEPTRS_PER_BLOCK\n- 参数: [struct btrfs_fs_info *fs_info]\n- 调用者: get_old_root\n- 被调用者: N/A"
    },
    {
        "id": 2947,
        "cwe": "CWE-362",
        "cve": "CVE-2021-29265",
        "purpose": "Code purpose:\"\"\"该代码用于管理USB/IP stub设备的socket连接状态，包括建立和断开连接，并处理相关的状态转换和资源分配。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在stub-up过程中对本地和共享状态的更新存在竞态条件，导致可能引发拒绝服务(GPF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: usbip_sockfd_store\n- 参数: [dev, attr, buf, count]\n- 调用者: 未显示（由设备属性子系统调用）\n- 被调用者: [dev_get_drvdata, dev_err, sscanf, dev_info, spin_lock_irq, sockfd_lookup, sockfd_put, spin_unlock_irq, kthread_get_run, usbip_event_add]\n\n2. 函数名: dev_get_drvdata\n- 参数: [dev]\n- 调用者: usbip_sockfd_store\n- 被调用者: []\n\n3. 函数名: dev_err\n- 参数: [dev, format_string]\n- 调用者: usbip_sockfd_store\n- 被调用者: []\n\n4. 函数名: sscanf\n- 参数: [buf, format_string, sockfd]\n- 调用者: usbip_sockfd_store\n- 被调用者: []\n\n5. 函数名: dev_info\n- 参数: [dev, format_string]\n- 调用者: usbip_sockfd_store\n- 被调用者: []\n\n6. 函数名: spin_lock_irq\n- 参数: [&sdev->ud.lock]\n- 调用者: usbip_sockfd_store\n- 被调用者: []\n\n7. 函数名: sockfd_lookup\n- 参数: [sockfd, &err]\n- 调用者: usbip_sockfd_store\n- 被调用者: []\n\n8. 函数名: sockfd_put\n- 参数: [socket]\n- 调用者: usbip_sockfd_store\n- 被调用者: []\n\n9. 函数名: spin_unlock_irq\n- 参数: [&sdev->ud.lock]\n- 调用者: usbip_sockfd_store\n- 被调用者: []\n\n10. 函数名: kthread_get_run\n- 参数: [stub_rx_loop/stub_tx_loop, &sdev->ud, \"stub_rx\"/\"stub_tx\"]\n- 调用者: usbip_sockfd_store\n- 被调用者: []\n\n11. 函数名: usbip_event_add\n- 参数: [&sdev->ud, SDEV_EVENT_DOWN]\n- 调用者: usbip_sockfd_store\n- 被调用者: []"
    },
    {
        "id": 2965,
        "cwe": "CWE-362",
        "cve": "CVE-2021-32399",
        "purpose": "Code purpose:\"\"\"该代码用于在HCI控制器上同步执行请求操作，包括加锁、执行请求和解锁过程，确保对HCI控制器的串行访问。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在HCI控制器移除过程中存在竞争条件，导致在检查HCI_UP标志位和实际执行请求之间可能发生状态变化\"\"\"",
        "functions": "Functions:\n1. 函数名: hci_req_sync\n- 参数: [hdev, req, opt, timeout, hci_status]\n- 调用者: 未显示\n- 被调用者: [test_bit, hci_req_sync_lock, __hci_req_sync, hci_req_sync_unlock]\n\n2. 函数名: test_bit\n- 参数: [HCI_UP, &hdev->flags]\n- 调用者: hci_req_sync\n- 被调用者: 未显示\n\n3. 函数名: hci_req_sync_lock\n- 参数: [hdev]\n- 调用者: hci_req_sync\n- 被调用者: 未显示\n\n4. 函数名: __hci_req_sync\n- 参数: [hdev, req, opt, timeout, hci_status]\n- 调用者: hci_req_sync\n- 被调用者: 未显示\n\n5. 函数名: hci_req_sync_unlock\n- 参数: [hdev]\n- 调用者: hci_req_sync\n- 被调用者: 未显示"
    },
    {
        "id": 2980,
        "cwe": "CWE-362",
        "cve": "CVE-2021-3348",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的NBD(网络块设备)驱动中添加一个新的socket连接，处理设备设置过程中的并发控制和资源分配\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在设备设置过程中存在竞态条件，导致在I/O请求处理时可能发生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nbd_add_socket\n- 参数: [struct nbd_device *nbd, unsigned long arg, bool netlink]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [nbd_get_socket, dev_err, kzalloc, krealloc, kfree, mutex_init, atomic_inc, sockfd_put]\n\n2. 函数名: nbd_get_socket\n- 参数: [struct nbd_device *nbd, unsigned long arg, int *err]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确（代码片段中未显示）\n\n3. 函数名: dev_err\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确（标准内核函数）\n\n4. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确（标准内核函数）\n\n5. 函数名: krealloc\n- 参数: [const void *p, size_t new_size, gfp_t flags]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确（标准内核函数）\n\n6. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确（标准内核函数）\n\n7. 函数名: mutex_init\n- 参数: [struct mutex *lock]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确（标准内核函数）\n\n8. 函数名: atomic_inc\n- 参数: [atomic_t *v]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确（标准内核函数）\n\n9. 函数名: sockfd_put\n- 参数: [struct socket *sock]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确（标准内核函数）"
    },
    {
        "id": 3019,
        "cwe": "CWE-362",
        "cve": "CVE-2021-3573",
        "purpose": "Code purpose:\"\"\"处理HCI设备事件并管理相关套接字连接，包括监控事件发送、设备状态变更通知和套接字分离操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于hci_sock_dev_event函数在处理设备注销事件时存在竞态条件，导致在释放hdev设备后仍可能被其他操作引用，造成释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: hci_sock_dev_event\n- 参数: [struct hci_dev *hdev, int event]\n- 调用者: 未显示\n- 被调用者: [atomic_read, create_monitor_event, hci_send_to_channel, kfree_skb, hci_si_event, read_lock, sk_for_each, bh_lock_sock_nested, hci_pi, sk->sk_state_change, hci_dev_put, bh_unlock_sock, read_unlock]\n\n2. 函数名: atomic_read\n- 参数: [&monitor_promisc]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n3. 函数名: create_monitor_event\n- 参数: [hdev, event]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n4. 函数名: hci_send_to_channel\n- 参数: [HCI_CHANNEL_MONITOR, skb, HCI_SOCK_TRUSTED, NULL]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n5. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n6. 函数名: hci_si_event\n- 参数: [NULL, HCI_EV_SI_DEVICE, sizeof(ev), &ev]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n7. 函数名: read_lock\n- 参数: [&hci_sk_list.lock]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n8. 函数名: sk_for_each\n- 参数: [sk, &hci_sk_list.head]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n9. 函数名: bh_lock_sock_nested\n- 参数: [sk]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n10. 函数名: hci_pi\n- 参数: [sk]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n11. 函数名: sk->sk_state_change\n- 参数: [sk]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n12. 函数名: hci_dev_put\n- 参数: [hdev]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n13. 函数名: bh_unlock_sock\n- 参数: [sk]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示\n\n14. 函数名: read_unlock\n- 参数: [&hci_sk_list.lock]\n- 调用者: hci_sock_dev_event\n- 被调用者: 未显示"
    },
    {
        "id": 3021,
        "cwe": "CWE-362",
        "cve": "CVE-2021-3609",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中CAN BCM网络协议的socket释放功能，包括移除相关操作、定时器、取消注册等清理工作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中CAN BCM网络协议存在竞态条件漏洞，当本地攻击者利用bcm_release函数中的锁机制缺陷时，可导致内存损坏、系统崩溃或权限提升\"\"\"",
        "functions": "Functions:\n1. 函数名: bcm_release\n- 参数: [struct socket *sock]\n- 调用者: 无（系统调用或内核其他部分调用）\n- 被调用者: [sock_net, bcm_sk, spin_lock, spin_unlock, schedule_timeout_uninterruptible, list_del, lock_sock, list_for_each_entry_safe, bcm_remove_op, dev_get_by_index, bcm_rx_unreg, dev_put, can_rx_unregister, remove_proc_entry, sock_orphan, release_sock, sock_put]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: bcm_release\n- 被调用者: 无\n\n3. 函数名: bcm_sk\n- 参数: [struct sock *sk]\n- 调用者: bcm_release\n- 被调用者: 无\n\n4. 函数名: spin_lock\n- 参数: [&bcm_notifier_lock]\n- 调用者: bcm_release\n- 被调用者: 无\n\n5. 函数名: spin_unlock\n- 参数: [&bcm_notifier_lock]\n- 调用者: bcm_release\n- 被调用者: 无\n\n6. 函数名: schedule_timeout_uninterruptible\n- 参数: [1]\n- 调用者: bcm_release\n- 被调用者: 无\n\n7. 函数名: list_del\n- 参数: [&bo->notifier]\n- 调用者: bcm_release\n- 被调用者: 无\n\n8. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: bcm_release\n- 被调用者: 无\n\n9. 函数名: list_for_each_entry_safe\n- 参数: [op, next, &bo->tx_ops, list]\n- 调用者: bcm_release\n- 被调用者: 无\n\n10. 函数名: bcm_remove_op\n- 参数: [struct bcm_op *op]\n- 调用者: bcm_release\n- 被调用者: 无\n\n11. 函数名: dev_get_by_index\n- 参数: [net, op->ifindex]\n- 调用者: bcm_release\n- 被调用者: 无\n\n12. 函数名: bcm_rx_unreg\n- 参数: [dev, op]\n- 调用者: bcm_release\n- 被调用者: 无\n\n13. 函数名: dev_put\n- 参数: [dev]\n- 调用者: bcm_release\n- 被调用者: 无\n\n14. 函数名: can_rx_unregister\n- 参数: [net, NULL, op->can_id, REGMASK(op->can_id), bcm_rx_handler, op]\n- 调用者: bcm_release\n- 被调用者: 无\n\n15. 函数名: remove_proc_entry\n- 参数: [bo->procname, net->can.bcmproc_dir]\n- 调用者: bcm_release\n- 被调用者: 无\n\n16. 函数名: sock_orphan\n- 参数: [sk]\n- 调用者: bcm_release\n- 被调用者: 无\n\n17. 函数名: release_sock\n- 参数: [sk]\n- 调用者: bcm_release\n- 被调用者: 无\n\n18. 函数名: sock_put\n- 参数: [sk]\n- 调用者: bcm_release\n- 被调用者: 无"
    },
    {
        "id": 3022,
        "cwe": "CWE-362",
        "cve": "CVE-2021-3609",
        "purpose": "Code purpose:\"\"\"该代码用于在CAN BCM协议中删除与指定条件匹配的接收操作，包括取消相关网络设备的注册和清理操作资源。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在删除CAN BCM协议中的接收操作时存在竞态条件，导致本地攻击者可能利用此条件破坏内存、使系统崩溃或提升权限\"\"\"",
        "functions": "Functions:\n1. 函数名: bcm_delete_rx_op\n- 参数: [ops, mh, ifindex]\n- 调用者: 未显示在代码片段中\n- 被调用者: [dev_get_by_index, bcm_rx_unreg, dev_put, can_rx_unregister, list_del, bcm_remove_op]\n\n2. 函数名: dev_get_by_index\n- 参数: [sock_net(op->sk), op->ifindex]\n- 调用者: bcm_delete_rx_op\n- 被调用者: 未显示在代码片段中\n\n3. 函数名: bcm_rx_unreg\n- 参数: [dev, op]\n- 调用者: bcm_delete_rx_op\n- 被调用者: 未显示在代码片段中\n\n4. 函数名: dev_put\n- 参数: [dev]\n- 调用者: bcm_delete_rx_op\n- 被调用者: 未显示在代码片段中\n\n5. 函数名: can_rx_unregister\n- 参数: [sock_net(op->sk), NULL, op->can_id, REGMASK(op->can_id), bcm_rx_handler, op]\n- 调用者: bcm_delete_rx_op\n- 被调用者: 未显示在代码片段中\n\n6. 函数名: list_del\n- 参数: [&op->list]\n- 调用者: bcm_delete_rx_op\n- 被调用者: 未显示在代码片段中\n\n7. 函数名: bcm_remove_op\n- 参数: [op]\n- 调用者: bcm_delete_rx_op\n- 被调用者: 未显示在代码片段中"
    },
    {
        "id": 3026,
        "cwe": "CWE-362",
        "cve": "CVE-2021-3640",
        "purpose": "Code purpose:\"\"\"该代码实现了蓝牙HCI子系统中SCO socket的消息发送功能，处理连接状态检查并发送数据帧。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在sco_sock_sendmsg()函数中存在竞态条件，当sco_conn_del()与sco_sock_sendmsg()同时被调用时，可能导致释放后使用(UAF)的内存错误。\"\"\"",
        "functions": "Functions:\n1. 函数名: sco_sock_sendmsg\n- 参数: [sock, msg, len]\n- 调用者: 未明确显示（由内核调用）\n- 被调用者: [sock_error, lock_sock, sco_send_frame, release_sock]\n\n2. 函数名: sock_error\n- 参数: [sk]\n- 调用者: sco_sock_sendmsg\n- 被调用者: []\n\n3. 函数名: lock_sock\n- 参数: [sk]\n- 调用者: sco_sock_sendmsg\n- 被调用者: []\n\n4. 函数名: sco_send_frame\n- 参数: [sk, msg, len]\n- 调用者: sco_sock_sendmsg\n- 被调用者: []\n\n5. 函数名: release_sock\n- 参数: [sk]\n- 调用者: sco_sock_sendmsg\n- 被调用者: []"
    },
    {
        "id": 3053,
        "cwe": "CWE-362",
        "cve": "CVE-2021-3752",
        "purpose": "Code purpose:\"\"\"在蓝牙子系统中处理L2CAP通道关闭时释放相关socket资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于蓝牙子系统中存在竞态条件，当用户同时调用连接和断开套接字操作时，会导致释放后重用(use-after-free)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_sock_close_cb\n- 参数: [struct l2cap_chan *chan]\n- 调用者: 未明确（由Linux内核蓝牙子系统调用）\n- 被调用者: [l2cap_sock_kill]\n\n2. 函数名: l2cap_sock_kill\n- 参数: [struct sock *sk]\n- 调用者: l2cap_sock_close_cb\n- 被调用者: []"
    },
    {
        "id": 3054,
        "cwe": "CWE-362",
        "cve": "CVE-2021-3752",
        "purpose": "Code purpose:\"\"\"在蓝牙子系统中处理L2CAP套接字销毁时的资源清理工作，包括释放通道和清空接收/发送队列\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于Linux内核蓝牙子系统中存在竞态条件，当用户同时调用socket连接和断开操作时会导致释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_sock_destruct\n- 参数: [struct sock *sk]\n- 调用者: 不适用（通常由内核调用）\n- 被调用者: [l2cap_pi, BT_DBG, l2cap_chan_put, kfree_skb, skb_queue_purge]\n\n2. 函数名: l2cap_pi\n- 参数: [struct sock *sk]\n- 调用者: l2cap_sock_destruct\n- 被调用者: []\n\n3. 函数名: BT_DBG\n- 参数: [\"sk %p\", sk]\n- 调用者: l2cap_sock_destruct\n- 被调用者: []\n\n4. 函数名: l2cap_chan_put\n- 参数: [l2cap_pi(sk)->chan]\n- 调用者: l2cap_sock_destruct\n- 被调用者: []\n\n5. 函数名: kfree_skb\n- 参数: [l2cap_pi(sk)->rx_busy_skb]\n- 调用者: l2cap_sock_destruct\n- 被调用者: []\n\n6. 函数名: skb_queue_purge\n- 参数: [&sk->sk_receive_queue, &sk->sk_write_queue]\n- 调用者: l2cap_sock_destruct\n- 被调用者: []"
    },
    {
        "id": 3055,
        "cwe": "CWE-362",
        "cve": "CVE-2021-3752",
        "purpose": "Code purpose:\"\"\"处理L2CAP通道的关闭和清理操作，包括监听和非监听状态的套接字，确保资源正确释放并避免竞态条件。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在蓝牙子系统的套接字拆卸回调函数中存在竞态条件，当用户同时调用连接和断开操作时可能导致释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_sock_teardown_cb\n- 参数: [struct l2cap_chan *chan, int err]\n- 调用者: 未明确显示（由蓝牙子系统调用）\n- 被调用者: [lock_sock_nested, bt_sk, l2cap_sock_cleanup_listen, bt_accept_unlink, release_sock, sock_set_flag]\n\n2. 函数名: lock_sock_nested\n- 参数: [struct sock *sk, int subclass]\n- 调用者: l2cap_sock_teardown_cb\n- 被调用者: []\n\n3. 函数名: bt_sk\n- 参数: [struct sock *sk]\n- 调用者: l2cap_sock_teardown_cb\n- 被调用者: []\n\n4. 函数名: l2cap_sock_cleanup_listen\n- 参数: [struct sock *sk]\n- 调用者: l2cap_sock_teardown_cb\n- 被调用者: []\n\n5. 函数名: bt_accept_unlink\n- 参数: [struct sock *sk]\n- 调用者: l2cap_sock_teardown_cb\n- 被调用者: []\n\n6. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: l2cap_sock_teardown_cb\n- 被调用者: []\n\n7. 函数名: sock_set_flag\n- 参数: [struct sock *sk, enum sock_flags flag]\n- 调用者: l2cap_sock_teardown_cb\n- 被调用者: []"
    },
    {
        "id": 3093,
        "cwe": "CWE-362",
        "cve": "CVE-2021-39648",
        "purpose": "Code purpose:\"\"\"该代码片段用于显示USB gadget驱动程序中UDC（USB Device Controller）的名称，可能因竞态条件导致内核堆内存信息泄露。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于存在竞态条件，在读取udc_name时可能导致内核堆内存信息泄露\"\"\"",
        "functions": "Functions:\n1. 函数名: gadget_dev_desc_UDC_show\n- 参数: [struct config_item *item, char *page]\n- 调用者: 未明确（由configfs子系统调用）\n- 被调用者: [to_gadget_info, sprintf]\n\n2. 函数名: to_gadget_info\n- 参数: [struct config_item *item]\n- 调用者: gadget_dev_desc_UDC_show\n- 被调用者: []\n\n3. 函数名: sprintf\n- 参数: [char *page, const char *format, char *udc_name]\n- 调用者: gadget_dev_desc_UDC_show\n- 被调用者: []"
    },
    {
        "id": 3099,
        "cwe": "CWE-362",
        "cve": "CVE-2021-39686",
        "purpose": "Code purpose:\"\"\"释放binder进程资源并处理相关设备引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于竞态条件导致在多个binder.c函数中可能向SELinux传递错误的域，造成本地权限提升漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_free_proc\n- 参数: [struct binder_proc *proc]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [container_of, refcount_dec_and_test, kfree, binder_alloc_deferred_release, put_task_struct, binder_stats_deleted]\n\n2. 函数名: container_of\n- 参数: [proc->context, struct binder_device, context]\n- 调用者: binder_free_proc\n- 被调用者: 未明确（通常是宏或内联函数）\n\n3. 函数名: refcount_dec_and_test\n- 参数: [&device->ref]\n- 调用者: binder_free_proc\n- 被调用者: 未明确（通常是原子操作函数）\n\n4. 函数名: kfree\n- 参数: [proc->context->name], [device]\n- 调用者: binder_free_proc\n- 被调用者: 未明确（内核内存释放函数）\n\n5. 函数名: binder_alloc_deferred_release\n- 参数: [&proc->alloc]\n- 调用者: binder_free_proc\n- 被调用者: 未明确（上下文未提供）\n\n6. 函数名: put_task_struct\n- 参数: [proc->tsk]\n- 调用者: binder_free_proc\n- 被调用者: 未明确（内核任务结构释放函数）\n\n7. 函数名: binder_stats_deleted\n- 参数: [BINDER_STAT_PROC]\n- 调用者: binder_free_proc\n- 被调用者: 未明确（上下文未提供）"
    },
    {
        "id": 3100,
        "cwe": "CWE-362",
        "cve": "CVE-2021-39686",
        "purpose": "Code purpose:\"\"\"处理Android Binder进程间通信(IPC)中的事务传输，包括事务的创建、处理、错误检查和安全上下文管理等核心功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于竞态条件导致在多个binder.c函数中可能向SELinux表示错误的域，从而引发本地权限提升漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_transaction\n- 参数: [struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply, binder_size_t extra_buffers_size]\n- 调用者: N/A (top-level function)\n- 被调用者: [binder_transaction_log_add, atomic_inc_return, strscpy, binder_inner_proc_lock, binder_inner_proc_unlock, binder_user_error, binder_set_nice, binder_get_txn_from_and_acq_inner, binder_proc_lock, binder_get_ref_olocked, binder_get_node_refs_for_txn, binder_proc_unlock, mutex_lock, mutex_unlock, security_binder_transaction, list_first_entry_or_null, spin_lock, spin_unlock, atomic_inc, kzalloc, binder_stats_created, spin_lock_init, binder_debug, task_euid, task_nice, security_task_getsecid_obj, security_secid_to_secctx, ALIGN, security_release_secctx, trace_binder_transaction, binder_alloc_new_buf, IS_ERR, PTR_ERR, binder_alloc_copy_to_buffer, binder_alloc_copy_user_to_buffer, IS_ALIGNED, binder_get_object, binder_translate_binder, binder_translate_handle, binder_translate_fd, binder_validate_ptr, binder_validate_fixup, binder_translate_fd_array, binder_fixup_parent, binder_enqueue_thread_work, binder_pop_transaction_ilocked, binder_enqueue_thread_work_ilocked, wake_up_interruptible_sync, binder_free_transaction, binder_enqueue_deferred_thread_work_ilocked, binder_proc_transaction, binder_pop_transaction_ilocked, binder_thread_dec_tmpref, binder_proc_dec_tmpref, binder_dec_node_tmpref, smp_wmb, WRITE_ONCE, binder_dequeue_work, binder_free_txn_fixups, trace_binder_transaction_failed_buffer_release, binder_transaction_buffer_release, binder_alloc_free_buf, kfree, binder_stats_deleted, binder_txn_latency_free, binder_dec_node, binder_send_failed_reply]\n\n2. 函数名: binder_transaction_log_add\n- 参数: [struct binder_transaction_log *log]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n3. 函数名: atomic_inc_return\n- 参数: [atomic_t *v]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n4. 函数名: strscpy\n- 参数: [char *dest, const char *src, size_t count]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n5. 函数名: binder_inner_proc_lock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n6. 函数名: binder_inner_proc_unlock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n7. 函数名: binder_user_error\n- 参数: [const char *fmt, ...]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n8. 函数名: binder_set_nice\n- 参数: [long nice]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n9. 函数名: binder_get_txn_from_and_acq_inner\n- 参数: [struct binder_transaction *t]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n10. 函数名: binder_proc_lock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n11. 函数名: binder_get_ref_olocked\n- 参数: [struct binder_proc *proc, uint32_t desc, bool strong]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n12. 函数名: binder_get_node_refs_for_txn\n- 参数: [struct binder_node *node, struct binder_proc **procp, uint32_t *error]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n13. 函数名: binder_proc_unlock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n14. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n15. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n16. 函数名: security_binder_transaction\n- 参数: [struct task_struct *from, struct task_struct *to]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n17. 函数名: list_first_entry_or_null\n- 参数: [struct list_head *head, size_t offset, typeof(*ptr)]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n18. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n19. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n20. 函数名: atomic_inc\n- 参数: [atomic_t *v]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n21. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n22. 函数名: binder_stats_created\n- 参数: [enum binder_stat_types type]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n23. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n24. 函数名: binder_debug\n- 参数: [unsigned int mask, const char *format, ...]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n25. 函数名: task_euid\n- 参数: [struct task_struct *task]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n26. 函数名: task_nice\n- 参数: [struct task_struct *task]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n27. 函数名: security_task_getsecid_obj\n- 参数: [struct task_struct *task, u32 *secid]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n28. 函数名: security_secid_to_secctx\n- 参数: [u32 secid, char **secdata, u32 *seclen]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n29. 函数名: security_release_secctx\n- 参数: [char *secdata, u32 seclen]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n30. 函数名: trace_binder_transaction\n- 参数: [int reply, struct binder_transaction *t, struct binder_node *target_node]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n31. 函数名: binder_alloc_new_buf\n- 参数: [struct binder_alloc *alloc, size_t data_size, size_t offsets_size, size_t extra_buffers_size, int is_async, pid_t pid]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n32. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n33. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n34. 函数名: binder_alloc_copy_to_buffer\n- 参数: [struct binder_alloc *alloc, struct binder_buffer *buffer, binder_size_t buffer_offset, const void *src, size_t bytes]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n35. 函数名: binder_alloc_copy_user_to_buffer\n- 参数: [struct binder_alloc *alloc, struct binder_buffer *buffer, binder_size_t buffer_offset, const void __user *from, size_t bytes]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n36. 函数名: binder_get_object\n- 参数: [struct binder_proc *proc, struct binder_buffer *buffer, binder_size_t offset, struct binder_object *object]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n37. 函数名: binder_translate_binder\n- 参数: [struct flat_binder_object *fp, struct binder_transaction *t, struct binder_thread *thread]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n38. 函数名: binder_translate_handle\n- 参数: [struct flat_binder_object *fp, struct binder_transaction *t, struct binder_thread *thread]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n39. 函数名: binder_translate_fd\n- 参数: [int fd, binder_size_t fd_offset, struct binder_transaction *t, struct binder_thread *thread, struct binder_transaction *in_reply_to]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n40. 函数名: binder_validate_ptr\n- 参数: [struct binder_proc *proc, struct binder_buffer *buffer, struct binder_object *object, binder_size_t ptr, binder_size_t off_start_offset, binder_size_t *offp, size_t num_valid]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n41. 函数名: binder_validate_fixup\n- 参数: [struct binder_proc *proc, struct binder_buffer *buffer, binder_size_t off_start_offset, binder_size_t object_offset, binder_size_t fixup_offset, binder_size_t last_obj_offset, binder_size_t last_min_offset]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n42. 函数名: binder_translate_fd_array\n- 参数: [struct binder_fd_array_object *fda, struct binder_buffer_object *parent, struct binder_transaction *t, struct binder_thread *thread, struct binder_transaction *in_reply_to]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n43. 函数名: binder_fixup_parent\n- 参数: [struct binder_transaction *t, struct binder_thread *thread, struct binder_buffer_object *bp, binder_size_t off_start_offset, size_t num_valid, binder_size_t last_fixup_obj_off, binder_size_t last_fixup_min_off]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n44. 函数名: binder_enqueue_thread_work\n- 参数: [struct binder_thread *thread, struct binder_work *work]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n45. 函数名: binder_pop_transaction_ilocked\n- 参数: [struct binder_thread *thread, struct binder_transaction *t]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n46. 函数名: binder_enqueue_thread_work_ilocked\n- 参数: [struct binder_thread *thread, struct binder_work *work]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n47. 函数名: wake_up_interruptible_sync\n- 参数: [wait_queue_head_t *q]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n48. 函数名: binder_free_transaction\n- 参数: [struct binder_transaction *t]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n49. 函数名: binder_enqueue_deferred_thread_work_ilocked\n- 参数: [struct binder_thread *thread, struct binder_work *work]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n50. 函数名: binder_proc_transaction\n- 参数: [struct binder_transaction *t, struct binder_proc *target_proc, struct binder_thread *target_thread]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n51. 函数名: binder_thread_dec_tmpref\n- 参数: [struct binder_thread *thread]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n52. 函数名: binder_proc_dec_tmpref\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n53. 函数名: binder_dec_node_tmpref\n- 参数: [struct binder_node *node]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n54. 函数名: binder_dequeue_work\n- 参数: [struct binder_proc *proc, struct binder_work *work]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n55. 函数名: binder_free_txn_fixups\n- 参数: [struct binder_transaction *t]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n56. 函数名: binder_transaction_buffer_release\n- 参数: [struct binder_proc *proc, struct binder_buffer *buffer, binder_size_t off_end_offset, bool is_failure]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n57. 函数名: binder_alloc_free_buf\n- 参数: [struct binder_alloc *alloc, struct binder_buffer *buffer]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n58. 函数名: binder_dec_node\n- 参数: [struct binder_node *node, int strong, int internal]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n59. 函数名: binder_send_failed_reply\n- 参数: [struct binder_transaction *t, uint32_t error_code]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n60. 函数名: binder_txn_latency_free\n- 参数: [struct binder_transaction *t]\n- 调用者: binder_transaction\n- 被调用者: N/A"
    },
    {
        "id": 3101,
        "cwe": "CWE-362",
        "cve": "CVE-2021-39686",
        "purpose": "Code purpose:\"\"\"该代码实现了Android Binder驱动中的open操作，用于创建并初始化一个新的Binder进程上下文，并将其添加到全局进程列表中，同时处理相关的debugfs和binderfs文件系统条目创建。\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于竞态条件导致在多个binder.c函数中可能向SELinux表示错误的域\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_open\n- 参数: [struct inode *nodp, struct file *filp]\n- 调用者: 未显示（通常由文件系统操作调用）\n- 被调用者: [kzalloc, spin_lock_init, get_task_struct, INIT_LIST_HEAD, init_waitqueue_head, task_nice, is_binderfs_device, container_of, refcount_inc, binder_alloc_init, binder_stats_created, mutex_lock, hlist_for_each_entry, hlist_add_head, mutex_unlock, snprintf, debugfs_create_file, binderfs_create_file, pr_warn]\n\n2. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: binder_open\n- 被调用者: []\n\n3. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: binder_open\n- 被调用者: []\n\n4. 函数名: get_task_struct\n- 参数: [struct task_struct *t]\n- 调用者: binder_open\n- 被调用者: []\n\n5. 函数名: INIT_LIST_HEAD\n- 参数: [struct list_head *list]\n- 调用者: binder_open\n- 被调用者: []\n\n6. 函数名: init_waitqueue_head\n- 参数: [wait_queue_head_t *q]\n- 调用者: binder_open\n- 被调用者: []\n\n7. 函数名: task_nice\n- 参数: [struct task_struct *p]\n- 调用者: binder_open\n- 被调用者: []\n\n8. 函数名: is_binderfs_device\n- 参数: [struct inode *nodp]\n- 调用者: binder_open\n- 被调用者: []\n\n9. 函数名: container_of\n- 参数: [void *ptr, type, member]\n- 调用者: binder_open\n- 被调用者: []\n\n10. 函数名: refcount_inc\n- 参数: [refcount_t *r]\n- 调用者: binder_open\n- 被调用者: []\n\n11. 函数名: binder_alloc_init\n- 参数: [struct binder_alloc *alloc]\n- 调用者: binder_open\n- 被调用者: []\n\n12. 函数名: binder_stats_created\n- 参数: [enum binder_stat_types type]\n- 调用者: binder_open\n- 被调用者: []\n\n13. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: binder_open\n- 被调用者: []\n\n14. 函数名: hlist_for_each_entry\n- 参数: [type *pos, struct hlist_head *head, member]\n- 调用者: binder_open\n- 被调用者: []\n\n15. 函数名: hlist_add_head\n- 参数: [struct hlist_node *n, struct hlist_head *h]\n- 调用者: binder_open\n- 被调用者: []\n\n16. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: binder_open\n- 被调用者: []\n\n17. 函数名: snprintf\n- 参数: [char *str, size_t size, const char *format, ...]\n- 调用者: binder_open\n- 被调用者: []\n\n18. 函数名: debugfs_create_file\n- 参数: [const char *name, umode_t mode, struct dentry *parent, void *data, const struct file_operations *fops]\n- 调用者: binder_open\n- 被调用者: []\n\n19. 函数名: binderfs_create_file\n- 参数: [struct dentry *dir, const char *name, const struct file_operations *fops, void *data]\n- 调用者: binder_open\n- 被调用者: []\n\n20. 函数名: pr_warn\n- 参数: [const char *fmt, ...]\n- 调用者: binder_open\n- 被调用者: []"
    },
    {
        "id": 3103,
        "cwe": "CWE-362",
        "cve": "CVE-2021-39713",
        "purpose": "Code purpose:\"\"\"该代码用于处理网络流量控制中的过滤器获取请求，包括验证参数、查找指定过滤器链和过滤器，并返回结果或错误信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发环境下未正确管理tcf_chain引用计数，导致竞争条件下可能释放仍在使用的资源\"\"\"",
        "functions": "Functions:\n1. 函数名: tc_get_tfilter\n- 参数: [struct sk_buff *skb, struct nlmsghdr *n, struct netlink_ext_ack *extack]\n- 调用者: 未显示\n- 被调用者: [nlmsg_parse, nlmsg_data, tcf_block_find, nla_get_u32, tcf_chain_get, tcf_chain_tp_find, nla_strcmp, tp->ops->get, tfilter_notify, tcf_chain_put]\n\n2. 函数名: nlmsg_parse\n- 参数: [struct nlmsghdr *n, int sizeof_t, struct nlattr *tca[], int TCA_MAX, NULL, struct netlink_ext_ack *extack]\n- 调用者: tc_get_tfilter\n- 被调用者: 未显示\n\n3. 函数名: nlmsg_data\n- 参数: [struct nlmsghdr *n]\n- 调用者: tc_get_tfilter\n- 被调用者: 未显示\n\n4. 函数名: tcf_block_find\n- 参数: [struct net *net, struct Qdisc **q, u32 *parent, unsigned long *cl, int tcm_ifindex, int tcm_block_index, struct netlink_ext_ack *extack]\n- 调用者: tc_get_tfilter\n- 被调用者: 未显示\n\n5. 函数名: nla_get_u32\n- 参数: [struct nlattr *tca[TCA_CHAIN]]\n- 调用者: tc_get_tfilter\n- 被调用者: 未显示\n\n6. 函数名: tcf_chain_get\n- 参数: [struct tcf_block *block, u32 chain_index, bool false]\n- 调用者: tc_get_tfilter\n- 被调用者: 未显示\n\n7. 函数名: tcf_chain_tp_find\n- 参数: [struct tcf_chain *chain, struct tcf_chain_info *chain_info, u32 protocol, u32 prio, bool false]\n- 调用者: tc_get_tfilter\n- 被调用者: 未显示\n\n8. 函数名: nla_strcmp\n- 参数: [struct nlattr *tca[TCA_KIND], char *tp->ops->kind]\n- 调用者: tc_get_tfilter\n- 被调用者: 未显示\n\n9. 函数名: tp->ops->get\n- 参数: [struct tcf_proto *tp, u32 t->tcm_handle]\n- 调用者: tc_get_tfilter\n- 被调用者: 未显示\n\n10. 函数名: tfilter_notify\n- 参数: [struct net *net, struct sk_buff *skb, struct nlmsghdr *n, struct tcf_proto *tp, struct tcf_block *block, struct Qdisc *q, u32 parent, void *fh, int RTM_NEWTFILTER, bool true]\n- 调用者: tc_get_tfilter\n- 被调用者: 未显示\n\n11. 函数名: tcf_chain_put\n- 参数: [struct tcf_chain *chain]\n- 调用者: tc_get_tfilter\n- 被调用者: 未显示"
    },
    {
        "id": 3104,
        "cwe": "CWE-362",
        "cve": "CVE-2021-39713",
        "purpose": "Code purpose:\"\"\"该代码用于在网络设备中查找和验证指定的流量控制块(tcf_block)，并根据不同的条件(如接口索引、父级Qdisc等)返回相应的块或错误信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于代码中缺少对并发访问共享资源(block)的适当保护，导致存在竞争条件漏洞(CWE-362)。\"\"\"",
        "functions": "Functions:\n1. 函数名: tcf_block_find\n- 参数: [net, q, parent, cl, ifindex, block_index, extack]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [tcf_block_lookup, __dev_get_by_index, qdisc_lookup, cops->find, cops->tcf_block, tcf_block_shared, NL_SET_ERR_MSG, ERR_PTR]\n\n2. 函数名: tcf_block_lookup\n- 参数: [net, block_index]\n- 调用者: tcf_block_find\n- 被调用者: 未明确\n\n3. 函数名: __dev_get_by_index\n- 参数: [net, ifindex]\n- 调用者: tcf_block_find\n- 被调用者: 未明确\n\n4. 函数名: qdisc_lookup\n- 参数: [dev, TC_H_MAJ(*parent)]\n- 调用者: tcf_block_find\n- 被调用者: 未明确\n\n5. 函数名: cops->find\n- 参数: [*q, *parent]\n- 调用者: tcf_block_find\n- 被调用者: 未明确\n\n6. 函数名: cops->tcf_block\n- 参数: [*q, *cl, extack]\n- 调用者: tcf_block_find\n- 被调用者: 未明确\n\n7. 函数名: tcf_block_shared\n- 参数: [block]\n- 调用者: tcf_block_find\n- 被调用者: 未明确\n\n8. 函数名: NL_SET_ERR_MSG\n- 参数: [extack, \"error message\"]\n- 调用者: tcf_block_find\n- 被调用者: 未明确\n\n9. 函数名: ERR_PTR\n- 参数: [error_code]\n- 调用者: tcf_block_find\n- 被调用者: 未明确"
    },
    {
        "id": 3105,
        "cwe": "CWE-362",
        "cve": "CVE-2021-39713",
        "purpose": "Code purpose:\"\"\"该代码实现了通过Netlink消息删除网络流量控制过滤器的功能，包括查找、验证和删除指定的过滤器链或单个过滤器。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在tc_del_tfilter函数中，当处理过滤器删除操作时，未能正确验证和处理并发情况下的资源访问，导致存在竞争条件漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: tc_del_tfilter\n- 参数: [struct sk_buff *skb, struct nlmsghdr *n, struct netlink_ext_ack *extack]\n- 调用者: (未显示)\n- 被调用者: [sock_net, netlink_ns_capable, nlmsg_parse, nlmsg_data, tcf_block_find, nla_get_u32, tcf_chain_get, tfilter_notify_chain, tcf_chain_flush, tcf_chain_tp_find, nla_strcmp, tp->ops->get, tcf_chain_tp_remove, tfilter_notify, tcf_proto_destroy, tfilter_del_notify, tcf_chain_put]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n3. 函数名: netlink_ns_capable\n- 参数: [struct sk_buff *skb, struct user_namespace *ns, int cap]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n4. 函数名: nlmsg_parse\n- 参数: [struct nlmsghdr *nlh, int hdrlen, struct nlattr *tb[], int maxtype, const struct nla_policy *policy, struct netlink_ext_ack *extack]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n5. 函数名: nlmsg_data\n- 参数: [struct nlmsghdr *nlh]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n6. 函数名: tcf_block_find\n- 参数: [struct net *net, struct Qdisc **q, u32 *parent, unsigned long *cl, int ifindex, u32 block_index, struct netlink_ext_ack *extack]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n7. 函数名: nla_get_u32\n- 参数: [const struct nlattr *nla]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n8. 函数名: tcf_chain_get\n- 参数: [struct tcf_block *block, u32 chain_index, bool create]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n9. 函数名: tfilter_notify_chain\n- 参数: [struct net *net, struct sk_buff *oskb, struct tcf_block *block, struct Qdisc *q, u32 parent, struct nlmsghdr *n, struct tcf_chain *chain, int event]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n10. 函数名: tcf_chain_flush\n- 参数: [struct tcf_chain *chain]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n11. 函数名: tcf_chain_tp_find\n- 参数: [struct tcf_chain *chain, struct tcf_chain_info *chain_info, u32 protocol, u32 prio, bool prio_allocate]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n12. 函数名: nla_strcmp\n- 参数: [const struct nlattr *nla, const char *str]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n13. 函数名: tp->ops->get\n- 参数: [struct tcf_proto *tp, u32 handle]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n14. 函数名: tcf_chain_tp_remove\n- 参数: [struct tcf_chain *chain, struct tcf_chain_info *chain_info, struct tcf_proto *tp]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n15. 函数名: tfilter_notify\n- 参数: [struct net *net, struct sk_buff *oskb, struct nlmsghdr *n, struct tcf_proto *tp, struct tcf_block *block, struct Qdisc *q, u32 parent, void *fh, int event, bool unicast]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n16. 函数名: tcf_proto_destroy\n- 参数: [struct tcf_proto *tp, struct netlink_ext_ack *extack]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n17. 函数名: tfilter_del_notify\n- 参数: [struct net *net, struct sk_buff *oskb, struct nlmsghdr *n, struct tcf_proto *tp, struct tcf_block *block, struct Qdisc *q, u32 parent, void *fh, bool unicast, bool *last, struct netlink_ext_ack *extack]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)\n\n18. 函数名: tcf_chain_put\n- 参数: [struct tcf_chain *chain]\n- 调用者: tc_del_tfilter\n- 被调用者: (未显示)"
    },
    {
        "id": 3106,
        "cwe": "CWE-362",
        "cve": "CVE-2021-39713",
        "purpose": "Code purpose:\"\"\"处理网络流量控制中新过滤器的创建和修改请求\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于代码中存在竞争条件，当多个线程同时访问和修改共享资源时，可能导致资源管理不当或状态不一致\"\"\"",
        "functions": "Functions:\n1. 函数名: tc_new_tfilter\n- 参数: [struct sk_buff *skb, struct nlmsghdr *n, struct netlink_ext_ack *extack]\n- 调用者: 未显示\n- 被调用者: [sock_net, netlink_ns_capable, nlmsg_parse, nlmsg_data, tcf_block_find, nla_get_u32, tcf_chain_get, tcf_chain_tp_find, tcf_auto_prio, tcf_chain_tp_prev, tcf_proto_create, nla_strcmp, tp->ops->get, tp->ops->change, tcf_chain_tp_insert, tfilter_notify, tcf_proto_destroy, tcf_chain_put]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n3. 函数名: netlink_ns_capable\n- 参数: [struct sk_buff *skb, struct user_namespace *ns, int cap]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n4. 函数名: nlmsg_parse\n- 参数: [struct nlmsghdr *nlh, int hdrlen, struct nlattr *tb[], int maxtype, const struct nla_policy *policy, struct netlink_ext_ack *extack]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n5. 函数名: nlmsg_data\n- 参数: [struct nlmsghdr *nlh]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n6. 函数名: tcf_block_find\n- 参数: [struct net *net, struct Qdisc **q, u32 *parent, unsigned long *cl, int ifindex, u32 block_index, struct netlink_ext_ack *extack]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n7. 函数名: nla_get_u32\n- 参数: [const struct nlattr *nla]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n8. 函数名: tcf_chain_get\n- 参数: [struct tcf_block *block, u32 chain_index, bool create]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n9. 函数名: tcf_chain_tp_find\n- 参数: [struct tcf_chain *chain, struct tcf_chain_info *chain_info, u32 protocol, u32 prio, bool prio_allocate]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n10. 函数名: tcf_auto_prio\n- 参数: [struct tcf_proto *tp]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n11. 函数名: tcf_chain_tp_prev\n- 参数: [struct tcf_chain_info *chain_info]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n12. 函数名: tcf_proto_create\n- 参数: [const char *kind, u32 protocol, u32 prio, struct tcf_chain *chain, struct netlink_ext_ack *extack]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n13. 函数名: nla_strcmp\n- 参数: [const struct nlattr *nla, const char *str]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n14. 函数名: tp->ops->get\n- 参数: [struct tcf_proto *tp, u32 handle]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n15. 函数名: tp->ops->change\n- 参数: [struct net *net, struct sk_buff *skb, struct tcf_proto *tp, unsigned long base, u32 handle, struct nlattr **tca, void **fh, bool rtnl_held, struct netlink_ext_ack *extack]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n16. 函数名: tcf_chain_tp_insert\n- 参数: [struct tcf_chain *chain, struct tcf_chain_info *chain_info, struct tcf_proto *tp]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n17. 函数名: tfilter_notify\n- 参数: [struct net *net, struct sk_buff *oskb, struct nlmsghdr *n, struct tcf_proto *tp, struct tcf_block *block, struct Qdisc *q, u32 parent, void *fh, int event, bool rtnl_held]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n18. 函数名: tcf_proto_destroy\n- 参数: [struct tcf_proto *tp, bool rtnl_held]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示\n\n19. 函数名: tcf_chain_put\n- 参数: [struct tcf_chain *chain]\n- 调用者: tc_new_tfilter\n- 被调用者: 未显示"
    },
    {
        "id": 3107,
        "cwe": "CWE-362",
        "cve": "CVE-2021-39713",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中流量控制链的管理功能，包括创建、删除和查询链，并处理相关的网络控制消息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于在处理TC(流量控制)链时，未能正确管理链的引用计数，导致存在竞争条件可能引发释放后使用(UAF)问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: tc_ctl_chain\n- 参数: [skb, n, extack]\n- 调用者: 无（顶级函数）\n- 被调用者: [sock_net, nlmsg_parse, nlmsg_data, tcf_block_find, nla_get_u32, tcf_chain_lookup, tcf_chain_held_by_acts_only, tcf_chain_hold, tcf_chain_create, tc_chain_tmplt_add, tc_chain_notify, tfilter_notify_chain, tcf_chain_flush, tcf_chain_put_explicitly_created, tcf_chain_put]\n\n2. 函数名: sock_net\n- 参数: [sk]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n3. 函数名: nlmsg_parse\n- 参数: [n, sizeof(*t), tca, TCA_MAX, NULL, extack]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n4. 函数名: nlmsg_data\n- 参数: [n]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n5. 函数名: tcf_block_find\n- 参数: [net, &q, &parent, &cl, t->tcm_ifindex, t->tcm_block_index, extack]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n6. 函数名: nla_get_u32\n- 参数: [tca[TCA_CHAIN]]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n7. 函数名: tcf_chain_lookup\n- 参数: [block, chain_index]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n8. 函数名: tcf_chain_held_by_acts_only\n- 参数: [chain]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n9. 函数名: tcf_chain_hold\n- 参数: [chain]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n10. 函数名: tcf_chain_create\n- 参数: [block, chain_index]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n11. 函数名: tc_chain_tmplt_add\n- 参数: [chain, net, tca, extack]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n12. 函数名: tc_chain_notify\n- 参数: [chain, NULL, 0, NLM_F_CREATE | NLM_F_EXCL, RTM_NEWCHAIN, false]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n13. 函数名: tfilter_notify_chain\n- 参数: [net, skb, block, q, parent, n, chain, RTM_DELTFILTER]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n14. 函数名: tcf_chain_flush\n- 参数: [chain]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n15. 函数名: tcf_chain_put_explicitly_created\n- 参数: [chain]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n16. 函数名: tcf_chain_put\n- 参数: [chain]\n- 调用者: tc_ctl_chain\n- 被调用者: 无"
    },
    {
        "id": 3127,
        "cwe": "CWE-362",
        "cve": "CVE-2021-40490",
        "purpose": "Code purpose:\"\"\"该代码用于处理ext4文件系统中内联数据的写入操作，包括获取inode位置、写入数据、更新页面状态等，并确保数据一致性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4_write_inline_data_end函数中存在竞态条件，当处理内联数据写入时未充分保护共享资源，导致并发访问时可能出现数据不一致问题\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_write_inline_data_end\n- 参数: [inode, pos, len, copied, page]\n- 调用者: N/A (top-level function)\n- 被调用者: [PageUptodate, ext4_get_inode_loc, ext4_std_error, ext4_write_lock_xattr, ext4_has_inline_data, kmap_atomic, ext4_write_inline_data, kunmap_atomic, SetPageUptodate, ClearPageDirty, ext4_write_unlock_xattr, brelse, mark_inode_dirty]\n\n2. 函数名: PageUptodate\n- 参数: [page]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n3. 函数名: ext4_get_inode_loc\n- 参数: [inode, iloc]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n4. 函数名: ext4_std_error\n- 参数: [sb, ret]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n5. 函数名: ext4_write_lock_xattr\n- 参数: [inode, no_expand]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n6. 函数名: ext4_has_inline_data\n- 参数: [inode]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n7. 函数名: kmap_atomic\n- 参数: [page]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n8. 函数名: ext4_write_inline_data\n- 参数: [inode, iloc, kaddr, pos, len]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n9. 函数名: kunmap_atomic\n- 参数: [kaddr]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n10. 函数名: SetPageUptodate\n- 参数: [page]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n11. 函数名: ClearPageDirty\n- 参数: [page]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n12. 函数名: ext4_write_unlock_xattr\n- 参数: [inode, no_expand]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n13. 函数名: brelse\n- 参数: [iloc.bh]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []\n\n14. 函数名: mark_inode_dirty\n- 参数: [inode]\n- 调用者: ext4_write_inline_data_end\n- 被调用者: []"
    },
    {
        "id": 3128,
        "cwe": "CWE-362",
        "cve": "CVE-2021-4083",
        "purpose": "Code purpose:\"\"\"在RCU保护下通过文件描述符查找并获取文件结构体引用\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核的Unix域套接字文件处理器的垃圾回收机制中，当用户同时调用close()和fget()时可能触发竞态条件，导致读取已释放的内存。\"\"\"",
        "functions": "Functions:\n1. 函数名: __fget_files\n- 参数: [struct files_struct *files, unsigned int fd, fmode_t mask, unsigned int refs]\n- 调用者: 未明确（通常由文件描述符相关操作调用）\n- 被调用者: [files_lookup_fd_rcu, get_file_rcu_many]\n\n2. 函数名: files_lookup_fd_rcu\n- 参数: [struct files_struct *files, unsigned int fd]\n- 调用者: __fget_files\n- 被调用者: []\n\n3. 函数名: get_file_rcu_many\n- 参数: [struct file *file, unsigned int refs]\n- 调用者: __fget_files\n- 被调用者: []"
    },
    {
        "id": 3145,
        "cwe": "CWE-362",
        "cve": "CVE-2021-4202",
        "purpose": "Code purpose:\"\"\"该代码用于管理NFC控制器接口(NCI)的请求，确保在设备可用时串行化处理请求并设置超时机制\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在设备被移除时，nci_request函数未能正确处理数据竞争条件，导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nci_request\n- 参数: [struct nci_dev *ndev, void (*req)(struct nci_dev *ndev, const void *opt), const void *opt, __u32 timeout]\n- 调用者: 未明确（外部调用）\n- 被调用者: [test_bit, mutex_lock, __nci_request, mutex_unlock]\n\n2. 函数名: req\n- 参数: [struct nci_dev *ndev, const void *opt]\n- 调用者: __nci_request\n- 被调用者: 未明确（回调函数）\n\n3. 函数名: test_bit\n- 参数: [NCI_UP, &ndev->flags]\n- 调用者: nci_request\n- 被调用者: 未明确（外部函数）\n\n4. 函数名: mutex_lock\n- 参数: [&ndev->req_lock]\n- 调用者: nci_request\n- 被调用者: 未明确（外部函数）\n\n5. 函数名: __nci_request\n- 参数: [struct nci_dev *ndev, void (*req)(struct nci_dev *ndev, const void *opt), const void *opt, __u32 timeout]\n- 调用者: nci_request\n- 被调用者: [req]\n\n6. 函数名: mutex_unlock\n- 参数: [&ndev->req_lock]\n- 调用者: nci_request\n- 被调用者: 未明确（外部函数）"
    },
    {
        "id": 3146,
        "cwe": "CWE-362",
        "cve": "CVE-2021-4203",
        "purpose": "Code purpose:\"\"\"该代码实现了获取套接字选项值的功能，处理不同类型的套接字选项请求并返回相应的值给用户空间。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于SO_PEERCRED和SO_PEERGROUPS选项在处理时与listen()和connect()操作存在竞争条件，导致在获取对端凭证信息时可能发生use-after-free读取漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: sock_getsockopt\n- 参数: [struct socket *sock, int level, int optname, char __user *optval, int __user *optlen]\n- 调用者: 未明确（系统调用或其他内核函数）\n- 被调用者: [get_user, memset, sock_flag, xchg, sock_get_timeout, copy_to_user, cred_to_ucred, put_user, groups_to_user, security_socket_getpeersec_stream, sock_getbindtodevice, sk_get_filter, bpf_tell_extensions, sk_get_meminfo, sock_gen_cookie, sock_net]\n\n2. 函数名: get_user\n- 参数: [len, optlen]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n3. 函数名: memset\n- 参数: [&v, 0, sizeof(v)]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n4. 函数名: sock_flag\n- 参数: [sk, SOCK_DBG/SOCK_LOCALROUTE/SOCK_BROADCAST/SOCK_KEEPOPEN/SOCK_URGINLINE/SOCK_LINGER/SOCK_RCVTSTAMP/SOCK_TSTAMP_NEW/SOCK_RCVTSTAMPNS/SOCK_RXQ_OVFL/SOCK_WIFI_STATUS/SOCK_NOFCS/SOCK_FILTER_LOCKED/SOCK_SELECT_ERR_QUEUE/SOCK_ZEROCOPY]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n5. 函数名: xchg\n- 参数: [&sk->sk_err_soft, 0]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n6. 函数名: sock_get_timeout\n- 参数: [sk->sk_rcvtimeo/sk->sk_sndtimeo, &v, SO_RCVTIMEO_OLD/SO_SNDTIMEO_OLD == optname]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n7. 函数名: copy_to_user\n- 参数: [optval, &peercred/address/meminfo/&v, len]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n8. 函数名: cred_to_ucred\n- 参数: [sk->sk_peer_pid, sk->sk_peer_cred, &peercred]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n9. 函数名: put_user\n- 参数: [len, optlen]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n10. 函数名: groups_to_user\n- 参数: [(gid_t __user *)optval, sk->sk_peer_cred->group_info]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n11. 函数名: security_socket_getpeersec_stream\n- 参数: [sock, optval, optlen, len]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n12. 函数名: sock_getbindtodevice\n- 参数: [sk, optval, optlen, len]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n13. 函数名: sk_get_filter\n- 参数: [sk, (struct sock_filter __user *)optval, len]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n14. 函数名: bpf_tell_extensions\n- 参数: []\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n15. 函数名: sk_get_meminfo\n- 参数: [sk, meminfo]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n16. 函数名: sock_gen_cookie\n- 参数: [sk]\n- 调用者: sock_getsockopt\n- 被调用者: []\n\n17. 函数名: sock_net\n- 参数: [sk]\n- 调用者: sock_getsockopt\n- 被调用者: []"
    },
    {
        "id": 3147,
        "cwe": "CWE-362",
        "cve": "CVE-2021-4203",
        "purpose": "Code purpose:\"\"\"该代码实现了套接字销毁时的资源清理功能，包括释放过滤器、时间戳、BPF存储、内存分配、页面碎片、对等凭证等资源，并处理潜在的竞态条件问题。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于SO_PEERCRED和SO_PEERGROUPS在listen()和connect()操作中存在竞态条件，导致在sock_getsockopt()中可能发生释放后使用(UAF)的问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: __sk_destruct\n- 参数: [head]\n- 调用者: 未明确显示（通常由RCU机制调用）\n- 被调用者: [container_of, sk->sk_destruct, rcu_dereference_check, refcount_read, sk_filter_uncharge, RCU_INIT_POINTER, sock_disable_timestamp, bpf_sk_storage_free, atomic_read, pr_debug, put_page, put_cred, put_pid, put_net, sk_prot_free, sock_net]\n\n2. 函数名: container_of\n- 参数: [head, struct sock, sk_rcu]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n3. 函数名: sk->sk_destruct\n- 参数: [sk]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n4. 函数名: rcu_dereference_check\n- 参数: [sk->sk_filter, refcount_read(&sk->sk_wmem_alloc) == 0]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n5. 函数名: refcount_read\n- 参数: [&sk->sk_wmem_alloc]\n- 调用者: __sk_destruct (通过rcu_dereference_check)\n- 被调用者: []\n\n6. 函数名: sk_filter_uncharge\n- 参数: [sk, filter]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n7. 函数名: RCU_INIT_POINTER\n- 参数: [sk->sk_filter, NULL]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n8. 函数名: sock_disable_timestamp\n- 参数: [sk, SK_FLAGS_TIMESTAMP]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n9. 函数名: bpf_sk_storage_free\n- 参数: [sk]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n10. 函数名: atomic_read\n- 参数: [&sk->sk_omem_alloc]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n11. 函数名: pr_debug\n- 参数: [\"%s: optmem leakage (%d bytes) detected\\n\", __func__, atomic_read(&sk->sk_omem_alloc)]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n12. 函数名: put_page\n- 参数: [sk->sk_frag.page]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n13. 函数名: put_cred\n- 参数: [sk->sk_peer_cred]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n14. 函数名: put_pid\n- 参数: [sk->sk_peer_pid]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n15. 函数名: put_net\n- 参数: [sock_net(sk)]\n- 调用者: __sk_destruct\n- 被调用者: []\n\n16. 函数名: sock_net\n- 参数: [sk]\n- 调用者: __sk_destruct (通过put_net)\n- 被调用者: []\n\n17. 函数名: sk_prot_free\n- 参数: [sk->sk_prot_creator, sk]\n- 调用者: __sk_destruct\n- 被调用者: []"
    },
    {
        "id": 3148,
        "cwe": "CWE-362",
        "cve": "CVE-2021-4203",
        "purpose": "Code purpose:\"\"\"初始化socket数据结构并设置相关参数和回调函数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于SO_PEERCRED和SO_PEERGROUPS选项在sock_getsockopt()中与listen()和connect()存在竞态条件，导致内核信息泄露或系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: sock_init_data\n- 参数: [struct socket *sock, struct sock *sk]\n- 调用者: 未显示\n- 被调用者: [sk_init_common, timer_setup, sk_set_socket, sock_set_flag, RCU_INIT_POINTER, SOCK_INODE, make_kuid, sock_net, rwlock_init, lockdep_set_class_and_name, refcount_set, atomic_set, sk_rx_queue_clear, WRITE_ONCE, smp_wmb]\n\n2. 函数名: sk_init_common\n- 参数: [struct sock *sk]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n3. 函数名: timer_setup\n- 参数: [&sk->sk_timer, NULL, 0]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n4. 函数名: sk_set_socket\n- 参数: [struct sock *sk, struct socket *sock]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n5. 函数名: sock_set_flag\n- 参数: [struct sock *sk, SOCK_ZAPPED]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n6. 函数名: RCU_INIT_POINTER\n- 参数: [sk->sk_wq, &sock->wq], [sk->sk_wq, NULL]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n7. 函数名: SOCK_INODE\n- 参数: [sock]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n8. 函数名: make_kuid\n- 参数: [sock_net(sk)->user_ns, 0]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n9. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n10. 函数名: rwlock_init\n- 参数: [&sk->sk_callback_lock]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n11. 函数名: lockdep_set_class_and_name\n- 参数: [&sk->sk_callback_lock, af_kern_callback_keys + sk->sk_family, af_family_kern_clock_key_strings[sk->sk_family]], [&sk->sk_callback_lock, af_callback_keys + sk->sk_family, af_family_clock_key_strings[sk->sk_family]]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n12. 函数名: refcount_set\n- 参数: [&sk->sk_refcnt, 1]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n13. 函数名: atomic_set\n- 参数: [&sk->sk_drops, 0]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n14. 函数名: sk_rx_queue_clear\n- 参数: [struct sock *sk]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n15. 函数名: WRITE_ONCE\n- 参数: [sk->sk_pacing_shift, 10]\n- 调用者: sock_init_data\n- 被调用者: 未显示\n\n16. 函数名: smp_wmb\n- 参数: []\n- 调用者: sock_init_data\n- 被调用者: 未显示"
    },
    {
        "id": 3149,
        "cwe": "CWE-362",
        "cve": "CVE-2021-4203",
        "purpose": "Code purpose:\"\"\"复制对端套接字的进程凭证信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在SO_PEERCRED和SO_PEERGROUPS操作与listen()/connect()之间存在竞争条件，导致对sk_peer_pid和sk_peer_cred的引用计数管理不当，可能引发释放后使用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: copy_peercred\n- 参数: [sk, peersk]\n- 调用者: 未指定\n- 被调用者: [put_pid, put_cred, get_pid, get_cred]\n\n2. 函数名: put_pid\n- 参数: [sk->sk_peer_pid]\n- 调用者: copy_peercred\n- 被调用者: 未指定\n\n3. 函数名: put_cred\n- 参数: [sk->sk_peer_cred]\n- 调用者: copy_peercred\n- 被调用者: 未指定\n\n4. 函数名: get_pid\n- 参数: [peersk->sk_peer_pid]\n- 调用者: copy_peercred\n- 被调用者: 未指定\n\n5. 函数名: get_cred\n- 参数: [peersk->sk_peer_cred]\n- 调用者: copy_peercred\n- 被调用者: 未指定"
    },
    {
        "id": 3150,
        "cwe": "CWE-362",
        "cve": "CVE-2021-4203",
        "purpose": "Code purpose:\"\"\"初始化套接字的对等进程凭证信息，包括进程ID和凭证\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于SO_PEERCRED和SO_PEERGROUPS选项在sock_getsockopt()中与listen()/connect()存在竞态条件，导致对已释放的sk_peer_cred和sk_peer_pid进行读取，引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: init_peercred\n- 参数: [struct sock *sk]\n- 调用者: 不适用（从代码片段无法确定）\n- 被调用者: [put_pid, put_cred, get_pid, task_tgid, get_current_cred]\n\n2. 函数名: put_pid\n- 参数: [struct pid *]\n- 调用者: init_peercred\n- 被调用者: 不适用（从代码片段无法确定）\n\n3. 函数名: put_cred\n- 参数: [const struct cred *]\n- 调用者: init_peercred\n- 被调用者: 不适用（从代码片段无法确定）\n\n4. 函数名: get_pid\n- 参数: [struct pid *]\n- 调用者: init_peercred\n- 被调用者: 不适用（从代码片段无法确定）\n\n5. 函数名: task_tgid\n- 参数: [struct task_struct *]\n- 调用者: init_peercred\n- 被调用者: 不适用（从代码片段无法确定）\n\n6. 函数名: get_current_cred\n- 参数: []\n- 调用者: init_peercred\n- 被调用者: 不适用（从代码片段无法确定）"
    },
    {
        "id": 3167,
        "cwe": "CWE-362",
        "cve": "CVE-2021-44733",
        "purpose": "Code purpose:\"\"\"释放共享内存对象，根据标志位选择通过dma_buf_put减少引用计数或直接调用tee_shm_release释放内存\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于tee_shm_get_from_id函数中存在竞态条件，导致在释放共享内存对象时可能发生释放后使用(UAF)问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: tee_shm_free\n- 参数: [struct tee_shm *shm]\n- 调用者: 未明确（可能是外部调用）\n- 被调用者: [dma_buf_put, tee_shm_release]\n\n2. 函数名: dma_buf_put\n- 参数: [shm->dmabuf]\n- 调用者: tee_shm_free\n- 被调用者: 未明确（可能是内核函数）\n\n3. 函数名: tee_shm_release\n- 参数: [shm]\n- 调用者: tee_shm_free\n- 被调用者: 未明确（可能是内部函数）"
    },
    {
        "id": 3168,
        "cwe": "CWE-362",
        "cve": "CVE-2021-44733",
        "purpose": "Code purpose:\"\"\"通过ID从TEE上下文中获取共享内存对象并处理相关引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在tee_shm_get_from_id函数中存在竞态条件，当尝试释放共享内存对象时可能导致使用后释放漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: tee_shm_get_from_id\n- 参数: [struct tee_context *ctx, int id]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [ERR_PTR, idr_find, mutex_lock, mutex_unlock, get_dma_buf]\n\n2. 函数名: ERR_PTR\n- 参数: [long error]\n- 调用者: tee_shm_get_from_id\n- 被调用者: 未明确\n\n3. 函数名: idr_find\n- 参数: [struct idr *idr, int id]\n- 调用者: tee_shm_get_from_id\n- 被调用者: 未明确\n\n4. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: tee_shm_get_from_id\n- 被调用者: 未明确\n\n5. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: tee_shm_get_from_id\n- 被调用者: 未明确\n\n6. 函数名: get_dma_buf\n- 参数: [struct dma_buf *dmabuf]\n- 调用者: tee_shm_get_from_id\n- 被调用者: 未明确"
    },
    {
        "id": 3169,
        "cwe": "CWE-362",
        "cve": "CVE-2021-44733",
        "purpose": "Code purpose:\"\"\"该代码实现了在TEE子系统中注册共享内存对象的功能，包括内存页的固定、ID分配和DMA缓冲区导出等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于tee_shm_get_from_id函数中存在竞态条件，导致在释放共享内存对象时可能发生释放后使用(UAF)问题\"\"\"",
        "functions": "Functions:\n1. 函数名: tee_shm_register\n- 参数: [struct tee_context *ctx, unsigned long addr, size_t length, u32 flags]\n- 调用者: 未指定\n- 被调用者: [tee_device_get, tee_device_put, teedev_ctx_get, kzalloc, untagged_addr, rounddown, roundup, kcalloc, pin_user_pages_fast, get_kernel_pages, kfree, mutex_lock, idr_alloc, mutex_unlock, ERR_PTR, ERR_CAST, release_registered_pages, teedev_ctx_put]\n\n2. 函数名: tee_device_get\n- 参数: [struct tee_device *teedev]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n3. 函数名: tee_device_put\n- 参数: [struct tee_device *teedev]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n4. 函数名: teedev_ctx_get\n- 参数: [struct tee_context *ctx]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n5. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n6. 函数名: untagged_addr\n- 参数: [unsigned long addr]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n7. 函数名: rounddown\n- 参数: [unsigned long addr, unsigned long size]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n8. 函数名: roundup\n- 参数: [unsigned long addr, unsigned long size]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n9. 函数名: kcalloc\n- 参数: [size_t n, size_t size, gfp_t flags]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n10. 函数名: pin_user_pages_fast\n- 参数: [unsigned long start, int nr_pages, unsigned int gup_flags, struct page **pages]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n11. 函数名: get_kernel_pages\n- 参数: [struct kvec *kiov, int nr_pages, int write, struct page **pages]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n12. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n13. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n14. 函数名: idr_alloc\n- 参数: [struct idr *idr, void *ptr, int start, int end, gfp_t gfp_mask]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n15. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n16. 函数名: ERR_PTR\n- 参数: [long error]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n17. 函数名: ERR_CAST\n- 参数: [void *ptr]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n18. 函数名: release_registered_pages\n- 参数: [struct tee_shm *shm]\n- 调用者: tee_shm_register\n- 被调用者: 未指定\n\n19. 函数名: teedev_ctx_put\n- 参数: [struct tee_context *ctx]\n- 调用者: tee_shm_register\n- 被调用者: 未指定"
    },
    {
        "id": 3170,
        "cwe": "CWE-362",
        "cve": "CVE-2021-44733",
        "purpose": "Code purpose:\"\"\"释放共享内存对象时处理DMA缓冲区的引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于tee_shm_get_from_id函数中存在竞态条件，导致在释放共享内存对象时可能发生释放后使用的问题\"\"\"",
        "functions": "Functions:\n1. 函数名: tee_shm_put\n- 参数: [struct tee_shm *shm]\n- 调用者: 未提供（上下文缺失）\n- 被调用者: [dma_buf_put]\n\n2. 函数名: dma_buf_put\n- 参数: [shm->dmabuf]\n- 调用者: tee_shm_put\n- 被调用者: 未提供（上下文缺失）"
    },
    {
        "id": 3171,
        "cwe": "CWE-362",
        "cve": "CVE-2021-44733",
        "purpose": "Code purpose:\"\"\"该代码用于在TEE子系统中分配和管理共享内存对象，包括处理不同类型的共享内存标志和资源分配\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在释放共享内存对象时存在竞争条件，导致在tee_shm_get_from_id中可能发生释放后使用(UAF)的问题\"\"\"",
        "functions": "Functions:\n1. 函数名: tee_shm_alloc\n- 参数: [struct tee_context *ctx, size_t size, u32 flags]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [dev_err, ERR_PTR, tee_device_get, kzalloc, poolm->ops->alloc, DEFINE_DMA_BUF_EXPORT_INFO, mutex_lock, idr_alloc, mutex_unlock, dma_buf_export, ERR_CAST, teedev_ctx_get, idr_remove, poolm->ops->free, kfree, tee_device_put]\n\n2. 函数名: dev_err\n- 参数: [teedev->dev.parent, \"only mapped allocations supported\\n\"] 或 [teedev->dev.parent, \"invalid shm flags 0x%x\", flags]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（内核日志函数）\n\n3. 函数名: ERR_PTR\n- 参数: [-EINVAL] 或 [-ENOMEM] 或 [rc] 或 [shm->id]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（内核错误处理宏）\n\n4. 函数名: tee_device_get\n- 参数: [teedev]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（外部函数）\n\n5. 函数名: kzalloc\n- 参数: [sizeof(*shm), GFP_KERNEL]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（内核内存分配函数）\n\n6. 函数名: poolm->ops->alloc\n- 参数: [poolm, shm, size]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（函数指针调用）\n\n7. 函数名: DEFINE_DMA_BUF_EXPORT_INFO\n- 参数: [exp_info]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（宏定义）\n\n8. 函数名: mutex_lock\n- 参数: [&teedev->mutex]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（内核互斥锁函数）\n\n9. 函数名: idr_alloc\n- 参数: [&teedev->idr, shm, 1, 0, GFP_KERNEL]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（内核ID分配函数）\n\n10. 函数名: mutex_unlock\n- 参数: [&teedev->mutex]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（内核互斥锁函数）\n\n11. 函数名: dma_buf_export\n- 参数: [&exp_info]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（DMA缓冲区导出函数）\n\n12. 函数名: ERR_CAST\n- 参数: [shm->dmabuf]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（内核错误处理宏）\n\n13. 函数名: teedev_ctx_get\n- 参数: [ctx]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（外部函数）\n\n14. 函数名: idr_remove\n- 参数: [&teedev->idr, shm->id]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（内核ID移除函数）\n\n15. 函数名: poolm->ops->free\n- 参数: [poolm, shm]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（函数指针调用）\n\n16. 函数名: kfree\n- 参数: [shm]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（内核内存释放函数）\n\n17. 函数名: tee_device_put\n- 参数: [teedev]\n- 调用者: tee_shm_alloc\n- 被调用者: 未显示（外部函数）"
    },
    {
        "id": 3172,
        "cwe": "CWE-362",
        "cve": "CVE-2021-44733",
        "purpose": "Code purpose:\"\"\"该代码用于获取共享内存对象的文件描述符，并在失败时释放相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于tee_shm_get_fd函数在处理共享内存对象时存在竞态条件，导致在释放共享内存对象时可能发生use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: tee_shm_get_fd\n- 参数: [struct tee_shm *shm]\n- 调用者: 未指定\n- 被调用者: [get_dma_buf, dma_buf_fd, dma_buf_put]\n\n2. 函数名: get_dma_buf\n- 参数: [shm->dmabuf]\n- 调用者: tee_shm_get_fd\n- 被调用者: 未指定\n\n3. 函数名: dma_buf_fd\n- 参数: [shm->dmabuf, O_CLOEXEC]\n- 调用者: tee_shm_get_fd\n- 被调用者: 未指定\n\n4. 函数名: dma_buf_put\n- 参数: [shm->dmabuf]\n- 调用者: tee_shm_get_fd\n- 被调用者: 未指定"
    },
    {
        "id": 3242,
        "cwe": "CWE-362",
        "cve": "CVE-2022-1048",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核声音子系统中处理PCM子流的附加操作，包括资源分配、状态管理和并发控制\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在ALSA PCM子系统中存在并发调用hw_params和hw_free等ioctl操作时的竞态条件，导致释放后重用(UAF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_pcm_attach_substream\n- 参数: [struct snd_pcm *pcm, int stream, struct file *file, struct snd_pcm_substream **rsubstream]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [snd_ctl_get_preferred_subdevice, kzalloc, alloc_pages_exact, free_pages_exact, kfree, memset, init_waitqueue_head, get_pid, task_pid]\n\n2. 函数名: snd_ctl_get_preferred_subdevice\n- 参数: [struct snd_card *card, SND_CTL_SUBDEV_PCM]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: 未明确（可能由内核提供）\n\n3. 函数名: kzalloc\n- 参数: [sizeof(*runtime), GFP_KERNEL]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: 未明确（内核内存分配函数）\n\n4. 函数名: alloc_pages_exact\n- 参数: [size, GFP_KERNEL]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: 未明确（内核内存分配函数）\n\n5. 函数名: free_pages_exact\n- 参数: [runtime->status, PAGE_ALIGN(sizeof(struct snd_pcm_mmap_status))]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: 未明确（内核内存释放函数）\n\n6. 函数名: kfree\n- 参数: [runtime]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: 未明确（内核内存释放函数）\n\n7. 函数名: memset\n- 参数: [runtime->status, 0, size]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: 未明确（标准库函数）\n\n8. 函数名: init_waitqueue_head\n- 参数: [&runtime->sleep]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: 未明确（内核函数）\n\n9. 函数名: get_pid\n- 参数: [task_pid(current)]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: 未明确（内核函数）\n\n10. 函数名: task_pid\n- 参数: [current]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: 未明确（内核函数）"
    },
    {
        "id": 3243,
        "cwe": "CWE-362",
        "cve": "CVE-2022-1048",
        "purpose": "Code purpose:\"\"\"释放PCM子流相关资源并处理并发访问问题\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在释放PCM子流资源时未正确处理并发访问，导致存在释放后使用(UAF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_pcm_detach_substream\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: 未指定\n- 被调用者: [PCM_RUNTIME_CHECK, free_pages_exact, kfree, spin_lock_irq, spin_unlock_irq, put_pid]\n\n2. 函数名: PCM_RUNTIME_CHECK\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_detach_substream\n- 被调用者: 未指定\n\n3. 函数名: free_pages_exact\n- 参数: [runtime->status, PAGE_ALIGN(sizeof(struct snd_pcm_mmap_status))]\n- 调用者: snd_pcm_detach_substream\n- 被调用者: 未指定\n\n4. 函数名: free_pages_exact\n- 参数: [runtime->control, PAGE_ALIGN(sizeof(struct snd_pcm_mmap_control))]\n- 调用者: snd_pcm_detach_substream\n- 被调用者: 未指定\n\n5. 函数名: kfree\n- 参数: [runtime->hw_constraints.rules]\n- 调用者: snd_pcm_detach_substream\n- 被调用者: 未指定\n\n6. 函数名: spin_lock_irq\n- 参数: [&substream->timer->lock]\n- 调用者: snd_pcm_detach_substream\n- 被调用者: 未指定\n\n7. 函数名: spin_unlock_irq\n- 参数: [&substream->timer->lock]\n- 调用者: snd_pcm_detach_substream\n- 被调用者: 未指定\n\n8. 函数名: kfree\n- 参数: [runtime]\n- 调用者: snd_pcm_detach_substream\n- 被调用者: 未指定\n\n9. 函数名: put_pid\n- 参数: [substream->pid]\n- 调用者: snd_pcm_detach_substream\n- 被调用者: 未指定"
    },
    {
        "id": 3244,
        "cwe": "CWE-362",
        "cve": "CVE-2022-1048",
        "purpose": "Code purpose:\"\"\"释放PCM子流的硬件资源并将其状态设置为OPEN\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ALSA PCM子系统中，由于对PCM hw_params的并发调用处理不当，导致在hw_free ioctl操作时出现竞态条件，可能引发释放后使用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_pcm_hw_free\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [PCM_RUNTIME_CHECK, snd_pcm_stream_lock_irq, snd_pcm_stream_unlock_irq, atomic_read, do_hw_free, snd_pcm_set_state, cpu_latency_qos_remove_request]\n\n2. 函数名: PCM_RUNTIME_CHECK\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_hw_free\n- 被调用者: []\n\n3. 函数名: snd_pcm_stream_lock_irq\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_hw_free\n- 被调用者: []\n\n4. 函数名: snd_pcm_stream_unlock_irq\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_hw_free\n- 被调用者: []\n\n5. 函数名: atomic_read\n- 参数: [&substream->mmap_count]\n- 调用者: snd_pcm_hw_free\n- 被调用者: []\n\n6. 函数名: do_hw_free\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_hw_free\n- 被调用者: []\n\n7. 函数名: snd_pcm_set_state\n- 参数: [struct snd_pcm_substream *substream, SNDRV_PCM_STATE_OPEN]\n- 调用者: snd_pcm_hw_free\n- 被调用者: []\n\n8. 函数名: cpu_latency_qos_remove_request\n- 参数: [&substream->latency_pm_qos_req]\n- 调用者: snd_pcm_hw_free\n- 被调用者: []"
    },
    {
        "id": 3245,
        "cwe": "CWE-362",
        "cve": "CVE-2022-1048",
        "purpose": "Code purpose:\"\"\"该代码用于处理PCM子流的硬件参数设置，包括参数验证、缓冲区分配、状态转换和资源管理，是Linux内核声音子系统的一部分。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核声音子系统中，PCM hw_params的并发调用导致竞态条件，引发释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_pcm_hw_params\n- 参数: [substream, params]\n- 调用者: 外部调用\n- 被调用者: [PCM_RUNTIME_CHECK, snd_pcm_stream_lock_irq, snd_pcm_stream_unlock_irq, atomic_read, snd_pcm_sync_stop, snd_pcm_hw_refine, snd_pcm_hw_params_choose, fixup_unreferenced_params, snd_pcm_lib_malloc_pages, params_buffer_bytes, params_access, params_format, params_subformat, params_channels, params_rate, params_period_size, params_periods, params_buffer_size, snd_pcm_format_physical_width, PAGE_ALIGN, memset, snd_pcm_timer_resolution_change, snd_pcm_set_state, cpu_latency_qos_request_active, cpu_latency_qos_remove_request, period_to_usecs, cpu_latency_qos_add_request, snd_pcm_lib_free_pages]\n\n2. 函数名: PCM_RUNTIME_CHECK\n- 参数: [substream]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n3. 函数名: snd_pcm_stream_lock_irq\n- 参数: [substream]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n4. 函数名: snd_pcm_stream_unlock_irq\n- 参数: [substream]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n5. 函数名: atomic_read\n- 参数: [&substream->mmap_count]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n6. 函数名: snd_pcm_sync_stop\n- 参数: [substream, true]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n7. 函数名: snd_pcm_hw_refine\n- 参数: [substream, params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n8. 函数名: snd_pcm_hw_params_choose\n- 参数: [substream, params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n9. 函数名: fixup_unreferenced_params\n- 参数: [substream, params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n10. 函数名: snd_pcm_lib_malloc_pages\n- 参数: [substream, params_buffer_bytes(params)]\n- 调用者: snd_pcm_hw_params\n- 被调用者: [params_buffer_bytes]\n\n11. 函数名: params_buffer_bytes\n- 参数: [params]\n- 调用者: snd_pcm_lib_malloc_pages\n- 被调用者: []\n\n12. 函数名: params_access\n- 参数: [params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n13. 函数名: params_format\n- 参数: [params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n14. 函数名: params_subformat\n- 参数: [params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n15. 函数名: params_channels\n- 参数: [params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n16. 函数名: params_rate\n- 参数: [params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n17. 函数名: params_period_size\n- 参数: [params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n18. 函数名: params_periods\n- 参数: [params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n19. 函数名: params_buffer_size\n- 参数: [params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n20. 函数名: snd_pcm_format_physical_width\n- 参数: [runtime->format]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n21. 函数名: PAGE_ALIGN\n- 参数: [size]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n22. 函数名: memset\n- 参数: [runtime->dma_area, 0, size]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n23. 函数名: snd_pcm_timer_resolution_change\n- 参数: [substream]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n24. 函数名: snd_pcm_set_state\n- 参数: [substream, SNDRV_PCM_STATE_SETUP/SNDRV_PCM_STATE_OPEN]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n25. 函数名: cpu_latency_qos_request_active\n- 参数: [&substream->latency_pm_qos_req]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n26. 函数名: cpu_latency_qos_remove_request\n- 参数: [&substream->latency_pm_qos_req]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n27. 函数名: period_to_usecs\n- 参数: [runtime]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n28. 函数名: cpu_latency_qos_add_request\n- 参数: [&substream->latency_pm_qos_req, usecs]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []\n\n29. 函数名: snd_pcm_lib_free_pages\n- 参数: [substream]\n- 调用者: snd_pcm_hw_params\n- 被调用者: []"
    },
    {
        "id": 3261,
        "cwe": "CWE-362",
        "cve": "CVE-2022-1462",
        "purpose": "Code purpose:\"\"\"该代码实现了伪终端(pty)的数据写入功能，将数据从一端写入另一端的输入队列，并处理流控制和缓冲区推送。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于竞态条件导致的内存越界读取漏洞，当用户通过特定ioctl操作触发时，可能泄露内存数据或导致系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: pty_write\n- 参数: [tty, buf, c]\n- 调用者: 不适用（由内核调用）\n- 被调用者: [spin_lock_irqsave, tty_insert_flip_string, spin_unlock_irqrestore, tty_flip_buffer_push]\n\n2. 函数名: spin_lock_irqsave\n- 参数: [&to->port->lock, flags]\n- 调用者: pty_write\n- 被调用者: []\n\n3. 函数名: tty_insert_flip_string\n- 参数: [to->port, buf, c]\n- 调用者: pty_write\n- 被调用者: []\n\n4. 函数名: spin_unlock_irqrestore\n- 参数: [&to->port->lock, flags]\n- 调用者: pty_write\n- 被调用者: []\n\n5. 函数名: tty_flip_buffer_push\n- 参数: [to->port]\n- 调用者: pty_write\n- 被调用者: []"
    },
    {
        "id": 3276,
        "cwe": "CWE-362",
        "cve": "CVE-2022-1729",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中perf_event_open系统调用，用于创建和管理性能监控事件，但存在竞争条件漏洞可被利用提升权限\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于perf_event_open()函数中存在竞态条件，未正确同步对任务信号结构的访问，导致非特权用户可利用该条件进行权限提升\"\"\"",
        "functions": "Functions:\n1. 函数名: perf_event_open\n- 参数: [struct perf_event_attr __user *attr_uptr, pid_t pid, int cpu, int group_fd, unsigned long flags]\n- 调用者: 系统调用\n- 被调用者: [security_perf_event_open, perf_copy_attr, perf_allow_kernel, perfmon_capable, perf_fget_light, find_lively_task_by_vpid, perf_event_alloc, perf_event_set_clock, find_get_context, perf_event_set_output, anon_inode_getfile, down_read_interruptible, perf_check_permission, __perf_event_ctx_lock_double, exclusive_event_installable, for_each_sibling_event, perf_remove_from_context, put_ctx, synchronize_rcu, perf_event__state_init, perf_install_in_context, get_ctx, perf_event__header_size, perf_event__id_header_size, perf_unpin_context, perf_event_ctx_unlock, up_read, put_task_struct, fdput, fd_install, put_unused_fd, fput, perf_unpin_context, put_ctx, free_event]\n\n2. 函数名: security_perf_event_open\n- 参数: [struct perf_event_attr *attr, int type]\n- 调用者: perf_event_open\n- 被调用者: []\n\n3. 函数名: perf_copy_attr\n- 参数: [struct perf_event_attr __user *attr_uptr, struct perf_event_attr *attr]\n- 调用者: perf_event_open\n- 被调用者: []\n\n4. 函数名: perf_allow_kernel\n- 参数: [struct perf_event_attr *attr]\n- 调用者: perf_event_open\n- 被调用者: []\n\n5. 函数名: perfmon_capable\n- 参数: []\n- 调用者: perf_event_open\n- 被调用者: []\n\n6. 函数名: perf_fget_light\n- 参数: [int fd, struct fd *f]\n- 调用者: perf_event_open\n- 被调用者: []\n\n7. 函数名: find_lively_task_by_vpid\n- 参数: [pid_t pid]\n- 调用者: perf_event_open\n- 被调用者: []\n\n8. 函数名: perf_event_alloc\n- 参数: [struct perf_event_attr *attr, int cpu, struct task_struct *task, struct perf_event *group_leader, void *overflow_handler, void *context, int cgroup_fd]\n- 调用者: perf_event_open\n- 被调用者: []\n\n9. 函数名: perf_event_set_clock\n- 参数: [struct perf_event *event, clockid_t clockid]\n- 调用者: perf_event_open\n- 被调用者: []\n\n10. 函数名: find_get_context\n- 参数: [struct pmu *pmu, struct task_struct *task, struct perf_event *event]\n- 调用者: perf_event_open\n- 被调用者: []\n\n11. 函数名: perf_event_set_output\n- 参数: [struct perf_event *event, struct perf_event *output_event]\n- 调用者: perf_event_open\n- 被调用者: []\n\n12. 函数名: anon_inode_getfile\n- 参数: [const char *name, const struct file_operations *fops, void *priv, int flags]\n- 调用者: perf_event_open\n- 被调用者: []\n\n13. 函数名: down_read_interruptible\n- 参数: [struct rw_semaphore *sem]\n- 调用者: perf_event_open\n- 被调用者: []\n\n14. 函数名: perf_check_permission\n- 参数: [struct perf_event_attr *attr, struct task_struct *task]\n- 调用者: perf_event_open\n- 被调用者: []\n\n15. 函数名: __perf_event_ctx_lock_double\n- 参数: [struct perf_event *group_leader, struct perf_event_context *ctx]\n- 调用者: perf_event_open\n- 被调用者: []\n\n16. 函数名: exclusive_event_installable\n- 参数: [struct perf_event *event, struct perf_event_context *ctx]\n- 调用者: perf_event_open\n- 被调用者: []\n\n17. 函数名: for_each_sibling_event\n- 参数: [struct perf_event *sibling, struct perf_event *group_leader]\n- 调用者: perf_event_open\n- 被调用者: []\n\n18. 函数名: perf_remove_from_context\n- 参数: [struct perf_event *event, int flags]\n- 调用者: perf_event_open\n- 被调用者: []\n\n19. 函数名: put_ctx\n- 参数: [struct perf_event_context *ctx]\n- 调用者: perf_event_open\n- 被调用者: []\n\n20. 函数名: synchronize_rcu\n- 参数: []\n- 调用者: perf_event_open\n- 被调用者: []\n\n21. 函数名: perf_event__state_init\n- 参数: [struct perf_event *event]\n- 调用者: perf_event_open\n- 被调用者: []\n\n22. 函数名: perf_install_in_context\n- 参数: [struct perf_event_context *ctx, struct perf_event *event, int cpu]\n- 调用者: perf_event_open\n- 被调用者: []\n\n23. 函数名: get_ctx\n- 参数: [struct perf_event_context *ctx]\n- 调用者: perf_event_open\n- 被调用者: []\n\n24. 函数名: perf_event__header_size\n- 参数: [struct perf_event *event]\n- 调用者: perf_event_open\n- 被调用者: []\n\n25. 函数名: perf_event__id_header_size\n- 参数: [struct perf_event *event]\n- 调用者: perf_event_open\n- 被调用者: []\n\n26. 函数名: perf_unpin_context\n- 参数: [struct perf_event_context *ctx]\n- 调用者: perf_event_open\n- 被调用者: []\n\n27. 函数名: perf_event_ctx_unlock\n- 参数: [struct perf_event *group_leader, struct perf_event_context *ctx]\n- 调用者: perf_event_open\n- 被调用者: []\n\n28. 函数名: up_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: perf_event_open\n- 被调用者: []\n\n29. 函数名: put_task_struct\n- 参数: [struct task_struct *t]\n- 调用者: perf_event_open\n- 被调用者: []\n\n30. 函数名: fdput\n- 参数: [struct fd fd]\n- 调用者: perf_event_open\n- 被调用者: []\n\n31. 函数名: fd_install\n- 参数: [int fd, struct file *file]\n- 调用者: perf_event_open\n- 被调用者: []\n\n32. 函数名: put_unused_fd\n- 参数: [int fd]\n- 调用者: perf_event_open\n- 被调用者: []\n\n33. 函数名: fput\n- 参数: [struct file *file]\n- 调用者: perf_event_open\n- 被调用者: []\n\n34. 函数名: free_event\n- 参数: [struct perf_event *event]\n- 调用者: perf_event_open\n- 被调用者: []"
    },
    {
        "id": 3337,
        "cwe": "CWE-362",
        "cve": "CVE-2022-20141",
        "purpose": "Code purpose:\"\"\"检查给定的多播地址和源地址是否在设备的接收列表中，用于IGMP协议处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在RCU读取期间未正确加锁保护，导致在多线程环境下可能出现释放后使用(UAF)的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: ip_check_mc_rcu\n- 参数: [struct in_device *in_dev, __be32 mc_addr, __be32 src_addr, u8 proto]\n- 调用者: 未明确（由系统调用）\n- 被调用者: [hash_32, rcu_dereference]\n\n2. 函数名: hash_32\n- 参数: [(__force u32)mc_addr, MC_HASH_SZ_LOG]\n- 调用者: ip_check_mc_rcu\n- 被调用者: []\n\n3. 函数名: rcu_dereference\n- 参数: [in_dev->mc_hash], [mc_hash[hash]], [im->next_hash]\n- 调用者: ip_check_mc_rcu\n- 被调用者: []\n\n4. 函数名: for_each_pmc_rcu\n- 参数: [in_dev, im]\n- 调用者: ip_check_mc_rcu\n- 被调用者: []"
    },
    {
        "id": 3338,
        "cwe": "CWE-362",
        "cve": "CVE-2022-20148",
        "purpose": "Code purpose:\"\"\"该代码实现了F2FS文件系统的超级块初始化、挂载过程，包括内存分配、设备扫描、检查点恢复、元数据读取等核心功能，并处理文件系统挂载时的各种错误情况。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于竞态条件导致的use-after-free漏洞，当多个线程同时访问和释放资源时，缺乏适当的同步机制，造成在资源被释放后仍被使用的情况。\"\"\"",
        "functions": "Functions:\n1. 函数名: f2fs_fill_super\n- 参数: [struct super_block *sb, void *data, int silent]\n- 调用者: N/A\n- 被调用者: [kzalloc, crypto_alloc_shash, sb_set_blocksize, read_raw_super_block, f2fs_chksum, kstrdup, parse_options, f2fs_setup_casefold, f2fs_init_iostat, init_percpu_info, mempool_create_page_pool, f2fs_init_xattr_caches, f2fs_init_page_array_cache, f2fs_iget, f2fs_get_valid_checkpoint, f2fs_scan_devices, f2fs_init_post_read_wq, f2fs_start_ckpt_thread, f2fs_build_segment_manager, f2fs_build_node_manager, f2fs_build_gc_manager, f2fs_build_stats, f2fs_init_compress_inode, f2fs_register_sysfs, f2fs_enable_quotas, f2fs_recover_orphan_inodes, f2fs_recover_fsync_data, f2fs_check_write_pointer, f2fs_disable_checkpoint, f2fs_enable_checkpoint, f2fs_start_gc_thread, f2fs_commit_super, f2fs_join_shrinker, f2fs_tuning_parameters, f2fs_update_time, sync_filesystem, f2fs_truncate_quota_inode_pages, f2fs_quota_off_umount, truncate_inode_pages_final, evict_inodes, f2fs_unregister_sysfs, f2fs_destroy_compress_inode, f2fs_release_ino_entry, f2fs_destroy_stats, f2fs_destroy_node_manager, f2fs_destroy_segment_manager, f2fs_destroy_post_read_wq, f2fs_stop_ckpt_thread, destroy_device_list, make_bad_inode, f2fs_destroy_page_array_cache, f2fs_destroy_xattr_caches, mempool_destroy, destroy_percpu_info, f2fs_destroy_iostat, utf8_unload, fscrypt_free_dummy_policy, shrink_dcache_sb]\n\n2. 函数名: read_raw_super_block\n- 参数: [struct f2fs_sb_info *sbi, struct f2fs_super_block **raw_super, int *valid_super_block, int *recovery]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n3. 函数名: parse_options\n- 参数: [struct super_block *sb, char *options, bool false]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n4. 函数名: f2fs_setup_casefold\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n5. 函数名: f2fs_init_iostat\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n6. 函数名: init_percpu_info\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n7. 函数名: f2fs_init_xattr_caches\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n8. 函数名: f2fs_init_page_array_cache\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n9. 函数名: f2fs_get_valid_checkpoint\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n10. 函数名: f2fs_scan_devices\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n11. 函数名: f2fs_init_post_read_wq\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n12. 函数名: f2fs_start_ckpt_thread\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n13. 函数名: f2fs_build_segment_manager\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n14. 函数名: f2fs_build_node_manager\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n15. 函数名: f2fs_build_gc_manager\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n16. 函数名: f2fs_build_stats\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n17. 函数名: f2fs_init_compress_inode\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n18. 函数名: f2fs_register_sysfs\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n19. 函数名: f2fs_enable_quotas\n- 参数: [struct super_block *sb]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n20. 函数名: f2fs_recover_orphan_inodes\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n21. 函数名: f2fs_recover_fsync_data\n- 参数: [struct f2fs_sb_info *sbi, bool true/false]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n22. 函数名: f2fs_check_write_pointer\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n23. 函数名: f2fs_disable_checkpoint\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n24. 函数名: f2fs_enable_checkpoint\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n25. 函数名: f2fs_start_gc_thread\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n26. 函数名: f2fs_commit_super\n- 参数: [struct f2fs_sb_info *sbi, bool true]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n27. 函数名: f2fs_join_shrinker\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n28. 函数名: f2fs_tuning_parameters\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n29. 函数名: f2fs_update_time\n- 参数: [struct f2fs_sb_info *sbi, CP_TIME/REQ_TIME]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n30. 函数名: f2fs_truncate_quota_inode_pages\n- 参数: [struct super_block *sb]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n31. 函数名: f2fs_quota_off_umount\n- 参数: [struct super_block *sb]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n32. 函数名: f2fs_unregister_sysfs\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n33. 函数名: f2fs_destroy_compress_inode\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n34. 函数名: f2fs_release_ino_entry\n- 参数: [struct f2fs_sb_info *sbi, bool true]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n35. 函数名: f2fs_destroy_stats\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n36. 函数名: f2fs_destroy_node_manager\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n37. 函数名: f2fs_destroy_segment_manager\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n38. 函数名: f2fs_destroy_post_read_wq\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n39. 函数名: f2fs_stop_ckpt_thread\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n40. 函数名: destroy_device_list\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n41. 函数名: f2fs_destroy_page_array_cache\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n42. 函数名: f2fs_destroy_xattr_caches\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n43. 函数名: destroy_percpu_info\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A\n\n44. 函数名: f2fs_destroy_iostat\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_fill_super\n- 被调用者: N/A"
    },
    {
        "id": 3340,
        "cwe": "CWE-362",
        "cve": "CVE-2022-20154",
        "purpose": "Code purpose:\"\"\"该代码片段实现了SCTP协议的诊断信息转储功能，通过遍历端点(ep)和传输(asoc)哈希表来收集和输出网络连接状态信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在lock_sock_nested函数中存在竞态条件导致锁释放后仍被使用，造成释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: sctp_diag_dump\n- 参数: [skb, cb, r]\n- 调用者: N/A (顶层函数)\n- 被调用者: [sock_net, netlink_net_capable, sctp_for_each_endpoint, sctp_for_each_transport]\n\n2. 函数名: sock_net\n- 参数: [skb->sk]\n- 调用者: sctp_diag_dump\n- 被调用者: []\n\n3. 函数名: netlink_net_capable\n- 参数: [cb->skb, CAP_NET_ADMIN]\n- 调用者: sctp_diag_dump\n- 被调用者: []\n\n4. 函数名: sctp_for_each_endpoint\n- 参数: [sctp_ep_dump, &commp]\n- 调用者: sctp_diag_dump\n- 被调用者: [sctp_ep_dump]\n\n5. 函数名: sctp_ep_dump\n- 参数: [&commp]\n- 调用者: sctp_for_each_endpoint\n- 被调用者: []\n\n6. 函数名: sctp_for_each_transport\n- 参数: [sctp_sock_filter, sctp_sock_dump, net, &pos, &commp]\n- 调用者: sctp_diag_dump\n- 被调用者: [sctp_sock_filter, sctp_sock_dump]\n\n7. 函数名: sctp_sock_filter\n- 参数: [未明确显示，但由sctp_for_each_transport调用]\n- 调用者: sctp_for_each_transport\n- 被调用者: []\n\n8. 函数名: sctp_sock_dump\n- 参数: [未明确显示，但由sctp_for_each_transport调用]\n- 调用者: sctp_for_each_transport\n- 被调用者: []"
    },
    {
        "id": 3341,
        "cwe": "CWE-362",
        "cve": "CVE-2022-20154",
        "purpose": "Code purpose:\"\"\"增加sctp端点的引用计数以防止其在被使用时被释放\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在lock_sock_nested函数中存在竞态条件，导致引用计数操作时可能发生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: sctp_endpoint_hold\n- 参数: [struct sctp_endpoint *ep]\n- 调用者: 未提供（需根据完整代码确定）\n- 被调用者: [refcount_inc]\n\n2. 函数名: refcount_inc\n- 参数: [&ep->base.refcnt]\n- 调用者: sctp_endpoint_hold\n- 被调用者: 未提供（需根据完整代码确定）"
    },
    {
        "id": 3342,
        "cwe": "CWE-362",
        "cve": "CVE-2022-20154",
        "purpose": "Code purpose:\"\"\"销毁SCTP端点并释放相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在销毁SCTP端点时存在竞态条件，导致在释放套接字资源后仍可能被访问，造成释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: sctp_endpoint_destroy\n- 参数: [struct sctp_endpoint *ep]\n- 调用者: 未显示\n- 被调用者: [WARN, kfree, sctp_auth_destroy_keys, sctp_auth_free, sctp_inq_free, sctp_bind_addr_free, memset, sctp_put_port, sock_put, SCTP_DBG_OBJCNT_DEC]\n\n2. 函数名: WARN\n- 参数: [1, \"Attempt to destroy undead endpoint %p!\\n\", ep]\n- 调用者: sctp_endpoint_destroy\n- 被调用者: 未显示\n\n3. 函数名: kfree\n- 参数: [ep->digest]\n- 调用者: sctp_endpoint_destroy\n- 被调用者: 未显示\n\n4. 函数名: sctp_auth_destroy_keys\n- 参数: [&ep->endpoint_shared_keys]\n- 调用者: sctp_endpoint_destroy\n- 被调用者: 未显示\n\n5. 函数名: sctp_auth_free\n- 参数: [ep]\n- 调用者: sctp_endpoint_destroy\n- 被调用者: 未显示\n\n6. 函数名: sctp_inq_free\n- 参数: [&ep->base.inqueue]\n- 调用者: sctp_endpoint_destroy\n- 被调用者: 未显示\n\n7. 函数名: sctp_bind_addr_free\n- 参数: [&ep->base.bind_addr]\n- 调用者: sctp_endpoint_destroy\n- 被调用者: 未显示\n\n8. 函数名: memset\n- 参数: [ep->secret_key, 0, sizeof(ep->secret_key)]\n- 调用者: sctp_endpoint_destroy\n- 被调用者: 未显示\n\n9. 函数名: sctp_put_port\n- 参数: [sk]\n- 调用者: sctp_endpoint_destroy\n- 被调用者: 未显示\n\n10. 函数名: sock_put\n- 参数: [sk]\n- 调用者: sctp_endpoint_destroy\n- 被调用者: 未显示\n\n11. 函数名: SCTP_DBG_OBJCNT_DEC\n- 参数: [ep]\n- 调用者: sctp_endpoint_destroy\n- 被调用者: 未显示"
    },
    {
        "id": 3397,
        "cwe": "CWE-362",
        "cve": "CVE-2022-20567",
        "purpose": "Code purpose:\"\"\"该代码片段定义了一个空的pppol2tp会话关闭函数，用于处理L2TP PPP会话的关闭操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于pppol2tp_session_close函数中存在竞态条件导致的释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: pppol2tp_session_close\n- 参数: [session]\n- 调用者: 未提供\n- 被调用者: []"
    },
    {
        "id": 3398,
        "cwe": "CWE-362",
        "cve": "CVE-2022-20567",
        "purpose": "Code purpose:\"\"\"该代码实现了PPPoL2TP协议的socket连接功能，包括隧道和会话的创建、绑定和管理，用于建立L2TP VPN连接。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在pppol2tp_connect函数中存在竞态条件，当多个线程同时访问和修改session和tunnel引用计数时可能导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: pppol2tp_connect\n- 参数: [struct socket *sock, struct sockaddr *uservaddr, int sockaddr_len, int flags]\n- 调用者: 未显示（由系统调用触发）\n- 被调用者: [lock_sock, pppox_sk, l2tp_tunnel_get, sock_net, l2tp_tunnel_create, l2tp_session_get, l2tp_session_priv, mutex_lock, rcu_dereference_protected, mutex_unlock, l2tp_session_create, pppol2tp_session_init, l2tp_session_inc_refcount, l2tp_session_register, kfree, ppp_register_net_channel, l2tp_session_dec_refcount, l2tp_tunnel_dec_refcount, release_sock]\n\n2. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n3. 函数名: pppox_sk\n- 参数: [struct sock *sk]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n4. 函数名: l2tp_tunnel_get\n- 参数: [struct net *net, u32 tunnel_id]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n5. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n6. 函数名: l2tp_tunnel_create\n- 参数: [struct net *net, int fd, int version, u32 tunnel_id, u32 peer_tunnel_id, struct l2tp_tunnel_cfg *cfg, struct l2tp_tunnel **tunnelp]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n7. 函数名: l2tp_session_get\n- 参数: [struct net *net, struct l2tp_tunnel *tunnel, u32 session_id]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n8. 函数名: l2tp_session_priv\n- 参数: [struct l2tp_session *session]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n9. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n10. 函数名: rcu_dereference_protected\n- 参数: [void *p, int condition]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n11. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n12. 函数名: l2tp_session_create\n- 参数: [int priv_size, struct l2tp_tunnel *tunnel, u32 session_id, u32 peer_session_id, struct l2tp_session_cfg *cfg]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n13. 函数名: pppol2tp_session_init\n- 参数: [struct l2tp_session *session]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n14. 函数名: l2tp_session_inc_refcount\n- 参数: [struct l2tp_session *session]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n15. 函数名: l2tp_session_register\n- 参数: [struct l2tp_session *session, struct l2tp_tunnel *tunnel]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n16. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n17. 函数名: ppp_register_net_channel\n- 参数: [struct net *net, struct ppp_channel *chan]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n18. 函数名: l2tp_session_dec_refcount\n- 参数: [struct l2tp_session *session]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n19. 函数名: l2tp_tunnel_dec_refcount\n- 参数: [struct l2tp_tunnel *tunnel]\n- 调用者: pppol2tp_connect\n- 被调用者: []\n\n20. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: pppol2tp_connect\n- 被调用者: []"
    },
    {
        "id": 3399,
        "cwe": "CWE-362",
        "cve": "CVE-2022-20567",
        "purpose": "Code purpose:\"\"\"释放PPPoL2TP套接字和相关会话资源，处理套接字状态变更和资源清理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在pppol2tp_release函数中存在竞态条件，导致在释放会话资源时可能出现use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: pppol2tp_release\n- 参数: [struct socket *sock]\n- 调用者: 未显示（通常由socket关闭操作调用）\n- 被调用者: [lock_sock, sock_flag, pppox_unbind_sock, sock_orphan, pppol2tp_sock_to_session, l2tp_session_delete, l2tp_session_priv, mutex_lock, rcu_dereference_protected, lockdep_is_held, RCU_INIT_POINTER, mutex_unlock, call_rcu, release_sock, sock_put]\n\n2. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n3. 函数名: sock_flag\n- 参数: [struct sock *sk, SOCK_DEAD]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n4. 函数名: pppox_unbind_sock\n- 参数: [struct sock *sk]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n5. 函数名: sock_orphan\n- 参数: [struct sock *sk]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n6. 函数名: pppol2tp_sock_to_session\n- 参数: [struct sock *sk]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n7. 函数名: l2tp_session_delete\n- 参数: [struct l2tp_session *session]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n8. 函数名: l2tp_session_priv\n- 参数: [struct l2tp_session *session]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n9. 函数名: mutex_lock\n- 参数: [&ps->sk_lock]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n10. 函数名: rcu_dereference_protected\n- 参数: [ps->sk, lockdep_is_held(&ps->sk_lock)]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n11. 函数名: lockdep_is_held\n- 参数: [&ps->sk_lock]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n12. 函数名: RCU_INIT_POINTER\n- 参数: [ps->sk, NULL]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n13. 函数名: mutex_unlock\n- 参数: [&ps->sk_lock]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n14. 函数名: call_rcu\n- 参数: [&ps->rcu, pppol2tp_put_sk]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n15. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n16. 函数名: sock_put\n- 参数: [struct sock *sk]\n- 调用者: pppol2tp_release\n- 被调用者: []\n\n17. 函数名: pppol2tp_put_sk\n- 参数: 未显示（通过call_rcu调用）\n- 调用者: call_rcu\n- 被调用者: []"
    },
    {
        "id": 3419,
        "cwe": "CWE-362",
        "cve": "CVE-2022-23036",
        "purpose": "Code purpose:\"\"\"结束对外部域授予的内存页面的访问权限，并根据情况释放资源或延迟处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"前端在移除后端访问权限时存在竞态条件，后端可能在权限检查后和实际移除前重新映射授权页面，导致后端持续拥有对客户机内存页的访问权限\"\"\"",
        "functions": "Functions:\n1. 函数名: gnttab_end_foreign_access\n- 参数: [grant_ref_t ref, int readonly, unsigned long page]\n- 调用者: 未指定（根据上下文可能是PV设备前端驱动）\n- 被调用者: [gnttab_end_foreign_access_ref, put_free_entry, put_page, virt_to_page, gnttab_add_deferred]\n\n2. 函数名: gnttab_end_foreign_access_ref\n- 参数: [grant_ref_t ref, int readonly]\n- 调用者: gnttab_end_foreign_access\n- 被调用者: 未指定\n\n3. 函数名: put_free_entry\n- 参数: [grant_ref_t ref]\n- 调用者: gnttab_end_foreign_access\n- 被调用者: 未指定\n\n4. 函数名: put_page\n- 参数: [struct page *page]\n- 调用者: gnttab_end_foreign_access\n- 被调用者: 未指定\n\n5. 函数名: virt_to_page\n- 参数: [unsigned long page]\n- 调用者: gnttab_end_foreign_access\n- 被调用者: 未指定\n\n6. 函数名: gnttab_add_deferred\n- 参数: [grant_ref_t ref, int readonly, struct page *page]\n- 调用者: gnttab_end_foreign_access\n- 被调用者: 未指定"
    },
    {
        "id": 3420,
        "cwe": "CWE-362",
        "cve": "CVE-2022-23037",
        "purpose": "Code purpose:\"\"\"该代码用于处理网络前端队列中的传输缓冲区垃圾回收，包括响应处理、资源释放和错误处理等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"前端在移除后端访问权限时存在竞态条件，恶意后端可能在权限检查后和权限移除前重新映射页面，从而保持对内存页的访问权限\"\"\"",
        "functions": "Functions:\n1. 函数名: xennet_tx_buf_gc\n- 参数: [struct netfront_queue *queue]\n- 调用者: 未显示\n- 被调用者: [dev_alert, RING_RESPONSE_PROD_OVERFLOW, RING_COPY_RESPONSE, gnttab_query_foreign_access, gnttab_end_foreign_access_ref, gnttab_release_grant_reference, add_id_to_list, dev_kfree_skb_irq, RING_FINAL_CHECK_FOR_RESPONSES, xennet_maybe_wake_tx]\n\n2. 函数名: dev_alert\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: xennet_tx_buf_gc\n- 被调用者: 未显示\n\n3. 函数名: RING_RESPONSE_PROD_OVERFLOW\n- 参数: [struct netfront_queue *queue, RING_IDX prod]\n- 调用者: xennet_tx_buf_gc\n- 被调用者: 未显示\n\n4. 函数名: RING_COPY_RESPONSE\n- 参数: [struct netfront_queue *queue, RING_IDX cons, struct xen_netif_tx_response *txrsp]\n- 调用者: xennet_tx_buf_gc\n- 被调用者: 未显示\n\n5. 函数名: gnttab_query_foreign_access\n- 参数: [grant_ref_t ref]\n- 调用者: xennet_tx_buf_gc\n- 被调用者: 未显示\n\n6. 函数名: gnttab_end_foreign_access_ref\n- 参数: [grant_ref_t ref, int readonly]\n- 调用者: xennet_tx_buf_gc\n- 被调用者: 未显示\n\n7. 函数名: gnttab_release_grant_reference\n- 参数: [grant_ref_t *head, grant_ref_t ref]\n- 调用者: xennet_tx_buf_gc\n- 被调用者: 未显示\n\n8. 函数名: add_id_to_list\n- 参数: [struct list_head *list, unsigned short *link, unsigned short id]\n- 调用者: xennet_tx_buf_gc\n- 被调用者: 未显示\n\n9. 函数名: dev_kfree_skb_irq\n- 参数: [struct sk_buff *skb]\n- 调用者: xennet_tx_buf_gc\n- 被调用者: 未显示\n\n10. 函数名: RING_FINAL_CHECK_FOR_RESPONSES\n- 参数: [struct netfront_queue *queue, bool *more_to_do]\n- 调用者: xennet_tx_buf_gc\n- 被调用者: 未显示\n\n11. 函数名: xennet_maybe_wake_tx\n- 参数: [struct netfront_queue *queue]\n- 调用者: xennet_tx_buf_gc\n- 被调用者: 未显示"
    },
    {
        "id": 3421,
        "cwe": "CWE-362",
        "cve": "CVE-2022-23039",
        "purpose": "Code purpose:\"\"\"该代码用于在Xen虚拟化环境中分配和管理grant reference，允许前端设备与后端设备共享内存页，但存在竞争条件漏洞可能导致恶意后端保持对内存页的访问权限\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在gntalloc驱动中，前端在移除后端访问权限时存在竞态条件，恶意后端可能在权限检查后但移除前映射授权页面，从而保持对客户机内存页的持续访问。\"\"\"",
        "functions": "Functions:\n1. 函数名: add_grefs\n- 参数: [struct ioctl_gntalloc_alloc_gref *op, uint32_t *gref_ids, struct gntalloc_file_private_data *priv]\n- 调用者: 未显示\n- 被调用者: [kzalloc, list_add_tail, alloc_page, gnttab_grant_foreign_access, xen_page_to_gfn, mutex_lock, list_splice_tail, mutex_unlock, list_for_each_entry_safe, list_del, __del_gref, list_empty]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*gref), GFP_KERNEL]\n- 调用者: add_grefs\n- 被调用者: 未显示\n\n3. 函数名: list_add_tail\n- 参数: [&gref->next_gref, &queue_gref], [&gref->next_file, &queue_file]\n- 调用者: add_grefs\n- 被调用者: 未显示\n\n4. 函数名: alloc_page\n- 参数: [GFP_KERNEL|__GFP_ZERO]\n- 调用者: add_grefs\n- 被调用者: 未显示\n\n5. 函数名: gnttab_grant_foreign_access\n- 参数: [op->domid, xen_page_to_gfn(gref->page), readonly]\n- 调用者: add_grefs\n- 被调用者: 未显示\n\n6. 函数名: xen_page_to_gfn\n- 参数: [gref->page]\n- 调用者: add_grefs\n- 被调用者: 未显示\n\n7. 函数名: mutex_lock\n- 参数: [&gref_mutex]\n- 调用者: add_grefs\n- 被调用者: 未显示\n\n8. 函数名: list_splice_tail\n- 参数: [&queue_gref, &gref_list], [&queue_file, &priv->list], [&queue_gref, &gref_list]\n- 调用者: add_grefs\n- 被调用者: 未显示\n\n9. 函数名: mutex_unlock\n- 参数: [&gref_mutex]\n- 调用者: add_grefs\n- 被调用者: 未显示\n\n10. 函数名: list_for_each_entry_safe\n- 参数: [gref, next, &queue_file, next_file]\n- 调用者: add_grefs\n- 被调用者: 未显示\n\n11. 函数名: list_del\n- 参数: [&gref->next_file]\n- 调用者: add_grefs\n- 被调用者: 未显示\n\n12. 函数名: __del_gref\n- 参数: [gref]\n- 调用者: add_grefs\n- 被调用者: 未显示\n\n13. 函数名: list_empty\n- 参数: [&queue_gref]\n- 调用者: add_grefs\n- 被调用者: 未显示"
    },
    {
        "id": 3422,
        "cwe": "CWE-362",
        "cve": "CVE-2022-23039",
        "purpose": "Code purpose:\"\"\"释放和管理Xen虚拟化环境中前端设备使用的grant reference资源，包括清除通知标志、释放内存页和解除后端访问权限。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在检查grant reference是否仍在使用后，代码假设后续的访问权限移除操作总会成功，但恶意后端可能在此期间映射granted page，导致前端无法真正移除后端的访问权限。\"\"\"",
        "functions": "Functions:\n1. 函数名: __del_gref\n- 参数: [struct gntalloc_gref *gref]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [kmap, kunmap, notify_remote_via_evtchn, evtchn_put, gnttab_query_foreign_access, gnttab_end_foreign_access_ref, gnttab_free_grant_reference, __free_page, kfree]\n\n2. 函数名: kmap\n- 参数: [gref->page]\n- 调用者: __del_gref\n- 被调用者: []\n\n3. 函数名: kunmap\n- 参数: [gref->page]\n- 调用者: __del_gref\n- 被调用者: []\n\n4. 函数名: notify_remote_via_evtchn\n- 参数: [gref->notify.event]\n- 调用者: __del_gref\n- 被调用者: []\n\n5. 函数名: evtchn_put\n- 参数: [gref->notify.event]\n- 调用者: __del_gref\n- 被调用者: []\n\n6. 函数名: gnttab_query_foreign_access\n- 参数: [gref->gref_id]\n- 调用者: __del_gref\n- 被调用者: []\n\n7. 函数名: gnttab_end_foreign_access_ref\n- 参数: [gref->gref_id, 0]\n- 调用者: __del_gref\n- 被调用者: []\n\n8. 函数名: gnttab_free_grant_reference\n- 参数: [gref->gref_id]\n- 调用者: __del_gref\n- 被调用者: []\n\n9. 函数名: __free_page\n- 参数: [gref->page]\n- 调用者: __del_gref\n- 被调用者: []\n\n10. 函数名: kfree\n- 参数: [gref]\n- 调用者: __del_gref\n- 被调用者: []"
    },
    {
        "id": 3423,
        "cwe": "CWE-362",
        "cve": "CVE-2022-23040",
        "purpose": "Code purpose:\"\"\"为Xen虚拟化环境中的前端设备分配并管理共享内存页面的访问权限\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"xenbus驱动在移除共享环缓冲区的授权访问时未检查操作是否成功，导致后端可能在授权访问被移除后仍保持对内存页的访问权限。\"\"\"",
        "functions": "Functions:\n1. 函数名: xenbus_grant_ring\n- 参数: [struct xenbus_device *dev, void *vaddr, unsigned int nr_pages, grant_ref_t *grefs]\n- 调用者: 未指定\n- 被调用者: [is_vmalloc_addr, pfn_to_gfn, vmalloc_to_pfn, virt_to_gfn, gnttab_grant_foreign_access, xenbus_dev_fatal, gnttab_end_foreign_access_ref]\n\n2. 函数名: is_vmalloc_addr\n- 参数: [void *vaddr]\n- 调用者: xenbus_grant_ring\n- 被调用者: 未指定\n\n3. 函数名: pfn_to_gfn\n- 参数: [unsigned long pfn]\n- 调用者: xenbus_grant_ring\n- 被调用者: 未指定\n\n4. 函数名: vmalloc_to_pfn\n- 参数: [void *vaddr]\n- 调用者: xenbus_grant_ring\n- 被调用者: 未指定\n\n5. 函数名: virt_to_gfn\n- 参数: [void *vaddr]\n- 调用者: xenbus_grant_ring\n- 被调用者: 未指定\n\n6. 函数名: gnttab_grant_foreign_access\n- 参数: [domid_t domid, unsigned long gfn, int readonly]\n- 调用者: xenbus_grant_ring\n- 被调用者: 未指定\n\n7. 函数名: xenbus_dev_fatal\n- 参数: [struct xenbus_device *dev, int err, const char *fmt, ...]\n- 调用者: xenbus_grant_ring\n- 被调用者: 未指定\n\n8. 函数名: gnttab_end_foreign_access_ref\n- 参数: [grant_ref_t ref, int readonly]\n- 调用者: xenbus_grant_ring\n- 被调用者: 未指定"
    },
    {
        "id": 3424,
        "cwe": "CWE-362",
        "cve": "CVE-2022-23042",
        "purpose": "Code purpose:\"\"\"处理网络前端队列中的接收数据包，包括响应处理、错误检查、数据填充和缓冲区管理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"netfront在撤销后端访问权限时未正确处理竞争条件，导致恶意后端可能保持对内存页的访问权限，触发断言失败造成拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: xennet_poll\n- 参数: [struct napi_struct *napi, int budget]\n- 调用者: N/A (内核网络子系统调用)\n- 被调用者: [container_of, dev_alert, RING_RESPONSE_PROD_OVERFLOW, rmb, RING_COPY_RESPONSE, memset, xennet_get_responses, __skb_dequeue, __skb_queue_tail, __skb_queue_head, xennet_set_skb_gso, xennet_set_rx_rsp_cons, skb_frag_off_set, skb_frag_size_set, xennet_fill_frags, xdp_do_flush, __skb_queue_purge, handle_incoming_queue, xennet_alloc_rx_buffers, napi_complete_done, RING_FINAL_CHECK_FOR_RESPONSES, napi_schedule]\n\n2. 函数名: container_of\n- 参数: [ptr, type, member]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n3. 函数名: dev_alert\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n4. 函数名: RING_RESPONSE_PROD_OVERFLOW\n- 参数: [ring, prod]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n5. 函数名: rmb\n- 参数: []\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n6. 函数名: RING_COPY_RESPONSE\n- 参数: [ring, idx, dst]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n7. 函数名: memset\n- 参数: [s, c, n]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n8. 函数名: xennet_get_responses\n- 参数: [struct netfront_queue *queue, struct netfront_rx_info *rinfo, RING_IDX rp, struct sk_buff_head *tmpq, bool *need_xdp_flush]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n9. 函数名: __skb_dequeue\n- 参数: [list]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n10. 函数名: __skb_queue_tail\n- 参数: [list, newsk]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n11. 函数名: __skb_queue_head\n- 参数: [list, newsk]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n12. 函数名: xennet_set_skb_gso\n- 参数: [struct sk_buff *skb, struct xen_netif_extra_info *gso]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n13. 函数名: xennet_set_rx_rsp_cons\n- 参数: [struct netfront_queue *queue, RING_IDX val]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n14. 函数名: skb_frag_off_set\n- 参数: [frag, val]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n15. 函数名: skb_frag_size_set\n- 参数: [frag, val]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n16. 函数名: xennet_fill_frags\n- 参数: [struct netfront_queue *queue, struct sk_buff *skb, struct sk_buff_head *tmpq]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n17. 函数名: xdp_do_flush\n- 参数: []\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n18. 函数名: __skb_queue_purge\n- 参数: [list]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n19. 函数名: handle_incoming_queue\n- 参数: [struct netfront_queue *queue, struct sk_buff_head *rxq]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n20. 函数名: xennet_alloc_rx_buffers\n- 参数: [struct netfront_queue *queue]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n21. 函数名: napi_complete_done\n- 参数: [struct napi_struct *n, int work_done]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n22. 函数名: RING_FINAL_CHECK_FOR_RESPONSES\n- 参数: [ring, more_to_do]\n- 调用者: xennet_poll\n- 被调用者: N/A\n\n23. 函数名: napi_schedule\n- 参数: [struct napi_struct *n]\n- 调用者: xennet_poll\n- 被调用者: N/A"
    },
    {
        "id": 3425,
        "cwe": "CWE-362",
        "cve": "CVE-2022-23042",
        "purpose": "Code purpose:\"\"\"处理网络前端队列中的接收响应，包括数据包处理、XDP程序执行和授权引用管理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"netfront在撤销访问权限时未正确处理竞争条件，导致恶意后端可能保持对内存页的访问，且当撤销失败时会触发BUG_ON()造成拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: xennet_get_responses\n- 参数: [struct netfront_queue *queue, struct netfront_rx_info *rinfo, RING_IDX rp, struct sk_buff_head *list, bool *need_xdp_flush]\n- 调用者: N/A (顶级函数)\n- 被调用者: [xennet_get_rx_skb, xennet_get_rx_ref, xennet_get_extras, dev_warn, xennet_move_rx_slot, gnttab_end_foreign_access_ref, gnttab_release_grant_reference, rcu_read_lock, rcu_dereference, xennet_run_xdp, rcu_read_unlock, __skb_queue_tail, RING_COPY_RESPONSE, xennet_set_rx_rsp_cons]\n\n2. 函数名: xennet_get_rx_skb\n- 参数: [struct netfront_queue *queue, RING_IDX cons]\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n3. 函数名: xennet_get_rx_ref\n- 参数: [struct netfront_queue *queue, RING_IDX cons]\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n4. 函数名: xennet_get_extras\n- 参数: [struct netfront_queue *queue, struct xen_netif_extra_info *extras, RING_IDX rp]\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n5. 函数名: dev_warn\n- 参数: [struct device *dev, const char *fmt, ...]\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n6. 函数名: xennet_move_rx_slot\n- 参数: [struct netfront_queue *queue, struct sk_buff *skb, grant_ref_t ref]\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n7. 函数名: gnttab_end_foreign_access_ref\n- 参数: [grant_ref_t ref, int readonly]\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n8. 函数名: gnttab_release_grant_reference\n- 参数: [grant_ref_t *head, grant_ref_t ref]\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n9. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n10. 函数名: rcu_dereference\n- 参数: [struct bpf_prog *xdp_prog]\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n11. 函数名: xennet_run_xdp\n- 参数: [struct netfront_queue *queue, struct page *page, struct xen_netif_rx_response *rx, struct bpf_prog *xdp_prog, struct xdp_buff *xdp, bool *need_xdp_flush]\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n12. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n13. 函数名: __skb_queue_tail\n- 参数: [struct sk_buff_head *list, struct sk_buff *skb]\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n14. 函数名: RING_COPY_RESPONSE\n- 参数: [struct netfront_queue *queue, RING_IDX cons, struct xen_netif_rx_response *rx_local]\n- 调用者: xennet_get_responses\n- 被调用者: []\n\n15. 函数名: xennet_set_rx_rsp_cons\n- 参数: [struct netfront_queue *queue, RING_IDX cons]\n- 调用者: xennet_get_responses\n- 被调用者: []"
    },
    {
        "id": 3426,
        "cwe": "CWE-362",
        "cve": "CVE-2022-23042",
        "purpose": "Code purpose:\"\"\"为Xen虚拟化环境中的网络前端设备(netfront)设置发送和接收环形缓冲区，并处理相关授权和事件通道的初始化工作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"netfront在撤销后端访问权限时存在竞态条件，未能正确同步释放数据页和撤销授权访问，导致后端可能保持对内存页的访问权限\"\"\"",
        "functions": "Functions:\n1. 函数名: setup_netfront\n- 参数: [struct xenbus_device *dev, struct netfront_queue *queue, unsigned int feature_split_evtchn]\n- 调用者: 未显示\n- 被调用者: [get_zeroed_page, SHARED_RING_INIT, FRONT_RING_INIT, xenbus_grant_ring, setup_netfront_split, setup_netfront_single, gnttab_end_foreign_access_ref, free_page, xenbus_dev_fatal]\n\n2. 函数名: get_zeroed_page\n- 参数: [GFP_NOIO | __GFP_HIGH]\n- 调用者: setup_netfront\n- 被调用者: 未显示\n\n3. 函数名: SHARED_RING_INIT\n- 参数: [txs/rxs]\n- 调用者: setup_netfront\n- 被调用者: 未显示\n\n4. 函数名: FRONT_RING_INIT\n- 参数: [&queue->tx/&queue->rx, txs/rxs, XEN_PAGE_SIZE]\n- 调用者: setup_netfront\n- 被调用者: 未显示\n\n5. 函数名: xenbus_grant_ring\n- 参数: [dev, txs/rxs, 1, &gref]\n- 调用者: setup_netfront\n- 被调用者: 未显示\n\n6. 函数名: setup_netfront_split\n- 参数: [queue]\n- 调用者: setup_netfront\n- 被调用者: 未显示\n\n7. 函数名: setup_netfront_single\n- 参数: [queue]\n- 调用者: setup_netfront\n- 被调用者: 未显示\n\n8. 函数名: gnttab_end_foreign_access_ref\n- 参数: [queue->rx_ring_ref/queue->tx_ring_ref, 0]\n- 调用者: setup_netfront\n- 被调用者: 未显示\n\n9. 函数名: free_page\n- 参数: [(unsigned long)rxs/(unsigned long)txs]\n- 调用者: setup_netfront\n- 被调用者: 未显示\n\n10. 函数名: xenbus_dev_fatal\n- 参数: [dev, err, \"allocating tx/rx ring page\"]\n- 调用者: setup_netfront\n- 被调用者: 未显示"
    },
    {
        "id": 3480,
        "cwe": "CWE-362",
        "cve": "CVE-2022-2590",
        "purpose": "Code purpose:\"\"\"处理内存页错误并管理写时复制(COW)操作，包括设置错误标志、处理错误返回和更新内存映射状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核内存子系统在处理私有只读共享内存映射的写时复制(COW)中断时存在竞态条件，导致本地低权限用户可获取对只读内存映射的写入权限\"\"\"",
        "functions": "Functions:\n1. 函数名: faultin_page\n- 参数: [struct vm_area_struct *vma, unsigned long address, unsigned int *flags, bool unshare, int *locked]\n- 调用者: 未明确显示（通常是内存管理相关的调用者）\n- 被调用者: [handle_mm_fault, vm_fault_to_errno, WARN_ON_ONCE]"
    },
    {
        "id": 3481,
        "cwe": "CWE-362",
        "cve": "CVE-2022-2590",
        "purpose": "Code purpose:\"\"\"处理设备映射页面的跟踪操作，包括权限检查、页面获取和引用计数管理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核内存子系统在处理私有只读共享内存映射的写时复制(COW)破坏时存在竞态条件，导致本地低权限用户可获取对只读内存映射的写入权限。\"\"\"",
        "functions": "Functions:\n1. 函数名: follow_devmap_pmd\n- 参数: [struct vm_area_struct *vma, unsigned long addr, pmd_t *pmd, int flags, struct dev_pagemap **pgmap]\n- 调用者: 未明确（由内核内存管理子系统调用）\n- 被调用者: [pmd_pfn, pmd_lockptr, assert_spin_locked, WARN_ONCE, WARN_ON_ONCE, pmd_write, pmd_present, pmd_devmap, touch_pmd, ERR_PTR, get_dev_pagemap, pfn_to_page, try_grab_page]\n\n2. 函数名: pmd_pfn\n- 参数: [pmd_t *pmd]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n3. 函数名: pmd_lockptr\n- 参数: [struct mm_struct *mm, pmd_t *pmd]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n4. 函数名: assert_spin_locked\n- 参数: [spinlock_t *lock]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n5. 函数名: WARN_ONCE\n- 参数: [bool condition, const char *fmt]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n6. 函数名: WARN_ON_ONCE\n- 参数: [bool condition]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n7. 函数名: pmd_write\n- 参数: [pmd_t *pmd]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n8. 函数名: pmd_present\n- 参数: [pmd_t *pmd]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n9. 函数名: pmd_devmap\n- 参数: [pmd_t *pmd]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n10. 函数名: touch_pmd\n- 参数: [struct vm_area_struct *vma, unsigned long addr, pmd_t *pmd, bool write]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n11. 函数名: ERR_PTR\n- 参数: [long error]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n12. 函数名: get_dev_pagemap\n- 参数: [unsigned long pfn, struct dev_pagemap *pgmap]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n13. 函数名: pfn_to_page\n- 参数: [unsigned long pfn]\n- 调用者: follow_devmap_pmd\n- 被调用者: []\n\n14. 函数名: try_grab_page\n- 参数: [struct page *page, int flags]\n- 调用者: follow_devmap_pmd\n- 被调用者: []"
    },
    {
        "id": 3482,
        "cwe": "CWE-362",
        "cve": "CVE-2022-2590",
        "purpose": "Code purpose:\"\"\"处理对透明大页(THP)的页表项(PMD)的跟踪操作，包括权限检查、NUMA提示处理以及页面的获取\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核内存子系统在处理私有只读共享内存映射的写时复制(COW)破坏时存在竞态条件，导致本地低权限用户可获取对只读内存映射的写入权限\"\"\"",
        "functions": "Functions:\n1. 函数名: follow_trans_huge_pmd\n- 参数: [vma, addr, pmd, flags]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [assert_spin_locked, can_follow_write_pmd, is_huge_zero_pmd, pmd_protnone, pmd_page, pmd_write, gup_must_unshare, try_grab_page, touch_pmd]\n\n2. 函数名: assert_spin_locked\n- 参数: [pmd_lockptr(mm, pmd)]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n3. 函数名: can_follow_write_pmd\n- 参数: [*pmd, flags]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n4. 函数名: is_huge_zero_pmd\n- 参数: [*pmd]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n5. 函数名: pmd_protnone\n- 参数: [*pmd]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n6. 函数名: pmd_page\n- 参数: [*pmd]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n7. 函数名: pmd_write\n- 参数: [*pmd]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n8. 函数名: gup_must_unshare\n- 参数: [flags, page]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n9. 函数名: try_grab_page\n- 参数: [page, flags]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []\n\n10. 函数名: touch_pmd\n- 参数: [vma, addr, pmd, flags & FOLL_WRITE]\n- 调用者: follow_trans_huge_pmd\n- 被调用者: []"
    },
    {
        "id": 3505,
        "cwe": "CWE-362",
        "cve": "CVE-2022-28796",
        "purpose": "Code purpose:\"\"\"该代码片段用于在Linux内核的jbd2日志系统中实现更新操作的锁定机制，通过屏障计数和等待条件来确保事务处理的同步与互斥。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在jbd2_journal_lock_updates函数中，由于未正确处理事务(transaction_t)的竞争条件，导致在等待更新完成时可能出现use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: jbd2_journal_lock_updates\n- 参数: [journal_t *journal]\n- 调用者: 未指定\n- 被调用者: [jbd2_might_wait_for_commit, atomic_read, write_lock, write_unlock, wait_event, jbd2_journal_wait_updates, mutex_lock]\n\n2. 函数名: jbd2_might_wait_for_commit\n- 参数: [journal_t *journal]\n- 调用者: jbd2_journal_lock_updates\n- 被调用者: 未指定\n\n3. 函数名: atomic_read\n- 参数: [atomic_t *v] (推断为 &journal->j_reserved_credits)\n- 调用者: jbd2_journal_lock_updates\n- 被调用者: 未指定\n\n4. 函数名: write_lock\n- 参数: [rwlock_t *lock] (具体为 &journal->j_state_lock)\n- 调用者: jbd2_journal_lock_updates\n- 被调用者: 未指定\n\n5. 函数名: write_unlock\n- 参数: [rwlock_t *lock] (具体为 &journal->j_state_lock)\n- 调用者: jbd2_journal_lock_updates\n- 被调用者: 未指定\n\n6. 函数名: wait_event\n- 参数: [wait_queue_head_t *q, condition] (具体为 journal->j_wait_reserved 和 atomic_read(&journal->j_reserved_credits) == 0)\n- 调用者: jbd2_journal_lock_updates\n- 被调用者: 未指定\n\n7. 函数名: jbd2_journal_wait_updates\n- 参数: [journal_t *journal]\n- 调用者: jbd2_journal_lock_updates\n- 被调用者: 未指定\n\n8. 函数名: mutex_lock\n- 参数: [struct mutex *lock] (具体为 &journal->j_barrier)\n- 调用者: jbd2_journal_lock_updates\n- 被调用者: 未指定"
    },
    {
        "id": 3506,
        "cwe": "CWE-362",
        "cve": "CVE-2022-28796",
        "purpose": "Code purpose:\"\"\"等待当前正在运行的日志事务完成所有更新操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放commit_transaction后，由于竞争条件导致在while循环中仍可能访问已释放的commit_transaction指针，造成use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: jbd2_journal_wait_updates\n- 参数: [journal]\n- 调用者: N/A\n- 被调用者: [atomic_read, spin_lock, DEFINE_WAIT, prepare_to_wait, spin_unlock, write_unlock, schedule, write_lock, finish_wait]\n\n2. 函数名: atomic_read\n- 参数: [&commit_transaction->t_updates]\n- 调用者: jbd2_journal_wait_updates\n- 被调用者: N/A\n\n3. 函数名: spin_lock\n- 参数: [&commit_transaction->t_handle_lock]\n- 调用者: jbd2_journal_wait_updates\n- 被调用者: N/A\n\n4. 函数名: DEFINE_WAIT\n- 参数: [wait]\n- 调用者: jbd2_journal_wait_updates\n- 被调用者: N/A\n\n5. 函数名: prepare_to_wait\n- 参数: [&journal->j_wait_updates, &wait, TASK_UNINTERRUPTIBLE]\n- 调用者: jbd2_journal_wait_updates\n- 被调用者: N/A\n\n6. 函数名: spin_unlock\n- 参数: [&commit_transaction->t_handle_lock]\n- 调用者: jbd2_journal_wait_updates\n- 被调用者: N/A\n\n7. 函数名: write_unlock\n- 参数: [&journal->j_state_lock]\n- 调用者: jbd2_journal_wait_updates\n- 被调用者: N/A\n\n8. 函数名: schedule\n- 参数: []\n- 调用者: jbd2_journal_wait_updates\n- 被调用者: N/A\n\n9. 函数名: write_lock\n- 参数: [&journal->j_state_lock]\n- 调用者: jbd2_journal_wait_updates\n- 被调用者: N/A\n\n10. 函数名: finish_wait\n- 参数: [&journal->j_wait_updates, &wait]\n- 调用者: jbd2_journal_wait_updates\n- 被调用者: N/A"
    },
    {
        "id": 3522,
        "cwe": "CWE-362",
        "cve": "CVE-2022-29582",
        "purpose": "Code purpose:\"\"\"处理io_uring中的超时请求，通过比较事件序列号来决定是否触发超时操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于io_uring超时处理中存在竞态条件，导致在时间序列比较和超时请求处理过程中可能发生use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_flush_timeouts\n- 参数: [ctx]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [atomic_read, spin_lock_irq, list_empty, list_first_entry, io_is_timeout_noseq, list_del_init, io_kill_timeout, spin_unlock_irq]\n\n2. 函数名: atomic_read\n- 参数: [&ctx->cq_timeouts]\n- 调用者: io_flush_timeouts\n- 被调用者: []\n\n3. 函数名: spin_lock_irq\n- 参数: [&ctx->timeout_lock]\n- 调用者: io_flush_timeouts\n- 被调用者: []\n\n4. 函数名: list_empty\n- 参数: [&ctx->timeout_list]\n- 调用者: io_flush_timeouts\n- 被调用者: []\n\n5. 函数名: list_first_entry\n- 参数: [&ctx->timeout_list, struct io_kiocb, timeout.list]\n- 调用者: io_flush_timeouts\n- 被调用者: []\n\n6. 函数名: io_is_timeout_noseq\n- 参数: [req]\n- 调用者: io_flush_timeouts\n- 被调用者: []\n\n7. 函数名: list_del_init\n- 参数: [&req->timeout.list]\n- 调用者: io_flush_timeouts\n- 被调用者: []\n\n8. 函数名: io_kill_timeout\n- 参数: [req, 0]\n- 调用者: io_flush_timeouts\n- 被调用者: []\n\n9. 函数名: spin_unlock_irq\n- 参数: [&ctx->timeout_lock]\n- 调用者: io_flush_timeouts\n- 被调用者: []"
    },
    {
        "id": 3523,
        "cwe": "CWE-362",
        "cve": "CVE-2022-29582",
        "purpose": "Code purpose:\"\"\"处理io_uring操作中的超时请求准备，包括参数验证、数据结构初始化和超时计时器设置\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于io_uring超时处理中存在竞态条件，导致在特定情况下可能发生释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_timeout_prep\n- 参数: [struct io_kiocb *req, const struct io_uring_sqe *sqe, bool is_timeout_link]\n- 调用者: 未明确显示（通常是io_uring相关操作调用）\n- 被调用者: [READ_ONCE, hweight32, INIT_LIST_HEAD, WARN_ON_ONCE, req_has_async_data, io_alloc_async_data, get_timespec64, io_translate_timeout_mode, hrtimer_init, io_timeout_get_clock]\n\n2. 函数名: READ_ONCE\n- 参数: [sqe->off, sqe->timeout_flags]\n- 调用者: io_timeout_prep\n- 被调用者: []\n\n3. 函数名: hweight32\n- 参数: [flags & IORING_TIMEOUT_CLOCK_MASK]\n- 调用者: io_timeout_prep\n- 被调用者: []\n\n4. 函数名: INIT_LIST_HEAD\n- 参数: [&req->timeout.list]\n- 调用者: io_timeout_prep\n- 被调用者: []\n\n5. 函数名: WARN_ON_ONCE\n- 参数: [req_has_async_data(req)]\n- 调用者: io_timeout_prep\n- 被调用者: []\n\n6. 函数名: req_has_async_data\n- 参数: [req]\n- 调用者: WARN_ON_ONCE\n- 被调用者: []\n\n7. 函数名: io_alloc_async_data\n- 参数: [req]\n- 调用者: io_timeout_prep\n- 被调用者: []\n\n8. 函数名: get_timespec64\n- 参数: [&data->ts, u64_to_user_ptr(sqe->addr)]\n- 调用者: io_timeout_prep\n- 被调用者: []\n\n9. 函数名: io_translate_timeout_mode\n- 参数: [flags]\n- 调用者: io_timeout_prep\n- 被调用者: []\n\n10. 函数名: hrtimer_init\n- 参数: [&data->timer, io_timeout_get_clock(data), data->mode]\n- 调用者: io_timeout_prep\n- 被调用者: []\n\n11. 函数名: io_timeout_get_clock\n- 参数: [data]\n- 调用者: hrtimer_init\n- 被调用者: []"
    },
    {
        "id": 3524,
        "cwe": "CWE-362",
        "cve": "CVE-2022-2959",
        "purpose": "Code purpose:\"\"\"该代码用于调整管道环形缓冲区的大小，包括分配新缓冲区、复制旧数据以及更新管道状态。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于pipe_resize_ring()函数在处理管道缓冲区时缺少适当的锁机制，导致存在竞争条件漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: pipe_resize_ring\n- 参数: [struct pipe_inode_info *pipe, unsigned int nr_slots]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [pipe_occupancy, kcalloc, memcpy, kfree, wake_up_interruptible]\n\n2. 函数名: pipe_occupancy\n- 参数: [pipe->head, pipe->tail]\n- 调用者: pipe_resize_ring\n- 被调用者: []\n\n3. 函数名: kcalloc\n- 参数: [nr_slots, sizeof(*bufs), GFP_KERNEL_ACCOUNT | __GFP_NOWARN]\n- 调用者: pipe_resize_ring\n- 被调用者: []\n\n4. 函数名: memcpy\n- 参数: [bufs, pipe->bufs + t, n * sizeof(struct pipe_buffer)] 或 [bufs + tsize, pipe->bufs, h * sizeof(struct pipe_buffer)] 或 [bufs, pipe->bufs + t, tsize * sizeof(struct pipe_buffer)]\n- 调用者: pipe_resize_ring\n- 被调用者: []\n\n5. 函数名: kfree\n- 参数: [pipe->bufs]\n- 调用者: pipe_resize_ring\n- 被调用者: []\n\n6. 函数名: wake_up_interruptible\n- 参数: [&pipe->wr_wait]\n- 调用者: pipe_resize_ring\n- 被调用者: []"
    },
    {
        "id": 3542,
        "cwe": "CWE-362",
        "cve": "CVE-2022-3028",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的XFRM子系统中处理PF_KEY套接字的注册请求，包括验证消息类型、更新注册状态、探测算法并广播支持信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于xfrm_probe_algs()函数在并发调用时存在竞态条件，可能导致越界写入或内核堆内存泄露\"\"\"",
        "functions": "Functions:\n1. 函数名: pfkey_register\n- 参数: [sk, skb, hdr, ext_hdrs]\n- 调用者: N/A (顶层函数)\n- 被调用者: [pfkey_sk, xfrm_probe_algs, compose_sadb_supported, pfkey_broadcast, sock_net]\n\n2. 函数名: pfkey_sk\n- 参数: [sk]\n- 调用者: pfkey_register\n- 被调用者: []\n\n3. 函数名: xfrm_probe_algs\n- 参数: []\n- 调用者: pfkey_register\n- 被调用者: []\n\n4. 函数名: compose_sadb_supported\n- 参数: [hdr, GFP_KERNEL | __GFP_ZERO]\n- 调用者: pfkey_register\n- 被调用者: []\n\n5. 函数名: pfkey_broadcast\n- 参数: [supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk, sock_net(sk)]\n- 调用者: pfkey_register\n- 被调用者: []\n\n6. 函数名: sock_net\n- 参数: [sk]\n- 调用者: pfkey_register\n- 被调用者: []"
    },
    {
        "id": 3603,
        "cwe": "CWE-362",
        "cve": "CVE-2022-3521",
        "purpose": "Code purpose:\"\"\"该代码实现了KCM (Kernel Connection Multiplexor)套接字释放功能，包括清理写队列、停止传输工作、取消相关psock绑定等操作，确保套接字资源被安全释放。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在kcm_release函数中存在竞态条件，由于对kcm_sock结构的操作缺乏适当的同步保护，导致在释放资源时可能与其他线程（如tx_work）产生竞争。\"\"\"",
        "functions": "Functions:\n1. 函数名: kcm_release\n- 参数: [struct socket *sock]\n- 调用者: 无（系统调用或外部调用）\n- 被调用者: [kcm_sk, sock_orphan, kfree_skb, lock_sock, __skb_queue_purge, release_sock, spin_lock_bh, list_del, spin_unlock_bh, cancel_work_sync, kcm_abort_tx_psock, unreserve_psock, kcm_done]\n\n2. 函数名: kcm_sk\n- 参数: [struct sock *sk]\n- 调用者: kcm_release\n- 被调用者: 无\n\n3. 函数名: sock_orphan\n- 参数: [struct sock *sk]\n- 调用者: kcm_release\n- 被调用者: 无\n\n4. 函数名: kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: kcm_release\n- 被调用者: 无\n\n5. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: kcm_release\n- 被调用者: 无\n\n6. 函数名: __skb_queue_purge\n- 参数: [struct sk_buff_head *list]\n- 调用者: kcm_release\n- 被调用者: 无\n\n7. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: kcm_release\n- 被调用者: 无\n\n8. 函数名: spin_lock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: kcm_release\n- 被调用者: 无\n\n9. 函数名: list_del\n- 参数: [struct list_head *entry]\n- 调用者: kcm_release\n- 被调用者: 无\n\n10. 函数名: spin_unlock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: kcm_release\n- 被调用者: 无\n\n11. 函数名: cancel_work_sync\n- 参数: [struct work_struct *work]\n- 调用者: kcm_release\n- 被调用者: 无\n\n12. 函数名: kcm_abort_tx_psock\n- 参数: [struct kcm_psock *psock, int err, bool wakeup_kcm]\n- 调用者: kcm_release\n- 被调用者: 无\n\n13. 函数名: unreserve_psock\n- 参数: [struct kcm_sock *kcm]\n- 调用者: kcm_release\n- 被调用者: 无\n\n14. 函数名: kcm_done\n- 参数: [struct kcm_sock *kcm]\n- 调用者: kcm_release\n- 被调用者: 无"
    },
    {
        "id": 3636,
        "cwe": "CWE-362",
        "cve": "CVE-2022-3564",
        "purpose": "Code purpose:\"\"\"处理蓝牙L2CAP协议中接收到的数据帧，包括帧的重新组装、序列号验证、错误处理以及状态管理，同时处理可能出现的竞争条件问题。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在蓝牙L2CAP协议处理过程中，当重组SDU数据时存在释放后重用(UAF)问题，导致使用已被释放的内存。\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_rx_state_recv\n- 参数: [chan, control, skb, event]\n- 调用者: 未显示\n- 被调用者: [l2cap_classify_txseq, l2cap_pass_to_tx, __next_seq, l2cap_reassemble_sdu, test_and_clear_bit, l2cap_retransmit_all, l2cap_ertm_send, test_bit, l2cap_send_ack, skb_queue_tail, skb_queue_len, clear_bit, l2cap_seq_list_clear, l2cap_send_srej, l2cap_send_disconn_req, __chan_is_moving, l2cap_send_i_or_rr_or_rnr, __set_retrans_timer, set_bit, l2cap_send_rr_or_rnr, __clear_retrans_timer, l2cap_handle_rej, l2cap_handle_srej, kfree_skb]\n\n2. 函数名: l2cap_classify_txseq\n- 参数: [chan, control->txseq]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n3. 函数名: l2cap_pass_to_tx\n- 参数: [chan, control]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n4. 函数名: __next_seq\n- 参数: [chan, control->txseq]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n5. 函数名: l2cap_reassemble_sdu\n- 参数: [chan, skb, control]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n6. 函数名: test_and_clear_bit\n- 参数: [CONN_REJ_ACT, &chan->conn_state]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n7. 函数名: l2cap_retransmit_all\n- 参数: [chan, control]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n8. 函数名: l2cap_ertm_send\n- 参数: [chan]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n9. 函数名: test_bit\n- 参数: [CONN_LOCAL_BUSY, &chan->conn_state]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n10. 函数名: l2cap_send_ack\n- 参数: [chan]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n11. 函数名: skb_queue_tail\n- 参数: [&chan->srej_q, skb]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n12. 函数名: skb_queue_len\n- 参数: [&chan->srej_q]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n13. 函数名: clear_bit\n- 参数: [CONN_SREJ_ACT, &chan->conn_state]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n14. 函数名: l2cap_send_srej\n- 参数: [chan, control->txseq]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n15. 函数名: l2cap_send_disconn_req\n- 参数: [chan, ECONNRESET]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n16. 函数名: __chan_is_moving\n- 参数: [chan]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n17. 函数名: l2cap_send_i_or_rr_or_rnr\n- 参数: [chan]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n18. 函数名: __set_retrans_timer\n- 参数: [chan]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n19. 函数名: set_bit\n- 参数: [CONN_REMOTE_BUSY, &chan->conn_state], [CONN_SEND_FBIT, &chan->conn_state]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n20. 函数名: l2cap_send_rr_or_rnr\n- 参数: [chan, 0]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n21. 函数名: __clear_retrans_timer\n- 参数: [chan]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n22. 函数名: l2cap_handle_rej\n- 参数: [chan, control]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n23. 函数名: l2cap_handle_srej\n- 参数: [chan, control]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示\n\n24. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: l2cap_rx_state_recv\n- 被调用者: 未显示"
    },
    {
        "id": 3637,
        "cwe": "CWE-362",
        "cve": "CVE-2022-3564",
        "purpose": "Code purpose:\"\"\"该代码片段实现了蓝牙L2CAP协议中接收数据流并进行重组的功能，处理数据包的顺序验证和缓冲区管理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放skb后仍可能通过chan->sdu引用导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_stream_rx\n- 参数: [chan, control, skb]\n- 调用者: 未显示（外部调用）\n- 被调用者: [l2cap_classify_txseq, l2cap_pass_to_tx, __next_seq, l2cap_reassemble_sdu, kfree_skb]\n\n2. 函数名: l2cap_classify_txseq\n- 参数: [chan, control->txseq]\n- 调用者: l2cap_stream_rx\n- 被调用者: 未显示\n\n3. 函数名: l2cap_pass_to_tx\n- 参数: [chan, control]\n- 调用者: l2cap_stream_rx\n- 被调用者: 未显示\n\n4. 函数名: __next_seq\n- 参数: [chan, chan->buffer_seq]\n- 调用者: l2cap_stream_rx\n- 被调用者: 未显示\n\n5. 函数名: l2cap_reassemble_sdu\n- 参数: [chan, skb, control]\n- 调用者: l2cap_stream_rx\n- 被调用者: 未显示\n\n6. 函数名: kfree_skb\n- 参数: [chan->sdu] 或 [skb]\n- 调用者: l2cap_stream_rx\n- 被调用者: 未显示"
    },
    {
        "id": 3641,
        "cwe": "CWE-362",
        "cve": "CVE-2022-3566",
        "purpose": "Code purpose:\"\"\"该代码实现了TCP套接字选项的获取功能，根据不同的协议级别调用相应的处理函数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于tcp_getsockopt函数在处理socket选项时未正确同步多线程访问，导致竞争条件(CWE-362)的发生。\"\"\"",
        "functions": "Functions:\n1. 函数名: tcp_getsockopt\n- 参数: [struct sock *sk, int level, int optname, char __user *optval, int __user *optlen]\n- 调用者: 未指定（由内核TCP处理流程调用）\n- 被调用者: [inet_csk, icsk->icsk_af_ops->getsockopt, do_tcp_getsockopt, USER_SOCKPTR]\n\n2. 函数名: inet_csk\n- 参数: [struct sock *sk]\n- 调用者: tcp_getsockopt\n- 被调用者: 未指定（内核内部函数）\n\n3. 函数名: icsk_af_ops->getsockopt\n- 参数: [struct sock *sk, int level, int optname, char __user *optval, int __user *optlen]\n- 调用者: tcp_getsockopt\n- 被调用者: 未指定（函数指针，具体实现取决于协议族）\n\n4. 函数名: do_tcp_getsockopt\n- 参数: [struct sock *sk, int level, int optname, USER_SOCKPTR(optval), USER_SOCKPTR(optlen)]\n- 调用者: tcp_getsockopt\n- 被调用者: 未指定（内核内部函数）\n\n5. 函数名: USER_SOCKPTR\n- 参数: [指针类型参数]\n- 调用者: tcp_getsockopt\n- 被调用者: 未指定（宏/内联函数）"
    },
    {
        "id": 3642,
        "cwe": "CWE-362",
        "cve": "CVE-2022-3566",
        "purpose": "Code purpose:\"\"\"处理TCP套接字选项的设置，根据不同的协议级别选择相应的设置函数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于tcp_setsockopt函数在处理套接字选项时缺乏适当的同步机制，导致多个线程同时访问时可能引发竞争条件漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: tcp_setsockopt\n- 参数: [struct sock *sk, int level, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: 未显示（由内核TCP处理逻辑调用）\n- 被调用者: [inet_csk, icsk->icsk_af_ops->setsockopt, do_tcp_setsockopt]\n\n2. 函数名: inet_csk\n- 参数: [struct sock *sk]\n- 调用者: tcp_setsockopt\n- 被调用者: 未显示（返回const struct inet_connection_sock *）\n\n3. 函数名: icsk_af_ops->setsockopt\n- 参数: [struct sock *sk, int level, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: tcp_setsockopt\n- 被调用者: 未显示（函数指针调用）\n\n4. 函数名: do_tcp_setsockopt\n- 参数: [struct sock *sk, int level, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: tcp_setsockopt\n- 被调用者: 未显示"
    },
    {
        "id": 3643,
        "cwe": "CWE-362",
        "cve": "CVE-2022-3566",
        "purpose": "Code purpose:\"\"\"处理IPv6套接字选项的设置操作，包括地址转换、多播控制、流量标签管理等网络配置功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理TCP套接字选项时，由于缺乏适当的同步机制，导致在多线程环境下可能出现竞争条件漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: do_ipv6_setsockopt\n- 参数: [struct sock *sk, int level, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: N/A (顶层函数)\n- 被调用者: [sock_net, sockptr_is_null, copy_from_sockptr, ip6_mroute_opt, ip6_mroute_setsockopt, rtnl_lock, sockopt_lock_sock, udp_sk, inet_csk, sk_refcnt_debug_dec, sock_prot_inuse_add, WRITE_ONCE, tcp_sync_mss, module_put, inet6_cleanup_sock, sk_refcnt_debug_inc, ipv6_set_opt_hdr, sk_dev_equal_l3scope, sock_kmalloc, copy_from_sockptr, ip6_datagram_send_ctl, ipv6_update_options, txopt_put, dev_get_by_index, dev_put, dev_get_by_index_rcu, l3mdev_master_ifindex_rcu, ipv6_sock_mc_join, ipv6_sock_mc_drop, ipv6_sock_ac_join, ipv6_sock_ac_drop, compat_ipv6_mcast_join_leave, ipv6_mcast_join_leave, do_ipv6_mcast_group_source, compat_ipv6_set_mcast_msfilter, ipv6_set_mcast_msfilter, ip6_ra_control, __ip6_sock_set_addr_preferences, sockopt_release_sock, rtnl_unlock]\n\n2. 函数名: setsockopt_needs_rtnl\n- 参数: [int optname]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n3. 函数名: ip6_mroute_opt\n- 参数: [int optname]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n4. 函数名: ip6_mroute_setsockopt\n- 参数: [struct sock *sk, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n5. 函数名: ipv6_set_opt_hdr\n- 参数: [struct sock *sk, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n6. 函数名: ip6_datagram_send_ctl\n- 参数: [struct net *net, struct sock *sk, struct msghdr *msg, struct flowi6 *fl6, struct ipcm6_cookie *ipc6]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n7. 函数名: ipv6_update_options\n- 参数: [struct sock *sk, struct ipv6_txoptions *opt]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n8. 函数名: ipv6_sock_mc_join\n- 参数: [struct sock *sk, int ifindex, struct in6_addr *addr]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n9. 函数名: ipv6_sock_mc_drop\n- 参数: [struct sock *sk, int ifindex, struct in6_addr *addr]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n10. 函数名: ipv6_sock_ac_join\n- 参数: [struct sock *sk, int ifindex, struct in6_addr *addr]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n11. 函数名: ipv6_sock_ac_drop\n- 参数: [struct sock *sk, int ifindex, struct in6_addr *addr]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n12. 函数名: compat_ipv6_mcast_join_leave\n- 参数: [struct sock *sk, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n13. 函数名: ipv6_mcast_join_leave\n- 参数: [struct sock *sk, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n14. 函数名: do_ipv6_mcast_group_source\n- 参数: [struct sock *sk, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n15. 函数名: compat_ipv6_set_mcast_msfilter\n- 参数: [struct sock *sk, sockptr_t optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n16. 函数名: ipv6_set_mcast_msfilter\n- 参数: [struct sock *sk, sockptr_t optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n17. 函数名: ip6_ra_control\n- 参数: [struct sock *sk, int val]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n18. 函数名: __ip6_sock_set_addr_preferences\n- 参数: [struct sock *sk, int val]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n19. 函数名: xfrm_user_policy\n- 参数: [struct sock *sk, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n20. 函数名: ipv6_flowlabel_opt\n- 参数: [struct sock *sk, sockptr_t optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []"
    },
    {
        "id": 3644,
        "cwe": "CWE-362",
        "cve": "CVE-2022-3566",
        "purpose": "Code purpose:\"\"\"该代码实现了IPv6环境下TCP连接的建立过程，包括地址验证、流标签处理、连接状态管理以及与IPv4的兼容性处理等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理TCP套接字选项(tcp_getsockopt/tcp_setsockopt)时存在竞态条件，多个线程可能同时访问和修改共享资源而缺乏适当的同步机制\"\"\"",
        "functions": "Functions:\n1. 函数名: tcp_v6_connect\n- 参数: [sk, uaddr, addr_len]\n- 调用者: 无（顶层函数）\n- 被调用者: [inet_csk, tcp_inet6_sk, inet_sk, tcp_sk, sock_net, memset, IP6_ECN_flow_init, fl6_sock_lookup, fl6_sock_release, ipv6_addr_any, ipv6_addr_v4mapped, ipv6_addr_set_v4mapped, ipv6_addr_type, sk_dev_equal_l3scope, ipv6_addr_equal, WRITE_ONCE, ipv6_only_sock, tcp_v4_connect, mptcpv6_handle_mapped, rcu_dereference_protected, fl6_update_dst, security_sk_classify_flow, ip6_dst_lookup_flow, inet_bhashfn_portaddr, inet_bhash2_update_saddr, ip6_dst_store, tcp_set_state, inet6_hash_connect, sk_set_txhash, secure_tcpv6_seq, secure_tcpv6_ts_off, tcp_fastopen_defer_connect, tcp_connect]\n\n2. 函数名: inet_csk\n- 参数: [sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n3. 函数名: tcp_inet6_sk\n- 参数: [sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n4. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n5. 函数名: tcp_sk\n- 参数: [sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n6. 函数名: sock_net\n- 参数: [sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n7. 函数名: IP6_ECN_flow_init\n- 参数: [fl6.flowlabel]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n8. 函数名: fl6_sock_lookup\n- 参数: [sk, fl6.flowlabel]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n9. 函数名: fl6_sock_release\n- 参数: [flowlabel]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n10. 函数名: ipv6_addr_any\n- 参数: [&usin->sin6_addr]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n11. 函数名: ipv6_addr_v4mapped\n- 参数: [&sk->sk_v6_rcv_saddr]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n12. 函数名: ipv6_addr_set_v4mapped\n- 参数: [htonl(INADDR_LOOPBACK), &usin->sin6_addr]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n13. 函数名: ipv6_addr_type\n- 参数: [&usin->sin6_addr]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n14. 函数名: sk_dev_equal_l3scope\n- 参数: [sk, usin->sin6_scope_id]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n15. 函数名: ipv6_addr_equal\n- 参数: [&sk->sk_v6_daddr, &usin->sin6_addr]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n16. 函数名: ipv6_only_sock\n- 参数: [sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n17. 函数名: tcp_v4_connect\n- 参数: [sk, (struct sockaddr *)&sin, sizeof(sin)]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n18. 函数名: mptcpv6_handle_mapped\n- 参数: [sk, true/false]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n19. 函数名: rcu_dereference_protected\n- 参数: [np->opt, lockdep_sock_is_held(sk)]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n20. 函数名: fl6_update_dst\n- 参数: [&fl6, opt, &final]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n21. 函数名: security_sk_classify_flow\n- 参数: [sk, flowi6_to_flowi_common(&fl6)]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n22. 函数名: ip6_dst_lookup_flow\n- 参数: [net, sk, &fl6, final_p]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n23. 函数名: inet_bhashfn_portaddr\n- 参数: [tcp_death_row->hashinfo, sk, net, inet->inet_num]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n24. 函数名: inet_bhash2_update_saddr\n- 参数: [prev_addr_hashbucket, sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n25. 函数名: ip6_dst_store\n- 参数: [sk, dst, NULL, NULL]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n26. 函数名: tcp_set_state\n- 参数: [sk, TCP_SYN_SENT/TCP_CLOSE]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n27. 函数名: inet6_hash_connect\n- 参数: [tcp_death_row, sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n28. 函数名: sk_set_txhash\n- 参数: [sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n29. 函数名: secure_tcpv6_seq\n- 参数: [np->saddr.s6_addr32, sk->sk_v6_daddr.s6_addr32, inet->inet_sport, inet->inet_dport]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n30. 函数名: secure_tcpv6_ts_off\n- 参数: [net, np->saddr.s6_addr32, sk->sk_v6_daddr.s6_addr32]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n31. 函数名: tcp_fastopen_defer_connect\n- 参数: [sk, &err]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n32. 函数名: tcp_connect\n- 参数: [sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无"
    },
    {
        "id": 3645,
        "cwe": "CWE-362",
        "cve": "CVE-2022-3567",
        "purpose": "Code purpose:\"\"\"该代码片段实现了通过socket设置选项的功能，将选项设置请求传递给底层协议处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于在IPv6处理程序中，setsockopt操作未正确处理并发访问导致的竞争条件问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: sock_common_setsockopt\n- 参数: [struct socket *sock, int level, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [sk->sk_prot->setsockopt]\n\n2. 函数名: setsockopt\n- 参数: [struct sock *sk, int level, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: sock_common_setsockopt\n- 被调用者: 未明确（由sk->sk_prot指向的函数实现）"
    },
    {
        "id": 3646,
        "cwe": "CWE-362",
        "cve": "CVE-2022-3567",
        "purpose": "Code purpose:\"\"\"该代码片段实现了通过socket获取选项值的功能，通过调用底层协议特定的getsockopt方法来处理用户空间的选项值和长度参数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于在IPv6处理组件的getsockopt操作中缺乏适当的同步机制，导致在多线程环境下可能发生竞争条件。\"\"\"",
        "functions": "Functions:\n1. 函数名: sock_common_getsockopt\n- 参数: [struct socket *sock, int level, int optname, char __user *optval, int __user *optlen]\n- 调用者: 未指定（由内核其他部分调用）\n- 被调用者: [sk->sk_prot->getsockopt]\n\n2. 函数名: sk->sk_prot->getsockopt\n- 参数: [struct sock *sk, int level, int optname, char __user *optval, int __user *optlen]\n- 调用者: sock_common_getsockopt\n- 被调用者: 未指定（具体实现取决于协议类型）"
    },
    {
        "id": 3647,
        "cwe": "CWE-362",
        "cve": "CVE-2022-3567",
        "purpose": "Code purpose:\"\"\"该代码实现了IPv6套接字接受连接的功能，包括获取新连接、状态验证和连接建立\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于在IPv6处理程序中inet_accept函数存在竞态条件，当多个线程同时访问共享资源时缺乏适当的同步机制，导致状态不一致。\"\"\"",
        "functions": "Functions:\n1. 函数名: inet_accept\n- 参数: [struct socket *sock, struct socket *newsock, int flags, bool kern]\n- 调用者: 未明确（由IPv6 Handler调用）\n- 被调用者: [sk1->sk_prot->accept, lock_sock, sock_rps_record_flow, WARN_ON, sock_graft, release_sock]\n\n2. 函数名: sk1->sk_prot->accept\n- 参数: [struct sock *sk1, int flags, int *err, bool kern]\n- 调用者: inet_accept\n- 被调用者: 未明确（协议特定的accept实现）\n\n3. 函数名: lock_sock\n- 参数: [struct sock *sk2]\n- 调用者: inet_accept\n- 被调用者: 未明确（内核锁函数）\n\n4. 函数名: sock_rps_record_flow\n- 参数: [struct sock *sk2]\n- 调用者: inet_accept\n- 被调用者: 未明确（记录流信息的函数）\n\n5. 函数名: WARN_ON\n- 参数: [!(1 << sk2->sk_state) & (TCPF_ESTABLISHED | TCPF_SYN_RECV | TCPF_CLOSE_WAIT | TCPF_CLOSE)]\n- 调用者: inet_accept\n- 被调用者: 未明确（内核警告宏）\n\n6. 函数名: sock_graft\n- 参数: [struct sock *sk2, struct socket *newsock]\n- 调用者: inet_accept\n- 被调用者: 未明确（socket嫁接函数）\n\n7. 函数名: release_sock\n- 参数: [struct sock *sk2]\n- 调用者: inet_accept\n- 被调用者: 未明确（内核锁释放函数）"
    },
    {
        "id": 3648,
        "cwe": "CWE-362",
        "cve": "CVE-2022-3567",
        "purpose": "Code purpose:\"\"\"该代码片段实现了通过socket发送页面数据的核心功能，支持IPv6协议处理发送操作时的竞态条件检查\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于IPv6处理程序中的inet6_stream_ops/inet6_dgram_ops组件存在竞态条件，导致在调用sendpage时可能出现并发访问问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: inet_sendpage\n- 参数: [sock, page, offset, size, flags]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [inet_send_prepare, sock_no_sendpage]\n\n2. 函数名: inet_send_prepare\n- 参数: [sk]\n- 调用者: inet_sendpage\n- 被调用者: 未明确\n\n3. 函数名: sock_no_sendpage\n- 参数: [sock, page, offset, size, flags]\n- 调用者: inet_sendpage\n- 被调用者: 未明确\n\n4. 函数名: sendpage (通过sk->sk_prot->sendpage调用)\n- 参数: [sk, page, offset, size, flags]\n- 调用者: inet_sendpage\n- 被调用者: 未明确"
    },
    {
        "id": 3649,
        "cwe": "CWE-362",
        "cve": "CVE-2022-3567",
        "purpose": "Code purpose:\"\"\"处理IPv6数据报套接字的连接操作，包括地址验证、协议断开、BPF预处理和自动绑定检查\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于在IPv6处理程序中存在竞争条件，特别是在inet6_stream_ops/inet6_dgram_ops组件的inet_dgram_connect函数中，缺乏适当的同步机制导致的数据竞争问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: inet_dgram_connect\n- 参数: [struct socket *sock, struct sockaddr *uaddr, int addr_len, int flags]\n- 调用者: 未明确（由系统调用或其他网络协议栈代码调用）\n- 被调用者: [sk->sk_prot->disconnect, sk->sk_prot->pre_connect, inet_sk, inet_autobind, sk->sk_prot->connect]\n\n2. 函数名: disconnect\n- 参数: [struct sock *sk, int flags]\n- 调用者: sk->sk_prot->disconnect (通过函数指针调用)\n- 被调用者: 未明确\n\n3. 函数名: pre_connect\n- 参数: [struct sock *sk, struct sockaddr *uaddr, int addr_len]\n- 调用者: sk->sk_prot->pre_connect (通过函数指针调用)\n- 被调用者: 未明确\n\n4. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: inet_dgram_connect\n- 被调用者: 未明确\n\n5. 函数名: inet_autobind\n- 参数: [struct sock *sk]\n- 调用者: inet_dgram_connect\n- 被调用者: 未明确\n\n6. 函数名: connect\n- 参数: [struct sock *sk, struct sockaddr *uaddr, int addr_len]\n- 调用者: sk->sk_prot->connect (通过函数指针调用)\n- 被调用者: 未明确"
    },
    {
        "id": 3657,
        "cwe": "CWE-362",
        "cve": "CVE-2022-3623",
        "purpose": "Code purpose:\"\"\"该代码用于处理虚拟内存页的跟踪和访问，包括页表项检查、页权限验证和页获取操作，同时处理并发访问时的竞争条件问题。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在follow_page_pte函数中存在竞态条件漏洞，由于未正确处理页表项(pte)的并发访问，导致在多线程环境下可能引发安全问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: follow_page_pte\n- 参数: [vma, address, pmd, flags, pgmap]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [WARN_ON_ONCE, ERR_PTR, pmd_bad, no_page_table, pte_offset_map_lock, pte_present, pte_unmap_unlock, migration_entry_wait, pte_none, pte_to_swp_entry, is_migration_entry, pte_protnone, vm_normal_page, can_follow_write_pte, pte_devmap, get_dev_pagemap, pte_page, is_zero_pfn, follow_pfn_pte, pte_write, gup_must_unshare, try_grab_page, arch_make_page_accessible, unpin_user_page, pte_dirty, set_page_dirty, mark_page_accessed]\n\n2. 函数名: WARN_ON_ONCE\n- 参数: [condition]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n3. 函数名: ERR_PTR\n- 参数: [error_code]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n4. 函数名: pmd_bad\n- 参数: [pmd]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n5. 函数名: no_page_table\n- 参数: [vma, flags]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n6. 函数名: pte_offset_map_lock\n- 参数: [mm, pmd, address, ptl]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n7. 函数名: pte_present\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n8. 函数名: pte_unmap_unlock\n- 参数: [ptep, ptl]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n9. 函数名: migration_entry_wait\n- 参数: [mm, pmd, address]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n10. 函数名: pte_none\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n11. 函数名: pte_to_swp_entry\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n12. 函数名: is_migration_entry\n- 参数: [entry]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n13. 函数名: pte_protnone\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n14. 函数名: vm_normal_page\n- 参数: [vma, address, pte]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n15. 函数名: can_follow_write_pte\n- 参数: [pte, page, vma, flags]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n16. 函数名: pte_devmap\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n17. 函数名: get_dev_pagemap\n- 参数: [pfn, pgmap]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n18. 函数名: pte_page\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n19. 函数名: is_zero_pfn\n- 参数: [pfn]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n20. 函数名: follow_pfn_pte\n- 参数: [vma, address, ptep, flags]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n21. 函数名: pte_write\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n22. 函数名: gup_must_unshare\n- 参数: [flags, page]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n23. 函数名: try_grab_page\n- 参数: [page, flags]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n24. 函数名: arch_make_page_accessible\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n25. 函数名: unpin_user_page\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n26. 函数名: pte_dirty\n- 参数: [pte]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n27. 函数名: set_page_dirty\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: []\n\n28. 函数名: mark_page_accessed\n- 参数: [page]\n- 调用者: follow_page_pte\n- 被调用者: []"
    },
    {
        "id": 3658,
        "cwe": "CWE-362",
        "cve": "CVE-2022-3623",
        "purpose": "Code purpose:\"\"\"该代码用于处理虚拟内存地址到物理页面的映射查找，包括处理大页、设备映射页和迁移条目等多种情况\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在follow_pmd_mask函数中存在对pmd值的竞争条件，未正确处理并发访问导致的竞态条件漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: follow_pmd_mask\n- 参数: [vma, address, pudp, flags, ctx]\n- 调用者: N/A\n- 被调用者: [pmd_offset, READ_ONCE, pmd_none, no_page_table, pmd_huge, is_vm_hugetlb_page, follow_huge_pmd, is_hugepd, pmd_val, follow_huge_pd, pmd_present, thp_migration_supported, is_pmd_migration_entry, pmd_migration_entry_wait, pmd_devmap, pmd_lock, follow_devmap_pmd, spin_unlock, pmd_trans_huge, follow_page_pte, pmd_protnone, pmd_page, is_huge_zero_page, split_huge_pmd, pmd_trans_unstable, pte_alloc, ERR_PTR, follow_trans_huge_pmd]\n\n2. 函数名: pmd_offset\n- 参数: [pudp, address]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n3. 函数名: READ_ONCE\n- 参数: [*pmd]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n4. 函数名: pmd_none\n- 参数: [pmdval]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n5. 函数名: no_page_table\n- 参数: [vma, flags]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n6. 函数名: pmd_huge\n- 参数: [pmdval]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n7. 函数名: is_vm_hugetlb_page\n- 参数: [vma]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n8. 函数名: follow_huge_pmd\n- 参数: [mm, address, pmd, flags]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n9. 函数名: is_hugepd\n- 参数: [__hugepd(pmd_val(pmdval))]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n10. 函数名: pmd_val\n- 参数: [pmdval]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n11. 函数名: follow_huge_pd\n- 参数: [vma, address, __hugepd(pmd_val(pmdval)), flags, PMD_SHIFT]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n12. 函数名: pmd_present\n- 参数: [pmdval]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n13. 函数名: thp_migration_supported\n- 参数: []\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n14. 函数名: is_pmd_migration_entry\n- 参数: [pmdval]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n15. 函数名: pmd_migration_entry_wait\n- 参数: [mm, pmd]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n16. 函数名: pmd_devmap\n- 参数: [pmdval]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n17. 函数名: pmd_lock\n- 参数: [mm, pmd]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n18. 函数名: follow_devmap_pmd\n- 参数: [vma, address, pmd, flags, &ctx->pgmap]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n19. 函数名: spin_unlock\n- 参数: [ptl]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n20. 函数名: pmd_trans_huge\n- 参数: [pmdval]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n21. 函数名: follow_page_pte\n- 参数: [vma, address, pmd, flags, &ctx->pgmap]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n22. 函数名: pmd_protnone\n- 参数: [pmdval]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n23. 函数名: pmd_page\n- 参数: [*pmd]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n24. 函数名: is_huge_zero_page\n- 参数: [page]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n25. 函数名: split_huge_pmd\n- 参数: [vma, pmd, address]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n26. 函数名: pmd_trans_unstable\n- 参数: [pmd]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n27. 函数名: pte_alloc\n- 参数: [mm, pmd]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n28. 函数名: ERR_PTR\n- 参数: [ret]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A\n\n29. 函数名: follow_trans_huge_pmd\n- 参数: [vma, address, pmd, flags]\n- 调用者: follow_pmd_mask\n- 被调用者: N/A"
    },
    {
        "id": 3668,
        "cwe": "CWE-362",
        "cve": "CVE-2022-3635",
        "purpose": "Code purpose:\"\"\"该代码片段实现了Linux内核中IDT77252驱动模块的退出清理功能，包括注销PCI驱动、释放设备资源等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放card结构体后，可能仍存在对dev->phy->stop的调用，导致释放后使用(use-after-free)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: __exit idt77252_exit\n- 参数: [void]\n- 调用者: 无（模块退出函数）\n- 被调用者: [pci_unregister_driver, dev->phy->stop, deinit_card, pci_disable_device, kfree, DIPRINTK]\n\n2. 函数名: pci_unregister_driver\n- 参数: [&idt77252_driver]\n- 调用者: idt77252_exit\n- 被调用者: 无\n\n3. 函数名: dev->phy->stop\n- 参数: [dev]\n- 调用者: idt77252_exit\n- 被调用者: 无\n\n4. 函数名: deinit_card\n- 参数: [card]\n- 调用者: idt77252_exit\n- 被调用者: 无\n\n5. 函数名: pci_disable_device\n- 参数: [card->pcidev]\n- 调用者: idt77252_exit\n- 被调用者: 无\n\n6. 函数名: kfree\n- 参数: [card]\n- 调用者: idt77252_exit\n- 被调用者: 无\n\n7. 函数名: DIPRINTK\n- 参数: [\"idt77252: finished cleanup-module().\\n\"]\n- 调用者: idt77252_exit\n- 被调用者: 无"
    },
    {
        "id": 3692,
        "cwe": "CWE-362",
        "cve": "CVE-2022-39188",
        "purpose": "Code purpose:\"\"\"在VMA边界处执行TLB刷新并重置范围，以避免范围随连续VMA之间未使用空间增长，同时确保tlb_start_vma()中的mmu_gather::vma_*标志正常工作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在VM_PFNMAP VMAs情况下存在竞态条件(unmap_mapping_range与munmap之间)，导致设备驱动程序可能在仍存在陈旧TLB条目时释放页面。\"\"\"",
        "functions": "Functions:\n1. 函数名: tlb_end_vma\n- 参数: [tlb, vma]\n- 调用者: 未明确显示（通常由内存管理相关代码调用）\n- 被调用者: [tlb_flush_mmu_tlbonly]\n\n2. 函数名: tlb_flush_mmu_tlbonly\n- 参数: [tlb]\n- 调用者: [tlb_end_vma]\n- 被调用者: 未明确显示"
    },
    {
        "id": 3693,
        "cwe": "CWE-362",
        "cve": "CVE-2022-39188",
        "purpose": "Code purpose:\"\"\"该代码片段旨在更新TLB（转译后备缓冲器）中虚拟内存区域（VMA）的标志位，但当前为空实现未实际执行任何操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在VM_PFNMAP VMAs情况下存在竞态条件(unmap_mapping_range与munmap之间)，导致设备驱动程序可能在仍存在陈旧TLB条目时释放页面。\"\"\"",
        "functions": "Functions:\n1. 函数名: tlb_update_vma_flags\n- 参数: [tlb, vma]\n- 调用者: 未提供（代码片段中未显示调用者信息）\n- 被调用者: []"
    },
    {
        "id": 3703,
        "cwe": "CWE-362",
        "cve": "CVE-2022-40307",
        "purpose": "Code purpose:\"\"\"释放EFI固件胶囊加载器相关的内存资源并清理文件私有数据\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放cap_info资源时存在竞态条件，导致可能发生释放后使用(UAF)的问题\"\"\"",
        "functions": "Functions:\n1. 函数名: efi_capsule_release\n- 参数: [struct inode *inode, struct file *file]\n- 调用者: 未明确（通常由文件操作结构中的release函数指针调用）\n- 被调用者: [kfree]\n\n2. 函数名: kfree\n- 参数: [void *ptr]\n- 调用者: [efi_capsule_release]\n- 被调用者: []"
    },
    {
        "id": 3720,
        "cwe": "CWE-362",
        "cve": "CVE-2022-41849",
        "purpose": "Code purpose:\"\"\"处理USB设备断开连接时的资源释放和状态清理工作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在USB设备断开连接时，由于缺乏适当的同步机制，导致在ufx_ops_open和ufx_usb_disconnect之间存在竞争条件，可能引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ufx_usb_disconnect\n- 参数: [struct usb_interface *interface]\n- 调用者: 无（由USB子系统调用）\n- 被调用者: [usb_get_intfdata, pr_debug, atomic_set, usb_set_intfdata, schedule_delayed_work, kref_put]\n\n2. 函数名: usb_get_intfdata\n- 参数: [struct usb_interface *interface]\n- 调用者: ufx_usb_disconnect\n- 被调用者: 无\n\n3. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: ufx_usb_disconnect\n- 被调用者: 无\n\n4. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: ufx_usb_disconnect\n- 被调用者: 无\n\n5. 函数名: usb_set_intfdata\n- 参数: [struct usb_interface *interface, void *data]\n- 调用者: ufx_usb_disconnect\n- 被调用者: 无\n\n6. 函数名: schedule_delayed_work\n- 参数: [struct delayed_work *work, unsigned long delay]\n- 调用者: ufx_usb_disconnect\n- 被调用者: 无\n\n7. 函数名: kref_put\n- 参数: [struct kref *kref, void (*release)(struct kref *kref)]\n- 调用者: ufx_usb_disconnect\n- 被调用者: [ufx_free]\n\n8. 函数名: ufx_free\n- 参数: [struct kref *kref]\n- 调用者: kref_put\n- 被调用者: 无"
    },
    {
        "id": 3721,
        "cwe": "CWE-362",
        "cve": "CVE-2022-41849",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中USB帧缓冲设备(ufx)的打开操作，包括设备状态检查、引用计数管理以及延迟IO初始化等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ufx_ops_open函数中，当USB设备被物理移除时，dev指针可能变为悬垂指针，导致在访问dev->virtualized和dev->fb_count时出现竞争条件和使用后释放漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ufx_ops_open\n- 参数: [struct fb_info *info, int user]\n- 调用者: 未明确显示（通常由framebuffer子系统调用）\n- 被调用者: [kref_get, kzalloc, fb_deferred_io_init, pr_debug]\n\n2. 函数名: kref_get\n- 参数: [&dev->kref]\n- 调用者: ufx_ops_open\n- 被调用者: []\n\n3. 函数名: kzalloc\n- 参数: [sizeof(*fbdefio), GFP_KERNEL]\n- 调用者: ufx_ops_open\n- 被调用者: []\n\n4. 函数名: fb_deferred_io_init\n- 参数: [info]\n- 调用者: ufx_ops_open\n- 被调用者: []\n\n5. 函数名: pr_debug\n- 参数: [\"open /dev/fb%d user=%d fb_info=%p count=%d\", info->node, user, info, dev->fb_count]\n- 调用者: ufx_ops_open\n- 被调用者: []\n\n6. 函数名: ufx_dpy_deferred_io\n- 参数: 未直接显示（通过fbdefio->deferred_io指针引用）\n- 调用者: 未直接调用（由fb_deferred_io机制后续调用）\n- 被调用者: []"
    },
    {
        "id": 3722,
        "cwe": "CWE-362",
        "cve": "CVE-2022-41850",
        "purpose": "Code purpose:\"\"\"该代码用于处理ROCCAT设备的事件报告，包括分配内存存储报告数据、管理循环缓冲区以及通知等待的读取进程。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在复制report->value时接收到新报告导致竞态条件，引发释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: roccat_report_event\n- 参数: [minor, data]\n- 调用者: 未指定（由外部调用）\n- 被调用者: [kmemdup, kfree, wake_up_interruptible]\n\n2. 函数名: kmemdup\n- 参数: [data, device->report_size, GFP_ATOMIC]\n- 调用者: roccat_report_event\n- 被调用者: []\n\n3. 函数名: kfree\n- 参数: [report->value]\n- 调用者: roccat_report_event\n- 被调用者: []\n\n4. 函数名: wake_up_interruptible\n- 参数: [&device->wait]\n- 调用者: roccat_report_event\n- 被调用者: []"
    },
    {
        "id": 3750,
        "cwe": "CWE-362",
        "cve": "CVE-2022-45869",
        "purpose": "Code purpose:\"\"\"该代码用于在KVM虚拟化环境中准备并执行影子页面的回收操作，处理无效页面并维护MMU页表结构的一致性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在启用嵌套虚拟化和TDP MMU时，x86 KVM子系统中存在竞争条件，导致在准备回收页面时可能引发主机操作系统崩溃或内存损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: __kvm_mmu_prepare_zap_page\n- 参数: [kvm, sp, invalid_list, nr_zapped]\n- 调用者: 未明确显示（通常是KVM内部MMU相关函数）\n- 被调用者: [mmu_zap_unsync_children, kvm_mmu_page_unlink_children, kvm_mmu_unlink_parents, unaccount_shadowed, kvm_unlink_unsync_page, kvm_unaccount_mmu_page, is_obsolete_sp, unaccount_huge_nx_page, kvm_make_all_cpus_request]\n\n2. 函数名: mmu_zap_unsync_children\n- 参数: [kvm, sp, invalid_list]\n- 调用者: __kvm_mmu_prepare_zap_page\n- 被调用者: []\n\n3. 函数名: kvm_mmu_page_unlink_children\n- 参数: [kvm, sp, invalid_list]\n- 调用者: __kvm_mmu_prepare_zap_page\n- 被调用者: []\n\n4. 函数名: kvm_mmu_unlink_parents\n- 参数: [sp]\n- 调用者: __kvm_mmu_prepare_zap_page\n- 被调用者: []\n\n5. 函数名: unaccount_shadowed\n- 参数: [kvm, sp]\n- 调用者: __kvm_mmu_prepare_zap_page\n- 被调用者: []\n\n6. 函数名: kvm_unlink_unsync_page\n- 参数: [kvm, sp]\n- 调用者: __kvm_mmu_prepare_zap_page\n- 被调用者: []\n\n7. 函数名: kvm_unaccount_mmu_page\n- 参数: [kvm, sp]\n- 调用者: __kvm_mmu_prepare_zap_page\n- 被调用者: []\n\n8. 函数名: is_obsolete_sp\n- 参数: [kvm, sp]\n- 调用者: __kvm_mmu_prepare_zap_page\n- 被调用者: []\n\n9. 函数名: unaccount_huge_nx_page\n- 参数: [kvm, sp]\n- 调用者: __kvm_mmu_prepare_zap_page\n- 被调用者: []\n\n10. 函数名: kvm_make_all_cpus_request\n- 参数: [kvm, KVM_REQ_MMU_FREE_OBSOLETE_ROOTS]\n- 调用者: __kvm_mmu_prepare_zap_page\n- 被调用者: []"
    },
    {
        "id": 3751,
        "cwe": "CWE-362",
        "cve": "CVE-2022-45869",
        "purpose": "Code purpose:\"\"\"处理x86 KVM子系统中客户机操作系统的页错误，包括页跟踪、快速页错误处理、内存缓存填充和MMU页映射等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在启用嵌套虚拟化和TDP MMU时，x86 KVM子系统中存在竞态条件，导致锁机制处理不当，可能引发主机操作系统崩溃或内存损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: direct_page_fault\n- 参数: [struct kvm_vcpu *vcpu, struct kvm_page_fault *fault]\n- 调用者: N/A\n- 被调用者: [is_tdp_mmu, kvm_vcpu_gfn_to_memslot, page_fault_handle_page_track, fast_page_fault, mmu_topup_memory_caches, kvm_faultin_pfn, handle_abnormal_pfn, is_page_fault_stale, make_mmu_pages_available, kvm_tdp_mmu_map, __direct_map, kvm_release_pfn_clean]\n\n2. 函数名: is_tdp_mmu\n- 参数: [struct kvm_vcpu->arch.mmu]\n- 调用者: direct_page_fault\n- 被调用者: N/A\n\n3. 函数名: kvm_vcpu_gfn_to_memslot\n- 参数: [struct kvm_vcpu *vcpu, fault->gfn]\n- 调用者: direct_page_fault\n- 被调用者: N/A\n\n4. 函数名: page_fault_handle_page_track\n- 参数: [struct kvm_vcpu *vcpu, struct kvm_page_fault *fault]\n- 调用者: direct_page_fault\n- 被调用者: N/A\n\n5. 函数名: fast_page_fault\n- 参数: [struct kvm_vcpu *vcpu, struct kvm_page_fault *fault]\n- 调用者: direct_page_fault\n- 被调用者: N/A\n\n6. 函数名: mmu_topup_memory_caches\n- 参数: [struct kvm_vcpu *vcpu, false]\n- 调用者: direct_page_fault\n- 被调用者: N/A\n\n7. 函数名: kvm_faultin_pfn\n- 参数: [struct kvm_vcpu *vcpu, struct kvm_page_fault *fault]\n- 调用者: direct_page_fault\n- 被调用者: N/A\n\n8. 函数名: handle_abnormal_pfn\n- 参数: [struct kvm_vcpu *vcpu, struct kvm_page_fault *fault, ACC_ALL]\n- 调用者: direct_page_fault\n- 被调用者: N/A\n\n9. 函数名: is_page_fault_stale\n- 参数: [struct kvm_vcpu *vcpu, struct kvm_page_fault *fault, mmu_seq]\n- 调用者: direct_page_fault\n- 被调用者: N/A\n\n10. 函数名: make_mmu_pages_available\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: direct_page_fault\n- 被调用者: N/A\n\n11. 函数名: kvm_tdp_mmu_map\n- 参数: [struct kvm_vcpu *vcpu, struct kvm_page_fault *fault]\n- 调用者: direct_page_fault\n- 被调用者: N/A\n\n12. 函数名: __direct_map\n- 参数: [struct kvm_vcpu *vcpu, struct kvm_page_fault *fault]\n- 调用者: direct_page_fault\n- 被调用者: N/A\n\n13. 函数名: kvm_release_pfn_clean\n- 参数: [fault->pfn]\n- 调用者: direct_page_fault\n- 被调用者: N/A"
    },
    {
        "id": 3752,
        "cwe": "CWE-362",
        "cve": "CVE-2022-45887",
        "purpose": "Code purpose:\"\"\"释放ttusb_dec结构体中的DVB相关资源并注销前端设备\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺少对dvb_frontend_detach的调用，导致在释放资源时未能正确清理前端设备的内存，造成内存泄漏\"\"\"",
        "functions": "Functions:\n1. 函数名: ttusb_dec_exit_dvb\n- 参数: [struct ttusb_dec *dec]\n- 调用者: 未显示\n- 被调用者: [dprintk, dvb_net_release, dec->demux.dmx.close, dec->demux.dmx.remove_frontend, dvb_dmxdev_release, dvb_dmx_release, dvb_unregister_frontend, dec->fe->ops.release, dvb_unregister_adapter]\n\n2. 函数名: dprintk\n- 参数: [\"%s\\n\", __func__]\n- 调用者: ttusb_dec_exit_dvb\n- 被调用者: []\n\n3. 函数名: dvb_net_release\n- 参数: [&dec->dvb_net]\n- 调用者: ttusb_dec_exit_dvb\n- 被调用者: []\n\n4. 函数名: dec->demux.dmx.close\n- 参数: [&dec->demux.dmx]\n- 调用者: ttusb_dec_exit_dvb\n- 被调用者: []\n\n5. 函数名: dec->demux.dmx.remove_frontend\n- 参数: [&dec->demux.dmx, &dec->frontend]\n- 调用者: ttusb_dec_exit_dvb\n- 被调用者: []\n\n6. 函数名: dvb_dmxdev_release\n- 参数: [&dec->dmxdev]\n- 调用者: ttusb_dec_exit_dvb\n- 被调用者: []\n\n7. 函数名: dvb_dmx_release\n- 参数: [&dec->demux]\n- 调用者: ttusb_dec_exit_dvb\n- 被调用者: []\n\n8. 函数名: dvb_unregister_frontend\n- 参数: [dec->fe]\n- 调用者: ttusb_dec_exit_dvb\n- 被调用者: []\n\n9. 函数名: dec->fe->ops.release\n- 参数: [dec->fe]\n- 调用者: ttusb_dec_exit_dvb\n- 被调用者: []\n\n10. 函数名: dvb_unregister_adapter\n- 参数: [&dec->adapter]\n- 调用者: ttusb_dec_exit_dvb\n- 被调用者: []"
    },
    {
        "id": 3753,
        "cwe": "CWE-362",
        "cve": "CVE-2022-45888",
        "purpose": "Code purpose:\"\"\"该代码实现了xillyusb设备的打开功能，包括设备通道的初始化、读写权限检查、端点分配和数据缓冲区设置等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在USB设备物理移除时，xillyusb_open函数中存在竞态条件导致对已释放资源的后续访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: xillyusb_open\n- 参数: [struct inode *inode, struct file *filp]\n- 调用者: 内核文件操作调用\n- 被调用者: [xillybus_find_inode, mutex_lock, dev_err, kref_get, endpoint_alloc, fifo_init, flush_downstream, report_io_error, kzalloc, kfree, xillyusb_send_opcode, request_read_anything, safely_assign_in_fifo, fifo_mem_release, endpoint_dealloc, kref_put, mutex_unlock]\n\n2. 函数名: xillybus_find_inode\n- 参数: [struct inode *inode, void **xdev, int *index]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n3. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n4. 函数名: dev_err\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n5. 函数名: kref_get\n- 参数: [struct kref *kref]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n6. 函数名: endpoint_alloc\n- 参数: [struct xillyusb_dev *xdev, int endpoint_num, work_func_t work_func, int buf_order, int bufs_num]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n7. 函数名: fifo_init\n- 参数: [struct xillyfifo *fifo, int log2_size]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n8. 函数名: flush_downstream\n- 参数: [struct xillyusb_channel *chan, int timeout, bool force]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n9. 函数名: report_io_error\n- 参数: [struct xillyusb_dev *xdev, int rc]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n10. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n11. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n12. 函数名: xillyusb_send_opcode\n- 参数: [struct xillyusb_dev *xdev, int endpoint_num, int opcode, u32 data]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n13. 函数名: request_read_anything\n- 参数: [struct xillyusb_channel *chan, int opcode]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n14. 函数名: safely_assign_in_fifo\n- 参数: [struct xillyusb_channel *chan, struct xillyfifo *in_fifo]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n15. 函数名: fifo_mem_release\n- 参数: [struct xillyfifo *fifo]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n16. 函数名: endpoint_dealloc\n- 参数: [struct xillyusb_endpoint *ep]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n17. 函数名: kref_put\n- 参数: [struct kref *kref, void (*release)(struct kref *kref)]\n- 调用者: xillyusb_open\n- 被调用者: [cleanup_dev]\n\n18. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: xillyusb_open\n- 被调用者: []\n\n19. 函数名: cleanup_dev\n- 参数: [struct kref *kref]\n- 调用者: kref_put\n- 被调用者: []"
    },
    {
        "id": 3754,
        "cwe": "CWE-362",
        "cve": "CVE-2022-45888",
        "purpose": "Code purpose:\"\"\"在USB设备物理移除时，清理相关资源并处理竞争条件，但存在潜在的竞态条件和释放后使用漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在USB设备物理移除时，xillyusb_disconnect函数存在竞态条件，导致在清理资源过程中可能发生use-after-free问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: xillyusb_disconnect\n- 参数: [struct usb_interface *interface]\n- 调用者: 无（由USB子系统调用）\n- 被调用者: [usb_get_intfdata, xillybus_cleanup_chrdev, xillyusb_send_opcode, wait_event_interruptible_timeout, dev_err, report_io_error, mutex_lock, endpoint_quiesce, mutex_unlock, usb_set_intfdata, kref_put]\n\n2. 函数名: usb_get_intfdata\n- 参数: [struct usb_interface *interface]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n3. 函数名: xillybus_cleanup_chrdev\n- 参数: [struct xillyusb_dev *xdev, struct device *dev]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n4. 函数名: xillyusb_send_opcode\n- 参数: [struct xillyusb_dev *xdev, ~0, OPCODE_QUIESCE, 0]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n5. 函数名: wait_event_interruptible_timeout\n- 参数: [fifo->waitq, msg_ep->drained || xdev->error, XILLY_RESPONSE_TIMEOUT]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n6. 函数名: dev_err\n- 参数: [&interface->dev, \"Weird timeout condition on sending quiesce request.\\n\"]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n7. 函数名: report_io_error\n- 参数: [xdev, -ENODEV]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n8. 函数名: mutex_lock\n- 参数: [&chan->lock]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n9. 函数名: endpoint_quiesce\n- 参数: [chan->out_ep]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n10. 函数名: mutex_unlock\n- 参数: [&chan->lock]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n11. 函数名: usb_set_intfdata\n- 参数: [interface, NULL]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n12. 函数名: kref_put\n- 参数: [&xdev->kref, cleanup_dev]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无"
    },
    {
        "id": 3869,
        "cwe": "CWE-362",
        "cve": "CVE-2023-1582",
        "purpose": "Code purpose:\"\"\"该代码用于处理进程内存映射的页表遍历和状态信息收集，实现/proc文件系统中内存管理信息的读取功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在透明大页(THP)处理过程中存在竞态条件，导致本地攻击者可能通过竞争条件引发拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: pagemap_pmd_range\n- 参数: [pmdp, addr, end, walk]\n- 调用者: N/A (top-level function)\n- 被调用者: [pmd_trans_huge_lock, pmd_present, pmd_page, pmd_soft_dirty, pmd_uffd_wp, pmd_pfn, is_swap_pmd, pmd_to_swp_entry, pmd_swp_soft_dirty, pmd_swp_uffd_wp, is_pmd_migration_entry, pfn_swap_entry_to_page, page_mapcount, add_to_pagemap, spin_unlock, pmd_trans_unstable, pte_offset_map_lock, pte_to_pagemap_entry, pte_unmap_unlock, cond_resched]\n\n2. 函数名: pmd_trans_huge_lock\n- 参数: [pmdp, vma]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n3. 函数名: pmd_present\n- 参数: [pmd]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n4. 函数名: pmd_page\n- 参数: [pmd]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n5. 函数名: pmd_soft_dirty\n- 参数: [pmd]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n6. 函数名: pmd_uffd_wp\n- 参数: [pmd]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n7. 函数名: pmd_pfn\n- 参数: [pmd]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n8. 函数名: is_swap_pmd\n- 参数: [pmd]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n9. 函数名: pmd_to_swp_entry\n- 参数: [pmd]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n10. 函数名: pmd_swp_soft_dirty\n- 参数: [pmd]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n11. 函数名: pmd_swp_uffd_wp\n- 参数: [pmd]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n12. 函数名: is_pmd_migration_entry\n- 参数: [pmd]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n13. 函数名: pfn_swap_entry_to_page\n- 参数: [entry]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n14. 函数名: page_mapcount\n- 参数: [page]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n15. 函数名: add_to_pagemap\n- 参数: [addr, pme, pm]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n16. 函数名: spin_unlock\n- 参数: [ptl]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n17. 函数名: pmd_trans_unstable\n- 参数: [pmdp]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n18. 函数名: pte_offset_map_lock\n- 参数: [mm, pmdp, addr, ptl]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n19. 函数名: pte_to_pagemap_entry\n- 参数: [pm, vma, addr, pte]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n20. 函数名: pte_unmap_unlock\n- 参数: [orig_pte, ptl]\n- 调用者: pagemap_pmd_range\n- 被调用者: []\n\n21. 函数名: cond_resched\n- 参数: []\n- 调用者: pagemap_pmd_range\n- 被调用者: []"
    },
    {
        "id": 3870,
        "cwe": "CWE-362",
        "cve": "CVE-2023-1582",
        "purpose": "Code purpose:\"\"\"该代码用于统计进程内存映射中页面的使用情况，包括常驻内存、交换空间等信息，并处理可能存在的竞争条件问题。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在内存映射统计过程中缺乏适当的同步机制，导致在多线程环境下可能出现竞争条件，从而引发拒绝服务漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: smaps_pte_entry\n- 参数: [pte_t *pte, unsigned long addr, struct mm_walk *walk]\n- 调用者: 未显示（由内存管理子系统调用）\n- 被调用者: [pte_present, vm_normal_page, is_swap_pte, pte_to_swp_entry, non_swap_entry, swp_swapcount, is_pfn_swap_entry, pfn_swap_entry_to_page, smaps_pte_hole_lookup, smaps_account]\n\n2. 函数名: pte_present\n- 参数: [pte_t *pte]\n- 调用者: smaps_pte_entry\n- 被调用者: []\n\n3. 函数名: vm_normal_page\n- 参数: [struct vm_area_struct *vma, unsigned long addr, pte_t pte]\n- 调用者: smaps_pte_entry\n- 被调用者: []\n\n4. 函数名: is_swap_pte\n- 参数: [pte_t *pte]\n- 调用者: smaps_pte_entry\n- 被调用者: []\n\n5. 函数名: pte_to_swp_entry\n- 参数: [pte_t *pte]\n- 调用者: smaps_pte_entry\n- 被调用者: []\n\n6. 函数名: non_swap_entry\n- 参数: [swp_entry_t swpent]\n- 调用者: smaps_pte_entry\n- 被调用者: []\n\n7. 函数名: swp_swapcount\n- 参数: [swp_entry_t swpent]\n- 调用者: smaps_pte_entry\n- 被调用者: []\n\n8. 函数名: is_pfn_swap_entry\n- 参数: [swp_entry_t swpent]\n- 调用者: smaps_pte_entry\n- 被调用者: []\n\n9. 函数名: pfn_swap_entry_to_page\n- 参数: [swp_entry_t swpent]\n- 调用者: smaps_pte_entry\n- 被调用者: []\n\n10. 函数名: smaps_pte_hole_lookup\n- 参数: [unsigned long addr, struct mm_walk *walk]\n- 调用者: smaps_pte_entry\n- 被调用者: []\n\n11. 函数名: smaps_account\n- 参数: [struct mem_size_stats *mss, struct page *page, bool false, pte_young(*pte), pte_dirty(*pte), bool locked]\n- 调用者: smaps_pte_entry\n- 被调用者: []\n\n12. 函数名: pte_young\n- 参数: [pte_t *pte]\n- 调用者: smaps_account\n- 被调用者: []\n\n13. 函数名: pte_dirty\n- 参数: [pte_t *pte]\n- 调用者: smaps_account\n- 被调用者: []"
    },
    {
        "id": 3871,
        "cwe": "CWE-362",
        "cve": "CVE-2023-1582",
        "purpose": "Code purpose:\"\"\"将页表项(pte)转换为可分页内存映射条目(pagemap_entry_t)，包括提取页框号(frame)和标志位(flags)信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在访问页表项(pte)和页面(page)时缺乏适当的同步机制，导致在多线程环境下可能出现竞争条件，从而引发拒绝服务漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: pte_to_pagemap_entry\n- 参数: [pm, vma, addr, pte]\n- 调用者: N/A\n- 被调用者: [pte_present, pte_pfn, vm_normal_page, pte_soft_dirty, pte_uffd_wp, is_swap_pte, pte_swp_soft_dirty, pte_swp_uffd_wp, pte_to_swp_entry, swp_type, swp_offset, is_pfn_swap_entry, pfn_swap_entry_to_page, PageAnon, page_mapcount, make_pme]\n\n2. 函数名: pte_present\n- 参数: [pte]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n3. 函数名: pte_pfn\n- 参数: [pte]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n4. 函数名: vm_normal_page\n- 参数: [vma, addr, pte]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n5. 函数名: pte_soft_dirty\n- 参数: [pte]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n6. 函数名: pte_uffd_wp\n- 参数: [pte]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n7. 函数名: is_swap_pte\n- 参数: [pte]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n8. 函数名: pte_swp_soft_dirty\n- 参数: [pte]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n9. 函数名: pte_swp_uffd_wp\n- 参数: [pte]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n10. 函数名: pte_to_swp_entry\n- 参数: [pte]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n11. 函数名: swp_type\n- 参数: [entry]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n12. 函数名: swp_offset\n- 参数: [entry]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n13. 函数名: is_pfn_swap_entry\n- 参数: [entry]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n14. 函数名: pfn_swap_entry_to_page\n- 参数: [entry]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n15. 函数名: PageAnon\n- 参数: [page]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n16. 函数名: page_mapcount\n- 参数: [page]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A\n\n17. 函数名: make_pme\n- 参数: [frame, flags]\n- 调用者: pte_to_pagemap_entry\n- 被调用者: N/A"
    },
    {
        "id": 3894,
        "cwe": "CWE-362",
        "cve": "CVE-2023-2006",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中RxRPC网络协议的连接调用功能，处理客户端连接请求并管理连接资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在RxRPC网络协议处理bundle时，由于对对象操作缺乏适当的锁保护，导致竞态条件漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: rxrpc_connect_call\n- 参数: [struct rxrpc_sock *rx, struct rxrpc_call *call, struct rxrpc_conn_parameters *cp, struct sockaddr_rxrpc *srx, gfp_t gfp]\n- 调用者: N/A\n- 被调用者: [rxrpc_discard_expired_client_conns, rxrpc_prep_call, rxrpc_wait_for_channel, rxrpc_put_bundle, trace_rxrpc_client, rxrpc_set_call_completion, rxrpc_disconnect_client_call]\n\n2. 函数名: rxrpc_discard_expired_client_conns\n- 参数: [&rxnet->client_conn_reaper]\n- 调用者: rxrpc_connect_call\n- 被调用者: N/A\n\n3. 函数名: rxrpc_prep_call\n- 参数: [rx, call, cp, srx, gfp]\n- 调用者: rxrpc_connect_call\n- 被调用者: N/A\n\n4. 函数名: rxrpc_wait_for_channel\n- 参数: [bundle, call, gfp]\n- 调用者: rxrpc_connect_call\n- 被调用者: N/A\n\n5. 函数名: rxrpc_put_bundle\n- 参数: [bundle]\n- 调用者: rxrpc_connect_call\n- 被调用者: N/A\n\n6. 函数名: trace_rxrpc_client\n- 参数: [call->conn, ret, rxrpc_client_chan_wait_failed]\n- 调用者: rxrpc_connect_call\n- 被调用者: N/A\n\n7. 函数名: rxrpc_set_call_completion\n- 参数: [call, RXRPC_CALL_LOCAL_ERROR, 0, ret]\n- 调用者: rxrpc_connect_call\n- 被调用者: N/A\n\n8. 函数名: rxrpc_disconnect_client_call\n- 参数: [bundle, call]\n- 调用者: rxrpc_connect_call\n- 被调用者: N/A"
    },
    {
        "id": 3895,
        "cwe": "CWE-362",
        "cve": "CVE-2023-2006",
        "purpose": "Code purpose:\"\"\"分配并初始化一个RxRPC网络协议使用的bundle结构体，包含参数复制、引用计数设置和锁初始化等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在RxRPC网络协议处理bundle时，由于对对象操作缺乏适当的锁保护，导致竞态条件漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: rxrpc_alloc_bundle\n- 参数: [struct rxrpc_conn_parameters *cp, gfp_t gfp]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [kzalloc, rxrpc_get_peer, refcount_set, spin_lock_init, INIT_LIST_HEAD]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*bundle), gfp]\n- 调用者: rxrpc_alloc_bundle\n- 被调用者: []\n\n3. 函数名: rxrpc_get_peer\n- 参数: [bundle->params.peer]\n- 调用者: rxrpc_alloc_bundle\n- 被调用者: []\n\n4. 函数名: refcount_set\n- 参数: [&bundle->ref, 1]\n- 调用者: rxrpc_alloc_bundle\n- 被调用者: []\n\n5. 函数名: spin_lock_init\n- 参数: [&bundle->channel_lock]\n- 调用者: rxrpc_alloc_bundle\n- 被调用者: []\n\n6. 函数名: INIT_LIST_HEAD\n- 参数: [&bundle->waiting_calls]\n- 调用者: rxrpc_alloc_bundle\n- 被调用者: []"
    },
    {
        "id": 3896,
        "cwe": "CWE-362",
        "cve": "CVE-2023-2006",
        "purpose": "Code purpose:\"\"\"该代码用于处理RxRPC网络协议中的连接解绑操作，管理连接与bundle之间的关系，并在无活跃连接时移除bundle\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在RxRPC网络协议处理bundle时，由于对对象操作缺乏适当的锁保护，导致存在竞态条件漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: rxrpc_unbundle_conn\n- 参数: [struct rxrpc_connection *conn]\n- 调用者: N/A\n- 被调用者: [rxrpc_process_delayed_final_acks, clear_bit, rb_erase, rxrpc_put_bundle, rxrpc_put_connection]\n\n2. 函数名: rxrpc_process_delayed_final_acks\n- 参数: [struct rxrpc_connection *conn, bool]\n- 调用者: rxrpc_unbundle_conn\n- 被调用者: N/A\n\n3. 函数名: clear_bit\n- 参数: [unsigned int, unsigned long *]\n- 调用者: rxrpc_unbundle_conn\n- 被调用者: N/A\n\n4. 函数名: rb_erase\n- 参数: [struct rb_node *, struct rb_root *]\n- 调用者: rxrpc_unbundle_conn\n- 被调用者: N/A\n\n5. 函数名: rxrpc_put_bundle\n- 参数: [struct rxrpc_bundle *]\n- 调用者: rxrpc_unbundle_conn\n- 被调用者: N/A\n\n6. 函数名: rxrpc_put_connection\n- 参数: [struct rxrpc_connection *]\n- 调用者: rxrpc_unbundle_conn\n- 被调用者: N/A"
    },
    {
        "id": 3897,
        "cwe": "CWE-362",
        "cve": "CVE-2023-2006",
        "purpose": "Code purpose:\"\"\"在RxRPC网络协议中查找或创建客户端连接包(bundle)，处理并发访问时存在竞态条件漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在RxRPC网络协议处理bundle时，由于对对象操作缺乏适当的锁保护，导致竞态条件漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: rxrpc_look_up_bundle\n- 参数: [struct rxrpc_conn_parameters *cp, gfp_t gfp]\n- 调用者: N/A (顶级函数)\n- 被调用者: [rxrpc_alloc_bundle, rb_entry, rxrpc_free_bundle, rxrpc_get_bundle, rb_link_node, rb_insert_color]\n\n2. 函数名: rxrpc_alloc_bundle\n- 参数: [struct rxrpc_conn_parameters *cp, gfp_t gfp]\n- 调用者: rxrpc_look_up_bundle\n- 被调用者: N/A\n\n3. 函数名: rb_entry\n- 参数: [struct rb_node *node, struct rxrpc_bundle, local_node]\n- 调用者: rxrpc_look_up_bundle\n- 被调用者: N/A\n\n4. 函数名: rxrpc_free_bundle\n- 参数: [struct rxrpc_bundle *candidate]\n- 调用者: rxrpc_look_up_bundle\n- 被调用者: N/A\n\n5. 函数名: rxrpc_get_bundle\n- 参数: [struct rxrpc_bundle *bundle]\n- 调用者: rxrpc_look_up_bundle\n- 被调用者: N/A\n\n6. 函数名: rb_link_node\n- 参数: [struct rb_node *node, struct rb_node *parent, struct rb_node **rb_link]\n- 调用者: rxrpc_look_up_bundle\n- 被调用者: N/A\n\n7. 函数名: rb_insert_color\n- 参数: [struct rb_node *node, struct rb_root *root]\n- 调用者: rxrpc_look_up_bundle\n- 被调用者: N/A"
    },
    {
        "id": 3898,
        "cwe": "CWE-362",
        "cve": "CVE-2023-2006",
        "purpose": "Code purpose:\"\"\"该代码用于在RxRPC网络协议中管理连接包(bundle)中的连接，处理连接的分配、重用和替换，但存在竞态条件漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在RxRPC网络协议处理bundle时，由于对对象操作缺乏适当的锁保护，导致存在竞态条件漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: rxrpc_add_conn_to_bundle\n- 参数: [bundle, gfp]\n- 调用者: 未显示\n- 被调用者: [rxrpc_alloc_client_connection, rxrpc_may_reuse_conn, trace_rxrpc_client, rxrpc_put_connection]\n\n2. 函数名: rxrpc_alloc_client_connection\n- 参数: [bundle, gfp]\n- 调用者: rxrpc_add_conn_to_bundle\n- 被调用者: 未显示\n\n3. 函数名: rxrpc_may_reuse_conn\n- 参数: [old]\n- 调用者: rxrpc_add_conn_to_bundle\n- 被调用者: 未显示\n\n4. 函数名: trace_rxrpc_client\n- 参数: [old, -1, rxrpc_client_replace] 或 [candidate, -1, rxrpc_client_duplicate]\n- 调用者: rxrpc_add_conn_to_bundle\n- 被调用者: 未显示\n\n5. 函数名: rxrpc_put_connection\n- 参数: [candidate] 或 [old]\n- 调用者: rxrpc_add_conn_to_bundle\n- 被调用者: 未显示\n\n6. 函数名: spin_unlock\n- 参数: [&bundle->channel_lock]\n- 调用者: rxrpc_add_conn_to_bundle\n- 被调用者: 未显示\n\n7. 函数名: spin_lock\n- 参数: [&bundle->channel_lock]\n- 调用者: rxrpc_add_conn_to_bundle\n- 被调用者: 未显示\n\n8. 函数名: set_bit\n- 参数: [shift + j, &bundle->avail_chans]\n- 调用者: rxrpc_add_conn_to_bundle\n- 被调用者: 未显示"
    },
    {
        "id": 3899,
        "cwe": "CWE-362",
        "cve": "CVE-2023-2006",
        "purpose": "Code purpose:\"\"\"该代码用于减少RxRPC bundle对象的引用计数并在计数归零时释放该对象\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在操作RxRPC bundle对象时缺乏适当的锁保护，导致存在竞态条件漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: rxrpc_put_bundle\n- 参数: [struct rxrpc_bundle *bundle]\n- 调用者: 未指定\n- 被调用者: [__refcount_dec_and_test, _debug, rxrpc_free_bundle]\n\n2. 函数名: __refcount_dec_and_test\n- 参数: [&bundle->ref, &r]\n- 调用者: rxrpc_put_bundle\n- 被调用者: 未指定\n\n3. 函数名: _debug\n- 参数: [\"PUT B=%x %d\", d, r]\n- 调用者: rxrpc_put_bundle\n- 被调用者: 未指定\n\n4. 函数名: rxrpc_free_bundle\n- 参数: [bundle]\n- 调用者: rxrpc_put_bundle\n- 被调用者: 未指定"
    },
    {
        "id": 3983,
        "cwe": "CWE-362",
        "cve": "CVE-2023-2898",
        "purpose": "Code purpose:\"\"\"该代码实现了F2FS文件系统的调整大小功能，需要管理员权限且文件系统非只读时，将用户空间传入的块数量参数传递给底层调整函数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于在f2fs_ioc_resize_fs函数中未对用户传入的block_count参数进行有效性验证，可能导致空指针解引用，造成拒绝服务。\"\"\"",
        "functions": "Functions:\n1. 函数名: f2fs_ioc_resize_fs\n- 参数: [struct file *filp, unsigned long arg]\n- 调用者: 未显示（应为系统调用或上层函数）\n- 被调用者: [file_inode, capable, f2fs_readonly, copy_from_user, f2fs_resize_fs]\n\n2. 函数名: file_inode\n- 参数: [struct file *filp]\n- 调用者: f2fs_ioc_resize_fs\n- 被调用者: []\n\n3. 函数名: capable\n- 参数: [CAP_SYS_ADMIN]\n- 调用者: f2fs_ioc_resize_fs\n- 被调用者: []\n\n4. 函数名: f2fs_readonly\n- 参数: [struct super_block *sb]\n- 调用者: f2fs_ioc_resize_fs\n- 被调用者: []\n\n5. 函数名: copy_from_user\n- 参数: [__u64 *block_count, void __user *arg, sizeof(block_count)]\n- 调用者: f2fs_ioc_resize_fs\n- 被调用者: []\n\n6. 函数名: f2fs_resize_fs\n- 参数: [struct f2fs_sb_info *sbi, __u64 block_count]\n- 调用者: f2fs_ioc_resize_fs\n- 被调用者: []"
    },
    {
        "id": 3993,
        "cwe": "CWE-362",
        "cve": "CVE-2023-3108",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的对称密钥密码算法接口中，将用户空间的数据迭代器转换为散列表(sg)以便进行加密操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确处理并发条件下的资源竞争，导致在skcipher_recvmsg函数中调用get_user_pages_fast时可能引发系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: af_alg_make_sg\n- 参数: [struct af_alg_sgl *sgl, struct iov_iter *iter, int len]\n- 调用者: 未明确（可能是外部调用）\n- 被调用者: [iov_iter_get_pages, PAGE_ALIGN, WARN_ON, sg_init_table, min_t, sg_set_page]\n\n2. 函数名: iov_iter_get_pages\n- 参数: [struct iov_iter *iter, struct page **pages, size_t maxsize, unsigned maxpages, size_t *start]\n- 调用者: af_alg_make_sg\n- 被调用者: 未明确\n\n3. 函数名: PAGE_ALIGN\n- 参数: [size_t size]\n- 调用者: af_alg_make_sg\n- 被调用者: 未明确\n\n4. 函数名: WARN_ON\n- 参数: [bool condition]\n- 调用者: af_alg_make_sg\n- 被调用者: 未明确\n\n5. 函数名: sg_init_table\n- 参数: [struct scatterlist *sgl, unsigned int nents]\n- 调用者: af_alg_make_sg\n- 被调用者: 未明确\n\n6. 函数名: min_t\n- 参数: [type, x, y]\n- 调用者: af_alg_make_sg\n- 被调用者: 未明确\n\n7. 函数名: sg_set_page\n- 参数: [struct scatterlist *sg, struct page *page, unsigned int len, unsigned int offset]\n- 调用者: af_alg_make_sg\n- 被调用者: 未明确"
    },
    {
        "id": 3994,
        "cwe": "CWE-362",
        "cve": "CVE-2023-3108",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中对称密钥密码算法的接收消息功能，处理来自用户空间的加密/解密请求并返回结果。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在skcipher_recvmsg函数中未正确处理并发访问，导致竞争条件(CWE-362)可能被利用来使系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: skcipher_recvmsg\n- 参数: [struct kiocb *unused, struct socket *sock, struct msghdr *msg, size_t ignored, int flags]\n- 调用者: N/A (kernel-level socket operation)\n- 被调用者: [alg_sk, crypto_ablkcipher_blocksize, crypto_ablkcipher_reqtfm, lock_sock, iov_iter_count, list_first_entry, skcipher_wait_for_data, min_t, af_alg_make_sg, ablkcipher_request_set_crypt, af_alg_wait_for_completion, crypto_ablkcipher_encrypt, crypto_ablkcipher_decrypt, af_alg_free_sg, skcipher_pull_sgl, iov_iter_advance, skcipher_wmem_wakeup, release_sock]\n\n2. 函数名: alg_sk\n- 参数: [struct sock *sk]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n3. 函数名: crypto_ablkcipher_blocksize\n- 参数: [struct crypto_ablkcipher *tfm]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n4. 函数名: crypto_ablkcipher_reqtfm\n- 参数: [struct ablkcipher_request *req]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n5. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n6. 函数名: iov_iter_count\n- 参数: [struct iov_iter *i]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n7. 函数名: list_first_entry\n- 参数: [struct list_head *ptr, type, member]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n8. 函数名: skcipher_wait_for_data\n- 参数: [struct sock *sk, int flags]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n9. 函数名: min_t\n- 参数: [type, x, y]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n10. 函数名: af_alg_make_sg\n- 参数: [struct af_alg_sgl *sgl, struct iov_iter *iter, size_t len]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n11. 函数名: ablkcipher_request_set_crypt\n- 参数: [struct ablkcipher_request *req, struct scatterlist *src, struct scatterlist *dst, unsigned int nbytes, void *iv]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n12. 函数名: af_alg_wait_for_completion\n- 参数: [int completion, struct completion *wait]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n13. 函数名: crypto_ablkcipher_encrypt\n- 参数: [struct ablkcipher_request *req]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n14. 函数名: crypto_ablkcipher_decrypt\n- 参数: [struct ablkcipher_request *req]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n15. 函数名: af_alg_free_sg\n- 参数: [struct af_alg_sgl *sgl]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n16. 函数名: skcipher_pull_sgl\n- 参数: [struct sock *sk, int used]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n17. 函数名: iov_iter_advance\n- 参数: [struct iov_iter *i, size_t size]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n18. 函数名: skcipher_wmem_wakeup\n- 参数: [struct sock *sk]\n- 调用者: skcipher_recvmsg\n- 被调用者: []\n\n19. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: skcipher_recvmsg\n- 被调用者: []"
    },
    {
        "id": 3995,
        "cwe": "CWE-362",
        "cve": "CVE-2023-31083",
        "purpose": "Code purpose:\"\"\"该代码实现了HCI UART TTY设备的IO控制功能，包括设置/获取协议、设置/获取标志等操作，用于管理蓝牙串行通信。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在设置协议标志位HCI_UART_PROTO_SET和实际设置hu->proto之间存在竞态条件，导致HCIUARTGETPROTO可能在hu->proto未设置时被调用，从而引发空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: hci_uart_tty_ioctl\n- 参数: [tty, cmd, arg]\n- 调用者: 未指定（由TTY子系统调用）\n- 被调用者: [test_and_set_bit, hci_uart_set_proto, clear_bit, test_bit, hci_uart_set_flags, n_tty_ioctl_helper]\n\n2. 函数名: test_and_set_bit\n- 参数: [HCI_UART_PROTO_SET, &hu->flags]\n- 调用者: hci_uart_tty_ioctl\n- 被调用者: []\n\n3. 函数名: hci_uart_set_proto\n- 参数: [hu, arg]\n- 调用者: hci_uart_tty_ioctl\n- 被调用者: []\n\n4. 函数名: clear_bit\n- 参数: [HCI_UART_PROTO_SET, &hu->flags]\n- 调用者: hci_uart_tty_ioctl\n- 被调用者: []\n\n5. 函数名: test_bit\n- 参数: [HCI_UART_PROTO_SET, &hu->flags] 或 [HCI_UART_REGISTERED, &hu->flags]\n- 调用者: hci_uart_tty_ioctl\n- 被调用者: []\n\n6. 函数名: hci_uart_set_flags\n- 参数: [hu, arg]\n- 调用者: hci_uart_tty_ioctl\n- 被调用者: []\n\n7. 函数名: n_tty_ioctl_helper\n- 参数: [tty, cmd, arg]\n- 调用者: hci_uart_tty_ioctl\n- 被调用者: []"
    },
    {
        "id": 4017,
        "cwe": "CWE-362",
        "cve": "CVE-2023-32250",
        "purpose": "Code purpose:\"\"\"释放ksmbd连接结构体中的服务器互斥锁\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_SESSION_SETUP命令时，由于对对象操作缺乏适当的锁保护，导致竞争条件漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ksmbd_conn_unlock\n- 参数: [struct ksmbd_conn *conn]\n- 调用者: 未明确（需查看完整代码）\n- 被调用者: [mutex_unlock]"
    },
    {
        "id": 4018,
        "cwe": "CWE-362",
        "cve": "CVE-2023-32250",
        "purpose": "Code purpose:\"\"\"该代码片段用于通过获取互斥锁来保护对ksmbd连接结构的并发访问\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_SESSION_SETUP命令时，由于对对象操作缺乏适当的锁定机制，导致并发竞争条件漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ksmbd_conn_lock\n- 参数: [struct ksmbd_conn *conn]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [mutex_lock]"
    },
    {
        "id": 4019,
        "cwe": "CWE-362",
        "cve": "CVE-2023-32250",
        "purpose": "Code purpose:\"\"\"检查ksmbd连接是否存活，根据服务器状态、会话状态、线程状态、打开文件数和最后活动时间等因素决定是否保持连接\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_SESSION_SETUP命令时，缺乏对对象操作的适当锁定机制，导致竞争条件漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ksmbd_conn_alive\n- 参数: [struct ksmbd_conn *conn]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [ksmbd_server_running, atomic_read, time_after, ksmbd_debug]\n\n2. 函数名: ksmbd_server_running\n- 参数: []\n- 调用者: ksmbd_conn_alive\n- 被调用者: []\n\n3. 函数名: atomic_read\n- 参数: [&conn->stats.open_files_count]\n- 调用者: ksmbd_conn_alive\n- 被调用者: []\n\n4. 函数名: time_after\n- 参数: [jiffies, conn->last_active + server_conf.deadtime]\n- 调用者: ksmbd_conn_alive\n- 被调用者: []\n\n5. 函数名: ksmbd_debug\n- 参数: [CONN, \"No response from client in %lu minutes\\n\", server_conf.deadtime / SMB_ECHO_INTERVAL]\n- 调用者: ksmbd_conn_alive\n- 被调用者: []"
    },
    {
        "id": 4020,
        "cwe": "CWE-362",
        "cve": "CVE-2023-32250",
        "purpose": "Code purpose:\"\"\"检查SMB连接状态并在连接断开或需要重连时设置错误状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_SESSION_SETUP命令时，由于对对象操作缺乏适当的锁保护，导致竞争条件漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: check_conn_state\n- 参数: [struct ksmbd_work *work]\n- 调用者: 未明确（需查看完整代码）\n- 被调用者: [ksmbd_conn_exiting, ksmbd_conn_need_reconnect]\n\n2. 函数名: ksmbd_conn_exiting\n- 参数: [struct ksmbd_work *work]\n- 调用者: check_conn_state\n- 被调用者: []\n\n3. 函数名: ksmbd_conn_need_reconnect\n- 参数: [struct ksmbd_work *work]\n- 调用者: check_conn_state\n- 被调用者: []"
    },
    {
        "id": 4021,
        "cwe": "CWE-362",
        "cve": "CVE-2023-32250",
        "purpose": "Code purpose:\"\"\"处理SMB2协议的协商请求，包括验证请求参数、初始化服务器配置、设置安全模式等，以建立客户端与服务器之间的通信连接。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_SESSION_SETUP命令时，由于缺乏对对象操作的适当锁定机制，导致存在竞争条件漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: smb2_handle_negotiate\n- 参数: [struct ksmbd_work *work]\n- 调用者: 未显示\n- 被调用者: [smb2_get_msg, ksmbd_debug, ksmbd_conn_good, get_rfc1002_len, le32_to_cpu, le16_to_cpu, kzalloc, deassemble_neg_contexts, kfree, init_smb3_11_server, ksmbd_gen_preauth_integrity_hash, cpu_to_le32, assemble_neg_contexts, init_smb3_02_server, init_smb3_0_server, init_smb2_1_server, memset, ksmbd_systime, ksmbd_copy_gss_neg_header, inc_rfc1001_len, smb2_set_err_rsp]\n\n2. 函数名: smb2_get_msg\n- 参数: [work->request_buf, work->response_buf]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n3. 函数名: ksmbd_debug\n- 参数: [SMB, \"Received negotiate request\\n\", \"Server dialect :0x%x not supported\\n\", \"negotiate context offset %d, count %d\\n\"]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n4. 函数名: ksmbd_conn_good\n- 参数: [work]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n5. 函数名: get_rfc1002_len\n- 参数: [work->request_buf]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n6. 函数名: le32_to_cpu\n- 参数: [req->NegotiateContextOffset, req->Capabilities, rsp->NegotiateContextOffset]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n7. 函数名: le16_to_cpu\n- 参数: [req->DialectCount, req->SecurityMode, rsp->SecurityBufferOffset]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n8. 函数名: kzalloc\n- 参数: [sizeof(struct preauth_integrity_info), GFP_KERNEL]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n9. 函数名: deassemble_neg_contexts\n- 参数: [conn, req, get_rfc1002_len(work->request_buf)]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n10. 函数名: kfree\n- 参数: [conn->preauth_info]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n11. 函数名: init_smb3_11_server\n- 参数: [conn]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n12. 函数名: ksmbd_gen_preauth_integrity_hash\n- 参数: [conn, work->request_buf, conn->preauth_info->Preauth_HashValue]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n13. 函数名: cpu_to_le32\n- 参数: [OFFSET_OF_NEG_CONTEXT, conn->vals->capabilities, conn->vals->max_trans_size, conn->vals->max_read_size, conn->vals->max_write_size]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n14. 函数名: assemble_neg_contexts\n- 参数: [conn, rsp, work->response_buf]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n15. 函数名: init_smb3_02_server\n- 参数: [conn]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n16. 函数名: init_smb3_0_server\n- 参数: [conn]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n17. 函数名: init_smb2_1_server\n- 参数: [conn]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n18. 函数名: memset\n- 参数: [rsp->ServerGUID, 0, SMB2_CLIENT_GUID_SIZE]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n19. 函数名: ksmbd_systime\n- 参数: []\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n20. 函数名: ksmbd_copy_gss_neg_header\n- 参数: [(char *)(&rsp->hdr) + le16_to_cpu(rsp->SecurityBufferOffset)]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n21. 函数名: inc_rfc1001_len\n- 参数: [work->response_buf, sizeof(struct smb2_negotiate_rsp) - sizeof(struct smb2_hdr) + AUTH_GSS_LENGTH]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n22. 函数名: smb2_set_err_rsp\n- 参数: [work]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示"
    },
    {
        "id": 4022,
        "cwe": "CWE-362",
        "cve": "CVE-2023-32250",
        "purpose": "Code purpose:\"\"\"销毁与当前用户匹配的先前会话，并标记相关通道状态为退出\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_SESSION_SETUP命令时，对会话对象的操作缺乏适当的锁保护，导致竞争条件可能被利用执行内核代码。\"\"\"",
        "functions": "Functions:\n1. 函数名: destroy_previous_session\n- 参数: [conn, user, id]\n- 调用者: 未显示\n- 被调用者: [ksmbd_session_lookup_slowpath, strcmp, memcmp, xa_for_each]\n\n2. 函数名: ksmbd_session_lookup_slowpath\n- 参数: [id]\n- 调用者: destroy_previous_session\n- 被调用者: 未显示\n\n3. 函数名: strcmp\n- 参数: [user->name, prev_user->name]\n- 调用者: destroy_previous_session\n- 被调用者: 未显示\n\n4. 函数名: memcmp\n- 参数: [user->passkey, prev_user->passkey, user->passkey_sz]\n- 调用者: destroy_previous_session\n- 被调用者: 未显示\n\n5. 函数名: xa_for_each\n- 参数: [&prev_sess->ksmbd_chann_list, index, chann]\n- 调用者: destroy_previous_session\n- 被调用者: 未显示"
    },
    {
        "id": 4023,
        "cwe": "CWE-362",
        "cve": "CVE-2023-32250",
        "purpose": "Code purpose:\"\"\"该代码实现了SMB2协议协商响应的初始化功能，包括设置协议头、协商参数和安全认证相关信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_SESSION_SETUP命令时，由于缺乏对对象操作的适当锁定机制，导致存在竞争条件漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: init_smb2_neg_rsp\n- 参数: [struct ksmbd_work *work]\n- 调用者: 未显示\n- 被调用者: [cpu_to_be32, smb2_get_msg, memset, cpu_to_le16, ksmbd_conn_good, ksmbd_debug, cpu_to_le32, cpu_to_le64, ksmbd_systime, ksmbd_copy_gss_neg_header, le16_to_cpu, inc_rfc1001_len, ksmbd_conn_set_need_negotiate]\n\n2. 函数名: cpu_to_be32\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n3. 函数名: smb2_get_msg\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n4. 函数名: memset\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n5. 函数名: cpu_to_le16\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n6. 函数名: ksmbd_conn_good\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n7. 函数名: ksmbd_debug\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n8. 函数名: cpu_to_le32\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n9. 函数名: cpu_to_le64\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n10. 函数名: ksmbd_systime\n- 参数: []\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n11. 函数名: ksmbd_copy_gss_neg_header\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n12. 函数名: le16_to_cpu\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n13. 函数名: inc_rfc1001_len\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n14. 函数名: ksmbd_conn_set_need_negotiate\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []"
    },
    {
        "id": 4024,
        "cwe": "CWE-362",
        "cve": "CVE-2023-32250",
        "purpose": "Code purpose:\"\"\"该代码片段实现了ksmbd内核模块中TCP读取功能，用于处理SMB2协议会话建立命令的数据接收操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_SESSION_SETUP命令时，由于缺乏对对象的适当锁定机制，导致竞争条件漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ksmbd_tcp_readv\n- 参数: [t, iov_orig, nr_segs, to_read, max_retries]\n- 调用者: N/A\n- 被调用者: [get_conn_iovec, ksmbd_conn_alive, kvec_array_init, kernel_recvmsg, try_to_freeze, usleep_range]\n\n2. 函数名: get_conn_iovec\n- 参数: [t, nr_segs]\n- 调用者: ksmbd_tcp_readv\n- 被调用者: N/A\n\n3. 函数名: ksmbd_conn_alive\n- 参数: [conn]\n- 调用者: ksmbd_tcp_readv\n- 被调用者: N/A\n\n4. 函数名: kvec_array_init\n- 参数: [iov, iov_orig, nr_segs, total_read]\n- 调用者: ksmbd_tcp_readv\n- 被调用者: N/A\n\n5. 函数名: kernel_recvmsg\n- 参数: [t->sock, &ksmbd_msg, iov, segs, to_read, 0]\n- 调用者: ksmbd_tcp_readv\n- 被调用者: N/A\n\n6. 函数名: try_to_freeze\n- 参数: []\n- 调用者: ksmbd_tcp_readv\n- 被调用者: N/A\n\n7. 函数名: usleep_range\n- 参数: [1000, 2000]\n- 调用者: ksmbd_tcp_readv\n- 被调用者: N/A"
    },
    {
        "id": 4033,
        "cwe": "CWE-362",
        "cve": "CVE-2023-32254",
        "purpose": "Code purpose:\"\"\"该代码用于在ksmbd会话中通过ID查找对应的树连接结构体\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_TREE_DISCONNECT命令时，对会话树连接对象的操作缺乏适当的锁保护机制\"\"\"",
        "functions": "Functions:\n1. 函数名: ksmbd_tree_conn_lookup\n- 参数: [sess, id]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [xa_load]\n\n2. 函数名: xa_load\n- 参数: [&sess->tree_conns, id]\n- 调用者: ksmbd_tree_conn_lookup\n- 被调用者: 未明确（内核内部函数）"
    },
    {
        "id": 4057,
        "cwe": "CWE-362",
        "cve": "CVE-2023-33203",
        "purpose": "Code purpose:\"\"\"该代码实现了EMAC网络设备驱动程序的移除功能，包括注销网络设备、清理时钟资源、释放内存映射和网络设备结构等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在emac_remove函数中存在竞态条件，当设备被物理拔出时可能导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: emac_remove\n- 参数: [struct platform_device *pdev]\n- 调用者: 平台设备驱动框架\n- 被调用者: [dev_get_drvdata, netdev_priv, unregister_netdev, netif_napi_del, emac_clks_teardown, put_device, mdiobus_unregister, iounmap, free_netdev]\n\n2. 函数名: dev_get_drvdata\n- 参数: [struct device *dev]\n- 调用者: emac_remove\n- 被调用者: []\n\n3. 函数名: netdev_priv\n- 参数: [struct net_device *dev]\n- 调用者: emac_remove\n- 被调用者: []\n\n4. 函数名: unregister_netdev\n- 参数: [struct net_device *dev]\n- 调用者: emac_remove\n- 被调用者: []\n\n5. 函数名: netif_napi_del\n- 参数: [struct napi_struct *napi]\n- 调用者: emac_remove\n- 被调用者: []\n\n6. 函数名: emac_clks_teardown\n- 参数: [struct emac_adapter *adpt]\n- 调用者: emac_remove\n- 被调用者: []\n\n7. 函数名: put_device\n- 参数: [struct device *dev]\n- 调用者: emac_remove\n- 被调用者: []\n\n8. 函数名: mdiobus_unregister\n- 参数: [struct mii_bus *bus]\n- 调用者: emac_remove\n- 被调用者: []\n\n9. 函数名: iounmap\n- 参数: [void *addr]\n- 调用者: emac_remove\n- 被调用者: []\n\n10. 函数名: free_netdev\n- 参数: [struct net_device *dev]\n- 调用者: emac_remove\n- 被调用者: []"
    },
    {
        "id": 4078,
        "cwe": "CWE-362",
        "cve": "CVE-2023-33951",
        "purpose": "Code purpose:\"\"\"该代码用于在vmwgfx驱动中创建一个简单的DRM缓冲区对象(dumb buffer)，处理颜色格式并计算缓冲区大小和步长(pitch)，最终通过GEM对象创建带句柄的缓冲区。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在GEM对象操作时未正确使用锁机制，导致存在竞争条件漏洞，允许本地特权用户在内核上下文中泄露信息\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_dumb_create\n- 参数: [file_priv, dev, args]\n- 调用者: 未指定（由DRM框架调用）\n- 被调用者: [vmw_priv, DIV_ROUND_UP, ALIGN, vmw_gem_object_create_with_handle]\n\n2. 函数名: vmw_priv\n- 参数: [dev]\n- 调用者: vmw_dumb_create\n- 被调用者: []\n\n3. 函数名: DIV_ROUND_UP\n- 参数: [args->bpp, 8]\n- 调用者: vmw_dumb_create\n- 被调用者: []\n\n4. 函数名: ALIGN\n- 参数: [args->pitch * args->height, PAGE_SIZE]\n- 调用者: vmw_dumb_create\n- 被调用者: []\n\n5. 函数名: vmw_gem_object_create_with_handle\n- 参数: [dev_priv, file_priv, args->size, &args->handle, &vbo]\n- 调用者: vmw_dumb_create\n- 被调用者: []"
    },
    {
        "id": 4079,
        "cwe": "CWE-362",
        "cve": "CVE-2023-33951",
        "purpose": "Code purpose:\"\"\"处理虚拟机图形驱动中用户空间与内核空间之间关于GEM对象的同步CPU操作，包括获取和释放操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在vmwgfx驱动中处理GEM对象时存在竞态条件，由于对对象操作时未正确加锁，导致本地特权用户可能泄露内核上下文信息\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_user_bo_synccpu_ioctl\n- 参数: [struct drm_device *dev, void *data, struct drm_file *file_priv]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [vmw_user_bo_lookup, vmw_user_bo_synccpu_grab, vmw_bo_unreference, vmw_user_bo_synccpu_release]\n\n2. 函数名: vmw_user_bo_lookup\n- 参数: [struct drm_file *file_priv, unsigned int handle, struct vmw_bo **vbo]\n- 调用者: vmw_user_bo_synccpu_ioctl\n- 被调用者: 未显示\n\n3. 函数名: vmw_user_bo_synccpu_grab\n- 参数: [struct vmw_bo *vbo, unsigned int flags]\n- 调用者: vmw_user_bo_synccpu_ioctl\n- 被调用者: 未显示\n\n4. 函数名: vmw_bo_unreference\n- 参数: [struct vmw_bo **vbo]\n- 调用者: vmw_user_bo_synccpu_ioctl\n- 被调用者: 未显示\n\n5. 函数名: vmw_user_bo_synccpu_release\n- 参数: [struct drm_file *file_priv, unsigned int handle, unsigned int flags]\n- 调用者: vmw_user_bo_synccpu_ioctl\n- 被调用者: 未显示"
    },
    {
        "id": 4080,
        "cwe": "CWE-362",
        "cve": "CVE-2023-33951",
        "purpose": "Code purpose:\"\"\"该代码用于释放VMware图形驱动中用户空间缓冲区对象的CPU同步资源，并处理相关引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在操作GEM对象时未正确实施锁定机制，导致存在竞争条件漏洞，允许本地特权用户在内核上下文中泄露信息\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_user_bo_synccpu_release\n- 参数: [struct drm_file *filp, uint32_t handle, uint32_t flags]\n- 调用者: 未指定（由外部调用）\n- 被调用者: [vmw_user_bo_lookup, atomic_dec, ttm_bo_put]\n\n2. 函数名: vmw_user_bo_lookup\n- 参数: [struct drm_file *filp, uint32_t handle, struct vmw_bo **vmw_bo]\n- 调用者: vmw_user_bo_synccpu_release\n- 被调用者: 未指定（可能为内部或外部函数）\n\n3. 函数名: atomic_dec\n- 参数: [atomic_t *v]\n- 调用者: vmw_user_bo_synccpu_release\n- 被调用者: 未指定（原子操作函数）\n\n4. 函数名: ttm_bo_put\n- 参数: [struct ttm_buffer_object *bo]\n- 调用者: vmw_user_bo_synccpu_release\n- 被调用者: 未指定（TTM缓冲区对象管理函数）"
    },
    {
        "id": 4081,
        "cwe": "CWE-362",
        "cve": "CVE-2023-33951",
        "purpose": "Code purpose:\"\"\"将客户机指针转换为虚拟机图形驱动可用的缓冲区对象，并处理相关的重定位信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在操作GEM对象时未正确实施锁定机制，导致存在竞争条件漏洞，允许本地特权用户在内核上下文中泄露信息\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_translate_guest_ptr\n- 参数: [struct vmw_private *dev_priv, struct vmw_sw_context *sw_context, SVGAGuestPtr *ptr, struct vmw_bo **vmw_bo_p]\n- 调用者: N/A\n- 被调用者: [vmw_validation_preload_bo, vmw_user_bo_lookup, drm_dbg, vmw_bo_placement_set, vmw_validation_add_bo, ttm_bo_put, vmw_validation_mem_alloc, list_add_tail]\n\n2. 函数名: vmw_validation_preload_bo\n- 参数: [sw_context->ctx]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: N/A\n\n3. 函数名: vmw_user_bo_lookup\n- 参数: [sw_context->filp, handle, &vmw_bo]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: N/A\n\n4. 函数名: drm_dbg\n- 参数: [&dev_priv->drm, \"Could not find or use GMR region.\"]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: N/A\n\n5. 函数名: vmw_bo_placement_set\n- 参数: [vmw_bo, VMW_BO_DOMAIN_GMR | VMW_BO_DOMAIN_VRAM, VMW_BO_DOMAIN_GMR | VMW_BO_DOMAIN_VRAM]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: N/A\n\n6. 函数名: vmw_validation_add_bo\n- 参数: [sw_context->ctx, vmw_bo]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: N/A\n\n7. 函数名: ttm_bo_put\n- 参数: [&vmw_bo->tbo]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: N/A\n\n8. 函数名: vmw_validation_mem_alloc\n- 参数: [sw_context->ctx, sizeof(*reloc)]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: N/A\n\n9. 函数名: list_add_tail\n- 参数: [&reloc->head, &sw_context->bo_relocations]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: N/A"
    },
    {
        "id": 4082,
        "cwe": "CWE-362",
        "cve": "CVE-2023-33951",
        "purpose": "Code purpose:\"\"\"将用户空间的MOB缓冲区ID转换为内核空间的vmw_bo对象，并建立相关映射关系\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在操作GEM对象时未正确实施锁定机制，导致存在竞争条件漏洞，允许本地特权用户在内核上下文中泄露信息\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_translate_mob_ptr\n- 参数: [dev_priv, sw_context, id, vmw_bo_p]\n- 调用者: N/A\n- 被调用者: [vmw_validation_preload_bo, vmw_user_bo_lookup, vmw_bo_placement_set, vmw_validation_add_bo, ttm_bo_put, vmw_validation_mem_alloc, list_add_tail]\n\n2. 函数名: vmw_validation_preload_bo\n- 参数: [sw_context->ctx]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: []\n\n3. 函数名: vmw_user_bo_lookup\n- 参数: [sw_context->filp, handle, &vmw_bo]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: []\n\n4. 函数名: vmw_bo_placement_set\n- 参数: [vmw_bo, VMW_BO_DOMAIN_MOB, VMW_BO_DOMAIN_MOB]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: []\n\n5. 函数名: vmw_validation_add_bo\n- 参数: [sw_context->ctx, vmw_bo]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: []\n\n6. 函数名: ttm_bo_put\n- 参数: [&vmw_bo->tbo]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: []\n\n7. 函数名: vmw_validation_mem_alloc\n- 参数: [sw_context->ctx, sizeof(*reloc)]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: []\n\n8. 函数名: list_add_tail\n- 参数: [&reloc->head, &sw_context->bo_relocations]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: []"
    },
    {
        "id": 4083,
        "cwe": "CWE-362",
        "cve": "CVE-2023-33951",
        "purpose": "Code purpose:\"\"\"该代码实现了在vmwgfx驱动中创建GEM对象并返回相关句柄和映射信息的IOCTL接口功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在操作GEM对象时未正确使用锁机制，导致存在竞态条件漏洞，可能造成内核信息泄露\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_gem_object_create_ioctl\n- 参数: [struct drm_device *dev, void *data, struct drm_file *filp]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [vmw_priv, vmw_gem_object_create_with_handle, drm_vma_node_offset_addr]\n\n2. 函数名: vmw_priv\n- 参数: [struct drm_device *dev]\n- 调用者: vmw_gem_object_create_ioctl\n- 被调用者: []\n\n3. 函数名: vmw_gem_object_create_with_handle\n- 参数: [struct vmw_private *dev_priv, struct drm_file *filp, req->size, &handle, &vbo]\n- 调用者: vmw_gem_object_create_ioctl\n- 被调用者: []\n\n4. 函数名: drm_vma_node_offset_addr\n- 参数: [&vbo->tbo.base.vma_node]\n- 调用者: vmw_gem_object_create_ioctl\n- 被调用者: []"
    },
    {
        "id": 4084,
        "cwe": "CWE-362",
        "cve": "CVE-2023-33951",
        "purpose": "Code purpose:\"\"\"该代码用于在vmwgfx驱动中创建和管理帧缓冲对象，处理来自用户空间的帧缓冲创建请求并验证相关参数的有效性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在操作GEM对象时未正确实施锁定机制，导致存在竞争条件漏洞，允许本地特权用户在内核上下文中泄露信息\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_kms_fb_create\n- 参数: [struct drm_device *dev, struct drm_file *file_priv, const struct drm_mode_fb_cmd2 *mode_cmd]\n- 调用者: N/A (顶层函数)\n- 被调用者: [vmw_priv, vmw_user_lookup_handle, vmw_kms_srf_ok, vmw_kms_new_framebuffer, vmw_bo_unreference, vmw_surface_unreference]\n\n2. 函数名: vmw_priv\n- 参数: [struct drm_device *dev]\n- 调用者: vmw_kms_fb_create\n- 被调用者: []\n\n3. 函数名: vmw_user_lookup_handle\n- 参数: [struct vmw_private *dev_priv, struct drm_file *file_priv, unsigned int handle, struct vmw_surface **surface, struct vmw_bo **bo]\n- 调用者: vmw_kms_fb_create\n- 被调用者: []\n\n4. 函数名: vmw_kms_srf_ok\n- 参数: [struct vmw_private *dev_priv, unsigned int width, unsigned int height]\n- 调用者: vmw_kms_fb_create\n- 被调用者: []\n\n5. 函数名: vmw_kms_new_framebuffer\n- 参数: [struct vmw_private *dev_priv, struct vmw_bo *bo, struct vmw_surface *surface, bool is_dmabuf_proxy, const struct drm_mode_fb_cmd2 *mode_cmd]\n- 调用者: vmw_kms_fb_create\n- 被调用者: []\n\n6. 函数名: vmw_bo_unreference\n- 参数: [struct vmw_bo **bo]\n- 调用者: vmw_kms_fb_create\n- 被调用者: []\n\n7. 函数名: vmw_surface_unreference\n- 参数: [struct vmw_surface **surface]\n- 调用者: vmw_kms_fb_create\n- 被调用者: []"
    },
    {
        "id": 4085,
        "cwe": "CWE-362",
        "cve": "CVE-2023-33951",
        "purpose": "Code purpose:\"\"\"处理虚拟机图形设备驱动中的覆盖层IOCTL操作，包括流控制的启用/禁用和更新\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在操作GEM对象时未正确实现锁定机制，导致存在竞争条件漏洞，允许本地特权用户在内核上下文中泄露信息\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_overlay_ioctl\n- 参数: [struct drm_device *dev, void *data, struct drm_file *file_priv]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [vmw_fpriv, vmw_priv, vmw_overlay_available, vmw_user_stream_lookup, mutex_lock, vmw_overlay_stop, vmw_user_bo_lookup, vmw_overlay_update_stream, vmw_bo_unreference, mutex_unlock, vmw_resource_unreference]\n\n2. 函数名: vmw_fpriv\n- 参数: [struct drm_file *file_priv]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: 未显示\n\n3. 函数名: vmw_priv\n- 参数: [struct drm_device *dev]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: 未显示\n\n4. 函数名: vmw_overlay_available\n- 参数: [struct vmw_private *dev_priv]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: 未显示\n\n5. 函数名: vmw_user_stream_lookup\n- 参数: [struct vmw_private *dev_priv, struct ttm_object_file *tfile, &arg->stream_id, &res]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: 未显示\n\n6. 函数名: mutex_lock\n- 参数: [&overlay->mutex]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: 未显示\n\n7. 函数名: vmw_overlay_stop\n- 参数: [struct vmw_private *dev_priv, arg->stream_id, false, true]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: 未显示\n\n8. 函数名: vmw_user_bo_lookup\n- 参数: [file_priv, arg->handle, &buf]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: 未显示\n\n9. 函数名: vmw_overlay_update_stream\n- 参数: [struct vmw_private *dev_priv, buf, arg, true]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: 未显示\n\n10. 函数名: vmw_bo_unreference\n- 参数: [&buf]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: 未显示\n\n11. 函数名: mutex_unlock\n- 参数: [&overlay->mutex]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: 未显示\n\n12. 函数名: vmw_resource_unreference\n- 参数: [&res]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: 未显示"
    },
    {
        "id": 4086,
        "cwe": "CWE-362",
        "cve": "CVE-2023-33951",
        "purpose": "Code purpose:\"\"\"处理虚拟机图形驱动中的着色器定义操作，包括验证输入参数、查找缓冲区对象并根据着色器类型分配相应的着色器资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在GEM对象操作过程中未正确实施锁定机制，导致存在竞争条件漏洞，允许本地特权用户在内核上下文中泄露信息。\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_shader_define\n- 参数: [struct drm_device *dev, struct drm_file *file_priv, enum drm_vmw_shader_type shader_type_drm, u32 buffer_handle, size_t size, size_t offset, uint8_t num_input_sig, uint8_t num_output_sig, uint32_t *shader_handle]\n- 调用者: 未显示（外部调用）\n- 被调用者: [vmw_priv, vmw_fpriv, vmw_user_bo_lookup, VMW_DEBUG_USER, vmw_user_shader_alloc, vmw_bo_unreference]\n\n2. 函数名: vmw_priv\n- 参数: [struct drm_device *dev]\n- 调用者: vmw_shader_define\n- 被调用者: []\n\n3. 函数名: vmw_fpriv\n- 参数: [struct drm_file *file_priv]\n- 调用者: vmw_shader_define\n- 被调用者: []\n\n4. 函数名: vmw_user_bo_lookup\n- 参数: [struct drm_file *file_priv, u32 buffer_handle, struct vmw_bo **buffer]\n- 调用者: vmw_shader_define\n- 被调用者: []\n\n5. 函数名: VMW_DEBUG_USER\n- 参数: [const char *fmt, ...]\n- 调用者: vmw_shader_define\n- 被调用者: []\n\n6. 函数名: vmw_user_shader_alloc\n- 参数: [struct vmw_private *dev_priv, struct vmw_bo *buffer, size_t size, size_t offset, SVGA3dShaderType shader_type, uint8_t num_input_sig, uint8_t num_output_sig, struct ttm_object_file *tfile, uint32_t *shader_handle]\n- 调用者: vmw_shader_define\n- 被调用者: []\n\n7. 函数名: vmw_bo_unreference\n- 参数: [struct vmw_bo **buffer]\n- 调用者: vmw_shader_define\n- 被调用者: []"
    },
    {
        "id": 4109,
        "cwe": "CWE-362",
        "cve": "CVE-2023-35823",
        "purpose": "Code purpose:\"\"\"释放SAA7134视频设备中与传输流(TS)相关的页表资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在saa7134_ts_fini函数中释放了dev->ts_q.pt资源后，未将指针置空或确保后续不再被访问，导致潜在的释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: saa7134_ts_fini\n- 参数: [struct saa7134_dev *dev]\n- 调用者: 未明确（需查看完整代码上下文）\n- 被调用者: [saa7134_pgtable_free]\n\n2. 函数名: saa7134_pgtable_free\n- 参数: [dev->pci, &dev->ts_q.pt]\n- 调用者: saa7134_ts_fini\n- 被调用者: 未明确（需查看完整代码上下文）"
    },
    {
        "id": 4110,
        "cwe": "CWE-362",
        "cve": "CVE-2023-35823",
        "purpose": "Code purpose:\"\"\"该函数用于释放或清理SAA7134视频捕获设备的VBI相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"saa7134_vbi_fini函数未正确释放资源导致后续使用时出现use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: saa7134_vbi_fini\n- 参数: [struct saa7134_dev *dev]\n- 调用者: 未提供（上下文不足）\n- 被调用者: []"
    },
    {
        "id": 4111,
        "cwe": "CWE-362",
        "cve": "CVE-2023-35823",
        "purpose": "Code purpose:\"\"\"释放saa7134视频设备相关的资源，包括页表、视频队列、VBI队列和控制处理器\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在saa7134_video_fini函数中存在释放后使用(UAF)问题，由于未正确处理资源释放顺序或同步机制，导致在释放video_q.pt和vbi_q.pt等资源后仍可能被访问。\"\"\"",
        "functions": "Functions:\n1. 函数名: saa7134_video_fini\n- 参数: [struct saa7134_dev *dev]\n- 调用者: 未显示\n- 被调用者: [saa7134_pgtable_free, v4l2_ctrl_handler_free, card_has_radio]\n\n2. 函数名: saa7134_pgtable_free\n- 参数: [dev->pci, &dev->video_q.pt], [dev->pci, &dev->vbi_q.pt]\n- 调用者: saa7134_video_fini\n- 被调用者: 未显示\n\n3. 函数名: v4l2_ctrl_handler_free\n- 参数: [&dev->ctrl_handler], [&dev->radio_ctrl_handler]\n- 调用者: saa7134_video_fini\n- 被调用者: 未显示\n\n4. 函数名: card_has_radio\n- 参数: [dev]\n- 调用者: saa7134_video_fini\n- 被调用者: 未显示"
    },
    {
        "id": 4112,
        "cwe": "CWE-362",
        "cve": "CVE-2023-35824",
        "purpose": "Code purpose:\"\"\"该代码用于在移除dm1105 PCI设备时清理相关资源，包括中断、内存映射、DVB适配器等。\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在dm1105_remove函数中，存在对已释放资源(dmx)的后续操作，导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: dm1105_remove\n- 参数: [struct pci_dev *pdev]\n- 调用者: 无（由内核PCI子系统调用）\n- 被调用者: [pci_get_drvdata, dm1105_ir_exit, dvb_net_release, dvb_unregister_frontend, dmx->close, dmx->disconnect_frontend, dmx->remove_frontend, dvb_dmxdev_release, dvb_dmx_release, dvb_unregister_adapter, i2c_del_adapter, dm1105_hw_exit, free_irq, pci_iounmap, pci_release_regions, pci_disable_device, kfree]\n\n2. 函数名: pci_get_drvdata\n- 参数: [struct pci_dev *pdev]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n3. 函数名: dm1105_ir_exit\n- 参数: [struct dm1105_dev *dev]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n4. 函数名: dvb_net_release\n- 参数: [struct dvb_net *dvbnet]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n5. 函数名: dvb_unregister_frontend\n- 参数: [struct dvb_frontend *fe]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n6. 函数名: dmx->close\n- 参数: [struct dmx_demux *dmx]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n7. 函数名: dmx->disconnect_frontend\n- 参数: [struct dmx_demux *dmx]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n8. 函数名: dmx->remove_frontend\n- 参数: [struct dmx_demux *dmx, struct dmx_frontend *frontend]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n9. 函数名: dvb_dmxdev_release\n- 参数: [struct dvb_demux *dvbdemux]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n10. 函数名: dvb_dmx_release\n- 参数: [struct dvb_demux *dvbdemux]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n11. 函数名: dvb_unregister_adapter\n- 参数: [struct dvb_adapter *dvb_adapter]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n12. 函数名: i2c_del_adapter\n- 参数: [struct i2c_adapter *adap]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n13. 函数名: dm1105_hw_exit\n- 参数: [struct dm1105_dev *dev]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n14. 函数名: free_irq\n- 参数: [unsigned int irq, void *dev_id]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n15. 函数名: pci_iounmap\n- 参数: [struct pci_dev *pdev, void __iomem *addr]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n16. 函数名: pci_release_regions\n- 参数: [struct pci_dev *pdev]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n17. 函数名: pci_disable_device\n- 参数: [struct pci_dev *pdev]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n18. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: dm1105_remove\n- 被调用者: 无"
    },
    {
        "id": 4113,
        "cwe": "CWE-362",
        "cve": "CVE-2023-35826",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理Cedrus视频解码器设备的移除操作，包括注销媒体设备、释放资源和清理相关数据结构。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在cedrus_remove函数中，存在对已释放的media设备节点(dev->mdev.devnode)的后续访问，导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: cedrus_remove\n- 参数: [struct platform_device *pdev]\n- 调用者: 未显示（由平台驱动框架调用）\n- 被调用者: [platform_get_drvdata, media_devnode_is_registered, media_device_unregister, v4l2_m2m_unregister_media_controller, media_device_cleanup, v4l2_m2m_release, video_unregister_device, v4l2_device_unregister, cedrus_hw_remove]\n\n2. 函数名: platform_get_drvdata\n- 参数: [struct platform_device *pdev]\n- 调用者: cedrus_remove\n- 被调用者: []\n\n3. 函数名: media_devnode_is_registered\n- 参数: [dev->mdev.devnode]\n- 调用者: cedrus_remove\n- 被调用者: []\n\n4. 函数名: media_device_unregister\n- 参数: [&dev->mdev]\n- 调用者: cedrus_remove\n- 被调用者: []\n\n5. 函数名: v4l2_m2m_unregister_media_controller\n- 参数: [dev->m2m_dev]\n- 调用者: cedrus_remove\n- 被调用者: []\n\n6. 函数名: media_device_cleanup\n- 参数: [&dev->mdev]\n- 调用者: cedrus_remove\n- 被调用者: []\n\n7. 函数名: v4l2_m2m_release\n- 参数: [dev->m2m_dev]\n- 调用者: cedrus_remove\n- 被调用者: []\n\n8. 函数名: video_unregister_device\n- 参数: [&dev->vfd]\n- 调用者: cedrus_remove\n- 被调用者: []\n\n9. 函数名: v4l2_device_unregister\n- 参数: [&dev->v4l2_dev]\n- 调用者: cedrus_remove\n- 被调用者: []\n\n10. 函数名: cedrus_hw_remove\n- 参数: [dev]\n- 调用者: cedrus_remove\n- 被调用者: []"
    },
    {
        "id": 4114,
        "cwe": "CWE-362",
        "cve": "CVE-2023-35827",
        "purpose": "Code purpose:\"\"\"关闭网络设备并释放相关资源，包括中断禁用、DMA停止、时间戳列表清理、PHY断开连接和内存释放等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ravb_close函数中，存在资源释放顺序不当的问题，可能导致在释放中断或DMA资源后，其他代码路径仍尝试访问这些已被释放的资源，从而引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ravb_close\n- 参数: [struct net_device *ndev]\n- 调用者: 未显示\n- 被调用者: [netdev_priv, netif_tx_stop_all_queues, ravb_write, ravb_ptp_stop, ravb_stop_dma, netdev_err, list_for_each_entry_safe, list_del, kfree_skb, kfree, phy_stop, phy_disconnect, of_phy_is_fixed_link, of_phy_deregister_fixed_link, free_irq, napi_disable, ravb_ring_free]\n\n2. 函数名: netdev_priv\n- 参数: [struct net_device *ndev]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n3. 函数名: netif_tx_stop_all_queues\n- 参数: [struct net_device *ndev]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n4. 函数名: ravb_write\n- 参数: [struct net_device *ndev, int value, int reg]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n5. 函数名: ravb_ptp_stop\n- 参数: [struct net_device *ndev]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n6. 函数名: ravb_stop_dma\n- 参数: [struct net_device *ndev]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n7. 函数名: netdev_err\n- 参数: [struct net_device *ndev, const char *fmt, ...]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n8. 函数名: list_for_each_entry_safe\n- 参数: [type *pos, type *n, struct list_head *head, member]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n9. 函数名: list_del\n- 参数: [struct list_head *entry]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n10. 函数名: kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n11. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n12. 函数名: phy_stop\n- 参数: [struct phy_device *phydev]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n13. 函数名: phy_disconnect\n- 参数: [struct phy_device *phydev]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n14. 函数名: of_phy_is_fixed_link\n- 参数: [struct device_node *np]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n15. 函数名: of_phy_deregister_fixed_link\n- 参数: [struct device_node *np]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n16. 函数名: free_irq\n- 参数: [unsigned int irq, void *dev_id]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n17. 函数名: napi_disable\n- 参数: [struct napi_struct *n]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n18. 函数名: ravb_ring_free\n- 参数: [struct net_device *ndev, int queue]\n- 调用者: ravb_close\n- 被调用者: 未显示"
    },
    {
        "id": 4115,
        "cwe": "CWE-362",
        "cve": "CVE-2023-35828",
        "purpose": "Code purpose:\"\"\"该代码实现了Renesas USB3设备驱动在移除时的资源清理功能，包括删除调试文件系统、移除设备属性、注销USB角色切换、删除USB gadget UDC、重置控制、释放DMA资源、释放端点请求以及禁用电源管理等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在设备移除过程中，存在对已释放资源的后续访问，导致了use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: renesas_usb3_remove\n- 参数: [struct platform_device *pdev]\n- 调用者: platform_driver_unregister (间接调用)\n- 被调用者: [platform_get_drvdata, debugfs_remove_recursive, device_remove_file, usb_role_switch_unregister, usb_del_gadget_udc, reset_control_assert, renesas_usb3_dma_free_prd, __renesas_usb3_ep_free_request, pm_runtime_disable]\n\n2. 函数名: platform_get_drvdata\n- 参数: [struct platform_device *pdev]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n3. 函数名: debugfs_remove_recursive\n- 参数: [struct dentry *dentry]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n4. 函数名: device_remove_file\n- 参数: [struct device *dev, const struct device_attribute *attr]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n5. 函数名: usb_role_switch_unregister\n- 参数: [struct usb_role_switch *sw]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n6. 函数名: usb_del_gadget_udc\n- 参数: [struct usb_gadget *gadget]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n7. 函数名: reset_control_assert\n- 参数: [struct reset_control *rstc]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n8. 函数名: renesas_usb3_dma_free_prd\n- 参数: [struct renesas_usb3 *usb3, struct device *dev]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n9. 函数名: __renesas_usb3_ep_free_request\n- 参数: [struct usb_request *req]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n10. 函数名: pm_runtime_disable\n- 参数: [struct device *dev]\n- 调用者: renesas_usb3_remove\n- 被调用者: []"
    },
    {
        "id": 4116,
        "cwe": "CWE-362",
        "cve": "CVE-2023-35829",
        "purpose": "Code purpose:\"\"\"该代码片段实现了Linux内核中rkvdec驱动程序的移除功能，包括清理V4L2相关资源和禁用电源管理功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在rkvdec_remove函数中，未正确管理资源释放顺序导致在设备移除时可能发生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: rkvdec_remove\n- 参数: [struct platform_device *pdev]\n- 调用者: 未明确（通常由平台驱动框架调用）\n- 被调用者: [platform_get_drvdata, rkvdec_v4l2_cleanup, pm_runtime_disable, pm_runtime_dont_use_autosuspend]\n\n2. 函数名: platform_get_drvdata\n- 参数: [struct platform_device *pdev]\n- 调用者: rkvdec_remove\n- 被调用者: []\n\n3. 函数名: rkvdec_v4l2_cleanup\n- 参数: [struct rkvdec_dev *rkvdec]\n- 调用者: rkvdec_remove\n- 被调用者: []\n\n4. 函数名: pm_runtime_disable\n- 参数: [struct device *dev]\n- 调用者: rkvdec_remove\n- 被调用者: []\n\n5. 函数名: pm_runtime_dont_use_autosuspend\n- 参数: [struct device *dev]\n- 调用者: rkvdec_remove\n- 被调用者: []"
    },
    {
        "id": 4208,
        "cwe": "CWE-362",
        "cve": "CVE-2023-42756",
        "purpose": "Code purpose:\"\"\"该代码实现了对IP集合(ipset)的操作调用，包括添加、删除等操作，并处理可能的错误和重试情况，同时支持在批处理模式下返回错误行号信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于IPSET_CMD_ADD和IPSET_CMD_SWAP之间的竞争条件导致错误地调用了__ip_set_put，从而引发内核崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: call_ad\n- 参数: [net, ctnl, skb, set, tb, adt, flags, use_lineno]\n- 调用者: (未显示)\n- 被调用者: [__ip_set_get, nfnl_unlock, cond_resched, nfnl_lock, __ip_set_put, ip_set_lock, ip_set_unlock, nlmsg_hdr, nlmsg_new, nlmsg_put, nlmsg_data, unsafe_memcpy, nla_parse, nlmsg_free, nla_data, nfnetlink_unicast]\n\n2. 函数名: __ip_set_get\n- 参数: [set]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n3. 函数名: nfnl_unlock\n- 参数: [NFNL_SUBSYS_IPSET]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n4. 函数名: cond_resched\n- 参数: []\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n5. 函数名: nfnl_lock\n- 参数: [NFNL_SUBSYS_IPSET]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n6. 函数名: __ip_set_put\n- 参数: [set]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n7. 函数名: ip_set_lock\n- 参数: [set]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n8. 函数名: ip_set_unlock\n- 参数: [set]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n9. 函数名: nlmsg_hdr\n- 参数: [skb]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n10. 函数名: nlmsg_new\n- 参数: [payload, GFP_KERNEL]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n11. 函数名: nlmsg_put\n- 参数: [skb2, NETLINK_CB(skb).portid, nlh->nlmsg_seq, NLMSG_ERROR, payload, 0]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n12. 函数名: nlmsg_data\n- 参数: [rep]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n13. 函数名: unsafe_memcpy\n- 参数: [&errmsg->msg, nlh, nlh->nlmsg_len]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n14. 函数名: nla_parse\n- 参数: [cda, IPSET_ATTR_CMD_MAX, cmdattr, nlh->nlmsg_len - min_len, ip_set_adt_policy, NULL]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n15. 函数名: nlmsg_free\n- 参数: [skb2]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n16. 函数名: nla_data\n- 参数: [cda[IPSET_ATTR_LINENO]]\n- 调用者: call_ad\n- 被调用者: (未显示)\n\n17. 函数名: nfnetlink_unicast\n- 参数: [skb2, net, NETLINK_CB(skb).portid]\n- 调用者: call_ad\n- 被调用者: (未显示)"
    },
    {
        "id": 4243,
        "cwe": "CWE-362",
        "cve": "CVE-2023-4732",
        "purpose": "Code purpose:\"\"\"该代码用于处理大页内存保护属性的修改，包括NUMA迁移、用户态页错误处理等操作，并确保在多线程环境下的正确同步。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在内存管理子系统中，pfn_swap_entry_to_page函数存在缺陷，导致本地特权攻击者可能通过引用pmd_t x的BUG语句引发拒绝服务问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: change_huge_pmd\n- 参数: [struct vm_area_struct *vma, pmd_t *pmd, unsigned long addr, pgprot_t newprot, unsigned long cp_flags]\n- 调用者: 未明确显示（由内存管理子系统调用）\n- 被调用者: [__pmd_trans_huge_lock, pmd_write, is_swap_pmd, pmd_to_swp_entry, is_pmd_migration_entry, is_write_migration_entry, make_migration_entry_read, swp_entry_to_pmd, pmd_swp_soft_dirty, pmd_swp_mksoft_dirty, set_pmd_at, is_huge_zero_pmd, pmd_protnone, pmdp_invalidate, pmd_modify, pmd_mk_savedwrite, pmd_wrprotect, pmd_mkuffd_wp, pmd_clear_uffd_wp, vma_is_anonymous, spin_unlock]\n\n2. 函数名: __pmd_trans_huge_lock\n- 参数: [pmd_t *pmd, struct vm_area_struct *vma]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n3. 函数名: pmd_write\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n4. 函数名: is_swap_pmd\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n5. 函数名: pmd_to_swp_entry\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n6. 函数名: is_pmd_migration_entry\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n7. 函数名: is_write_migration_entry\n- 参数: [swp_entry_t entry]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n8. 函数名: make_migration_entry_read\n- 参数: [swp_entry_t *entry]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n9. 函数名: swp_entry_to_pmd\n- 参数: [swp_entry_t entry]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n10. 函数名: pmd_swp_soft_dirty\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n11. 函数名: pmd_swp_mksoft_dirty\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n12. 函数名: set_pmd_at\n- 参数: [struct mm_struct *mm, unsigned long addr, pmd_t *pmd, pmd_t entry]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n13. 函数名: is_huge_zero_pmd\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n14. 函数名: pmd_protnone\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n15. 函数名: pmdp_invalidate\n- 参数: [struct vm_area_struct *vma, unsigned long addr, pmd_t *pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n16. 函数名: pmd_modify\n- 参数: [pmd_t pmd, pgprot_t newprot]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n17. 函数名: pmd_mk_savedwrite\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n18. 函数名: pmd_wrprotect\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n19. 函数名: pmd_mkuffd_wp\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n20. 函数名: pmd_clear_uffd_wp\n- 参数: [pmd_t pmd]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n21. 函数名: vma_is_anonymous\n- 参数: [struct vm_area_struct *vma]\n- 调用者: change_huge_pmd\n- 被调用者: []\n\n22. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: change_huge_pmd\n- 被调用者: []"
    },
    {
        "id": 4244,
        "cwe": "CWE-362",
        "cve": "CVE-2023-4732",
        "purpose": "Code purpose:\"\"\"该代码用于处理内存迁移过程中大页(PMD)的移除和替换操作，包括页表项更新、缓存刷新和内存映射维护等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在内存管理子系统中，pfn_swap_entry_to_page函数处理pmd_t类型的交换条目时存在缺陷，导致本地特权攻击者可能通过触发BUG语句引发拒绝服务问题\"\"\"",
        "functions": "Functions:\n1. 函数名: remove_migration_pmd\n- 参数: [pvmw, new]\n- 调用者: N/A\n- 被调用者: [pmd_to_swp_entry, get_page, pmd_mkold, mk_huge_pmd, pmd_swp_soft_dirty, pmd_mksoft_dirty, is_write_migration_entry, maybe_pmd_mkwrite, flush_cache_range, PageAnon, page_add_anon_rmap, page_add_file_rmap, set_pmd_at, PageDoubleMap, mlock_vma_page, update_mmu_cache_pmd]\n\n2. 函数名: pmd_to_swp_entry\n- 参数: [*pvmw->pmd]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n3. 函数名: get_page\n- 参数: [new]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n4. 函数名: pmd_mkold\n- 参数: [mk_huge_pmd(new, vma->vm_page_prot)]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n5. 函数名: mk_huge_pmd\n- 参数: [new, vma->vm_page_prot]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n6. 函数名: pmd_swp_soft_dirty\n- 参数: [*pvmw->pmd]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n7. 函数名: pmd_mksoft_dirty\n- 参数: [pmde]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n8. 函数名: is_write_migration_entry\n- 参数: [entry]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n9. 函数名: maybe_pmd_mkwrite\n- 参数: [pmde, vma]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n10. 函数名: flush_cache_range\n- 参数: [vma, mmun_start, mmun_start + HPAGE_PMD_SIZE]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n11. 函数名: PageAnon\n- 参数: [new]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n12. 函数名: page_add_anon_rmap\n- 参数: [new, vma, mmun_start, true]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n13. 函数名: page_add_file_rmap\n- 参数: [new, true]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n14. 函数名: set_pmd_at\n- 参数: [mm, mmun_start, pvmw->pmd, pmde]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n15. 函数名: PageDoubleMap\n- 参数: [new]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n16. 函数名: mlock_vma_page\n- 参数: [new]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A\n\n17. 函数名: update_mmu_cache_pmd\n- 参数: [vma, address, pvmw->pmd]\n- 调用者: remove_migration_pmd\n- 被调用者: N/A"
    },
    {
        "id": 4245,
        "cwe": "CWE-362",
        "cve": "CVE-2023-4732",
        "purpose": "Code purpose:\"\"\"该代码用于在内存管理子系统中复制当前页表条目(PTE)，处理写保护、共享映射和用户态页错误处理等特性，实现虚拟内存页的复制功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在内存管理子系统中处理交换页表项时未正确验证pmd_t类型，导致本地攻击者可能通过触发BUG语句引发拒绝服务问题\"\"\"",
        "functions": "Functions:\n1. 函数名: copy_present_pte\n- 参数: [dst_vma, src_vma, dst_pte, src_pte, addr, rss, prealloc]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [vm_normal_page, copy_present_page, get_page, page_dup_rmap, is_cow_mapping, pte_write, ptep_set_wrprotect, pte_wrprotect, pte_mkclean, pte_mkold, pte_clear_uffd_wp, set_pte_at]\n\n2. 函数名: vm_normal_page\n- 参数: [src_vma, addr, pte]\n- 调用者: copy_present_pte\n- 被调用者: []\n\n3. 函数名: copy_present_page\n- 参数: [dst_vma, src_vma, dst_pte, src_pte, addr, rss, prealloc, pte, page]\n- 调用者: copy_present_pte\n- 被调用者: []\n\n4. 函数名: get_page\n- 参数: [page]\n- 调用者: copy_present_pte\n- 被调用者: []\n\n5. 函数名: page_dup_rmap\n- 参数: [page, false]\n- 调用者: copy_present_pte\n- 被调用者: []\n\n6. 函数名: is_cow_mapping\n- 参数: [vm_flags]\n- 调用者: copy_present_pte\n- 被调用者: []\n\n7. 函数名: pte_write\n- 参数: [pte]\n- 调用者: copy_present_pte\n- 被调用者: []\n\n8. 函数名: ptep_set_wrprotect\n- 参数: [src_mm, addr, src_pte]\n- 调用者: copy_present_pte\n- 被调用者: []\n\n9. 函数名: pte_wrprotect\n- 参数: [pte]\n- 调用者: copy_present_pte\n- 被调用者: []\n\n10. 函数名: pte_mkclean\n- 参数: [pte]\n- 调用者: copy_present_pte\n- 被调用者: []\n\n11. 函数名: pte_mkold\n- 参数: [pte]\n- 调用者: copy_present_pte\n- 被调用者: []\n\n12. 函数名: pte_clear_uffd_wp\n- 参数: [pte]\n- 调用者: copy_present_pte\n- 被调用者: []\n\n13. 函数名: set_pte_at\n- 参数: [dst_vma->vm_mm, addr, dst_pte, pte]\n- 调用者: copy_present_pte\n- 被调用者: []"
    },
    {
        "id": 4246,
        "cwe": "CWE-362",
        "cve": "CVE-2023-4732",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核内存管理子系统中复制进程地址空间的PMD(页中间目录)范围，处理大页和普通页的复制操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在内存管理子系统中处理交换页表项时，对pmd_t类型的引用存在缺陷，导致本地特权攻击者可能通过触发BUG语句引发拒绝服务问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: copy_pmd_range\n- 参数: [dst_vma, src_vma, dst_pud, src_pud, addr, end]\n- 调用者: 未明确（由内核内存管理子系统调用）\n- 被调用者: [pmd_alloc, pmd_offset, pmd_addr_end, is_swap_pmd, pmd_trans_huge, pmd_devmap, copy_huge_pmd, pmd_none_or_clear_bad, copy_pte_range]\n\n2. 函数名: pmd_alloc\n- 参数: [dst_mm, dst_pud, addr]\n- 调用者: copy_pmd_range\n- 被调用者: []\n\n3. 函数名: pmd_offset\n- 参数: [src_pud, addr]\n- 调用者: copy_pmd_range\n- 被调用者: []\n\n4. 函数名: pmd_addr_end\n- 参数: [addr, end]\n- 调用者: copy_pmd_range\n- 被调用者: []\n\n5. 函数名: is_swap_pmd\n- 参数: [*src_pmd]\n- 调用者: copy_pmd_range\n- 被调用者: []\n\n6. 函数名: pmd_trans_huge\n- 参数: [*src_pmd]\n- 调用者: copy_pmd_range\n- 被调用者: []\n\n7. 函数名: pmd_devmap\n- 参数: [*src_pmd]\n- 调用者: copy_pmd_range\n- 被调用者: []\n\n8. 函数名: copy_huge_pmd\n- 参数: [dst_mm, src_mm, dst_pmd, src_pmd, addr, src_vma]\n- 调用者: copy_pmd_range\n- 被调用者: []\n\n9. 函数名: pmd_none_or_clear_bad\n- 参数: [src_pmd]\n- 调用者: copy_pmd_range\n- 被调用者: []\n\n10. 函数名: copy_pte_range\n- 参数: [dst_vma, src_vma, dst_pmd, src_pmd, addr, next]\n- 调用者: copy_pmd_range\n- 被调用者: []"
    },
    {
        "id": 4247,
        "cwe": "CWE-362",
        "cve": "CVE-2023-4732",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核内存管理子系统中复制进程地址空间中的页表项(PTE)范围，处理包括正常页表项和交换页表项的复制操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在内存管理子系统中，pfn_swap_entry_to_page函数处理交换条目时存在缺陷，导致本地特权攻击者可能通过引用pmd_t x触发BUG语句造成拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: copy_pte_range\n- 参数: [struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma, pmd_t *dst_pmd, pmd_t *src_pmd, unsigned long addr, unsigned long end]\n- 调用者: N/A (顶级函数)\n- 被调用者: [pte_alloc_map_lock, pte_offset_map, pte_lockptr, spin_lock_nested, arch_enter_lazy_mmu_mode, need_resched, spin_needbreak, pte_none, pte_present, copy_nonpresent_pte, copy_present_pte, put_page, arch_leave_lazy_mmu_mode, spin_unlock, pte_unmap, add_mm_rss_vec, pte_unmap_unlock, cond_resched, add_swap_count_continuation, page_copy_prealloc]\n\n2. 函数名: pte_alloc_map_lock\n- 参数: [struct mm_struct *dst_mm, pmd_t *dst_pmd, unsigned long addr, spinlock_t **dst_ptl]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n3. 函数名: pte_offset_map\n- 参数: [pmd_t *src_pmd, unsigned long addr]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n4. 函数名: pte_lockptr\n- 参数: [struct mm_struct *src_mm, pmd_t *src_pmd]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n5. 函数名: spin_lock_nested\n- 参数: [spinlock_t *src_ptl, int SINGLE_DEPTH_NESTING]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n6. 函数名: arch_enter_lazy_mmu_mode\n- 参数: []\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n7. 函数名: need_resched\n- 参数: []\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n8. 函数名: spin_needbreak\n- 参数: [spinlock_t *src_ptl/dst_ptl]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n9. 函数名: pte_none\n- 参数: [pte_t *src_pte]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n10. 函数名: pte_present\n- 参数: [pte_t *src_pte]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n11. 函数名: copy_nonpresent_pte\n- 参数: [struct mm_struct *dst_mm, struct mm_struct *src_mm, pte_t *dst_pte, pte_t *src_pte, struct vm_area_struct *src_vma, unsigned long addr, int *rss]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n12. 函数名: copy_present_pte\n- 参数: [struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma, pte_t *dst_pte, pte_t *src_pte, unsigned long addr, int *rss, struct page **prealloc]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n13. 函数名: put_page\n- 参数: [struct page *prealloc]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n14. 函数名: arch_leave_lazy_mmu_mode\n- 参数: []\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n15. 函数名: spin_unlock\n- 参数: [spinlock_t *src_ptl]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n16. 函数名: pte_unmap\n- 参数: [pte_t *orig_src_pte]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n17. 函数名: add_mm_rss_vec\n- 参数: [struct mm_struct *dst_mm, int *rss]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n18. 函数名: pte_unmap_unlock\n- 参数: [pte_t *orig_dst_pte, spinlock_t *dst_ptl]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n19. 函数名: cond_resched\n- 参数: []\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n20. 函数名: add_swap_count_continuation\n- 参数: [swp_entry_t entry, gfp_t GFP_KERNEL]\n- 调用者: copy_pte_range\n- 被调用者: N/A\n\n21. 函数名: page_copy_prealloc\n- 参数: [struct mm_struct *src_mm, struct vm_area_struct *src_vma, unsigned long addr]\n- 调用者: copy_pte_range\n- 被调用者: N/A"
    },
    {
        "id": 4248,
        "cwe": "CWE-362",
        "cve": "CVE-2023-4732",
        "purpose": "Code purpose:\"\"\"该代码片段的核心功能是在内存管理子系统中处理页面复制操作，特别是针对可能被父进程固定的页面进行特殊处理，确保这些页面不会被随机替换。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于内存管理子系统中的pfn_swap_entry_to_page函数在处理交换条目到页面的转换时，错误地引用了pmd_t类型导致内核触发BUG语句，造成拒绝服务漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: copy_present_page\n- 参数: [dst_vma, src_vma, dst_pte, src_pte, addr, rss, prealloc, pte, page]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [page_needs_cow_for_dma, copy_user_highpage, __SetPageUptodate, page_add_new_anon_rmap, lru_cache_add_inactive_or_unevictable, mk_pte, maybe_mkwrite, pte_mkdirty, set_pte_at]\n\n2. 函数名: page_needs_cow_for_dma\n- 参数: [src_vma, page]\n- 调用者: copy_present_page\n- 被调用者: 未明确\n\n3. 函数名: copy_user_highpage\n- 参数: [new_page, page, addr, src_vma]\n- 调用者: copy_present_page\n- 被调用者: 未明确\n\n4. 函数名: __SetPageUptodate\n- 参数: [new_page]\n- 调用者: copy_present_page\n- 被调用者: 未明确\n\n5. 函数名: page_add_new_anon_rmap\n- 参数: [new_page, dst_vma, addr, false]\n- 调用者: copy_present_page\n- 被调用者: 未明确\n\n6. 函数名: lru_cache_add_inactive_or_unevictable\n- 参数: [new_page, dst_vma]\n- 调用者: copy_present_page\n- 被调用者: 未明确\n\n7. 函数名: mk_pte\n- 参数: [new_page, dst_vma->vm_page_prot]\n- 调用者: copy_present_page\n- 被调用者: 未明确\n\n8. 函数名: maybe_mkwrite\n- 参数: [pte_mkdirty(pte), dst_vma]\n- 调用者: copy_present_page\n- 被调用者: 未明确\n\n9. 函数名: pte_mkdirty\n- 参数: [pte]\n- 调用者: copy_present_page\n- 被调用者: 未明确\n\n10. 函数名: set_pte_at\n- 参数: [dst_vma->vm_mm, addr, dst_pte, pte]\n- 调用者: copy_present_page\n- 被调用者: 未明确"
    },
    {
        "id": 4302,
        "cwe": "CWE-362",
        "cve": "CVE-2023-6546",
        "purpose": "Code purpose:\"\"\"清理和释放GSM多路复用器(mux)相关的资源，包括关闭数据链路连接接口(DLCI)、停止定时器、刷新工作队列以及释放内存等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当两个线程同时执行GSMIOC_SETCONF ioctl操作时，由于缺乏适当的同步机制，导致在重启gsm mux过程中出现竞争条件，可能引发对已释放的struct gsm_dlci结构的use-after-free问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: gsm_cleanup_mux\n- 参数: [struct gsm_mux *gsm, bool disc]\n- 调用者: 未显示\n- 被调用者: [mutex_lock, gsm_dlci_begin_close, wait_event, del_timer_sync, flush_work, gsm_unregister_devices, gsm_dlci_release, mutex_unlock, tty_ldisc_flush, list_for_each_entry_safe, kfree, INIT_LIST_HEAD]\n\n2. 函数名: mutex_lock\n- 参数: [&gsm->mutex]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示\n\n3. 函数名: gsm_dlci_begin_close\n- 参数: [dlci]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示\n\n4. 函数名: wait_event\n- 参数: [gsm->event, dlci->state == DLCI_CLOSED]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示\n\n5. 函数名: del_timer_sync\n- 参数: [&gsm->kick_timer], [&gsm->t2_timer], [&gsm->ka_timer]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示\n\n6. 函数名: flush_work\n- 参数: [&gsm->tx_work]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示\n\n7. 函数名: gsm_unregister_devices\n- 参数: [gsm_tty_driver, gsm->num]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示\n\n8. 函数名: gsm_dlci_release\n- 参数: [gsm->dlci[i]]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示\n\n9. 函数名: mutex_unlock\n- 参数: [&gsm->mutex]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示\n\n10. 函数名: tty_ldisc_flush\n- 参数: [gsm->tty]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示\n\n11. 函数名: list_for_each_entry_safe\n- 参数: [txq, ntxq, &gsm->tx_ctrl_list, list], [txq, ntxq, &gsm->tx_data_list, list]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示\n\n12. 函数名: kfree\n- 参数: [txq]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示\n\n13. 函数名: INIT_LIST_HEAD\n- 参数: [&gsm->tx_ctrl_list], [&gsm->tx_data_list]\n- 调用者: gsm_cleanup_mux\n- 被调用者: 未显示"
    },
    {
        "id": 428,
        "cwe": "CWE-416",
        "cve": "CVE-2014-0100",
        "purpose": "Code purpose:\"\"\"该代码用于在网络碎片重组过程中管理碎片队列，通过哈希表查找或创建新的队列项，并处理并发访问的竞争条件\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在inet_frag_intern函数中存在竞态条件，当系统CPU负载高时，攻击者通过发送大量分片ICMP Echo请求包可能导致使用后释放错误\"\"\"",
        "functions": "Functions:\n1. 函数名: inet_frag_intern\n- 参数: [struct netns_frags *nf, struct inet_frag_queue *qp_in, struct inet_frags *f, void *arg]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [atomic_inc, mod_timer, hlist_add_head, inet_frag_put, inet_frag_lru_add, read_lock, read_unlock, spin_lock, spin_unlock, f->hashfn, f->match]\n\n2. 函数名: atomic_inc\n- 参数: [atomic_t *v]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n3. 函数名: mod_timer\n- 参数: [struct timer_list *timer, unsigned long expires]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n4. 函数名: hlist_add_head\n- 参数: [struct hlist_node *n, struct hlist_head *h]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n5. 函数名: inet_frag_put\n- 参数: [struct inet_frag_queue *q, struct inet_frags *f]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n6. 函数名: inet_frag_lru_add\n- 参数: [struct netns_frags *nf, struct inet_frag_queue *qp]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n7. 函数名: read_lock\n- 参数: [rwlock_t *lock]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n8. 函数名: read_unlock\n- 参数: [rwlock_t *lock]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n9. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n10. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n11. 函数名: f->hashfn\n- 参数: [struct inet_frag_queue *qp_in]\n- 调用者: inet_frag_intern\n- 被调用者: []\n\n12. 函数名: f->match\n- 参数: [struct inet_frag_queue *qp, void *arg]\n- 调用者: inet_frag_intern\n- 被调用者: []"
    },
    {
        "id": 431,
        "cwe": "CWE-416",
        "cve": "CVE-2014-0131",
        "purpose": "Code purpose:\"\"\"该代码用于在网络数据包分段处理时，将一个大的sk_buff结构分割成多个小的sk_buff结构，以支持网络设备的分散/聚集(Scatter/Gather)功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在skb_segment函数中处理网络数据包分段时，由于缺少对sk_buff结构的适当孤立操作，导致可能发生释放后重用(use-after-free)的情况，从而允许攻击者获取内核内存中的敏感信息。\"\"\"",
        "functions": "Functions:\n1. 函数名: skb_segment\n- 参数: [head_skb, features]\n- 调用者: N/A (top-level function)\n- 被调用者: [skb_shinfo, skb_mac_header, skb_tnl_header_len, skb_network_protocol, can_checksum_protocol, __skb_push, skb_headroom, skb_headlen, skb_clone, pskb_trim, kfree_skb, skb_end_offset, skb_cow_head, skb_release_head_state, __alloc_skb, skb_reserve, __skb_put, __copy_skb_header, skb_headers_offset_update, skb_copy_from_linear_data_offset, skb_copy_and_csum_bits, skb_put, skb_checksum, kfree_skb_list]\n\n2. 函数名: skb_shinfo\n- 参数: [skb]\n- 调用者: skb_segment\n- 被调用者: []\n\n3. 函数名: skb_mac_header\n- 参数: [skb]\n- 调用者: skb_segment\n- 被调用者: []\n\n4. 函数名: skb_tnl_header_len\n- 参数: [skb]\n- 调用者: skb_segment\n- 被调用者: []\n\n5. 函数名: skb_network_protocol\n- 参数: [skb]\n- 调用者: skb_segment\n- 被调用者: []\n\n6. 函数名: can_checksum_protocol\n- 参数: [features, proto]\n- 调用者: skb_segment\n- 被调用者: []\n\n7. 函数名: __skb_push\n- 参数: [skb, len]\n- 调用者: skb_segment\n- 被调用者: []\n\n8. 函数名: skb_headroom\n- 参数: [skb]\n- 调用者: skb_segment\n- 被调用者: []\n\n9. 函数名: skb_headlen\n- 参数: [skb]\n- 调用者: skb_segment\n- 被调用者: []\n\n10. 函数名: skb_clone\n- 参数: [skb, gfp_mask]\n- 调用者: skb_segment\n- 被调用者: []\n\n11. 函数名: pskb_trim\n- 参数: [skb, len]\n- 调用者: skb_segment\n- 被调用者: []\n\n12. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: skb_segment\n- 被调用者: []\n\n13. 函数名: skb_end_offset\n- 参数: [skb]\n- 调用者: skb_segment\n- 被调用者: []\n\n14. 函数名: skb_cow_head\n- 参数: [skb, headroom]\n- 调用者: skb_segment\n- 被调用者: []\n\n15. 函数名: skb_release_head_state\n- 参数: [skb]\n- 调用者: skb_segment\n- 被调用者: []\n\n16. 函数名: __alloc_skb\n- 参数: [size, priority, flags, node]\n- 调用者: skb_segment\n- 被调用者: []\n\n17. 函数名: skb_reserve\n- 参数: [skb, len]\n- 调用者: skb_segment\n- 被调用者: []\n\n18. 函数名: __skb_put\n- 参数: [skb, len]\n- 调用者: skb_segment\n- 被调用者: []\n\n19. 函数名: __copy_skb_header\n- 参数: [new, old]\n- 调用者: skb_segment\n- 被调用者: []\n\n20. 函数名: skb_headers_offset_update\n- 参数: [skb, offset]\n- 调用者: skb_segment\n- 被调用者: []\n\n21. 函数名: skb_copy_from_linear_data_offset\n- 参数: [skb, offset, to, len]\n- 调用者: skb_segment\n- 被调用者: []\n\n22. 函数名: skb_copy_and_csum_bits\n- 参数: [skb, offset, to, len, csum]\n- 调用者: skb_segment\n- 被调用者: []\n\n23. 函数名: skb_put\n- 参数: [skb, len]\n- 调用者: skb_segment\n- 被调用者: []\n\n24. 函数名: skb_checksum\n- 参数: [skb, offset, len, csum]\n- 调用者: skb_segment\n- 被调用者: []\n\n25. 函数名: kfree_skb_list\n- 参数: [segs]\n- 调用者: skb_segment\n- 被调用者: []"
    },
    {
        "id": 462,
        "cwe": "CWE-416",
        "cve": "CVE-2014-0203",
        "purpose": "Code purpose:\"\"\"该代码用于在内核中处理符号链接的跟随操作，确保正确解析路径并访问目标文件。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在2.6.33版本前的__do_follow_link函数中，对某些文件系统最后一个路径组件的处理不当，导致本地用户可通过open系统调用触发错误的释放操作和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: __do_follow_link\n- 参数: [struct path *path, struct nameidata *nd]\n- 调用者: 未明确（通常是内核中的路径查找相关函数）\n- 被调用者: [touch_atime, nd_set_link, path_to_nameidata, dget, mntget, PTR_ERR, IS_ERR, nd_get_link, __vfs_follow_link, force_reval_path, path_put]\n\n2. 函数名: touch_atime\n- 参数: [struct vfsmount *mnt, struct dentry *dentry]\n- 调用者: __do_follow_link\n- 被调用者: []\n\n3. 函数名: nd_set_link\n- 参数: [struct nameidata *nd, void *ptr]\n- 调用者: __do_follow_link\n- 被调用者: []\n\n4. 函数名: path_to_nameidata\n- 参数: [struct path *path, struct nameidata *nd]\n- 调用者: __do_follow_link\n- 被调用者: []\n\n5. 函数名: dget\n- 参数: [struct dentry *dentry]\n- 调用者: __do_follow_link\n- 被调用者: []\n\n6. 函数名: mntget\n- 参数: [struct vfsmount *mnt]\n- 调用者: __do_follow_link\n- 被调用者: []\n\n7. 函数名: PTR_ERR\n- 参数: [void *ptr]\n- 调用者: __do_follow_link\n- 被调用者: []\n\n8. 函数名: IS_ERR\n- 参数: [void *ptr]\n- 调用者: __do_follow_link\n- 被调用者: []\n\n9. 函数名: nd_get_link\n- 参数: [struct nameidata *nd]\n- 调用者: __do_follow_link\n- 被调用者: []\n\n10. 函数名: __vfs_follow_link\n- 参数: [struct nameidata *nd, char *name]\n- 调用者: __do_follow_link\n- 被调用者: []\n\n11. 函数名: force_reval_path\n- 参数: [struct path *path, struct nameidata *nd]\n- 调用者: __do_follow_link\n- 被调用者: []\n\n12. 函数名: path_put\n- 参数: [struct path *path]\n- 调用者: __do_follow_link\n- 被调用者: []"
    },
    {
        "id": 463,
        "cwe": "CWE-416",
        "cve": "CVE-2014-0203",
        "purpose": "Code purpose:\"\"\"处理/proc文件系统中进程ID符号链接的跟随操作，并检查文件描述符访问权限\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核在处理某些文件系统的最后一个路径组件时未正确释放资源，导致可被本地用户利用造成系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: proc_pid_follow_link\n- 参数: [dentry, nd]\n- 调用者: 未指定（由内核调用）\n- 被调用者: [path_put, proc_fd_access_allowed, PROC_I, ERR_PTR]\n\n2. 函数名: path_put\n- 参数: [&nd->path]\n- 调用者: proc_pid_follow_link\n- 被调用者: []\n\n3. 函数名: proc_fd_access_allowed\n- 参数: [inode]\n- 调用者: proc_pid_follow_link\n- 被调用者: []\n\n4. 函数名: PROC_I\n- 参数: [inode]\n- 调用者: proc_pid_follow_link\n- 被调用者: []\n\n5. 函数名: ERR_PTR\n- 参数: [error]\n- 调用者: proc_pid_follow_link\n- 被调用者: []"
    },
    {
        "id": 484,
        "cwe": "CWE-416",
        "cve": "CVE-2014-2568",
        "purpose": "Code purpose:\"\"\"构建并发送包含网络数据包信息的Netlink消息，用于内核与用户空间之间的通信\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核在skb_zerocopy操作中未正确执行内存引用计数管理，导致释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nfqnl_build_packet_message\n- 参数: [net, queue, entry, packet_id_ptr]\n- 调用者: 未显示\n- 被调用者: [nlmsg_total_size, nla_total_size, skb_csum_unnecessary, ACCESS_ONCE, skb_checksum_help, skb_zerocopy_headlen, min_t, nfqnl_ct_get, nfnetlink_alloc_skb, nlmsg_put, kfree_skb, nlmsg_data, __nla_reserve, nla_data, nla_put_be32, br_port_get_rcu, dev_parse_header, ktime_to_timeval, nfqnl_put_sk_uidgid, nfqnl_ct_put, nfqnl_put_packet_info, skb_tailroom, skb_put, skb_zerocopy]\n\n2. 函数名: nlmsg_total_size\n- 参数: [size]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n3. 函数名: nla_total_size\n- 参数: [size]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n4. 函数名: skb_csum_unnecessary\n- 参数: [entskb]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n5. 函数名: ACCESS_ONCE\n- 参数: [queue->copy_mode]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n6. 函数名: skb_checksum_help\n- 参数: [entskb]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n7. 函数名: skb_zerocopy_headlen\n- 参数: [entskb]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n8. 函数名: min_t\n- 参数: [unsigned int, hlen, data_len]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n9. 函数名: nfqnl_ct_get\n- 参数: [entskb, &size, &ctinfo]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n10. 函数名: nfnetlink_alloc_skb\n- 参数: [net, size, queue->peer_portid, GFP_ATOMIC]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n11. 函数名: nlmsg_put\n- 参数: [skb, 0, 0, NFNL_SUBSYS_QUEUE << 8 | NFQNL_MSG_PACKET, sizeof(struct nfgenmsg), 0]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n12. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n13. 函数名: nlmsg_data\n- 参数: [nlh]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n14. 函数名: __nla_reserve\n- 参数: [skb, NFQA_PACKET_HDR, sizeof(*pmsg)]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n15. 函数名: nla_data\n- 参数: [nla]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n16. 函数名: nla_put_be32\n- 参数: [skb, NFQA_IFINDEX_INDEV, htonl(indev->ifindex)]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n17. 函数名: br_port_get_rcu\n- 参数: [indev]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n18. 函数名: dev_parse_header\n- 参数: [entskb, phw.hw_addr]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n19. 函数名: ktime_to_timeval\n- 参数: [entskb->tstamp]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n20. 函数名: nfqnl_put_sk_uidgid\n- 参数: [skb, entskb->sk]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n21. 函数名: nfqnl_ct_put\n- 参数: [skb, ct, ctinfo]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n22. 函数名: nfqnl_put_packet_info\n- 参数: [skb, entskb, csum_verify]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n23. 函数名: skb_tailroom\n- 参数: [skb]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n24. 函数名: skb_put\n- 参数: [skb, sizeof(*nla)]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []\n\n25. 函数名: skb_zerocopy\n- 参数: [skb, entskb, data_len, hlen]\n- 调用者: nfqnl_build_packet_message\n- 被调用者: []"
    },
    {
        "id": 485,
        "cwe": "CWE-416",
        "cve": "CVE-2014-2568",
        "purpose": "Code purpose:\"\"\"将网络数据包从内核空间通过Netlink套接字安全地传递到用户空间，同时处理VLAN标签、校验和以及内存对齐等网络数据包特性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核在skb_zerocopy操作中未正确处理skb缓冲区的引用计数，导致释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: queue_userspace_packet\n- 参数: [dp, skb, upcall_info]\n- 调用者: N/A (顶层函数)\n- 被调用者: [get_dpifindex, skb_clone, __vlan_put_tag, vlan_tx_tag_present, vlan_tx_tag_get, nla_attr_size, skb_checksum_help, skb_zerocopy_headlen, upcall_msg_size, genlmsg_new_unicast, genlmsg_put, nla_nest_start, ovs_nla_put_flow, nla_nest_end, __nla_put, nla_reserve, skb_zerocopy, skb_put, genlmsg_unicast, kfree_skb]\n\n2. 函数名: get_dpifindex\n- 参数: [dp]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n3. 函数名: skb_clone\n- 参数: [skb, GFP_ATOMIC]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n4. 函数名: __vlan_put_tag\n- 参数: [nskb, nskb->vlan_proto, vlan_tx_tag_get(nskb)]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n5. 函数名: vlan_tx_tag_present\n- 参数: [skb]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n6. 函数名: vlan_tx_tag_get\n- 参数: [nskb]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n7. 函数名: nla_attr_size\n- 参数: [skb->len]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n8. 函数名: skb_checksum_help\n- 参数: [skb]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n9. 函数名: skb_zerocopy_headlen\n- 参数: [skb]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n10. 函数名: upcall_msg_size\n- 参数: [upcall_info->userdata, hlen]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n11. 函数名: genlmsg_new_unicast\n- 参数: [len, &info, GFP_ATOMIC]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n12. 函数名: genlmsg_put\n- 参数: [user_skb, 0, 0, &dp_packet_genl_family, 0, upcall_info->cmd]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n13. 函数名: nla_nest_start\n- 参数: [user_skb, OVS_PACKET_ATTR_KEY]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n14. 函数名: ovs_nla_put_flow\n- 参数: [upcall_info->key, upcall_info->key, user_skb]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n15. 函数名: nla_nest_end\n- 参数: [user_skb, nla]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n16. 函数名: __nla_put\n- 参数: [user_skb, OVS_PACKET_ATTR_USERDATA, nla_len(upcall_info->userdata), nla_data(upcall_info->userdata)]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n17. 函数名: nla_reserve\n- 参数: [user_skb, OVS_PACKET_ATTR_PACKET, 0]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n18. 函数名: skb_zerocopy\n- 参数: [user_skb, skb, skb->len, hlen]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n19. 函数名: skb_put\n- 参数: [user_skb, plen]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n20. 函数名: genlmsg_unicast\n- 参数: [ovs_dp_get_net(dp), user_skb, upcall_info->portid]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n21. 函数名: kfree_skb\n- 参数: [nskb]\n- 调用者: queue_userspace_packet\n- 被调用者: []\n\n22. 函数名: ovs_dp_get_net\n- 参数: [dp]\n- 调用者: queue_userspace_packet\n- 被调用者: []"
    },
    {
        "id": 498,
        "cwe": "CWE-416",
        "cve": "CVE-2014-2851",
        "purpose": "Code purpose:\"\"\"该代码用于检查当前进程的有效组ID是否在允许的ping组范围内，以决定是否允许初始化ping套接字。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确处理组信息块的引用计数管理，导致整数溢出可能引发引用计数错误，从而造成释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ping_init_sock\n- 参数: [struct sock *sk]\n- 调用者: N/A\n- 被调用者: [sock_net, current_egid, get_current_groups, inet_get_ping_group_range_net, gid_lte, min_t]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: ping_init_sock\n- 被调用者: N/A\n\n3. 函数名: current_egid\n- 参数: []\n- 调用者: ping_init_sock\n- 被调用者: N/A\n\n4. 函数名: get_current_groups\n- 参数: []\n- 调用者: ping_init_sock\n- 被调用者: N/A\n\n5. 函数名: inet_get_ping_group_range_net\n- 参数: [struct net *net, kgid_t *low, kgid_t *high]\n- 调用者: ping_init_sock\n- 被调用者: N/A\n\n6. 函数名: gid_lte\n- 参数: [kgid_t left, kgid_t right]\n- 调用者: ping_init_sock\n- 被调用者: N/A\n\n7. 函数名: min_t\n- 参数: [int type, int a, int b]\n- 调用者: ping_init_sock\n- 被调用者: N/A"
    },
    {
        "id": 567,
        "cwe": "CWE-416",
        "cve": "CVE-2014-4653",
        "purpose": "Code purpose:\"\"\"该代码用于向声卡控制链表中添加新的控制元素，并处理相关的通知和错误检查。\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放读写锁后未正确保护控制元素的内存访问，导致可能发生use-after-free情况\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_ctl_add\n- 参数: [struct snd_card *card, struct snd_kcontrol *kcontrol]\n- 调用者: N/A (顶层函数)\n- 被调用者: [snd_BUG_ON, snd_ctl_find_id, dev_err, snd_ctl_find_hole, list_add_tail, snd_ctl_notify, snd_ctl_free_one]\n\n2. 函数名: snd_BUG_ON\n- 参数: [condition]\n- 调用者: snd_ctl_add\n- 被调用者: N/A\n\n3. 函数名: snd_ctl_find_id\n- 参数: [struct snd_card *card, struct snd_ctl_elem_id *id]\n- 调用者: snd_ctl_add\n- 被调用者: N/A\n\n4. 函数名: dev_err\n- 参数: [struct device *dev, const char *fmt, ...]\n- 调用者: snd_ctl_add\n- 被调用者: N/A\n\n5. 函数名: snd_ctl_find_hole\n- 参数: [struct snd_card *card, unsigned int count]\n- 调用者: snd_ctl_add\n- 被调用者: N/A\n\n6. 函数名: list_add_tail\n- 参数: [struct list_head *new, struct list_head *head]\n- 调用者: snd_ctl_add\n- 被调用者: N/A\n\n7. 函数名: snd_ctl_notify\n- 参数: [struct snd_card *card, int mask, struct snd_ctl_elem_id *id]\n- 调用者: snd_ctl_add\n- 被调用者: N/A\n\n8. 函数名: snd_ctl_free_one\n- 参数: [struct snd_kcontrol *kcontrol]\n- 调用者: snd_ctl_add\n- 被调用者: N/A"
    },
    {
        "id": 568,
        "cwe": "CWE-416",
        "cve": "CVE-2014-4653",
        "purpose": "Code purpose:\"\"\"该代码实现了ALSA控制接口中TLV(Tagged List Value)数据的读写操作，包括权限检查、内存拷贝和回调处理等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核ALSA控制实现中未正确持有读写锁，导致存在竞争条件可能引发释放后重用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_ctl_tlv_ioctl\n- 参数: [struct snd_ctl_file *file, struct snd_ctl_tlv __user *_tlv, int op_flag]\n- 调用者: 未指定（由系统调用触发）\n- 被调用者: [copy_from_user, down_read, snd_ctl_find_numid, up_read, snd_ctl_notify, copy_to_user]\n\n2. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: snd_ctl_tlv_ioctl\n- 被调用者: []\n\n3. 函数名: down_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: snd_ctl_tlv_ioctl\n- 被调用者: []\n\n4. 函数名: snd_ctl_find_numid\n- 参数: [struct snd_card *card, int numid]\n- 调用者: snd_ctl_tlv_ioctl\n- 被调用者: []\n\n5. 函数名: up_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: snd_ctl_tlv_ioctl\n- 被调用者: []\n\n6. 函数名: snd_ctl_notify\n- 参数: [struct snd_card *card, int mask, struct snd_ctl_elem_id *id]\n- 调用者: snd_ctl_tlv_ioctl\n- 被调用者: []\n\n7. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: snd_ctl_tlv_ioctl\n- 被调用者: []"
    },
    {
        "id": 569,
        "cwe": "CWE-416",
        "cve": "CVE-2014-4653",
        "purpose": "Code purpose:\"\"\"该代码实现了ALSA控制接口中元素写入功能，包括查找控制元素、验证写入权限并执行写入操作，同时处理相关通知事件。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在释放读锁后仍可能访问已被释放的内存，导致存在use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_ctl_elem_write\n- 参数: [struct snd_card *card, struct snd_ctl_file *file, struct snd_ctl_elem_value *control]\n- 调用者: N/A\n- 被调用者: [down_read, snd_ctl_find_id, snd_ctl_get_ioff, snd_ctl_build_ioff, kctl->put, up_read, snd_ctl_notify]\n\n2. 函数名: snd_ctl_find_id\n- 参数: [struct snd_card *card, &control->id]\n- 调用者: snd_ctl_elem_write\n- 被调用者: N/A\n\n3. 函数名: snd_ctl_get_ioff\n- 参数: [kctl, &control->id]\n- 调用者: snd_ctl_elem_write\n- 被调用者: N/A\n\n4. 函数名: snd_ctl_build_ioff\n- 参数: [&control->id, kctl, index_offset]\n- 调用者: snd_ctl_elem_write\n- 被调用者: N/A\n\n5. 函数名: down_read\n- 参数: [&card->controls_rwsem]\n- 调用者: snd_ctl_elem_write\n- 被调用者: N/A\n\n6. 函数名: up_read\n- 参数: [&card->controls_rwsem]\n- 调用者: snd_ctl_elem_write\n- 被调用者: N/A\n\n7. 函数名: snd_ctl_notify\n- 参数: [card, SNDRV_CTL_EVENT_MASK_VALUE, &control->id]\n- 调用者: snd_ctl_elem_write\n- 被调用者: N/A\n\n8. 函数名: kctl->put\n- 参数: [kctl, control]\n- 调用者: snd_ctl_elem_write\n- 被调用者: N/A"
    },
    {
        "id": 570,
        "cwe": "CWE-416",
        "cve": "CVE-2014-4653",
        "purpose": "Code purpose:\"\"\"该代码用于替换或添加ALSA声卡控制元素，管理控制列表并处理相关通知事件\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在snd_ctl_replace函数中，当执行snd_ctl_remove操作后未重新获取锁就直接跳转到add标签继续操作，导致潜在的竞争条件和use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_ctl_replace\n- 参数: [struct snd_card *card, struct snd_kcontrol *kcontrol, bool add_on_replace]\n- 调用者: N/A (top-level function)\n- 被调用者: [snd_ctl_find_id, snd_ctl_remove, snd_ctl_find_hole, list_add_tail, snd_ctl_notify, snd_ctl_free_one]\n\n2. 函数名: snd_ctl_find_id\n- 参数: [struct snd_card *card, struct snd_ctl_elem_id *id]\n- 调用者: snd_ctl_replace\n- 被调用者: []\n\n3. 函数名: snd_ctl_remove\n- 参数: [struct snd_card *card, struct snd_kcontrol *old]\n- 调用者: snd_ctl_replace\n- 被调用者: []\n\n4. 函数名: snd_ctl_find_hole\n- 参数: [struct snd_card *card, int count]\n- 调用者: snd_ctl_replace\n- 被调用者: []\n\n5. 函数名: list_add_tail\n- 参数: [struct list_head *list, struct list_head *head]\n- 调用者: snd_ctl_replace\n- 被调用者: []\n\n6. 函数名: snd_ctl_notify\n- 参数: [struct snd_card *card, int mask, struct snd_ctl_elem_id *id]\n- 调用者: snd_ctl_replace\n- 被调用者: []\n\n7. 函数名: snd_ctl_free_one\n- 参数: [struct snd_kcontrol *kcontrol]\n- 调用者: snd_ctl_replace\n- 被调用者: []"
    },
    {
        "id": 571,
        "cwe": "CWE-416",
        "cve": "CVE-2014-4654",
        "purpose": "Code purpose:\"\"\"该代码实现了ALSA控制接口中元素的添加和替换功能，允许用户空间通过ioctl调用管理音频控制元素\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于snd_ctl_elem_add函数在执行SNDRV_CTL_IOCTL_ELEM_REPLACE操作时未进行适当的权限检查，导致本地用户可通过/dev/snd/controlCX设备文件进行未授权的内核控制移除，从而引发拒绝服务。\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_ctl_elem_add\n- 参数: [struct snd_ctl_file *file, struct snd_ctl_elem_info *info, int replace]\n- 调用者: 外部调用（通过ioctl）\n- 被调用者: [snd_ctl_find_id, snd_ctl_remove, snd_ctl_elem_user_enum_info, snd_ctl_elem_user_info, snd_ctl_elem_user_get, snd_ctl_elem_user_put, snd_ctl_elem_user_tlv, snd_ctl_elem_init_enum_names, snd_ctl_new, snd_ctl_add, snd_ctl_elem_user_free, kzalloc, kfree, memset, memcpy, down_write, up_write]\n\n2. 函数名: snd_ctl_find_id\n- 参数: [struct snd_card *card, struct snd_ctl_elem_id *id]\n- 调用者: snd_ctl_elem_add\n- 被调用者: []\n\n3. 函数名: snd_ctl_remove\n- 参数: [struct snd_card *card, struct snd_kcontrol *kcontrol]\n- 调用者: snd_ctl_elem_add\n- 被调用者: []\n\n4. 函数名: snd_ctl_elem_user_enum_info\n- 参数: [struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo]\n- 调用者: snd_ctl_elem_add\n- 被调用者: []\n\n5. 函数名: snd_ctl_elem_user_info\n- 参数: [struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo]\n- 调用者: snd_ctl_elem_add\n- 被调用者: []\n\n6. 函数名: snd_ctl_elem_user_get\n- 参数: [struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol]\n- 调用者: snd_ctl_elem_add\n- 被调用者: []\n\n7. 函数名: snd_ctl_elem_user_put\n- 参数: [struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol]\n- 调用者: snd_ctl_elem_add\n- 被调用者: []\n\n8. 函数名: snd_ctl_elem_user_tlv\n- 参数: [struct snd_kcontrol *kcontrol, int op_flag, unsigned int size, unsigned int __user *tlv]\n- 调用者: snd_ctl_elem_add\n- 被调用者: []\n\n9. 函数名: snd_ctl_elem_init_enum_names\n- 参数: [struct user_element *ue]\n- 调用者: snd_ctl_elem_add\n- 被调用者: []\n\n10. 函数名: snd_ctl_new\n- 参数: [struct snd_kcontrol *kcontrol, unsigned int access]\n- 调用者: snd_ctl_elem_add\n- 被调用者: []\n\n11. 函数名: snd_ctl_add\n- 参数: [struct snd_card *card, struct snd_kcontrol *kcontrol]\n- 调用者: snd_ctl_elem_add\n- 被调用者: []\n\n12. 函数名: snd_ctl_elem_user_free\n- 参数: [struct snd_kcontrol *kcontrol]\n- 调用者: snd_ctl_elem_add\n- 被调用者: []"
    },
    {
        "id": 711,
        "cwe": "CWE-416",
        "cve": "CVE-2014-9914",
        "purpose": "Code purpose:\"\"\"该代码用于在IPv4 UDP套接字释放时处理路由缓存更新，确保数据包能正确路由到目标地址\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在多线程访问IPv4 UDP套接字的内部数据结构时，由于锁定机制不当导致的竞态条件，可能引发释放后重用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: ip4_datagram_release_cb\n- 参数: [struct sock *sk]\n- 调用者: 未显示\n- 被调用者: [inet_sk, __sk_dst_get, __sk_dst_check, rcu_read_lock, rcu_dereference, ip_route_output_ports, sock_net, IS_ERR, __sk_dst_set, rcu_read_unlock]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: 未显示\n\n3. 函数名: __sk_dst_get\n- 参数: [struct sock *sk]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: 未显示\n\n4. 函数名: __sk_dst_check\n- 参数: [struct sock *sk, 0]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: 未显示\n\n5. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: ip4_datagram_release_cb\n- 被调用者: 未显示\n\n6. 函数名: rcu_dereference\n- 参数: [inet->inet_opt]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: 未显示\n\n7. 函数名: ip_route_output_ports\n- 参数: [sock_net(sk), &fl4, sk, daddr, inet->inet_saddr, inet->inet_dport, inet->inet_sport, sk->sk_protocol, RT_CONN_FLAGS(sk), sk->sk_bound_dev_if]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: 未显示\n\n8. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: 未显示\n\n9. 函数名: IS_ERR\n- 参数: [rt]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: 未显示\n\n10. 函数名: __sk_dst_set\n- 参数: [sk, &rt->dst]\n- 调用者: ip4_datagram_release_cb\n- 被调用者: 未显示\n\n11. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: ip4_datagram_release_cb\n- 被调用者: 未显示"
    },
    {
        "id": 714,
        "cwe": "CWE-416",
        "cve": "CVE-2014-9940",
        "purpose": "Code purpose:\"\"\"释放与调节器使能GPIO相关的资源，包括减少引用计数或在引用计数为1时释放GPIO和内存资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放GPIO资源时未正确处理引用计数，导致可能发生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: regulator_ena_gpio_free\n- 参数: [struct regulator_dev *rdev]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [gpiod_put, list_del, kfree]\n\n2. 函数名: gpiod_put\n- 参数: [struct gpio_desc *gpiod]\n- 调用者: regulator_ena_gpio_free\n- 被调用者: 未明确\n\n3. 函数名: list_del\n- 参数: [struct list_head *entry]\n- 调用者: regulator_ena_gpio_free\n- 被调用者: 未明确\n\n4. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: regulator_ena_gpio_free\n- 被调用者: 未明确"
    },
    {
        "id": 778,
        "cwe": "CWE-416",
        "cve": "CVE-2015-5706",
        "purpose": "Code purpose:\"\"\"处理文件路径打开操作，包括临时文件创建、路径解析和符号链接跟踪等功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在path_openat函数中处理O_TMPFILE文件时存在双重清理操作，导致释放后重用(use-after-free)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: path_openat\n- 参数: [dfd, pathname, nd, op, flags]\n- 调用者: 未显示\n- 被调用者: [get_empty_filp, do_tmpfile, path_init, do_last, may_follow_link, follow_link, put_link, path_cleanup, put_filp, ERR_PTR]\n\n2. 函数名: get_empty_filp\n- 参数: []\n- 调用者: path_openat\n- 被调用者: 未显示\n\n3. 函数名: do_tmpfile\n- 参数: [dfd, pathname, nd, flags, op, file, opened]\n- 调用者: path_openat\n- 被调用者: 未显示\n\n4. 函数名: path_init\n- 参数: [dfd, pathname, flags, nd]\n- 调用者: path_openat\n- 被调用者: 未显示\n\n5. 函数名: do_last\n- 参数: [nd, path, file, op, opened, pathname]\n- 调用者: path_openat\n- 被调用者: 未显示\n\n6. 函数名: may_follow_link\n- 参数: [link, nd]\n- 调用者: path_openat\n- 被调用者: 未显示\n\n7. 函数名: follow_link\n- 参数: [link, nd, cookie]\n- 调用者: path_openat\n- 被调用者: 未显示\n\n8. 函数名: put_link\n- 参数: [nd, link, cookie]\n- 调用者: path_openat\n- 被调用者: 未显示\n\n9. 函数名: path_cleanup\n- 参数: [nd]\n- 调用者: path_openat\n- 被调用者: 未显示\n\n10. 函数名: put_filp\n- 参数: [file]\n- 调用者: path_openat\n- 被调用者: 未显示\n\n11. 函数名: ERR_PTR\n- 参数: [error]\n- 调用者: path_openat\n- 被调用者: 未显示\n\n12. 函数名: path_put_conditional\n- 参数: [path, nd]\n- 调用者: path_openat\n- 被调用者: 未显示\n\n13. 函数名: path_put\n- 参数: [nd->path]\n- 调用者: path_openat\n- 被调用者: 未显示"
    },
    {
        "id": 869,
        "cwe": "CWE-416",
        "cve": "CVE-2015-8961",
        "purpose": "Code purpose:\"\"\"该代码用于处理ext4文件系统日志事务的停止操作，包括错误处理和资源释放\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在__ext4_journal_stop函数中，对handle->h_err错误字段的访问存在竞争条件，可能导致释放后使用(use-after-free)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: __ext4_journal_stop\n- 参数: [where, line, handle]\n- 调用者: 未明确（外部调用）\n- 被调用者: [ext4_handle_valid, ext4_put_nojournal, jbd2_journal_stop, __ext4_std_error]\n\n2. 函数名: ext4_handle_valid\n- 参数: [handle]\n- 调用者: __ext4_journal_stop\n- 被调用者: 未明确\n\n3. 函数名: ext4_put_nojournal\n- 参数: [handle]\n- 调用者: __ext4_journal_stop\n- 被调用者: 未明确\n\n4. 函数名: jbd2_journal_stop\n- 参数: [handle]\n- 调用者: __ext4_journal_stop\n- 被调用者: 未明确\n\n5. 函数名: __ext4_std_error\n- 参数: [sb, where, line, err]\n- 调用者: __ext4_journal_stop\n- 被调用者: 未明确"
    },
    {
        "id": 871,
        "cwe": "CWE-416",
        "cve": "CVE-2015-8963",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中为性能监控事件添加软件事件处理，涉及CPU热插拔时的竞态条件处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在CPU热拔插操作期间，由于对swevent数据结构的错误处理导致竞态条件，可能引发释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: perf_swevent_add\n- 参数: [struct perf_event *event, int flags]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [this_cpu_ptr, is_sampling_event, perf_swevent_set_period, find_swevent_head, WARN_ON_ONCE, hlist_add_head_rcu, perf_event_update_userpage]\n\n2. 函数名: this_cpu_ptr\n- 参数: [&swevent_htable]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n3. 函数名: is_sampling_event\n- 参数: [struct perf_event *event]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n4. 函数名: perf_swevent_set_period\n- 参数: [struct perf_event *event]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n5. 函数名: find_swevent_head\n- 参数: [struct swevent_htable *swhash, struct perf_event *event]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n6. 函数名: WARN_ON_ONCE\n- 参数: [swhash->online]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n7. 函数名: hlist_add_head_rcu\n- 参数: [&event->hlist_entry, head]\n- 调用者: perf_swevent_add\n- 被调用者: []\n\n8. 函数名: perf_event_update_userpage\n- 参数: [struct perf_event *event]\n- 调用者: perf_swevent_add\n- 被调用者: []"
    },
    {
        "id": 872,
        "cwe": "CWE-416",
        "cve": "CVE-2015-8963",
        "purpose": "Code purpose:\"\"\"初始化指定CPU的性能事件监控数据结构，并在有引用时分配新的监控链表\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在CPU热插拔操作期间，由于对swevent数据结构的竞争条件处理不当，导致可能发生释放后重用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: perf_event_init_cpu\n- 参数: [cpu]\n- 调用者: 未显示（由系统CPU热插拔操作触发）\n- 被调用者: [mutex_lock, kzalloc_node, WARN_ON, rcu_assign_pointer, mutex_unlock, cpu_to_node]\n\n2. 函数名: mutex_lock\n- 参数: [&swhash->hlist_mutex]\n- 调用者: perf_event_init_cpu\n- 被调用者: []\n\n3. 函数名: kzalloc_node\n- 参数: [sizeof(*hlist), GFP_KERNEL, cpu_to_node(cpu)]\n- 调用者: perf_event_init_cpu\n- 被调用者: []\n\n4. 函数名: WARN_ON\n- 参数: [!hlist]\n- 调用者: perf_event_init_cpu\n- 被调用者: []\n\n5. 函数名: rcu_assign_pointer\n- 参数: [swhash->swevent_hlist, hlist]\n- 调用者: perf_event_init_cpu\n- 被调用者: []\n\n6. 函数名: mutex_unlock\n- 参数: [&swhash->hlist_mutex]\n- 调用者: perf_event_init_cpu\n- 被调用者: []\n\n7. 函数名: cpu_to_node\n- 参数: [cpu]\n- 调用者: perf_event_init_cpu\n- 被调用者: []"
    },
    {
        "id": 873,
        "cwe": "CWE-416",
        "cve": "CVE-2015-8963",
        "purpose": "Code purpose:\"\"\"该代码用于在多核环境下安全地获取和引用特定CPU上的软件事件哈希表，并在需要时分配新的哈希表结构。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在CPU热拔插操作期间，由于对swevent数据结构的处理不当，导致存在竞态条件可能引发释放后重用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: swevent_hlist_get_cpu\n- 参数: [struct perf_event *event, int cpu]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [swevent_hlist_deref, cpu_online, kzalloc, rcu_assign_pointer, mutex_lock, mutex_unlock]\n\n2. 函数名: swevent_hlist_deref\n- 参数: [struct swevent_htable *swhash]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: []\n\n3. 函数名: cpu_online\n- 参数: [int cpu]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: []\n\n4. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: []\n\n5. 函数名: rcu_assign_pointer\n- 参数: [pointer, value]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: []\n\n6. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: []\n\n7. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: swevent_hlist_get_cpu\n- 被调用者: []"
    },
    {
        "id": 893,
        "cwe": "CWE-416",
        "cve": "CVE-2016-10088",
        "purpose": "Code purpose:\"\"\"处理来自用户空间的写入请求，将数据通过BSG(Block SCSI Generic)接口写入设备，并返回写入的字节数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中的sg实现未正确限制KERNEL_DS选项设置时的写操作，导致本地用户可通过访问/dev/sg设备任意读写内核内存或引发拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: bsg_write\n- 参数: [struct file *file, const char __user *buf, size_t count, loff_t *ppos]\n- 调用者: 未指定（由文件操作结构调用）\n- 被调用者: [dprintk, bsg_set_block, __bsg_write, err_block_err]\n\n2. 函数名: dprintk\n- 参数: [const char *fmt, ...]（变参函数）\n- 调用者: [bsg_write]\n- 被调用者: []\n\n3. 函数名: bsg_set_block\n- 参数: [struct bsg_device *bd, struct file *file]\n- 调用者: [bsg_write]\n- 被调用者: []\n\n4. 函数名: __bsg_write\n- 参数: [struct bsg_device *bd, const char __user *buf, size_t count, ssize_t *bytes_written, int write_mode]\n- 调用者: [bsg_write]\n- 被调用者: []\n\n5. 函数名: err_block_err\n- 参数: [int ret]\n- 调用者: [bsg_write]\n- 被调用者: []"
    },
    {
        "id": 894,
        "cwe": "CWE-416",
        "cve": "CVE-2016-10088",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中SCSI通用设备(/dev/sg)的写操作处理功能，包括命令解析、数据传输方向控制和请求处理等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中的sg实现未正确限制KERNEL_DS选项设置时的写操作，导致本地用户可通过访问/dev/sg设备读写任意内核内存或引发释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: sg_write\n- 参数: [struct file *filp, const char __user *buf, size_t count, loff_t *ppos]\n- 调用者: 文件系统调用\n- 被调用者: [sg_printk, scsi_block_when_processing_errors, access_ok, __copy_from_user, sg_new_write, sg_add_request, __get_user, sg_remove_request, sg_common_write, strcmp, strcpy, printk_ratelimited]\n\n2. 函数名: sg_printk\n- 参数: [int log_level, Sg_device *sdp, const char *fmt, ...]\n- 调用者: sg_write\n- 被调用者: []\n\n3. 函数名: scsi_block_when_processing_errors\n- 参数: [struct scsi_device *sdev]\n- 调用者: sg_write\n- 被调用者: []\n\n4. 函数名: access_ok\n- 参数: [int type, const void __user *addr, unsigned long size]\n- 调用者: sg_write\n- 被调用者: []\n\n5. 函数名: __copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: sg_write\n- 被调用者: []\n\n6. 函数名: sg_new_write\n- 参数: [Sg_fd *sfp, struct file *filp, const char __user *buf, size_t count, int blocking, int read_only, int force_packid, sg_io_hdr_t *hp]\n- 调用者: sg_write\n- 被调用者: []\n\n7. 函数名: sg_add_request\n- 参数: [Sg_fd *sfp]\n- 调用者: sg_write\n- 被调用者: []\n\n8. 函数名: __get_user\n- 参数: [type x, const type __user *ptr]\n- 调用者: sg_write\n- 被调用者: []\n\n9. 函数名: sg_remove_request\n- 参数: [Sg_fd *sfp, Sg_request *srp]\n- 调用者: sg_write\n- 被调用者: []\n\n10. 函数名: sg_common_write\n- 参数: [Sg_fd *sfp, Sg_request *srp, unsigned char *cmnd, int timeout, int blocking]\n- 调用者: sg_write\n- 被调用者: []\n\n11. 函数名: strcmp\n- 参数: [const char *s1, const char *s2]\n- 调用者: sg_write\n- 被调用者: []\n\n12. 函数名: strcpy\n- 参数: [char *dest, const char *src]\n- 调用者: sg_write\n- 被调用者: []\n\n13. 函数名: printk_ratelimited\n- 参数: [const char *fmt, ...]\n- 调用者: sg_write\n- 被调用者: []"
    },
    {
        "id": 898,
        "cwe": "CWE-416",
        "cve": "CVE-2016-10200",
        "purpose": "Code purpose:\"\"\"实现L2TPv3 IP封装功能中的socket绑定操作，包括地址验证、状态检查和绑定表管理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在检查SOCK_ZAPPED状态和实际绑定操作之间存在竞争条件，导致多个bind系统调用可能绕过状态检查，引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: l2tp_ip_bind\n- 参数: [struct sock *sk, struct sockaddr *uaddr, int addr_len]\n- 调用者: 未显示（应为系统调用或内核其他模块）\n- 被调用者: [inet_sk, sock_net, sock_flag, __l2tp_ip_bind_lookup, read_lock_bh, read_unlock_bh, lock_sock, inet_addr_type, sk_dst_reset, l2tp_ip_sk, write_lock_bh, sk_add_bind_node, sk_del_node_init, write_unlock_bh, sock_reset_flag, release_sock]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n3. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n4. 函数名: sock_flag\n- 参数: [struct sock *sk, SOCK_ZAPPED]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n5. 函数名: __l2tp_ip_bind_lookup\n- 参数: [struct net *net, addr->l2tp_addr.s_addr, sk->sk_bound_dev_if, addr->l2tp_conn_id]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n6. 函数名: read_lock_bh\n- 参数: [&l2tp_ip_lock]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n7. 函数名: read_unlock_bh\n- 参数: [&l2tp_ip_lock]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n8. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n9. 函数名: inet_addr_type\n- 参数: [struct net *net, addr->l2tp_addr.s_addr]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n10. 函数名: sk_dst_reset\n- 参数: [struct sock *sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n11. 函数名: l2tp_ip_sk\n- 参数: [struct sock *sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n12. 函数名: write_lock_bh\n- 参数: [&l2tp_ip_lock]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n13. 函数名: sk_add_bind_node\n- 参数: [struct sock *sk, &l2tp_ip_bind_table]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n14. 函数名: sk_del_node_init\n- 参数: [struct sock *sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n15. 函数名: write_unlock_bh\n- 参数: [&l2tp_ip_lock]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n16. 函数名: sock_reset_flag\n- 参数: [struct sock *sk, SOCK_ZAPPED]\n- 调用者: l2tp_ip_bind\n- 被调用者: []\n\n17. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: l2tp_ip_bind\n- 被调用者: []"
    },
    {
        "id": 899,
        "cwe": "CWE-416",
        "cve": "CVE-2016-10200",
        "purpose": "Code purpose:\"\"\"该代码实现了L2TPv3协议在IPv6环境下的socket绑定功能，包括地址验证、状态检查和绑定表管理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多次bind系统调用时未能正确检查SOCK_ZAPPED状态，导致竞争条件引发的use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: l2tp_ip6_bind\n- 参数: [sk, uaddr, addr_len]\n- 调用者: 未显示（系统调用）\n- 被调用者: [inet_sk, inet6_sk, sock_net, ipv6_addr_type, __l2tp_ip6_bind_lookup, lock_sock, rcu_read_lock, dev_get_by_index_rcu, ipv6_chk_addr, rcu_read_unlock, sk_add_bind_node, sk_del_node_init, sock_reset_flag, release_sock]\n\n2. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n3. 函数名: inet6_sk\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n4. 函数名: sock_net\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n5. 函数名: ipv6_addr_type\n- 参数: [&addr->l2tp_addr]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n6. 函数名: __l2tp_ip6_bind_lookup\n- 参数: [net, &addr->l2tp_addr, sk->sk_bound_dev_if, addr->l2tp_conn_id]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n7. 函数名: lock_sock\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n8. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n9. 函数名: dev_get_by_index_rcu\n- 参数: [sock_net(sk), sk->sk_bound_dev_if]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n10. 函数名: ipv6_chk_addr\n- 参数: [sock_net(sk), &addr->l2tp_addr, dev, 0]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n11. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n12. 函数名: sk_add_bind_node\n- 参数: [sk, &l2tp_ip6_bind_table]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n13. 函数名: sk_del_node_init\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n14. 函数名: sock_reset_flag\n- 参数: [sk, SOCK_ZAPPED]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []\n\n15. 函数名: release_sock\n- 参数: [sk]\n- 调用者: l2tp_ip6_bind\n- 被调用者: []"
    },
    {
        "id": 907,
        "cwe": "CWE-416",
        "cve": "CVE-2016-10905",
        "purpose": "Code purpose:\"\"\"该代码用于清理GFS2文件系统中的资源组描述符(rgrpd)及相关资源，包括释放内存、删除索引树节点和处理关联的glock对象\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在gfs2_clear_rgrpd函数中，由于在释放rgd资源后未正确处理gl对象的引用，导致后续操作可能访问已释放的内存区域，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: gfs2_clear_rgrpd\n- 参数: [struct gfs2_sbd *sdp]\n- 调用者: N/A\n- 被调用者: [rb_first, rb_entry, rb_erase, spin_lock, spin_unlock, gfs2_glock_add_to_lru, gfs2_glock_put, gfs2_free_clones, kfree, return_all_reservations, kmem_cache_free]\n\n2. 函数名: rb_first\n- 参数: [&sdp->sd_rindex_tree]\n- 调用者: gfs2_clear_rgrpd\n- 被调用者: N/A\n\n3. 函数名: rb_entry\n- 参数: [n, struct gfs2_rgrpd, rd_node]\n- 调用者: gfs2_clear_rgrpd\n- 被调用者: N/A\n\n4. 函数名: rb_erase\n- 参数: [n, &sdp->sd_rindex_tree]\n- 调用者: gfs2_clear_rgrpd\n- 被调用者: N/A\n\n5. 函数名: spin_lock\n- 参数: [&gl->gl_lockref.lock]\n- 调用者: gfs2_clear_rgrpd\n- 被调用者: N/A\n\n6. 函数名: spin_unlock\n- 参数: [&gl->gl_lockref.lock]\n- 调用者: gfs2_clear_rgrpd\n- 被调用者: N/A\n\n7. 函数名: gfs2_glock_add_to_lru\n- 参数: [gl]\n- 调用者: gfs2_clear_rgrpd\n- 被调用者: N/A\n\n8. 函数名: gfs2_glock_put\n- 参数: [gl]\n- 调用者: gfs2_clear_rgrpd\n- 被调用者: N/A\n\n9. 函数名: gfs2_free_clones\n- 参数: [rgd]\n- 调用者: gfs2_clear_rgrpd\n- 被调用者: N/A\n\n10. 函数名: kfree\n- 参数: [rgd->rd_bits]\n- 调用者: gfs2_clear_rgrpd\n- 被调用者: N/A\n\n11. 函数名: return_all_reservations\n- 参数: [rgd]\n- 调用者: gfs2_clear_rgrpd\n- 被调用者: N/A\n\n12. 函数名: kmem_cache_free\n- 参数: [gfs2_rgrpd_cachep, rgd]\n- 调用者: gfs2_clear_rgrpd\n- 被调用者: N/A"
    },
    {
        "id": 908,
        "cwe": "CWE-416",
        "cve": "CVE-2016-10905",
        "purpose": "Code purpose:\"\"\"读取并处理GFS2文件系统的资源组索引条目，分配和管理相关资源组描述符\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在read_rindex_entry函数中，当rgd_insert失败时，错误处理路径中直接释放了rgd结构体，但未正确处理与之关联的glock对象，导致后续可能发生use-after-free\"\"\"",
        "functions": "Functions:\n1. 函数名: read_rindex_entry\n- 参数: [struct gfs2_inode *ip]\n- 调用者: 未明确显示（可能是外部调用）\n- 被调用者: [i_size_read, gfs2_internal_read, kmem_cache_zalloc, be64_to_cpu, be32_to_cpu, spin_lock_init, compute_bitstructs, gfs2_glock_get, PAGE_ALIGN, spin_lock, rgd_insert, spin_unlock, gfs2_glock_put, kfree, kmem_cache_free]\n\n2. 函数名: i_size_read\n- 参数: [struct inode *inode]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n3. 函数名: gfs2_internal_read\n- 参数: [struct gfs2_inode *ip, char *buf, loff_t *pos, size_t size]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n4. 函数名: kmem_cache_zalloc\n- 参数: [struct kmem_cache *cachep, gfp_t flags]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n5. 函数名: be64_to_cpu\n- 参数: [__be64 x]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n6. 函数名: be32_to_cpu\n- 参数: [__be32 x]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n7. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n8. 函数名: compute_bitstructs\n- 参数: [struct gfs2_rgrpd *rgd]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n9. 函数名: gfs2_glock_get\n- 参数: [struct gfs2_sbd *sdp, u64 number, const struct gfs2_glock_operations *glops, int create, struct gfs2_glock **glp]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n10. 函数名: PAGE_ALIGN\n- 参数: [unsigned long addr]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n11. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n12. 函数名: rgd_insert\n- 参数: [struct gfs2_rgrpd *rgd]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n13. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n14. 函数名: gfs2_glock_put\n- 参数: [struct gfs2_glock *gl]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n15. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: read_rindex_entry\n- 被调用者: []\n\n16. 函数名: kmem_cache_free\n- 参数: [struct kmem_cache *cachep, void *objp]\n- 调用者: read_rindex_entry\n- 被调用者: []"
    },
    {
        "id": 909,
        "cwe": "CWE-416",
        "cve": "CVE-2016-10906",
        "purpose": "Code purpose:\"\"\"该代码实现了ARC EMAC网络设备驱动中的数据包发送功能，包括数据包填充、DMA映射、传输描述符更新和队列状态管理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于arc_emac_tx和arc_emac_tx_clean函数之间的竞争条件导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: arc_emac_tx\n- 参数: [struct sk_buff *skb, struct net_device *ndev]\n- 调用者: 未显示（通常由网络子系统调用）\n- 被调用者: [skb_padto, max_t, arc_emac_tx_avail, netif_stop_queue, netdev_err, dma_map_single, dma_mapping_error, dev_kfree_skb, dma_unmap_addr_set, dma_unmap_len_set, cpu_to_le32, wmb, skb_tx_timestamp, smp_mb, netif_start_queue, arc_reg_set]\n\n2. 函数名: skb_padto\n- 参数: [struct sk_buff *skb, unsigned int len]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n3. 函数名: max_t\n- 参数: [unsigned int, ETH_ZLEN, skb->len]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n4. 函数名: arc_emac_tx_avail\n- 参数: [struct arc_emac_priv *priv]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n5. 函数名: netif_stop_queue\n- 参数: [struct net_device *ndev]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n6. 函数名: netdev_err\n- 参数: [struct net_device *ndev, const char *fmt, ...]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n7. 函数名: dma_map_single\n- 参数: [struct device *dev, void *ptr, size_t size, enum dma_data_direction dir]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n8. 函数名: dma_mapping_error\n- 参数: [struct device *dev, dma_addr_t dma_addr]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n9. 函数名: dev_kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n10. 函数名: dma_unmap_addr_set\n- 参数: [struct buffer *buf, dma_addr_t addr, dma_addr_t val]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n11. 函数名: dma_unmap_len_set\n- 参数: [struct buffer *buf, unsigned int len, unsigned int val]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n12. 函数名: cpu_to_le32\n- 参数: [__u32 val]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n13. 函数名: wmb\n- 参数: []\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n14. 函数名: skb_tx_timestamp\n- 参数: [struct sk_buff *skb]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n15. 函数名: smp_mb\n- 参数: []\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n16. 函数名: netif_start_queue\n- 参数: [struct net_device *dev]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示\n\n17. 函数名: arc_reg_set\n- 参数: [struct arc_emac_priv *priv, int reg, u32 value]\n- 调用者: arc_emac_tx\n- 被调用者: 未显示"
    },
    {
        "id": 910,
        "cwe": "CWE-416",
        "cve": "CVE-2016-10906",
        "purpose": "Code purpose:\"\"\"该代码用于清理网络设备发送缓冲区中的已完成传输的数据包，并更新相关统计信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于arc_emac_tx和arc_emac_tx_clean函数之间的竞争条件导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: arc_emac_tx_clean\n- 参数: [struct net_device *ndev]\n- 调用者: 未明确显示（通常由网络子系统调用）\n- 被调用者: [le32_to_cpu, dma_unmap_single, dev_kfree_skb_irq, smp_mb, netif_queue_stopped, arc_emac_tx_avail, netif_wake_queue]\n\n2. 函数名: le32_to_cpu\n- 参数: [unsigned int info]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n3. 函数名: dma_unmap_single\n- 参数: [&ndev->dev, dma_unmap_addr(tx_buff, addr), dma_unmap_len(tx_buff, len), DMA_TO_DEVICE]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n4. 函数名: dev_kfree_skb_irq\n- 参数: [struct sk_buff *skb]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n5. 函数名: smp_mb\n- 参数: []\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n6. 函数名: netif_queue_stopped\n- 参数: [struct net_device *ndev]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n7. 函数名: arc_emac_tx_avail\n- 参数: [struct arc_emac_priv *priv]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []\n\n8. 函数名: netif_wake_queue\n- 参数: [struct net_device *ndev]\n- 调用者: arc_emac_tx_clean\n- 被调用者: []"
    },
    {
        "id": 989,
        "cwe": "CWE-416",
        "cve": "CVE-2016-3841",
        "purpose": "Code purpose:\"\"\"处理IPv6 DCCP协议中接收请求并创建新套接字的过程，包括IPv4映射和IPv6原生连接的处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致在精心构造的sendmsg系统调用下可能发生use-after-free，从而允许本地用户提升权限或引发拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: dccp_v6_request_recv_sock\n- 参数: [const struct sock *sk, struct sk_buff *skb, struct request_sock *req, struct dst_entry *dst, struct request_sock *req_unhash, bool *own_req]\n- 调用者: 未显示\n- 被调用者: [inet_rsk, inet6_sk, dccp_v4_request_recv_sock, inet_sk, memcpy, inet_csk, dccp_v4_do_rcv, inet6_iif, dccp_sync_mss, sk_acceptq_is_full, inet6_csk_route_req, dccp_create_openreq_child, __ip6_dst_store, ipv6_dup_options, __inet_inherit_port, inet_csk_prepare_forced_close, dccp_done, inet_ehash_nolisten, skb_clone, consume_skb, skb_set_owner_r, dst_release]\n\n2. 函数名: dccp_v4_request_recv_sock\n- 参数: [const struct sock *sk, struct sk_buff *skb, struct request_sock *req, struct dst_entry *dst, struct request_sock *req_unhash, bool *own_req]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n3. 函数名: dccp_create_openreq_child\n- 参数: [const struct sock *sk, struct request_sock *req, struct sk_buff *skb]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n4. 函数名: dccp_sync_mss\n- 参数: [struct sock *newsk, inet_csk(newsk)->icsk_pmtu_cookie]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n5. 函数名: dccp_v4_do_rcv\n- 参数: 未显示\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n6. 函数名: dccp_done\n- 参数: [struct sock *newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n7. 函数名: inet_rsk\n- 参数: [struct request_sock *req]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n8. 函数名: inet6_sk\n- 参数: [const struct sock *sk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n9. 函数名: inet_sk\n- 参数: [struct sock *newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n10. 函数名: inet_csk\n- 参数: [struct sock *newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n11. 函数名: inet6_iif\n- 参数: [struct sk_buff *skb]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n12. 函数名: sk_acceptq_is_full\n- 参数: [const struct sock *sk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n13. 函数名: inet6_csk_route_req\n- 参数: [const struct sock *sk, struct flowi6 *fl6, struct request_sock *req, IPPROTO_DCCP]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n14. 函数名: __ip6_dst_store\n- 参数: [struct sock *newsk, struct dst_entry *dst, NULL, NULL]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n15. 函数名: ipv6_dup_options\n- 参数: [struct sock *newsk, np->opt]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n16. 函数名: __inet_inherit_port\n- 参数: [const struct sock *sk, struct sock *newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n17. 函数名: inet_csk_prepare_forced_close\n- 参数: [struct sock *newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n18. 函数名: inet_ehash_nolisten\n- 参数: [struct sock *newsk, req_to_sk(req_unhash)]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n19. 函数名: skb_clone\n- 参数: [ireq->pktopts, GFP_ATOMIC]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n20. 函数名: consume_skb\n- 参数: [ireq->pktopts]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n21. 函数名: skb_set_owner_r\n- 参数: [newnp->pktoptions, newsk]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示\n\n22. 函数名: dst_release\n- 参数: [struct dst_entry *dst]\n- 调用者: dccp_v6_request_recv_sock\n- 被调用者: 未显示"
    },
    {
        "id": 990,
        "cwe": "CWE-416",
        "cve": "CVE-2016-3841",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中DCCP协议在IPv6环境下的客户端连接功能，包括地址处理、路由查找和连接建立等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致本地用户可通过精心构造的sendmsg系统调用触发释放后重用漏洞，从而获取权限或造成系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: dccp_v6_connect\n- 参数: [sk, uaddr, addr_len]\n- 调用者: 无（系统调用）\n- 被调用者: [inet_csk, inet_sk, inet6_sk, dccp_sk, memset, ipv6_addr_any, ipv6_addr_type, fl6_sock_lookup, fl6_sock_release, SOCK_DEBUG, __ipv6_only_sock, dccp_v4_connect, security_sk_classify_flow, fl6_update_dst, ip6_dst_lookup_flow, __ip6_dst_store, dccp_set_state, inet6_hash_connect, secure_dccpv6_sequence_number, dccp_connect, __sk_dst_reset]\n\n2. 函数名: inet_csk\n- 参数: [sk]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n3. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n4. 函数名: inet6_sk\n- 参数: [sk]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n5. 函数名: dccp_sk\n- 参数: [sk]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n6. 函数名: memset\n- 参数: [&fl6, 0, sizeof(fl6)]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n7. 函数名: ipv6_addr_any\n- 参数: [&usin->sin6_addr]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n8. 函数名: ipv6_addr_type\n- 参数: [&usin->sin6_addr]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n9. 函数名: fl6_sock_lookup\n- 参数: [sk, fl6.flowlabel]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n10. 函数名: fl6_sock_release\n- 参数: [flowlabel]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n11. 函数名: SOCK_DEBUG\n- 参数: [sk, \"connect: ipv4 mapped\"]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n12. 函数名: __ipv6_only_sock\n- 参数: [sk]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n13. 函数名: dccp_v4_connect\n- 参数: [sk, (struct sockaddr *)&sin, sizeof(sin)]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n14. 函数名: security_sk_classify_flow\n- 参数: [sk, flowi6_to_flowi(&fl6)]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n15. 函数名: fl6_update_dst\n- 参数: [&fl6, np->opt, &final]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n16. 函数名: ip6_dst_lookup_flow\n- 参数: [sk, &fl6, final_p]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n17. 函数名: __ip6_dst_store\n- 参数: [sk, dst, NULL, NULL]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n18. 函数名: dccp_set_state\n- 参数: [sk, DCCP_REQUESTING/DCCP_CLOSED]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n19. 函数名: inet6_hash_connect\n- 参数: [&dccp_death_row, sk]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n20. 函数名: secure_dccpv6_sequence_number\n- 参数: [np->saddr.s6_addr32, sk->sk_v6_daddr.s6_addr32, inet->inet_sport, inet->inet_dport]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n21. 函数名: dccp_connect\n- 参数: [sk]\n- 调用者: dccp_v6_connect\n- 被调用者: 无\n\n22. 函数名: __sk_dst_reset\n- 参数: [sk]\n- 调用者: dccp_v6_connect\n- 被调用者: 无"
    },
    {
        "id": 991,
        "cwe": "CWE-416",
        "cve": "CVE-2016-3841",
        "purpose": "Code purpose:\"\"\"该代码用于处理DCCP协议在IPv6下的响应发送，包括构建响应报文、计算校验和并通过IPv6协议栈发送响应。\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致在精心构造的sendmsg系统调用下可能发生释放后重用(use-after-free)问题\"\"\"",
        "functions": "Functions:\n1. 函数名: dccp_v6_send_response\n- 参数: [const struct sock *sk, struct request_sock *req]\n- 调用者: N/A\n- 被调用者: [inet_rsk, inet6_sk, memset, htons, security_req_classify_flow, flowi6_to_flowi, fl6_update_dst, ip6_dst_lookup_flow, IS_ERR, PTR_ERR, dccp_make_response, dccp_v6_csum_finish, ip6_xmit, net_xmit_eval, dst_release]\n\n2. 函数名: inet_rsk\n- 参数: [struct request_sock *req]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n3. 函数名: inet6_sk\n- 参数: [const struct sock *sk]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n4. 函数名: memset\n- 参数: [&fl6, 0, sizeof(fl6)]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n5. 函数名: htons\n- 参数: [ireq->ir_num]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n6. 函数名: security_req_classify_flow\n- 参数: [req, flowi6_to_flowi(&fl6)]\n- 调用者: dccp_v6_send_response\n- 被调用者: [flowi6_to_flowi]\n\n7. 函数名: flowi6_to_flowi\n- 参数: [&fl6]\n- 调用者: security_req_classify_flow\n- 被调用者: N/A\n\n8. 函数名: fl6_update_dst\n- 参数: [&fl6, np->opt, &final]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n9. 函数名: ip6_dst_lookup_flow\n- 参数: [sk, &fl6, final_p]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n10. 函数名: IS_ERR\n- 参数: [dst]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n11. 函数名: PTR_ERR\n- 参数: [dst]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n12. 函数名: dccp_make_response\n- 参数: [sk, dst, req]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n13. 函数名: dccp_v6_csum_finish\n- 参数: [skb, &ireq->ir_v6_loc_addr, &ireq->ir_v6_rmt_addr]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n14. 函数名: ip6_xmit\n- 参数: [sk, skb, &fl6, np->opt, np->tclass]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n15. 函数名: net_xmit_eval\n- 参数: [err]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A\n\n16. 函数名: dst_release\n- 参数: [dst]\n- 调用者: dccp_v6_send_response\n- 被调用者: N/A"
    },
    {
        "id": 992,
        "cwe": "CWE-416",
        "cve": "CVE-2016-3841",
        "purpose": "Code purpose:\"\"\"释放IPv6套接字相关资源，包括接收选项、PMTU数据、流标签和传输选项\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在释放后使用(UAF)问题，导致本地用户可通过特制的sendmsg系统调用获取权限或引发拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: inet6_destroy_sock\n- 参数: [sk]\n- 调用者: 未显示\n- 被调用者: [inet6_sk, xchg, kfree_skb, fl6_free_socklist, sock_kfree_s]\n\n2. 函数名: inet6_sk\n- 参数: [sk]\n- 调用者: inet6_destroy_sock\n- 被调用者: 未显示\n\n3. 函数名: xchg\n- 参数: [&np->pktoptions, NULL], [&np->rxpmtu, NULL], [&np->opt, NULL]\n- 调用者: inet6_destroy_sock\n- 被调用者: 未显示\n\n4. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: inet6_destroy_sock\n- 被调用者: 未显示\n\n5. 函数名: fl6_free_socklist\n- 参数: [sk]\n- 调用者: inet6_destroy_sock\n- 被调用者: 未显示\n\n6. 函数名: sock_kfree_s\n- 参数: [sk, opt, opt->tot_len]\n- 调用者: inet6_destroy_sock\n- 被调用者: 未显示"
    },
    {
        "id": 993,
        "cwe": "CWE-416",
        "cve": "CVE-2016-3841",
        "purpose": "Code purpose:\"\"\"该代码用于重建IPv6套接字的头部信息，包括检查目标路由缓存、创建新的流标签和查找目标路由等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致在特定情况下可能发生use-after-free错误，允许本地用户通过精心构造的sendmsg系统调用提升权限或造成拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: inet6_sk_rebuild_header\n- 参数: [struct sock *sk]\n- 调用者: 未显示\n- 被调用者: [inet6_sk, __sk_dst_check, inet_sk, memset, security_sk_classify_flow, fl6_update_dst, ip6_dst_lookup_flow, __ip6_dst_store]\n\n2. 函数名: inet6_sk\n- 参数: [struct sock *sk]\n- 调用者: inet6_sk_rebuild_header\n- 被调用者: 未显示\n\n3. 函数名: __sk_dst_check\n- 参数: [struct sock *sk, np->dst_cookie]\n- 调用者: inet6_sk_rebuild_header\n- 被调用者: 未显示\n\n4. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: inet6_sk_rebuild_header\n- 被调用者: 未显示\n\n5. 函数名: memset\n- 参数: [&fl6, 0, sizeof(fl6)]\n- 调用者: inet6_sk_rebuild_header\n- 被调用者: 未显示\n\n6. 函数名: security_sk_classify_flow\n- 参数: [sk, flowi6_to_flowi(&fl6)]\n- 调用者: inet6_sk_rebuild_header\n- 被调用者: 未显示\n\n7. 函数名: fl6_update_dst\n- 参数: [&fl6, np->opt, &final]\n- 调用者: inet6_sk_rebuild_header\n- 被调用者: 未显示\n\n8. 函数名: ip6_dst_lookup_flow\n- 参数: [sk, &fl6, final_p]\n- 调用者: inet6_sk_rebuild_header\n- 被调用者: 未显示\n\n9. 函数名: __ip6_dst_store\n- 参数: [sk, dst, NULL, NULL]\n- 调用者: inet6_sk_rebuild_header\n- 被调用者: 未显示"
    },
    {
        "id": 994,
        "cwe": "CWE-416",
        "cve": "CVE-2016-3841",
        "purpose": "Code purpose:\"\"\"该代码实现了IPv6数据报的连接功能，处理IPv6套接字连接请求并建立相应的路由和地址信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在use-after-free漏洞，本地用户可通过精心构造的sendmsg系统调用利用此漏洞获取权限或导致系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: __ip6_datagram_connect\n- 参数: [sk, uaddr, addr_len]\n- 调用者: 未显示（系统调用或内核其他部分）\n- 被调用者: [__ipv6_only_sock, __ip4_datagram_connect, fl6_sock_lookup, ipv6_addr_type, ipv6_addr_set_v4mapped, ipv6_addr_any, ipv6_mapped_addr_any, __ipv6_addr_needs_scope_id, security_sk_classify_flow, fl6_update_dst, ip6_dst_lookup_flow, ip6_dst_store, sk_set_txhash, fl6_sock_release]\n\n2. 函数名: __ipv6_only_sock\n- 参数: [sk]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n3. 函数名: __ip4_datagram_connect\n- 参数: [sk, uaddr, addr_len]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n4. 函数名: fl6_sock_lookup\n- 参数: [sk, fl6.flowlabel]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n5. 函数名: ipv6_addr_type\n- 参数: [&usin->sin6_addr]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n6. 函数名: ipv6_addr_set_v4mapped\n- 参数: [inet->inet_daddr, &sk->sk_v6_daddr], [inet->inet_saddr, &np->saddr], [inet->inet_rcv_saddr, &sk->sk_v6_rcv_saddr]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n7. 函数名: ipv6_addr_any\n- 参数: [&np->saddr], [&sk->sk_v6_rcv_saddr], [&np->saddr], [&sk->sk_v6_rcv_saddr]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n8. 函数名: ipv6_mapped_addr_any\n- 参数: [&np->saddr], [&sk->sk_v6_rcv_saddr]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n9. 函数名: __ipv6_addr_needs_scope_id\n- 参数: [addr_type]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n10. 函数名: security_sk_classify_flow\n- 参数: [sk, flowi6_to_flowi(&fl6)]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n11. 函数名: fl6_update_dst\n- 参数: [&fl6, opt, &final]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n12. 函数名: ip6_dst_lookup_flow\n- 参数: [sk, &fl6, final_p]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n13. 函数名: ip6_dst_store\n- 参数: [sk, dst, ipv6_addr_equal(&fl6.daddr, &sk->sk_v6_daddr) ? &sk->sk_v6_daddr : NULL, ipv6_addr_equal(&fl6.saddr, &np->saddr) ? &np->saddr : NULL]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n14. 函数名: sk_set_txhash\n- 参数: [sk]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n15. 函数名: fl6_sock_release\n- 参数: [flowlabel]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []"
    },
    {
        "id": 995,
        "cwe": "CWE-416",
        "cve": "CVE-2016-3841",
        "purpose": "Code purpose:\"\"\"复制IPv6传输选项结构体并调整其中的指针偏移量\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在复制IPv6选项时未正确处理内存指针，导致后续可能发生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ipv6_dup_options\n- 参数: [sk, opt]\n- 调用者: 未明确（由Linux内核IPv6栈调用）\n- 被调用者: [sock_kmalloc, memcpy]\n\n2. 函数名: sock_kmalloc\n- 参数: [sk, size, flags]\n- 调用者: ipv6_dup_options\n- 被调用者: []\n\n3. 函数名: memcpy\n- 参数: [dest, src, n]\n- 调用者: ipv6_dup_options\n- 被调用者: []"
    },
    {
        "id": 996,
        "cwe": "CWE-416",
        "cve": "CVE-2016-3841",
        "purpose": "Code purpose:\"\"\"该代码用于更新IPv6套接字的传输选项，包括处理各种IPv6选项头(如HOPOPTS、RTHDRDSTOPTS等)的重新分配和复制，并计算新的选项总长度。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在释放后使用(UAF)漏洞，由于未正确管理内存导致本地用户可通过精心构造的sendmsg系统调用触发该漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ipv6_renew_options\n- 参数: [sk, opt, newtype, newopt, newoptlen]\n- 调用者: 未显示（由系统调用触发）\n- 被调用者: [CMSG_ALIGN, ipv6_optlen, sock_kmalloc, ERR_PTR, memset, ipv6_renew_option, sock_kfree_s]\n\n2. 函数名: CMSG_ALIGN\n- 参数: [未显示具体参数]\n- 调用者: ipv6_renew_options\n- 被调用者: []\n\n3. 函数名: ipv6_optlen\n- 参数: [未显示具体参数]\n- 调用者: ipv6_renew_options\n- 被调用者: []\n\n4. 函数名: sock_kmalloc\n- 参数: [sk, tot_len, GFP_ATOMIC]\n- 调用者: ipv6_renew_options\n- 被调用者: []\n\n5. 函数名: ERR_PTR\n- 参数: [err_code]\n- 调用者: ipv6_renew_options\n- 被调用者: []\n\n6. 函数名: memset\n- 参数: [opt2, 0, tot_len]\n- 调用者: ipv6_renew_options\n- 被调用者: []\n\n7. 函数名: ipv6_renew_option\n- 参数: [opt_old, newopt, newoptlen, condition, opt_new, p]\n- 调用者: ipv6_renew_options\n- 被调用者: []\n\n8. 函数名: sock_kfree_s\n- 参数: [sk, opt2, opt2->tot_len]\n- 调用者: ipv6_renew_options\n- 被调用者: []"
    },
    {
        "id": 997,
        "cwe": "CWE-416",
        "cve": "CVE-2016-3841",
        "purpose": "Code purpose:\"\"\"该代码用于为IPv6套接字创建或检查路由缓存条目，处理流标签、源/目的地址等网络流信息，并返回目标路由条目。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致在特定情况下可能发生释放后重用(use-after-free)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: inet6_csk_route_socket\n- 参数: [struct sock *sk, struct flowi6 *fl6]\n- 调用者: 未指定\n- 被调用者: [inet_sk, inet6_sk, memset, IP6_ECN_flow_xmit, security_sk_classify_flow, flowi6_to_flowi, fl6_update_dst, __inet6_csk_dst_check, ip6_dst_lookup_flow, IS_ERR, __inet6_csk_dst_store]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: inet6_csk_route_socket\n- 被调用者: 未指定\n\n3. 函数名: inet6_sk\n- 参数: [struct sock *sk]\n- 调用者: inet6_csk_route_socket\n- 被调用者: 未指定\n\n4. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: inet6_csk_route_socket\n- 被调用者: 未指定\n\n5. 函数名: IP6_ECN_flow_xmit\n- 参数: [struct sock *sk, __be32 flowlabel]\n- 调用者: inet6_csk_route_socket\n- 被调用者: 未指定\n\n6. 函数名: security_sk_classify_flow\n- 参数: [struct sock *sk, struct flowi *fl]\n- 调用者: inet6_csk_route_socket\n- 被调用者: 未指定\n\n7. 函数名: flowi6_to_flowi\n- 参数: [struct flowi6 *fl6]\n- 调用者: inet6_csk_route_socket\n- 被调用者: 未指定\n\n8. 函数名: fl6_update_dst\n- 参数: [struct flowi6 *fl6, struct ipv6_txoptions *opt, struct in6_addr *final]\n- 调用者: inet6_csk_route_socket\n- 被调用者: 未指定\n\n9. 函数名: __inet6_csk_dst_check\n- 参数: [struct sock *sk, u32 cookie]\n- 调用者: inet6_csk_route_socket\n- 被调用者: 未指定\n\n10. 函数名: ip6_dst_lookup_flow\n- 参数: [struct sock *sk, struct flowi6 *fl6, struct in6_addr *final_dst]\n- 调用者: inet6_csk_route_socket\n- 被调用者: 未指定\n\n11. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: inet6_csk_route_socket\n- 被调用者: 未指定\n\n12. 函数名: __inet6_csk_dst_store\n- 参数: [struct sock *sk, struct dst_entry *dst, struct dst_entry *old_dst, struct dst_entry *new_dst]\n- 调用者: inet6_csk_route_socket\n- 被调用者: 未指定"
    },
    {
        "id": 998,
        "cwe": "CWE-416",
        "cve": "CVE-2016-3841",
        "purpose": "Code purpose:\"\"\"该代码用于在IPv6协议栈中为传入的连接请求创建路由条目，处理源地址、目的地址、端口等网络流信息，并最终查找和返回对应的路由目标。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致在精心构造的sendmsg系统调用下可能发生use-after-free错误，允许本地用户提升权限或引发拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: inet6_csk_route_req\n- 参数: [const struct sock *sk, struct flowi6 *fl6, const struct request_sock *req, u8 proto]\n- 调用者: 未指定\n- 被调用者: [inet_rsk, inet6_sk, memset, fl6_update_dst, htons, security_req_classify_flow, flowi6_to_flowi, ip6_dst_lookup_flow, IS_ERR]\n\n2. 函数名: inet_rsk\n- 参数: [const struct request_sock *req]\n- 调用者: inet6_csk_route_req\n- 被调用者: 未指定\n\n3. 函数名: inet6_sk\n- 参数: [const struct sock *sk]\n- 调用者: inet6_csk_route_req\n- 被调用者: 未指定\n\n4. 函数名: memset\n- 参数: [struct flowi6 *fl6, 0, sizeof(*fl6)]\n- 调用者: inet6_csk_route_req\n- 被调用者: 未指定\n\n5. 函数名: fl6_update_dst\n- 参数: [struct flowi6 *fl6, np->opt, &final]\n- 调用者: inet6_csk_route_req\n- 被调用者: 未指定\n\n6. 函数名: htons\n- 参数: [ireq->ir_num]\n- 调用者: inet6_csk_route_req\n- 被调用者: 未指定\n\n7. 函数名: security_req_classify_flow\n- 参数: [req, flowi6_to_flowi(fl6)]\n- 调用者: inet6_csk_route_req\n- 被调用者: [flowi6_to_flowi]\n\n8. 函数名: flowi6_to_flowi\n- 参数: [struct flowi6 *fl6]\n- 调用者: security_req_classify_flow\n- 被调用者: 未指定\n\n9. 函数名: ip6_dst_lookup_flow\n- 参数: [sk, fl6, final_p]\n- 调用者: inet6_csk_route_req\n- 被调用者: 未指定\n\n10. 函数名: IS_ERR\n- 参数: [dst]\n- 调用者: inet6_csk_route_req\n- 被调用者: 未指定"
    },
    {
        "id": 999,
        "cwe": "CWE-416",
        "cve": "CVE-2016-3841",
        "purpose": "Code purpose:\"\"\"该代码片段实现了IPv6套接字的数据发送功能，包括路由查找、目标地址设置和实际数据发送操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致在sendmsg系统调用中可能发生释放后重用(UAF)问题\"\"\"",
        "functions": "Functions:\n1. 函数名: inet6_csk_xmit\n- 参数: [sk, skb, fl_unused]\n- 调用者: 未指定\n- 被调用者: [inet6_sk, inet6_csk_route_socket, IS_ERR, PTR_ERR, kfree_skb, rcu_read_lock, skb_dst_set_noref, ip6_xmit, rcu_read_unlock]\n\n2. 函数名: inet6_sk\n- 参数: [sk]\n- 调用者: inet6_csk_xmit\n- 被调用者: 未指定\n\n3. 函数名: inet6_csk_route_socket\n- 参数: [sk, &fl6]\n- 调用者: inet6_csk_xmit\n- 被调用者: 未指定\n\n4. 函数名: IS_ERR\n- 参数: [dst]\n- 调用者: inet6_csk_xmit\n- 被调用者: 未指定\n\n5. 函数名: PTR_ERR\n- 参数: [dst]\n- 调用者: inet6_csk_xmit\n- 被调用者: 未指定\n\n6. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: inet6_csk_xmit\n- 被调用者: 未指定\n\n7. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: inet6_csk_xmit\n- 被调用者: 未指定\n\n8. 函数名: skb_dst_set_noref\n- 参数: [skb, dst]\n- 调用者: inet6_csk_xmit\n- 被调用者: 未指定\n\n9. 函数名: ip6_xmit\n- 参数: [sk, skb, &fl6, np->opt, np->tclass]\n- 调用者: inet6_csk_xmit\n- 被调用者: 未指定\n\n10. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: inet6_csk_xmit\n- 被调用者: 未指定"
    },
    {
        "id": 1000,
        "cwe": "CWE-416",
        "cve": "CVE-2016-3841",
        "purpose": "Code purpose:\"\"\"该代码用于更新IPv6套接字的传输选项，处理选项长度并同步最大段大小(MSS)。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在释放后使用漏洞，由于未正确管理ipv6_txoptions结构体的生命周期，导致本地用户可通过特制的sendmsg系统调用触发该漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ipv6_update_options\n- 参数: [sk, opt]\n- 调用者: 未明确（由系统调用触发）\n- 被调用者: [inet_sk, inet_csk, xchg, sk_dst_reset]\n\n2. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: ipv6_update_options\n- 被调用者: []\n\n3. 函数名: inet_csk\n- 参数: [sk]\n- 调用者: ipv6_update_options\n- 被调用者: []\n\n4. 函数名: xchg\n- 参数: [&inet6_sk(sk)->opt, opt]\n- 调用者: ipv6_update_options\n- 被调用者: []\n\n5. 函数名: sk_dst_reset\n- 参数: [sk]\n- 调用者: ipv6_update_options\n- 被调用者: []\n\n6. 函数名: icsk_sync_mss\n- 参数: [sk, icsk->icsk_pmtu_cookie]\n- 调用者: ipv6_update_options\n- 被调用者: []"
    },
    {
        "id": 1001,
        "cwe": "CWE-416",
        "cve": "CVE-2016-3841",
        "purpose": "Code purpose:\"\"\"处理IPv6套接字选项的设置，包括地址格式、多播、流标签等多种选项的配置和验证\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在释放后使用(UAF)漏洞，本地攻击者可通过精心构造的sendmsg系统调用利用此漏洞获取权限或导致系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: do_ipv6_setsockopt\n- 参数: [struct sock *sk, int level, int optname, char __user *optval, unsigned int optlen]\n- 调用者: 系统调用\n- 被调用者: [sock_net, setsockopt_needs_rtnl, get_user, ip6_mroute_opt, ip6_mroute_setsockopt, rtnl_lock, lock_sock, udp_sk, ipv6_only_sock, ipv6_addr_v4mapped, fl6_free_socklist, ipv6_sock_mc_close, sk_refcnt_debug_dec, sock_prot_inuse_add, local_bh_disable, local_bh_enable, tcp_sync_mss, xchg, sock_kfree_s, kfree_skb, sk_refcnt_debug_inc, module_put, ns_capable, ipv6_renew_options, ipv6_update_options, copy_from_user, dev_get_by_index, dev_put, ipv6_sock_mc_join, ipv6_sock_mc_drop, ipv6_sock_ac_join, ipv6_sock_ac_drop, ip6_mc_source, ip6_mc_msfilter, ip6_ra_control, xfrm_user_policy, ipv6_flowlabel_opt, release_sock, rtnl_unlock]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n3. 函数名: setsockopt_needs_rtnl\n- 参数: [int optname]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n4. 函数名: get_user\n- 参数: [int val, int __user *optval]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n5. 函数名: ip6_mroute_opt\n- 参数: [int optname]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n6. 函数名: ip6_mroute_setsockopt\n- 参数: [struct sock *sk, int optname, char __user *optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n7. 函数名: rtnl_lock\n- 参数: []\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n8. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n9. 函数名: udp_sk\n- 参数: [struct sock *sk]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n10. 函数名: ipv6_only_sock\n- 参数: [struct sock *sk]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n11. 函数名: ipv6_addr_v4mapped\n- 参数: [struct in6_addr *addr]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n12. 函数名: fl6_free_socklist\n- 参数: [struct sock *sk]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n13. 函数名: ipv6_sock_mc_close\n- 参数: [struct sock *sk]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n14. 函数名: sk_refcnt_debug_dec\n- 参数: [struct sock *sk]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n15. 函数名: sock_prot_inuse_add\n- 参数: [struct net *net, struct proto *prot, int val]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n16. 函数名: local_bh_disable\n- 参数: []\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n17. 函数名: local_bh_enable\n- 参数: []\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n18. 函数名: tcp_sync_mss\n- 参数: [struct sock *sk, u32 pmtu]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n19. 函数名: xchg\n- 参数: [struct ipv6_txoptions **np_opt, NULL]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n20. 函数名: sock_kfree_s\n- 参数: [struct sock *sk, void *mem, int size]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n21. 函数名: kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n22. 函数名: sk_refcnt_debug_inc\n- 参数: [struct sock *sk]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n23. 函数名: module_put\n- 参数: [struct module *mod]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n24. 函数名: ns_capable\n- 参数: [struct user_namespace *ns, int cap]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n25. 函数名: ipv6_renew_options\n- 参数: [struct sock *sk, struct ipv6_txoptions *opt, int optname, struct ipv6_opt_hdr __user *optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n26. 函数名: ipv6_update_options\n- 参数: [struct sock *sk, struct ipv6_txoptions *opt]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n27. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n28. 函数名: dev_get_by_index\n- 参数: [struct net *net, int ifindex]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n29. 函数名: dev_put\n- 参数: [struct net_device *dev]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n30. 函数名: ipv6_sock_mc_join\n- 参数: [struct sock *sk, int ifindex, struct in6_addr *addr]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n31. 函数名: ipv6_sock_mc_drop\n- 参数: [struct sock *sk, int ifindex, struct in6_addr *addr]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n32. 函数名: ipv6_sock_ac_join\n- 参数: [struct sock *sk, int ifindex, struct in6_addr *addr]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n33. 函数名: ipv6_sock_ac_drop\n- 参数: [struct sock *sk, int ifindex, struct in6_addr *addr]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n34. 函数名: ip6_mc_source\n- 参数: [int add, int omode, struct sock *sk, struct group_source_req *p]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n35. 函数名: ip6_mc_msfilter\n- 参数: [struct sock *sk, struct group_filter *gsf]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n36. 函数名: ip6_ra_control\n- 参数: [struct sock *sk, int val]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n37. 函数名: xfrm_user_policy\n- 参数: [struct sock *sk, int optname, char __user *optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n38. 函数名: ipv6_flowlabel_opt\n- 参数: [struct sock *sk, char __user *optval, unsigned int optlen]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n39. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []\n\n40. 函数名: rtnl_unlock\n- 参数: []\n- 调用者: do_ipv6_setsockopt\n- 被调用者: []"
    },
    {
        "id": 1002,
        "cwe": "CWE-416",
        "cve": "CVE-2016-3841",
        "purpose": "Code purpose:\"\"\"该代码实现了IPv6套接字选项的获取功能，处理不同类型的IPv6选项请求并返回相应的配置信息或状态值。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在释放后使用漏洞，本地攻击者可通过精心构造的sendmsg系统调用利用此漏洞获取权限或导致系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: do_ipv6_getsockopt\n- 参数: [struct sock *sk, int level, int optname, char __user *optval, int __user *optlen, unsigned int flags]\n- 调用者: 未显示\n- 被调用者: [ip6_mroute_getsockopt, get_user, copy_from_user, lock_sock, ip6_mc_msfget, release_sock, ip6_datagram_recv_ctl, put_cmsg, __sk_dst_get, dst_mtu, ipv6_getsockopt_sticky, put_user, copy_to_user, ipv6_flowlabel_opt_get]\n\n2. 函数名: ip6_mroute_getsockopt\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n3. 函数名: get_user\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n4. 函数名: copy_from_user\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n5. 函数名: lock_sock\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n6. 函数名: ip6_mc_msfget\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n7. 函数名: release_sock\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n8. 函数名: ip6_datagram_recv_ctl\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n9. 函数名: put_cmsg\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n10. 函数名: __sk_dst_get\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n11. 函数名: dst_mtu\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n12. 函数名: ipv6_getsockopt_sticky\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n13. 函数名: put_user\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n14. 函数名: copy_to_user\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示\n\n15. 函数名: ipv6_flowlabel_opt_get\n- 参数: 未显示\n- 调用者: do_ipv6_getsockopt\n- 被调用者: 未显示"
    },
    {
        "id": 1003,
        "cwe": "CWE-416",
        "cve": "CVE-2016-3841",
        "purpose": "Code purpose:\"\"\"处理IPv6原始套接字发送消息的请求，包括地址验证、流标签处理、选项设置和数据发送等功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致本地用户可通过精心构造的sendmsg系统调用触发释放后使用漏洞，从而获取权限或造成系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: rawv6_sendmsg\n- 参数: [struct sock *sk, struct msghdr *msg, size_t len]\n- 调用者: 系统调用\n- 被调用者: [fl6_sock_lookup, ip6_datagram_send_ctl, fl6_sock_release, fl6_merge_options, ipv6_fixup_options, rawv6_probe_proto_opt, fl6_update_dst, ip6_dst_lookup_flow, ip6_sk_dst_hoplimit, rawv6_send_hdrinc, ip6_append_data, ip6_flush_pending_frames, rawv6_push_pending_frames, dst_release, dst_confirm]\n\n2. 函数名: fl6_sock_lookup\n- 参数: [struct sock *sk, fl6.flowlabel]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n3. 函数名: ip6_datagram_send_ctl\n- 参数: [sock_net(sk), sk, msg, &fl6, opt, &hlimit, &tclass, &dontfrag]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n4. 函数名: fl6_sock_release\n- 参数: [flowlabel]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n5. 函数名: fl6_merge_options\n- 参数: [&opt_space, flowlabel, opt]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n6. 函数名: ipv6_fixup_options\n- 参数: [&opt_space, opt]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n7. 函数名: rawv6_probe_proto_opt\n- 参数: [&rfv, &fl6]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n8. 函数名: fl6_update_dst\n- 参数: [&fl6, opt, &final]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n9. 函数名: ip6_dst_lookup_flow\n- 参数: [sk, &fl6, final_p]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n10. 函数名: ip6_sk_dst_hoplimit\n- 参数: [np, &fl6, dst]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n11. 函数名: rawv6_send_hdrinc\n- 参数: [sk, msg, len, &fl6, &dst, msg->msg_flags]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n12. 函数名: ip6_append_data\n- 参数: [sk, raw6_getfrag, &rfv, len, 0, hlimit, tclass, opt, &fl6, (struct rt6_info *)dst, msg->msg_flags, dontfrag]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n13. 函数名: ip6_flush_pending_frames\n- 参数: [sk]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n14. 函数名: rawv6_push_pending_frames\n- 参数: [sk, &fl6, rp]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n15. 函数名: dst_release\n- 参数: [dst]\n- 调用者: rawv6_sendmsg\n- 被调用者: []\n\n16. 函数名: dst_confirm\n- 参数: [dst]\n- 调用者: rawv6_sendmsg\n- 被调用者: []"
    },
    {
        "id": 1004,
        "cwe": "CWE-416",
        "cve": "CVE-2016-3841",
        "purpose": "Code purpose:\"\"\"该代码用于处理IPv6 TCP同步cookie验证，验证接收到的TCP SYN-ACK报文中的cookie有效性并建立相应的请求套接字\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致在精心构造的sendmsg系统调用下可能发生use-after-free错误，允许本地用户提升权限或引发拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: cookie_v6_check\n- 参数: [struct sock *sk, struct sk_buff *skb]\n- 调用者: 未显示\n- 被调用者: [tcp_synq_no_recent_overflow, __cookie_v6_check, tcp_parse_options, cookie_timestamp_decode, inet_reqsk_alloc, security_inet_conn_request, ipv6_opt_accepted, tcp_v6_iif, inet_request_mark, fl6_update_dst, ip6_dst_lookup_flow, tcp_select_initial_window, tcp_get_cookie_sock, reqsk_free]\n\n2. 函数名: tcp_synq_no_recent_overflow\n- 参数: [struct sock *sk]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n3. 函数名: __cookie_v6_check\n- 参数: [ipv6_hdr(skb), th, cookie]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n4. 函数名: tcp_parse_options\n- 参数: [skb, &tcp_opt, 0, NULL]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n5. 函数名: cookie_timestamp_decode\n- 参数: [&tcp_opt]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n6. 函数名: inet_reqsk_alloc\n- 参数: [&tcp6_request_sock_ops, sk, false]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n7. 函数名: security_inet_conn_request\n- 参数: [sk, skb, req]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n8. 函数名: ipv6_opt_accepted\n- 参数: [sk, skb, &TCP_SKB_CB(skb)->header.h6]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n9. 函数名: tcp_v6_iif\n- 参数: [skb]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n10. 函数名: inet_request_mark\n- 参数: [sk, skb]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n11. 函数名: fl6_update_dst\n- 参数: [&fl6, np->opt, &final]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n12. 函数名: ip6_dst_lookup_flow\n- 参数: [sk, &fl6, final_p]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n13. 函数名: tcp_select_initial_window\n- 参数: [tcp_full_space(sk), req->mss, &req->rsk_rcv_wnd, &req->rsk_window_clamp, ireq->wscale_ok, &rcv_wscale, dst_metric(dst, RTAX_INITRWND)]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n14. 函数名: tcp_get_cookie_sock\n- 参数: [sk, skb, req, dst]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示\n\n15. 函数名: reqsk_free\n- 参数: [req]\n- 调用者: cookie_v6_check\n- 被调用者: 未显示"
    },
    {
        "id": 1005,
        "cwe": "CWE-416",
        "cve": "CVE-2016-3841",
        "purpose": "Code purpose:\"\"\"该代码片段实现了Linux内核中IPv6协议栈发送SYN-ACK响应的功能，用于TCP连接建立过程中的三次握手阶段。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致在精心构造的sendmsg系统调用下可能发生释放后重用(use-after-free)，从而允许本地用户提升权限或引发拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: tcp_v6_send_synack\n- 参数: [const struct sock *sk, struct dst_entry *dst, struct flowi *fl, struct request_sock *req, struct tcp_fastopen_cookie *foc, bool attach_req]\n- 调用者: 未显示\n- 被调用者: [inet_rsk, inet6_sk, inet6_csk_route_req, tcp_make_synack, __tcp_v6_send_check, ip6_flowlabel, ipv6_hdr, ip6_xmit, net_xmit_eval]\n\n2. 函数名: inet_rsk\n- 参数: [struct request_sock *req]\n- 调用者: tcp_v6_send_synack\n- 被调用者: 未显示\n\n3. 函数名: inet6_sk\n- 参数: [const struct sock *sk]\n- 调用者: tcp_v6_send_synack\n- 被调用者: 未显示\n\n4. 函数名: inet6_csk_route_req\n- 参数: [const struct sock *sk, struct flowi6 *fl6, struct request_sock *req, int protocol]\n- 调用者: tcp_v6_send_synack\n- 被调用者: 未显示\n\n5. 函数名: tcp_make_synack\n- 参数: [const struct sock *sk, struct dst_entry *dst, struct request_sock *req, struct tcp_fastopen_cookie *foc, bool attach_req]\n- 调用者: tcp_v6_send_synack\n- 被调用者: 未显示\n\n6. 函数名: __tcp_v6_send_check\n- 参数: [struct sk_buff *skb, const struct in6_addr *saddr, const struct in6_addr *daddr]\n- 调用者: tcp_v6_send_synack\n- 被调用者: 未显示\n\n7. 函数名: ip6_flowlabel\n- 参数: [struct ipv6hdr *hdr]\n- 调用者: tcp_v6_send_synack\n- 被调用者: 未显示\n\n8. 函数名: ipv6_hdr\n- 参数: [const struct sk_buff *skb]\n- 调用者: tcp_v6_send_synack\n- 被调用者: 未显示\n\n9. 函数名: ip6_xmit\n- 参数: [struct sock *sk, struct sk_buff *skb, struct flowi6 *fl6, struct ipv6_txoptions *opt, int tclass]\n- 调用者: tcp_v6_send_synack\n- 被调用者: 未显示\n\n10. 函数名: net_xmit_eval\n- 参数: [int err]\n- 调用者: tcp_v6_send_synack\n- 被调用者: 未显示"
    },
    {
        "id": 1006,
        "cwe": "CWE-416",
        "cve": "CVE-2016-3841",
        "purpose": "Code purpose:\"\"\"处理IPv6 TCP连接的同步接收套接字创建过程，包括IPv4映射地址的处理和套接字选项的复制\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致在精心构造的sendmsg系统调用下可能发生use-after-free错误，从而允许本地用户提升权限或造成拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: tcp_v6_syn_recv_sock\n- 参数: [sk, skb, req, dst, req_unhash, own_req]\n- 调用者: 未显示（由内核TCP/IP协议栈调用）\n- 被调用者: [tcp_v4_syn_recv_sock, inet6_sk, inet_sk, tcp_sk, memcpy, inet_csk, tcp_sync_mss, sk_acceptq_is_full, inet6_csk_route_req, tcp_create_openreq_child, __ip6_dst_store, inet6_sk_rx_dst_set, ipv6_dup_options, tcp_ca_openreq_child, dst_mtu, dst_metric_advmss, tcp_initialize_rcv_mss, tcp_v6_md5_do_lookup, tcp_md5_do_add, __inet_inherit_port, inet_csk_prepare_forced_close, tcp_done, inet_ehash_nolisten, tcp_move_syn, skb_clone, consume_skb, skb_set_owner_r, NET_INC_STATS_BH, dst_release]\n\n2. 函数名: tcp_v4_syn_recv_sock\n- 参数: [sk, skb, req, dst, req_unhash, own_req]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n3. 函数名: inet6_sk\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n4. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n5. 函数名: tcp_sk\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n6. 函数名: memcpy\n- 参数: [dest, src, n]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n7. 函数名: inet_csk\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n8. 函数名: tcp_sync_mss\n- 参数: [sk, pmtu]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n9. 函数名: sk_acceptq_is_full\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n10. 函数名: inet6_csk_route_req\n- 参数: [sk, fl6, req, proto]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n11. 函数名: tcp_create_openreq_child\n- 参数: [sk, req, skb]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n12. 函数名: __ip6_dst_store\n- 参数: [sk, dst, saddr, daddr]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n13. 函数名: inet6_sk_rx_dst_set\n- 参数: [sk, skb]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n14. 函数名: ipv6_dup_options\n- 参数: [sk, opt]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n15. 函数名: tcp_ca_openreq_child\n- 参数: [sk, dst]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n16. 函数名: dst_mtu\n- 参数: [dst]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n17. 函数名: dst_metric_advmss\n- 参数: [dst]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n18. 函数名: tcp_initialize_rcv_mss\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n19. 函数名: tcp_v6_md5_do_lookup\n- 参数: [sk, addr]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n20. 函数名: tcp_md5_do_add\n- 参数: [sk, addr, family, key, keylen, gfp]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n21. 函数名: __inet_inherit_port\n- 参数: [sk, newsk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n22. 函数名: inet_csk_prepare_forced_close\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n23. 函数名: tcp_done\n- 参数: [sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n24. 函数名: inet_ehash_nolisten\n- 参数: [sk, sk2]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n25. 函数名: tcp_move_syn\n- 参数: [tp, req]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n26. 函数名: skb_clone\n- 参数: [skb, gfp_mask]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n27. 函数名: consume_skb\n- 参数: [skb]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n28. 函数名: skb_set_owner_r\n- 参数: [skb, sk]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n29. 函数名: NET_INC_STATS_BH\n- 参数: [net, stat]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示\n\n30. 函数名: dst_release\n- 参数: [dst]\n- 调用者: tcp_v6_syn_recv_sock\n- 被调用者: 未显示"
    },
    {
        "id": 1007,
        "cwe": "CWE-416",
        "cve": "CVE-2016-3841",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中IPv6协议栈的TCP连接功能，处理IPv6地址转换、流标签、多播地址检查等操作，并建立TCP连接\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致本地用户可通过精心构造的sendmsg系统调用触发释放后重用漏洞，从而获取权限或造成系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: tcp_v6_connect\n- 参数: [struct sock *sk, struct sockaddr *uaddr, int addr_len]\n- 调用者: 无（系统调用）\n- 被调用者: [inet_sk, inet_csk, tcp_sk, inet6_sk, ipv6_addr_any, ipv6_addr_type, ipv6_addr_equal, fl6_sock_lookup, fl6_sock_release, __ipv6_only_sock, tcp_v4_connect, fl6_update_dst, security_sk_classify_flow, ip6_dst_lookup_flow, __ip6_dst_store, tcp_fetch_timewait_stamp, tcp_set_state, inet6_hash_connect, sk_set_txhash, secure_tcpv6_sequence_number, tcp_connect, __sk_dst_reset]\n\n2. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n3. 函数名: inet_csk\n- 参数: [struct sock *sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n4. 函数名: tcp_sk\n- 参数: [struct sock *sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n5. 函数名: inet6_sk\n- 参数: [struct sock *sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n6. 函数名: ipv6_addr_any\n- 参数: [const struct in6_addr *addr]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n7. 函数名: ipv6_addr_type\n- 参数: [const struct in6_addr *addr]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n8. 函数名: ipv6_addr_equal\n- 参数: [const struct in6_addr *a1, const struct in6_addr *a2]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n9. 函数名: fl6_sock_lookup\n- 参数: [struct sock *sk, __be32 label]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n10. 函数名: fl6_sock_release\n- 参数: [struct ip6_flowlabel *fl]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n11. 函数名: __ipv6_only_sock\n- 参数: [struct sock *sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n12. 函数名: tcp_v4_connect\n- 参数: [struct sock *sk, struct sockaddr *uaddr, int addr_len]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n13. 函数名: fl6_update_dst\n- 参数: [struct flowi6 *fl6, struct ipv6_txoptions *opt, struct in6_addr *final]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n14. 函数名: security_sk_classify_flow\n- 参数: [struct sock *sk, struct flowi *fl]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n15. 函数名: ip6_dst_lookup_flow\n- 参数: [struct sock *sk, struct flowi6 *fl6, struct in6_addr *final]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n16. 函数名: __ip6_dst_store\n- 参数: [struct sock *sk, struct dst_entry *dst, struct dst_entry *old, struct dst_entry *(*gc)(struct dst_entry *)]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n17. 函数名: tcp_fetch_timewait_stamp\n- 参数: [struct sock *sk, struct dst_entry *dst]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n18. 函数名: tcp_set_state\n- 参数: [struct sock *sk, int state]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n19. 函数名: inet6_hash_connect\n- 参数: [struct inet_timewait_death_row *death_row, struct sock *sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n20. 函数名: sk_set_txhash\n- 参数: [struct sock *sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n21. 函数名: secure_tcpv6_sequence_number\n- 参数: [__be32 *saddr, __be32 *daddr, __be16 sport, __be16 dport]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n22. 函数名: tcp_connect\n- 参数: [struct sock *sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无\n\n23. 函数名: __sk_dst_reset\n- 参数: [struct sock *sk]\n- 调用者: tcp_v6_connect\n- 被调用者: 无"
    },
    {
        "id": 1008,
        "cwe": "CWE-416",
        "cve": "CVE-2016-3841",
        "purpose": "Code purpose:\"\"\"处理IPv6 UDP套接字发送消息的请求，包括地址验证、选项处理和实际数据发送等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在use-after-free漏洞，本地用户可通过精心构造的sendmsg系统调用利用此漏洞获取权限或导致系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: udpv6_sendmsg\n- 参数: [struct sock *sk, struct msghdr *msg, size_t len]\n- 调用者: 系统调用\n- 被调用者: [udp_sendmsg, udplite_getfrag, ip_generic_getfrag, lock_sock, release_sock, fl6_sock_lookup, ip6_datagram_send_ctl, fl6_sock_release, fl6_merge_options, ipv6_fixup_options, fl6_update_dst, security_sk_classify_flow, ip6_sk_dst_lookup_flow, ip6_make_skb, udp_v6_send_skb, ip6_append_data, udp_v6_flush_pending_frames, udp_v6_push_pending_frames, ip6_dst_store, dst_release, dst_confirm]\n\n2. 函数名: udp_sendmsg\n- 参数: [struct sock *sk, struct msghdr *msg, size_t len]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n3. 函数名: udplite_getfrag\n- 参数: [void *, char *, int, int, int, struct sk_buff *]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n4. 函数名: ip_generic_getfrag\n- 参数: [void *, char *, int, int, int, struct sk_buff *]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n5. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n6. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n7. 函数名: fl6_sock_lookup\n- 参数: [struct sock *sk, fl6.flowlabel]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n8. 函数名: ip6_datagram_send_ctl\n- 参数: [sock_net(sk), sk, msg, &fl6, opt, &hlimit, &tclass, &dontfrag]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n9. 函数名: fl6_sock_release\n- 参数: [flowlabel]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n10. 函数名: fl6_merge_options\n- 参数: [&opt_space, flowlabel, opt]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n11. 函数名: ipv6_fixup_options\n- 参数: [&opt_space, opt]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n12. 函数名: fl6_update_dst\n- 参数: [&fl6, opt, &final]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n13. 函数名: security_sk_classify_flow\n- 参数: [sk, flowi6_to_flowi(&fl6)]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n14. 函数名: ip6_sk_dst_lookup_flow\n- 参数: [sk, &fl6, final_p]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n15. 函数名: ip6_make_skb\n- 参数: [sk, getfrag, msg, ulen, sizeof(struct udphdr), hlimit, tclass, opt, &fl6, (struct rt6_info *)dst, msg->msg_flags, dontfrag]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n16. 函数名: udp_v6_send_skb\n- 参数: [skb, &fl6]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n17. 函数名: ip6_append_data\n- 参数: [sk, getfrag, msg, ulen, sizeof(struct udphdr), hlimit, tclass, opt, &fl6, (struct rt6_info *)dst, corkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags, dontfrag]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n18. 函数名: udp_v6_flush_pending_frames\n- 参数: [sk]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n19. 函数名: udp_v6_push_pending_frames\n- 参数: [sk]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n20. 函数名: ip6_dst_store\n- 参数: [sk, dst, ipv6_addr_equal(&fl6.daddr, &sk->sk_v6_daddr) ? &sk->sk_v6_daddr : NULL, #ifdef CONFIG_IPV6_SUBTREES ipv6_addr_equal(&fl6.saddr, &np->saddr) ? &np->saddr : #endif NULL]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n21. 函数名: dst_release\n- 参数: [dst]\n- 调用者: udpv6_sendmsg\n- 被调用者: []\n\n22. 函数名: dst_confirm\n- 参数: [dst]\n- 调用者: udpv6_sendmsg\n- 被调用者: []"
    },
    {
        "id": 1009,
        "cwe": "CWE-416",
        "cve": "CVE-2016-3841",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中L2TP over IPv6协议的数据发送功能，处理消息头、地址验证、流标签管理和数据包发送等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核IPv6栈在处理选项数据时存在缺陷，导致本地用户可通过精心构造的sendmsg系统调用触发释放后重用漏洞，从而获取权限或造成系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: l2tp_ip6_sendmsg\n- 参数: [struct sock *sk, struct msghdr *msg, size_t len]\n- 调用者: 系统调用sendmsg\n- 被调用者: [fl6_sock_lookup, ip6_datagram_send_ctl, fl6_sock_release, fl6_merge_options, ipv6_fixup_options, fl6_update_dst, security_sk_classify_flow, ip6_dst_lookup_flow, ip6_sk_dst_hoplimit, ip6_append_data, ip6_flush_pending_frames, l2tp_ip6_push_pending_frames, dst_release, dst_confirm]\n\n2. 函数名: fl6_sock_lookup\n- 参数: [struct sock *sk, fl6.flowlabel]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n3. 函数名: ip6_datagram_send_ctl\n- 参数: [sock_net(sk), sk, msg, &fl6, opt, &hlimit, &tclass, &dontfrag]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n4. 函数名: fl6_sock_release\n- 参数: [flowlabel]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n5. 函数名: fl6_merge_options\n- 参数: [&opt_space, flowlabel, opt]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n6. 函数名: ipv6_fixup_options\n- 参数: [&opt_space, opt]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n7. 函数名: fl6_update_dst\n- 参数: [&fl6, opt, &final]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n8. 函数名: security_sk_classify_flow\n- 参数: [sk, flowi6_to_flowi(&fl6)]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n9. 函数名: ip6_dst_lookup_flow\n- 参数: [sk, &fl6, final_p]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n10. 函数名: ip6_sk_dst_hoplimit\n- 参数: [np, &fl6, dst]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n11. 函数名: ip6_append_data\n- 参数: [sk, ip_generic_getfrag, msg, ulen, transhdrlen, hlimit, tclass, opt, &fl6, (struct rt6_info *)dst, msg->msg_flags, dontfrag]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n12. 函数名: ip6_flush_pending_frames\n- 参数: [sk]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n13. 函数名: l2tp_ip6_push_pending_frames\n- 参数: [sk]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n14. 函数名: dst_release\n- 参数: [dst]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []\n\n15. 函数名: dst_confirm\n- 参数: [dst]\n- 调用者: l2tp_ip6_sendmsg\n- 被调用者: []"
    },
    {
        "id": 1035,
        "cwe": "CWE-416",
        "cve": "CVE-2016-4805",
        "purpose": "Code purpose:\"\"\"该代码用于注销PPP通道，包括释放相关资源、断开连接并从网络命名空间中移除通道\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放通道资源后未正确处理网络命名空间的引用，导致在移除网络命名空间时可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: ppp_unregister_channel\n- 参数: [struct ppp_channel *chan]\n- 调用者: 未明确（由系统调用或内核其他部分调用）\n- 被调用者: [down_write, spin_lock_bh, spin_unlock_bh, up_write, ppp_disconnect_channel, ppp_pernet, list_del, wake_up_interruptible, atomic_dec_and_test, ppp_destroy_channel]\n\n2. 函数名: down_write\n- 参数: [&pch->chan_sem]\n- 调用者: ppp_unregister_channel\n- 被调用者: []\n\n3. 函数名: spin_lock_bh\n- 参数: [&pch->downl], [&pn->all_channels_lock]\n- 调用者: ppp_unregister_channel\n- 被调用者: []\n\n4. 函数名: spin_unlock_bh\n- 参数: [&pch->downl], [&pn->all_channels_lock]\n- 调用者: ppp_unregister_channel\n- 被调用者: []\n\n5. 函数名: up_write\n- 参数: [&pch->chan_sem]\n- 调用者: ppp_unregister_channel\n- 被调用者: []\n\n6. 函数名: ppp_disconnect_channel\n- 参数: [pch]\n- 调用者: ppp_unregister_channel\n- 被调用者: []\n\n7. 函数名: ppp_pernet\n- 参数: [pch->chan_net]\n- 调用者: ppp_unregister_channel\n- 被调用者: []\n\n8. 函数名: list_del\n- 参数: [&pch->list]\n- 调用者: ppp_unregister_channel\n- 被调用者: []\n\n9. 函数名: wake_up_interruptible\n- 参数: [&pch->file.rwait]\n- 调用者: ppp_unregister_channel\n- 被调用者: []\n\n10. 函数名: atomic_dec_and_test\n- 参数: [&pch->file.refcnt]\n- 调用者: ppp_unregister_channel\n- 被调用者: []\n\n11. 函数名: ppp_destroy_channel\n- 参数: [pch]\n- 调用者: ppp_unregister_channel\n- 被调用者: []"
    },
    {
        "id": 1036,
        "cwe": "CWE-416",
        "cve": "CVE-2016-4805",
        "purpose": "Code purpose:\"\"\"注册PPP网络通道并将其添加到网络命名空间的新通道列表中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在移除网络命名空间时未正确处理ppp_register_net_channel和ppp_unregister_channel函数间的同步，导致释放后重用(use-after-free)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ppp_register_net_channel\n- 参数: [net, chan]\n- 调用者: 未显示\n- 被调用者: [kzalloc, ppp_pernet, init_ppp_file, init_rwsem, spin_lock_init, rwlock_init, spin_lock_bh, list_add, atomic_inc, spin_unlock_bh]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(struct channel), GFP_KERNEL]\n- 调用者: ppp_register_net_channel\n- 被调用者: 未显示\n\n3. 函数名: ppp_pernet\n- 参数: [net]\n- 调用者: ppp_register_net_channel\n- 被调用者: 未显示\n\n4. 函数名: init_ppp_file\n- 参数: [&pch->file, CHANNEL]\n- 调用者: ppp_register_net_channel\n- 被调用者: 未显示\n\n5. 函数名: init_rwsem\n- 参数: [&pch->chan_sem]\n- 调用者: ppp_register_net_channel\n- 被调用者: 未显示\n\n6. 函数名: spin_lock_init\n- 参数: [&pch->downl]\n- 调用者: ppp_register_net_channel\n- 被调用者: 未显示\n\n7. 函数名: rwlock_init\n- 参数: [&pch->upl]\n- 调用者: ppp_register_net_channel\n- 被调用者: 未显示\n\n8. 函数名: spin_lock_bh\n- 参数: [&pn->all_channels_lock]\n- 调用者: ppp_register_net_channel\n- 被调用者: 未显示\n\n9. 函数名: list_add\n- 参数: [&pch->list, &pn->new_channels]\n- 调用者: ppp_register_net_channel\n- 被调用者: 未显示\n\n10. 函数名: atomic_inc\n- 参数: [&channel_count]\n- 调用者: ppp_register_net_channel\n- 被调用者: 未显示\n\n11. 函数名: spin_unlock_bh\n- 参数: [&pn->all_channels_lock]\n- 调用者: ppp_register_net_channel\n- 被调用者: 未显示"
    },
    {
        "id": 1091,
        "cwe": "CWE-416",
        "cve": "CVE-2016-6828",
        "purpose": "Code purpose:\"\"\"检查并更新TCP发送队列头指针，防止因数据复制失败导致的SACK状态不一致问题\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核在维护TCP SACK状态时，未能正确处理数据复制失败后的sk_send_head指针，导致后续可能发生use-after-free问题\"\"\"",
        "functions": "Functions:\n1. 函数名: tcp_check_send_head\n- 参数: [sk, skb_unlinked]\n- 调用者: 未明确（可能是TCP协议栈中处理SACK选项的相关函数）\n- 被调用者: []"
    },
    {
        "id": 1109,
        "cwe": "CWE-416",
        "cve": "CVE-2016-7910",
        "purpose": "Code purpose:\"\"\"在停止磁盘序列文件操作时释放迭代器资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在disk_seqf_stop函数中，即使对应的start操作失败，仍会执行stop操作释放iter指针，导致后续可能发生use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: disk_seqf_stop\n- 参数: [struct seq_file *seqf, void *v]\n- 调用者: 未明确（由内核序列文件系统调用）\n- 被调用者: [class_dev_iter_exit, kfree]\n\n2. 函数名: class_dev_iter_exit\n- 参数: [struct class_dev_iter *iter]\n- 调用者: disk_seqf_stop\n- 被调用者: []\n\n3. 函数名: kfree\n- 参数: [void *ptr]\n- 调用者: disk_seqf_stop\n- 被调用者: []"
    },
    {
        "id": 1110,
        "cwe": "CWE-416",
        "cve": "CVE-2016-7911",
        "purpose": "Code purpose:\"\"\"获取指定任务的I/O优先级值，包括安全检查并返回默认或任务特定的I/O优先级\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在get_task_ioprio函数中访问p->io_context时存在竞态条件，可能导致在释放io_context后仍被访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: get_task_ioprio\n- 参数: [struct task_struct *p]\n- 调用者: 未明确显示（由系统调用ioprio_get触发）\n- 被调用者: [security_task_getioprio, IOPRIO_PRIO_VALUE]\n\n2. 函数名: security_task_getioprio\n- 参数: [struct task_struct *p]\n- 调用者: get_task_ioprio\n- 被调用者: []\n\n3. 函数名: IOPRIO_PRIO_VALUE\n- 参数: [IOPRIO_CLASS_NONE, IOPRIO_NORM]（宏参数）\n- 调用者: get_task_ioprio\n- 被调用者: []"
    },
    {
        "id": 1111,
        "cwe": "CWE-416",
        "cve": "CVE-2016-7912",
        "purpose": "Code purpose:\"\"\"该代码用于处理USB功能文件系统(FFS)中的用户空间I/O数据拷贝工作，包括数据拷贝、完成回调通知和资源释放等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ffs_user_copy_worker函数中，io_data结构体在回调函数ki_complete执行后被释放，但回调函数可能仍会访问该结构体，导致释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ffs_user_copy_worker\n- 参数: [work]\n- 调用者: N/A (workqueue callback)\n- 被调用者: [container_of, use_mm, copy_to_iter, iov_iter_count, unuse_mm, eventfd_signal, usb_ep_free_request, kfree]\n\n2. 函数名: container_of\n- 参数: [work, struct ffs_io_data, work]\n- 调用者: ffs_user_copy_worker\n- 被调用者: N/A\n\n3. 函数名: use_mm\n- 参数: [io_data->mm]\n- 调用者: ffs_user_copy_worker\n- 被调用者: N/A\n\n4. 函数名: copy_to_iter\n- 参数: [io_data->buf, ret, &io_data->data]\n- 调用者: ffs_user_copy_worker\n- 被调用者: N/A\n\n5. 函数名: iov_iter_count\n- 参数: [&io_data->data]\n- 调用者: ffs_user_copy_worker\n- 被调用者: N/A\n\n6. 函数名: unuse_mm\n- 参数: [io_data->mm]\n- 调用者: ffs_user_copy_worker\n- 被调用者: N/A\n\n7. 函数名: eventfd_signal\n- 参数: [io_data->ffs->ffs_eventfd, 1]\n- 调用者: ffs_user_copy_worker\n- 被调用者: N/A\n\n8. 函数名: usb_ep_free_request\n- 参数: [io_data->ep, io_data->req]\n- 调用者: ffs_user_copy_worker\n- 被调用者: N/A\n\n9. 函数名: kfree\n- 参数: [io_data->to_free], [io_data->buf], [io_data]\n- 调用者: ffs_user_copy_worker\n- 被调用者: N/A"
    },
    {
        "id": 1112,
        "cwe": "CWE-416",
        "cve": "CVE-2016-7913",
        "purpose": "Code purpose:\"\"\"该代码用于配置xc2028调谐器的参数，包括处理固件名称的复制和更新，并请求加载新的固件。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放priv->ctrl.fname后未正确检查p->fname是否为NULL，导致可能发生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: xc2028_set_config\n- 参数: [struct dvb_frontend *fe, void *priv_cfg]\n- 调用者: 未明确显示（由内核其他部分调用）\n- 被调用者: [mutex_lock, kfree, memcpy, kstrdup, free_firmware, strcmp, request_firmware_nowait, mutex_unlock]\n\n2. 函数名: tuner_dbg\n- 参数: [const char *fmt, ...]\n- 调用者: xc2028_set_config\n- 被调用者: []\n\n3. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: xc2028_set_config\n- 被调用者: []\n\n4. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: xc2028_set_config\n- 被调用者: []\n\n5. 函数名: memcpy\n- 参数: [void *to, const void *from, __kernel_size_t n]\n- 调用者: xc2028_set_config\n- 被调用者: []\n\n6. 函数名: kstrdup\n- 参数: [const char *s, gfp_t gfp]\n- 调用者: xc2028_set_config\n- 被调用者: []\n\n7. 函数名: free_firmware\n- 参数: [struct xc2028_data *priv]\n- 调用者: xc2028_set_config\n- 被调用者: []\n\n8. 函数名: strcmp\n- 参数: [const char *cs, const char *ct]\n- 调用者: xc2028_set_config\n- 被调用者: []\n\n9. 函数名: request_firmware_nowait\n- 参数: [struct module *module, int uevent, const char *name, struct device *device, gfp_t gfp, void *context, void (*cont)(const struct firmware *fw, void *context)]\n- 调用者: xc2028_set_config\n- 被调用者: []\n\n10. 函数名: tuner_err\n- 参数: [const char *fmt, ...]\n- 调用者: xc2028_set_config\n- 被调用者: []\n\n11. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: xc2028_set_config\n- 被调用者: []\n\n12. 函数名: load_firmware_cb\n- 参数: [const struct firmware *fw, void *context]\n- 调用者: request_firmware_nowait\n- 被调用者: []"
    },
    {
        "id": 1131,
        "cwe": "CWE-416",
        "cve": "CVE-2016-8655",
        "purpose": "Code purpose:\"\"\"该代码用于设置和管理Linux内核中AF_PACKET套接字的环形缓冲区，处理接收和发送数据包的相关配置和资源分配。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中的packet_set_ring函数存在竞态条件，当本地用户利用CAP_NET_RAW能力更改socket版本时，可能导致use-after-free漏洞，从而引发权限提升或拒绝服务。\"\"\"",
        "functions": "Functions:\n1. 函数名: packet_set_ring\n- 参数: [struct sock *sk, union tpacket_req_u *req_u, int closing, int tx_ring]\n- 调用者: N/A (顶层函数)\n- 被调用者: [pkt_sk, net_warn_ratelimited, atomic_read, packet_read_pending, PAGE_ALIGNED, get_order, alloc_pg_vec, init_prb_bdqc, lock_sock, __unregister_prot_hook, synchronize_net, mutex_lock, spin_lock_bh, spin_unlock_bh, mutex_unlock, register_prot_hook, prb_shutdown_retire_blk_timer, release_sock, free_pg_vec]\n\n2. 函数名: pkt_sk\n- 参数: [struct sock *sk]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n3. 函数名: net_warn_ratelimited\n- 参数: [const char *fmt, ...]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n4. 函数名: atomic_read\n- 参数: [const atomic_t *v]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n5. 函数名: packet_read_pending\n- 参数: [struct packet_ring_buffer *rb]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n6. 函数名: PAGE_ALIGNED\n- 参数: [unsigned long addr]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n7. 函数名: get_order\n- 参数: [unsigned long size]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n8. 函数名: alloc_pg_vec\n- 参数: [struct tpacket_req *req, int order]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n9. 函数名: init_prb_bdqc\n- 参数: [struct packet_sock *po, struct packet_ring_buffer *rb, struct pgv *pg_vec, union tpacket_req_u *req_u]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n10. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n11. 函数名: __unregister_prot_hook\n- 参数: [struct sock *sk, bool sync]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n12. 函数名: synchronize_net\n- 参数: []\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n13. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n14. 函数名: spin_lock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n15. 函数名: spin_unlock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n16. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n17. 函数名: register_prot_hook\n- 参数: [struct sock *sk]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n18. 函数名: prb_shutdown_retire_blk_timer\n- 参数: [struct packet_sock *po, struct sk_buff_head *rb_queue]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n19. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: packet_set_ring\n- 被调用者: N/A\n\n20. 函数名: free_pg_vec\n- 参数: [struct pgv *pg_vec, int order, int len]\n- 调用者: packet_set_ring\n- 被调用者: N/A"
    },
    {
        "id": 1132,
        "cwe": "CWE-416",
        "cve": "CVE-2016-8655",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中AF_PACKET套接字的选项设置功能，包括成员管理、环形缓冲区配置、版本控制等网络包处理操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中的packet_setsockopt函数存在竞态条件漏洞，允许本地用户通过CAP_NET_RAW能力更改socket版本，导致packet_set_ring和packet_setsockopt函数之间的使用后释放问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: packet_setsockopt\n- 参数: [struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen]\n- 调用者: 未显示（系统调用）\n- 被调用者: [pkt_sk, memset, copy_from_user, packet_mc_add, packet_mc_drop, packet_set_ring, fanout_add, fanout_set_data]\n\n2. 函数名: pkt_sk\n- 参数: [struct sock *sk]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n3. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n4. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n5. 函数名: packet_mc_add\n- 参数: [struct sock *sk, struct packet_mreq_max *mreq]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n6. 函数名: packet_mc_drop\n- 参数: [struct sock *sk, struct packet_mreq_max *mreq]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n7. 函数名: packet_set_ring\n- 参数: [struct sock *sk, union tpacket_req_u *req_u, int flag, int tx_ring]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n8. 函数名: fanout_add\n- 参数: [struct sock *sk, int val1, int val2]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示\n\n9. 函数名: fanout_set_data\n- 参数: [struct packet_sock *po, char __user *optval, unsigned int optlen]\n- 调用者: packet_setsockopt\n- 被调用者: 未显示"
    },
    {
        "id": 1139,
        "cwe": "CWE-416",
        "cve": "CVE-2016-9120",
        "purpose": "Code purpose:\"\"\"释放ION内存客户端中的句柄资源并验证其有效性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放ION句柄时存在竞态条件，当两个CPU同时调用ION_IOC_FREE时可能导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ion_free\n- 参数: [struct ion_client *client, struct ion_handle *handle]\n- 调用者: 未明确显示（可能是ION_IOC_FREE的调用者）\n- 被调用者: [ion_handle_validate, ion_handle_put]\n\n2. 函数名: ion_handle_validate\n- 参数: [struct ion_client *client, struct ion_handle *handle]\n- 调用者: ion_free\n- 被调用者: []\n\n3. 函数名: ion_handle_put\n- 参数: [struct ion_handle *handle]\n- 调用者: ion_free\n- 被调用者: []\n\n4. 函数名: mutex_lock\n- 参数: [&client->lock]\n- 调用者: ion_free\n- 被调用者: []\n\n5. 函数名: mutex_unlock\n- 参数: [&client->lock]\n- 调用者: ion_free\n- 被调用者: []"
    },
    {
        "id": 1140,
        "cwe": "CWE-416",
        "cve": "CVE-2016-9120",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中ION内存管理子系统的ioctl接口，用于处理内存分配、释放、共享等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当两个CPU同时调用ION_IOC_FREE时，由于缺乏适当的同步机制，导致ion_handle_get_by_id和ion_free之间存在竞争条件，可能引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ion_ioctl\n- 参数: [struct file *filp, unsigned int cmd, unsigned long arg]\n- 调用者: 无（系统调用接口）\n- 被调用者: [ion_ioctl_dir, _IOC_SIZE, copy_from_user, ion_alloc, PTR_ERR, ion_handle_get_by_id, ion_free, ion_handle_put, ion_share_dma_buf_fd, ion_import_dma_buf_fd, ion_sync_for_device, copy_to_user]\n\n2. 函数名: ion_ioctl_dir\n- 参数: [unsigned int cmd]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n3. 函数名: _IOC_SIZE\n- 参数: [unsigned int cmd]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n4. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n5. 函数名: ion_alloc\n- 参数: [struct ion_client *client, size_t len, size_t align, unsigned int heap_id_mask, unsigned int flags]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n6. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n7. 函数名: ion_handle_get_by_id\n- 参数: [struct ion_client *client, int id]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n8. 函数名: ion_free\n- 参数: [struct ion_client *client, struct ion_handle *handle]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n9. 函数名: ion_handle_put\n- 参数: [struct ion_handle *handle]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n10. 函数名: ion_share_dma_buf_fd\n- 参数: [struct ion_client *client, struct ion_handle *handle]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n11. 函数名: ion_import_dma_buf_fd\n- 参数: [struct ion_client *client, int fd]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n12. 函数名: ion_sync_for_device\n- 参数: [struct ion_client *client, int fd]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n13. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: ion_ioctl\n- 被调用者: 无"
    },
    {
        "id": 1141,
        "cwe": "CWE-416",
        "cve": "CVE-2016-9120",
        "purpose": "Code purpose:\"\"\"该代码用于通过减少引用计数来安全释放ION内存句柄，并在引用计数归零时销毁句柄\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多CPU并发调用ION_IOC_FREE时，ion_handle_put函数中的互斥锁保护不足，导致存在竞争条件可能引发use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ion_handle_put\n- 参数: [struct ion_handle *handle]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [mutex_lock, kref_put, mutex_unlock]\n\n2. 函数名: mutex_lock\n- 参数: [&client->lock]\n- 调用者: ion_handle_put\n- 被调用者: []\n\n3. 函数名: kref_put\n- 参数: [&handle->ref, ion_handle_destroy]\n- 调用者: ion_handle_put\n- 被调用者: [ion_handle_destroy]\n\n4. 函数名: mutex_unlock\n- 参数: [&client->lock]\n- 调用者: ion_handle_put\n- 被调用者: []\n\n5. 函数名: ion_handle_destroy\n- 参数: 未明确（通过kref_put间接调用）\n- 调用者: kref_put\n- 被调用者: []"
    },
    {
        "id": 1142,
        "cwe": "CWE-416",
        "cve": "CVE-2016-9120",
        "purpose": "Code purpose:\"\"\"通过ID查找并获取ion_handle结构体引用，同时处理并发访问\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多CPU并发调用ION_IOC_FREE时，缺乏对ion_handle_get_by_id函数中handle引用的充分保护，导致可能发生use-after-free情况。\"\"\"",
        "functions": "Functions:\n1. 函数名: ion_handle_get_by_id\n- 参数: [struct ion_client *client, int id]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [mutex_lock, idr_find, ion_handle_get, mutex_unlock, ERR_PTR]\n\n2. 函数名: mutex_lock\n- 参数: [&client->lock]\n- 调用者: ion_handle_get_by_id\n- 被调用者: []\n\n3. 函数名: idr_find\n- 参数: [&client->idr, id]\n- 调用者: ion_handle_get_by_id\n- 被调用者: []\n\n4. 函数名: ion_handle_get\n- 参数: [handle]\n- 调用者: ion_handle_get_by_id\n- 被调用者: []\n\n5. 函数名: mutex_unlock\n- 参数: [&client->lock]\n- 调用者: ion_handle_get_by_id\n- 被调用者: []\n\n6. 函数名: ERR_PTR\n- 参数: [-EINVAL]\n- 调用者: ion_handle_get_by_id\n- 被调用者: []"
    },
    {
        "id": 1146,
        "cwe": "CWE-416",
        "cve": "CVE-2016-9576",
        "purpose": "Code purpose:\"\"\"该代码用于将用户空间的I/O向量请求映射到内核空间的块设备请求，处理数据传输的映射和复制操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中的blk_rq_map_user_iov函数未能正确限制迭代器类型，导致本地用户可通过访问/dev/sg设备读写任意内核内存或引发拒绝服务（释放后重用）。\"\"\"",
        "functions": "Functions:\n1. 函数名: blk_rq_map_user_iov\n- 参数: [q, rq, map_data, iter, gfp_mask]\n- 调用者: N/A\n- 被调用者: [iov_iter_alignment, queue_dma_alignment, queue_virt_boundary, iov_iter_gap_alignment, __blk_rq_map_user_iov, iov_iter_count, bio_flagged, __blk_rq_unmap_user]\n\n2. 函数名: iov_iter_alignment\n- 参数: [iter]\n- 调用者: blk_rq_map_user_iov\n- 被调用者: N/A\n\n3. 函数名: queue_dma_alignment\n- 参数: [q]\n- 调用者: blk_rq_map_user_iov\n- 被调用者: N/A\n\n4. 函数名: queue_virt_boundary\n- 参数: [q]\n- 调用者: blk_rq_map_user_iov\n- 被调用者: N/A\n\n5. 函数名: iov_iter_gap_alignment\n- 参数: [iter]\n- 调用者: blk_rq_map_user_iov\n- 被调用者: N/A\n\n6. 函数名: __blk_rq_map_user_iov\n- 参数: [rq, map_data, i, gfp_mask, copy]\n- 调用者: blk_rq_map_user_iov\n- 被调用者: N/A\n\n7. 函数名: iov_iter_count\n- 参数: [i]\n- 调用者: blk_rq_map_user_iov\n- 被调用者: N/A\n\n8. 函数名: bio_flagged\n- 参数: [bio, BIO_USER_MAPPED]\n- 调用者: blk_rq_map_user_iov\n- 被调用者: N/A\n\n9. 函数名: __blk_rq_unmap_user\n- 参数: [bio]\n- 调用者: blk_rq_map_user_iov\n- 被调用者: N/A"
    },
    {
        "id": 1168,
        "cwe": "CWE-416",
        "cve": "CVE-2016-9794",
        "purpose": "Code purpose:\"\"\"该代码用于处理音频PCM子流周期中断事件，更新硬件指针位置并触发定时器中断，最后通知异步I/O事件\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在snd_pcm_period_elapsed函数中存在竞态条件，当处理SNDRV_PCM_TRIGGER_START命令时可能导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_pcm_period_elapsed\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: 未明确（由系统或驱动调用）\n- 被调用者: [PCM_RUNTIME_CHECK, snd_pcm_stream_lock_irqsave, snd_pcm_running, snd_pcm_update_hw_ptr0, snd_timer_interrupt, snd_pcm_stream_unlock_irqrestore, kill_fasync]\n\n2. 函数名: PCM_RUNTIME_CHECK\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n3. 函数名: snd_pcm_stream_lock_irqsave\n- 参数: [struct snd_pcm_substream *substream, unsigned long flags]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n4. 函数名: snd_pcm_running\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n5. 函数名: snd_pcm_update_hw_ptr0\n- 参数: [struct snd_pcm_substream *substream, int in_interrupt]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n6. 函数名: snd_timer_interrupt\n- 参数: [struct snd_timer *timer, int ticks]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n7. 函数名: snd_pcm_stream_unlock_irqrestore\n- 参数: [struct snd_pcm_substream *substream, unsigned long flags]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []\n\n8. 函数名: kill_fasync\n- 参数: [struct fasync_struct **fp, int sig, int band]\n- 调用者: snd_pcm_period_elapsed\n- 被调用者: []"
    },
    {
        "id": 1175,
        "cwe": "CWE-416",
        "cve": "CVE-2017-0861",
        "purpose": "Code purpose:\"\"\"处理ALSA子系统中的PCM设备控制IOCTL命令，包括获取下一个设备、获取PCM信息以及设置首选子设备等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放互斥锁后未正确验证或保护指针的使用，导致在snd_pcm_info_user函数中可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_pcm_control_ioctl\n- 参数: [struct snd_card *card, struct snd_ctl_file *control, unsigned int cmd, unsigned long arg]\n- 调用者: 未显示（由系统调用触发）\n- 被调用者: [get_user, mutex_lock, snd_pcm_next, mutex_unlock, put_user, snd_pcm_get, snd_pcm_info_user]\n\n2. 函数名: get_user\n- 参数: [device, (int __user *)arg]\n- 调用者: snd_pcm_control_ioctl\n- 被调用者: 未显示（内核函数）\n\n3. 函数名: mutex_lock\n- 参数: [&register_mutex]\n- 调用者: snd_pcm_control_ioctl\n- 被调用者: 未显示（内核同步原语）\n\n4. 函数名: snd_pcm_next\n- 参数: [card, device]\n- 调用者: snd_pcm_control_ioctl\n- 被调用者: 未显示（内核ALSA子系统函数）\n\n5. 函数名: mutex_unlock\n- 参数: [&register_mutex]\n- 调用者: snd_pcm_control_ioctl\n- 被调用者: 未显示（内核同步原语）\n\n6. 函数名: put_user\n- 参数: [device, (int __user *)arg]\n- 调用者: snd_pcm_control_ioctl\n- 被调用者: 未显示（内核函数）\n\n7. 函数名: snd_pcm_get\n- 参数: [card, device]\n- 调用者: snd_pcm_control_ioctl\n- 被调用者: 未显示（内核ALSA子系统函数）\n\n8. 函数名: snd_pcm_info_user\n- 参数: [substream, info]\n- 调用者: snd_pcm_control_ioctl\n- 被调用者: 未显示（内核ALSA子系统函数）"
    },
    {
        "id": 1242,
        "cwe": "CWE-416",
        "cve": "CVE-2017-10661",
        "purpose": "Code purpose:\"\"\"该代码用于设置timerfd的取消功能，根据时钟类型和标志位决定是否将定时器上下文添加到取消列表或从中移除。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多线程环境下对might_cancel标志和取消列表的操作缺乏适当的同步保护，导致竞争条件可能引发列表损坏或释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: timerfd_setup_cancel\n- 参数: [struct timerfd_ctx *ctx, int flags]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [spin_lock, list_add_rcu, spin_unlock, timerfd_remove_cancel]\n\n2. 函数名: spin_lock\n- 参数: [&cancel_lock]\n- 调用者: timerfd_setup_cancel\n- 被调用者: []\n\n3. 函数名: list_add_rcu\n- 参数: [&ctx->clist, &cancel_list]\n- 调用者: timerfd_setup_cancel\n- 被调用者: []\n\n4. 函数名: spin_unlock\n- 参数: [&cancel_lock]\n- 调用者: timerfd_setup_cancel\n- 被调用者: []\n\n5. 函数名: timerfd_remove_cancel\n- 参数: [ctx]\n- 调用者: timerfd_setup_cancel\n- 被调用者: []"
    },
    {
        "id": 1243,
        "cwe": "CWE-416",
        "cve": "CVE-2017-10661",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中的timerfd_create系统调用，用于创建一个定时器文件描述符，允许用户空间程序通过文件描述符接口来接收定时事件通知。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于timerfd_create函数中存在竞态条件，当多个文件描述符操作同时进行时，可能导致队列管理不当，引发列表损坏或释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: SYSCALL_DEFINE2(timerfd_create)\n- 参数: [int clockid, int flags]\n- 调用者: 系统调用\n- 被调用者: [kzalloc, init_waitqueue_head, isalarm, alarm_init, hrtimer_init, ktime_mono_to_real, anon_inode_getfd, kfree]\n\n2. 函数名: BUILD_BUG_ON\n- 参数: [condition]\n- 调用者: SYSCALL_DEFINE2(timerfd_create)\n- 被调用者: []\n\n3. 函数名: capable\n- 参数: [CAP_WAKE_ALARM]\n- 调用者: SYSCALL_DEFINE2(timerfd_create)\n- 被调用者: []\n\n4. 函数名: kzalloc\n- 参数: [sizeof(*ctx), GFP_KERNEL]\n- 调用者: SYSCALL_DEFINE2(timerfd_create)\n- 被调用者: []\n\n5. 函数名: init_waitqueue_head\n- 参数: [&ctx->wqh]\n- 调用者: SYSCALL_DEFINE2(timerfd_create)\n- 被调用者: []\n\n6. 函数名: isalarm\n- 参数: [ctx]\n- 调用者: SYSCALL_DEFINE2(timerfd_create)\n- 被调用者: []\n\n7. 函数名: alarm_init\n- 参数: [&ctx->t.alarm, ALARM_REALTIME/ALARM_BOOTTIME, timerfd_alarmproc]\n- 调用者: SYSCALL_DEFINE2(timerfd_create)\n- 被调用者: []\n\n8. 函数名: hrtimer_init\n- 参数: [&ctx->t.tmr, clockid, HRTIMER_MODE_ABS]\n- 调用者: SYSCALL_DEFINE2(timerfd_create)\n- 被调用者: []\n\n9. 函数名: ktime_mono_to_real\n- 参数: [0]\n- 调用者: SYSCALL_DEFINE2(timerfd_create)\n- 被调用者: []\n\n10. 函数名: anon_inode_getfd\n- 参数: [\"[timerfd]\", &timerfd_fops, ctx, O_RDWR | (flags & TFD_SHARED_FCNTL_FLAGS)]\n- 调用者: SYSCALL_DEFINE2(timerfd_create)\n- 被调用者: []\n\n11. 函数名: kfree\n- 参数: [ctx]\n- 调用者: SYSCALL_DEFINE2(timerfd_create)\n- 被调用者: []"
    },
    {
        "id": 1244,
        "cwe": "CWE-416",
        "cve": "CVE-2017-10661",
        "purpose": "Code purpose:\"\"\"该代码用于在取消定时器文件描述符操作时，从取消队列中安全移除上下文对象并防止竞态条件\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于timerfd_remove_cancel函数在多线程环境下对ctx->might_cancel标志和链表操作缺乏原子性保护，导致竞争条件可能引发链表损坏或释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: timerfd_remove_cancel\n- 参数: [struct timerfd_ctx *ctx]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [spin_lock, list_del_rcu, spin_unlock]"
    },
    {
        "id": 1249,
        "cwe": "CWE-416",
        "cve": "CVE-2017-11176",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中消息队列的通知机制，允许用户空间程序通过信号、线程或空操作等方式接收队列通知，并处理相关套接字资源。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在重试逻辑中未将sock指针置为NULL，导致用户空间关闭Netlink套接字时可能引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: do_mq_notify\n- 参数: [mqd_t mqdes, const struct sigevent *notification]\n- 调用者: 无（内核函数）\n- 被调用者: [audit_mq_notify, valid_signal, alloc_skb, copy_from_user, skb_put, fdget, netlink_getsockbyfilp, fdput, netlink_attachskb, file_inode, current_time, remove_notification, get_pid, get_user_ns, spin_lock, spin_unlock, netlink_detachskb, dev_kfree_skb]\n\n2. 函数名: audit_mq_notify\n- 参数: [mqd_t mqdes, const struct sigevent *notification]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n3. 函数名: valid_signal\n- 参数: [int sig]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n4. 函数名: alloc_skb\n- 参数: [unsigned int size, gfp_t priority]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n5. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n6. 函数名: skb_put\n- 参数: [struct sk_buff *skb, unsigned int len]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n7. 函数名: fdget\n- 参数: [int fd]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n8. 函数名: netlink_getsockbyfilp\n- 参数: [struct file *filp]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n9. 函数名: fdput\n- 参数: [struct fd fd]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n10. 函数名: netlink_attachskb\n- 参数: [struct sock *sk, struct sk_buff *skb, long *timeo, struct sock *ssk]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n11. 函数名: file_inode\n- 参数: [const struct file *file]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n12. 函数名: current_time\n- 参数: [struct inode *inode]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n13. 函数名: remove_notification\n- 参数: [struct mqueue_inode_info *info]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n14. 函数名: get_pid\n- 参数: [struct pid *pid]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n15. 函数名: get_user_ns\n- 参数: [struct user_namespace *ns]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n16. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n17. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n18. 函数名: netlink_detachskb\n- 参数: [struct sock *sk, struct sk_buff *skb]\n- 调用者: do_mq_notify\n- 被调用者: []\n\n19. 函数名: dev_kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: do_mq_notify\n- 被调用者: []"
    },
    {
        "id": 1289,
        "cwe": "CWE-416",
        "cve": "CVE-2017-15115",
        "purpose": "Code purpose:\"\"\"该代码用于在SCTP协议中实现将一个关联(association)从原始socket分离(peel-off)到新socket的功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"sctp_do_peeloff函数在执行peel-off操作时未验证目标网络命名空间(netns)是否匹配，导致可能发生跨命名空间的资源访问\"\"\"",
        "functions": "Functions:\n1. 函数名: sctp_do_peeloff\n- 参数: [struct sock *sk, sctp_assoc_t id, struct socket **sockp]\n- 调用者: 未显示\n- 被调用者: [sctp_id2assoc, sctp_sk, sock_create, sctp_copy_sock, sp->pf->to_sk_daddr, sctp_sock_migrate]\n\n2. 函数名: sctp_id2assoc\n- 参数: [struct sock *sk, sctp_assoc_t id]\n- 调用者: sctp_do_peeloff\n- 被调用者: 未显示\n\n3. 函数名: sctp_sk\n- 参数: [struct sock *sk]\n- 调用者: sctp_do_peeloff\n- 被调用者: 未显示\n\n4. 函数名: sock_create\n- 参数: [sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock]\n- 调用者: sctp_do_peeloff\n- 被调用者: 未显示\n\n5. 函数名: sctp_copy_sock\n- 参数: [sock->sk, sk, asoc]\n- 调用者: sctp_do_peeloff\n- 被调用者: 未显示\n\n6. 函数名: to_sk_daddr\n- 参数: [&asoc->peer.primary_addr, sk]\n- 调用者: sctp_do_peeloff (通过sp->pf->to_sk_daddr)\n- 被调用者: 未显示\n\n7. 函数名: sctp_sock_migrate\n- 参数: [sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH]\n- 调用者: sctp_do_peeloff\n- 被调用者: 未显示"
    },
    {
        "id": 1300,
        "cwe": "CWE-416",
        "cve": "CVE-2017-15265",
        "purpose": "Code purpose:\"\"\"该代码用于处理ALSA子系统中的序列端口创建请求，包括权限检查、端口创建、回调函数设置以及端口信息更新等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在ALSA子系统中存在竞态条件，当处理/dev/snd/seq的ioctl调用时，可能导致使用后释放(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_seq_ioctl_create_port\n- 参数: [struct snd_seq_client *client, void *arg]\n- 调用者: 未指定（由ioctl调用触发）\n- 被调用者: [snd_seq_create_port, snd_seq_delete_port, snd_seq_set_port_info, snd_seq_system_client_ev_port_start]\n\n2. 函数名: snd_seq_create_port\n- 参数: [struct snd_seq_client *client, int port]\n- 调用者: snd_seq_ioctl_create_port\n- 被调用者: 未指定\n\n3. 函数名: snd_seq_delete_port\n- 参数: [struct snd_seq_client *client, int port]\n- 调用者: snd_seq_ioctl_create_port\n- 被调用者: 未指定\n\n4. 函数名: snd_seq_set_port_info\n- 参数: [struct snd_seq_client_port *port, struct snd_seq_port_info *info]\n- 调用者: snd_seq_ioctl_create_port\n- 被调用者: 未指定\n\n5. 函数名: snd_seq_system_client_ev_port_start\n- 参数: [int client, int port]\n- 调用者: snd_seq_ioctl_create_port\n- 被调用者: 未指定"
    },
    {
        "id": 1301,
        "cwe": "CWE-416",
        "cve": "CVE-2017-15265",
        "purpose": "Code purpose:\"\"\"创建一个新的ALSA序列端口并初始化其数据结构，同时管理客户端端口列表\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ALSA子系统中存在竞态条件，当处理/dev/snd/seq的ioctl调用时，由于对端口资源的创建和管理缺乏适当的同步保护，可能导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_seq_create_port\n- 参数: [struct snd_seq_client *client, int port]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [snd_BUG_ON, pr_warn, kzalloc, sprintf, snd_use_lock_init, port_subs_info_init, mutex_lock, write_lock_irqsave, list_for_each_entry, list_add_tail, write_unlock_irqrestore, mutex_unlock]\n\n2. 函数名: snd_BUG_ON\n- 参数: [!client]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n3. 函数名: pr_warn\n- 参数: [\"ALSA: seq: too many ports for client %d\\n\", client->number]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n4. 函数名: kzalloc\n- 参数: [sizeof(*new_port), GFP_KERNEL]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n5. 函数名: sprintf\n- 参数: [new_port->name, \"port-%d\", num]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n6. 函数名: snd_use_lock_init\n- 参数: [&new_port->use_lock]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n7. 函数名: port_subs_info_init\n- 参数: [&new_port->c_src]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n8. 函数名: port_subs_info_init\n- 参数: [&new_port->c_dest]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n9. 函数名: mutex_lock\n- 参数: [&client->ports_mutex]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n10. 函数名: write_lock_irqsave\n- 参数: [&client->ports_lock, flags]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n11. 函数名: list_for_each_entry\n- 参数: [p, &client->ports_list_head, list]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n12. 函数名: list_add_tail\n- 参数: [&new_port->list, &p->list]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n13. 函数名: write_unlock_irqrestore\n- 参数: [&client->ports_lock, flags]\n- 调用者: snd_seq_create_port\n- 被调用者: []\n\n14. 函数名: mutex_unlock\n- 参数: [&client->ports_mutex]\n- 调用者: snd_seq_create_port\n- 被调用者: []"
    },
    {
        "id": 1309,
        "cwe": "CWE-416",
        "cve": "CVE-2017-16525",
        "purpose": "Code purpose:\"\"\"该代码用于设置USB串行控制台，包括配置波特率、数据位、校验位等参数，并处理USB设备的连接和初始化。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在USB控制台设置过程中，当设备断开连接或设置失败时，未能正确处理tty结构体的引用计数和内存释放，导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: usb_console_setup\n- 参数: [struct console *co, char *options]\n- 调用者: 未明确显示（通常由console子系统调用）\n- 被调用者: [simple_strtoul, usb_serial_port_get_by_minor, usb_autopm_get_interface, tty_port_tty_set, kzalloc, kref_init, init_ldsem, spin_lock_init, INIT_LIST_HEAD, kref_get, __module_get, tty_init_termios, tty_termios_encode_baud_rate, memset, tty_kref_put, tty_port_set_initialized, usb_autopm_put_interface, usb_serial_put, mutex_unlock]\n\n2. 函数名: simple_strtoul\n- 参数: [const char *nptr, char **endptr, int base]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n3. 函数名: usb_serial_port_get_by_minor\n- 参数: [int minor]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n4. 函数名: usb_autopm_get_interface\n- 参数: [struct usb_interface *intf]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n5. 函数名: tty_port_tty_set\n- 参数: [struct tty_port *port, struct tty_struct *tty]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n6. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n7. 函数名: kref_init\n- 参数: [struct kref *kref]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n8. 函数名: init_ldsem\n- 参数: [struct ld_semaphore *sem]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n9. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n10. 函数名: INIT_LIST_HEAD\n- 参数: [struct list_head *list]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n11. 函数名: kref_get\n- 参数: [struct kref *kref]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n12. 函数名: __module_get\n- 参数: [struct module *module]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n13. 函数名: tty_init_termios\n- 参数: [struct tty_struct *tty]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n14. 函数名: tty_termios_encode_baud_rate\n- 参数: [struct ktermios *termios, speed_t ibaud, speed_t obaud]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n15. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n16. 函数名: tty_kref_put\n- 参数: [struct tty_struct *tty]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n17. 函数名: tty_port_set_initialized\n- 参数: [struct tty_port *port, bool val]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n18. 函数名: usb_autopm_put_interface\n- 参数: [struct usb_interface *intf]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n19. 函数名: usb_serial_put\n- 参数: [struct usb_serial *serial]\n- 调用者: usb_console_setup\n- 被调用者: []\n\n20. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: usb_console_setup\n- 被调用者: []"
    },
    {
        "id": 1312,
        "cwe": "CWE-416",
        "cve": "CVE-2017-16527",
        "purpose": "Code purpose:\"\"\"释放USB音频混音器接口相关的内存资源，包括元素ID、URB传输缓冲区和设置包等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放mixer资源时未正确处理urb和rc_urb的释放顺序，导致可能发生use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_usb_mixer_free\n- 参数: [struct usb_mixer_interface *mixer]\n- 调用者: 未明确（由系统调用）\n- 被调用者: [kfree, usb_free_urb]\n\n2. 函数名: kfree\n- 参数: [void *ptr]\n- 调用者: snd_usb_mixer_free\n- 被调用者: []\n\n3. 函数名: usb_free_urb\n- 参数: [struct urb *urb]\n- 调用者: snd_usb_mixer_free\n- 被调用者: []"
    },
    {
        "id": 1313,
        "cwe": "CWE-416",
        "cve": "CVE-2017-16527",
        "purpose": "Code purpose:\"\"\"在USB音频设备断开连接时终止相关的URB(USB请求块)传输\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在snd_usb_mixer_disconnect函数中，由于没有正确处理mixer对象的生命周期，导致在usb_kill_urb调用后可能出现use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_usb_mixer_disconnect\n- 参数: [struct usb_mixer_interface *mixer]\n- 调用者: 未明确（由系统调用）\n- 被调用者: [usb_kill_urb, usb_kill_urb]\n\n2. 函数名: usb_kill_urb\n- 参数: [struct urb *urb] (通过mixer->urb和mixer->rc_urb传递)\n- 调用者: snd_usb_mixer_disconnect\n- 被调用者: []"
    },
    {
        "id": 1314,
        "cwe": "CWE-416",
        "cve": "CVE-2017-16528",
        "purpose": "Code purpose:\"\"\"释放序列设备资源并减少设备引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放设备资源时未正确处理引用计数，导致后续可能发生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_seq_device_dev_free\n- 参数: [struct snd_device *device]\n- 调用者: 未明确（由Linux内核设备子系统调用）\n- 被调用者: [put_device]"
    },
    {
        "id": 1342,
        "cwe": "CWE-416",
        "cve": "CVE-2017-16648",
        "purpose": "Code purpose:\"\"\"释放DVB前端设备相关资源并处理前端私有数据的清理工作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放fepriv内存后仍可能被访问，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: __dvb_frontend_free\n- 参数: [struct dvb_frontend *fe]\n- 调用者: 未明确（可能是外部调用）\n- 被调用者: [dvb_free_device, dvb_frontend_invoke_release, kfree]\n\n2. 函数名: dvb_free_device\n- 参数: [fepriv->dvbdev]\n- 调用者: __dvb_frontend_free\n- 被调用者: 未明确\n\n3. 函数名: dvb_frontend_invoke_release\n- 参数: [fe, fe->ops.release]\n- 调用者: __dvb_frontend_free\n- 被调用者: 未明确\n\n4. 函数名: kfree\n- 参数: [fepriv]\n- 调用者: __dvb_frontend_free\n- 被调用者: 未明确"
    },
    {
        "id": 1352,
        "cwe": "CWE-416",
        "cve": "CVE-2017-16939",
        "purpose": "Code purpose:\"\"\"该代码片段实现了XFRM策略转储完成时的清理操作，包括结束策略遍历并释放相关网络资源。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在XFRM策略转储实现中存在对已释放内存的后续使用（use-after-free），本地用户可通过特制的SO_RCVBUF setsockopt系统调用结合XFRM_MSG_GETPOLICY Netlink消息利用此漏洞获取权限或导致拒绝服务。\"\"\"",
        "functions": "Functions:\n1. 函数名: xfrm_dump_policy_done\n- 参数: [struct netlink_callback *cb]\n- 调用者: 未明确（由内核网络子系统调用）\n- 被调用者: [sock_net, xfrm_policy_walk_done]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: xfrm_dump_policy_done\n- 被调用者: []\n\n3. 函数名: xfrm_policy_walk_done\n- 参数: [struct xfrm_policy_walk *walk, struct net *net]\n- 调用者: xfrm_dump_policy_done\n- 被调用者: []"
    },
    {
        "id": 1353,
        "cwe": "CWE-416",
        "cve": "CVE-2017-16939",
        "purpose": "Code purpose:\"\"\"该代码实现了XFRM策略的转储功能，通过Netlink回调机制将网络策略信息从内核空间传输到用户空间\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在XFRM策略转储实现中存在use-after-free漏洞，攻击者可通过特制的SO_RCVBUF setsockopt系统调用结合XFRM_MSG_GETPOLICY Netlink消息利用该漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: xfrm_dump_policy\n- 参数: [skb, cb]\n- 调用者: 未明确（由内核网络子系统调用）\n- 被调用者: [sock_net, xfrm_policy_walk_init, xfrm_policy_walk]\n\n2. 函数名: sock_net\n- 参数: [skb->sk]\n- 调用者: xfrm_dump_policy\n- 被调用者: []\n\n3. 函数名: xfrm_policy_walk_init\n- 参数: [walk, XFRM_POLICY_TYPE_ANY]\n- 调用者: xfrm_dump_policy\n- 被调用者: []\n\n4. 函数名: xfrm_policy_walk\n- 参数: [net, walk, dump_one_policy, &info]\n- 调用者: xfrm_dump_policy\n- 被调用者: [dump_one_policy]\n\n5. 函数名: dump_one_policy\n- 参数: [未明确，通过函数指针传递]\n- 调用者: xfrm_policy_walk\n- 被调用者: []"
    },
    {
        "id": 1354,
        "cwe": "CWE-416",
        "cve": "CVE-2017-16939",
        "purpose": "Code purpose:\"\"\"处理XFRM(IPsec)相关的用户空间消息，包括权限检查、消息解析和执行相应操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在XFRM策略转储实现中存在use-after-free漏洞，攻击者可通过精心构造的SO_RCVBUF setsockopt系统调用结合XFRM_MSG_GETPOLICY Netlink消息触发。\"\"\"",
        "functions": "Functions:\n1. 函数名: xfrm_user_rcv_msg\n- 参数: [struct sk_buff *skb, struct nlmsghdr *nlh, struct netlink_ext_ack *extack]\n- 调用者: 未显示（由内核网络子系统调用）\n- 被调用者: [sock_net, nlmsg_parse, netlink_net_capable, netlink_dump_start, link->dump, link->done, link->doit]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: xfrm_user_rcv_msg\n- 被调用者: 未显示\n\n3. 函数名: nlmsg_parse\n- 参数: [struct nlmsghdr *nlh, int hdrlen, struct nlattr *tb[], int maxtype, const struct nla_policy *policy, struct netlink_ext_ack *extack]\n- 调用者: xfrm_user_rcv_msg\n- 被调用者: 未显示\n\n4. 函数名: netlink_net_capable\n- 参数: [struct sk_buff *skb, int cap]\n- 调用者: xfrm_user_rcv_msg\n- 被调用者: 未显示\n\n5. 函数名: netlink_dump_start\n- 参数: [struct sock *ssk, struct sk_buff *skb, struct nlmsghdr *nlh, struct netlink_dump_control *control]\n- 调用者: xfrm_user_rcv_msg\n- 被调用者: 未显示\n\n6. 函数名: link->dump\n- 参数: 未显示（函数指针）\n- 调用者: xfrm_user_rcv_msg\n- 被调用者: 未显示\n\n7. 函数名: link->done\n- 参数: 未显示（函数指针）\n- 调用者: xfrm_user_rcv_msg\n- 被调用者: 未显示\n\n8. 函数名: link->doit\n- 参数: [struct sk_buff *skb, struct nlmsghdr *nlh, struct nlattr **attrs]\n- 调用者: xfrm_user_rcv_msg\n- 被调用者: 未显示"
    },
    {
        "id": 1357,
        "cwe": "CWE-416",
        "cve": "CVE-2017-17052",
        "purpose": "Code purpose:\"\"\"初始化新进程的内存管理结构体(mm_struct)，设置其初始状态和相关参数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"mm_init函数在初始化新进程的mm_struct时未清除->exe_file成员，导致可能发生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: mm_init\n- 参数: [mm, p, user_ns]\n- 调用者: 未明确（通常是进程创建相关函数）\n- 被调用者: [atomic_set, init_rwsem, INIT_LIST_HEAD, atomic_long_set, mm_nr_pmds_init, memset, spin_lock_init, mm_init_cpumask, mm_init_aio, mm_init_owner, mmu_notifier_mm_init, init_tlb_flush_pending, mm_alloc_pgd, init_new_context, get_user_ns, mm_free_pgd, free_mm]\n\n2. 函数名: atomic_set\n- 参数: [&mm->mm_users, 1]\n- 调用者: mm_init\n- 被调用者: []\n\n3. 函数名: init_rwsem\n- 参数: [&mm->mmap_sem]\n- 调用者: mm_init\n- 被调用者: []\n\n4. 函数名: INIT_LIST_HEAD\n- 参数: [&mm->mmlist]\n- 调用者: mm_init\n- 被调用者: []\n\n5. 函数名: atomic_long_set\n- 参数: [&mm->nr_ptes, 0]\n- 调用者: mm_init\n- 被调用者: []\n\n6. 函数名: mm_nr_pmds_init\n- 参数: [mm]\n- 调用者: mm_init\n- 被调用者: []\n\n7. 函数名: memset\n- 参数: [&mm->rss_stat, 0, sizeof(mm->rss_stat)]\n- 调用者: mm_init\n- 被调用者: []\n\n8. 函数名: spin_lock_init\n- 参数: [&mm->page_table_lock]\n- 调用者: mm_init\n- 被调用者: []\n\n9. 函数名: mm_init_cpumask\n- 参数: [mm]\n- 调用者: mm_init\n- 被调用者: []\n\n10. 函数名: mm_init_aio\n- 参数: [mm]\n- 调用者: mm_init\n- 被调用者: []\n\n11. 函数名: mm_init_owner\n- 参数: [mm, p]\n- 调用者: mm_init\n- 被调用者: []\n\n12. 函数名: mmu_notifier_mm_init\n- 参数: [mm]\n- 调用者: mm_init\n- 被调用者: []\n\n13. 函数名: init_tlb_flush_pending\n- 参数: [mm]\n- 调用者: mm_init\n- 被调用者: []\n\n14. 函数名: mm_alloc_pgd\n- 参数: [mm]\n- 调用者: mm_init\n- 被调用者: []\n\n15. 函数名: init_new_context\n- 参数: [p, mm]\n- 调用者: mm_init\n- 被调用者: []\n\n16. 函数名: get_user_ns\n- 参数: [user_ns]\n- 调用者: mm_init\n- 被调用者: []\n\n17. 函数名: mm_free_pgd\n- 参数: [mm]\n- 调用者: mm_init\n- 被调用者: []\n\n18. 函数名: free_mm\n- 参数: [mm]\n- 调用者: mm_init\n- 被调用者: []"
    },
    {
        "id": 1358,
        "cwe": "CWE-416",
        "cve": "CVE-2017-17053",
        "purpose": "Code purpose:\"\"\"初始化新进程的内存管理上下文，包括内存保护密钥和LDT表的设置\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在创建新进程时，init_new_context函数未能正确处理LDT表分配失败的情况，导致可能发生use-after-free或其他未定义影响\"\"\"",
        "functions": "Functions:\n1. 函数名: init_new_context\n- 参数: [struct task_struct *tsk, struct mm_struct *mm]\n- 调用者: 未明确显示（通常由进程创建相关函数调用）\n- 被调用者: [init_new_context_ldt]\n\n2. 函数名: init_new_context_ldt\n- 参数: [struct task_struct *tsk, struct mm_struct *mm]\n- 调用者: init_new_context\n- 被调用者: []"
    },
    {
        "id": 1386,
        "cwe": "CWE-416",
        "cve": "CVE-2017-17975",
        "purpose": "Code purpose:\"\"\"该代码用于探测并初始化USB视频采集设备(USBTV007)，包括视频和音频功能的初始化，并在失败时进行资源清理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在音频注册失败时，代码会先释放usbtv数据结构，然后在usbtv_video_fail标签处再次尝试访问和释放已释放的内存，导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: usbtv_probe\n- 参数: [struct usb_interface *intf, const struct usb_device_id *id]\n- 调用者: 内核USB子系统\n- 被调用者: [usb_endpoint_maxp, usb_endpoint_maxp_mult, kzalloc, usb_get_dev, interface_to_usbdev, usb_set_intfdata, usbtv_video_init, usbtv_audio_init, v4l2_device_get, dev_info, usbtv_video_free, usb_put_dev, kfree]\n\n2. 函数名: usb_endpoint_maxp\n- 参数: [&ep->desc]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n3. 函数名: usb_endpoint_maxp_mult\n- 参数: [&ep->desc]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n4. 函数名: kzalloc\n- 参数: [sizeof(struct usbtv), GFP_KERNEL]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n5. 函数名: usb_get_dev\n- 参数: [interface_to_usbdev(intf)]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n6. 函数名: interface_to_usbdev\n- 参数: [intf]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n7. 函数名: usb_set_intfdata\n- 参数: [intf, usbtv]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n8. 函数名: usbtv_video_init\n- 参数: [usbtv]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n9. 函数名: usbtv_audio_init\n- 参数: [usbtv]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n10. 函数名: v4l2_device_get\n- 参数: [&usbtv->v4l2_dev]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n11. 函数名: dev_info\n- 参数: [dev, \"Fushicai USBTV007 Audio-Video Grabber\\n\"]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n12. 函数名: usbtv_video_free\n- 参数: [usbtv]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n13. 函数名: usb_put_dev\n- 参数: [usbtv->udev]\n- 调用者: usbtv_probe\n- 被调用者: []\n\n14. 函数名: kfree\n- 参数: [usbtv]\n- 调用者: usbtv_probe\n- 被调用者: []"
    },
    {
        "id": 1387,
        "cwe": "CWE-416",
        "cve": "CVE-2017-18017",
        "purpose": "Code purpose:\"\"\"该代码用于修改TCP数据包中的MSS(最大分段大小)选项，以适配路径MTU或强制设置特定MSS值，防止TCP分段问题。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理TCP MSS选项时，由于在扩展skb缓冲区后未正确更新TCP头部指针，导致潜在的use-after-free和内存损坏问题\"\"\"",
        "functions": "Functions:\n1. 函数名: tcpmss_mangle_packet\n- 参数: [skb, par, family, tcphoff, minlen]\n- 调用者: 未明确显示（由iptables/netfilter框架调用）\n- 被调用者: [skb_make_writable, tcpmss_reverse_mtu, dst_mtu, net_err_ratelimited, optlen, inet_proto_csum_replace2, htons, skb_tailroom, pskb_expand_head, skb_put, xt_family, memmove, inet_proto_csum_replace4]\n\n2. 函数名: skb_make_writable\n- 参数: [skb, len]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n3. 函数名: tcpmss_reverse_mtu\n- 参数: [net, skb, family]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n4. 函数名: dst_mtu\n- 参数: [skb_dst(skb)]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n5. 函数名: net_err_ratelimited\n- 参数: [format string, min_mtu]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n6. 函数名: optlen\n- 参数: [opt, i]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n7. 函数名: inet_proto_csum_replace2\n- 参数: [&tcph->check, skb, htons(oldmss), htons(newmss), false]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n8. 函数名: htons\n- 参数: [value]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n9. 函数名: skb_tailroom\n- 参数: [skb]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n10. 函数名: pskb_expand_head\n- 参数: [skb, 0, TCPOLEN_MSS - skb_tailroom(skb), GFP_ATOMIC]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n11. 函数名: skb_put\n- 参数: [skb, TCPOLEN_MSS]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n12. 函数名: xt_family\n- 参数: [par]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n13. 函数名: memmove\n- 参数: [opt + TCPOLEN_MSS, opt, len - sizeof(struct tcphdr)]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n14. 函数名: inet_proto_csum_replace4\n- 参数: [&tcph->check, skb, 0, *((__be32 *)opt), false]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []"
    },
    {
        "id": 1397,
        "cwe": "CWE-416",
        "cve": "CVE-2017-18202",
        "purpose": "Code purpose:\"\"\"该代码用于在内存不足(OOM)情况下回收已终止进程的内存资源，通过解除内存映射来释放匿名页面和共享内存页面。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核的__oom_reap_task_mm函数中，由于未正确处理TLB收集操作，导致在特定时间窗口内触发copy_to_user调用时可能出现TLB条目泄漏或释放后重用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: __oom_reap_task_mm\n- 参数: [struct task_struct *tsk, struct mm_struct *mm]\n- 调用者: 未明确显示（应为oom killer相关调用）\n- 被调用者: [down_read_trylock, trace_skip_task_reaping, up_read, schedule_timeout_idle, test_bit, trace_start_task_reaping, set_bit, tlb_gather_mmu, can_madv_dontneed_vma, vma_is_anonymous, unmap_page_range, tlb_finish_mmu, get_mm_counter, task_pid_nr, trace_finish_task_reaping, mutex_unlock]\n\n2. 函数名: down_read_trylock\n- 参数: [struct rw_semaphore *sem]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n3. 函数名: trace_skip_task_reaping\n- 参数: [pid_t pid]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n4. 函数名: up_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n5. 函数名: schedule_timeout_idle\n- 参数: [long timeout]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n6. 函数名: test_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n7. 函数名: trace_start_task_reaping\n- 参数: [pid_t pid]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n8. 函数名: set_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n9. 函数名: tlb_gather_mmu\n- 参数: [struct mmu_gather *tlb, struct mm_struct *mm, unsigned long start, unsigned long end]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n10. 函数名: can_madv_dontneed_vma\n- 参数: [struct vm_area_struct *vma]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n11. 函数名: vma_is_anonymous\n- 参数: [struct vm_area_struct *vma]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n12. 函数名: unmap_page_range\n- 参数: [struct mmu_gather *tlb, struct vm_area_struct *vma, unsigned long addr, unsigned long end, struct zap_details *details]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n13. 函数名: tlb_finish_mmu\n- 参数: [struct mmu_gather *tlb, unsigned long start, unsigned long end]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n14. 函数名: get_mm_counter\n- 参数: [struct mm_struct *mm, int member]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n15. 函数名: task_pid_nr\n- 参数: [struct task_struct *tsk]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n16. 函数名: trace_finish_task_reaping\n- 参数: [pid_t pid]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n17. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []"
    },
    {
        "id": 1404,
        "cwe": "CWE-416",
        "cve": "CVE-2017-18218",
        "purpose": "Code purpose:\"\"\"该代码实现了网络设备的数据包发送功能，包括数据包的分段处理、DMA映射、描述符填充以及错误处理等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于hns_nic_net_xmit_hw函数在处理skb缓冲区时存在释放后使用(use-after-free)的问题，导致本地用户可能通过利用hns_nic_net_xmit_hw和hns_nic_net_xmit之间skb处理的差异引发拒绝服务或其他影响\"\"\"",
        "functions": "Functions:\n1. 函数名: hns_nic_net_xmit_hw\n- 参数: [ndev, skb, ring_data]\n- 调用者: 未显示\n- 被调用者: [netdev_priv, ring_to_dev, skb_shinfo, dma_map_single, dma_mapping_error, priv->ops.fill_desc, skb_frag_size, skb_frag_dma_map, skb_frag_page, netdev_get_tx_queue, netdev_tx_sent_queue, hnae_queue_xmit, unfill_desc, dma_unmap_page, dma_unmap_single, dev_kfree_skb_any, netif_stop_subqueue]\n\n2. 函数名: netdev_priv\n- 参数: [ndev]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n3. 函数名: ring_to_dev\n- 参数: [ring]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n4. 函数名: skb_shinfo\n- 参数: [skb]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n5. 函数名: dma_map_single\n- 参数: [dev, skb->data, size, DMA_TO_DEVICE]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n6. 函数名: dma_mapping_error\n- 参数: [dev, dma]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n7. 函数名: skb_frag_size\n- 参数: [frag]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n8. 函数名: skb_frag_dma_map\n- 参数: [dev, frag, 0, size, DMA_TO_DEVICE]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n9. 函数名: skb_frag_page\n- 参数: [frag]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n10. 函数名: netdev_get_tx_queue\n- 参数: [ndev, skb->queue_mapping]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n11. 函数名: netdev_tx_sent_queue\n- 参数: [dev_queue, skb->len]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n12. 函数名: hnae_queue_xmit\n- 参数: [priv->ae_handle->qs[skb->queue_mapping], buf_num]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n13. 函数名: unfill_desc\n- 参数: [ring]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n14. 函数名: dma_unmap_page\n- 参数: [dev, ring->desc_cb[ring->next_to_use].dma, ring->desc_cb[ring->next_to_use].length, DMA_TO_DEVICE]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n15. 函数名: dma_unmap_single\n- 参数: [dev, ring->desc_cb[next_to_use].dma, ring->desc_cb[next_to_use].length, DMA_TO_DEVICE]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n16. 函数名: dev_kfree_skb_any\n- 参数: [skb]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n17. 函数名: netif_stop_subqueue\n- 参数: [ndev, skb->queue_mapping]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []"
    },
    {
        "id": 1405,
        "cwe": "CWE-416",
        "cve": "CVE-2017-18218",
        "purpose": "Code purpose:\"\"\"该代码片段实现了网络设备的数据包发送功能，包括队列映射验证、硬件发送操作和发送统计更新。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于hns_nic_net_xmit_hw和hns_nic_net_xmit对skb的处理存在差异，导致可能发生释放后使用(use-after-free)的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: hns_nic_net_xmit\n- 参数: [struct sk_buff *skb, struct net_device *ndev]\n- 调用者: 未显示（通常由网络子系统调用）\n- 被调用者: [netdev_priv, assert, hns_nic_net_xmit_hw, netif_trans_update, tx_ring_data]\n\n2. 函数名: netdev_priv\n- 参数: [struct net_device *ndev]\n- 调用者: hns_nic_net_xmit\n- 被调用者: 未显示\n\n3. 函数名: assert\n- 参数: [skb->queue_mapping < ndev->ae_handle->q_num]\n- 调用者: hns_nic_net_xmit\n- 被调用者: 未显示\n\n4. 函数名: hns_nic_net_xmit_hw\n- 参数: [struct net_device *ndev, struct sk_buff *skb, &tx_ring_data(priv, skb->queue_mapping)]\n- 调用者: hns_nic_net_xmit\n- 被调用者: 未显示\n\n5. 函数名: netif_trans_update\n- 参数: [struct net_device *ndev]\n- 调用者: hns_nic_net_xmit\n- 被调用者: 未显示\n\n6. 函数名: tx_ring_data\n- 参数: [priv, skb->queue_mapping]\n- 调用者: hns_nic_net_xmit\n- 被调用者: 未显示"
    },
    {
        "id": 1444,
        "cwe": "CWE-416",
        "cve": "CVE-2017-2584",
        "purpose": "Code purpose:\"\"\"该代码用于在x86模拟环境中执行fxrstor指令，包括检查FXSR支持、读取浮点状态、验证mxcsr寄存器值，并最终恢复浮点状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在em_fxrstor函数中，由于对fx_state结构体的使用缺乏充分的边界检查和验证，导致可能发生使用后释放或内核信息泄露的安全问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: em_fxrstor\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: 未明确（由指令模拟器调用）\n- 被调用者: [check_fxsr, segmented_read, emulate_gp, fxrstor_fixup, asm_safe]\n\n2. 函数名: check_fxsr\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: em_fxrstor\n- 被调用者: []\n\n3. 函数名: segmented_read\n- 参数: [struct x86_emulate_ctxt *ctxt, ctxt->memop.addr.mem, &fx_state, 512]\n- 调用者: em_fxrstor\n- 被调用者: []\n\n4. 函数名: emulate_gp\n- 参数: [struct x86_emulate_ctxt *ctxt, 0]\n- 调用者: em_fxrstor\n- 被调用者: []\n\n5. 函数名: fxrstor_fixup\n- 参数: [struct x86_emulate_ctxt *ctxt, &fx_state]\n- 调用者: em_fxrstor\n- 被调用者: []\n\n6. 函数名: asm_safe\n- 参数: [\"fxrstor %[fx]\", : [fx] \"m\"(fx_state)]\n- 调用者: em_fxrstor\n- 被调用者: []\n\n7. 函数名: ctxt->ops->get_fpu\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: em_fxrstor\n- 被调用者: []\n\n8. 函数名: ctxt->ops->put_fpu\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: em_fxrstor\n- 被调用者: []"
    },
    {
        "id": 1445,
        "cwe": "CWE-416",
        "cve": "CVE-2017-2584",
        "purpose": "Code purpose:\"\"\"模拟存储描述符指针操作，包括根据模式设置操作字节数并执行分段写入\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在指令模拟过程中未正确处理内存释放后的访问，导致存在释放后使用漏洞，可能泄露内核敏感信息或引发拒绝服务。\"\"\"",
        "functions": "Functions:\n1. 函数名: emulate_store_desc_ptr\n- 参数: [struct x86_emulate_ctxt *ctxt, void (*get)(struct x86_emulate_ctxt *ctxt, struct desc_ptr *ptr)]\n- 调用者: 未明确显示（由指令模拟相关功能调用）\n- 被调用者: [get, segmented_write]\n\n2. 函数名: get\n- 参数: [struct x86_emulate_ctxt *ctxt, struct desc_ptr *ptr]\n- 调用者: emulate_store_desc_ptr\n- 被调用者: 未明确显示（函数指针，具体实现未在代码片段中给出）\n\n3. 函数名: segmented_write\n- 参数: [struct x86_emulate_ctxt *ctxt, ctxt->dst.addr.mem, &desc_ptr, 2 + ctxt->op_bytes]\n- 调用者: emulate_store_desc_ptr\n- 被调用者: 未明确显示（未在代码片段中给出）"
    },
    {
        "id": 1446,
        "cwe": "CWE-416",
        "cve": "CVE-2017-2584",
        "purpose": "Code purpose:\"\"\"该代码用于在KVM虚拟化环境中模拟执行fxsave指令，保存FPU状态到指定内存位置\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在em_fxsave函数中，由于未正确验证用户提供的输入并处理fx_state结构体，导致内核内存信息泄露或使用后释放漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: em_fxsave\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [check_fxsr, asm_safe, segmented_write, ctxt->ops->get_fpu, ctxt->ops->put_fpu, ctxt->ops->get_cr]\n\n2. 函数名: check_fxsr\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: em_fxsave\n- 被调用者: 未明确\n\n3. 函数名: asm_safe\n- 参数: [\"fxsave %[fx]\", , [fx] \"+m\"(fx_state)]\n- 调用者: em_fxsave\n- 被调用者: 未明确\n\n4. 函数名: segmented_write\n- 参数: [struct x86_emulate_ctxt *ctxt, ctxt->memop.addr.mem, &fx_state, size]\n- 调用者: em_fxsave\n- 被调用者: 未明确\n\n5. 函数名: ctxt->ops->get_fpu\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: em_fxsave\n- 被调用者: 未明确\n\n6. 函数名: ctxt->ops->put_fpu\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: em_fxsave\n- 被调用者: 未明确\n\n7. 函数名: ctxt->ops->get_cr\n- 参数: [struct x86_emulate_ctxt *ctxt, 4]\n- 调用者: em_fxsave\n- 被调用者: 未明确"
    },
    {
        "id": 1482,
        "cwe": "CWE-416",
        "cve": "CVE-2017-6346",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中PACKET_FANOUT套接字选项的功能，用于将多个套接字分组以进行数据包分发处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多线程环境下对fanout_list的访问缺乏足够的同步保护，导致在PACKET_FANOUT setsockopt系统调用时可能出现竞争条件，引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: fanout_add\n- 参数: [struct sock *sk, u16 id, u16 type_flags]\n- 调用者: 未明确显示（应为系统调用处理函数）\n- 被调用者: [pkt_sk, kzalloc, atomic_long_set, mutex_lock, list_for_each_entry, read_pnet, sock_net, write_pnet, spin_lock_init, atomic_set, fanout_init_data, dev_add_pack, list_add, atomic_read, __dev_remove_pack, atomic_inc, __fanout_link, mutex_unlock, kfree]\n\n2. 函数名: pkt_sk\n- 参数: [struct sock *sk]\n- 调用者: fanout_add\n- 被调用者: []\n\n3. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: fanout_add\n- 被调用者: []\n\n4. 函数名: atomic_long_set\n- 参数: [atomic_long_t *v, long i]\n- 调用者: fanout_add\n- 被调用者: []\n\n5. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: fanout_add\n- 被调用者: []\n\n6. 函数名: list_for_each_entry\n- 参数: [type *pos, struct list_head *head, member]\n- 调用者: fanout_add\n- 被调用者: []\n\n7. 函数名: read_pnet\n- 参数: [const possible_net_t *net]\n- 调用者: fanout_add\n- 被调用者: []\n\n8. 函数名: sock_net\n- 参数: [const struct sock *sk]\n- 调用者: fanout_add\n- 被调用者: []\n\n9. 函数名: write_pnet\n- 参数: [possible_net_t *net, struct net *net]\n- 调用者: fanout_add\n- 被调用者: []\n\n10. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: fanout_add\n- 被调用者: []\n\n11. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: fanout_add\n- 被调用者: []\n\n12. 函数名: fanout_init_data\n- 参数: [struct packet_fanout *f]\n- 调用者: fanout_add\n- 被调用者: []\n\n13. 函数名: dev_add_pack\n- 参数: [struct packet_type *pt]\n- 调用者: fanout_add\n- 被调用者: []\n\n14. 函数名: list_add\n- 参数: [struct list_head *new, struct list_head *head]\n- 调用者: fanout_add\n- 被调用者: []\n\n15. 函数名: atomic_read\n- 参数: [const atomic_t *v]\n- 调用者: fanout_add\n- 被调用者: []\n\n16. 函数名: __dev_remove_pack\n- 参数: [struct packet_type *pt]\n- 调用者: fanout_add\n- 被调用者: []\n\n17. 函数名: atomic_inc\n- 参数: [atomic_t *v]\n- 调用者: fanout_add\n- 被调用者: []\n\n18. 函数名: __fanout_link\n- 参数: [struct sock *sk, struct packet_sock *po]\n- 调用者: fanout_add\n- 被调用者: []\n\n19. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: fanout_add\n- 被调用者: []\n\n20. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: fanout_add\n- 被调用者: []"
    },
    {
        "id": 1483,
        "cwe": "CWE-416",
        "cve": "CVE-2017-6346",
        "purpose": "Code purpose:\"\"\"管理网络数据包扇出(fanout)结构的释放，包括引用计数递减、链表删除和内存释放等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在多线程环境下，由于缺乏对fanout结构体的引用计数的适当保护，导致在释放内存后可能被其他线程继续访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: fanout_release\n- 参数: [struct sock *sk]\n- 调用者: 未明确显示（由系统调用触发）\n- 被调用者: [pkt_sk, mutex_lock, atomic_dec_and_test, list_del, dev_remove_pack, fanout_release_data, kfree, mutex_unlock, kfree_rcu]\n\n2. 函数名: pkt_sk\n- 参数: [struct sock *sk]\n- 调用者: fanout_release\n- 被调用者: []\n\n3. 函数名: mutex_lock\n- 参数: [&fanout_mutex]\n- 调用者: fanout_release\n- 被调用者: []\n\n4. 函数名: atomic_dec_and_test\n- 参数: [&f->sk_ref]\n- 调用者: fanout_release\n- 被调用者: []\n\n5. 函数名: list_del\n- 参数: [&f->list]\n- 调用者: fanout_release\n- 被调用者: []\n\n6. 函数名: dev_remove_pack\n- 参数: [&f->prot_hook]\n- 调用者: fanout_release\n- 被调用者: []\n\n7. 函数名: fanout_release_data\n- 参数: [f]\n- 调用者: fanout_release\n- 被调用者: []\n\n8. 函数名: kfree\n- 参数: [f]\n- 调用者: fanout_release\n- 被调用者: []\n\n9. 函数名: mutex_unlock\n- 参数: [&fanout_mutex]\n- 调用者: fanout_release\n- 被调用者: []\n\n10. 函数名: kfree_rcu\n- 参数: [po->rollover, rcu]\n- 调用者: fanout_release\n- 被调用者: []"
    },
    {
        "id": 1487,
        "cwe": "CWE-416",
        "cve": "CVE-2017-6874",
        "purpose": "Code purpose:\"\"\"该代码用于在原子计数器减至零时释放ucounts结构体，涉及链表操作和内存释放\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于原子递减操作与链表删除操作之间的竞争条件，导致在释放ucounts结构体后可能被再次访问，造成释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: put_ucounts\n- 参数: [struct ucounts *ucounts]\n- 调用者: 未明确（由系统调用触发）\n- 被调用者: [atomic_dec_and_test, spin_lock_irqsave, hlist_del_init, spin_unlock_irqrestore, kfree]\n\n2. 函数名: atomic_dec_and_test\n- 参数: [&ucounts->count]\n- 调用者: put_ucounts\n- 被调用者: []\n\n3. 函数名: spin_lock_irqsave\n- 参数: [&ucounts_lock, flags]\n- 调用者: put_ucounts\n- 被调用者: []\n\n4. 函数名: hlist_del_init\n- 参数: [&ucounts->node]\n- 调用者: put_ucounts\n- 被调用者: []\n\n5. 函数名: spin_unlock_irqrestore\n- 参数: [&ucounts_lock, flags]\n- 调用者: put_ucounts\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [ucounts]\n- 调用者: put_ucounts\n- 被调用者: []"
    },
    {
        "id": 1488,
        "cwe": "CWE-416",
        "cve": "CVE-2017-6874",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中管理用户命名空间的引用计数，通过哈希表查找或创建ucounts结构体来跟踪特定用户命名空间和用户ID的使用情况。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"竞态条件下，由于get_ucounts函数中释放和重用ucounts对象时缺乏适当的同步保护，导致可能发生use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: get_ucounts\n- 参数: [struct user_namespace *ns, kuid_t uid]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [ucounts_hashentry, find_ucounts, spin_lock_irq, spin_unlock_irq, kzalloc, kfree, atomic_set, hlist_add_head, atomic_add_unless]\n\n2. 函数名: ucounts_hashentry\n- 参数: [struct user_namespace *ns, kuid_t uid]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n3. 函数名: find_ucounts\n- 参数: [struct user_namespace *ns, kuid_t uid, struct hlist_head *hashent]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n4. 函数名: spin_lock_irq\n- 参数: [&ucounts_lock]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n5. 函数名: spin_unlock_irq\n- 参数: [&ucounts_lock]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n6. 函数名: kzalloc\n- 参数: [sizeof(*new), GFP_KERNEL]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n7. 函数名: kfree\n- 参数: [new]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n8. 函数名: atomic_set\n- 参数: [&new->count, 0]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n9. 函数名: hlist_add_head\n- 参数: [&new->node, hashent]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n10. 函数名: atomic_add_unless\n- 参数: [&ucounts->count, 1, INT_MAX]\n- 调用者: get_ucounts\n- 被调用者: 未明确"
    },
    {
        "id": 1497,
        "cwe": "CWE-416",
        "cve": "CVE-2017-7374",
        "purpose": "Code purpose:\"\"\"验证加密文件系统中目录项的有效性，特别是处理与加密密钥相关的状态变化\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在密钥被撤销后，代码未正确处理加密信息对象(ci)的释放，导致后续使用时可能引用已释放的内存\"\"\"",
        "functions": "Functions:\n1. 函数名: fscrypt_d_revalidate\n- 参数: [struct dentry *dentry, unsigned int flags]\n- 调用者: 未显示（通常由文件系统调用）\n- 被调用者: [dget_parent, d_inode, dput, spin_lock, spin_unlock, d_is_negative]\n\n2. 函数名: dget_parent\n- 参数: [struct dentry *dentry]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: []\n\n3. 函数名: d_inode\n- 参数: [struct dentry *dentry]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: []\n\n4. 函数名: dput\n- 参数: [struct dentry *dentry]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: []\n\n5. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: []\n\n6. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: []\n\n7. 函数名: d_is_negative\n- 参数: [const struct dentry *dentry]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: []"
    },
    {
        "id": 1498,
        "cwe": "CWE-416",
        "cve": "CVE-2017-7374",
        "purpose": "Code purpose:\"\"\"该代码用于处理Linux内核中文件系统加密相关的文件名设置，包括加密文件名分配、加密操作以及解密处理等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当密钥环中的密钥被撤销时，加密转换对象被过早释放，导致后续使用时出现空指针解引用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: fscrypt_setup_filename\n- 参数: [struct inode *dir, const struct qstr *iname, int lookup, struct fscrypt_name *fname]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [memset, fscrypt_is_dot_dotdot, fscrypt_get_crypt_info, fscrypt_fname_alloc_buffer, fname_encrypt, kmalloc, digest_decode, memcpy, fscrypt_fname_free_buffer]\n\n2. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: fscrypt_setup_filename\n- 被调用者: 无\n\n3. 函数名: fscrypt_is_dot_dotdot\n- 参数: [const struct qstr *iname]\n- 调用者: fscrypt_setup_filename\n- 被调用者: 无\n\n4. 函数名: fscrypt_get_crypt_info\n- 参数: [struct inode *dir]\n- 调用者: fscrypt_setup_filename\n- 被调用者: 无\n\n5. 函数名: fscrypt_fname_alloc_buffer\n- 参数: [struct inode *dir, unsigned int len, struct fscrypt_str *crypto_buf]\n- 调用者: fscrypt_setup_filename\n- 被调用者: 无\n\n6. 函数名: fname_encrypt\n- 参数: [struct inode *dir, const struct qstr *iname, struct fscrypt_str *out]\n- 调用者: fscrypt_setup_filename\n- 被调用者: 无\n\n7. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: fscrypt_setup_filename\n- 被调用者: 无\n\n8. 函数名: digest_decode\n- 参数: [const char *src, int len, char *dst]\n- 调用者: fscrypt_setup_filename\n- 被调用者: 无\n\n9. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: fscrypt_setup_filename\n- 被调用者: 无\n\n10. 函数名: fscrypt_fname_free_buffer\n- 参数: [struct fscrypt_str *crypto_buf]\n- 调用者: fscrypt_setup_filename\n- 被调用者: 无"
    },
    {
        "id": 1499,
        "cwe": "CWE-416",
        "cve": "CVE-2017-7374",
        "purpose": "Code purpose:\"\"\"检查inode的加密信息是否有效，若无效则重新获取加密信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当密钥环密钥被撤销时，加密信息结构体中的密钥指针未被及时清理，导致后续使用时可能引用已释放的内存。\"\"\"",
        "functions": "Functions:\n1. 函数名: fscrypt_get_encryption_info\n- 参数: [struct inode *inode]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [fscrypt_get_crypt_info]\n\n2. 函数名: fscrypt_get_crypt_info\n- 参数: [struct inode *inode]\n- 调用者: [fscrypt_get_encryption_info]\n- 被调用者: 未明确（代码片段中未显示）"
    },
    {
        "id": 1500,
        "cwe": "CWE-416",
        "cve": "CVE-2017-7374",
        "purpose": "Code purpose:\"\"\"验证用户提供的加密密钥并派生用于文件系统加密的密钥\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在密钥被撤销后仍尝试访问已释放的密钥环密钥，导致使用后释放漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: validate_user_key\n- 参数: [struct fscrypt_info *crypt_info, struct fscrypt_context *ctx, u8 *raw_key, const char *prefix]\n- 调用者: (未明确显示)\n- 被调用者: [kasprintf, request_key, kfree, IS_ERR, PTR_ERR, printk_once, down_read, user_key_payload, up_read, derive_key_aes, key_put]\n\n2. 函数名: kasprintf\n- 参数: [GFP_NOFS, \"%s%*phN\", prefix, FS_KEY_DESCRIPTOR_SIZE, ctx->master_key_descriptor]\n- 调用者: validate_user_key\n- 被调用者: (未明确显示)\n\n3. 函数名: request_key\n- 参数: [&key_type_logon, description, NULL]\n- 调用者: validate_user_key\n- 被调用者: (未明确显示)\n\n4. 函数名: kfree\n- 参数: [description]\n- 调用者: validate_user_key\n- 被调用者: (未明确显示)\n\n5. 函数名: IS_ERR\n- 参数: [keyring_key]\n- 调用者: validate_user_key\n- 被调用者: (未明确显示)\n\n6. 函数名: PTR_ERR\n- 参数: [keyring_key]\n- 调用者: validate_user_key\n- 被调用者: (未明确显示)\n\n7. 函数名: printk_once\n- 参数: [KERN_WARNING, \"%s: key type must be logon\\n\", __func__]\n- 调用者: validate_user_key\n- 被调用者: (未明确显示)\n\n8. 函数名: down_read\n- 参数: [&keyring_key->sem]\n- 调用者: validate_user_key\n- 被调用者: (未明确显示)\n\n9. 函数名: user_key_payload\n- 参数: [keyring_key]\n- 调用者: validate_user_key\n- 被调用者: (未明确显示)\n\n10. 函数名: up_read\n- 参数: [&keyring_key->sem]\n- 调用者: validate_user_key\n- 被调用者: (未明确显示)\n\n11. 函数名: derive_key_aes\n- 参数: [ctx->nonce, master_key->raw, raw_key]\n- 调用者: validate_user_key\n- 被调用者: (未明确显示)\n\n12. 函数名: key_put\n- 参数: [keyring_key]\n- 调用者: validate_user_key\n- 被调用者: (未明确显示)"
    },
    {
        "id": 1501,
        "cwe": "CWE-416",
        "cve": "CVE-2017-7374",
        "purpose": "Code purpose:\"\"\"释放文件系统加密信息结构体及其相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放加密信息结构体时未正确处理密钥环密钥与加密转换对象的引用关系，导致密钥被撤销时可能引发提前释放和使用后释放问题\"\"\"",
        "functions": "Functions:\n1. 函数名: put_crypt_info\n- 参数: [struct fscrypt_info *ci]\n- 调用者: 未指定\n- 被调用者: [key_put, crypto_free_skcipher, kmem_cache_free]\n\n2. 函数名: key_put\n- 参数: [ci->ci_keyring_key]\n- 调用者: put_crypt_info\n- 被调用者: 未指定\n\n3. 函数名: crypto_free_skcipher\n- 参数: [ci->ci_ctfm]\n- 调用者: put_crypt_info\n- 被调用者: 未指定\n\n4. 函数名: kmem_cache_free\n- 参数: [fscrypt_info_cachep, ci]\n- 调用者: put_crypt_info\n- 被调用者: 未指定"
    },
    {
        "id": 1507,
        "cwe": "CWE-416",
        "cve": "CVE-2017-7487",
        "purpose": "Code purpose:\"\"\"处理IPX网络接口的ioctl命令，包括设置/获取接口地址、创建/删除接口以及配置自动创建和选择参数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中ipxitf_ioctl函数在处理SIOCGIFADDR ioctl调用时未能正确管理引用计数，导致在调用失败时可能发生引用计数错误，从而引发use-after-free问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: ipxitf_ioctl\n- 参数: [unsigned int cmd, void __user *arg]\n- 调用者: 未显示（应为内核IOCTL处理调用）\n- 被调用者: [copy_from_user, memcpy, ipxitf_delete, ipxitf_create, __dev_get_by_name, ipxitf_find_using_phys, ipx_map_frame_type, copy_to_user, ipxitf_put, get_user]\n\n2. 函数名: copy_from_user\n- 参数: [&ifr, arg, sizeof(ifr)]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n3. 函数名: memcpy\n- 参数: [f.ipx_device, ifr.ifr_name, sizeof(f.ipx_device)] 和 [f.ipx_node, sipx->sipx_node, IPX_NODE_LEN] 和 [sipx->sipx_node, ipxif->if_node, sizeof(sipx->sipx_node)]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n4. 函数名: ipxitf_delete\n- 参数: [&f]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n5. 函数名: ipxitf_create\n- 参数: [&f]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n6. 函数名: __dev_get_by_name\n- 参数: [&init_net, ifr.ifr_name]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n7. 函数名: ipxitf_find_using_phys\n- 参数: [dev, ipx_map_frame_type(sipx->sipx_type)]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n8. 函数名: ipx_map_frame_type\n- 参数: [sipx->sipx_type]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n9. 函数名: copy_to_user\n- 参数: [arg, &ifr, sizeof(ifr)]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n10. 函数名: ipxitf_put\n- 参数: [ipxif]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n11. 函数名: get_user\n- 参数: [val, (unsigned char __user *) arg]\n- 调用者: ipxitf_ioctl\n- 被调用者: []"
    },
    {
        "id": 1554,
        "cwe": "CWE-416",
        "cve": "CVE-2017-8824",
        "purpose": "Code purpose:\"\"\"该代码实现了DCCP协议套接字断开连接的功能，包括状态转换、资源清理和重置相关参数等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在DCCP_LISTEN状态下通过AF_UNSPEC connect系统调用触发的dccp_disconnect函数中存在use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: dccp_disconnect\n- 参数: [struct sock *sk, int flags]\n- 调用者: 未显示（由系统调用触发）\n- 被调用者: [inet_csk, inet_sk, dccp_set_state, inet_csk_listen_stop, dccp_need_reset, dccp_send_reset, dccp_clear_xmit_timers, __skb_queue_purge, __kfree_skb, inet_reset_saddr, sock_reset_flag, inet_csk_delack_init, __sk_dst_reset, sk->sk_error_report]\n\n2. 函数名: inet_csk\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n3. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n4. 函数名: dccp_set_state\n- 参数: [struct sock *sk, int state]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n5. 函数名: inet_csk_listen_stop\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n6. 函数名: dccp_need_reset\n- 参数: [int old_state]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n7. 函数名: dccp_send_reset\n- 参数: [struct sock *sk, int code]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n8. 函数名: dccp_clear_xmit_timers\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n9. 函数名: __skb_queue_purge\n- 参数: [struct sk_buff_head *list]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n10. 函数名: __kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n11. 函数名: inet_reset_saddr\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n12. 函数名: sock_reset_flag\n- 参数: [struct sock *sk, int flag]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n13. 函数名: inet_csk_delack_init\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n14. 函数名: __sk_dst_reset\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: []\n\n15. 函数名: sk->sk_error_report\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: []"
    },
    {
        "id": 1593,
        "cwe": "CWE-416",
        "cve": "CVE-2018-10675",
        "purpose": "Code purpose:\"\"\"该代码用于获取当前进程的内存策略信息，包括策略类型和节点掩码，可通过不同标志位控制获取策略的方式和内容。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在do_get_mempolicy函数中，当flags包含MPOL_F_ADDR时，如果vma存在但pol为NULL，会直接使用default_policy，但在后续操作中未正确处理vma的锁释放和pol的引用计数，导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: do_get_mempolicy\n- 参数: [int *policy, nodemask_t *nmask, unsigned long addr, unsigned long flags]\n- 调用者: 系统调用\n- 被调用者: [task_lock, task_unlock, down_read, up_read, find_vma_intersection, lookup_node, next_node_in, mpol_store_user_nodemask, get_policy_nodemask, mpol_cond_put]\n\n2. 函数名: task_lock\n- 参数: [current]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n3. 函数名: task_unlock\n- 参数: [current]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n4. 函数名: down_read\n- 参数: [&mm->mmap_sem]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n5. 函数名: up_read\n- 参数: [&mm->mmap_sem]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n6. 函数名: find_vma_intersection\n- 参数: [mm, addr, addr+1]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n7. 函数名: lookup_node\n- 参数: [addr]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n8. 函数名: next_node_in\n- 参数: [current->il_prev, pol->v.nodes]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n9. 函数名: mpol_store_user_nodemask\n- 参数: [pol]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n10. 函数名: get_policy_nodemask\n- 参数: [pol, nmask]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n11. 函数名: mpol_cond_put\n- 参数: [pol]\n- 调用者: do_get_mempolicy\n- 被调用者: []"
    },
    {
        "id": 1604,
        "cwe": "CWE-416",
        "cve": "CVE-2018-10876",
        "purpose": "Code purpose:\"\"\"该代码用于在ext4文件系统中异步读取指定块组的块位图，并进行验证和初始化处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4文件系统中处理特制镜像时，ext4_ext_remove_space()函数存在释放后使用(UAF)问题\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_read_block_bitmap_nowait\n- 参数: [struct super_block *sb, ext4_group_t block_group]\n- 调用者: N/A\n- 被调用者: [ext4_get_group_desc, ext4_block_bitmap, le32_to_cpu, ext4_blocks_count, ext4_error, ext4_mark_group_bitmap_corrupted, sb_getblk, bitmap_uptodate, lock_buffer, unlock_buffer, ext4_lock_group, ext4_init_block_bitmap, set_bitmap_uptodate, set_buffer_uptodate, set_buffer_verified, ext4_unlock_group, buffer_uptodate, set_buffer_new, trace_ext4_read_block_bitmap_load, ext4_end_bitmap_read, get_bh, submit_bh, ext4_validate_block_bitmap, put_bh]\n\n2. 函数名: ext4_get_group_desc\n- 参数: [struct super_block *sb, ext4_group_t block_group, NULL]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n3. 函数名: ext4_block_bitmap\n- 参数: [struct super_block *sb, struct ext4_group_desc *desc]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n4. 函数名: le32_to_cpu\n- 参数: [sbi->s_es->s_first_data_block]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n5. 函数名: ext4_blocks_count\n- 参数: [sbi->s_es]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n6. 函数名: ext4_error\n- 参数: [sb, \"Invalid block bitmap block %llu in block_group %u\", bitmap_blk, block_group]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n7. 函数名: ext4_mark_group_bitmap_corrupted\n- 参数: [sb, block_group, EXT4_GROUP_INFO_BBITMAP_CORRUPT]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n8. 函数名: sb_getblk\n- 参数: [sb, bitmap_blk]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n9. 函数名: bitmap_uptodate\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n10. 函数名: lock_buffer\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n11. 函数名: unlock_buffer\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n12. 函数名: ext4_lock_group\n- 参数: [sb, block_group]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n13. 函数名: ext4_init_block_bitmap\n- 参数: [sb, bh, block_group, desc]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n14. 函数名: set_bitmap_uptodate\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n15. 函数名: set_buffer_uptodate\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n16. 函数名: set_buffer_verified\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n17. 函数名: ext4_unlock_group\n- 参数: [sb, block_group]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n18. 函数名: buffer_uptodate\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n19. 函数名: set_buffer_new\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n20. 函数名: trace_ext4_read_block_bitmap_load\n- 参数: [sb, block_group]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n21. 函数名: ext4_end_bitmap_read\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n22. 函数名: get_bh\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n23. 函数名: submit_bh\n- 参数: [REQ_OP_READ, REQ_META | REQ_PRIO, bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n24. 函数名: ext4_validate_block_bitmap\n- 参数: [sb, desc, block_group, bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A\n\n25. 函数名: put_bh\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: N/A"
    },
    {
        "id": 1387,
        "cwe": "CWE-416",
        "cve": "CVE-2017-18017",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理TCP报文，通过修改TCP选项中的MSS(最大分段大小)值来适应路径MTU，以防止IP分片。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理TCP MSS选项时，由于对skb缓冲区操作不当导致use-after-free和内存损坏漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: tcpmss_mangle_packet\n- 参数: [skb, par, family, tcphoff, minlen]\n- 调用者: 未明确显示（可能是iptables/netfilter框架）\n- 被调用者: [skb_make_writable, skb_network_header, tcpmss_reverse_mtu, dst_mtu, skb_dst, net_err_ratelimited, optlen, inet_proto_csum_replace2, skb_tailroom, pskb_expand_head, skb_put, memmove, inet_proto_csum_replace4]\n\n2. 函数名: skb_make_writable\n- 参数: [skb, len]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n3. 函数名: skb_network_header\n- 参数: [skb]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n4. 函数名: tcpmss_reverse_mtu\n- 参数: [net, skb, family]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n5. 函数名: dst_mtu\n- 参数: [dst]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n6. 函数名: skb_dst\n- 参数: [skb]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n7. 函数名: net_err_ratelimited\n- 参数: [fmt, ...]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n8. 函数名: optlen\n- 参数: [opt, i]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n9. 函数名: inet_proto_csum_replace2\n- 参数: [sum, skb, from, to, pseudohdr]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n10. 函数名: skb_tailroom\n- 参数: [skb]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n11. 函数名: pskb_expand_head\n- 参数: [skb, nhead, ntail, gfp_mask]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n12. 函数名: skb_put\n- 参数: [skb, len]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n13. 函数名: memmove\n- 参数: [dest, src, n]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []\n\n14. 函数名: inet_proto_csum_replace4\n- 参数: [sum, skb, from, to, pseudohdr]\n- 调用者: tcpmss_mangle_packet\n- 被调用者: []"
    },
    {
        "id": 1397,
        "cwe": "CWE-416",
        "cve": "CVE-2017-18202",
        "purpose": "Code purpose:\"\"\"该代码用于在内存不足时回收已终止进程的内存页，通过解除内存映射来释放内存空间\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在TLB收集操作期间，未能正确处理内存映射的同步和清理，导致在特定时间窗口内可能发生TLB条目泄漏或释放后重用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: __oom_reap_task_mm\n- 参数: [struct task_struct *tsk, struct mm_struct *mm]\n- 调用者: 未明确显示（通常是OOM killer相关代码）\n- 被调用者: [down_read_trylock, trace_skip_task_reaping, up_read, schedule_timeout_idle, test_bit, trace_start_task_reaping, set_bit, tlb_gather_mmu, can_madv_dontneed_vma, vma_is_anonymous, unmap_page_range, tlb_finish_mmu, get_mm_counter, task_pid_nr, trace_finish_task_reaping, mutex_unlock]\n\n2. 函数名: down_read_trylock\n- 参数: [struct rw_semaphore *sem]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n3. 函数名: trace_skip_task_reaping\n- 参数: [pid_t pid]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n4. 函数名: up_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n5. 函数名: schedule_timeout_idle\n- 参数: [long timeout]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n6. 函数名: test_bit\n- 参数: [int nr, const volatile unsigned long *addr]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n7. 函数名: trace_start_task_reaping\n- 参数: [pid_t pid]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n8. 函数名: set_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n9. 函数名: tlb_gather_mmu\n- 参数: [struct mmu_gather *tlb, struct mm_struct *mm, unsigned long start, unsigned long end]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n10. 函数名: can_madv_dontneed_vma\n- 参数: [struct vm_area_struct *vma]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n11. 函数名: vma_is_anonymous\n- 参数: [struct vm_area_struct *vma]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n12. 函数名: unmap_page_range\n- 参数: [struct mmu_gather *tlb, struct vm_area_struct *vma, unsigned long addr, unsigned long end, struct zap_details *details]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n13. 函数名: tlb_finish_mmu\n- 参数: [struct mmu_gather *tlb, unsigned long start, unsigned long end]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n14. 函数名: get_mm_counter\n- 参数: [struct mm_struct *mm, int member]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n15. 函数名: task_pid_nr\n- 参数: [struct task_struct *tsk]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n16. 函数名: trace_finish_task_reaping\n- 参数: [pid_t pid]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []\n\n17. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: __oom_reap_task_mm\n- 被调用者: []"
    },
    {
        "id": 1404,
        "cwe": "CWE-416",
        "cve": "CVE-2017-18218",
        "purpose": "Code purpose:\"\"\"该代码实现了网络设备的数据包发送功能，包括数据包的分段处理、DMA映射和传输队列管理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于hns_nic_net_xmit_hw函数在处理skb时存在释放后使用(use-after-free)的问题，导致本地用户可能造成拒绝服务或其他影响。\"\"\"",
        "functions": "Functions:\n1. 函数名: hns_nic_net_xmit_hw\n- 参数: [ndev, skb, ring_data]\n- 调用者: 未显示（应为网络驱动调用）\n- 被调用者: [netdev_priv, ring_to_dev, skb_shinfo, dma_map_single, dma_mapping_error, priv->ops.fill_desc, skb_frag_size, skb_frag_dma_map, skb_frag_page, netdev_get_tx_queue, netdev_tx_sent_queue, hnae_queue_xmit, unfill_desc, dma_unmap_page, dma_unmap_single, dev_kfree_skb_any, netif_stop_subqueue]\n\n2. 函数名: netdev_priv\n- 参数: [ndev]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n3. 函数名: ring_to_dev\n- 参数: [ring]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n4. 函数名: skb_shinfo\n- 参数: [skb]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n5. 函数名: dma_map_single\n- 参数: [dev, skb->data, size, DMA_TO_DEVICE]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n6. 函数名: dma_mapping_error\n- 参数: [dev, dma]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n7. 函数名: skb_frag_size\n- 参数: [frag]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n8. 函数名: skb_frag_dma_map\n- 参数: [dev, frag, 0, size, DMA_TO_DEVICE]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n9. 函数名: skb_frag_page\n- 参数: [frag]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n10. 函数名: netdev_get_tx_queue\n- 参数: [ndev, skb->queue_mapping]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n11. 函数名: netdev_tx_sent_queue\n- 参数: [dev_queue, skb->len]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n12. 函数名: hnae_queue_xmit\n- 参数: [priv->ae_handle->qs[skb->queue_mapping], buf_num]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n13. 函数名: unfill_desc\n- 参数: [ring]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n14. 函数名: dma_unmap_page\n- 参数: [dev, ring->desc_cb[ring->next_to_use].dma, ring->desc_cb[ring->next_to_use].length, DMA_TO_DEVICE]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n15. 函数名: dma_unmap_single\n- 参数: [dev, ring->desc_cb[next_to_use].dma, ring->desc_cb[next_to_use].length, DMA_TO_DEVICE]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n16. 函数名: dev_kfree_skb_any\n- 参数: [skb]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []\n\n17. 函数名: netif_stop_subqueue\n- 参数: [ndev, skb->queue_mapping]\n- 调用者: hns_nic_net_xmit_hw\n- 被调用者: []"
    },
    {
        "id": 1405,
        "cwe": "CWE-416",
        "cve": "CVE-2017-18218",
        "purpose": "Code purpose:\"\"\"该代码片段实现了网络设备的数据包发送功能，包括队列映射验证、硬件发送操作和统计信息更新。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于hns_nic_net_xmit_hw和hns_nic_net_xmit对skb的处理存在差异，导致释放后使用(use-after-free)问题\"\"\"",
        "functions": "Functions:\n1. 函数名: hns_nic_net_xmit\n- 参数: [skb, ndev]\n- 调用者: 未显示（通常由网络子系统调用）\n- 被调用者: [netdev_priv, assert, hns_nic_net_xmit_hw, netif_trans_update, tx_ring_data]\n\n2. 函数名: netdev_priv\n- 参数: [ndev]\n- 调用者: hns_nic_net_xmit\n- 被调用者: 未显示（内核内部函数）\n\n3. 函数名: assert\n- 参数: [skb->queue_mapping < ndev->ae_handle->q_num]\n- 调用者: hns_nic_net_xmit\n- 被调用者: 未显示（宏/断言）\n\n4. 函数名: hns_nic_net_xmit_hw\n- 参数: [ndev, skb, &tx_ring_data(priv, skb->queue_mapping)]\n- 调用者: hns_nic_net_xmit\n- 被调用者: 未显示\n\n5. 函数名: netif_trans_update\n- 参数: [ndev]\n- 调用者: hns_nic_net_xmit\n- 被调用者: 未显示（内核网络接口函数）\n\n6. 函数名: tx_ring_data\n- 参数: [priv, skb->queue_mapping]\n- 调用者: hns_nic_net_xmit\n- 被调用者: 未显示（宏/函数）"
    },
    {
        "id": 1444,
        "cwe": "CWE-416",
        "cve": "CVE-2017-2584",
        "purpose": "Code purpose:\"\"\"该代码用于在x86架构下模拟执行fxrstor指令，包括检查FXSR功能、读取浮点寄存器状态、验证mxcsr寄存器值，并最终执行fxrstor操作恢复浮点状态。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在em_fxrstor函数中，由于对fx_state结构体的使用缺乏充分的边界检查和验证，导致可能发生使用后释放或内核信息泄露的安全问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: em_fxrstor\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: 未明确（由指令模拟器调用）\n- 被调用者: [check_fxsr, segmented_read, emulate_gp, fxrstor_fixup, asm_safe]\n\n2. 函数名: check_fxsr\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: em_fxrstor\n- 被调用者: []\n\n3. 函数名: segmented_read\n- 参数: [struct x86_emulate_ctxt *ctxt, ctxt->memop.addr.mem, &fx_state, 512]\n- 调用者: em_fxrstor\n- 被调用者: []\n\n4. 函数名: emulate_gp\n- 参数: [struct x86_emulate_ctxt *ctxt, 0]\n- 调用者: em_fxrstor\n- 被调用者: []\n\n5. 函数名: fxrstor_fixup\n- 参数: [struct x86_emulate_ctxt *ctxt, &fx_state]\n- 调用者: em_fxrstor\n- 被调用者: []\n\n6. 函数名: asm_safe\n- 参数: [\"fxrstor %[fx]\", : [fx] \"m\"(fx_state)]\n- 调用者: em_fxrstor\n- 被调用者: []\n\n7. 函数名: ctxt->ops->get_fpu\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: em_fxrstor\n- 被调用者: []\n\n8. 函数名: ctxt->ops->put_fpu\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: em_fxrstor\n- 被调用者: []"
    },
    {
        "id": 1445,
        "cwe": "CWE-416",
        "cve": "CVE-2017-2584",
        "purpose": "Code purpose:\"\"\"模拟存储描述符指针操作，包括根据模式设置操作字节数并执行分段写入\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在模拟存储描述符指针时，未正确验证或处理用户提供的输入，导致内核内存信息泄露或使用后释放漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: emulate_store_desc_ptr\n- 参数: [struct x86_emulate_ctxt *ctxt, void (*get)(struct x86_emulate_ctxt *ctxt, struct desc_ptr *ptr)]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [get, segmented_write]\n\n2. 函数名: get\n- 参数: [struct x86_emulate_ctxt *ctxt, struct desc_ptr *ptr]\n- 调用者: emulate_store_desc_ptr\n- 被调用者: 未明确（函数指针）\n\n3. 函数名: segmented_write\n- 参数: [struct x86_emulate_ctxt *ctxt, ctxt->dst.addr.mem, &desc_ptr, 2 + ctxt->op_bytes]\n- 调用者: emulate_store_desc_ptr\n- 被调用者: 未明确"
    },
    {
        "id": 1446,
        "cwe": "CWE-416",
        "cve": "CVE-2017-2584",
        "purpose": "Code purpose:\"\"\"该代码实现了x86指令模拟器中fxsave指令的功能，用于将FPU状态保存到指定内存位置\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在em_fxsave函数中，由于对fx_state缓冲区的大小计算不当，可能导致内核内存信息泄露或使用后释放漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: em_fxsave\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: 未显示\n- 被调用者: [check_fxsr, asm_safe, segmented_write]\n\n2. 函数名: check_fxsr\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: em_fxsave\n- 被调用者: 未显示\n\n3. 函数名: asm_safe\n- 参数: [\"fxsave %[fx]\", , [fx] \"+m\"(fx_state)]\n- 调用者: em_fxsave\n- 被调用者: 未显示\n\n4. 函数名: segmented_write\n- 参数: [struct x86_emulate_ctxt *ctxt, ctxt->memop.addr.mem, &fx_state, size]\n- 调用者: em_fxsave\n- 被调用者: 未显示\n\n5. 函数名: get_fpu\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: em_fxsave (通过 ctxt->ops->get_fpu)\n- 被调用者: 未显示\n\n6. 函数名: put_fpu\n- 参数: [struct x86_emulate_ctxt *ctxt]\n- 调用者: em_fxsave (通过 ctxt->ops->put_fpu)\n- 被调用者: 未显示\n\n7. 函数名: get_cr\n- 参数: [struct x86_emulate_ctxt *ctxt, 4]\n- 调用者: em_fxsave (通过 ctxt->ops->get_cr)\n- 被调用者: 未显示"
    },
    {
        "id": 1482,
        "cwe": "CWE-416",
        "cve": "CVE-2017-6346",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中PACKET_FANOUT套接字选项的功能，用于将多个套接字分组以进行数据包分发处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多线程环境下对fanout_list的访问缺乏足够的同步保护，导致在PACKET_FANOUT setsockopt系统调用时可能发生竞争条件，引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: fanout_add\n- 参数: [struct sock *sk, u16 id, u16 type_flags]\n- 调用者: 未显示（应为外部调用）\n- 被调用者: [pkt_sk, kzalloc, atomic_long_set, mutex_lock, list_for_each_entry, read_pnet, sock_net, write_pnet, INIT_LIST_HEAD, spin_lock_init, atomic_set, fanout_init_data, dev_add_pack, list_add, atomic_read, __dev_remove_pack, atomic_inc, __fanout_link, mutex_unlock, kfree]\n\n2. 函数名: pkt_sk\n- 参数: [struct sock *sk]\n- 调用者: fanout_add\n- 被调用者: 未显示\n\n3. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: fanout_add\n- 被调用者: 未显示\n\n4. 函数名: atomic_long_set\n- 参数: [atomic_long_t *v, long i]\n- 调用者: fanout_add\n- 被调用者: 未显示\n\n5. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: fanout_add\n- 被调用者: 未显示\n\n6. 函数名: list_for_each_entry\n- 参数: [type *pos, struct list_head *head, member]\n- 调用者: fanout_add\n- 被调用者: 未显示\n\n7. 函数名: read_pnet\n- 参数: [const possible_net_t *net]\n- 调用者: fanout_add\n- 被调用者: 未显示\n\n8. 函数名: sock_net\n- 参数: [const struct sock *sk]\n- 调用者: fanout_add\n- 被调用者: 未显示\n\n9. 函数名: write_pnet\n- 参数: [possible_net_t *net, struct net *net]\n- 调用者: fanout_add\n- 被调用者: 未显示\n\n10. 函数名: INIT_LIST_HEAD\n- 参数: [struct list_head *list]\n- 调用者: fanout_add\n- 被调用者: 未显示\n\n11. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: fanout_add\n- 被调用者: 未显示\n\n12. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: fanout_add\n- 被调用者: 未显示\n\n13. 函数名: fanout_init_data\n- 参数: [struct packet_fanout *f]\n- 调用者: fanout_add\n- 被调用者: 未显示\n\n14. 函数名: dev_add_pack\n- 参数: [struct packet_type *pt]\n- 调用者: fanout_add\n- 被调用者: 未显示\n\n15. 函数名: list_add\n- 参数: [struct list_head *new, struct list_head *head]\n- 调用者: fanout_add\n- 被调用者: 未显示\n\n16. 函数名: atomic_read\n- 参数: [const atomic_t *v]\n- 调用者: fanout_add\n- 被调用者: 未显示\n\n17. 函数名: __dev_remove_pack\n- 参数: [struct packet_type *pt]\n- 调用者: fanout_add\n- 被调用者: 未显示\n\n18. 函数名: atomic_inc\n- 参数: [atomic_t *v]\n- 调用者: fanout_add\n- 被调用者: 未显示\n\n19. 函数名: __fanout_link\n- 参数: [struct sock *sk, struct packet_sock *po]\n- 调用者: fanout_add\n- 被调用者: 未显示\n\n20. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: fanout_add\n- 被调用者: 未显示\n\n21. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: fanout_add\n- 被调用者: 未显示"
    },
    {
        "id": 1483,
        "cwe": "CWE-416",
        "cve": "CVE-2017-6346",
        "purpose": "Code purpose:\"\"\"管理网络数据包扇出(fanout)结构的释放，包括引用计数减少、链表删除和内存释放等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在多线程环境下，由于缺乏适当的同步机制，导致在fanout_release函数中对fanout结构的释放操作可能与其他线程的PACKET_FANOUT setsockopt系统调用产生竞争条件，引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: fanout_release\n- 参数: [struct sock *sk]\n- 调用者: 未明确显示（由系统调用触发）\n- 被调用者: [pkt_sk, mutex_lock, atomic_dec_and_test, list_del, dev_remove_pack, fanout_release_data, kfree, mutex_unlock, kfree_rcu]\n\n2. 函数名: pkt_sk\n- 参数: [struct sock *sk]\n- 调用者: fanout_release\n- 被调用者: []\n\n3. 函数名: mutex_lock\n- 参数: [&fanout_mutex]\n- 调用者: fanout_release\n- 被调用者: []\n\n4. 函数名: atomic_dec_and_test\n- 参数: [&f->sk_ref]\n- 调用者: fanout_release\n- 被调用者: []\n\n5. 函数名: list_del\n- 参数: [&f->list]\n- 调用者: fanout_release\n- 被调用者: []\n\n6. 函数名: dev_remove_pack\n- 参数: [&f->prot_hook]\n- 调用者: fanout_release\n- 被调用者: []\n\n7. 函数名: fanout_release_data\n- 参数: [f]\n- 调用者: fanout_release\n- 被调用者: []\n\n8. 函数名: kfree\n- 参数: [f]\n- 调用者: fanout_release\n- 被调用者: []\n\n9. 函数名: mutex_unlock\n- 参数: [&fanout_mutex]\n- 调用者: fanout_release\n- 被调用者: []\n\n10. 函数名: kfree_rcu\n- 参数: [po->rollover, rcu]\n- 调用者: fanout_release\n- 被调用者: []"
    },
    {
        "id": 1487,
        "cwe": "CWE-416",
        "cve": "CVE-2017-6874",
        "purpose": "Code purpose:\"\"\"该代码用于在引用计数减至零时释放ucounts结构体，通过原子操作和自旋锁确保线程安全\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在原子递减操作和后续链表删除操作之间存在竞争条件，导致可能发生use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: put_ucounts\n- 参数: [ucounts]\n- 调用者: 未明确（由系统调用触发）\n- 被调用者: [atomic_dec_and_test, spin_lock_irqsave, hlist_del_init, spin_unlock_irqrestore, kfree]\n\n2. 函数名: atomic_dec_and_test\n- 参数: [&ucounts->count]\n- 调用者: put_ucounts\n- 被调用者: []\n\n3. 函数名: spin_lock_irqsave\n- 参数: [&ucounts_lock, flags]\n- 调用者: put_ucounts\n- 被调用者: []\n\n4. 函数名: hlist_del_init\n- 参数: [&ucounts->node]\n- 调用者: put_ucounts\n- 被调用者: []\n\n5. 函数名: spin_unlock_irqrestore\n- 参数: [&ucounts_lock, flags]\n- 调用者: put_ucounts\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [ucounts]\n- 调用者: put_ucounts\n- 被调用者: []"
    },
    {
        "id": 1488,
        "cwe": "CWE-416",
        "cve": "CVE-2017-6874",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中管理用户命名空间的引用计数，通过哈希表查找或创建ucounts结构体来跟踪特定用户命名空间和用户ID的使用情况。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在get_ucounts函数中存在竞态条件，当多个线程同时操作ucounts结构时可能导致use-after-free问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: get_ucounts\n- 参数: [struct user_namespace *ns, kuid_t uid]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [ucounts_hashentry, find_ucounts, spin_lock_irq, spin_unlock_irq, kzalloc, kfree, atomic_set, hlist_add_head, atomic_add_unless]\n\n2. 函数名: ucounts_hashentry\n- 参数: [struct user_namespace *ns, kuid_t uid]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n3. 函数名: find_ucounts\n- 参数: [struct user_namespace *ns, kuid_t uid, struct hlist_head *hashent]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n4. 函数名: spin_lock_irq\n- 参数: [spinlock_t *lock]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n5. 函数名: spin_unlock_irq\n- 参数: [spinlock_t *lock]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n6. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n7. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n8. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n9. 函数名: hlist_add_head\n- 参数: [struct hlist_node *n, struct hlist_head *h]\n- 调用者: get_ucounts\n- 被调用者: 未明确\n\n10. 函数名: atomic_add_unless\n- 参数: [atomic_t *v, int a, int u]\n- 调用者: get_ucounts\n- 被调用者: 未明确"
    },
    {
        "id": 1497,
        "cwe": "CWE-416",
        "cve": "CVE-2017-7374",
        "purpose": "Code purpose:\"\"\"该代码用于验证加密文件系统中目录项的有效性，检查密钥状态并决定是否重新验证目录项\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当密钥环密钥被撤销时，加密信息对象(ci)被过早释放，导致后续访问时出现空指针解引用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: fscrypt_d_revalidate\n- 参数: [struct dentry *dentry, unsigned int flags]\n- 调用者: 未明确（通常由文件系统调用）\n- 被调用者: [dget_parent, d_inode, dput, spin_lock, spin_unlock, d_is_negative]\n\n2. 函数名: dget_parent\n- 参数: [struct dentry *dentry]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: []\n\n3. 函数名: d_inode\n- 参数: [struct dentry *dentry]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: []\n\n4. 函数名: dput\n- 参数: [struct dentry *dentry]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: []\n\n5. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: []\n\n6. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: []\n\n7. 函数名: d_is_negative\n- 参数: [const struct dentry *dentry]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: []"
    },
    {
        "id": 1498,
        "cwe": "CWE-416",
        "cve": "CVE-2017-7374",
        "purpose": "Code purpose:\"\"\"该代码用于处理Linux内核中文件系统加密相关的文件名设置，包括加密文件名、解密操作以及相关缓冲区的管理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当密钥环中的密钥被撤销时，加密转换对象被过早释放，导致后续使用时出现空指针解引用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: fscrypt_setup_filename\n- 参数: [struct inode *dir, const struct qstr *iname, int lookup, struct fscrypt_name *fname]\n- 调用者: N/A (top-level function)\n- 被调用者: [memset, fscrypt_is_dot_dotdot, fscrypt_get_crypt_info, fscrypt_fname_alloc_buffer, fname_encrypt, kmalloc, digest_decode, memcpy, fscrypt_fname_free_buffer]\n\n2. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: fscrypt_setup_filename\n- 被调用者: []\n\n3. 函数名: fscrypt_is_dot_dotdot\n- 参数: [const struct qstr *iname]\n- 调用者: fscrypt_setup_filename\n- 被调用者: []\n\n4. 函数名: fscrypt_get_crypt_info\n- 参数: [struct inode *dir]\n- 调用者: fscrypt_setup_filename\n- 被调用者: []\n\n5. 函数名: fscrypt_fname_alloc_buffer\n- 参数: [struct inode *dir, size_t len, struct fscrypt_str *crypto_buf]\n- 调用者: fscrypt_setup_filename\n- 被调用者: []\n\n6. 函数名: fname_encrypt\n- 参数: [struct inode *dir, const struct qstr *iname, struct fscrypt_str *crypto_buf]\n- 调用者: fscrypt_setup_filename\n- 被调用者: []\n\n7. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: fscrypt_setup_filename\n- 被调用者: []\n\n8. 函数名: digest_decode\n- 参数: [const char *src, int len, char *dst]\n- 调用者: fscrypt_setup_filename\n- 被调用者: []\n\n9. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: fscrypt_setup_filename\n- 被调用者: []\n\n10. 函数名: fscrypt_fname_free_buffer\n- 参数: [struct fscrypt_str *crypto_buf]\n- 调用者: fscrypt_setup_filename\n- 被调用者: []"
    },
    {
        "id": 1499,
        "cwe": "CWE-416",
        "cve": "CVE-2017-7374",
        "purpose": "Code purpose:\"\"\"检查inode的加密信息是否有效，若无效则重新获取加密信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当密钥环密钥被撤销时，加密转换对象被过早释放，导致后续使用时出现释放后重用(use-after-free)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: fscrypt_get_encryption_info\n- 参数: [struct inode *inode]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [fscrypt_get_crypt_info]\n\n2. 函数名: fscrypt_get_crypt_info\n- 参数: [struct inode *inode]\n- 调用者: [fscrypt_get_encryption_info]\n- 被调用者: 未明确"
    },
    {
        "id": 1500,
        "cwe": "CWE-416",
        "cve": "CVE-2017-7374",
        "purpose": "Code purpose:\"\"\"验证用户提供的加密密钥并派生用于文件系统加密的密钥\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在密钥被撤销后，代码仍尝试访问已被释放的keyring_key对象，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: validate_user_key\n- 参数: [struct fscrypt_info *crypt_info, struct fscrypt_context *ctx, u8 *raw_key, const char *prefix]\n- 调用者: (未在代码片段中显示)\n- 被调用者: [kasprintf, request_key, kfree, IS_ERR, PTR_ERR, printk_once, down_read, user_key_payload, up_read, derive_key_aes, key_put]\n\n2. 函数名: kasprintf\n- 参数: [GFP_NOFS, \"%s%*phN\", prefix, FS_KEY_DESCRIPTOR_SIZE, ctx->master_key_descriptor]\n- 调用者: validate_user_key\n- 被调用者: (未在代码片段中显示)\n\n3. 函数名: request_key\n- 参数: [&key_type_logon, description, NULL]\n- 调用者: validate_user_key\n- 被调用者: (未在代码片段中显示)\n\n4. 函数名: kfree\n- 参数: [description]\n- 调用者: validate_user_key\n- 被调用者: (未在代码片段中显示)\n\n5. 函数名: IS_ERR\n- 参数: [keyring_key]\n- 调用者: validate_user_key\n- 被调用者: (未在代码片段中显示)\n\n6. 函数名: PTR_ERR\n- 参数: [keyring_key]\n- 调用者: validate_user_key\n- 被调用者: (未在代码片段中显示)\n\n7. 函数名: printk_once\n- 参数: [KERN_WARNING, \"%s: key type must be logon\\n\", __func__] 和 [KERN_WARNING, \"%s: key size incorrect: %d\\n\", __func__, master_key->size]\n- 调用者: validate_user_key\n- 被调用者: (未在代码片段中显示)\n\n8. 函数名: down_read\n- 参数: [&keyring_key->sem]\n- 调用者: validate_user_key\n- 被调用者: (未在代码片段中显示)\n\n9. 函数名: user_key_payload\n- 参数: [keyring_key]\n- 调用者: validate_user_key\n- 被调用者: (未在代码片段中显示)\n\n10. 函数名: up_read\n- 参数: [&keyring_key->sem]\n- 调用者: validate_user_key\n- 被调用者: (未在代码片段中显示)\n\n11. 函数名: derive_key_aes\n- 参数: [ctx->nonce, master_key->raw, raw_key]\n- 调用者: validate_user_key\n- 被调用者: (未在代码片段中显示)\n\n12. 函数名: key_put\n- 参数: [keyring_key]\n- 调用者: validate_user_key\n- 被调用者: (未在代码片段中显示)"
    },
    {
        "id": 1501,
        "cwe": "CWE-416",
        "cve": "CVE-2017-7374",
        "purpose": "Code purpose:\"\"\"释放文件系统加密信息结构体及其相关资源，包括密钥环密钥和加密转换对象\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放加密信息结构体时未正确处理密钥环密钥和加密转换对象的引用计数，导致密钥被撤销时可能引发提前释放和使用后释放问题\"\"\"",
        "functions": "Functions:\n1. 函数名: put_crypt_info\n- 参数: [struct fscrypt_info *ci]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [key_put, crypto_free_skcipher, kmem_cache_free]\n\n2. 函数名: key_put\n- 参数: [ci->ci_keyring_key]\n- 调用者: put_crypt_info\n- 被调用者: 未明确\n\n3. 函数名: crypto_free_skcipher\n- 参数: [ci->ci_ctfm]\n- 调用者: put_crypt_info\n- 被调用者: 未明确\n\n4. 函数名: kmem_cache_free\n- 参数: [fscrypt_info_cachep, ci]\n- 调用者: put_crypt_info\n- 被调用者: 未明确"
    },
    {
        "id": 1507,
        "cwe": "CWE-416",
        "cve": "CVE-2017-7487",
        "purpose": "Code purpose:\"\"\"处理IPX网络接口的ioctl请求，包括设置/获取接口地址、创建/删除接口以及配置自动创建和选择参数等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中ipxitf_ioctl函数在处理SIOCGIFADDR ioctl调用时未能正确管理引用计数，导致在调用失败时可能引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ipxitf_ioctl\n- 参数: [unsigned int cmd, void __user *arg]\n- 调用者: 未显示（内核IOCTL调用）\n- 被调用者: [copy_from_user, ipxitf_delete, ipxitf_create, __dev_get_by_name, ipxitf_find_using_phys, ipx_map_frame_type, memcpy, copy_to_user, ipxitf_put, get_user]\n\n2. 函数名: copy_from_user\n- 参数: [&ifr, arg, sizeof(ifr)]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n3. 函数名: ipxitf_delete\n- 参数: [&f]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n4. 函数名: ipxitf_create\n- 参数: [&f]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n5. 函数名: __dev_get_by_name\n- 参数: [&init_net, ifr.ifr_name]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n6. 函数名: ipxitf_find_using_phys\n- 参数: [dev, ipx_map_frame_type(sipx->sipx_type)]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n7. 函数名: ipx_map_frame_type\n- 参数: [sipx->sipx_type]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n8. 函数名: memcpy\n- 参数: [f.ipx_device, ifr.ifr_name, sizeof(f.ipx_device)] 和 [f.ipx_node, sipx->sipx_node, IPX_NODE_LEN] 和 [sipx->sipx_node, ipxif->if_node, sizeof(sipx->sipx_node)]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n9. 函数名: copy_to_user\n- 参数: [arg, &ifr, sizeof(ifr)]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n10. 函数名: ipxitf_put\n- 参数: [ipxif]\n- 调用者: ipxitf_ioctl\n- 被调用者: []\n\n11. 函数名: get_user\n- 参数: [val, (unsigned char __user *) arg]\n- 调用者: ipxitf_ioctl\n- 被调用者: []"
    },
    {
        "id": 1554,
        "cwe": "CWE-416",
        "cve": "CVE-2017-8824",
        "purpose": "Code purpose:\"\"\"该代码用于处理DCCP协议套接字的断开连接操作，包括状态转换、资源清理和重置相关参数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在DCCP_LISTEN状态下通过AF_UNSPEC connect系统调用触发dccp_disconnect函数时，可能导致use-after-free漏洞，允许本地用户提升权限或造成拒绝服务。\"\"\"",
        "functions": "Functions:\n1. 函数名: dccp_disconnect\n- 参数: [struct sock *sk, int flags]\n- 调用者: 无（顶层函数）\n- 被调用者: [inet_csk, inet_sk, dccp_set_state, inet_csk_listen_stop, dccp_need_reset, dccp_send_reset, dccp_clear_xmit_timers, __skb_queue_purge, __kfree_skb, inet_reset_saddr, sock_reset_flag, inet_csk_delack_init, __sk_dst_reset, sk->sk_error_report]\n\n2. 函数名: inet_csk\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: 无\n\n3. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: 无\n\n4. 函数名: dccp_set_state\n- 参数: [struct sock *sk, int state]\n- 调用者: dccp_disconnect\n- 被调用者: 无\n\n5. 函数名: inet_csk_listen_stop\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: 无\n\n6. 函数名: dccp_need_reset\n- 参数: [int old_state]\n- 调用者: dccp_disconnect\n- 被调用者: 无\n\n7. 函数名: dccp_send_reset\n- 参数: [struct sock *sk, int code]\n- 调用者: dccp_disconnect\n- 被调用者: 无\n\n8. 函数名: dccp_clear_xmit_timers\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: 无\n\n9. 函数名: __skb_queue_purge\n- 参数: [struct sk_buff_head *list]\n- 调用者: dccp_disconnect\n- 被调用者: 无\n\n10. 函数名: __kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: dccp_disconnect\n- 被调用者: 无\n\n11. 函数名: inet_reset_saddr\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: 无\n\n12. 函数名: sock_reset_flag\n- 参数: [struct sock *sk, int flag]\n- 调用者: dccp_disconnect\n- 被调用者: 无\n\n13. 函数名: inet_csk_delack_init\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: 无\n\n14. 函数名: __sk_dst_reset\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: 无\n\n15. 函数名: sk->sk_error_report\n- 参数: [struct sock *sk]\n- 调用者: dccp_disconnect\n- 被调用者: 无"
    },
    {
        "id": 1593,
        "cwe": "CWE-416",
        "cve": "CVE-2018-10675",
        "purpose": "Code purpose:\"\"\"该代码用于获取当前进程的内存策略信息，包括策略类型和节点掩码，可通过不同标志位控制获取策略的方式和内容。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在do_get_mempolicy函数中，当flags包含MPOL_F_ADDR时，如果vma存在但pol为NULL，会错误地释放vma锁后继续使用已释放的pol指针，导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: do_get_mempolicy\n- 参数: [int *policy, nodemask_t *nmask, unsigned long addr, unsigned long flags]\n- 调用者: 未显示（系统调用）\n- 被调用者: [task_lock, task_unlock, down_read, find_vma_intersection, up_read, lookup_node, next_node_in, mpol_store_user_nodemask, get_policy_nodemask, mpol_cond_put]\n\n2. 函数名: task_lock\n- 参数: [current]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n3. 函数名: task_unlock\n- 参数: [current]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n4. 函数名: down_read\n- 参数: [&mm->mmap_sem]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n5. 函数名: find_vma_intersection\n- 参数: [mm, addr, addr+1]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n6. 函数名: up_read\n- 参数: [&current->mm->mmap_sem]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n7. 函数名: lookup_node\n- 参数: [addr]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n8. 函数名: next_node_in\n- 参数: [current->il_prev, pol->v.nodes]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n9. 函数名: mpol_store_user_nodemask\n- 参数: [pol]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n10. 函数名: get_policy_nodemask\n- 参数: [pol, nmask]\n- 调用者: do_get_mempolicy\n- 被调用者: []\n\n11. 函数名: mpol_cond_put\n- 参数: [pol]\n- 调用者: do_get_mempolicy\n- 被调用者: []"
    },
    {
        "id": 1604,
        "cwe": "CWE-416",
        "cve": "CVE-2018-10876",
        "purpose": "Code purpose:\"\"\"该代码用于在ext4文件系统中异步读取指定块组的块位图，并进行验证和初始化处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4_ext_remove_space()函数中对已释放的内存空间进行了后续操作，导致了use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_read_block_bitmap_nowait\n- 参数: [struct super_block *sb, ext4_group_t block_group]\n- 调用者: N/A (顶层函数)\n- 被调用者: [ext4_get_group_desc, ext4_block_bitmap, le32_to_cpu, ext4_blocks_count, ext4_error, ext4_mark_group_bitmap_corrupted, sb_getblk, bitmap_uptodate, lock_buffer, unlock_buffer, ext4_lock_group, ext4_init_block_bitmap, set_bitmap_uptodate, set_buffer_uptodate, set_buffer_verified, ext4_unlock_group, buffer_uptodate, set_buffer_new, trace_ext4_read_block_bitmap_load, ext4_end_bitmap_read, get_bh, submit_bh, ext4_validate_block_bitmap, put_bh]\n\n2. 函数名: ext4_get_group_desc\n- 参数: [struct super_block *sb, ext4_group_t block_group, NULL]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []\n\n3. 函数名: ext4_block_bitmap\n- 参数: [struct super_block *sb, struct ext4_group_desc *desc]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []\n\n4. 函数名: le32_to_cpu\n- 参数: [sbi->s_es->s_first_data_block]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []\n\n5. 函数名: ext4_blocks_count\n- 参数: [sbi->s_es]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []\n\n6. 函数名: ext4_error\n- 参数: [sb, \"Invalid block bitmap block %llu in block_group %u\", bitmap_blk, block_group]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []\n\n7. 函数名: ext4_mark_group_bitmap_corrupted\n- 参数: [sb, block_group, EXT4_GROUP_INFO_BBITMAP_CORRUPT]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []\n\n8. 函数名: sb_getblk\n- 参数: [sb, bitmap_blk]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []\n\n9. 函数名: bitmap_uptodate\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []\n\n10. 函数名: lock_buffer\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []\n\n11. 函数名: unlock_buffer\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []\n\n12. 函数名: ext4_lock_group\n- 参数: [sb, block_group]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []\n\n13. 函数名: ext4_init_block_bitmap\n- 参数: [sb, bh, block_group, desc]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []\n\n14. 函数名: set_bitmap_uptodate\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []\n\n15. 函数名: set_buffer_uptodate\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []\n\n16. 函数名: set_buffer_verified\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []\n\n17. 函数名: ext4_unlock_group\n- 参数: [sb, block_group]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []\n\n18. 函数名: buffer_uptodate\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []\n\n19. 函数名: set_buffer_new\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []\n\n20. 函数名: trace_ext4_read_block_bitmap_load\n- 参数: [sb, block_group]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []\n\n21. 函数名: ext4_end_bitmap_read\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []\n\n22. 函数名: get_bh\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []\n\n23. 函数名: submit_bh\n- 参数: [REQ_OP_READ, REQ_META | REQ_PRIO, bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []\n\n24. 函数名: ext4_validate_block_bitmap\n- 参数: [sb, desc, block_group, bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []\n\n25. 函数名: put_bh\n- 参数: [bh]\n- 调用者: ext4_read_block_bitmap_nowait\n- 被调用者: []"
    },
    {
        "id": 1605,
        "cwe": "CWE-416",
        "cve": "CVE-2018-10876",
        "purpose": "Code purpose:\"\"\"该代码实现了ext4文件系统中创建新inode的核心功能，包括分配inode号、初始化inode结构、处理配额和安全属性等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4_ext_remove_space()函数中处理特制ext4镜像时，存在释放后使用(UAF)问题\"\"\"",
        "functions": "Functions:\n1. 函数名: __ext4_new_inode\n- 参数: [handle_t *handle, struct inode *dir, umode_t mode, const struct qstr *qstr, __u32 goal, uid_t *owner, __u32 i_flags, int handle_type, unsigned int line_no, int nblocks]\n- 调用者: N/A (顶层函数)\n- 被调用者: [ext4_forced_shutdown, ext4_encrypted_inode, DUMMY_ENCRYPTION_ENABLED, fscrypt_get_encryption_info, fscrypt_has_encryption_key, get_acl, posix_acl_release, ext4_get_groups_count, new_inode, i_uid_write, i_gid_write, current_fsuid, inode_init_owner, make_kprojid, dquot_initialize, find_group_orlov, find_group_other, ext4_get_group_desc, ext4_get_group_info, brelse, ext4_read_inode_bitmap, find_inode_bit, ext4_error, ext4_mark_group_bitmap_corrupted, __ext4_journal_start_sb, ext4_journal_get_write_access, ext4_lock_group, ext4_test_and_set_bit, ext4_unlock_group, ext4_handle_dirty_metadata, ext4_read_block_bitmap, ext4_free_clusters_after_init, ext4_block_bitmap_csum_set, ext4_group_desc_csum_set, down_read, up_read, ext4_itable_unused_count, ext4_itable_unused_set, ext4_flex_group, atomic_inc, percpu_counter_dec, percpu_counter_inc, atomic_dec, current_time, memset, ext4_mask_flags, ext4_set_inode_flags, ext4_handle_sync, insert_inode_locked, prandom_u32, ext4_chksum, ext4_clear_state_flags, ext4_set_inode_state, dquot_alloc_inode, fscrypt_inherit_context, ext4_init_acl, ext4_init_security, ext4_set_inode_flag, ext4_ext_tree_init, ext4_mark_inode_dirty, dquot_free_inode, clear_nlink, unlock_new_inode, dquot_drop, iput]\n\n2. 函数名: ext4_forced_shutdown\n- 参数: [struct ext4_sb_info *sbi]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n3. 函数名: ext4_encrypted_inode\n- 参数: [struct inode *inode]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n4. 函数名: DUMMY_ENCRYPTION_ENABLED\n- 参数: [struct ext4_sb_info *sbi]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n5. 函数名: fscrypt_get_encryption_info\n- 参数: [struct inode *inode]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n6. 函数名: fscrypt_has_encryption_key\n- 参数: [struct inode *inode]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n7. 函数名: get_acl\n- 参数: [struct inode *inode, int type]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n8. 函数名: posix_acl_release\n- 参数: [struct posix_acl *acl]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n9. 函数名: ext4_get_groups_count\n- 参数: [struct super_block *sb]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n10. 函数名: new_inode\n- 参数: [struct super_block *sb]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n11. 函数名: i_uid_write\n- 参数: [struct inode *inode, uid_t uid]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n12. 函数名: i_gid_write\n- 参数: [struct inode *inode, gid_t gid]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n13. 函数名: current_fsuid\n- 参数: []\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n14. 函数名: inode_init_owner\n- 参数: [struct inode *inode, struct inode *dir, umode_t mode]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n15. 函数名: make_kprojid\n- 参数: [struct user_namespace *ns, kprojid_t projid]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n16. 函数名: dquot_initialize\n- 参数: [struct inode *inode]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n17. 函数名: find_group_orlov\n- 参数: [struct super_block *sb, struct inode *parent, ext4_group_t *group, umode_t mode, const struct qstr *qstr]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n18. 函数名: find_group_other\n- 参数: [struct super_block *sb, struct inode *parent, ext4_group_t *group, umode_t mode]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n19. 函数名: ext4_get_group_desc\n- 参数: [struct super_block *sb, ext4_group_t block_group, struct buffer_head **bh]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n20. 函数名: ext4_get_group_info\n- 参数: [struct super_block *sb, ext4_group_t group]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n21. 函数名: brelse\n- 参数: [struct buffer_head *bh]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n22. 函数名: ext4_read_inode_bitmap\n- 参数: [struct super_block *sb, ext4_group_t block_group]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n23. 函数名: find_inode_bit\n- 参数: [struct super_block *sb, ext4_group_t group, struct buffer_head *bitmap, unsigned long *ino]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n24. 函数名: ext4_error\n- 参数: [struct super_block *sb, const char *function, const char *fmt, ...]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n25. 函数名: ext4_mark_group_bitmap_corrupted\n- 参数: [struct super_block *sb, ext4_group_t group, int flags]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n26. 函数名: __ext4_journal_start_sb\n- 参数: [struct super_block *sb, unsigned int line_no, int handle_type, int nblocks, int revoke_creds]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n27. 函数名: ext4_journal_get_write_access\n- 参数: [handle_t *handle, struct buffer_head *bh]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n28. 函数名: ext4_lock_group\n- 参数: [struct super_block *sb, ext4_group_t group]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n29. 函数名: ext4_test_and_set_bit\n- 参数: [int nr, void *addr]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n30. 函数名: ext4_unlock_group\n- 参数: [struct super_block *sb, ext4_group_t group]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n31. 函数名: ext4_handle_dirty_metadata\n- 参数: [handle_t *handle, struct inode *inode, struct buffer_head *bh]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n32. 函数名: ext4_read_block_bitmap\n- 参数: [struct super_block *sb, ext4_group_t block_group]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n33. 函数名: ext4_free_clusters_after_init\n- 参数: [struct super_block *sb, ext4_group_t block_group, struct ext4_group_desc *gdp]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n34. 函数名: ext4_block_bitmap_csum_set\n- 参数: [struct super_block *sb, ext4_group_t group, struct ext4_group_desc *gdp, struct buffer_head *bh]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n35. 函数名: ext4_group_desc_csum_set\n- 参数: [struct super_block *sb, ext4_group_t group, struct ext4_group_desc *gdp]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n36. 函数名: down_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n37. 函数名: up_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n38. 函数名: ext4_itable_unused_count\n- 参数: [struct super_block *sb, struct ext4_group_desc *gdp]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n39. 函数名: ext4_itable_unused_set\n- 参数: [struct super_block *sb, struct ext4_group_desc *gdp, __u16 count]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n40. 函数名: ext4_flex_group\n- 参数: [struct ext4_sb_info *sbi, ext4_group_t group]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n41. 函数名: atomic_inc\n- 参数: [atomic_t *v]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n42. 函数名: percpu_counter_dec\n- 参数: [struct percpu_counter *fbc]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n43. 函数名: percpu_counter_inc\n- 参数: [struct percpu_counter *fbc]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n44. 函数名: atomic_dec\n- 参数: [atomic_t *v]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n45. 函数名: current_time\n- 参数: [struct inode *inode]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n46. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n47. 函数名: ext4_mask_flags\n- 参数: [umode_t mode, int flags]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n48. 函数名: ext4_set_inode_flags\n- 参数: [struct inode *inode]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n49. 函数名: ext4_handle_sync\n- 参数: [handle_t *handle]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n50. 函数名: insert_inode_locked\n- 参数: [struct inode *inode]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n51. 函数名: prandom_u32\n- 参数: []\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n52. 函数名: ext4_chksum\n- 参数: [struct ext4_sb_info *sbi, __u32 crc, const void *address, unsigned int length]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n53. 函数名: ext4_clear_state_flags\n- 参数: [struct ext4_inode_info *ei]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n54. 函数名: ext4_set_inode_state\n- 参数: [struct inode *inode, unsigned int state]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n55. 函数名: dquot_alloc_inode\n- 参数: [struct inode *inode]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n56. 函数名: fscrypt_inherit_context\n- 参数: [struct inode *parent, struct inode *child, handle_t *handle, bool preload]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n57. 函数名: ext4_init_acl\n- 参数: [handle_t *handle, struct inode *inode, struct inode *dir]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n58. 函数名: ext4_init_security\n- 参数: [handle_t *handle, struct inode *inode, struct inode *dir, const struct qstr *qstr]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n59. 函数名: ext4_set_inode_flag\n- 参数: [struct inode *inode, int flag]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n60. 函数名: ext4_ext_tree_init\n- 参数: [handle_t *handle, struct inode *inode]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n61. 函数名: ext4_mark_inode_dirty\n- 参数: [handle_t *handle, struct inode *inode]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n62. 函数名: dquot_free_inode\n- 参数: [struct inode *inode]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n63. 函数名: clear_nlink\n- 参数: [struct inode *inode]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n64. 函数名: unlock_new_inode\n- 参数: [struct inode *inode]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n65. 函数名: dquot_drop\n- 参数: [struct inode *inode]\n- 调用者: __ext4_new_inode\n- 被调用者: []\n\n66. 函数名: iput\n- 参数: [struct inode *inode]\n- 调用者: __ext4_new_inode\n- 被调用者: []"
    },
    {
        "id": 1606,
        "cwe": "CWE-416",
        "cve": "CVE-2018-10876",
        "purpose": "Code purpose:\"\"\"该代码用于读取和验证ext4文件系统中指定块组的inode位图，处理位图的初始化和更新，并检查其有效性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4_ext_remove_space()函数中处理特制ext4镜像时，存在释放后使用(UAF)的内存安全问题\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_read_inode_bitmap\n- 参数: [struct super_block *sb, ext4_group_t block_group]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [ext4_get_group_desc, ext4_inode_bitmap, le32_to_cpu, ext4_blocks_count, ext4_error, ext4_mark_group_bitmap_corrupted, sb_getblk, bitmap_uptodate, lock_buffer, unlock_buffer, ext4_lock_group, memset, ext4_mark_bitmap_end, set_bitmap_uptodate, set_buffer_uptodate, set_buffer_verified, ext4_unlock_group, buffer_uptodate, get_bh, submit_bh, wait_on_buffer, put_bh, ext4_validate_inode_bitmap]\n\n2. 函数名: ext4_get_group_desc\n- 参数: [struct super_block *sb, ext4_group_t block_group, NULL]\n- 调用者: ext4_read_inode_bitmap\n- 被调用者: 未明确（可能为底层函数）\n\n3. 函数名: ext4_inode_bitmap\n- 参数: [struct super_block *sb, struct ext4_group_desc *desc]\n- 调用者: ext4_read_inode_bitmap\n- 被调用者: 未明确（可能为底层函数）\n\n4. 函数名: le32_to_cpu\n- 参数: [sbi->s_es->s_first_data_block]\n- 调用者: ext4_read_inode_bitmap\n- 被调用者: 未明确（可能为底层函数）\n\n5. 函数名: ext4_blocks_count\n- 参数: [sbi->s_es]\n- 调用者: ext4_read_inode_bitmap\n- 被调用者: 未明确（可能为底层函数）\n\n6. 函数名: ext4_error\n- 参数: [struct super_block *sb, \"Invalid inode bitmap blk %llu in block_group %u\", bitmap_blk, block_group]\n- 调用者: ext4_read_inode_bitmap\n- 被调用者: 未明确（可能为底层函数）\n\n7. 函数名: ext4_mark_group_bitmap_corrupted\n- 参数: [struct super_block *sb, block_group, EXT4_GROUP_INFO_IBITMAP_CORRUPT]\n- 调用者: ext4_read_inode_bitmap\n- 被调用者: 未明确（可能为底层函数）\n\n8. 函数名: sb_getblk\n- 参数: [struct super_block *sb, bitmap_blk]\n- 调用者: ext4_read_inode_bitmap\n- 被调用者: 未明确（可能为底层函数）\n\n9. 函数名: bitmap_uptodate\n- 参数: [bh]\n- 调用者: ext4_read_inode_bitmap\n- 被调用者: 未明确（可能为底层函数）\n\n10. 函数名: lock_buffer\n- 参数: [bh]\n- 调用者: ext4_read_inode_bitmap\n- 被调用者: 未明确（可能为底层函数）\n\n11. 函数名: unlock_buffer\n- 参数: [bh]\n- 调用者: ext4_read_inode_bitmap\n- 被调用者: 未明确（可能为底层函数）\n\n12. 函数名: ext4_lock_group\n- 参数: [struct super_block *sb, block_group]\n- 调用者: ext4_read_inode_bitmap\n- 被调用者: 未明确（可能为底层函数）\n\n13. 函数名: memset\n- 参数: [bh->b_data, 0, (EXT4_INODES_PER_GROUP(sb) + 7) / 8]\n- 调用者: ext4_read_inode_bitmap\n- 被调用者: 未明确（标准库函数）\n\n14. 函数名: ext4_mark_bitmap_end\n- 参数: [EXT4_INODES_PER_GROUP(sb), sb->s_blocksize * 8, bh->b_data]\n- 调用者: ext4_read_inode_bitmap\n- 被调用者: 未明确（可能为底层函数）\n\n15. 函数名: set_bitmap_uptodate\n- 参数: [bh]\n- 调用者: ext4_read_inode_bitmap\n- 被调用者: 未明确（可能为底层函数）\n\n16. 函数名: set_buffer_uptodate\n- 参数: [bh]\n- 调用者: ext4_read_inode_bitmap\n- 被调用者: 未明确（可能为底层函数）\n\n17. 函数名: set_buffer_verified\n- 参数: [bh]\n- 调用者: ext4_read_inode_bitmap\n- 被调用者: 未明确（可能为底层函数）\n\n18. 函数名: ext4_unlock_group\n- 参数: [struct super_block *sb, block_group]\n- 调用者: ext4_read_inode_bitmap\n- 被调用者: 未明确（可能为底层函数）\n\n19. 函数名: buffer_uptodate\n- 参数: [bh]\n- 调用者: ext4_read_inode_bitmap\n- 被调用者: 未明确（可能为底层函数）\n\n20. 函数名: get_bh\n- 参数: [bh]\n- 调用者: ext4_read_inode_bitmap\n- 被调用者: 未明确（可能为底层函数）\n\n21. 函数名: submit_bh\n- 参数: [REQ_OP_READ, REQ_META | REQ_PRIO, bh]\n- 调用者: ext4_read_inode_bitmap\n- 被调用者: 未明确（可能为底层函数）\n\n22. 函数名: wait_on_buffer\n- 参数: [bh]\n- 调用者: ext4_read_inode_bitmap\n- 被调用者: 未明确（可能为底层函数）\n\n23. 函数名: put_bh\n- 参数: [bh]\n- 调用者: ext4_read_inode_bitmap\n- 被调用者: 未明确（可能为底层函数）\n\n24. 函数名: ext4_validate_inode_bitmap\n- 参数: [struct super_block *sb, struct ext4_group_desc *desc, block_group, bh]\n- 调用者: ext4_read_inode_bitmap\n- 被调用者: 未明确（可能为底层函数）"
    },
    {
        "id": 1607,
        "cwe": "CWE-416",
        "cve": "CVE-2018-10876",
        "purpose": "Code purpose:\"\"\"该代码片段实现了ext4文件系统中标记已使用磁盘空间的功能，包括更新位图和组描述符等元数据操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4_ext_remove_space()函数中处理特制ext4镜像时，由于未正确管理内存引用导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_mb_mark_diskspace_used\n- 参数: [ac, handle, reserv_clstrs]\n- 调用者: N/A (顶级函数)\n- 被调用者: [ext4_read_block_bitmap, ext4_journal_get_write_access, ext4_get_group_desc, ext4_free_group_clusters, ext4_grp_offs_to_block, ext4_data_block_valid, ext4_lock_group, ext4_set_bits, ext4_unlock_group, ext4_handle_dirty_metadata, ext4_free_clusters_after_init, ext4_block_bitmap_csum_set, ext4_group_desc_csum_set, ext4_flex_group, brelse]\n\n2. 函数名: ext4_read_block_bitmap\n- 参数: [sb, fe_group]\n- 调用者: ext4_mb_mark_diskspace_used\n- 被调用者: N/A\n\n3. 函数名: ext4_journal_get_write_access\n- 参数: [handle, bitmap_bh/gdp_bh]\n- 调用者: ext4_mb_mark_diskspace_used\n- 被调用者: N/A\n\n4. 函数名: ext4_get_group_desc\n- 参数: [sb, fe_group, gdp_bh]\n- 调用者: ext4_mb_mark_diskspace_used\n- 被调用者: N/A\n\n5. 函数名: ext4_free_group_clusters\n- 参数: [sb, gdp]\n- 调用者: ext4_mb_mark_diskspace_used\n- 被调用者: N/A\n\n6. 函数名: ext4_grp_offs_to_block\n- 参数: [sb, ac_b_ex]\n- 调用者: ext4_mb_mark_diskspace_used\n- 被调用者: N/A\n\n7. 函数名: ext4_data_block_valid\n- 参数: [sbi, block, len]\n- 调用者: ext4_mb_mark_diskspace_used\n- 被调用者: N/A\n\n8. 函数名: ext4_lock_group\n- 参数: [sb, fe_group]\n- 调用者: ext4_mb_mark_diskspace_used\n- 被调用者: N/A\n\n9. 函数名: ext4_set_bits\n- 参数: [b_data, fe_start, fe_len]\n- 调用者: ext4_mb_mark_diskspace_used\n- 被调用者: N/A\n\n10. 函数名: ext4_unlock_group\n- 参数: [sb, fe_group]\n- 调用者: ext4_mb_mark_diskspace_used\n- 被调用者: N/A\n\n11. 函数名: ext4_handle_dirty_metadata\n- 参数: [handle, NULL, bitmap_bh/gdp_bh]\n- 调用者: ext4_mb_mark_diskspace_used\n- 被调用者: N/A\n\n12. 函数名: ext4_free_clusters_after_init\n- 参数: [sb, fe_group, gdp]\n- 调用者: ext4_mb_mark_diskspace_used\n- 被调用者: N/A\n\n13. 函数名: ext4_block_bitmap_csum_set\n- 参数: [sb, fe_group, gdp, bitmap_bh]\n- 调用者: ext4_mb_mark_diskspace_used\n- 被调用者: N/A\n\n14. 函数名: ext4_group_desc_csum_set\n- 参数: [sb, fe_group, gdp]\n- 调用者: ext4_mb_mark_diskspace_used\n- 被调用者: N/A\n\n15. 函数名: ext4_flex_group\n- 参数: [sbi, fe_group]\n- 调用者: ext4_mb_mark_diskspace_used\n- 被调用者: N/A\n\n16. 函数名: brelse\n- 参数: [bitmap_bh]\n- 调用者: ext4_mb_mark_diskspace_used\n- 被调用者: N/A"
    },
    {
        "id": 1608,
        "cwe": "CWE-416",
        "cve": "CVE-2018-10876",
        "purpose": "Code purpose:\"\"\"该代码用于在ext4文件系统中添加组信息，包括分配和管理组描述符信息的内存空间，并初始化相关数据结构。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4文件系统中，当操作特制的ext4镜像时，ext4_ext_remove_space()函数中存在释放后使用(UAF)的问题\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_mb_add_groupinfo\n- 参数: [struct super_block *sb, ext4_group_t group, struct ext4_group_desc *desc]\n- 调用者: 未显示（外部调用）\n- 被调用者: [get_groupinfo_cache, kmalloc, ext4_msg, kmem_cache_zalloc, set_bit, ext4_free_clusters_after_init, ext4_free_group_clusters, INIT_LIST_HEAD, init_rwsem, kfree]\n\n2. 函数名: get_groupinfo_cache\n- 参数: [sb->s_blocksize_bits]\n- 调用者: ext4_mb_add_groupinfo\n- 被调用者: 未显示\n\n3. 函数名: kmalloc\n- 参数: [metalen, GFP_NOFS]\n- 调用者: ext4_mb_add_groupinfo\n- 被调用者: 未显示\n\n4. 函数名: ext4_msg\n- 参数: [sb, KERN_ERR, \"can't allocate mem for a buddy group\"]\n- 调用者: ext4_mb_add_groupinfo\n- 被调用者: 未显示\n\n5. 函数名: kmem_cache_zalloc\n- 参数: [cachep, GFP_NOFS]\n- 调用者: ext4_mb_add_groupinfo\n- 被调用者: 未显示\n\n6. 函数名: set_bit\n- 参数: [EXT4_GROUP_INFO_NEED_INIT_BIT, &(meta_group_info[i]->bb_state)]\n- 调用者: ext4_mb_add_groupinfo\n- 被调用者: 未显示\n\n7. 函数名: ext4_free_clusters_after_init\n- 参数: [sb, group, desc]\n- 调用者: ext4_mb_add_groupinfo\n- 被调用者: 未显示\n\n8. 函数名: ext4_free_group_clusters\n- 参数: [sb, desc]\n- 调用者: ext4_mb_add_groupinfo\n- 被调用者: 未显示\n\n9. 函数名: INIT_LIST_HEAD\n- 参数: [&meta_group_info[i]->bb_prealloc_list]\n- 调用者: ext4_mb_add_groupinfo\n- 被调用者: 未显示\n\n10. 函数名: init_rwsem\n- 参数: [&meta_group_info[i]->alloc_sem]\n- 调用者: ext4_mb_add_groupinfo\n- 被调用者: 未显示\n\n11. 函数名: kfree\n- 参数: [sbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)]]\n- 调用者: ext4_mb_add_groupinfo\n- 被调用者: 未显示"
    },
    {
        "id": 1609,
        "cwe": "CWE-416",
        "cve": "CVE-2018-10876",
        "purpose": "Code purpose:\"\"\"该代码用于检查ext4文件系统中未初始化的inode表，并返回第一个未初始化的块组号\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4文件系统中处理特制镜像时，ext4_ext_remove_space()函数存在释放后使用(UAF)问题\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_has_uninit_itable\n- 参数: [struct super_block *sb]\n- 调用者: 未提供（代码片段中未显示）\n- 被调用者: [ext4_get_group_desc]\n\n2. 函数名: ext4_get_group_desc\n- 参数: [struct super_block *sb, ext4_group_t group, NULL]\n- 调用者: ext4_has_uninit_itable\n- 被调用者: 未提供（代码片段中未显示）"
    },
    {
        "id": 1612,
        "cwe": "CWE-416",
        "cve": "CVE-2018-10879",
        "purpose": "Code purpose:\"\"\"检查ext4文件系统中组描述符的有效性，包括块位图、inode位图和inode表的位置验证以及校验和检查\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4文件系统中，当用户重命名文件时，ext4_xattr_set_entry函数中存在释放后使用(UAF)漏洞，可能导致拒绝服务或其他未指定的影响。\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_check_descriptors\n- 参数: [struct super_block *sb, ext4_fsblk_t sb_block, ext4_group_t *first_not_zeroed]\n- 调用者: 未显示\n- 被调用者: [le32_to_cpu, ext4_has_feature_flex_bg, ext4_debug, ext4_get_group_desc, ext4_blocks_count, cpu_to_le16, ext4_block_bitmap, ext4_msg, sb_rdonly, ext4_inode_bitmap, ext4_inode_table, ext4_lock_group, ext4_group_desc_csum_verify, ext4_group_desc_csum, le16_to_cpu, ext4_unlock_group]\n\n2. 函数名: le32_to_cpu\n- 参数: [sbi->s_es->s_first_data_block]\n- 调用者: ext4_check_descriptors\n- 被调用者: 未显示\n\n3. 函数名: ext4_has_feature_flex_bg\n- 参数: [sb]\n- 调用者: ext4_check_descriptors\n- 被调用者: 未显示\n\n4. 函数名: ext4_debug\n- 参数: [\"Checking group descriptors\"]\n- 调用者: ext4_check_descriptors\n- 被调用者: 未显示\n\n5. 函数名: ext4_get_group_desc\n- 参数: [sb, i, NULL]\n- 调用者: ext4_check_descriptors\n- 被调用者: 未显示\n\n6. 函数名: ext4_blocks_count\n- 参数: [sbi->s_es]\n- 调用者: ext4_check_descriptors\n- 被调用者: 未显示\n\n7. 函数名: cpu_to_le16\n- 参数: [gdp->bg_flags]\n- 调用者: ext4_check_descriptors\n- 被调用者: 未显示\n\n8. 函数名: ext4_block_bitmap\n- 参数: [sb, gdp]\n- 调用者: ext4_check_descriptors\n- 被调用者: 未显示\n\n9. 函数名: ext4_msg\n- 参数: [sb, KERN_ERR, \"ext4_check_descriptors: Block bitmap for group %u overlaps superblock\", i] 等\n- 调用者: ext4_check_descriptors\n- 被调用者: 未显示\n\n10. 函数名: sb_rdonly\n- 参数: [sb]\n- 调用者: ext4_check_descriptors\n- 被调用者: 未显示\n\n11. 函数名: ext4_inode_bitmap\n- 参数: [sb, gdp]\n- 调用者: ext4_check_descriptors\n- 被调用者: 未显示\n\n12. 函数名: ext4_inode_table\n- 参数: [sb, gdp]\n- 调用者: ext4_check_descriptors\n- 被调用者: 未显示\n\n13. 函数名: ext4_lock_group\n- 参数: [sb, i]\n- 调用者: ext4_check_descriptors\n- 被调用者: 未显示\n\n14. 函数名: ext4_group_desc_csum_verify\n- 参数: [sb, i, gdp]\n- 调用者: ext4_check_descriptors\n- 被调用者: 未显示\n\n15. 函数名: ext4_group_desc_csum\n- 参数: [sb, i, gdp]\n- 调用者: ext4_check_descriptors\n- 被调用者: 未显示\n\n16. 函数名: le16_to_cpu\n- 参数: [ext4_group_desc_csum(sb, i, gdp)] 和 [gdp->bg_checksum]\n- 调用者: ext4_check_descriptors\n- 被调用者: 未显示\n\n17. 函数名: ext4_unlock_group\n- 参数: [sb, i]\n- 调用者: ext4_check_descriptors\n- 被调用者: 未显示"
    },
    {
        "id": 1621,
        "cwe": "CWE-416",
        "cve": "CVE-2018-10902",
        "purpose": "Code purpose:\"\"\"该代码用于处理原始MIDI输入流的参数设置，包括缓冲区大小和最小可用空间的验证与调整\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该代码在处理MIDI输入参数时未对并发访问进行保护，导致可能发生双重释放内存的情况。\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_rawmidi_input_params\n- 参数: [struct snd_rawmidi_substream *substream, struct snd_rawmidi_params *params]\n- 调用者: snd_rawmidi_ioctl\n- 被调用者: [snd_rawmidi_drain_input, krealloc]\n\n2. 函数名: snd_rawmidi_drain_input\n- 参数: [struct snd_rawmidi_substream *substream]\n- 调用者: snd_rawmidi_input_params\n- 被调用者: []\n\n3. 函数名: krealloc\n- 参数: [void *p, size_t new_size, gfp_t flags]\n- 调用者: snd_rawmidi_input_params\n- 被调用者: []"
    },
    {
        "id": 1622,
        "cwe": "CWE-416",
        "cve": "CVE-2018-10902",
        "purpose": "Code purpose:\"\"\"该代码用于处理MIDI输出流的参数设置，包括缓冲区大小调整和可用最小空间设置，但不具备并发访问保护机制\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未对并发访问进行保护，导致在snd_rawmidi_output_params函数中可能发生双重释放漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_rawmidi_output_params\n- 参数: [struct snd_rawmidi_substream *substream, struct snd_rawmidi_params *params]\n- 调用者: snd_rawmidi_ioctl (根据漏洞描述推断)\n- 被调用者: [snd_rawmidi_drain_output, krealloc]\n\n2. 函数名: snd_rawmidi_drain_output\n- 参数: [struct snd_rawmidi_substream *substream]\n- 调用者: snd_rawmidi_output_params\n- 被调用者: []\n\n3. 函数名: krealloc\n- 参数: [runtime->buffer, params->buffer_size, GFP_KERNEL]\n- 调用者: snd_rawmidi_output_params\n- 被调用者: []"
    },
    {
        "id": 1643,
        "cwe": "CWE-416",
        "cve": "CVE-2018-11412",
        "purpose": "Code purpose:\"\"\"该代码用于在ext4文件系统中查找并处理内联数据(inline data)的系统扩展属性，确定其偏移量和大小。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4文件系统中处理内联数据时，未对从文件系统获取的e_value_size进行充分验证，导致可能执行基于不可信长度的memcpy操作，造成内存破坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_find_inline_data_nolock\n- 参数: [struct inode *inode]\n- 调用者: 未提供\n- 被调用者: [ext4_get_inode_loc, ext4_xattr_ibody_find, brelse]\n\n2. 函数名: ext4_get_inode_loc\n- 参数: [struct inode *inode, struct ext4_iloc *iloc]\n- 调用者: ext4_find_inline_data_nolock\n- 被调用者: 未提供\n\n3. 函数名: ext4_xattr_ibody_find\n- 参数: [struct inode *inode, struct ext4_xattr_info *i, struct ext4_xattr_ibody_find *is]\n- 调用者: ext4_find_inline_data_nolock\n- 被调用者: 未提供\n\n4. 函数名: brelse\n- 参数: [struct buffer_head *bh]\n- 调用者: ext4_find_inline_data_nolock\n- 被调用者: 未提供\n\n5. 函数名: ext4_raw_inode\n- 参数: [struct ext4_iloc *iloc]\n- 调用者: ext4_find_inline_data_nolock\n- 被调用者: 未提供\n\n6. 函数名: le32_to_cpu\n- 参数: [__le32 value]\n- 调用者: ext4_find_inline_data_nolock\n- 被调用者: 未提供\n\n7. 函数名: ext4_set_inode_state\n- 参数: [struct inode *inode, unsigned long state]\n- 调用者: ext4_find_inline_data_nolock\n- 被调用者: 未提供"
    },
    {
        "id": 1680,
        "cwe": "CWE-416",
        "cve": "CVE-2018-14611",
        "purpose": "Code purpose:\"\"\"验证btrfs文件系统中chunk数据的有效性，包括长度、对齐、条带数、类型等参数是否符合规范\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在btrfs_check_chunk_valid函数中缺少对chunk类型标志的充分检查，导致在处理精心构造的btrfs镜像时可能引发use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: btrfs_check_chunk_valid\n- 参数: [struct btrfs_fs_info *fs_info, struct extent_buffer *leaf, struct btrfs_chunk *chunk, u64 logical]\n- 调用者: N/A (未在代码片段中显示)\n- 被调用者: [btrfs_chunk_length, btrfs_chunk_stripe_len, btrfs_chunk_num_stripes, btrfs_chunk_sub_stripes, btrfs_chunk_type, btrfs_err, IS_ALIGNED, btrfs_chunk_sector_size, is_power_of_2]\n\n2. 函数名: btrfs_chunk_length\n- 参数: [struct extent_buffer *leaf, struct btrfs_chunk *chunk]\n- 调用者: btrfs_check_chunk_valid\n- 被调用者: N/A\n\n3. 函数名: btrfs_chunk_stripe_len\n- 参数: [struct extent_buffer *leaf, struct btrfs_chunk *chunk]\n- 调用者: btrfs_check_chunk_valid\n- 被调用者: N/A\n\n4. 函数名: btrfs_chunk_num_stripes\n- 参数: [struct extent_buffer *leaf, struct btrfs_chunk *chunk]\n- 调用者: btrfs_check_chunk_valid\n- 被调用者: N/A\n\n5. 函数名: btrfs_chunk_sub_stripes\n- 参数: [struct extent_buffer *leaf, struct btrfs_chunk *chunk]\n- 调用者: btrfs_check_chunk_valid\n- 被调用者: N/A\n\n6. 函数名: btrfs_chunk_type\n- 参数: [struct extent_buffer *leaf, struct btrfs_chunk *chunk]\n- 调用者: btrfs_check_chunk_valid\n- 被调用者: N/A\n\n7. 函数名: btrfs_err\n- 参数: [struct btrfs_fs_info *fs_info, const char *fmt, ...]\n- 调用者: btrfs_check_chunk_valid\n- 被调用者: N/A\n\n8. 函数名: IS_ALIGNED\n- 参数: [u64 value, u64 alignment]\n- 调用者: btrfs_check_chunk_valid\n- 被调用者: N/A\n\n9. 函数名: btrfs_chunk_sector_size\n- 参数: [struct extent_buffer *leaf, struct btrfs_chunk *chunk]\n- 调用者: btrfs_check_chunk_valid\n- 被调用者: N/A\n\n10. 函数名: is_power_of_2\n- 参数: [unsigned long n]\n- 调用者: btrfs_check_chunk_valid\n- 被调用者: N/A"
    },
    {
        "id": 1693,
        "cwe": "CWE-416",
        "cve": "CVE-2018-14625",
        "purpose": "Code purpose:\"\"\"通过锁定机制获取指定guest_cid对应的vhost_vsock结构体\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于vhost_vsock_get函数中spin_lock_bh锁保护不足，导致connect()和close()函数之间存在竞争条件，可能引发内核内存信息泄露或消息劫持\"\"\"",
        "functions": "Functions:\n1. 函数名: vhost_vsock_get\n- 参数: [guest_cid]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [spin_lock_bh, __vhost_vsock_get, spin_unlock_bh]\n\n2. 函数名: spin_lock_bh\n- 参数: [&vhost_vsock_lock]\n- 调用者: vhost_vsock_get\n- 被调用者: []\n\n3. 函数名: __vhost_vsock_get\n- 参数: [guest_cid]\n- 调用者: vhost_vsock_get\n- 被调用者: []\n\n4. 函数名: spin_unlock_bh\n- 参数: [&vhost_vsock_lock]\n- 调用者: vhost_vsock_get\n- 被调用者: []"
    },
    {
        "id": 1694,
        "cwe": "CWE-416",
        "cve": "CVE-2018-14625",
        "purpose": "Code purpose:\"\"\"该代码用于在vhost传输层中取消与特定vsock套接字相关的数据包，并处理相关队列中的回复计数和轮询操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于vhost_transport_cancel_pkt函数中未正确处理vsock对象的引用计数，导致在connect()和close()并发操作时出现竞态条件，可能引发内核内存信息泄露或消息劫持。\"\"\"",
        "functions": "Functions:\n1. 函数名: vhost_transport_cancel_pkt\n- 参数: [struct vsock_sock *vsk]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [vhost_vsock_get, spin_lock_bh, list_for_each_entry_safe, list_move, spin_unlock_bh, list_del, virtio_transport_free_pkt, atomic_sub_return, vhost_poll_queue]\n\n2. 函数名: vhost_vsock_get\n- 参数: [vsk->remote_addr.svm_cid]\n- 调用者: vhost_transport_cancel_pkt\n- 被调用者: 未明确\n\n3. 函数名: spin_lock_bh\n- 参数: [&vsock->send_pkt_list_lock]\n- 调用者: vhost_transport_cancel_pkt\n- 被调用者: 未明确\n\n4. 函数名: list_for_each_entry_safe\n- 参数: [pkt, n, &vsock->send_pkt_list, list]\n- 调用者: vhost_transport_cancel_pkt\n- 被调用者: 未明确\n\n5. 函数名: list_move\n- 参数: [&pkt->list, &freeme]\n- 调用者: vhost_transport_cancel_pkt\n- 被调用者: 未明确\n\n6. 函数名: spin_unlock_bh\n- 参数: [&vsock->send_pkt_list_lock]\n- 调用者: vhost_transport_cancel_pkt\n- 被调用者: 未明确\n\n7. 函数名: list_del\n- 参数: [&pkt->list]\n- 调用者: vhost_transport_cancel_pkt\n- 被调用者: 未明确\n\n8. 函数名: virtio_transport_free_pkt\n- 参数: [pkt]\n- 调用者: vhost_transport_cancel_pkt\n- 被调用者: 未明确\n\n9. 函数名: atomic_sub_return\n- 参数: [cnt, &vsock->queued_replies]\n- 调用者: vhost_transport_cancel_pkt\n- 被调用者: 未明确\n\n10. 函数名: vhost_poll_queue\n- 参数: [&tx_vq->poll]\n- 调用者: vhost_transport_cancel_pkt\n- 被调用者: 未明确"
    },
    {
        "id": 1695,
        "cwe": "CWE-416",
        "cve": "CVE-2018-14625",
        "purpose": "Code purpose:\"\"\"该代码用于通过vhost机制传输VSOCK数据包，包括查找目标VSOCK实例、管理数据包队列并调度工作队列进行发送\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于vhost_vsock_get()获取的vsock对象在后续操作中可能被并发关闭，导致竞态条件下的内存访问问题\"\"\"",
        "functions": "Functions:\n1. 函数名: vhost_transport_send_pkt\n- 参数: [struct virtio_vsock_pkt *pkt]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [vhost_vsock_get, virtio_transport_free_pkt, atomic_inc, spin_lock_bh, list_add_tail, spin_unlock_bh, vhost_work_queue]\n\n2. 函数名: vhost_vsock_get\n- 参数: [le64_to_cpu(pkt->hdr.dst_cid)]\n- 调用者: vhost_transport_send_pkt\n- 被调用者: 未明确\n\n3. 函数名: virtio_transport_free_pkt\n- 参数: [pkt]\n- 调用者: vhost_transport_send_pkt\n- 被调用者: 未明确\n\n4. 函数名: atomic_inc\n- 参数: [&vsock->queued_replies]\n- 调用者: vhost_transport_send_pkt\n- 被调用者: 未明确\n\n5. 函数名: spin_lock_bh\n- 参数: [&vsock->send_pkt_list_lock]\n- 调用者: vhost_transport_send_pkt\n- 被调用者: 未明确\n\n6. 函数名: list_add_tail\n- 参数: [&pkt->list, &vsock->send_pkt_list]\n- 调用者: vhost_transport_send_pkt\n- 被调用者: 未明确\n\n7. 函数名: spin_unlock_bh\n- 参数: [&vsock->send_pkt_list_lock]\n- 调用者: vhost_transport_send_pkt\n- 被调用者: 未明确\n\n8. 函数名: vhost_work_queue\n- 参数: [&vsock->dev, &vsock->send_pkt_work]\n- 调用者: vhost_transport_send_pkt\n- 被调用者: 未明确"
    },
    {
        "id": 1696,
        "cwe": "CWE-416",
        "cve": "CVE-2018-14625",
        "purpose": "Code purpose:\"\"\"该代码用于在vhost_vsock中设置客户机CID（上下文ID），并确保CID的有效性和唯一性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于vhost_vsock_set_cid函数中存在竞争条件，当connect()和close()操作并发执行时，可能导致内核内存信息泄露或消息被截获或破坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: vhost_vsock_set_cid\n- 参数: [vsock, guest_cid]\n- 调用者: 未明确显示（通常由外部调用）\n- 被调用者: [__vhost_vsock_get, spin_lock_bh, spin_unlock_bh]\n\n2. 函数名: __vhost_vsock_get\n- 参数: [guest_cid]\n- 调用者: vhost_vsock_set_cid\n- 被调用者: 未显示\n\n3. 函数名: spin_lock_bh\n- 参数: [&vhost_vsock_lock]\n- 调用者: vhost_vsock_set_cid\n- 被调用者: 未显示\n\n4. 函数名: spin_unlock_bh\n- 参数: [&vhost_vsock_lock]\n- 调用者: vhost_vsock_set_cid\n- 被调用者: 未显示"
    },
    {
        "id": 1697,
        "cwe": "CWE-416",
        "cve": "CVE-2018-14625",
        "purpose": "Code purpose:\"\"\"释放vhost_vsock设备资源并清理相关数据结构\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在vhost_vsock_dev_release函数中，由于connect()和close()之间存在竞争条件，导致AF_VSOCK协议中可能出现内核内存信息泄露或消息劫持。\"\"\"",
        "functions": "Functions:\n1. 函数名: vhost_vsock_dev_release\n- 参数: [struct inode *inode, struct file *file]\n- 调用者: 无（内核回调函数）\n- 被调用者: [spin_lock_bh, list_del, spin_unlock_bh, vsock_for_each_connected_socket, vhost_vsock_stop, vhost_vsock_flush, vhost_dev_stop, list_empty, list_first_entry, list_del_init, virtio_transport_free_pkt, vhost_dev_cleanup, kfree, vhost_vsock_free]\n\n2. 函数名: spin_lock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: vhost_vsock_dev_release\n- 被调用者: 无\n\n3. 函数名: list_del\n- 参数: [struct list_head *entry]\n- 调用者: vhost_vsock_dev_release\n- 被调用者: 无\n\n4. 函数名: spin_unlock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: vhost_vsock_dev_release\n- 被调用者: 无\n\n5. 函数名: vsock_for_each_connected_socket\n- 参数: [void (*fn)(struct sock *)]\n- 调用者: vhost_vsock_dev_release\n- 被调用者: 无\n\n6. 函数名: vhost_vsock_stop\n- 参数: [struct vhost_vsock *vsock]\n- 调用者: vhost_vsock_dev_release\n- 被调用者: 无\n\n7. 函数名: vhost_vsock_flush\n- 参数: [struct vhost_vsock *vsock]\n- 调用者: vhost_vsock_dev_release\n- 被调用者: 无\n\n8. 函数名: vhost_dev_stop\n- 参数: [struct vhost_dev *dev]\n- 调用者: vhost_vsock_dev_release\n- 被调用者: 无\n\n9. 函数名: list_empty\n- 参数: [const struct list_head *head]\n- 调用者: vhost_vsock_dev_release\n- 被调用者: 无\n\n10. 函数名: list_first_entry\n- 参数: [struct list_head *ptr, type, member]\n- 调用者: vhost_vsock_dev_release\n- 被调用者: 无\n\n11. 函数名: list_del_init\n- 参数: [struct list_head *entry]\n- 调用者: vhost_vsock_dev_release\n- 被调用者: 无\n\n12. 函数名: virtio_transport_free_pkt\n- 参数: [struct virtio_vsock_pkt *pkt]\n- 调用者: vhost_vsock_dev_release\n- 被调用者: 无\n\n13. 函数名: vhost_dev_cleanup\n- 参数: [struct vhost_dev *dev]\n- 调用者: vhost_vsock_dev_release\n- 被调用者: 无\n\n14. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: vhost_vsock_dev_release\n- 被调用者: 无\n\n15. 函数名: vhost_vsock_free\n- 参数: [struct vhost_vsock *vsock]\n- 调用者: vhost_vsock_dev_release\n- 被调用者: 无"
    },
    {
        "id": 1705,
        "cwe": "CWE-416",
        "cve": "CVE-2018-14734",
        "purpose": "Code purpose:\"\"\"处理用户空间请求加入RDMA多播组的操作，包括验证参数、创建多播上下文、执行加入操作并返回结果。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ucma_process_join函数中，当错误处理流程跳转到err3时，先调用了rdma_leave_multicast操作了一个可能已被清理的mc数据结构，导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ucma_process_join\n- 参数: [struct ucma_file *file, struct rdma_ucm_join_mcast *cmd, int out_len]\n- 调用者: N/A (top-level function)\n- 被调用者: [rdma_addr_size, ucma_get_ctx_dev, ucma_alloc_multicast, memcpy, rdma_join_multicast, copy_to_user, u64_to_user_ptr, rdma_leave_multicast, ucma_cleanup_mc_events, idr_remove, list_del, kfree]\n\n2. 函数名: rdma_addr_size\n- 参数: [struct sockaddr *addr]\n- 调用者: ucma_process_join\n- 被调用者: []\n\n3. 函数名: ucma_get_ctx_dev\n- 参数: [struct ucma_file *file, cmd->id]\n- 调用者: ucma_process_join\n- 被调用者: []\n\n4. 函数名: ucma_alloc_multicast\n- 参数: [struct ucma_context *ctx]\n- 调用者: ucma_process_join\n- 被调用者: []\n\n5. 函数名: memcpy\n- 参数: [&mc->addr, addr, cmd->addr_size]\n- 调用者: ucma_process_join\n- 被调用者: []\n\n6. 函数名: rdma_join_multicast\n- 参数: [ctx->cm_id, (struct sockaddr *)&mc->addr, join_state, mc]\n- 调用者: ucma_process_join\n- 被调用者: []\n\n7. 函数名: copy_to_user\n- 参数: [u64_to_user_ptr(cmd->response), &resp, sizeof(resp)]\n- 调用者: ucma_process_join\n- 被调用者: []\n\n8. 函数名: u64_to_user_ptr\n- 参数: [cmd->response]\n- 调用者: ucma_process_join (via copy_to_user)\n- 被调用者: []\n\n9. 函数名: rdma_leave_multicast\n- 参数: [ctx->cm_id, (struct sockaddr *) &mc->addr]\n- 调用者: ucma_process_join\n- 被调用者: []\n\n10. 函数名: ucma_cleanup_mc_events\n- 参数: [mc]\n- 调用者: ucma_process_join\n- 被调用者: []\n\n11. 函数名: idr_remove\n- 参数: [&multicast_idr, mc->id]\n- 调用者: ucma_process_join\n- 被调用者: []\n\n12. 函数名: list_del\n- 参数: [&mc->list]\n- 调用者: ucma_process_join\n- 被调用者: []\n\n13. 函数名: kfree\n- 参数: [mc]\n- 调用者: ucma_process_join\n- 被调用者: []"
    },
    {
        "id": 1706,
        "cwe": "CWE-416",
        "cve": "CVE-2018-14734",
        "purpose": "Code purpose:\"\"\"分配并初始化一个多播结构体，将其加入上下文的多播列表中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ucma_leave_multicast中访问了已被ucma_process_join清理的数据结构，导致释放后使用(use-after-free)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ucma_alloc_multicast\n- 参数: [struct ucma_context *ctx]\n- 调用者: 未明确显示（通常由需要分配多播结构的函数调用）\n- 被调用者: [kzalloc, mutex_lock, idr_alloc, mutex_unlock, list_add_tail, kfree]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*mc), GFP_KERNEL]\n- 调用者: ucma_alloc_multicast\n- 被调用者: []\n\n3. 函数名: mutex_lock\n- 参数: [&mut]\n- 调用者: ucma_alloc_multicast\n- 被调用者: []\n\n4. 函数名: idr_alloc\n- 参数: [&multicast_idr, mc, 0, 0, GFP_KERNEL]\n- 调用者: ucma_alloc_multicast\n- 被调用者: []\n\n5. 函数名: mutex_unlock\n- 参数: [&mut]\n- 调用者: ucma_alloc_multicast\n- 被调用者: []\n\n6. 函数名: list_add_tail\n- 参数: [&mc->list, &ctx->mc_list]\n- 调用者: ucma_alloc_multicast\n- 被调用者: []\n\n7. 函数名: kfree\n- 参数: [mc]\n- 调用者: ucma_alloc_multicast\n- 被调用者: []"
    },
    {
        "id": 1721,
        "cwe": "CWE-416",
        "cve": "CVE-2018-16882",
        "purpose": "Code purpose:\"\"\"处理嵌套虚拟化中VMCS12页面的映射和配置，包括APIC访问页、虚拟APIC页和发布中断描述符页的设置\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在嵌套虚拟化环境下处理posted interrupt地址错误时，未正确重置pi_desc描述符地址，导致后续使用时可能引用已释放的内存\"\"\"",
        "functions": "Functions:\n1. 函数名: nested_get_vmcs12_pages\n- 参数: [vcpu]\n- 调用者: N/A\n- 被调用者: [get_vmcs12, to_vmx, nested_cpu_has2, kvm_release_page_dirty, kvm_vcpu_gpa_to_page, is_error_page, page_to_phys, vmcs_write64, vmcs_clear_bits, nested_cpu_has, kunmap, kmap, nested_vmx_prepare_msr_bitmap, vmcs_set_bits]\n\n2. 函数名: get_vmcs12\n- 参数: [vcpu]\n- 调用者: nested_get_vmcs12_pages\n- 被调用者: N/A\n\n3. 函数名: to_vmx\n- 参数: [vcpu]\n- 调用者: nested_get_vmcs12_pages\n- 被调用者: N/A\n\n4. 函数名: nested_cpu_has2\n- 参数: [vmcs12, SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES]\n- 调用者: nested_get_vmcs12_pages\n- 被调用者: N/A\n\n5. 函数名: kvm_release_page_dirty\n- 参数: [page]\n- 调用者: nested_get_vmcs12_pages\n- 被调用者: N/A\n\n6. 函数名: kvm_vcpu_gpa_to_page\n- 参数: [vcpu, addr]\n- 调用者: nested_get_vmcs12_pages\n- 被调用者: N/A\n\n7. 函数名: is_error_page\n- 参数: [page]\n- 调用者: nested_get_vmcs12_pages\n- 被调用者: N/A\n\n8. 函数名: page_to_phys\n- 参数: [page]\n- 调用者: nested_get_vmcs12_pages\n- 被调用者: N/A\n\n9. 函数名: vmcs_write64\n- 参数: [field, value]\n- 调用者: nested_get_vmcs12_pages\n- 被调用者: N/A\n\n10. 函数名: vmcs_clear_bits\n- 参数: [field, bits]\n- 调用者: nested_get_vmcs12_pages\n- 被调用者: N/A\n\n11. 函数名: nested_cpu_has\n- 参数: [vmcs12, CPU_BASED_TPR_SHADOW]\n- 调用者: nested_get_vmcs12_pages\n- 被调用者: N/A\n\n12. 函数名: kunmap\n- 参数: [page]\n- 调用者: nested_get_vmcs12_pages\n- 被调用者: N/A\n\n13. 函数名: kmap\n- 参数: [page]\n- 调用者: nested_get_vmcs12_pages\n- 被调用者: N/A\n\n14. 函数名: nested_vmx_prepare_msr_bitmap\n- 参数: [vcpu, vmcs12]\n- 调用者: nested_get_vmcs12_pages\n- 被调用者: N/A\n\n15. 函数名: vmcs_set_bits\n- 参数: [field, bits]\n- 调用者: nested_get_vmcs12_pages\n- 被调用者: N/A"
    },
    {
        "id": 1722,
        "cwe": "CWE-416",
        "cve": "CVE-2018-16884",
        "purpose": "Code purpose:\"\"\"处理NFS服务的RPC请求，包括验证、版本检查、程序/过程查找以及请求处理，并生成相应的响应。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在不同网络命名空间中同时挂载NFS41+共享时，bc_svc_process()使用了错误的back-channel ID，导致释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: svc_process_common\n- 参数: [struct svc_rqst *rqstp, struct kvec *argv, struct kvec *resv]\n- 调用者: N/A (顶层函数)\n- 被调用者: [svc_putu32, svc_getnl, svc_authenticate, svc_authorise, svc_close_xprt, svc_printk, svc_reserve_auth, xdr_ressize_check, dprintk, memset, test_bit, set_bit, clear_bit, ntohl]\n\n2. 函数名: svc_putu32\n- 参数: [struct kvec *resv, __be32 value]\n- 调用者: svc_process_common\n- 被调用者: N/A\n\n3. 函数名: svc_getnl\n- 参数: [struct kvec *argv]\n- 调用者: svc_process_common\n- 被调用者: N/A\n\n4. 函数名: svc_authenticate\n- 参数: [struct svc_rqst *rqstp, __be32 *auth_stat]\n- 调用者: svc_process_common\n- 被调用者: N/A\n\n5. 函数名: svc_authorise\n- 参数: [struct svc_rqst *rqstp]\n- 调用者: svc_process_common\n- 被调用者: N/A\n\n6. 函数名: svc_close_xprt\n- 参数: [struct svc_xprt *xprt]\n- 调用者: svc_process_common\n- 被调用者: N/A\n\n7. 函数名: svc_printk\n- 参数: [struct svc_rqst *rqstp, const char *fmt, ...]\n- 调用者: svc_process_common\n- 被调用者: N/A\n\n8. 函数名: svc_reserve_auth\n- 参数: [struct svc_rqst *rqstp, int size]\n- 调用者: svc_process_common\n- 被调用者: N/A\n\n9. 函数名: xdr_ressize_check\n- 参数: [struct svc_rqst *rqstp, __be32 *reply_statp]\n- 调用者: svc_process_common\n- 被调用者: N/A\n\n10. 函数名: dprintk\n- 参数: [const char *fmt, ...]\n- 调用者: svc_process_common\n- 被调用者: N/A\n\n11. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: svc_process_common\n- 被调用者: N/A\n\n12. 函数名: test_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: svc_process_common\n- 被调用者: N/A\n\n13. 函数名: set_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: svc_process_common\n- 被调用者: N/A\n\n14. 函数名: clear_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: svc_process_common\n- 被调用者: N/A\n\n15. 函数名: ntohl\n- 参数: [__be32 netlong]\n- 调用者: svc_process_common\n- 被调用者: N/A"
    },
    {
        "id": 1723,
        "cwe": "CWE-416",
        "cve": "CVE-2018-16884",
        "purpose": "Code purpose:\"\"\"处理NFSv4.1+的回调请求，包括参数解析、执行请求和同步发送响应\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在不同网络命名空间中同时挂载NFS41+共享时，bc_svc_process()函数使用了错误的back-channel ID，导致释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: bc_svc_process\n- 参数: [serv, req, rqstp]\n- 调用者: 未显示\n- 被调用者: [dprintk, memcpy, svc_getu32, svc_getnl, svc_process_common, atomic_inc, xprt_free_bc_request, rpc_run_bc_task, IS_ERR, PTR_ERR, atomic_read, rpc_put_task]\n\n2. 函数名: dprintk\n- 参数: [format string, req]\n- 调用者: bc_svc_process\n- 被调用者: []\n\n3. 函数名: memcpy\n- 参数: [dest, src, size]\n- 调用者: bc_svc_process\n- 被调用者: []\n\n4. 函数名: svc_getu32\n- 参数: [argv]\n- 调用者: bc_svc_process\n- 被调用者: []\n\n5. 函数名: svc_getnl\n- 参数: [argv]\n- 调用者: bc_svc_process\n- 被调用者: []\n\n6. 函数名: svc_process_common\n- 参数: [rqstp, argv, resv]\n- 调用者: bc_svc_process\n- 被调用者: []\n\n7. 函数名: atomic_inc\n- 参数: [&req->rq_xprt->bc_free_slots]\n- 调用者: bc_svc_process\n- 被调用者: []\n\n8. 函数名: xprt_free_bc_request\n- 参数: [req]\n- 调用者: bc_svc_process\n- 被调用者: []\n\n9. 函数名: rpc_run_bc_task\n- 参数: [req]\n- 调用者: bc_svc_process\n- 被调用者: []\n\n10. 函数名: IS_ERR\n- 参数: [task]\n- 调用者: bc_svc_process\n- 被调用者: []\n\n11. 函数名: PTR_ERR\n- 参数: [task]\n- 调用者: bc_svc_process\n- 被调用者: []\n\n12. 函数名: atomic_read\n- 参数: [&task->tk_count]\n- 调用者: bc_svc_process\n- 被调用者: []\n\n13. 函数名: rpc_put_task\n- 参数: [task]\n- 调用者: bc_svc_process\n- 被调用者: []"
    },
    {
        "id": 1724,
        "cwe": "CWE-416",
        "cve": "CVE-2018-16884",
        "purpose": "Code purpose:\"\"\"调整NFS服务请求的预留空间并更新传输通道的预留计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于NFS41+子系统在不同网络命名空间中共享挂载时，bc_svc_process()使用了错误的back-channel ID，导致释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: svc_reserve\n- 参数: [rqstp, space]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [atomic_sub, svc_xprt_enqueue]\n\n2. 函数名: atomic_sub\n- 参数: [(rqstp->rq_reserved - space), &xprt->xpt_reserved]\n- 调用者: svc_reserve\n- 被调用者: 未明确（系统原子操作函数）\n\n3. 函数名: svc_xprt_enqueue\n- 参数: [xprt]\n- 调用者: svc_reserve\n- 被调用者: 未明确（上下文未提供）"
    },
    {
        "id": 1725,
        "cwe": "CWE-416",
        "cve": "CVE-2018-16884",
        "purpose": "Code purpose:\"\"\"为NFS TCP响应准备头部信息，包括预留记录长度空间\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"NFS41+在不同网络命名空间中同时挂载共享时，导致bc_svc_process()使用了错误的back-channel ID，引发了释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: svc_tcp_prep_reply_hdr\n- 参数: [struct svc_rqst *rqstp]\n- 调用者: 未明确（由NFS41+子系统调用）\n- 被调用者: [svc_putnl]\n\n2. 函数名: svc_putnl\n- 参数: [struct kvec *resv, int 0]\n- 调用者: svc_tcp_prep_reply_hdr\n- 被调用者: 未明确"
    },
    {
        "id": 1726,
        "cwe": "CWE-416",
        "cve": "CVE-2018-17182",
        "purpose": "Code purpose:\"\"\"处理虚拟内存地址缓存无效化时的序列号溢出问题\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于vmacache_seqnum溢出处理不当，导致在序列号回绕时可能引发use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: vmacache_invalidate\n- 参数: [struct mm_struct *mm]\n- 调用者: 未指定\n- 被调用者: [vmacache_flush_all]\n\n2. 函数名: vmacache_flush_all\n- 参数: [struct mm_struct *mm]\n- 调用者: [vmacache_invalidate]\n- 被调用者: 未指定"
    },
    {
        "id": 1727,
        "cwe": "CWE-416",
        "cve": "CVE-2018-17182",
        "purpose": "Code purpose:\"\"\"该代码用于打印内存管理结构体mm_struct的详细信息，包括内存映射、任务大小、页表信息等内核内存状态数据。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中的vmacache_flush_all函数未能正确处理序列号溢出问题，导致在特定线程操作序列下可能引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: dump_mm\n- 参数: [const struct mm_struct *mm]\n- 调用者: 未明确显示（通常是内核调试或崩溃处理相关代码）\n- 被调用者: [pr_emerg, atomic_read, mm_pgtables_bytes]\n\n2. 函数名: pr_emerg\n- 参数: [格式化字符串及多个变量参数]\n- 调用者: dump_mm\n- 被调用者: []\n\n3. 函数名: atomic_read\n- 参数: [atomic_t *v]\n- 调用者: dump_mm\n- 被调用者: []\n\n4. 函数名: mm_pgtables_bytes\n- 参数: [struct mm_struct *mm]\n- 调用者: dump_mm\n- 被调用者: []"
    },
    {
        "id": 1739,
        "cwe": "CWE-416",
        "cve": "CVE-2018-18559",
        "purpose": "Code purpose:\"\"\"该代码实现了AF_PACKET套接字的绑定功能，处理网络设备名称或索引与协议类型的绑定关系，并在需要时重新注册协议钩子。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在多线程环境下对AF_PACKET套接字的fanout_add和bind操作存在竞争条件，导致未正确处理的解注册和重新注册操作引发use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: packet_do_bind\n- 参数: [sk, name, ifindex, proto]\n- 调用者: N/A (顶层函数)\n- 被调用者: [pkt_sk, lock_sock, spin_lock, rcu_read_lock, dev_get_by_name_rcu, dev_get_by_index_rcu, dev_hold, __unregister_prot_hook, dev_get_by_index_rcu, dev_put, packet_cached_dev_reset, packet_cached_dev_assign, register_prot_hook, rcu_read_unlock, spin_unlock, release_sock]\n\n2. 函数名: pkt_sk\n- 参数: [sk]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n3. 函数名: lock_sock\n- 参数: [sk]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n4. 函数名: spin_lock\n- 参数: [&po->bind_lock]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n5. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: packet_do_bind\n- 被调用者: []\n\n6. 函数名: dev_get_by_name_rcu\n- 参数: [sock_net(sk), name]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n7. 函数名: dev_get_by_index_rcu\n- 参数: [sock_net(sk), ifindex]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n8. 函数名: dev_hold\n- 参数: [dev]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n9. 函数名: __unregister_prot_hook\n- 参数: [sk, true]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n10. 函数名: dev_put\n- 参数: [dev_curr]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n11. 函数名: packet_cached_dev_reset\n- 参数: [po]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n12. 函数名: packet_cached_dev_assign\n- 参数: [po, dev]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n13. 函数名: register_prot_hook\n- 参数: [sk]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n14. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: packet_do_bind\n- 被调用者: []\n\n15. 函数名: spin_unlock\n- 参数: [&po->bind_lock]\n- 调用者: packet_do_bind\n- 被调用者: []\n\n16. 函数名: release_sock\n- 参数: [sk]\n- 调用者: packet_do_bind\n- 被调用者: []"
    },
    {
        "id": 1745,
        "cwe": "CWE-416",
        "cve": "CVE-2018-19824",
        "purpose": "Code purpose:\"\"\"该代码用于处理USB音频设备的探测和初始化，包括设备识别、配置检查、资源分配和ALSA音频接口的创建与注册。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当恶意USB音频设备提供零接口时，usb_audio_probe函数未能正确处理这种情况，导致对已释放内存的引用，产生use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: usb_audio_probe\n- 参数: [struct usb_interface *intf, const struct usb_device_id *usb_id]\n- 调用者: 内核USB子系统\n- 被调用者: [interface_to_usbdev, get_iface_desc, get_alias_id, get_alias_quirk, snd_usb_apply_boot_quirk, snd_usb_audio_create, snd_usb_create_quirk, snd_usb_create_streams, snd_usb_create_mixer, snd_card_register, snd_card_free]\n\n2. 函数名: interface_to_usbdev\n- 参数: [struct usb_interface *intf]\n- 调用者: usb_audio_probe\n- 被调用者: []\n\n3. 函数名: get_iface_desc\n- 参数: [struct usb_host_interface *alts]\n- 调用者: usb_audio_probe\n- 被调用者: []\n\n4. 函数名: get_alias_id\n- 参数: [struct usb_device *dev, u32 *id]\n- 调用者: usb_audio_probe\n- 被调用者: []\n\n5. 函数名: get_alias_quirk\n- 参数: [struct usb_device *dev, u32 id]\n- 调用者: usb_audio_probe\n- 被调用者: []\n\n6. 函数名: snd_usb_apply_boot_quirk\n- 参数: [struct usb_device *dev, struct usb_interface *intf, const struct snd_usb_audio_quirk *quirk, u32 id]\n- 调用者: usb_audio_probe\n- 被调用者: []\n\n7. 函数名: snd_usb_audio_create\n- 参数: [struct usb_interface *intf, struct usb_device *dev, int i, const struct snd_usb_audio_quirk *quirk, u32 id, struct snd_usb_audio **chip]\n- 调用者: usb_audio_probe\n- 被调用者: []\n\n8. 函数名: snd_usb_create_quirk\n- 参数: [struct snd_usb_audio *chip, struct usb_interface *intf, struct usb_driver *driver, const struct snd_usb_audio_quirk *quirk]\n- 调用者: usb_audio_probe\n- 被调用者: []\n\n9. 函数名: snd_usb_create_streams\n- 参数: [struct snd_usb_audio *chip, int ifnum]\n- 调用者: usb_audio_probe\n- 被调用者: []\n\n10. 函数名: snd_usb_create_mixer\n- 参数: [struct snd_usb_audio *chip, int ifnum, int ignore_ctl_error]\n- 调用者: usb_audio_probe\n- 被调用者: []\n\n11. 函数名: snd_card_register\n- 参数: [struct snd_card *card]\n- 调用者: usb_audio_probe\n- 被调用者: []\n\n12. 函数名: snd_card_free\n- 参数: [struct snd_card *card]\n- 调用者: usb_audio_probe\n- 被调用者: []"
    },
    {
        "id": 1782,
        "cwe": "CWE-416",
        "cve": "CVE-2018-20836",
        "purpose": "Code purpose:\"\"\"处理SAS任务超时，设置任务状态为中止并完成相关慢任务的完成通知\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于smp_task_timedout()和smp_task_done()之间存在竞争条件，导致在释放任务资源后仍可能被访问，造成释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: smp_task_timedout\n- 参数: [t]\n- 调用者: 未显示（由定时器回调触发）\n- 被调用者: [from_timer, spin_lock_irqsave, spin_unlock_irqrestore, complete]\n\n2. 函数名: from_timer\n- 参数: [slow, t, timer]\n- 调用者: smp_task_timedout\n- 被调用者: []\n\n3. 函数名: spin_lock_irqsave\n- 参数: [&task->task_state_lock, flags]\n- 调用者: smp_task_timedout\n- 被调用者: []\n\n4. 函数名: spin_unlock_irqrestore\n- 参数: [&task->task_state_lock, flags]\n- 调用者: smp_task_timedout\n- 被调用者: []\n\n5. 函数名: complete\n- 参数: [&task->slow_task->completion]\n- 调用者: smp_task_timedout\n- 被调用者: []"
    },
    {
        "id": 1783,
        "cwe": "CWE-416",
        "cve": "CVE-2018-20836",
        "purpose": "Code purpose:\"\"\"在SCSI SAS扩展器驱动中处理慢速任务的完成，包括取消定时器和通知任务完成\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于smp_task_done()函数中未正确处理定时器删除与任务完成之间的竞争条件，导致可能发生释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: smp_task_done\n- 参数: [struct sas_task *task]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [del_timer, complete]\n\n2. 函数名: del_timer\n- 参数: [&task->slow_task->timer]\n- 调用者: smp_task_done\n- 被调用者: []\n\n3. 函数名: complete\n- 参数: [&task->slow_task->completion]\n- 调用者: smp_task_done\n- 被调用者: []"
    },
    {
        "id": 1787,
        "cwe": "CWE-416",
        "cve": "CVE-2018-20856",
        "purpose": "Code purpose:\"\"\"初始化一个已分配请求队列的结构，包括分配刷新队列、初始化请求处理函数、设置队列标志等工作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在错误处理路径中未正确清理队列资源，导致在__blk_drain_queue()中可能访问已释放的内存\"\"\"",
        "functions": "Functions:\n1. 函数名: blk_init_allocated_queue\n- 参数: [struct request_queue *q]\n- 调用者: N/A\n- 被调用者: [blk_alloc_flush_queue, q->init_rq_fn, blk_init_rl, INIT_WORK, blk_queue_make_request, elevator_init, q->exit_rq_fn, blk_free_flush_queue]\n\n2. 函数名: blk_alloc_flush_queue\n- 参数: [struct request_queue *q, int NUMA_NO_NODE, int q->cmd_size]\n- 调用者: blk_init_allocated_queue\n- 被调用者: N/A\n\n3. 函数名: blk_init_rl\n- 参数: [&q->root_rl, q, GFP_KERNEL]\n- 调用者: blk_init_allocated_queue\n- 被调用者: N/A\n\n4. 函数名: INIT_WORK\n- 参数: [&q->timeout_work, blk_timeout_work]\n- 调用者: blk_init_allocated_queue\n- 被调用者: N/A\n\n5. 函数名: blk_queue_make_request\n- 参数: [q, blk_queue_bio]\n- 调用者: blk_init_allocated_queue\n- 被调用者: N/A\n\n6. 函数名: elevator_init\n- 参数: [q]\n- 调用者: blk_init_allocated_queue\n- 被调用者: N/A\n\n7. 函数名: blk_free_flush_queue\n- 参数: [q->fq]\n- 调用者: blk_init_allocated_queue\n- 被调用者: N/A"
    },
    {
        "id": 1790,
        "cwe": "CWE-416",
        "cve": "CVE-2018-20976",
        "purpose": "Code purpose:\"\"\"卸载XFS文件系统并释放相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在xfs_fs_fill_super失败时，未正确处理资源释放导致后续对已释放内存的引用\"\"\"",
        "functions": "Functions:\n1. 函数名: xfs_fs_put_super\n- 参数: [struct super_block *sb]\n- 调用者: 未显示\n- 被调用者: [XFS, xfs_notice, xfs_filestream_unmount, xfs_unmountfs, xfs_freesb, free_percpu, xfs_destroy_percpu_counters, xfs_destroy_mount_workqueues, xfs_close_devices, xfs_free_fsname, kfree]\n\n2. 函数名: XFS\n- 参数: [struct super_block *sb]\n- 调用者: xfs_fs_put_super\n- 被调用者: 未显示\n\n3. 函数名: xfs_notice\n- 参数: [struct xfs_mount *mp, const char *fmt]\n- 调用者: xfs_fs_put_super\n- 被调用者: 未显示\n\n4. 函数名: xfs_filestream_unmount\n- 参数: [struct xfs_mount *mp]\n- 调用者: xfs_fs_put_super\n- 被调用者: 未显示\n\n5. 函数名: xfs_unmountfs\n- 参数: [struct xfs_mount *mp]\n- 调用者: xfs_fs_put_super\n- 被调用者: 未显示\n\n6. 函数名: xfs_freesb\n- 参数: [struct xfs_mount *mp]\n- 调用者: xfs_fs_put_super\n- 被调用者: 未显示\n\n7. 函数名: free_percpu\n- 参数: [void *__pdata]\n- 调用者: xfs_fs_put_super\n- 被调用者: 未显示\n\n8. 函数名: xfs_destroy_percpu_counters\n- 参数: [struct xfs_mount *mp]\n- 调用者: xfs_fs_put_super\n- 被调用者: 未显示\n\n9. 函数名: xfs_destroy_mount_workqueues\n- 参数: [struct xfs_mount *mp]\n- 调用者: xfs_fs_put_super\n- 被调用者: 未显示\n\n10. 函数名: xfs_close_devices\n- 参数: [struct xfs_mount *mp]\n- 调用者: xfs_fs_put_super\n- 被调用者: 未显示\n\n11. 函数名: xfs_free_fsname\n- 参数: [struct xfs_mount *mp]\n- 调用者: xfs_fs_put_super\n- 被调用者: 未显示\n\n12. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: xfs_fs_put_super\n- 被调用者: 未显示"
    },
    {
        "id": 1791,
        "cwe": "CWE-416",
        "cve": "CVE-2018-20976",
        "purpose": "Code purpose:\"\"\"该代码用于统计XFS文件系统中可回收的inode缓存对象数量\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在xfs_fs_fill_super失败时，xfs_fs_nr_cached_objects函数可能访问已释放的内存，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: xfs_fs_nr_cached_objects\n- 参数: [struct super_block *sb, struct shrink_control *sc]\n- 调用者: 未明确（通常由内存管理子系统调用）\n- 被调用者: [xfs_reclaim_inodes_count, XFS_M]\n\n2. 函数名: xfs_reclaim_inodes_count\n- 参数: [未明确（应为XFS挂载点结构体指针）]\n- 调用者: xfs_fs_nr_cached_objects\n- 被调用者: []\n\n3. 函数名: XFS_M\n- 参数: [struct super_block *sb]\n- 调用者: xfs_fs_nr_cached_objects\n- 被调用者: []"
    },
    {
        "id": 1792,
        "cwe": "CWE-416",
        "cve": "CVE-2018-20976",
        "purpose": "Code purpose:\"\"\"该代码用于实现XFS文件系统的超级块填充和挂载操作，包括初始化文件系统参数、设备处理、工作队列设置以及错误处理等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在xfs_fs_fill_super函数中，当挂载失败时未正确清理已分配的mp结构体，导致后续可能发生释放后使用(use-after-free)问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: xfs_fs_fill_super\n- 参数: [struct super_block *sb, void *data, int silent]\n- 调用者: 未显示（应为文件系统挂载相关调用）\n- 被调用者: [xfs_mount_alloc, xfs_parseargs, sb_min_blocksize, xfs_open_devices, xfs_init_mount_workqueues, xfs_init_percpu_counters, alloc_percpu, xfs_readsb, xfs_finish_flags, xfs_setup_devices, xfs_filestream_mount, bdev_dax_supported, bdev_get_queue, blk_queue_discard, xfs_mountfs, igrab, VFS_I, d_make_root, xfs_filestream_unmount, xfs_freesb, free_percpu, xfs_destroy_percpu_counters, xfs_destroy_mount_workqueues, xfs_close_devices, xfs_free_fsname, kfree, xfs_unmountfs]\n\n2. 函数名: xfs_mount_alloc\n- 参数: [struct super_block *sb]\n- 调用者: xfs_fs_fill_super\n- 被调用者: 未显示\n\n3. 函数名: xfs_parseargs\n- 参数: [struct xfs_mount *mp, char *data]\n- 调用者: xfs_fs_fill_super\n- 被调用者: 未显示\n\n4. 函数名: xfs_open_devices\n- 参数: [struct xfs_mount *mp]\n- 调用者: xfs_fs_fill_super\n- 被调用者: 未显示\n\n5. 函数名: xfs_init_mount_workqueues\n- 参数: [struct xfs_mount *mp]\n- 调用者: xfs_fs_fill_super\n- 被调用者: 未显示\n\n6. 函数名: xfs_init_percpu_counters\n- 参数: [struct xfs_mount *mp]\n- 调用者: xfs_fs_fill_super\n- 被调用者: 未显示\n\n7. 函数名: xfs_readsb\n- 参数: [struct xfs_mount *mp, int flags]\n- 调用者: xfs_fs_fill_super\n- 被调用者: 未显示\n\n8. 函数名: xfs_finish_flags\n- 参数: [struct xfs_mount *mp]\n- 调用者: xfs_fs_fill_super\n- 被调用者: 未显示\n\n9. 函数名: xfs_setup_devices\n- 参数: [struct xfs_mount *mp]\n- 调用者: xfs_fs_fill_super\n- 被调用者: 未显示\n\n10. 函数名: xfs_filestream_mount\n- 参数: [struct xfs_mount *mp]\n- 调用者: xfs_fs_fill_super\n- 被调用者: 未显示\n\n11. 函数名: xfs_mountfs\n- 参数: [struct xfs_mount *mp]\n- 调用者: xfs_fs_fill_super\n- 被调用者: 未显示\n\n12. 函数名: xfs_filestream_unmount\n- 参数: [struct xfs_mount *mp]\n- 调用者: xfs_fs_fill_super\n- 被调用者: 未显示\n\n13. 函数名: xfs_freesb\n- 参数: [struct xfs_mount *mp]\n- 调用者: xfs_fs_fill_super\n- 被调用者: 未显示\n\n14. 函数名: xfs_destroy_percpu_counters\n- 参数: [struct xfs_mount *mp]\n- 调用者: xfs_fs_fill_super\n- 被调用者: 未显示\n\n15. 函数名: xfs_destroy_mount_workqueues\n- 参数: [struct xfs_mount *mp]\n- 调用者: xfs_fs_fill_super\n- 被调用者: 未显示\n\n16. 函数名: xfs_close_devices\n- 参数: [struct xfs_mount *mp]\n- 调用者: xfs_fs_fill_super\n- 被调用者: 未显示\n\n17. 函数名: xfs_free_fsname\n- 参数: [struct xfs_mount *mp]\n- 调用者: xfs_fs_fill_super\n- 被调用者: 未显示\n\n18. 函数名: xfs_unmountfs\n- 参数: [struct xfs_mount *mp]\n- 调用者: xfs_fs_fill_super\n- 被调用者: 未显示"
    },
    {
        "id": 1793,
        "cwe": "CWE-416",
        "cve": "CVE-2018-21008",
        "purpose": "Code purpose:\"\"\"释放无线网络适配器资源并注销相关硬件注册\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放适配器结构体后仍访问其成员sbands，导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: rsi_mac80211_detach\n- 参数: [struct rsi_hw *adapter]\n- 调用者: 未显示\n- 被调用者: [ieee80211_stop_queues, ieee80211_unregister_hw, ieee80211_free_hw, kfree, rsi_remove_dbgfs]\n\n2. 函数名: ieee80211_stop_queues\n- 参数: [struct ieee80211_hw *hw]\n- 调用者: rsi_mac80211_detach\n- 被调用者: 未显示\n\n3. 函数名: ieee80211_unregister_hw\n- 参数: [struct ieee80211_hw *hw]\n- 调用者: rsi_mac80211_detach\n- 被调用者: 未显示\n\n4. 函数名: ieee80211_free_hw\n- 参数: [struct ieee80211_hw *hw]\n- 调用者: rsi_mac80211_detach\n- 被调用者: 未显示\n\n5. 函数名: kfree\n- 参数: [sband->channels], [adapter->dfsentry]\n- 调用者: rsi_mac80211_detach\n- 被调用者: 未显示\n\n6. 函数名: rsi_remove_dbgfs\n- 参数: [struct rsi_hw *adapter]\n- 调用者: rsi_mac80211_detach\n- 被调用者: 未显示"
    },
    {
        "id": 1794,
        "cwe": "CWE-416",
        "cve": "CVE-2018-25015",
        "purpose": "Code purpose:\"\"\"该代码实现了SCTP协议中发送消息的功能，包括处理消息头、验证地址、管理关联(association)、处理数据分片以及底层传输等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在SCTP协议实现中，当执行peel off操作后未正确处理持有的锁，导致后续操作中可能访问已释放的内存区域，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: sctp_sendmsg\n- 参数: [struct sock *sk, struct msghdr *msg, size_t msg_len]\n- 调用者: 无（系统调用）\n- 被调用者: [sock_net, sctp_sk, sctp_style, sctp_sstate, sctp_msghdr_parse, sctp_verify_addr, memcpy, memset, sctp_endpoint_lookup_assoc, sctp_endpoint_is_peeled_off, sctp_id2assoc, sctp_state, sctp_primitive_SHUTDOWN, sctp_make_abort_user, sctp_primitive_ABORT, sctp_autobind, ns_capable, sctp_scope, sctp_association_new, sctp_assoc_set_bind_addr_from_ep, sctp_stream_init, sctp_assoc_add_peer, sctp_assoc2id, sctp_assoc_pending_pmtu, sctp_stream_init_ext, sctp_wspace, sctp_prsctp_prune, sock_sndtimeo, sctp_wait_for_sndbuf, sctp_assoc_lookup_paddr, sctp_primitive_ASSOCIATE, sctp_datamsg_from_user, sctp_chunk_hold, sctp_set_owner_w, sctp_primitive_SEND, sctp_datamsg_free, sctp_datamsg_put, sctp_wait_for_connect, sctp_association_free, release_sock, sctp_error]\n\n2. 函数名: sctp_msghdr_parse\n- 参数: [struct msghdr *msg, struct sctp_cmsgs *cmsgs]\n- 调用者: sctp_sendmsg\n- 被调用者: 无\n\n3. 函数名: sctp_verify_addr\n- 参数: [struct sock *sk, union sctp_addr *addr, int addr_len]\n- 调用者: sctp_sendmsg\n- 被调用者: 无\n\n4. 函数名: sctp_endpoint_lookup_assoc\n- 参数: [struct sctp_endpoint *ep, union sctp_addr *to, struct sctp_transport **transport]\n- 调用者: sctp_sendmsg\n- 被调用者: 无\n\n5. 函数名: sctp_endpoint_is_peeled_off\n- 参数: [struct sctp_endpoint *ep, union sctp_addr *addr]\n- 调用者: sctp_sendmsg\n- 被调用者: 无\n\n6. 函数名: sctp_id2assoc\n- 参数: [struct sock *sk, sctp_assoc_t id]\n- 调用者: sctp_sendmsg\n- 被调用者: 无\n\n7. 函数名: sctp_make_abort_user\n- 参数: [struct sctp_association *asoc, struct msghdr *msg, size_t msg_len]\n- 调用者: sctp_sendmsg\n- 被调用者: 无\n\n8. 函数名: sctp_autobind\n- 参数: [struct sock *sk]\n- 调用者: sctp_sendmsg\n- 被调用者: 无\n\n9. 函数名: sctp_association_new\n- 参数: [struct sctp_endpoint *ep, struct sock *sk, enum sctp_scope scope, gfp_t gfp]\n- 调用者: sctp_sendmsg\n- 被调用者: 无\n\n10. 函数名: sctp_assoc_set_bind_addr_from_ep\n- 参数: [struct sctp_association *asoc, enum sctp_scope scope, gfp_t gfp]\n- 调用者: sctp_sendmsg\n- 被调用者: 无\n\n11. 函数名: sctp_stream_init\n- 参数: [struct sctp_stream *stream, __u16 outcnt, __u16 incnt, gfp_t gfp]\n- 调用者: sctp_sendmsg\n- 被调用者: 无\n\n12. 函数名: sctp_assoc_add_peer\n- 参数: [struct sctp_association *asoc, union sctp_addr *addr, gfp_t gfp, int state]\n- 调用者: sctp_sendmsg\n- 被调用者: 无\n\n13. 函数名: sctp_assoc_pending_pmtu\n- 参数: [struct sctp_association *asoc]\n- 调用者: sctp_sendmsg\n- 被调用者: 无\n\n14. 函数名: sctp_stream_init_ext\n- 参数: [struct sctp_stream *stream, __u16 sid]\n- 调用者: sctp_sendmsg\n- 被调用者: 无\n\n15. 函数名: sctp_prsctp_prune\n- 参数: [struct sctp_association *asoc, struct sctp_sndrcvinfo *sinfo, int msg_len]\n- 调用者: sctp_sendmsg\n- 被调用者: 无\n\n16. 函数名: sctp_wait_for_sndbuf\n- 参数: [struct sctp_association *asoc, long *timeo, size_t msg_len, struct sock **sk]\n- 调用者: sctp_sendmsg\n- 被调用者: 无\n\n17. 函数名: sctp_assoc_lookup_paddr\n- 参数: [struct sctp_association *asoc, union sctp_addr *addr]\n- 调用者: sctp_sendmsg\n- 被调用者: 无\n\n18. 函数名: sctp_datamsg_from_user\n- 参数: [struct sctp_association *asoc, struct sctp_sndrcvinfo *sinfo, struct iov_iter *from]\n- 调用者: sctp_sendmsg\n- 被调用者: 无\n\n19. 函数名: sctp_datamsg_free\n- 参数: [struct sctp_datamsg *msg]\n- 调用者: sctp_sendmsg\n- 被调用者: 无\n\n20. 函数名: sctp_wait_for_connect\n- 参数: [struct sctp_association *asoc, long *timeo]\n- 调用者: sctp_sendmsg\n- 被调用者: 无\n\n21. 函数名: sctp_association_free\n- 参数: [struct sctp_association *asoc]\n- 调用者: sctp_sendmsg\n- 被调用者: 无\n\n22. 函数名: sctp_error\n- 参数: [struct sock *sk, int msg_flags, int err]\n- 调用者: sctp_sendmsg\n- 被调用者: 无"
    },
    {
        "id": 1821,
        "cwe": "CWE-416",
        "cve": "CVE-2018-5344",
        "purpose": "Code purpose:\"\"\"该代码用于管理循环设备(loop device)的释放操作，包括自动清除模式下的设备关闭和普通模式下的队列刷新处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在lo_release函数中，由于对lo_ctl_mutex锁的管理不当，可能导致在释放锁后继续访问已释放的内存，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: lo_release\n- 参数: [disk, mode]\n- 调用者: 未明确显示（通常是内核中块设备相关操作调用）\n- 被调用者: [atomic_dec_return, mutex_lock, loop_clr_fd, blk_mq_freeze_queue, blk_mq_unfreeze_queue, mutex_unlock]\n\n2. 函数名: atomic_dec_return\n- 参数: [&lo->lo_refcnt]\n- 调用者: lo_release\n- 被调用者: []\n\n3. 函数名: mutex_lock\n- 参数: [&lo->lo_ctl_mutex]\n- 调用者: lo_release\n- 被调用者: []\n\n4. 函数名: loop_clr_fd\n- 参数: [lo]\n- 调用者: lo_release\n- 被调用者: []\n\n5. 函数名: blk_mq_freeze_queue\n- 参数: [lo->lo_queue]\n- 调用者: lo_release\n- 被调用者: []\n\n6. 函数名: blk_mq_unfreeze_queue\n- 参数: [lo->lo_queue]\n- 调用者: lo_release\n- 被调用者: []\n\n7. 函数名: mutex_unlock\n- 参数: [&lo->lo_ctl_mutex]\n- 调用者: lo_release\n- 被调用者: []"
    },
    {
        "id": 1840,
        "cwe": "CWE-416",
        "cve": "CVE-2018-5873",
        "purpose": "Code purpose:\"\"\"该代码用于获取命名空间对应的文件系统路径，处理命名空间对象的路径查找和创建，并管理相关资源的引用计数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在访问文件时存在竞态条件，导致在__ns_get_path函数中可能发生释放后使用(UAF)的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: __ns_get_path\n- 参数: [struct path *path, struct ns_common *ns]\n- 调用者: N/A\n- 被调用者: [atomic_long_read, lockref_get_not_dead, mntget, new_inode_pseudo, current_time, d_alloc_pseudo, iput, d_instantiate, atomic_long_cmpxchg, d_delete, dput, cpu_relax]\n\n2. 函数名: atomic_long_read\n- 参数: [&ns->stashed]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n3. 函数名: lockref_get_not_dead\n- 参数: [&dentry->d_lockref]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n4. 函数名: mntget\n- 参数: [mnt]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n5. 函数名: new_inode_pseudo\n- 参数: [mnt->mnt_sb]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n6. 函数名: current_time\n- 参数: [inode]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n7. 函数名: d_alloc_pseudo\n- 参数: [mnt->mnt_sb, &qname]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n8. 函数名: iput\n- 参数: [inode]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n9. 函数名: d_instantiate\n- 参数: [dentry, inode]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n10. 函数名: atomic_long_cmpxchg\n- 参数: [&ns->stashed, 0, (unsigned long)dentry]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n11. 函数名: d_delete\n- 参数: [dentry]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n12. 函数名: dput\n- 参数: [dentry]\n- 调用者: __ns_get_path\n- 被调用者: N/A\n\n13. 函数名: cpu_relax\n- 参数: []\n- 调用者: __ns_get_path\n- 被调用者: N/A"
    },
    {
        "id": 1866,
        "cwe": "CWE-416",
        "cve": "CVE-2018-9422",
        "purpose": "Code purpose:\"\"\"该代码用于获取futex（快速用户空间互斥锁）的键值，处理用户空间地址到内核键值的映射，包括地址对齐检查、访问权限验证和内存页锁定等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在获取futex键时未正确处理页面映射的锁定机制，导致可能发生use-after-free情况\"\"\"",
        "functions": "Functions:\n1. 函数名: get_futex_key\n- 参数: [u32 __user *uaddr, int fshared, union futex_key *key, int rw]\n- 调用者: (未在代码片段中显示)\n- 被调用者: [access_ok, should_fail_futex, get_futex_key_refs, get_user_pages_fast, lock_page, compound_head, PageSwapCache, unlock_page, put_page, PageAnon, basepage_index]\n\n2. 函数名: access_ok\n- 参数: [int rw, u32 __user *uaddr, size_t size]\n- 调用者: get_futex_key\n- 被调用者: (未在代码片段中显示)\n\n3. 函数名: should_fail_futex\n- 参数: [int fshared]\n- 调用者: get_futex_key\n- 被调用者: (未在代码片段中显示)\n\n4. 函数名: get_futex_key_refs\n- 参数: [union futex_key *key]\n- 调用者: get_futex_key\n- 被调用者: (未在代码片段中显示)\n\n5. 函数名: get_user_pages_fast\n- 参数: [unsigned long address, int nr_pages, int write, struct page **pages]\n- 调用者: get_futex_key\n- 被调用者: (未在代码片段中显示)\n\n6. 函数名: lock_page\n- 参数: [struct page *page]\n- 调用者: get_futex_key\n- 被调用者: (未在代码片段中显示)\n\n7. 函数名: compound_head\n- 参数: [struct page *page]\n- 调用者: get_futex_key\n- 被调用者: (未在代码片段中显示)\n\n8. 函数名: PageSwapCache\n- 参数: [struct page *page]\n- 调用者: get_futex_key\n- 被调用者: (未在代码片段中显示)\n\n9. 函数名: unlock_page\n- 参数: [struct page *page]\n- 调用者: get_futex_key\n- 被调用者: (未在代码片段中显示)\n\n10. 函数名: put_page\n- 参数: [struct page *page]\n- 调用者: get_futex_key\n- 被调用者: (未在代码片段中显示)\n\n11. 函数名: PageAnon\n- 参数: [struct page *page]\n- 调用者: get_futex_key\n- 被调用者: (未在代码片段中显示)\n\n12. 函数名: basepage_index\n- 参数: [struct page *page]\n- 调用者: get_futex_key\n- 被调用者: (未在代码片段中显示)"
    },
    {
        "id": 1867,
        "cwe": "CWE-416",
        "cve": "CVE-2018-9465",
        "purpose": "Code purpose:\"\"\"该代码用于处理Android内核中binder驱动的延迟工作队列，包括文件结构释放、刷新操作和进程资源释放等任务\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放proc后仍可能通过proc访问files指针，导致释放后使用(UAF)的内存破坏漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_deferred_func\n- 参数: [struct work_struct *work]\n- 调用者: 未显示（由工作队列机制调用）\n- 被调用者: [mutex_lock, mutex_unlock, hlist_empty, hlist_entry, hlist_del_init, binder_deferred_flush, binder_deferred_release, put_files_struct]\n\n2. 函数名: mutex_lock\n- 参数: [&binder_deferred_lock]\n- 调用者: binder_deferred_func\n- 被调用者: []\n\n3. 函数名: mutex_unlock\n- 参数: [&binder_deferred_lock]\n- 调用者: binder_deferred_func\n- 被调用者: []\n\n4. 函数名: hlist_empty\n- 参数: [&binder_deferred_list]\n- 调用者: binder_deferred_func\n- 被调用者: []\n\n5. 函数名: hlist_entry\n- 参数: [binder_deferred_list.first, struct binder_proc, deferred_work_node]\n- 调用者: binder_deferred_func\n- 被调用者: []\n\n6. 函数名: hlist_del_init\n- 参数: [&proc->deferred_work_node]\n- 调用者: binder_deferred_func\n- 被调用者: []\n\n7. 函数名: binder_deferred_flush\n- 参数: [proc]\n- 调用者: binder_deferred_func\n- 被调用者: []\n\n8. 函数名: binder_deferred_release\n- 参数: [proc]\n- 调用者: binder_deferred_func\n- 被调用者: []\n\n9. 函数名: put_files_struct\n- 参数: [files]\n- 调用者: binder_deferred_func\n- 被调用者: []"
    },
    {
        "id": 1868,
        "cwe": "CWE-416",
        "cve": "CVE-2018-9465",
        "purpose": "Code purpose:\"\"\"在binder进程间通信机制中，将文件描述符与文件对象关联安装到进程的文件描述符表中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在释放proc->files后仍可能被使用，导致内存释放后重用(UAF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: task_fd_install\n- 参数: [proc, fd, file]\n- 调用者: 未指定（由外部调用）\n- 被调用者: [__fd_install]\n\n2. 函数名: __fd_install\n- 参数: [proc->files, fd, file]\n- 调用者: task_fd_install\n- 被调用者: 未指定"
    },
    {
        "id": 1869,
        "cwe": "CWE-416",
        "cve": "CVE-2018-9465",
        "purpose": "Code purpose:\"\"\"该代码实现了Android内核中binder驱动的打开功能，用于创建并初始化一个新的binder进程上下文，并将其添加到全局进程列表中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在binder_open函数中存在对已释放内存的后续使用（use-after-free），导致可能的内存损坏问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_open\n- 参数: [struct inode *nodp, struct file *filp]\n- 调用者: 未显示（通常由文件系统操作调用）\n- 被调用者: [kzalloc, spin_lock_init, get_task_struct, INIT_LIST_HEAD, task_nice, container_of, binder_alloc_init, binder_stats_created, mutex_lock, hlist_add_head, mutex_unlock, snprintf, debugfs_create_file]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*proc), GFP_KERNEL]\n- 调用者: binder_open\n- 被调用者: []\n\n3. 函数名: spin_lock_init\n- 参数: [&proc->inner_lock], [&proc->outer_lock]\n- 调用者: binder_open\n- 被调用者: []\n\n4. 函数名: get_task_struct\n- 参数: [current->group_leader]\n- 调用者: binder_open\n- 被调用者: []\n\n5. 函数名: INIT_LIST_HEAD\n- 参数: [&proc->todo], [&proc->delivered_death], [&proc->waiting_threads]\n- 调用者: binder_open\n- 被调用者: []\n\n6. 函数名: task_nice\n- 参数: [current]\n- 调用者: binder_open\n- 被调用者: []\n\n7. 函数名: container_of\n- 参数: [filp->private_data, struct binder_device, miscdev]\n- 调用者: binder_open\n- 被调用者: []\n\n8. 函数名: binder_alloc_init\n- 参数: [&proc->alloc]\n- 调用者: binder_open\n- 被调用者: []\n\n9. 函数名: binder_stats_created\n- 参数: [BINDER_STAT_PROC]\n- 调用者: binder_open\n- 被调用者: []\n\n10. 函数名: mutex_lock\n- 参数: [&binder_procs_lock]\n- 调用者: binder_open\n- 被调用者: []\n\n11. 函数名: hlist_add_head\n- 参数: [&proc->proc_node, &binder_procs]\n- 调用者: binder_open\n- 被调用者: []\n\n12. 函数名: mutex_unlock\n- 参数: [&binder_procs_lock]\n- 调用者: binder_open\n- 被调用者: []\n\n13. 函数名: snprintf\n- 参数: [strbuf, sizeof(strbuf), \"%u\", proc->pid]\n- 调用者: binder_open\n- 被调用者: []\n\n14. 函数名: debugfs_create_file\n- 参数: [strbuf, S_IRUGO, binder_debugfs_dir_entry_proc, (void *)(unsigned long)proc->pid, &binder_proc_fops]\n- 调用者: binder_open\n- 被调用者: []"
    },
    {
        "id": 1870,
        "cwe": "CWE-416",
        "cve": "CVE-2018-9465",
        "purpose": "Code purpose:\"\"\"该代码实现了Android内核中binder驱动程序的mmap功能，用于在进程间通信时映射内存区域，并设置了相关的内存保护标志。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在binder_mmap函数中未正确处理内存映射后的资源释放，导致存在释放后重用(use-after-free)的内存破坏漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_mmap\n- 参数: [struct file *filp, struct vm_area_struct *vma]\n- 调用者: 未明确显示（通常是内核的mmap系统调用处理流程）\n- 被调用者: [binder_debug, binder_alloc_mmap_handler, get_files_struct, pr_err]\n\n2. 函数名: binder_debug\n- 参数: [BINDER_DEBUG_OPEN_CLOSE, format string, __func__, proc->pid, vma->vm_start, vma->vm_end, (vma->vm_end - vma->vm_start) / SZ_1K, vma->vm_flags, (unsigned long)pgprot_val(vma->vm_page_prot)]\n- 调用者: binder_mmap\n- 被调用者: []\n\n3. 函数名: binder_alloc_mmap_handler\n- 参数: [&proc->alloc, vma]\n- 调用者: binder_mmap\n- 被调用者: []\n\n4. 函数名: get_files_struct\n- 参数: [current]\n- 调用者: binder_mmap\n- 被调用者: []\n\n5. 函数名: pr_err\n- 参数: [format string, proc->pid, vma->vm_start, vma->vm_end, failure_string, ret]\n- 调用者: binder_mmap\n- 被调用者: []"
    },
    {
        "id": 1871,
        "cwe": "CWE-416",
        "cve": "CVE-2018-9465",
        "purpose": "Code purpose:\"\"\"该代码用于在binder进程中获取一个未使用的文件描述符并设置相应标志位\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在task_get_unused_fd_flags函数中，由于proc->files指针可能在获取文件描述符后被释放，导致后续使用时出现释放后重用(UAF)的内存破坏漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: task_get_unused_fd_flags\n- 参数: [proc, flags]\n- 调用者: 未提供\n- 被调用者: [lock_task_sighand, task_rlimit, unlock_task_sighand, __alloc_fd]\n\n2. 函数名: lock_task_sighand\n- 参数: [proc->tsk, &irqs]\n- 调用者: task_get_unused_fd_flags\n- 被调用者: 未提供\n\n3. 函数名: task_rlimit\n- 参数: [proc->tsk, RLIMIT_NOFILE]\n- 调用者: task_get_unused_fd_flags\n- 被调用者: 未提供\n\n4. 函数名: unlock_task_sighand\n- 参数: [proc->tsk, &irqs]\n- 调用者: task_get_unused_fd_flags\n- 被调用者: 未提供\n\n5. 函数名: __alloc_fd\n- 参数: [files, 0, rlim_cur, flags]\n- 调用者: task_get_unused_fd_flags\n- 被调用者: 未提供"
    },
    {
        "id": 1872,
        "cwe": "CWE-416",
        "cve": "CVE-2018-9465",
        "purpose": "Code purpose:\"\"\"关闭binder进程中的文件描述符并处理可能的错误返回值\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在task_close_fd函数中存在对已释放内存的后续使用（use-after-free），导致可能的内存损坏漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: task_close_fd\n- 参数: [struct binder_proc *proc, unsigned int fd]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [__close_fd]\n\n2. 函数名: __close_fd\n- 参数: [未明确（根据上下文推断为 struct files_struct *files, unsigned int fd）]\n- 调用者: task_close_fd\n- 被调用者: 未明确（上下文未提供）"
    },
    {
        "id": 1873,
        "cwe": "CWE-416",
        "cve": "CVE-2018-9517",
        "purpose": "Code purpose:\"\"\"该代码实现了L2TP协议中通过Netlink接口创建会话的功能，包括验证参数、配置会话属性并调用相应伪线类型的创建函数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在pppol2tp_connect中存在因释放后使用(use-after-free)导致的内存损坏问题\"\"\"",
        "functions": "Functions:\n1. 函数名: l2tp_nl_cmd_session_create\n- 参数: [struct sk_buff *skb, struct genl_info *info]\n- 调用者: 未显示（由Netlink框架调用）\n- 被调用者: [l2tp_tunnel_get, nla_get_u32, nla_get_u16, nla_get_u8, nla_len, nla_data, memcpy, genl_unlock, genl_lock, request_module, l2tp_session_get, l2tp_session_notify, l2tp_session_dec_refcount, l2tp_tunnel_dec_refcount]\n\n2. 函数名: l2tp_tunnel_get\n- 参数: [struct net *net, u32 tunnel_id]\n- 调用者: l2tp_nl_cmd_session_create\n- 被调用者: []\n\n3. 函数名: nla_get_u32\n- 参数: [struct nlattr *nla]\n- 调用者: l2tp_nl_cmd_session_create\n- 被调用者: []\n\n4. 函数名: nla_get_u16\n- 参数: [struct nlattr *nla]\n- 调用者: l2tp_nl_cmd_session_create\n- 被调用者: []\n\n5. 函数名: nla_get_u8\n- 参数: [struct nlattr *nla]\n- 调用者: l2tp_nl_cmd_session_create\n- 被调用者: []\n\n6. 函数名: nla_len\n- 参数: [struct nlattr *nla]\n- 调用者: l2tp_nl_cmd_session_create\n- 被调用者: []\n\n7. 函数名: nla_data\n- 参数: [struct nlattr *nla]\n- 调用者: l2tp_nl_cmd_session_create\n- 被调用者: []\n\n8. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: l2tp_nl_cmd_session_create\n- 被调用者: []\n\n9. 函数名: genl_unlock\n- 参数: []\n- 调用者: l2tp_nl_cmd_session_create\n- 被调用者: []\n\n10. 函数名: genl_lock\n- 参数: []\n- 调用者: l2tp_nl_cmd_session_create\n- 被调用者: []\n\n11. 函数名: request_module\n- 参数: [const char *fmt, ...]\n- 调用者: l2tp_nl_cmd_session_create\n- 被调用者: []\n\n12. 函数名: l2tp_session_get\n- 参数: [struct net *net, struct l2tp_tunnel *tunnel, u32 session_id, bool do_ref]\n- 调用者: l2tp_nl_cmd_session_create\n- 被调用者: []\n\n13. 函数名: l2tp_session_notify\n- 参数: [struct genl_family *family, struct genl_info *info, struct l2tp_session *session, enum l2tp_cmd cmd]\n- 调用者: l2tp_nl_cmd_session_create\n- 被调用者: []\n\n14. 函数名: l2tp_session_dec_refcount\n- 参数: [struct l2tp_session *session]\n- 调用者: l2tp_nl_cmd_session_create\n- 被调用者: []\n\n15. 函数名: l2tp_tunnel_dec_refcount\n- 参数: [struct l2tp_tunnel *tunnel]\n- 调用者: l2tp_nl_cmd_session_create\n- 被调用者: []"
    },
    {
        "id": 1884,
        "cwe": "CWE-416",
        "cve": "CVE-2019-10125",
        "purpose": "Code purpose:\"\"\"该代码片段实现了异步I/O操作的准备工作，包括文件描述符获取、标志位设置和I/O优先级检查等功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在aio_poll()中，当vfs_poll()返回后立即触发预期事件时，aio_poll_wake()会释放文件，导致后续出现use-after-free问题\"\"\"",
        "functions": "Functions:\n1. 函数名: aio_prep_rw\n- 参数: [struct kiocb *req, const struct iocb *iocb]\n- 调用者: 未显示\n- 被调用者: [fget, aio_complete_rw, ki_hint_validate, file_write_hint, ioprio_check_cap, get_current_ioprio, kiocb_set_rw_flags, fput]\n\n2. 函数名: fget\n- 参数: [iocb->aio_fildes]\n- 调用者: aio_prep_rw\n- 被调用者: 未显示\n\n3. 函数名: aio_complete_rw\n- 参数: 未显示\n- 调用者: aio_prep_rw\n- 被调用者: 未显示\n\n4. 函数名: ki_hint_validate\n- 参数: [file_write_hint(req->ki_filp)]\n- 调用者: aio_prep_rw\n- 被调用者: [file_write_hint]\n\n5. 函数名: file_write_hint\n- 参数: [req->ki_filp]\n- 调用者: ki_hint_validate\n- 被调用者: 未显示\n\n6. 函数名: ioprio_check_cap\n- 参数: [iocb->aio_reqprio]\n- 调用者: aio_prep_rw\n- 被调用者: 未显示\n\n7. 函数名: get_current_ioprio\n- 参数: 无\n- 调用者: aio_prep_rw\n- 被调用者: 未显示\n\n8. 函数名: kiocb_set_rw_flags\n- 参数: [req, iocb->aio_rw_flags]\n- 调用者: aio_prep_rw\n- 被调用者: 未显示\n\n9. 函数名: fput\n- 参数: [req->ki_filp]\n- 调用者: aio_prep_rw\n- 被调用者: 未显示"
    },
    {
        "id": 1885,
        "cwe": "CWE-416",
        "cve": "CVE-2019-10125",
        "purpose": "Code purpose:\"\"\"该代码片段实现了异步文件同步操作(aio_fsync)，通过检查输入参数有效性、获取文件描述符并安排异步工作队列来完成文件同步任务。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在aio_poll()中，当vfs_poll()返回后立即触发预期事件时，aio_poll_wake()可能会释放文件，导致后续出现释放后使用(UAF)问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: aio_fsync\n- 参数: [req, iocb, datasync]\n- 调用者: 未明确（可能是外部调用）\n- 被调用者: [fget, fput, INIT_WORK, schedule_work]\n\n2. 函数名: fget\n- 参数: [iocb->aio_fildes]\n- 调用者: aio_fsync\n- 被调用者: 未明确（内核函数）\n\n3. 函数名: fput\n- 参数: [req->file]\n- 调用者: aio_fsync\n- 被调用者: 未明确（内核函数）\n\n4. 函数名: INIT_WORK\n- 参数: [&req->work, aio_fsync_work]\n- 调用者: aio_fsync\n- 被调用者: 未明确（内核宏）\n\n5. 函数名: schedule_work\n- 参数: [&req->work]\n- 调用者: aio_fsync\n- 被调用者: 未明确（内核函数）\n\n6. 函数名: aio_fsync_work\n- 参数: 未明确（通过INIT_WORK初始化）\n- 调用者: INIT_WORK\n- 被调用者: 未明确"
    },
    {
        "id": 1886,
        "cwe": "CWE-416",
        "cve": "CVE-2019-10125",
        "purpose": "Code purpose:\"\"\"在异步I/O操作完成后处理文件描述符的轮询结果并释放相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在aio_poll_complete函数中，由于文件描述符可能在vfs_poll返回后立即被释放，导致后续的fput操作引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: aio_poll_complete\n- 参数: [struct aio_kiocb *iocb, __poll_t mask]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [aio_complete, mangle_poll, fput]\n\n2. 函数名: aio_complete\n- 参数: [struct aio_kiocb *iocb, long res, long res2]\n- 调用者: aio_poll_complete\n- 被调用者: 未明确（上下文未提供）\n\n3. 函数名: mangle_poll\n- 参数: [__poll_t mask]\n- 调用者: aio_poll_complete\n- 被调用者: 未明确（上下文未提供）\n\n4. 函数名: fput\n- 参数: [struct file *file]\n- 调用者: aio_poll_complete\n- 被调用者: 未明确（上下文未提供）"
    },
    {
        "id": 1887,
        "cwe": "CWE-416",
        "cve": "CVE-2019-10125",
        "purpose": "Code purpose:\"\"\"该代码实现了异步I/O轮询功能，用于检查文件描述符上的事件状态并在事件发生时触发回调。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在aio_poll()函数中，当vfs_poll()返回后立即触发预期事件时，aio_poll_wake()可能会释放文件，导致后续出现use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: aio_poll\n- 参数: [aiocb, iocb]\n- 调用者: N/A\n- 被调用者: [demangle_poll, fget, INIT_WORK, INIT_LIST_HEAD, init_waitqueue_func_entry, refcount_set, vfs_poll, spin_lock_irq, spin_lock, spin_unlock, spin_unlock_irq, fput, aio_poll_complete, iocb_put]\n\n2. 函数名: aio_poll_complete_work\n- 参数: [&req->work]\n- 调用者: INIT_WORK\n- 被调用者: N/A\n\n3. 函数名: aio_poll_queue_proc\n- 参数: N/A\n- 调用者: apt.pt._qproc\n- 被调用者: N/A\n\n4. 函数名: aio_poll_wake\n- 参数: [&req->wait]\n- 调用者: init_waitqueue_func_entry\n- 被调用者: N/A\n\n5. 函数名: aio_poll_cancel\n- 参数: [aiocb]\n- 调用者: aiocb->ki_cancel\n- 被调用者: N/A\n\n6. 函数名: demangle_poll\n- 参数: [iocb->aio_buf]\n- 调用者: aio_poll\n- 被调用者: N/A\n\n7. 函数名: fget\n- 参数: [iocb->aio_fildes]\n- 调用者: aio_poll\n- 被调用者: N/A\n\n8. 函数名: INIT_WORK\n- 参数: [&req->work, aio_poll_complete_work]\n- 调用者: aio_poll\n- 被调用者: N/A\n\n9. 函数名: INIT_LIST_HEAD\n- 参数: [&req->wait.entry]\n- 调用者: aio_poll\n- 被调用者: N/A\n\n10. 函数名: init_waitqueue_func_entry\n- 参数: [&req->wait, aio_poll_wake]\n- 调用者: aio_poll\n- 被调用者: N/A\n\n11. 函数名: refcount_set\n- 参数: [&aiocb->ki_refcnt, 2]\n- 调用者: aio_poll\n- 被调用者: N/A\n\n12. 函数名: vfs_poll\n- 参数: [req->file, &apt.pt]\n- 调用者: aio_poll\n- 被调用者: N/A\n\n13. 函数名: spin_lock_irq\n- 参数: [&ctx->ctx_lock]\n- 调用者: aio_poll\n- 被调用者: N/A\n\n14. 函数名: spin_lock\n- 参数: [&req->head->lock]\n- 调用者: aio_poll\n- 被调用者: N/A\n\n15. 函数名: spin_unlock\n- 参数: [&req->head->lock]\n- 调用者: aio_poll\n- 被调用者: N/A\n\n16. 函数名: spin_unlock_irq\n- 参数: [&ctx->ctx_lock]\n- 调用者: aio_poll\n- 被调用者: N/A\n\n17. 函数名: fput\n- 参数: [req->file]\n- 调用者: aio_poll\n- 被调用者: N/A\n\n18. 函数名: aio_poll_complete\n- 参数: [aiocb, mask]\n- 调用者: aio_poll\n- 被调用者: N/A\n\n19. 函数名: iocb_put\n- 参数: [aiocb]\n- 调用者: aio_poll\n- 被调用者: N/A"
    },
    {
        "id": 1888,
        "cwe": "CWE-416",
        "cve": "CVE-2019-10125",
        "purpose": "Code purpose:\"\"\"该代码片段用于处理异步I/O操作的完成回调，包括从列表中移除完成的I/O控制块、处理写操作的冻结保护和文件引用计数管理，并最终完成I/O操作的通知。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在aio_poll_wake()中，当vfs_poll()返回后立即触发预期事件时，会释放文件导致后续出现use-after-free问题\"\"\"",
        "functions": "Functions:\n1. 函数名: aio_complete_rw\n- 参数: [kiocb, res, res2]\n- 调用者: 未明确（由内核异步I/O子系统调用）\n- 被调用者: [list_empty_careful, aio_remove_iocb, file_inode, S_ISREG, __sb_writers_acquired, file_end_write, fput, aio_complete]\n\n2. 函数名: list_empty_careful\n- 参数: [&iocb->ki_list]\n- 调用者: aio_complete_rw\n- 被调用者: []\n\n3. 函数名: aio_remove_iocb\n- 参数: [iocb]\n- 调用者: aio_complete_rw\n- 被调用者: []\n\n4. 函数名: file_inode\n- 参数: [kiocb->ki_filp]\n- 调用者: aio_complete_rw\n- 被调用者: []\n\n5. 函数名: S_ISREG\n- 参数: [inode->i_mode]\n- 调用者: aio_complete_rw\n- 被调用者: []\n\n6. 函数名: __sb_writers_acquired\n- 参数: [inode->i_sb, SB_FREEZE_WRITE]\n- 调用者: aio_complete_rw\n- 被调用者: []\n\n7. 函数名: file_end_write\n- 参数: [kiocb->ki_filp]\n- 调用者: aio_complete_rw\n- 被调用者: []\n\n8. 函数名: fput\n- 参数: [kiocb->ki_filp]\n- 调用者: aio_complete_rw\n- 被调用者: []\n\n9. 函数名: aio_complete\n- 参数: [iocb, res, res2]\n- 调用者: aio_complete_rw\n- 被调用者: []"
    },
    {
        "id": 1889,
        "cwe": "CWE-416",
        "cve": "CVE-2019-10125",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中异步I/O(aio)的写操作功能，包括准备写请求、验证文件可写性、设置I/O向量并执行实际的写操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在aio_poll_wake()中，当vfs_poll()返回后立即触发预期事件时，会释放文件导致后续使用已释放的文件对象，造成释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: aio_write\n- 参数: [struct kiocb *req, const struct iocb *iocb, bool vectored, bool compat]\n- 调用者: N/A\n- 被调用者: [aio_prep_rw, aio_setup_rw, rw_verify_area, file_inode, __sb_start_write, __sb_writers_release, aio_rw_done, call_write_iter, kfree, fput]\n\n2. 函数名: aio_prep_rw\n- 参数: [struct kiocb *req, const struct iocb *iocb]\n- 调用者: aio_write\n- 被调用者: N/A\n\n3. 函数名: aio_setup_rw\n- 参数: [WRITE, const struct iocb *iocb, struct iovec **iovec, bool vectored, bool compat, struct iov_iter *iter]\n- 调用者: aio_write\n- 被调用者: N/A\n\n4. 函数名: rw_verify_area\n- 参数: [WRITE, struct file *file, loff_t *pos, size_t count]\n- 调用者: aio_write\n- 被调用者: N/A\n\n5. 函数名: file_inode\n- 参数: [struct file *file]\n- 调用者: aio_write\n- 被调用者: N/A\n\n6. 函数名: __sb_start_write\n- 参数: [struct super_block *sb, int level, bool wait]\n- 调用者: aio_write\n- 被调用者: N/A\n\n7. 函数名: __sb_writers_release\n- 参数: [struct super_block *sb, int level]\n- 调用者: aio_write\n- 被调用者: N/A\n\n8. 函数名: aio_rw_done\n- 参数: [struct kiocb *req, ssize_t ret]\n- 调用者: aio_write\n- 被调用者: N/A\n\n9. 函数名: call_write_iter\n- 参数: [struct file *file, struct kiocb *req, struct iov_iter *iter]\n- 调用者: aio_write\n- 被调用者: N/A\n\n10. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: aio_write\n- 被调用者: N/A\n\n11. 函数名: fput\n- 参数: [struct file *file]\n- 调用者: aio_write\n- 被调用者: N/A"
    },
    {
        "id": 1890,
        "cwe": "CWE-416",
        "cve": "CVE-2019-10125",
        "purpose": "Code purpose:\"\"\"处理异步I/O请求的提交和调度，包括读取、写入、同步和轮询等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在aio_poll()中，当vfs_poll()返回后立即触发预期事件时，aio_poll_wake()会释放文件，导致后续使用已释放的文件对象而产生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: __io_submit_one\n- 参数: [struct kioctx *ctx, const struct iocb *iocb, struct iocb __user *user_iocb, bool compat]\n- 调用者: 未显示\n- 被调用者: [get_reqs_available, aio_get_req, eventfd_ctx_fdget, put_user, aio_read, aio_write, aio_fsync, aio_poll, eventfd_ctx_put, iocb_put, put_reqs_available]\n\n2. 函数名: get_reqs_available\n- 参数: [struct kioctx *ctx]\n- 调用者: __io_submit_one\n- 被调用者: 未显示\n\n3. 函数名: aio_get_req\n- 参数: [struct kioctx *ctx]\n- 调用者: __io_submit_one\n- 被调用者: 未显示\n\n4. 函数名: eventfd_ctx_fdget\n- 参数: [(int) iocb->aio_resfd]\n- 调用者: __io_submit_one\n- 被调用者: 未显示\n\n5. 函数名: put_user\n- 参数: [KIOCB_KEY, &user_iocb->aio_key]\n- 调用者: __io_submit_one\n- 被调用者: 未显示\n\n6. 函数名: aio_read\n- 参数: [&req->rw, iocb, false, compat]\n- 调用者: __io_submit_one\n- 被调用者: 未显示\n\n7. 函数名: aio_write\n- 参数: [&req->rw, iocb, false, compat]\n- 调用者: __io_submit_one\n- 被调用者: 未显示\n\n8. 函数名: aio_fsync\n- 参数: [&req->fsync, iocb, false]\n- 调用者: __io_submit_one\n- 被调用者: 未显示\n\n9. 函数名: aio_poll\n- 参数: [req, iocb]\n- 调用者: __io_submit_one\n- 被调用者: 未显示\n\n10. 函数名: eventfd_ctx_put\n- 参数: [req->ki_eventfd]\n- 调用者: __io_submit_one\n- 被调用者: 未显示\n\n11. 函数名: iocb_put\n- 参数: [req]\n- 调用者: __io_submit_one\n- 被调用者: 未显示\n\n12. 函数名: put_reqs_available\n- 参数: [ctx, 1]\n- 调用者: __io_submit_one\n- 被调用者: 未显示"
    },
    {
        "id": 1891,
        "cwe": "CWE-416",
        "cve": "CVE-2019-10125",
        "purpose": "Code purpose:\"\"\"该代码片段实现了异步文件同步操作，通过工作队列处理文件同步请求并在完成后释放相关资源。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在aio_poll_wake()中，当vfs_poll()返回后立即触发预期事件(如关闭管道对)会导致文件被释放，从而引发use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: aio_fsync_work\n- 参数: [work]\n- 调用者: 未明确（由工作队列机制调用）\n- 被调用者: [container_of, vfs_fsync, fput, aio_complete]\n\n2. 函数名: container_of\n- 参数: [work, struct fsync_iocb, work]\n- 调用者: aio_fsync_work\n- 被调用者: []\n\n3. 函数名: vfs_fsync\n- 参数: [req->file, req->datasync]\n- 调用者: aio_fsync_work\n- 被调用者: []\n\n4. 函数名: fput\n- 参数: [req->file]\n- 调用者: aio_fsync_work\n- 被调用者: []\n\n5. 函数名: aio_complete\n- 参数: [container_of(req, struct aio_kiocb, fsync), ret, 0]\n- 调用者: aio_fsync_work\n- 被调用者: []\n\n6. 函数名: container_of\n- 参数: [req, struct aio_kiocb, fsync]\n- 调用者: aio_fsync_work\n- 被调用者: []"
    },
    {
        "id": 1892,
        "cwe": "CWE-416",
        "cve": "CVE-2019-10125",
        "purpose": "Code purpose:\"\"\"该代码片段用于在引用计数为零或递减后测试为零时释放异步I/O控制块(iocb)及其相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在aio_poll_wake()中，当vfs_poll()返回后立即触发预期事件时，会过早释放文件导致后续使用已释放的内存引发use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: iocb_put\n- 参数: [struct aio_kiocb *iocb]\n- 调用者: 未明确（上下文缺失）\n- 被调用者: [refcount_read, refcount_dec_and_test, percpu_ref_put, kmem_cache_free]\n\n2. 函数名: refcount_read\n- 参数: [&iocb->ki_refcnt]\n- 调用者: iocb_put\n- 被调用者: []\n\n3. 函数名: refcount_dec_and_test\n- 参数: [&iocb->ki_refcnt]\n- 调用者: iocb_put\n- 被调用者: []\n\n4. 函数名: percpu_ref_put\n- 参数: [&iocb->ki_ctx->reqs]\n- 调用者: iocb_put\n- 被调用者: []\n\n5. 函数名: kmem_cache_free\n- 参数: [kiocb_cachep, iocb]\n- 调用者: iocb_put\n- 被调用者: []"
    },
    {
        "id": 1893,
        "cwe": "CWE-416",
        "cve": "CVE-2019-10125",
        "purpose": "Code purpose:\"\"\"该代码实现了异步I/O读取操作，包括准备读取请求、验证文件可读性、设置读写参数并执行实际读取操作的功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在aio_poll_wake()中，当vfs_poll()返回后立即触发预期事件时，会释放文件导致后续出现use-after-free问题\"\"\"",
        "functions": "Functions:\n1. 函数名: aio_read\n- 参数: [struct kiocb *req, const struct iocb *iocb, bool vectored, bool compat]\n- 调用者: N/A\n- 被调用者: [aio_prep_rw, aio_setup_rw, rw_verify_area, aio_rw_done, call_read_iter, kfree, fput]\n\n2. 函数名: aio_prep_rw\n- 参数: [struct kiocb *req, const struct iocb *iocb]\n- 调用者: aio_read\n- 被调用者: N/A\n\n3. 函数名: aio_setup_rw\n- 参数: [READ, const struct iocb *iocb, struct iovec **iovec, bool vectored, bool compat, struct iov_iter *iter]\n- 调用者: aio_read\n- 被调用者: N/A\n\n4. 函数名: rw_verify_area\n- 参数: [READ, struct file *file, loff_t *pos, size_t count]\n- 调用者: aio_read\n- 被调用者: N/A\n\n5. 函数名: aio_rw_done\n- 参数: [struct kiocb *req, ssize_t ret]\n- 调用者: aio_read\n- 被调用者: N/A\n\n6. 函数名: call_read_iter\n- 参数: [struct file *file, struct kiocb *req, struct iov_iter *iter]\n- 调用者: aio_read\n- 被调用者: N/A\n\n7. 函数名: kfree\n- 参数: [void *ptr]\n- 调用者: aio_read\n- 被调用者: N/A\n\n8. 函数名: fput\n- 参数: [struct file *file]\n- 调用者: aio_read\n- 被调用者: N/A"
    },
    {
        "id": 1917,
        "cwe": "CWE-416",
        "cve": "CVE-2019-11487",
        "purpose": "Code purpose:\"\"\"该代码实现了FUSE设备通过管道(pipe)进行数据写入的功能，包括从管道缓冲区复制数据并通过FUSE协议传输到用户空间。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于内核在处理FUSE请求时未能正确管理pipe缓冲区的引用计数，导致在系统内存较大(约140GiB)时可能发生引用计数溢出，进而引发use-after-free问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: fuse_dev_splice_write\n- 参数: [pipe, out, ppos, len, flags]\n- 调用者: 未指定\n- 被调用者: [fuse_get_dev, pipe_lock, kvmalloc_array, pipe_unlock, fuse_copy_init, fuse_dev_do_write, pipe_buf_release, kvfree]\n\n2. 函数名: fuse_get_dev\n- 参数: [out]\n- 调用者: fuse_dev_splice_write\n- 被调用者: 未指定\n\n3. 函数名: pipe_lock\n- 参数: [pipe]\n- 调用者: fuse_dev_splice_write\n- 被调用者: 未指定\n\n4. 函数名: kvmalloc_array\n- 参数: [pipe->nrbufs, sizeof(struct pipe_buffer), GFP_KERNEL]\n- 调用者: fuse_dev_splice_write\n- 被调用者: 未指定\n\n5. 函数名: pipe_unlock\n- 参数: [pipe]\n- 调用者: fuse_dev_splice_write\n- 被调用者: 未指定\n\n6. 函数名: pipe_buf_get\n- 参数: [pipe, ibuf]\n- 调用者: fuse_dev_splice_write\n- 被调用者: 未指定\n\n7. 函数名: fuse_copy_init\n- 参数: [&cs, 0, NULL]\n- 调用者: fuse_dev_splice_write\n- 被调用者: 未指定\n\n8. 函数名: fuse_dev_do_write\n- 参数: [fud, &cs, len]\n- 调用者: fuse_dev_splice_write\n- 被调用者: 未指定\n\n9. 函数名: pipe_buf_release\n- 参数: [pipe, &bufs[idx]]\n- 调用者: fuse_dev_splice_write\n- 被调用者: 未指定\n\n10. 函数名: kvfree\n- 参数: [bufs]\n- 调用者: fuse_dev_splice_write\n- 被调用者: 未指定"
    },
    {
        "id": 1918,
        "cwe": "CWE-416",
        "cve": "CVE-2019-11487",
        "purpose": "Code purpose:\"\"\"增加管道缓冲区页面的引用计数以防止页面被释放\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于Linux内核在内存页引用计数处理时未考虑整数溢出，导致在系统内存约140GiB时可能发生引用计数溢出，进而引发释放后重用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: generic_pipe_buf_get\n- 参数: [pipe, buf]\n- 调用者: 不适用（未在代码片段中显示）\n- 被调用者: [get_page]\n\n2. 函数名: get_page\n- 参数: [buf->page]\n- 调用者: generic_pipe_buf_get\n- 被调用者: 不适用（未在代码片段中显示）"
    },
    {
        "id": 1919,
        "cwe": "CWE-416",
        "cve": "CVE-2019-11487",
        "purpose": "Code purpose:\"\"\"该代码实现了在两个管道之间传输数据的核心功能，通过管理管道缓冲区的读写操作来完成数据拼接(splice)。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在管道缓冲区操作中未正确处理引用计数，导致在大量内存环境下可能发生引用计数溢出，进而引发释放后重用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: splice_pipe_to_pipe\n- 参数: [struct pipe_inode_info *ipipe, struct pipe_inode_info *opipe, size_t len, unsigned int flags]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [ipipe_prep, opipe_prep, pipe_double_lock, send_sig, pipe_unlock, pipe_buf_get, wakeup_pipe_readers, wakeup_pipe_writers]\n\n2. 函数名: ipipe_prep\n- 参数: [struct pipe_inode_info *ipipe, unsigned int flags]\n- 调用者: splice_pipe_to_pipe\n- 被调用者: 未明确\n\n3. 函数名: opipe_prep\n- 参数: [struct pipe_inode_info *opipe, unsigned int flags]\n- 调用者: splice_pipe_to_pipe\n- 被调用者: 未明确\n\n4. 函数名: pipe_double_lock\n- 参数: [struct pipe_inode_info *ipipe, struct pipe_inode_info *opipe]\n- 调用者: splice_pipe_to_pipe\n- 被调用者: 未明确\n\n5. 函数名: send_sig\n- 参数: [SIGPIPE, current, 0]\n- 调用者: splice_pipe_to_pipe\n- 被调用者: 未明确\n\n6. 函数名: pipe_unlock\n- 参数: [struct pipe_inode_info *pipe]\n- 调用者: splice_pipe_to_pipe\n- 被调用者: 未明确\n\n7. 函数名: pipe_buf_get\n- 参数: [struct pipe_inode_info *ipipe, struct pipe_buffer *ibuf]\n- 调用者: splice_pipe_to_pipe\n- 被调用者: 未明确\n\n8. 函数名: wakeup_pipe_readers\n- 参数: [struct pipe_inode_info *opipe]\n- 调用者: splice_pipe_to_pipe\n- 被调用者: 未明确\n\n9. 函数名: wakeup_pipe_writers\n- 参数: [struct pipe_inode_info *ipipe]\n- 调用者: splice_pipe_to_pipe\n- 被调用者: 未明确"
    },
    {
        "id": 1920,
        "cwe": "CWE-416",
        "cve": "CVE-2019-11487",
        "purpose": "Code purpose:\"\"\"该代码实现了在两个管道之间传输数据的核心功能，通过锁定机制防止死锁，并处理数据传输过程中的各种边界条件。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在pipe缓冲区处理中存在引用计数溢出问题，导致在系统内存约140GiB时可能引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: link_pipe\n- 参数: [struct pipe_inode_info *ipipe, struct pipe_inode_info *opipe, size_t len, unsigned int flags]\n- 调用者: 未明确显示（通常是内核中调用管道操作的函数）\n- 被调用者: [pipe_double_lock, send_sig, pipe_buf_get, wakeup_pipe_readers, pipe_unlock]\n\n2. 函数名: pipe_double_lock\n- 参数: [struct pipe_inode_info *ipipe, struct pipe_inode_info *opipe]\n- 调用者: link_pipe\n- 被调用者: []\n\n3. 函数名: send_sig\n- 参数: [SIGPIPE, current, 0]\n- 调用者: link_pipe\n- 被调用者: []\n\n4. 函数名: pipe_buf_get\n- 参数: [struct pipe_inode_info *ipipe, struct pipe_buffer *ibuf]\n- 调用者: link_pipe\n- 被调用者: []\n\n5. 函数名: wakeup_pipe_readers\n- 参数: [struct pipe_inode_info *opipe]\n- 调用者: link_pipe\n- 被调用者: []\n\n6. 函数名: pipe_unlock\n- 参数: [struct pipe_inode_info *pipe]\n- 调用者: link_pipe\n- 被调用者: []"
    },
    {
        "id": 1921,
        "cwe": "CWE-416",
        "cve": "CVE-2019-11487",
        "purpose": "Code purpose:\"\"\"增加管道缓冲区的引用计数以防止在使用过程中被释放\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于Linux内核在处理管道缓冲区引用计数时未正确防止_refcount溢出，导致在系统内存约140GiB时可能引发引用计数溢出和后续的释放后重用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: pipe_buf_get\n- 参数: [struct pipe_inode_info *pipe, struct pipe_buffer *buf]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [buf->ops->get]"
    },
    {
        "id": 1922,
        "cwe": "CWE-416",
        "cve": "CVE-2019-11487",
        "purpose": "Code purpose:\"\"\"增加管道缓冲区引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对引用计数器进行溢出检查，当系统内存约140GiB时可能导致_refcount溢出，进而引发释放后重用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: buffer_pipe_buf_get\n- 参数: [struct pipe_inode_info *pipe, struct pipe_buffer *buf]\n- 调用者: 未明确（由内核管道系统调用）\n- 被调用者: []"
    },
    {
        "id": 1931,
        "cwe": "CWE-416",
        "cve": "CVE-2019-11810",
        "purpose": "Code purpose:\"\"\"为SCSI设备分配命令结构体数组并初始化，包括内存分配和帧池创建\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当megasas_create_frame_pool()函数调用失败时，未正确处理已分配的命令列表资源，导致后续操作中可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: megasas_alloc_cmds\n- 参数: [struct megasas_instance *instance]\n- 调用者: 未明确显示（应为外部调用）\n- 被调用者: [kcalloc, dev_printk, memset, kmalloc, kfree, list_add_tail, megasas_create_frame_pool, megasas_free_cmds]\n\n2. 函数名: kcalloc\n- 参数: [max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL]\n- 调用者: megasas_alloc_cmds\n- 被调用者: []\n\n3. 函数名: dev_printk\n- 参数: [KERN_DEBUG, &instance->pdev->dev, \"out of memory\\n\"]\n- 调用者: megasas_alloc_cmds\n- 被调用者: []\n\n4. 函数名: memset\n- 参数: [instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd]\n- 调用者: megasas_alloc_cmds\n- 被调用者: []\n\n5. 函数名: kmalloc\n- 参数: [sizeof(struct megasas_cmd), GFP_KERNEL]\n- 调用者: megasas_alloc_cmds\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [instance->cmd_list[j]]\n- 调用者: megasas_alloc_cmds\n- 被调用者: []\n\n7. 函数名: list_add_tail\n- 参数: [&cmd->list, &instance->cmd_pool]\n- 调用者: megasas_alloc_cmds\n- 被调用者: []\n\n8. 函数名: megasas_create_frame_pool\n- 参数: [instance]\n- 调用者: megasas_alloc_cmds\n- 被调用者: []\n\n9. 函数名: megasas_free_cmds\n- 参数: [instance]\n- 调用者: megasas_alloc_cmds\n- 被调用者: []"
    },
    {
        "id": 1932,
        "cwe": "CWE-416",
        "cve": "CVE-2019-11811",
        "purpose": "Code purpose:\"\"\"初始化IPMI系统接口(SMI)的状态机，包括设备分配、I/O空间设置、中断处理和设备注册等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ipmi_si模块被移除后，尝试访问/proc/ioports时会发生use-after-free错误，源于对已释放资源的后续访问\"\"\"",
        "functions": "Functions:\n1. 函数名: try_smi_init\n- 参数: [struct smi_info *new_smi]\n- 调用者: (未在代码片段中显示)\n- 被调用者: [ipmi_addr_src_to_str, si_to_str, addr_space_to_str, kasprintf, platform_device_alloc, kmalloc, new_smi->handlers->init_data, new_smi->io.io_setup, new_smi->handlers->detect, try_get_dev_id, setup_oem_data_handler, setup_xaction_handlers, check_for_broken_irqs, try_enable_event_buffer, start_clear_flags, platform_device_add, dev_set_drvdata, device_add_group, ipmi_register_smi, kfree]\n\n2. 函数名: ipmi_addr_src_to_str\n- 参数: [new_smi->io.addr_source]\n- 调用者: try_smi_init\n- 被调用者: (未在代码片段中显示)\n\n3. 函数名: si_to_str\n- 参数: [new_smi->io.si_type]\n- 调用者: try_smi_init\n- 被调用者: (未在代码片段中显示)\n\n4. 函数名: addr_space_to_str\n- 参数: [new_smi->io.addr_type]\n- 调用者: try_smi_init\n- 被调用者: (未在代码片段中显示)\n\n5. 函数名: kasprintf\n- 参数: [GFP_KERNEL, \"ipmi_si.%d\", new_smi->si_num]\n- 调用者: try_smi_init\n- 被调用者: (未在代码片段中显示)\n\n6. 函数名: platform_device_alloc\n- 参数: [\"ipmi_si\", new_smi->si_num]\n- 调用者: try_smi_init\n- 被调用者: (未在代码片段中显示)\n\n7. 函数名: kmalloc\n- 参数: [new_smi->handlers->size(), GFP_KERNEL]\n- 调用者: try_smi_init\n- 被调用者: (未在代码片段中显示)\n\n8. 函数名: new_smi->handlers->init_data\n- 参数: [new_smi->si_sm, &new_smi->io]\n- 调用者: try_smi_init\n- 被调用者: (未在代码片段中显示)\n\n9. 函数名: new_smi->io.io_setup\n- 参数: [&new_smi->io]\n- 调用者: try_smi_init\n- 被调用者: (未在代码片段中显示)\n\n10. 函数名: new_smi->handlers->detect\n- 参数: [new_smi->si_sm]\n- 调用者: try_smi_init\n- 被调用者: (未在代码片段中显示)\n\n11. 函数名: try_get_dev_id\n- 参数: [new_smi]\n- 调用者: try_smi_init\n- 被调用者: (未在代码片段中显示)\n\n12. 函数名: setup_oem_data_handler\n- 参数: [new_smi]\n- 调用者: try_smi_init\n- 被调用者: (未在代码片段中显示)\n\n13. 函数名: setup_xaction_handlers\n- 参数: [new_smi]\n- 调用者: try_smi_init\n- 被调用者: (未在代码片段中显示)\n\n14. 函数名: check_for_broken_irqs\n- 参数: [new_smi]\n- 调用者: try_smi_init\n- 被调用者: (未在代码片段中显示)\n\n15. 函数名: try_enable_event_buffer\n- 参数: [new_smi]\n- 调用者: try_smi_init\n- 被调用者: (未在代码片段中显示)\n\n16. 函数名: start_clear_flags\n- 参数: [new_smi]\n- 调用者: try_smi_init\n- 被调用者: (未在代码片段中显示)\n\n17. 函数名: platform_device_add\n- 参数: [new_smi->pdev]\n- 调用者: try_smi_init\n- 被调用者: (未在代码片段中显示)\n\n18. 函数名: dev_set_drvdata\n- 参数: [new_smi->io.dev, new_smi]\n- 调用者: try_smi_init\n- 被调用者: (未在代码片段中显示)\n\n19. 函数名: device_add_group\n- 参数: [new_smi->io.dev, &ipmi_si_dev_attr_group]\n- 调用者: try_smi_init\n- 被调用者: (未在代码片段中显示)\n\n20. 函数名: ipmi_register_smi\n- 参数: [&handlers, new_smi, new_smi->io.dev, new_smi->io.slave_addr]\n- 调用者: try_smi_init\n- 被调用者: (未在代码片段中显示)\n\n21. 函数名: kfree\n- 参数: [init_name]\n- 调用者: try_smi_init\n- 被调用者: (未在代码片段中显示)"
    },
    {
        "id": 1933,
        "cwe": "CWE-416",
        "cve": "CVE-2019-11811",
        "purpose": "Code purpose:\"\"\"该代码用于设置IPMI系统接口的内存映射和I/O操作，包括内存区域请求和寄存器大小适配。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ipmi_si模块被移除后，由于未正确清理内存资源，导致后续访问/proc/ioports时发生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ipmi_si_mem_setup\n- 参数: [struct si_sm_io *io]\n- 调用者: (未在代码片段中显示)\n- 被调用者: [mem_cleanup, intf_mem_inb, intf_mem_outb, intf_mem_inw, intf_mem_outw, intf_mem_inl, intf_mem_outl, mem_inq, mem_outq, dev_warn, request_mem_region, mem_region_cleanup, ioremap]\n\n2. 函数名: mem_cleanup\n- 参数: (未在代码片段中显示)\n- 调用者: ipmi_si_mem_setup\n- 被调用者: (未在代码片段中显示)\n\n3. 函数名: intf_mem_inb\n- 参数: (未在代码片段中显示)\n- 调用者: ipmi_si_mem_setup\n- 被调用者: (未在代码片段中显示)\n\n4. 函数名: intf_mem_outb\n- 参数: (未在代码片段中显示)\n- 调用者: ipmi_si_mem_setup\n- 被调用者: (未在代码片段中显示)\n\n5. 函数名: intf_mem_inw\n- 参数: (未在代码片段中显示)\n- 调用者: ipmi_si_mem_setup\n- 被调用者: (未在代码片段中显示)\n\n6. 函数名: intf_mem_outw\n- 参数: (未在代码片段中显示)\n- 调用者: ipmi_si_mem_setup\n- 被调用者: (未在代码片段中显示)\n\n7. 函数名: intf_mem_inl\n- 参数: (未在代码片段中显示)\n- 调用者: ipmi_si_mem_setup\n- 被调用者: (未在代码片段中显示)\n\n8. 函数名: intf_mem_outl\n- 参数: (未在代码片段中显示)\n- 调用者: ipmi_si_mem_setup\n- 被调用者: (未在代码片段中显示)\n\n9. 函数名: mem_inq\n- 参数: (未在代码片段中显示)\n- 调用者: ipmi_si_mem_setup\n- 被调用者: (未在代码片段中显示)\n\n10. 函数名: mem_outq\n- 参数: (未在代码片段中显示)\n- 调用者: ipmi_si_mem_setup\n- 被调用者: (未在代码片段中显示)\n\n11. 函数名: dev_warn\n- 参数: [io->dev, \"Invalid register size: %d\\n\", io->regsize]\n- 调用者: ipmi_si_mem_setup\n- 被调用者: (未在代码片段中显示)\n\n12. 函数名: request_mem_region\n- 参数: [addr + idx * io->regspacing, io->regsize, DEVICE_NAME]\n- 调用者: ipmi_si_mem_setup\n- 被调用者: (未在代码片段中显示)\n\n13. 函数名: mem_region_cleanup\n- 参数: [io, idx] 或 [io, io->io_size]\n- 调用者: ipmi_si_mem_setup\n- 被调用者: (未在代码片段中显示)\n\n14. 函数名: ioremap\n- 参数: [addr, mapsize]\n- 调用者: ipmi_si_mem_setup\n- 被调用者: (未在代码片段中显示)"
    },
    {
        "id": 1934,
        "cwe": "CWE-416",
        "cve": "CVE-2019-11811",
        "purpose": "Code purpose:\"\"\"该代码用于设置IPMI系统接口的I/O端口，包括分配和注册I/O区域，并根据寄存器大小选择相应的输入输出操作函数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ipmi_si模块被移除后，由于未正确处理I/O端口资源的释放，导致后续访问/proc/ioports时发生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ipmi_si_port_setup\n- 参数: [struct si_sm_io *io]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [port_cleanup, port_inb, port_outb, port_inw, port_outw, port_inl, port_outl, dev_warn, request_region, release_region]\n\n2. 函数名: port_cleanup\n- 参数: 未明确（通过io->io_cleanup调用）\n- 调用者: ipmi_si_port_setup\n- 被调用者: []\n\n3. 函数名: port_inb\n- 参数: 未明确（通过io->inputb调用）\n- 调用者: ipmi_si_port_setup\n- 被调用者: []\n\n4. 函数名: port_outb\n- 参数: 未明确（通过io->outputb调用）\n- 调用者: ipmi_si_port_setup\n- 被调用者: []\n\n5. 函数名: port_inw\n- 参数: 未明确（通过io->inputb调用）\n- 调用者: ipmi_si_port_setup\n- 被调用者: []\n\n6. 函数名: port_outw\n- 参数: 未明确（通过io->outputb调用）\n- 调用者: ipmi_si_port_setup\n- 被调用者: []\n\n7. 函数名: port_inl\n- 参数: 未明确（通过io->inputb调用）\n- 调用者: ipmi_si_port_setup\n- 被调用者: []\n\n8. 函数名: port_outl\n- 参数: 未明确（通过io->outputb调用）\n- 调用者: ipmi_si_port_setup\n- 被调用者: []\n\n9. 函数名: dev_warn\n- 参数: [io->dev, \"Invalid register size: %d\\n\", io->regsize]\n- 调用者: ipmi_si_port_setup\n- 被调用者: []\n\n10. 函数名: request_region\n- 参数: [addr + idx * io->regspacing, io->regsize, DEVICE_NAME]\n- 调用者: ipmi_si_port_setup\n- 被调用者: []\n\n11. 函数名: release_region\n- 参数: [addr + idx * io->regspacing, io->regsize]\n- 调用者: ipmi_si_port_setup\n- 被调用者: []"
    },
    {
        "id": 1935,
        "cwe": "CWE-416",
        "cve": "CVE-2019-11815",
        "purpose": "Code purpose:\"\"\"该代码用于在网络命名空间清理时停止RDS TCP监听并销毁相关连接，但存在竞态条件导致释放后使用漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在清理网络命名空间时，由于缺乏适当的同步机制导致竞争条件，使得在释放资源后仍可能被访问，造成释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: rds_tcp_kill_sock\n- 参数: [net]\n- 调用者: N/A\n- 被调用者: [net_generic, rds_tcp_listen_stop, read_pnet, list_has_conn, list_move_tail, list_del, spin_lock_irq, spin_unlock_irq, list_for_each_entry_safe, rds_conn_destroy]\n\n2. 函数名: net_generic\n- 参数: [net, rds_tcp_netid]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n3. 函数名: rds_tcp_listen_stop\n- 参数: [lsock, &rtn->rds_tcp_accept_w]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n4. 函数名: read_pnet\n- 参数: [&tc->t_cpath->cp_conn->c_net]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n5. 函数名: list_has_conn\n- 参数: [&tmp_list, tc->t_cpath->cp_conn]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n6. 函数名: list_move_tail\n- 参数: [&tc->t_tcp_node, &tmp_list]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n7. 函数名: list_del\n- 参数: [&tc->t_tcp_node]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n8. 函数名: spin_lock_irq\n- 参数: [&rds_tcp_conn_lock]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n9. 函数名: spin_unlock_irq\n- 参数: [&rds_tcp_conn_lock]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n10. 函数名: list_for_each_entry_safe\n- 参数: [tc, _tc, &rds_tcp_conn_list, t_tcp_node]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A\n\n11. 函数名: rds_conn_destroy\n- 参数: [tc->t_cpath->cp_conn]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: N/A"
    },
    {
        "id": 1954,
        "cwe": "CWE-416",
        "cve": "CVE-2019-12819",
        "purpose": "Code purpose:\"\"\"该代码用于注册和管理MDIO总线设备，包括初始化总线、处理PHY设备扫描以及错误恢复等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在__mdiobus_register()函数中，当device_register()失败时调用了put_device()，导致后续可能发生use-after-free问题\"\"\"",
        "functions": "Functions:\n1. 函数名: __mdiobus_register\n- 参数: [struct mii_bus *bus, struct module *owner]\n- 调用者: N/A (顶层函数)\n- 被调用者: [dev_set_name, device_register, pr_err, put_device, mutex_init, devm_gpiod_get_optional, dev_err, device_del, gpiod_set_value_cansleep, udelay, mdiobus_scan, mdiobus_setup_mdiodev_from_board_info, mdiobus_create_device, pr_info]\n\n2. 函数名: dev_set_name\n- 参数: [&bus->dev, \"%s\", bus->id]\n- 调用者: __mdiobus_register\n- 被调用者: N/A\n\n3. 函数名: device_register\n- 参数: [&bus->dev]\n- 调用者: __mdiobus_register\n- 被调用者: N/A\n\n4. 函数名: pr_err\n- 参数: [\"mii_bus %s failed to register\\n\", bus->id]\n- 调用者: __mdiobus_register\n- 被调用者: N/A\n\n5. 函数名: put_device\n- 参数: [&bus->dev]\n- 调用者: __mdiobus_register\n- 被调用者: N/A\n\n6. 函数名: mutex_init\n- 参数: [&bus->mdio_lock]\n- 调用者: __mdiobus_register\n- 被调用者: N/A\n\n7. 函数名: devm_gpiod_get_optional\n- 参数: [&bus->dev, \"reset\", GPIOD_OUT_LOW]\n- 调用者: __mdiobus_register\n- 被调用者: N/A\n\n8. 函数名: dev_err\n- 参数: [&bus->dev, \"mii_bus %s couldn't get reset GPIO\\n\", bus->id]\n- 调用者: __mdiobus_register\n- 被调用者: N/A\n\n9. 函数名: device_del\n- 参数: [&bus->dev]\n- 调用者: __mdiobus_register\n- 被调用者: N/A\n\n10. 函数名: gpiod_set_value_cansleep\n- 参数: [gpiod, 1], [gpiod, 0], [bus->reset_gpiod, 1]\n- 调用者: __mdiobus_register\n- 被调用者: N/A\n\n11. 函数名: udelay\n- 参数: [bus->reset_delay_us]\n- 调用者: __mdiobus_register\n- 被调用者: N/A\n\n12. 函数名: mdiobus_scan\n- 参数: [bus, i]\n- 调用者: __mdiobus_register\n- 被调用者: N/A\n\n13. 函数名: mdiobus_setup_mdiodev_from_board_info\n- 参数: [bus, mdiobus_create_device]\n- 调用者: __mdiobus_register\n- 被调用者: N/A\n\n14. 函数名: mdiobus_create_device\n- 参数: N/A (作为函数指针传递)\n- 调用者: mdiobus_setup_mdiodev_from_board_info\n- 被调用者: N/A\n\n15. 函数名: pr_info\n- 参数: [\"%s: probed\\n\", bus->name]\n- 调用者: __mdiobus_register\n- 被调用者: N/A"
    },
    {
        "id": 1957,
        "cwe": "CWE-416",
        "cve": "CVE-2019-13233",
        "purpose": "Code purpose:\"\"\"获取指定段寄存器的段限制值，考虑段描述符的粒度和模式（用户64位模式或虚拟8086模式）\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于modify_ldt()和#BR异常处理之间存在竞争条件，导致对LDT条目的访问出现释放后使用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: get_seg_limit\n- 参数: [struct pt_regs *regs, int seg_reg_idx]\n- 调用者: 未明确（由上下文推断可能是内核中处理段限制的相关代码）\n- 被调用者: [get_segment_selector, user_64bit_mode, v8086_mode, get_desc, get_desc_limit]\n\n2. 函数名: get_segment_selector\n- 参数: [struct pt_regs *regs, int seg_reg_idx]\n- 调用者: get_seg_limit\n- 被调用者: []\n\n3. 函数名: user_64bit_mode\n- 参数: [struct pt_regs *regs]\n- 调用者: get_seg_limit\n- 被调用者: []\n\n4. 函数名: v8086_mode\n- 参数: [struct pt_regs *regs]\n- 调用者: get_seg_limit\n- 被调用者: []\n\n5. 函数名: get_desc\n- 参数: [short sel]\n- 调用者: get_seg_limit\n- 被调用者: []\n\n6. 函数名: get_desc_limit\n- 参数: [struct desc_struct *desc]\n- 调用者: get_seg_limit\n- 被调用者: []"
    },
    {
        "id": 1958,
        "cwe": "CWE-416",
        "cve": "CVE-2019-13233",
        "purpose": "Code purpose:\"\"\"获取当前代码段参数（地址大小和操作数大小）并验证其有效性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于modify_ldt()和#BR异常处理之间存在竞争条件，导致对LDT条目的访问出现释放后使用(UAF)问题\"\"\"",
        "functions": "Functions:\n1. 函数名: insn_get_code_seg_params\n- 参数: [struct pt_regs *regs]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [v8086_mode, get_segment_selector, get_desc]\n\n2. 函数名: v8086_mode\n- 参数: [struct pt_regs *regs]\n- 调用者: insn_get_code_seg_params\n- 被调用者: []\n\n3. 函数名: get_segment_selector\n- 参数: [struct pt_regs *regs, INAT_SEG_REG_CS]\n- 调用者: insn_get_code_seg_params\n- 被调用者: []\n\n4. 函数名: get_desc\n- 参数: [short sel]\n- 调用者: insn_get_code_seg_params\n- 被调用者: []"
    },
    {
        "id": 1959,
        "cwe": "CWE-416",
        "cve": "CVE-2019-13233",
        "purpose": "Code purpose:\"\"\"获取指定段寄存器的基地址，处理不同模式下的段选择子并返回对应的基地址\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于modify_ldt()和#BR异常处理之间存在竞争条件，导致对LDT条目的访问出现释放后使用(UAF)问题\"\"\"",
        "functions": "Functions:\n1. 函数名: insn_get_seg_base\n- 参数: [struct pt_regs *regs, int seg_reg_idx]\n- 调用者: 不适用（顶级函数）\n- 被调用者: [get_segment_selector, v8086_mode, user_64bit_mode, rdmsrl, get_desc, get_desc_base]\n\n2. 函数名: get_segment_selector\n- 参数: [struct pt_regs *regs, int seg_reg_idx]\n- 调用者: insn_get_seg_base\n- 被调用者: []\n\n3. 函数名: v8086_mode\n- 参数: [struct pt_regs *regs]\n- 调用者: insn_get_seg_base\n- 被调用者: []\n\n4. 函数名: user_64bit_mode\n- 参数: [struct pt_regs *regs]\n- 调用者: insn_get_seg_base\n- 被调用者: []\n\n5. 函数名: rdmsrl\n- 参数: [MSR_FS_BASE/MSR_KERNEL_GS_BASE, unsigned long base]\n- 调用者: insn_get_seg_base\n- 被调用者: []\n\n6. 函数名: get_desc\n- 参数: [short sel]\n- 调用者: insn_get_seg_base\n- 被调用者: []\n\n7. 函数名: get_desc_base\n- 参数: [struct desc_struct *desc]\n- 调用者: insn_get_seg_base\n- 被调用者: []"
    },
    {
        "id": 1993,
        "cwe": "CWE-416",
        "cve": "CVE-2019-15211",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中Thanko's Raremono USB无线电设备的探测和初始化功能，包括设备识别、内存分配、V4L2设备注册等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于radio-raremono.c驱动未正确分配内存，导致在v4l2-dev.c驱动中存在恶意USB设备触发的释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: usb_raremono_probe\n- 参数: [struct usb_interface *intf, const struct usb_device_id *id]\n- 调用者: 内核USB子系统\n- 被调用者: [devm_kzalloc, devm_kmalloc, interface_to_usbdev, msleep, usb_control_msg, get_unaligned_be16, dev_info, v4l2_device_register, dev_err, mutex_init, strscpy, usb_set_intfdata, video_set_drvdata, raremono_cmd_main, video_register_device, video_device_node_name, v4l2_device_unregister]\n\n2. 函数名: devm_kzalloc\n- 参数: [&intf->dev, sizeof(struct raremono_device), GFP_KERNEL]\n- 调用者: usb_raremono_probe\n- 被调用者: []\n\n3. 函数名: devm_kmalloc\n- 参数: [&intf->dev, BUFFER_LENGTH, GFP_KERNEL]\n- 调用者: usb_raremono_probe\n- 被调用者: []\n\n4. 函数名: interface_to_usbdev\n- 参数: [intf]\n- 调用者: usb_raremono_probe\n- 被调用者: []\n\n5. 函数名: msleep\n- 参数: [20]\n- 调用者: usb_raremono_probe\n- 被调用者: []\n\n6. 函数名: usb_control_msg\n- 参数: [radio->usbdev, usb_rcvctrlpipe(radio->usbdev, 0), HID_REQ_GET_REPORT, USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN, 1, 2, radio->buffer, 3, 500]\n- 调用者: usb_raremono_probe\n- 被调用者: []\n\n7. 函数名: get_unaligned_be16\n- 参数: [&radio->buffer[1]]\n- 调用者: usb_raremono_probe\n- 被调用者: []\n\n8. 函数名: dev_info\n- 参数: [&intf->dev, \"this is not Thanko's Raremono.\\n\"] 和 [&intf->dev, \"Thanko's Raremono connected: (%04X:%04X)\\n\", id->idVendor, id->idProduct] 和 [&intf->dev, \"V4L2 device registered as %s\\n\", video_device_node_name(&radio->vdev)]\n- 调用者: usb_raremono_probe\n- 被调用者: []\n\n9. 函数名: v4l2_device_register\n- 参数: [&intf->dev, &radio->v4l2_dev]\n- 调用者: usb_raremono_probe\n- 被调用者: []\n\n10. 函数名: dev_err\n- 参数: [&intf->dev, \"couldn't register v4l2_device\\n\"]\n- 调用者: usb_raremono_probe\n- 被调用者: []\n\n11. 函数名: mutex_init\n- 参数: [&radio->lock]\n- 调用者: usb_raremono_probe\n- 被调用者: []\n\n12. 函数名: strscpy\n- 参数: [radio->vdev.name, radio->v4l2_dev.name, sizeof(radio->vdev.name)]\n- 调用者: usb_raremono_probe\n- 被调用者: []\n\n13. 函数名: usb_set_intfdata\n- 参数: [intf, &radio->v4l2_dev]\n- 调用者: usb_raremono_probe\n- 被调用者: []\n\n14. 函数名: video_set_drvdata\n- 参数: [&radio->vdev, radio]\n- 调用者: usb_raremono_probe\n- 被调用者: []\n\n15. 函数名: raremono_cmd_main\n- 参数: [radio, BAND_FM, 95160]\n- 调用者: usb_raremono_probe\n- 被调用者: []\n\n16. 函数名: video_register_device\n- 参数: [&radio->vdev, VFL_TYPE_RADIO, -1]\n- 调用者: usb_raremono_probe\n- 被调用者: []\n\n17. 函数名: video_device_node_name\n- 参数: [&radio->vdev]\n- 调用者: usb_raremono_probe\n- 被调用者: []\n\n18. 函数名: v4l2_device_unregister\n- 参数: [&radio->v4l2_dev]\n- 调用者: usb_raremono_probe\n- 被调用者: []"
    },
    {
        "id": 1995,
        "cwe": "CWE-416",
        "cve": "CVE-2019-15213",
        "purpose": "Code purpose:\"\"\"该代码用于在USB接口断开时清理DVB-USB设备相关资源并打印注销信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放dvb_usb_device结构体后仍然引用了其desc指针指向的name字符串，导致释放后使用(use-after-free)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: dvb_usb_device_exit\n- 参数: [struct usb_interface *intf]\n- 调用者: 未明确（由系统调用）\n- 被调用者: [usb_get_intfdata, usb_set_intfdata, dvb_usb_exit, info]\n\n2. 函数名: usb_get_intfdata\n- 参数: [struct usb_interface *intf]\n- 调用者: dvb_usb_device_exit\n- 被调用者: []\n\n3. 函数名: usb_set_intfdata\n- 参数: [struct usb_interface *intf, NULL]\n- 调用者: dvb_usb_device_exit\n- 被调用者: []\n\n4. 函数名: dvb_usb_exit\n- 参数: [struct dvb_usb_device *d]\n- 调用者: dvb_usb_device_exit\n- 被调用者: []\n\n5. 函数名: info\n- 参数: [const char *format, ...]\n- 调用者: dvb_usb_device_exit\n- 被调用者: []"
    },
    {
        "id": 1996,
        "cwe": "CWE-416",
        "cve": "CVE-2019-15214",
        "purpose": "Code purpose:\"\"\"该代码实现了声卡设备的断开连接功能，包括禁用用户空间操作、替换文件操作结构体以及通知所有连接的设备断开连接等步骤。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在声卡断开连接过程中过早释放了某些数据结构，导致后续操作中可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_card_disconnect\n- 参数: [struct snd_card *card]\n- 调用者: N/A\n- 被调用者: [spin_lock, spin_unlock, mutex_lock, mutex_unlock, list_for_each_entry, clear_bit, fops_get, snd_mixer_oss_notify_callback, snd_device_disconnect_all, snd_info_card_disconnect, device_del, wake_up]\n\n2. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: snd_card_disconnect\n- 被调用者: N/A\n\n3. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: snd_card_disconnect\n- 被调用者: N/A\n\n4. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: snd_card_disconnect\n- 被调用者: N/A\n\n5. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: snd_card_disconnect\n- 被调用者: N/A\n\n6. 函数名: list_for_each_entry\n- 参数: [struct snd_monitor_file *mfile, &card->files_list, list]\n- 调用者: snd_card_disconnect\n- 被调用者: N/A\n\n7. 函数名: clear_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: snd_card_disconnect\n- 被调用者: N/A\n\n8. 函数名: fops_get\n- 参数: [struct file_operations *fops]\n- 调用者: snd_card_disconnect\n- 被调用者: N/A\n\n9. 函数名: snd_mixer_oss_notify_callback\n- 参数: [struct snd_card *card, SND_MIXER_OSS_NOTIFY_DISCONNECT]\n- 调用者: snd_card_disconnect\n- 被调用者: N/A\n\n10. 函数名: snd_device_disconnect_all\n- 参数: [struct snd_card *card]\n- 调用者: snd_card_disconnect\n- 被调用者: N/A\n\n11. 函数名: snd_info_card_disconnect\n- 参数: [struct snd_card *card]\n- 调用者: snd_card_disconnect\n- 被调用者: N/A\n\n12. 函数名: device_del\n- 参数: [struct device *dev]\n- 调用者: snd_card_disconnect\n- 被调用者: N/A\n\n13. 函数名: wake_up\n- 参数: [wait_queue_head_t *q]\n- 调用者: snd_card_disconnect\n- 被调用者: N/A"
    },
    {
        "id": 1997,
        "cwe": "CWE-416",
        "cve": "CVE-2019-15215",
        "purpose": "Code purpose:\"\"\"处理CPiA2 USB摄像头设备断开连接时的资源清理和状态更新\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在USB设备断开连接时，由于未正确管理互斥锁和资源释放顺序，导致在释放相机数据结构后仍可能被访问，造成释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: cpia2_usb_disconnect\n- 参数: [struct usb_interface *intf]\n- 调用者: 系统/USB子系统\n- 被调用者: [usb_get_intfdata, usb_set_intfdata, cpia2_usb_stream_stop, mutex_lock, cpia2_unregister_camera, v4l2_device_disconnect, mutex_unlock, v4l2_device_put, wake_up_interruptible]\n\n2. 函数名: usb_get_intfdata\n- 参数: [struct usb_interface *intf]\n- 调用者: cpia2_usb_disconnect\n- 被调用者: []\n\n3. 函数名: usb_set_intfdata\n- 参数: [struct usb_interface *intf, NULL]\n- 调用者: cpia2_usb_disconnect\n- 被调用者: []\n\n4. 函数名: cpia2_usb_stream_stop\n- 参数: [struct camera_data *cam]\n- 调用者: cpia2_usb_disconnect\n- 被调用者: []\n\n5. 函数名: mutex_lock\n- 参数: [&cam->v4l2_lock]\n- 调用者: cpia2_usb_disconnect\n- 被调用者: []\n\n6. 函数名: cpia2_unregister_camera\n- 参数: [struct camera_data *cam]\n- 调用者: cpia2_usb_disconnect\n- 被调用者: []\n\n7. 函数名: v4l2_device_disconnect\n- 参数: [&cam->v4l2_dev]\n- 调用者: cpia2_usb_disconnect\n- 被调用者: []\n\n8. 函数名: mutex_unlock\n- 参数: [&cam->v4l2_lock]\n- 调用者: cpia2_usb_disconnect\n- 被调用者: []\n\n9. 函数名: v4l2_device_put\n- 参数: [&cam->v4l2_dev]\n- 调用者: cpia2_usb_disconnect\n- 被调用者: []\n\n10. 函数名: wake_up_interruptible\n- 参数: [&cam->wq_stream]\n- 调用者: cpia2_usb_disconnect\n- 被调用者: []"
    },
    {
        "id": 2002,
        "cwe": "CWE-416",
        "cve": "CVE-2019-15220",
        "purpose": "Code purpose:\"\"\"该代码用于处理USB无线网卡固件加载完成后的回调操作，包括固件验证、设备初始化和错误处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在设备初始化失败时，代码在释放priv资源后仍可能通过priv指针访问已释放的内存，导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: p54u_load_firmware_cb\n- 参数: [const struct firmware *firmware, void *context]\n- 调用者: 未明确显示（通常由firmware加载子系统调用）\n- 被调用者: [complete, p54u_start_ops, dev_err, device_lock, device_release_driver, device_unlock, usb_put_dev]\n\n2. 函数名: complete\n- 参数: [&priv->fw_wait_load]\n- 调用者: p54u_load_firmware_cb\n- 被调用者: []\n\n3. 函数名: p54u_start_ops\n- 参数: [priv]\n- 调用者: p54u_load_firmware_cb\n- 被调用者: []\n\n4. 函数名: dev_err\n- 参数: [&udev->dev, \"Firmware not found.\\n\"] 和 [&udev->dev, \"failed to initialize device (%d)\\n\", err]\n- 调用者: p54u_load_firmware_cb\n- 被调用者: []\n\n5. 函数名: device_lock\n- 参数: [parent]\n- 调用者: p54u_load_firmware_cb\n- 被调用者: []\n\n6. 函数名: device_release_driver\n- 参数: [&udev->dev]\n- 调用者: p54u_load_firmware_cb\n- 被调用者: []\n\n7. 函数名: device_unlock\n- 参数: [parent]\n- 调用者: p54u_load_firmware_cb\n- 被调用者: []\n\n8. 函数名: usb_put_dev\n- 参数: [udev]\n- 调用者: p54u_load_firmware_cb\n- 被调用者: []"
    },
    {
        "id": 2003,
        "cwe": "CWE-416",
        "cve": "CVE-2019-15220",
        "purpose": "Code purpose:\"\"\"该代码实现了对特定USB无线网卡设备的探测和初始化，包括端点识别、固件加载和硬件类型判断等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在p54u_probe函数中，当加载固件失败时，未正确清理已设置的usb_intfdata，导致后续可能访问已释放的内存区域，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: p54u_probe\n- 参数: [struct usb_interface *intf, const struct usb_device_id *id]\n- 调用者: USB子系统\n- 被调用者: [p54_init_common, interface_to_usbdev, dev_err, SET_IEEE80211_DEV, usb_set_intfdata, skb_queue_head_init, init_usb_anchor, usb_get_dev, p54u_device_reset, p54u_load_firmware, usb_put_dev, p54_free_common]\n\n2. 函数名: p54_init_common\n- 参数: [size_t priv_data_len]\n- 调用者: p54u_probe\n- 被调用者: []\n\n3. 函数名: interface_to_usbdev\n- 参数: [struct usb_interface *intf]\n- 调用者: p54u_probe\n- 被调用者: []\n\n4. 函数名: dev_err\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: p54u_probe\n- 被调用者: []\n\n5. 函数名: SET_IEEE80211_DEV\n- 参数: [struct ieee80211_hw *hw, struct device *dev]\n- 调用者: p54u_probe\n- 被调用者: []\n\n6. 函数名: usb_set_intfdata\n- 参数: [struct usb_interface *intf, void *data]\n- 调用者: p54u_probe\n- 被调用者: []\n\n7. 函数名: skb_queue_head_init\n- 参数: [struct sk_buff_head *list]\n- 调用者: p54u_probe\n- 被调用者: []\n\n8. 函数名: init_usb_anchor\n- 参数: [struct usb_anchor *anchor]\n- 调用者: p54u_probe\n- 被调用者: []\n\n9. 函数名: usb_get_dev\n- 参数: [struct usb_device *dev]\n- 调用者: p54u_probe\n- 被调用者: []\n\n10. 函数名: p54u_device_reset\n- 参数: [struct ieee80211_hw *dev]\n- 调用者: p54u_probe\n- 被调用者: []\n\n11. 函数名: p54u_load_firmware\n- 参数: [struct ieee80211_hw *dev, struct usb_interface *intf]\n- 调用者: p54u_probe\n- 被调用者: []\n\n12. 函数名: usb_put_dev\n- 参数: [struct usb_device *dev]\n- 调用者: p54u_probe\n- 被调用者: []\n\n13. 函数名: p54_free_common\n- 参数: [struct ieee80211_hw *hw]\n- 调用者: p54u_probe\n- 被调用者: []"
    },
    {
        "id": 2004,
        "cwe": "CWE-416",
        "cve": "CVE-2019-15220",
        "purpose": "Code purpose:\"\"\"该代码用于从USB设备异步加载无线网卡固件，并在加载完成后通过回调函数处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在p54u_load_firmware函数中，当request_firmware_nowait调用失败时，未等待完成回调函数p54u_load_firmware_cb就释放了udev设备，导致潜在的use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: p54u_load_firmware\n- 参数: [struct ieee80211_hw *dev, struct usb_interface *intf]\n- 调用者: (未显示在代码片段中)\n- 被调用者: [interface_to_usbdev, init_completion, p54_find_type, dev_info, usb_get_dev, request_firmware_nowait, dev_err, usb_put_dev]\n\n2. 函数名: interface_to_usbdev\n- 参数: [struct usb_interface *intf]\n- 调用者: p54u_load_firmware\n- 被调用者: (未显示在代码片段中)\n\n3. 函数名: init_completion\n- 参数: [&priv->fw_wait_load]\n- 调用者: p54u_load_firmware\n- 被调用者: (未显示在代码片段中)\n\n4. 函数名: p54_find_type\n- 参数: [struct p54u_priv *priv]\n- 调用者: p54u_load_firmware\n- 被调用者: (未显示在代码片段中)\n\n5. 函数名: dev_info\n- 参数: [&priv->udev->dev, \"Loading firmware file %s\\n\", p54u_fwlist[i].fw]\n- 调用者: p54u_load_firmware\n- 被调用者: (未显示在代码片段中)\n\n6. 函数名: usb_get_dev\n- 参数: [udev]\n- 调用者: p54u_load_firmware\n- 被调用者: (未显示在代码片段中)\n\n7. 函数名: request_firmware_nowait\n- 参数: [THIS_MODULE, 1, p54u_fwlist[i].fw, device, GFP_KERNEL, priv, p54u_load_firmware_cb]\n- 调用者: p54u_load_firmware\n- 被调用者: (未显示在代码片段中)\n\n8. 函数名: dev_err\n- 参数: [&priv->udev->dev, \"(p54usb) cannot load firmware %s (%d)!\\n\", p54u_fwlist[i].fw, err]\n- 调用者: p54u_load_firmware\n- 被调用者: (未显示在代码片段中)\n\n9. 函数名: usb_put_dev\n- 参数: [udev]\n- 调用者: p54u_load_firmware\n- 被调用者: (未显示在代码片段中)"
    },
    {
        "id": 2005,
        "cwe": "CWE-416",
        "cve": "CVE-2019-15220",
        "purpose": "Code purpose:\"\"\"处理USB无线网卡设备的断开连接操作，包括等待固件加载完成、注销设备、释放资源等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在p54u_disconnect函数中，存在对已释放的priv指针的后续访问，导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: p54u_disconnect\n- 参数: [struct usb_interface *intf]\n- 调用者: 无（由USB子系统调用）\n- 被调用者: [usb_get_intfdata, wait_for_completion, p54_unregister_common, interface_to_usbdev, usb_put_dev, release_firmware, p54_free_common]\n\n2. 函数名: usb_get_intfdata\n- 参数: [struct usb_interface *intf]\n- 调用者: p54u_disconnect\n- 被调用者: 无\n\n3. 函数名: wait_for_completion\n- 参数: [&priv->fw_wait_load]\n- 调用者: p54u_disconnect\n- 被调用者: 无\n\n4. 函数名: p54_unregister_common\n- 参数: [struct ieee80211_hw *dev]\n- 调用者: p54u_disconnect\n- 被调用者: 无\n\n5. 函数名: interface_to_usbdev\n- 参数: [struct usb_interface *intf]\n- 调用者: p54u_disconnect\n- 被调用者: 无\n\n6. 函数名: usb_put_dev\n- 参数: [interface_to_usbdev(intf)]\n- 调用者: p54u_disconnect\n- 被调用者: 无\n\n7. 函数名: release_firmware\n- 参数: [priv->fw]\n- 调用者: p54u_disconnect\n- 被调用者: 无\n\n8. 函数名: p54_free_common\n- 参数: [struct ieee80211_hw *dev]\n- 调用者: p54u_disconnect\n- 被调用者: 无"
    },
    {
        "id": 2013,
        "cwe": "CWE-416",
        "cve": "CVE-2019-15239",
        "purpose": "Code purpose:\"\"\"清除TCP套接字写入队列中的所有缓冲区并释放相关内存\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在断开连接和重新连接之间向写入队列添加数据时，由于不当的回溯引入了新的释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: tcp_write_queue_purge\n- 参数: [struct sock *sk]\n- 调用者: 不适用（未在代码片段中显示）\n- 被调用者: [tcp_chrono_stop, __skb_dequeue, sk_wmem_free_skb, sk_mem_reclaim, tcp_clear_all_retrans_hints, tcp_sk]\n\n2. 函数名: tcp_chrono_stop\n- 参数: [struct sock *sk, TCP_CHRONO_BUSY]\n- 调用者: tcp_write_queue_purge\n- 被调用者: []\n\n3. 函数名: __skb_dequeue\n- 参数: [&sk->sk_write_queue]\n- 调用者: tcp_write_queue_purge\n- 被调用者: []\n\n4. 函数名: sk_wmem_free_skb\n- 参数: [struct sock *sk, struct sk_buff *skb]\n- 调用者: tcp_write_queue_purge\n- 被调用者: []\n\n5. 函数名: sk_mem_reclaim\n- 参数: [struct sock *sk]\n- 调用者: tcp_write_queue_purge\n- 被调用者: []\n\n6. 函数名: tcp_clear_all_retrans_hints\n- 参数: [tcp_sk(sk)]\n- 调用者: tcp_write_queue_purge\n- 被调用者: []\n\n7. 函数名: tcp_sk\n- 参数: [struct sock *sk]\n- 调用者: tcp_write_queue_purge\n- 被调用者: []"
    },
    {
        "id": 2015,
        "cwe": "CWE-416",
        "cve": "CVE-2019-15292",
        "purpose": "Code purpose:\"\"\"在Linux内核中移除AppleTalk网络协议相关的proc文件系统子树\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在atalk_proc_exit函数中，由于未正确处理proc文件系统的资源释放顺序，导致在移除proc子树时可能访问已释放的内存，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: atalk_proc_exit\n- 参数: []\n- 调用者: __exit\n- 被调用者: [remove_proc_subtree]\n\n2. 函数名: remove_proc_subtree\n- 参数: [\"atalk\", init_net.proc_net]\n- 调用者: atalk_proc_exit\n- 被调用者: []"
    },
    {
        "id": 2016,
        "cwe": "CWE-416",
        "cve": "CVE-2019-15292",
        "purpose": "Code purpose:\"\"\"注册AppleTalk网络协议的系统控制(sysctl)接口\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核中，atalk_proc_exit函数存在释放后使用(UAF)问题，源于未正确处理net/appletalk相关资源的释放顺序。\"\"\"",
        "functions": "Functions:\n1. 函数名: atalk_register_sysctl\n- 参数: [void]\n- 调用者: N/A (顶层函数)\n- 被调用者: [register_net_sysctl]\n\n2. 函数名: register_net_sysctl\n- 参数: [&init_net, \"net/appletalk\", atalk_table]\n- 调用者: atalk_register_sysctl\n- 被调用者: []"
    },
    {
        "id": 2024,
        "cwe": "CWE-416",
        "cve": "CVE-2019-15917",
        "purpose": "Code purpose:\"\"\"该代码用于设置HCI UART协议并注册相关设备，当注册失败时会清除协议就绪标志位\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当hci_uart_register_dev()调用失败时，未正确清理已设置的hu->proto指针，导致后续可能使用已被释放的内存\"\"\"",
        "functions": "Functions:\n1. 函数名: hci_uart_set_proto\n- 参数: [struct hci_uart *hu, int id]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [hci_uart_get_proto, hci_uart_register_dev]\n\n2. 函数名: hci_uart_get_proto\n- 参数: [int id]\n- 调用者: hci_uart_set_proto\n- 被调用者: []\n\n3. 函数名: hci_uart_register_dev\n- 参数: [struct hci_uart *hu]\n- 调用者: hci_uart_set_proto\n- 被调用者: []\n\n4. 函数名: set_bit\n- 参数: [HCI_UART_PROTO_READY, &hu->flags]\n- 调用者: hci_uart_set_proto\n- 被调用者: []\n\n5. 函数名: clear_bit\n- 参数: [HCI_UART_PROTO_READY, &hu->flags]\n- 调用者: hci_uart_set_proto\n- 被调用者: []"
    },
    {
        "id": 2026,
        "cwe": "CWE-416",
        "cve": "CVE-2019-15919",
        "purpose": "Code purpose:\"\"\"该代码实现了SMB2协议中的写操作功能，用于向服务器发送写入请求并处理响应。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在SMB2_write函数中，对请求缓冲区req的释放操作(cifs_small_buf_release)发生在接收响应处理之前，可能导致在响应处理时访问已释放的内存区域，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: SMB2_write\n- 参数: [xid, io_parms, nbytes, iov, n_vec]\n- 调用者: 未显示\n- 被调用者: [smb2_plain_req_init, smb3_encryption_required, cpu_to_le32, cpu_to_le64, cpu_to_le16, trace_smb3_write_enter, memset, cifs_send_recv, cifs_small_buf_release, trace_smb3_write_err, cifs_stats_fail_inc, cifs_dbg, le32_to_cpu, trace_smb3_write_done, free_rsp_buf]\n\n2. 函数名: smb2_plain_req_init\n- 参数: [SMB2_WRITE, io_parms->tcon, (void **) &req, &total_len]\n- 调用者: SMB2_write\n- 被调用者: 未显示\n\n3. 函数名: smb3_encryption_required\n- 参数: [io_parms->tcon]\n- 调用者: SMB2_write\n- 被调用者: 未显示\n\n4. 函数名: cpu_to_le32\n- 参数: [io_parms->pid]\n- 调用者: SMB2_write\n- 被调用者: 未显示\n\n5. 函数名: cpu_to_le64\n- 参数: [io_parms->offset]\n- 调用者: SMB2_write\n- 被调用者: 未显示\n\n6. 函数名: cpu_to_le16\n- 参数: [offsetof(struct smb2_write_req, Buffer)]\n- 调用者: SMB2_write\n- 被调用者: 未显示\n\n7. 函数名: trace_smb3_write_enter\n- 参数: [xid, io_parms->persistent_fid, io_parms->tcon->tid, io_parms->tcon->ses->Suid, io_parms->offset, io_parms->length]\n- 调用者: SMB2_write\n- 被调用者: 未显示\n\n8. 函数名: memset\n- 参数: [&rqst, 0, sizeof(struct smb_rqst)]\n- 调用者: SMB2_write\n- 被调用者: 未显示\n\n9. 函数名: cifs_send_recv\n- 参数: [xid, io_parms->tcon->ses, &rqst, &resp_buftype, flags, &rsp_iov]\n- 调用者: SMB2_write\n- 被调用者: 未显示\n\n10. 函数名: cifs_small_buf_release\n- 参数: [req]\n- 调用者: SMB2_write\n- 被调用者: 未显示\n\n11. 函数名: trace_smb3_write_err\n- 参数: [xid, req->PersistentFileId, io_parms->tcon->tid, io_parms->tcon->ses->Suid, io_parms->offset, io_parms->length, rc]\n- 调用者: SMB2_write\n- 被调用者: 未显示\n\n12. 函数名: cifs_stats_fail_inc\n- 参数: [io_parms->tcon, SMB2_WRITE_HE]\n- 调用者: SMB2_write\n- 被调用者: 未显示\n\n13. 函数名: cifs_dbg\n- 参数: [VFS, \"Send error in write = %d\\n\", rc]\n- 调用者: SMB2_write\n- 被调用者: 未显示\n\n14. 函数名: le32_to_cpu\n- 参数: [rsp->DataLength]\n- 调用者: SMB2_write\n- 被调用者: 未显示\n\n15. 函数名: trace_smb3_write_done\n- 参数: [xid, req->PersistentFileId, io_parms->tcon->tid, io_parms->tcon->ses->Suid, io_parms->offset, *nbytes]\n- 调用者: SMB2_write\n- 被调用者: 未显示\n\n16. 函数名: free_rsp_buf\n- 参数: [resp_buftype, rsp]\n- 调用者: SMB2_write\n- 被调用者: 未显示"
    },
    {
        "id": 2027,
        "cwe": "CWE-416",
        "cve": "CVE-2019-15920",
        "purpose": "Code purpose:\"\"\"该代码实现了SMB2协议中的读取操作功能，处理从服务器读取数据的请求和响应。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在SMB2_read函数中，当resp_buftype为CIFS_NO_BUFFER时，未正确处理rsp_iov.iov_base的内存释放，导致后续可能发生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: SMB2_read\n- 参数: [xid, io_parms, nbytes, buf, buf_type]\n- 调用者: 未显示\n- 被调用者: [smb2_new_read_req, smb3_encryption_required, cifs_send_recv, cifs_small_buf_release, cifs_stats_fail_inc, cifs_dbg, trace_smb3_read_err, trace_smb3_read_done, free_rsp_buf, le32_to_cpu, memcpy]\n\n2. 函数名: smb2_new_read_req\n- 参数: [(void **)&req, &total_len, io_parms, NULL, 0, 0]\n- 调用者: SMB2_read\n- 被调用者: 未显示\n\n3. 函数名: smb3_encryption_required\n- 参数: [io_parms->tcon]\n- 调用者: SMB2_read\n- 被调用者: 未显示\n\n4. 函数名: cifs_send_recv\n- 参数: [xid, ses, &rqst, &resp_buftype, flags, &rsp_iov]\n- 调用者: SMB2_read\n- 被调用者: 未显示\n\n5. 函数名: cifs_small_buf_release\n- 参数: [req]\n- 调用者: SMB2_read\n- 被调用者: 未显示\n\n6. 函数名: cifs_stats_fail_inc\n- 参数: [io_parms->tcon, SMB2_READ_HE]\n- 调用者: SMB2_read\n- 被调用者: 未显示\n\n7. 函数名: cifs_dbg\n- 参数: [VFS, \"Send error in read = %d\\n\", rc] 和 [FYI, \"bad length %d for count %d\\n\", *nbytes, io_parms->length]\n- 调用者: SMB2_read\n- 被调用者: 未显示\n\n8. 函数名: trace_smb3_read_err\n- 参数: [xid, req->PersistentFileId, io_parms->tcon->tid, ses->Suid, io_parms->offset, io_parms->length, rc]\n- 调用者: SMB2_read\n- 被调用者: 未显示\n\n9. 函数名: trace_smb3_read_done\n- 参数: [xid, req->PersistentFileId, io_parms->tcon->tid, ses->Suid, io_parms->offset, 0] 和 [xid, req->PersistentFileId, io_parms->tcon->tid, ses->Suid, io_parms->offset, io_parms->length]\n- 调用者: SMB2_read\n- 被调用者: 未显示\n\n10. 函数名: free_rsp_buf\n- 参数: [resp_buftype, rsp_iov.iov_base]\n- 调用者: SMB2_read\n- 被调用者: 未显示\n\n11. 函数名: le32_to_cpu\n- 参数: [rsp->DataLength]\n- 调用者: SMB2_read\n- 被调用者: 未显示\n\n12. 函数名: memcpy\n- 参数: [*buf, (char *)rsp + rsp->DataOffset, *nbytes]\n- 调用者: SMB2_read\n- 被调用者: 未显示"
    },
    {
        "id": 2091,
        "cwe": "CWE-416",
        "cve": "CVE-2019-18683",
        "purpose": "Code purpose:\"\"\"该代码用于停止视频捕获流并处理相关资源释放，包括停止生成线程、释放活动缓冲区和完成控制请求。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在vivid_stop_generating_vid_cap()函数中存在错误的互斥锁使用，导致多个竞争条件，可能引发释放后使用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: vivid_stop_generating_vid_cap\n- 参数: [struct vivid_dev *dev, bool *pstreaming]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [dprintk, list_empty, list_entry, list_del, v4l2_ctrl_request_complete, vb2_buffer_done, vivid_grab_controls, mutex_unlock, kthread_stop, mutex_lock]\n\n2. 函数名: dprintk\n- 参数: [struct vivid_dev *dev, int level, const char *fmt, ...]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示（可能是内核打印函数）\n\n3. 函数名: list_empty\n- 参数: [struct list_head *list]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示（内核链表操作函数）\n\n4. 函数名: list_entry\n- 参数: [struct list_head *ptr, type, member]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示（内核链表操作函数）\n\n5. 函数名: list_del\n- 参数: [struct list_head *entry]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示（内核链表操作函数）\n\n6. 函数名: v4l2_ctrl_request_complete\n- 参数: [struct v4l2_ctrl_handler *hdl, struct v4l2_ctrl_handler *from]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示（V4L2子系统函数）\n\n7. 函数名: vb2_buffer_done\n- 参数: [struct vb2_buffer *vb, enum vb2_buffer_state state]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示（Video Buffer 2子系统函数）\n\n8. 函数名: vivid_grab_controls\n- 参数: [struct vivid_dev *dev, bool grab]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示（vivid驱动内部函数）\n\n9. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示（内核互斥锁操作函数）\n\n10. 函数名: kthread_stop\n- 参数: [struct task_struct *k]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示（内核线程操作函数）\n\n11. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: vivid_stop_generating_vid_cap\n- 被调用者: 未显示（内核互斥锁操作函数）"
    },
    {
        "id": 2092,
        "cwe": "CWE-416",
        "cve": "CVE-2019-18683",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中V4L2子系统vivid驱动程序的视频捕获线程功能，用于管理视频流捕获过程中的帧计数、时间计算和缓冲区同步等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在视频流停止过程中存在多个竞态条件，由于vivid_stop_generating_vid_cap()等函数及其对应的kthread中错误的互斥锁使用导致使用后释放漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: vivid_thread_vid_cap\n- 参数: [data]\n- 调用者: 未被显示（通常由kthread_create或类似函数调用）\n- 被调用者: [dprintk, set_freezable, ktime_get_ns, vivid_cap_update_frame_period, try_to_freeze, kthread_should_stop, mutex_lock, mutex_unlock, vivid_thread_vid_cap_tick, do_div, schedule_timeout_interruptible]\n\n2. 函数名: dprintk\n- 参数: [dev, 1, format_string]\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n3. 函数名: set_freezable\n- 参数: []\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n4. 函数名: ktime_get_ns\n- 参数: []\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n5. 函数名: vivid_cap_update_frame_period\n- 参数: [dev]\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n6. 函数名: try_to_freeze\n- 参数: []\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n7. 函数名: kthread_should_stop\n- 参数: []\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n8. 函数名: mutex_lock\n- 参数: [&dev->mutex]\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n9. 函数名: mutex_unlock\n- 参数: [&dev->mutex]\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n10. 函数名: vivid_thread_vid_cap_tick\n- 参数: [dev, dropped_bufs]\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n11. 函数名: do_div\n- 参数: [buffers_since_start, HZ * numerator]\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []\n\n12. 函数名: schedule_timeout_interruptible\n- 参数: [wait_jiffies ? wait_jiffies : 1]\n- 调用者: vivid_thread_vid_cap\n- 被调用者: []"
    },
    {
        "id": 2093,
        "cwe": "CWE-416",
        "cve": "CVE-2019-18683",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中V4L2子系统vivid驱动程序的视频输出线程功能，负责管理视频流的时间同步和缓冲区计数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在视频输出线程中存在竞态条件，由于错误的互斥锁使用导致在停止流媒体时可能发生释放后使用(UAF)问题\"\"\"",
        "functions": "Functions:\n1. 函数名: vivid_thread_vid_out\n- 参数: [data]\n- 调用者: 未知（由内核线程调用）\n- 被调用者: [dprintk, set_freezable, try_to_freeze, kthread_should_stop, mutex_lock, mutex_unlock, vivid_thread_vid_out_tick, do_div, schedule_timeout_interruptible]\n\n2. 函数名: dprintk\n- 参数: [dev, 1, format_string]\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n3. 函数名: set_freezable\n- 参数: []\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n4. 函数名: try_to_freeze\n- 参数: []\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n5. 函数名: kthread_should_stop\n- 参数: []\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n6. 函数名: mutex_lock\n- 参数: [&dev->mutex]\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n7. 函数名: mutex_unlock\n- 参数: [&dev->mutex]\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n8. 函数名: vivid_thread_vid_out_tick\n- 参数: [dev]\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n9. 函数名: do_div\n- 参数: [buffers_since_start, HZ * numerator]\n- 调用者: vivid_thread_vid_out\n- 被调用者: []\n\n10. 函数名: schedule_timeout_interruptible\n- 参数: [wait_jiffies ? wait_jiffies : 1]\n- 调用者: vivid_thread_vid_out\n- 被调用者: []"
    },
    {
        "id": 2094,
        "cwe": "CWE-416",
        "cve": "CVE-2019-18683",
        "purpose": "Code purpose:\"\"\"该代码用于停止视频输出流并处理相关缓冲区和控制线程，但存在竞态条件导致潜在的使用后释放漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在停止视频流生成时存在多个竞态条件，由于错误的互斥锁锁定机制导致使用后释放漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: vivid_stop_generating_vid_out\n- 参数: [dev, pstreaming]\n- 调用者: 未明确显示（应为外部调用）\n- 被调用者: [dprintk, list_empty, list_entry, list_del, v4l2_ctrl_request_complete, vb2_buffer_done, vivid_grab_controls, mutex_unlock, kthread_stop, mutex_lock]\n\n2. 函数名: dprintk\n- 参数: [dev, level, format, ...]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n3. 函数名: list_empty\n- 参数: [&dev->vid_out_active, &dev->vbi_out_active, &dev->meta_out_active]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n4. 函数名: list_entry\n- 参数: [dev->vid_out_active.next, dev->vbi_out_active.next, dev->meta_out_active.next, struct vivid_buffer, list]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n5. 函数名: list_del\n- 参数: [&buf->list]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n6. 函数名: v4l2_ctrl_request_complete\n- 参数: [buf->vb.vb2_buf.req_obj.req, &dev->ctrl_hdl_vid_out, &dev->ctrl_hdl_vbi_out, &dev->ctrl_hdl_meta_out]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n7. 函数名: vb2_buffer_done\n- 参数: [&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n8. 函数名: vivid_grab_controls\n- 参数: [dev, false]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n9. 函数名: mutex_unlock\n- 参数: [&dev->mutex]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n10. 函数名: kthread_stop\n- 参数: [dev->kthread_vid_out]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []\n\n11. 函数名: mutex_lock\n- 参数: [&dev->mutex]\n- 调用者: vivid_stop_generating_vid_out\n- 被调用者: []"
    },
    {
        "id": 2095,
        "cwe": "CWE-416",
        "cve": "CVE-2019-18683",
        "purpose": "Code purpose:\"\"\"停止SDR捕获流并清理相关资源，包括处理活动缓冲区列表和控制线程的关闭\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在停止流媒体过程中存在错误的互斥锁锁定机制，导致多个竞争条件，最终引发释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: sdr_cap_stop_streaming\n- 参数: [struct vb2_queue *vq]\n- 调用者: 未明确显示（通常由V4L2子系统调用）\n- 被调用者: [vb2_get_drv_priv, list_empty, list_entry, list_del, v4l2_ctrl_request_complete, vb2_buffer_done, mutex_unlock, kthread_stop, mutex_lock]\n\n2. 函数名: vb2_get_drv_priv\n- 参数: [struct vb2_queue *vq]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n3. 函数名: list_empty\n- 参数: [&dev->sdr_cap_active]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n4. 函数名: list_entry\n- 参数: [dev->sdr_cap_active.next, struct vivid_buffer, list]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n5. 函数名: list_del\n- 参数: [&buf->list]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n6. 函数名: v4l2_ctrl_request_complete\n- 参数: [buf->vb.vb2_buf.req_obj.req, &dev->ctrl_hdl_sdr_cap]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n7. 函数名: vb2_buffer_done\n- 参数: [&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n8. 函数名: mutex_unlock\n- 参数: [&dev->mutex]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n9. 函数名: kthread_stop\n- 参数: [dev->kthread_sdr_cap]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []\n\n10. 函数名: mutex_lock\n- 参数: [&dev->mutex]\n- 调用者: sdr_cap_stop_streaming\n- 被调用者: []"
    },
    {
        "id": 2096,
        "cwe": "CWE-416",
        "cve": "CVE-2019-18683",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中V4L2子系统vivid驱动程序的SDR捕获线程功能，用于处理软件定义无线电(SDR)的数据流捕获和同步。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在vivid驱动程序的流停止过程中存在多个竞态条件，由于vivid_stop_generating_vid_cap()等函数及其对应的kthread中错误的互斥锁锁定机制，导致了使用后释放的问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: vivid_thread_sdr_cap\n- 参数: [data]\n- 调用者: 未被显示（通常由kthread_create或类似函数创建线程时调用）\n- 被调用者: [dprintk, set_freezable, try_to_freeze, kthread_should_stop, mutex_lock, mutex_unlock, vivid_thread_sdr_cap_tick, do_div, schedule_timeout_interruptible]\n\n2. 函数名: dprintk\n- 参数: [dev, 1, format_string]\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n3. 函数名: set_freezable\n- 参数: []\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n4. 函数名: try_to_freeze\n- 参数: []\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n5. 函数名: kthread_should_stop\n- 参数: []\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n6. 函数名: mutex_lock\n- 参数: [&dev->mutex]\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n7. 函数名: mutex_unlock\n- 参数: [&dev->mutex]\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n8. 函数名: vivid_thread_sdr_cap_tick\n- 参数: [dev]\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n9. 函数名: do_div\n- 参数: [buffers_since_start, HZ * SDR_CAP_SAMPLES_PER_BUF]\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []\n\n10. 函数名: schedule_timeout_interruptible\n- 参数: [wait_jiffies ? wait_jiffies : 1]\n- 调用者: vivid_thread_sdr_cap\n- 被调用者: []"
    },
    {
        "id": 2106,
        "cwe": "CWE-416",
        "cve": "CVE-2019-18814",
        "purpose": "Code purpose:\"\"\"初始化AppArmor审计规则，包括验证字段和操作符，分配内存并解析标签，最后返回规则结构体\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当aa_label_parse()函数调用失败时，aa_audit_rule_free()释放了rule内存，但后续又通过PTR_ERR()访问了已释放的rule->label，导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: aa_audit_rule_init\n- 参数: [u32 field, u32 op, char *rulestr, void **vrule]\n- 调用者: 未显示（外部调用）\n- 被调用者: [kzalloc, aa_label_parse, aa_audit_rule_free, PTR_ERR]\n\n2. 函数名: aa_label_parse\n- 参数: [&root_ns->unconfined->label, rulestr, GFP_KERNEL, true, false]\n- 调用者: aa_audit_rule_init\n- 被调用者: 未显示（可能为内部实现）\n\n3. 函数名: aa_audit_rule_free\n- 参数: [rule]\n- 调用者: aa_audit_rule_init\n- 被调用者: 未显示（可能为内部实现）\n\n4. 函数名: kzalloc\n- 参数: [sizeof(struct aa_audit_rule), GFP_KERNEL]\n- 调用者: aa_audit_rule_init\n- 被调用者: 未显示（内核内存分配函数）\n\n5. 函数名: PTR_ERR\n- 参数: [rule->label]\n- 调用者: aa_audit_rule_init\n- 被调用者: 未显示（内核错误处理宏）"
    },
    {
        "id": 2187,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19318",
        "purpose": "Code purpose:\"\"\"创建一个新的测试inode结构体用于btrfs文件系统测试\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在btrfs文件系统中重复挂载特制镜像导致rwsem_down_write_slowpath中的使用已释放指针，引发use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: btrfs_new_test_inode\n- 参数: []\n- 调用者: N/A (顶层函数)\n- 被调用者: [new_inode]\n\n2. 函数名: new_inode\n- 参数: [test_mnt->mnt_sb]\n- 调用者: btrfs_new_test_inode\n- 被调用者: []"
    },
    {
        "id": 2188,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19319",
        "purpose": "Code purpose:\"\"\"该代码用于在ext4文件系统中设置系统区域，包括处理块组描述符、位图和inode表等系统数据结构\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核5.2之前版本中，挂载特制的ext4镜像后执行setxattr操作时，由于ext4_xattr_set_entry函数中对大old_size值的memset调用存在释放后使用问题，导致可越界写入的漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_setup_system_zone\n- 参数: [struct super_block *sb]\n- 调用者: N/A\n- 被调用者: [ext4_get_groups_count, EXT4_SB, ext4_flex_bg_size, test_opt, ext4_release_system_zone, ext4_bg_has_super, add_system_zone, ext4_group_first_block_no, ext4_bg_num_gdb, ext4_get_group_desc, ext4_block_bitmap, ext4_inode_bitmap, ext4_inode_table, debug_print_tree]\n\n2. 函数名: ext4_get_groups_count\n- 参数: [struct super_block *sb]\n- 调用者: ext4_setup_system_zone\n- 被调用者: N/A\n\n3. 函数名: ext4_flex_bg_size\n- 参数: [struct ext4_sb_info *sbi]\n- 调用者: ext4_setup_system_zone\n- 被调用者: N/A\n\n4. 函数名: test_opt\n- 参数: [struct super_block *sb, int opt]\n- 调用者: ext4_setup_system_zone\n- 被调用者: N/A\n\n5. 函数名: ext4_release_system_zone\n- 参数: [struct super_block *sb]\n- 调用者: ext4_setup_system_zone\n- 被调用者: N/A\n\n6. 函数名: ext4_bg_has_super\n- 参数: [struct super_block *sb, ext4_group_t group]\n- 调用者: ext4_setup_system_zone\n- 被调用者: N/A\n\n7. 函数名: add_system_zone\n- 参数: [struct ext4_sb_info *sbi, sector_t start_blk, unsigned int count]\n- 调用者: ext4_setup_system_zone\n- 被调用者: N/A\n\n8. 函数名: ext4_group_first_block_no\n- 参数: [struct super_block *sb, ext4_group_t group]\n- 调用者: ext4_setup_system_zone\n- 被调用者: N/A\n\n9. 函数名: ext4_bg_num_gdb\n- 参数: [struct super_block *sb, ext4_group_t group]\n- 调用者: ext4_setup_system_zone\n- 被调用者: N/A\n\n10. 函数名: ext4_get_group_desc\n- 参数: [struct super_block *sb, ext4_group_t group, struct buffer_head **bh]\n- 调用者: ext4_setup_system_zone\n- 被调用者: N/A\n\n11. 函数名: ext4_block_bitmap\n- 参数: [struct super_block *sb, struct ext4_group_desc *bg]\n- 调用者: ext4_setup_system_zone\n- 被调用者: N/A\n\n12. 函数名: ext4_inode_bitmap\n- 参数: [struct super_block *sb, struct ext4_group_desc *bg]\n- 调用者: ext4_setup_system_zone\n- 被调用者: N/A\n\n13. 函数名: ext4_inode_table\n- 参数: [struct super_block *sb, struct ext4_group_desc *bg]\n- 调用者: ext4_setup_system_zone\n- 被调用者: N/A\n\n14. 函数名: debug_print_tree\n- 参数: [struct ext4_sb_info *sbi]\n- 调用者: ext4_setup_system_zone\n- 被调用者: N/A"
    },
    {
        "id": 2189,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19319",
        "purpose": "Code purpose:\"\"\"检查ext4文件系统中数据块的合法性，防止非法块访问\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核5.2之前版本中，挂载特制的ext4镜像后执行setxattr操作时，由于ext4_xattr_set_entry函数中对大old_size值的memset调用存在释放后使用(UAF)问题，导致slab越界写入。\"\"\"",
        "functions": "Functions:\n1. 函数名: __check_block_validity\n- 参数: [struct inode *inode, const char *func, unsigned int line, struct ext4_map_blocks *map]\n- 调用者: 未明确显示（通常由ext4文件系统相关操作调用）\n- 被调用者: [ext4_data_block_valid, ext4_error_inode]\n\n2. 函数名: ext4_data_block_valid\n- 参数: [EXT4_SB(inode->i_sb), map->m_pblk, map->m_len]\n- 调用者: __check_block_validity\n- 被调用者: 未显示\n\n3. 函数名: ext4_error_inode\n- 参数: [inode, func, line, map->m_pblk, \"lblock %lu mapped to illegal pblock %llu (length %d)\", (unsigned long) map->m_lblk, map->m_pblk, map->m_len]\n- 调用者: __check_block_validity\n- 被调用者: 未显示"
    },
    {
        "id": 2193,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19377",
        "purpose": "Code purpose:\"\"\"该代码用于处理Btrfs文件系统中页面缓存的写入操作，包括查找脏页、锁定扩展缓冲区并执行写入操作，同时处理循环写入和同步/异步模式。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在btree_write_cache_pages函数中，对extent_buffer对象的引用计数管理不当，可能导致在释放后仍被使用的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: btree_write_cache_pages\n- 参数: [struct address_space *mapping, struct writeback_control *wbc]\n- 调用者: N/A\n- 被调用者: [pagevec_init, tag_pages_for_writeback, pagevec_lookup_range_tag, atomic_inc_not_zero, lock_extent_buffer_for_io, free_extent_buffer, write_one_eb, pagevec_release, cond_resched, end_write_bio, flush_write_bio]\n\n2. 函数名: pagevec_init\n- 参数: [struct pagevec *pvec]\n- 调用者: btree_write_cache_pages\n- 被调用者: N/A\n\n3. 函数名: tag_pages_for_writeback\n- 参数: [struct address_space *mapping, pgoff_t index, pgoff_t end]\n- 调用者: btree_write_cache_pages\n- 被调用者: N/A\n\n4. 函数名: pagevec_lookup_range_tag\n- 参数: [struct pagevec *pvec, struct address_space *mapping, pgoff_t *index, pgoff_t end, xa_mark_t tag]\n- 调用者: btree_write_cache_pages\n- 被调用者: N/A\n\n5. 函数名: atomic_inc_not_zero\n- 参数: [atomic_t *v]\n- 调用者: btree_write_cache_pages\n- 被调用者: N/A\n\n6. 函数名: lock_extent_buffer_for_io\n- 参数: [struct extent_buffer *eb, struct extent_page_data *epd]\n- 调用者: btree_write_cache_pages\n- 被调用者: N/A\n\n7. 函数名: free_extent_buffer\n- 参数: [struct extent_buffer *eb]\n- 调用者: btree_write_cache_pages\n- 被调用者: N/A\n\n8. 函数名: write_one_eb\n- 参数: [struct extent_buffer *eb, struct writeback_control *wbc, struct extent_page_data *epd]\n- 调用者: btree_write_cache_pages\n- 被调用者: N/A\n\n9. 函数名: pagevec_release\n- 参数: [struct pagevec *pvec]\n- 调用者: btree_write_cache_pages\n- 被调用者: N/A\n\n10. 函数名: cond_resched\n- 参数: []\n- 调用者: btree_write_cache_pages\n- 被调用者: N/A\n\n11. 函数名: end_write_bio\n- 参数: [struct extent_page_data *epd, int ret]\n- 调用者: btree_write_cache_pages\n- 被调用者: N/A\n\n12. 函数名: flush_write_bio\n- 参数: [struct extent_page_data *epd]\n- 调用者: btree_write_cache_pages\n- 被调用者: N/A"
    },
    {
        "id": 2194,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19447",
        "purpose": "Code purpose:\"\"\"该代码实现了ext4文件系统中删除文件或目录的功能，包括查找目录项、处理日志事务、更新inode链接计数等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4文件系统卸载过程中，由于未正确处理孤儿inode列表导致释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_unlink\n- 参数: [dir, dentry]\n- 调用者: 无（内核函数，由VFS层调用）\n- 被调用者: [ext4_forced_shutdown, dquot_initialize, ext4_find_entry, ext4_journal_start, ext4_handle_sync, ext4_warning_inode, ext4_delete_entry, current_time, ext4_update_dx_flag, ext4_mark_inode_dirty, drop_nlink, ext4_orphan_add, d_invalidate, brelse, ext4_journal_stop]\n\n2. 函数名: ext4_forced_shutdown\n- 参数: [EXT4_SB(dir->i_sb)]\n- 调用者: ext4_unlink\n- 被调用者: []\n\n3. 函数名: dquot_initialize\n- 参数: [dir], [d_inode(dentry)]\n- 调用者: ext4_unlink\n- 被调用者: []\n\n4. 函数名: ext4_find_entry\n- 参数: [dir, &dentry->d_name, &de, NULL]\n- 调用者: ext4_unlink\n- 被调用者: []\n\n5. 函数名: ext4_journal_start\n- 参数: [dir, EXT4_HT_DIR, EXT4_DATA_TRANS_BLOCKS(dir->i_sb)]\n- 调用者: ext4_unlink\n- 被调用者: []\n\n6. 函数名: ext4_handle_sync\n- 参数: [handle]\n- 调用者: ext4_unlink\n- 被调用者: []\n\n7. 函数名: ext4_warning_inode\n- 参数: [inode, \"Deleting file '%.*s' with no links\", dentry->d_name.len, dentry->d_name.name]\n- 调用者: ext4_unlink\n- 被调用者: []\n\n8. 函数名: ext4_delete_entry\n- 参数: [handle, dir, de, bh]\n- 调用者: ext4_unlink\n- 被调用者: []\n\n9. 函数名: current_time\n- 参数: [dir], [inode]\n- 调用者: ext4_unlink\n- 被调用者: []\n\n10. 函数名: ext4_update_dx_flag\n- 参数: [dir]\n- 调用者: ext4_unlink\n- 被调用者: []\n\n11. 函数名: ext4_mark_inode_dirty\n- 参数: [handle, dir], [handle, inode]\n- 调用者: ext4_unlink\n- 被调用者: []\n\n12. 函数名: drop_nlink\n- 参数: [inode]\n- 调用者: ext4_unlink\n- 被调用者: []\n\n13. 函数名: ext4_orphan_add\n- 参数: [handle, inode]\n- 调用者: ext4_unlink\n- 被调用者: []\n\n14. 函数名: d_invalidate\n- 参数: [dentry]\n- 调用者: ext4_unlink\n- 被调用者: []\n\n15. 函数名: brelse\n- 参数: [bh]\n- 调用者: ext4_unlink\n- 被调用者: []\n\n16. 函数名: ext4_journal_stop\n- 参数: [handle]\n- 调用者: ext4_unlink\n- 被调用者: []"
    },
    {
        "id": 2195,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19448",
        "purpose": "Code purpose:\"\"\"该代码用于在Btrfs文件系统中尝试合并相邻的空闲空间块，以优化存储空间管理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在合并空闲空间时，左右数据结构的指针可能相同，导致释放后再次使用，引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: try_merge_free_space\n- 参数: [struct btrfs_free_space_ctl *ctl, struct btrfs_free_space *info, bool update_stat]\n- 调用者: 未明确显示（由外部调用）\n- 被调用者: [tree_search_offset, rb_prev, rb_entry, unlink_free_space, __unlink_free_space, kmem_cache_free, btrfs_free_space_trimmed]\n\n2. 函数名: tree_search_offset\n- 参数: [struct btrfs_free_space_ctl *ctl, u64 offset, int bitmap_only, int fuzzy]\n- 调用者: try_merge_free_space\n- 被调用者: 未显示\n\n3. 函数名: rb_prev\n- 参数: [struct rb_node *node]\n- 调用者: try_merge_free_space\n- 被调用者: 未显示\n\n4. 函数名: rb_entry\n- 参数: [struct rb_node *ptr, type, member]\n- 调用者: try_merge_free_space\n- 被调用者: 未显示\n\n5. 函数名: unlink_free_space\n- 参数: [struct btrfs_free_space_ctl *ctl, struct btrfs_free_space *info]\n- 调用者: try_merge_free_space\n- 被调用者: 未显示\n\n6. 函数名: __unlink_free_space\n- 参数: [struct btrfs_free_space_ctl *ctl, struct btrfs_free_space *info]\n- 调用者: try_merge_free_space\n- 被调用者: 未显示\n\n7. 函数名: kmem_cache_free\n- 参数: [struct kmem_cache *cachep, void *objp]\n- 调用者: try_merge_free_space\n- 被调用者: 未显示\n\n8. 函数名: btrfs_free_space_trimmed\n- 参数: [struct btrfs_free_space *info]\n- 调用者: try_merge_free_space\n- 被调用者: 未显示"
    },
    {
        "id": 2198,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19523",
        "purpose": "Code purpose:\"\"\"该代码用于处理USB设备断开连接时的清理工作，包括注销设备接口和释放相关资源。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放设备(adu_delete)后，仍可能通过dev指针访问已被释放的内存，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: adu_disconnect\n- 参数: [struct usb_interface *interface]\n- 调用者: 未显示（通常由USB子系统调用）\n- 被调用者: [usb_get_intfdata, mutex_lock, usb_deregister_dev, mutex_unlock, usb_set_intfdata, adu_delete]\n\n2. 函数名: usb_get_intfdata\n- 参数: [struct usb_interface *interface]\n- 调用者: adu_disconnect\n- 被调用者: []\n\n3. 函数名: mutex_lock\n- 参数: [&dev->mtx, &adutux_mutex]\n- 调用者: adu_disconnect\n- 被调用者: []\n\n4. 函数名: usb_deregister_dev\n- 参数: [struct usb_interface *interface, &adu_class]\n- 调用者: adu_disconnect\n- 被调用者: []\n\n5. 函数名: mutex_unlock\n- 参数: [&dev->mtx, &adutux_mutex]\n- 调用者: adu_disconnect\n- 被调用者: []\n\n6. 函数名: usb_set_intfdata\n- 参数: [struct usb_interface *interface, NULL]\n- 调用者: adu_disconnect\n- 被调用者: []\n\n7. 函数名: adu_delete\n- 参数: [struct adu_device *dev]\n- 调用者: adu_disconnect\n- 被调用者: []"
    },
    {
        "id": 2199,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19524",
        "purpose": "Code purpose:\"\"\"释放内存中ml_device结构体的private成员所指向的内存空间\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放ml->private指针后未将其置空，导致后续可能发生对已释放内存的使用\"\"\"",
        "functions": "Functions:\n1. 函数名: ml_ff_destroy\n- 参数: [struct ff_device *ff]\n- 调用者: 未明确显示（通常由输入设备驱动框架调用）\n- 被调用者: [kfree]\n\n2. 函数名: kfree\n- 参数: [void *ml->private]\n- 调用者: ml_ff_destroy\n- 被调用者: []"
    },
    {
        "id": 2200,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19525",
        "purpose": "Code purpose:\"\"\"处理USB接口断开时的资源清理和硬件注销工作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在atusb_disconnect函数中，由于未正确管理USB设备引用计数和资源释放顺序，导致在设备断开连接时可能发生use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: atusb_disconnect\n- 参数: [struct usb_interface *interface]\n- 调用者: 内核USB子系统\n- 被调用者: [usb_get_intfdata, dev_dbg, cancel_delayed_work_sync, usb_kill_anchored_urbs, atusb_free_urbs, usb_kill_urb, usb_free_urb, ieee802154_unregister_hw, ieee802154_free_hw, usb_set_intfdata, usb_put_dev, pr_debug]\n\n2. 函数名: usb_get_intfdata\n- 参数: [struct usb_interface *interface]\n- 调用者: atusb_disconnect\n- 被调用者: []\n\n3. 函数名: dev_dbg\n- 参数: [&atusb->usb_dev->dev, \"%s\\n\", __func__]\n- 调用者: atusb_disconnect\n- 被调用者: []\n\n4. 函数名: cancel_delayed_work_sync\n- 参数: [&atusb->work]\n- 调用者: atusb_disconnect\n- 被调用者: []\n\n5. 函数名: usb_kill_anchored_urbs\n- 参数: [&atusb->rx_urbs]\n- 调用者: atusb_disconnect\n- 被调用者: []\n\n6. 函数名: atusb_free_urbs\n- 参数: [atusb]\n- 调用者: atusb_disconnect\n- 被调用者: []\n\n7. 函数名: usb_kill_urb\n- 参数: [atusb->tx_urb]\n- 调用者: atusb_disconnect\n- 被调用者: []\n\n8. 函数名: usb_free_urb\n- 参数: [atusb->tx_urb]\n- 调用者: atusb_disconnect\n- 被调用者: []\n\n9. 函数名: ieee802154_unregister_hw\n- 参数: [atusb->hw]\n- 调用者: atusb_disconnect\n- 被调用者: []\n\n10. 函数名: ieee802154_free_hw\n- 参数: [atusb->hw]\n- 调用者: atusb_disconnect\n- 被调用者: []\n\n11. 函数名: usb_set_intfdata\n- 参数: [interface, NULL]\n- 调用者: atusb_disconnect\n- 被调用者: []\n\n12. 函数名: usb_put_dev\n- 参数: [atusb->usb_dev]\n- 调用者: atusb_disconnect\n- 被调用者: []\n\n13. 函数名: pr_debug\n- 参数: [\"%s done\\n\", __func__]\n- 调用者: atusb_disconnect\n- 被调用者: []"
    },
    {
        "id": 2201,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19526",
        "purpose": "Code purpose:\"\"\"该代码实现了PN533 USB NFC设备的探测和初始化功能，包括USB接口配置、端点检测、URB分配以及设备注册等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在错误处理路径中未正确释放已分配的in_buf缓冲区，导致后续可能发生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: pn533_usb_probe\n- 参数: [struct usb_interface *interface, const struct usb_device_id *id]\n- 调用者: 内核USB子系统\n- 被调用者: [devm_kzalloc, kzalloc, usb_get_dev, interface_to_usbdev, usb_endpoint_is_bulk_in, usb_endpoint_is_bulk_out, nfc_err, usb_alloc_urb, usb_fill_bulk_urb, pn533_register_device, pn533_acr122_poweron_rdr, pn533_finalize_setup, usb_set_intfdata, usb_free_urb, usb_put_dev, kfree]\n\n2. 函数名: pn533_send_complete\n- 参数: [未在代码中显示完整参数]\n- 调用者: USB核心(通过urb完成回调)\n- 被调用者: []\n\n3. 函数名: pn533_acr122_poweron_rdr\n- 参数: [struct pn533_usb_phy *phy]\n- 调用者: pn533_usb_probe\n- 被调用者: []\n\n4. 函数名: pn533_register_device\n- 参数: [id->driver_info, protocols, protocol_type, phy, &usb_phy_ops, fops, &phy->udev->dev, &interface->dev]\n- 调用者: pn533_usb_probe\n- 被调用者: []\n\n5. 函数名: pn533_finalize_setup\n- 参数: [struct pn533 *priv]\n- 调用者: pn533_usb_probe\n- 被调用者: []"
    },
    {
        "id": 2202,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19527",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中HID设备驱动的打开功能，处理USB HID设备的连接、初始化和资源分配，并管理设备的存在状态和电源状态。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在检查设备存在状态和增加打开计数之间存在竞争条件，导致在设备已被释放后仍可能被访问，造成释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: hiddev_open\n- 参数: [struct inode *inode, struct file *file]\n- 调用者: 未显示（由文件操作结构调用）\n- 被调用者: [usbhid_find_interface, iminor, usb_get_intfdata, vzalloc, mutex_init, hid_hw_open, spin_lock_irq, list_add_tail, spin_unlock_irq, mutex_lock, mutex_unlock, hid_hw_power, vfree]\n\n2. 函数名: usbhid_find_interface\n- 参数: [int minor]\n- 调用者: hiddev_open\n- 被调用者: 未显示\n\n3. 函数名: iminor\n- 参数: [struct inode *inode]\n- 调用者: hiddev_open\n- 被调用者: 未显示\n\n4. 函数名: usb_get_intfdata\n- 参数: [struct usb_interface *intf]\n- 调用者: hiddev_open\n- 被调用者: 未显示\n\n5. 函数名: vzalloc\n- 参数: [size_t size]\n- 调用者: hiddev_open\n- 被调用者: 未显示\n\n6. 函数名: mutex_init\n- 参数: [struct mutex *lock]\n- 调用者: hiddev_open\n- 被调用者: 未显示\n\n7. 函数名: hid_hw_open\n- 参数: [struct hid_device *hid]\n- 调用者: hiddev_open\n- 被调用者: 未显示\n\n8. 函数名: spin_lock_irq\n- 参数: [spinlock_t *lock]\n- 调用者: hiddev_open\n- 被调用者: 未显示\n\n9. 函数名: list_add_tail\n- 参数: [struct list_head *new, struct list_head *head]\n- 调用者: hiddev_open\n- 被调用者: 未显示\n\n10. 函数名: spin_unlock_irq\n- 参数: [spinlock_t *lock]\n- 调用者: hiddev_open\n- 被调用者: 未显示\n\n11. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: hiddev_open\n- 被调用者: 未显示\n\n12. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: hiddev_open\n- 被调用者: 未显示\n\n13. 函数名: hid_hw_power\n- 参数: [struct hid_device *hid, int level]\n- 调用者: hiddev_open\n- 被调用者: 未显示\n\n14. 函数名: vfree\n- 参数: [const void *addr]\n- 调用者: hiddev_open\n- 被调用者: 未显示"
    },
    {
        "id": 2203,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19528",
        "purpose": "Code purpose:\"\"\"处理USB I/O Warrior设备的断开连接，包括释放资源、终止未完成操作以及清理设备数据结构。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在iowarrior_disconnect函数中，当设备未被打开时直接调用iowarrior_delete释放dev结构体，但在释放后仍可能被其他线程访问，导致释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: iowarrior_disconnect\n- 参数: [struct usb_interface *interface]\n- 调用者: 未显示（由USB子系统调用）\n- 被调用者: [usb_get_intfdata, mutex_lock, usb_set_intfdata, mutex_unlock, usb_deregister_dev, usb_kill_urb, wake_up_interruptible, iowarrior_delete, dev_info]\n\n2. 函数名: usb_get_intfdata\n- 参数: [struct usb_interface *interface]\n- 调用者: iowarrior_disconnect\n- 被调用者: []\n\n3. 函数名: mutex_lock\n- 参数: [&iowarrior_open_disc_lock]\n- 调用者: iowarrior_disconnect\n- 被调用者: []\n\n4. 函数名: usb_set_intfdata\n- 参数: [struct usb_interface *interface, NULL]\n- 调用者: iowarrior_disconnect\n- 被调用者: []\n\n5. 函数名: mutex_unlock\n- 参数: [&iowarrior_open_disc_lock]\n- 调用者: iowarrior_disconnect\n- 被调用者: []\n\n6. 函数名: usb_deregister_dev\n- 参数: [struct usb_interface *interface, &iowarrior_class]\n- 调用者: iowarrior_disconnect\n- 被调用者: []\n\n7. 函数名: mutex_lock\n- 参数: [&dev->mutex]\n- 调用者: iowarrior_disconnect\n- 被调用者: []\n\n8. 函数名: mutex_unlock\n- 参数: [&dev->mutex]\n- 调用者: iowarrior_disconnect\n- 被调用者: []\n\n9. 函数名: usb_kill_urb\n- 参数: [dev->int_in_urb]\n- 调用者: iowarrior_disconnect\n- 被调用者: []\n\n10. 函数名: wake_up_interruptible\n- 参数: [&dev->read_wait]\n- 调用者: iowarrior_disconnect\n- 被调用者: []\n\n11. 函数名: wake_up_interruptible\n- 参数: [&dev->write_wait]\n- 调用者: iowarrior_disconnect\n- 被调用者: []\n\n12. 函数名: iowarrior_delete\n- 参数: [dev]\n- 调用者: iowarrior_disconnect\n- 被调用者: []\n\n13. 函数名: dev_info\n- 参数: [&interface->dev, \"I/O-Warror #%d now disconnected\\n\", minor - IOWARRIOR_MINOR_BASE]\n- 调用者: iowarrior_disconnect\n- 被调用者: []"
    },
    {
        "id": 2204,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19529",
        "purpose": "Code purpose:\"\"\"处理USB CAN设备断开连接时的清理工作，包括取消注册网络设备、释放资源和断开URB链接\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在设备断开连接时，代码在释放netdev资源后仍可能通过priv指针访问已释放的内存，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: mcba_usb_disconnect\n- 参数: [struct usb_interface *intf]\n- 调用者: 未显示（由USB子系统调用）\n- 被调用者: [usb_get_intfdata, usb_set_intfdata, netdev_info, unregister_candev, free_candev, mcba_urb_unlink]\n\n2. 函数名: usb_get_intfdata\n- 参数: [struct usb_interface *intf]\n- 调用者: mcba_usb_disconnect\n- 被调用者: []\n\n3. 函数名: usb_set_intfdata\n- 参数: [struct usb_interface *intf, NULL]\n- 调用者: mcba_usb_disconnect\n- 被调用者: []\n\n4. 函数名: netdev_info\n- 参数: [priv->netdev, \"device disconnected\\n\"]\n- 调用者: mcba_usb_disconnect\n- 被调用者: []\n\n5. 函数名: unregister_candev\n- 参数: [priv->netdev]\n- 调用者: mcba_usb_disconnect\n- 被调用者: []\n\n6. 函数名: free_candev\n- 参数: [priv->netdev]\n- 调用者: mcba_usb_disconnect\n- 被调用者: []\n\n7. 函数名: mcba_urb_unlink\n- 参数: [priv]\n- 调用者: mcba_usb_disconnect\n- 被调用者: []"
    },
    {
        "id": 2205,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19530",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中USB ACM(Abstract Control Model)驱动程序的探测功能，用于初始化和配置USB通信设备类(CDC)的ACM设备，包括接口检测、端点配置、缓冲区分配和设备注册等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在cdc-acm驱动程序中，当恶意USB设备被拔出时，由于未正确处理设备资源的释放顺序，导致存在use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: acm_probe\n- 参数: [struct usb_interface *intf, const struct usb_device_id *id]\n- 调用者: 内核USB子系统\n- 被调用者: [usb_ifnum_to_if, cdc_parse_cdc_header, usb_find_common_endpoints, swap, kzalloc, tty_port_init, acm_alloc_minor, usb_endpoint_maxp, usb_alloc_coherent, acm_write_buffers_alloc, usb_alloc_urb, usb_fill_int_urb, usb_fill_bulk_urb, device_create_file, kmalloc, memcpy, usb_set_intfdata, usb_driver_claim_interface, usb_get_intf, tty_port_register_device, usb_clear_halt, device_remove_file, kfree, usb_free_urb, acm_read_buffers_free, acm_write_buffers_free, usb_free_coherent, tty_port_put]\n\n2. 函数名: usb_ifnum_to_if\n- 参数: [struct usb_device *dev, unsigned ifnum]\n- 调用者: acm_probe\n- 被调用者: []\n\n3. 函数名: cdc_parse_cdc_header\n- 参数: [struct usb_cdc_parsed_header *h, struct usb_interface *intf, unsigned char *buffer, int buflen]\n- 调用者: acm_probe\n- 被调用者: []\n\n4. 函数名: usb_find_common_endpoints\n- 参数: [struct usb_host_interface *alt, struct usb_endpoint_descriptor **in, struct usb_endpoint_descriptor **out, struct usb_endpoint_descriptor **status, struct usb_endpoint_descriptor **interrupt]\n- 调用者: acm_probe\n- 被调用者: []\n\n5. 函数名: swap\n- 参数: [type a, type b]\n- 调用者: acm_probe\n- 被调用者: []\n\n6. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: acm_probe\n- 被调用者: []\n\n7. 函数名: tty_port_init\n- 参数: [struct tty_port *port]\n- 调用者: acm_probe\n- 被调用者: []\n\n8. 函数名: acm_alloc_minor\n- 参数: [struct acm *acm]\n- 调用者: acm_probe\n- 被调用者: []\n\n9. 函数名: usb_endpoint_maxp\n- 参数: [const struct usb_endpoint_descriptor *epd]\n- 调用者: acm_probe\n- 被调用者: []\n\n10. 函数名: usb_alloc_coherent\n- 参数: [struct usb_device *dev, size_t size, gfp_t mem_flags, dma_addr_t *dma]\n- 调用者: acm_probe\n- 被调用者: []\n\n11. 函数名: acm_write_buffers_alloc\n- 参数: [struct acm *acm]\n- 调用者: acm_probe\n- 被调用者: []\n\n12. 函数名: usb_alloc_urb\n- 参数: [int iso_packets, gfp_t mem_flags]\n- 调用者: acm_probe\n- 被调用者: []\n\n13. 函数名: usb_fill_int_urb\n- 参数: [struct urb *urb, struct usb_device *dev, unsigned int pipe, void *transfer_buffer, int buffer_length, usb_complete_t complete_fn, void *context, int interval]\n- 调用者: acm_probe\n- 被调用者: []\n\n14. 函数名: usb_fill_bulk_urb\n- 参数: [struct urb *urb, struct usb_device *dev, unsigned int pipe, void *transfer_buffer, int buffer_length, usb_complete_t complete_fn, void *context]\n- 调用者: acm_probe\n- 被调用者: []\n\n15. 函数名: device_create_file\n- 参数: [struct device *dev, const struct device_attribute *attr]\n- 调用者: acm_probe\n- 被调用者: []\n\n16. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: acm_probe\n- 被调用者: []\n\n17. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: acm_probe\n- 被调用者: []\n\n18. 函数名: usb_set_intfdata\n- 参数: [struct usb_interface *intf, void *data]\n- 调用者: acm_probe\n- 被调用者: []\n\n19. 函数名: usb_driver_claim_interface\n- 参数: [struct usb_driver *driver, struct usb_interface *iface, void *priv]\n- 调用者: acm_probe\n- 被调用者: []\n\n20. 函数名: usb_get_intf\n- 参数: [struct usb_interface *intf]\n- 调用者: acm_probe\n- 被调用者: []\n\n21. 函数名: tty_port_register_device\n- 参数: [struct tty_port *port, struct tty_driver *driver, unsigned index, struct device *device]\n- 调用者: acm_probe\n- 被调用者: []\n\n22. 函数名: usb_clear_halt\n- 参数: [struct usb_device *dev, int pipe]\n- 调用者: acm_probe\n- 被调用者: []\n\n23. 函数名: device_remove_file\n- 参数: [struct device *dev, const struct device_attribute *attr]\n- 调用者: acm_probe\n- 被调用者: []\n\n24. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: acm_probe\n- 被调用者: []\n\n25. 函数名: usb_free_urb\n- 参数: [struct urb *urb]\n- 调用者: acm_probe\n- 被调用者: []\n\n26. 函数名: acm_read_buffers_free\n- 参数: [struct acm *acm]\n- 调用者: acm_probe\n- 被调用者: []\n\n27. 函数名: acm_write_buffers_free\n- 参数: [struct acm *acm]\n- 调用者: acm_probe\n- 被调用者: []\n\n28. 函数名: usb_free_coherent\n- 参数: [struct usb_device *dev, size_t size, void *addr, dma_addr_t dma]\n- 调用者: acm_probe\n- 被调用者: []\n\n29. 函数名: tty_port_put\n- 参数: [struct tty_port *port]\n- 调用者: acm_probe\n- 被调用者: []"
    },
    {
        "id": 2206,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19531",
        "purpose": "Code purpose:\"\"\"释放USB设备yurex驱动相关的资源，包括URB（USB请求块）、缓冲区和设备结构体\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放USB设备资源时，由于未正确处理引用计数导致在释放后仍可能被访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: yurex_delete\n- 参数: [struct kref *kref]\n- 调用者: 未显示（通常由kref_put调用）\n- 被调用者: [to_yurex_dev, dev_dbg, usb_put_dev, usb_kill_urb, kfree, usb_free_coherent, usb_free_urb]\n\n2. 函数名: to_yurex_dev\n- 参数: [struct kref *kref]\n- 调用者: yurex_delete\n- 被调用者: []\n\n3. 函数名: dev_dbg\n- 参数: [&dev->interface->dev, \"%s\\n\", __func__]\n- 调用者: yurex_delete\n- 被调用者: []\n\n4. 函数名: usb_put_dev\n- 参数: [dev->udev]\n- 调用者: yurex_delete\n- 被调用者: []\n\n5. 函数名: usb_kill_urb\n- 参数: [dev->cntl_urb], [dev->urb]\n- 调用者: yurex_delete\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [dev->cntl_req], [dev]\n- 调用者: yurex_delete\n- 被调用者: []\n\n7. 函数名: usb_free_coherent\n- 参数: [dev->udev, YUREX_BUF_SIZE, dev->cntl_buffer, dev->cntl_urb->transfer_dma], [dev->udev, YUREX_BUF_SIZE, dev->int_buffer, dev->urb->transfer_dma]\n- 调用者: yurex_delete\n- 被调用者: []\n\n8. 函数名: usb_free_urb\n- 参数: [dev->cntl_urb], [dev->urb]\n- 调用者: yurex_delete\n- 被调用者: []"
    },
    {
        "id": 2221,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19543",
        "purpose": "Code purpose:\"\"\"初始化串口红外设备模块，设置相关硬件参数并进行初始化操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在serial_ir_init_module()函数中存在初始化失败后未正确清理资源的情况，导致后续可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: serial_ir_init_module\n- 参数: [void]\n- 调用者: module initialization\n- 被调用者: [serial_ir_init, serial_ir_exit]\n\n2. 函数名: serial_ir_init\n- 参数: []\n- 调用者: serial_ir_init_module\n- 被调用者: []\n\n3. 函数名: serial_ir_exit\n- 参数: []\n- 调用者: serial_ir_init_module\n- 被调用者: []"
    },
    {
        "id": 2223,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19767",
        "purpose": "Code purpose:\"\"\"扩展ext4文件系统中inode结构的额外空间大小，处理可能存在的扩展属性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在扩展inode额外大小时未正确处理内存释放导致use-after-free错误\"\"\"",
        "functions": "Functions:\n1. 函数名: __ext4_expand_extra_isize\n- 参数: [inode, new_extra_isize, iloc, handle, no_expand]\n- 调用者: 未明确显示（应为内核其他部分调用）\n- 被调用者: [ext4_raw_inode, IHDR, ext4_test_inode_state, cpu_to_le32, memset, ext4_expand_extra_isize_ea]\n\n2. 函数名: ext4_raw_inode\n- 参数: [iloc]\n- 调用者: __ext4_expand_extra_isize\n- 被调用者: []\n\n3. 函数名: IHDR\n- 参数: [inode, raw_inode]\n- 调用者: __ext4_expand_extra_isize\n- 被调用者: []\n\n4. 函数名: ext4_test_inode_state\n- 参数: [inode, EXT4_STATE_XATTR]\n- 调用者: __ext4_expand_extra_isize\n- 被调用者: []\n\n5. 函数名: cpu_to_le32\n- 参数: [EXT4_XATTR_MAGIC]\n- 调用者: __ext4_expand_extra_isize\n- 被调用者: []\n\n6. 函数名: memset\n- 参数: [(void *)raw_inode + EXT4_GOOD_OLD_INODE_SIZE + EXT4_I(inode)->i_extra_isize, 0, new_extra_isize - EXT4_I(inode)->i_extra_isize]\n- 调用者: __ext4_expand_extra_isize\n- 被调用者: []\n\n7. 函数名: ext4_expand_extra_isize_ea\n- 参数: [inode, new_extra_isize, raw_inode, handle]\n- 调用者: __ext4_expand_extra_isize\n- 被调用者: []"
    },
    {
        "id": 2224,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19767",
        "purpose": "Code purpose:\"\"\"该代码用于在ext4文件系统中动态调整inode结构体额外空间的大小，确保其满足最小要求且不超过inode总大小限制\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理ext4文件系统扩展inode额外空间时，由于不当的内存管理导致use-after-free错误\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_clamp_want_extra_isize\n- 参数: [struct super_block *sb]\n- 调用者: 未明确显示（可能是内核其他模块调用）\n- 被调用者: [le16_to_cpu, ext4_has_feature_extra_isize, ext4_msg]\n\n2. 函数名: le16_to_cpu\n- 参数: [未明确显示，但接收一个16位值]\n- 调用者: ext4_clamp_want_extra_isize\n- 被调用者: []\n\n3. 函数名: ext4_has_feature_extra_isize\n- 参数: [struct super_block *sb]\n- 调用者: ext4_clamp_want_extra_isize\n- 被调用者: []\n\n4. 函数名: ext4_msg\n- 参数: [struct super_block *sb, KERN_INFO, \"required extra inode space not available\"]\n- 调用者: ext4_clamp_want_extra_isize\n- 被调用者: []"
    },
    {
        "id": 2225,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19768",
        "purpose": "Code purpose:\"\"\"检查请求队列是否启用了块跟踪消息功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在__blk_add_trace函数中，由于未正确处理blk_trace结构体的引用计数，导致在读取bt->act_mask时可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: blk_trace_note_message_enabled\n- 参数: [struct request_queue *q]\n- 调用者: 未明确显示（可能是内核中调用blktrace相关功能的代码）\n- 被调用者: [likely]\n\n2. 函数名: likely\n- 参数: [条件表达式]\n- 调用者: blk_trace_note_message_enabled\n- 被调用者: []"
    },
    {
        "id": 2226,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19768",
        "purpose": "Code purpose:\"\"\"该代码用于在块设备请求处理过程中添加跟踪记录，以便进行I/O操作的性能分析和调试\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在__blk_add_trace函数中，由于对已释放的blk_trace结构体bt进行了读取操作，导致了use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: blk_add_trace_rq\n- 参数: [struct request *rq, int error, unsigned int nr_bytes, u32 what, u64 cgid]\n- 调用者: 未明确显示（通常由块设备I/O跟踪相关代码调用）\n- 被调用者: [blk_rq_is_passthrough, __blk_add_trace, blk_rq_trace_sector, req_op]\n\n2. 函数名: blk_rq_is_passthrough\n- 参数: [struct request *rq]\n- 调用者: blk_add_trace_rq\n- 被调用者: []\n\n3. 函数名: __blk_add_trace\n- 参数: [struct blk_trace *bt, sector_t sector, unsigned int nr_bytes, int op, int cmd_flags, u32 what, int error, int pdu_len, void *pdu_data, u64 cgid]\n- 调用者: blk_add_trace_rq\n- 被调用者: []\n\n4. 函数名: blk_rq_trace_sector\n- 参数: [struct request *rq]\n- 调用者: blk_add_trace_rq\n- 被调用者: []\n\n5. 函数名: req_op\n- 参数: [struct request *rq]\n- 调用者: blk_add_trace_rq\n- 被调用者: []"
    },
    {
        "id": 2227,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19768",
        "purpose": "Code purpose:\"\"\"该代码片段用于移除请求队列中的块设备跟踪器并释放相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在blk_trace_remove_queue函数中，由于在释放bt指针后未将其置空，导致后续__blk_add_trace函数可能访问已释放的内存区域，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: blk_trace_remove_queue\n- 参数: [struct request_queue *q]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [xchg, put_probe_ref, blk_trace_free]\n\n2. 函数名: xchg\n- 参数: [&q->blk_trace, NULL]\n- 调用者: blk_trace_remove_queue\n- 被调用者: 未明确（可能是原子操作函数）\n\n3. 函数名: put_probe_ref\n- 参数: []\n- 调用者: blk_trace_remove_queue\n- 被调用者: 未明确\n\n4. 函数名: blk_trace_free\n- 参数: [bt]\n- 调用者: blk_trace_remove_queue\n- 被调用者: 未明确"
    },
    {
        "id": 2228,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19768",
        "purpose": "Code purpose:\"\"\"该代码用于在块设备请求队列中添加跟踪记录，处理bio请求或无bio时的跟踪信息记录\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在__blk_add_trace函数中存在对已释放内存的读取操作，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: blk_add_trace_getrq\n- 参数: [ignore, q, bio, rw]\n- 调用者: 未提供\n- 被调用者: [blk_add_trace_bio, __blk_add_trace]\n\n2. 函数名: blk_add_trace_bio\n- 参数: [q, bio, BLK_TA_GETRQ, 0]\n- 调用者: blk_add_trace_getrq\n- 被调用者: 未提供\n\n3. 函数名: __blk_add_trace\n- 参数: [bt, 0, 0, rw, 0, BLK_TA_GETRQ, 0, 0, NULL, 0]\n- 调用者: blk_add_trace_getrq\n- 被调用者: 未提供"
    },
    {
        "id": 2229,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19768",
        "purpose": "Code purpose:\"\"\"该代码用于在块设备请求队列中添加跟踪信息，记录bio操作的详细信息以便进行性能分析或调试\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在__blk_add_trace函数中，由于对已释放的bio结构体进行了读取操作，导致了use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: blk_add_trace_bio\n- 参数: [q, bio, what, error]\n- 调用者: 未显示\n- 被调用者: [__blk_add_trace, bio_op, blk_trace_bio_get_cgid]\n\n2. 函数名: __blk_add_trace\n- 参数: [bt, bio->bi_iter.bi_sector, bio->bi_iter.bi_size, bio_op(bio), bio->bi_opf, what, error, 0, NULL, blk_trace_bio_get_cgid(q, bio)]\n- 调用者: blk_add_trace_bio\n- 被调用者: 未显示\n\n3. 函数名: bio_op\n- 参数: [bio]\n- 调用者: blk_add_trace_bio\n- 被调用者: 未显示\n\n4. 函数名: blk_trace_bio_get_cgid\n- 参数: [q, bio]\n- 调用者: blk_add_trace_bio\n- 被调用者: 未显示"
    },
    {
        "id": 2230,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19768",
        "purpose": "Code purpose:\"\"\"该代码用于在块设备请求队列中添加驱动数据到跟踪缓冲区，以便进行I/O操作跟踪\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在__blk_add_trace函数中，由于对已释放的blk_trace结构体进行了读取操作，导致了use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: blk_add_driver_data\n- 参数: [struct request_queue *q, struct request *rq, void *data, size_t len]\n- 调用者: 未显示\n- 被调用者: [__blk_add_trace, blk_rq_trace_sector, blk_rq_bytes, blk_trace_request_get_cgid]\n\n2. 函数名: __blk_add_trace\n- 参数: [struct blk_trace *bt, blk_rq_trace_sector(rq), blk_rq_bytes(rq), 0, 0, BLK_TA_DRV_DATA, 0, len, data, blk_trace_request_get_cgid(q, rq)]\n- 调用者: blk_add_driver_data\n- 被调用者: 未显示\n\n3. 函数名: blk_rq_trace_sector\n- 参数: [struct request *rq]\n- 调用者: blk_add_driver_data\n- 被调用者: 未显示\n\n4. 函数名: blk_rq_bytes\n- 参数: [struct request *rq]\n- 调用者: blk_add_driver_data\n- 被调用者: 未显示\n\n5. 函数名: blk_trace_request_get_cgid\n- 参数: [struct request_queue *q, struct request *rq]\n- 调用者: blk_add_driver_data\n- 被调用者: 未显示"
    },
    {
        "id": 2231,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19768",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中通过sysfs接口展示块设备跟踪(blktrace)的相关属性信息，包括启用状态、动作掩码、进程ID、起始和结束逻辑块地址等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放bdev后仍可能通过q指针访问其成员，导致释放后使用(UAF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: sysfs_blk_trace_attr_show\n- 参数: [struct device *dev, struct device_attribute *attr, char *buf]\n- 调用者: 未显示（通常由sysfs子系统调用）\n- 被调用者: [dev_to_part, bdget, blk_trace_get_queue, mutex_lock, sprintf, blk_trace_mask2str, mutex_unlock, bdput]\n\n2. 函数名: dev_to_part\n- 参数: [struct device *dev]\n- 调用者: sysfs_blk_trace_attr_show\n- 被调用者: 未显示\n\n3. 函数名: bdget\n- 参数: [dev_t dev]\n- 调用者: sysfs_blk_trace_attr_show\n- 被调用者: 未显示\n\n4. 函数名: blk_trace_get_queue\n- 参数: [struct block_device *bdev]\n- 调用者: sysfs_blk_trace_attr_show\n- 被调用者: 未显示\n\n5. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: sysfs_blk_trace_attr_show\n- 被调用者: 未显示\n\n6. 函数名: sprintf\n- 参数: [char *buf, const char *format, ...]\n- 调用者: sysfs_blk_trace_attr_show\n- 被调用者: 未显示\n\n7. 函数名: blk_trace_mask2str\n- 参数: [char *buf, u32 mask]\n- 调用者: sysfs_blk_trace_attr_show\n- 被调用者: 未显示\n\n8. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: sysfs_blk_trace_attr_show\n- 被调用者: 未显示\n\n9. 函数名: bdput\n- 参数: [struct block_device *bdev]\n- 调用者: sysfs_blk_trace_attr_show\n- 被调用者: 未显示"
    },
    {
        "id": 2232,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19768",
        "purpose": "Code purpose:\"\"\"清理块设备跟踪结构并释放相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在blk_trace_cleanup函数中，先释放了bt结构体再调用put_probe_ref，可能导致后续操作中访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: blk_trace_cleanup\n- 参数: [struct blk_trace *bt]\n- 调用者: 未显示\n- 被调用者: [blk_trace_free, put_probe_ref]\n\n2. 函数名: blk_trace_free\n- 参数: [struct blk_trace *bt]\n- 调用者: blk_trace_cleanup\n- 被调用者: 未显示\n\n3. 函数名: put_probe_ref\n- 参数: []\n- 调用者: blk_trace_cleanup\n- 被调用者: 未显示"
    },
    {
        "id": 2233,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19768",
        "purpose": "Code purpose:\"\"\"该代码用于在块设备跟踪系统中记录bio请求被分割的事件信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在__blk_add_trace函数中处理blk_trace结构体时存在释放后使用漏洞，当请求队列q的blk_trace被释放后仍被访问导致UAF读。\"\"\"",
        "functions": "Functions:\n1. 函数名: blk_add_trace_split\n- 参数: [ignore, q, bio, pdu]\n- 调用者: 未明确显示（通常由块设备层调用）\n- 被调用者: [cpu_to_be64, __blk_add_trace, bio_op, blk_trace_bio_get_cgid]\n\n2. 函数名: cpu_to_be64\n- 参数: [pdu]\n- 调用者: blk_add_trace_split\n- 被调用者: []\n\n3. 函数名: __blk_add_trace\n- 参数: [bt, bio->bi_iter.bi_sector, bio->bi_iter.bi_size, bio_op(bio), bio->bi_opf, BLK_TA_SPLIT, bio->bi_status, sizeof(rpdu), &rpdu, blk_trace_bio_get_cgid(q, bio)]\n- 调用者: blk_add_trace_split\n- 被调用者: []\n\n4. 函数名: bio_op\n- 参数: [bio]\n- 调用者: blk_add_trace_split\n- 被调用者: []\n\n5. 函数名: blk_trace_bio_get_cgid\n- 参数: [q, bio]\n- 调用者: blk_add_trace_split\n- 被调用者: []"
    },
    {
        "id": 2234,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19768",
        "purpose": "Code purpose:\"\"\"该代码用于在块设备I/O操作重映射时添加跟踪记录，将重映射相关信息填充到跟踪结构中以便后续分析\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在__blk_add_trace函数中，由于对bio结构体的引用没有适当的同步保护，可能导致在bio被释放后仍然被访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: blk_add_trace_bio_remap\n- 参数: [ignore, q, bio, dev, from]\n- 调用者: 未显示\n- 被调用者: [cpu_to_be32, bio_dev, cpu_to_be64, __blk_add_trace, blk_trace_bio_get_cgid]\n\n2. 函数名: cpu_to_be32\n- 参数: [dev]\n- 调用者: blk_add_trace_bio_remap\n- 被调用者: []\n\n3. 函数名: bio_dev\n- 参数: [bio]\n- 调用者: blk_add_trace_bio_remap\n- 被调用者: []\n\n4. 函数名: cpu_to_be64\n- 参数: [from]\n- 调用者: blk_add_trace_bio_remap\n- 被调用者: []\n\n5. 函数名: __blk_add_trace\n- 参数: [bt, bio->bi_iter.bi_sector, bio->bi_iter.bi_size, bio_op(bio), bio->bi_opf, BLK_TA_REMAP, bio->bi_status, sizeof(r), &r, blk_trace_bio_get_cgid(q, bio)]\n- 调用者: blk_add_trace_bio_remap\n- 被调用者: []\n\n6. 函数名: blk_trace_bio_get_cgid\n- 参数: [q, bio]\n- 调用者: blk_add_trace_bio_remap\n- 被调用者: []\n\n7. 函数名: bio_op\n- 参数: [bio]\n- 调用者: __blk_add_trace (通过参数传递)\n- 被调用者: []"
    },
    {
        "id": 2235,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19768",
        "purpose": "Code purpose:\"\"\"该代码用于在块设备请求队列取消阻塞时添加跟踪记录，记录取消阻塞的类型和深度信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在__blk_add_trace函数中处理blk_trace结构体时存在释放后使用(UAF)问题，导致可以读取已释放的内存。\"\"\"",
        "functions": "Functions:\n1. 函数名: blk_add_trace_unplug\n- 参数: [ignore, q, depth, explicit]\n- 调用者: 未明确显示（由内核其他部分调用）\n- 被调用者: [cpu_to_be64, __blk_add_trace]\n\n2. 函数名: cpu_to_be64\n- 参数: [depth]\n- 调用者: blk_add_trace_unplug\n- 被调用者: []\n\n3. 函数名: __blk_add_trace\n- 参数: [bt, 0, 0, 0, 0, what, 0, sizeof(rpdu), &rpdu, 0]\n- 调用者: blk_add_trace_unplug\n- 被调用者: []"
    },
    {
        "id": 2236,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19768",
        "purpose": "Code purpose:\"\"\"该代码片段用于安全关闭块设备跟踪功能，通过互斥锁保护操作，停止跟踪并移除相关跟踪资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放q->blk_trace资源后未正确清理或保护，导致后续可能发生对已释放内存的访问\"\"\"",
        "functions": "Functions:\n1. 函数名: blk_trace_shutdown\n- 参数: [struct request_queue *q]\n- 调用者: 不适用\n- 被调用者: [mutex_lock, __blk_trace_startstop, __blk_trace_remove, mutex_unlock]\n\n2. 函数名: mutex_lock\n- 参数: [&q->blk_trace_mutex]\n- 调用者: blk_trace_shutdown\n- 被调用者: 不适用\n\n3. 函数名: __blk_trace_startstop\n- 参数: [q, 0]\n- 调用者: blk_trace_shutdown\n- 被调用者: 不适用\n\n4. 函数名: __blk_trace_remove\n- 参数: [q]\n- 调用者: blk_trace_shutdown\n- 被调用者: 不适用\n\n5. 函数名: mutex_unlock\n- 参数: [&q->blk_trace_mutex]\n- 调用者: blk_trace_shutdown\n- 被调用者: 不适用"
    },
    {
        "id": 2237,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19768",
        "purpose": "Code purpose:\"\"\"该代码用于在块设备请求重映射时添加追踪记录，将重映射信息填充到跟踪结构中以便后续分析\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在__blk_add_trace函数中，由于对已释放的blk_trace结构体进行了读取操作，导致了use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: blk_add_trace_rq_remap\n- 参数: [ignore, q, rq, dev, from]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [cpu_to_be32, disk_devt, cpu_to_be64, __blk_add_trace, blk_rq_pos, blk_rq_bytes, rq_data_dir, blk_trace_request_get_cgid]\n\n2. 函数名: cpu_to_be32\n- 参数: [dev]\n- 调用者: blk_add_trace_rq_remap\n- 被调用者: []\n\n3. 函数名: disk_devt\n- 参数: [rq->rq_disk]\n- 调用者: blk_add_trace_rq_remap\n- 被调用者: []\n\n4. 函数名: cpu_to_be64\n- 参数: [from]\n- 调用者: blk_add_trace_rq_remap\n- 被调用者: []\n\n5. 函数名: __blk_add_trace\n- 参数: [bt, blk_rq_pos(rq), blk_rq_bytes(rq), rq_data_dir(rq), 0, BLK_TA_REMAP, 0, sizeof(r), &r, blk_trace_request_get_cgid(q, rq)]\n- 调用者: blk_add_trace_rq_remap\n- 被调用者: []\n\n6. 函数名: blk_rq_pos\n- 参数: [rq]\n- 调用者: blk_add_trace_rq_remap\n- 被调用者: []\n\n7. 函数名: blk_rq_bytes\n- 参数: [rq]\n- 调用者: blk_add_trace_rq_remap\n- 被调用者: []\n\n8. 函数名: rq_data_dir\n- 参数: [rq]\n- 调用者: blk_add_trace_rq_remap\n- 被调用者: []\n\n9. 函数名: blk_trace_request_get_cgid\n- 参数: [q, rq]\n- 调用者: blk_add_trace_rq_remap\n- 被调用者: []"
    },
    {
        "id": 2238,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19768",
        "purpose": "Code purpose:\"\"\"该代码用于处理块设备跟踪属性的存储操作，包括设置跟踪掩码、PID、起始和结束LBA等参数，并管理跟踪队列的创建和移除。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在__blk_add_trace函数中处理blk_io_trace结构时存在释放后使用(UAF)问题，导致可以读取已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: sysfs_blk_trace_attr_store\n- 参数: [struct device *dev, struct device_attribute *attr, const char *buf, size_t count]\n- 调用者: 未显示（由sysfs调用）\n- 被调用者: [kstrtoull, blk_trace_str2mask, dev_to_part, bdget, blk_trace_get_queue, mutex_lock, blk_trace_setup_queue, blk_trace_remove_queue, mutex_unlock, bdput]\n\n2. 函数名: kstrtoull\n- 参数: [const char *buf, 0, u64 *value]\n- 调用者: sysfs_blk_trace_attr_store\n- 被调用者: 未显示\n\n3. 函数名: blk_trace_str2mask\n- 参数: [const char *buf]\n- 调用者: sysfs_blk_trace_attr_store\n- 被调用者: 未显示\n\n4. 函数名: dev_to_part\n- 参数: [struct device *dev]\n- 调用者: sysfs_blk_trace_attr_store\n- 被调用者: 未显示\n\n5. 函数名: bdget\n- 参数: [dev_t devt]\n- 调用者: sysfs_blk_trace_attr_store\n- 被调用者: 未显示\n\n6. 函数名: blk_trace_get_queue\n- 参数: [struct block_device *bdev]\n- 调用者: sysfs_blk_trace_attr_store\n- 被调用者: 未显示\n\n7. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: sysfs_blk_trace_attr_store\n- 被调用者: 未显示\n\n8. 函数名: blk_trace_setup_queue\n- 参数: [struct request_queue *q, struct block_device *bdev]\n- 调用者: sysfs_blk_trace_attr_store\n- 被调用者: 未显示\n\n9. 函数名: blk_trace_remove_queue\n- 参数: [struct request_queue *q]\n- 调用者: sysfs_blk_trace_attr_store\n- 被调用者: 未显示\n\n10. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: sysfs_blk_trace_attr_store\n- 被调用者: 未显示\n\n11. 函数名: bdput\n- 参数: [struct block_device *bdev]\n- 调用者: sysfs_blk_trace_attr_store\n- 被调用者: 未显示"
    },
    {
        "id": 2239,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19768",
        "purpose": "Code purpose:\"\"\"该代码片段用于在请求队列有块跟踪时，添加一个表示plug事件的跟踪记录\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在blk_add_trace_plug函数中，由于未对bt指针进行有效的引用计数或锁定保护，可能导致在__blk_add_trace调用时bt指向的内存已被释放，从而引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: blk_add_trace_plug\n- 参数: [ignore, q]\n- 调用者: 未指定\n- 被调用者: [__blk_add_trace]\n\n2. 函数名: __blk_add_trace\n- 参数: [bt, 0, 0, 0, 0, BLK_TA_PLUG, 0, 0, NULL, 0]\n- 调用者: blk_add_trace_plug\n- 被调用者: 未指定"
    },
    {
        "id": 2240,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19768",
        "purpose": "Code purpose:\"\"\"该代码用于控制块设备跟踪的启动和停止操作，管理跟踪状态并在运行列表中添加或删除跟踪项。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在__blk_trace_startstop函数中，由于对blk_trace结构体的状态管理不当，可能导致在释放后仍被访问，造成use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: __blk_trace_startstop\n- 参数: [struct request_queue *q, int start]\n- 调用者: 未明确显示（通常由blktrace相关函数调用）\n- 被调用者: [smp_mb, spin_lock_irq, spin_unlock_irq, list_add, list_del_init, relay_flush, trace_note_time]\n\n2. 函数名: smp_mb\n- 参数: []\n- 调用者: __blk_trace_startstop\n- 被调用者: []\n\n3. 函数名: spin_lock_irq\n- 参数: [&running_trace_lock]\n- 调用者: __blk_trace_startstop\n- 被调用者: []\n\n4. 函数名: spin_unlock_irq\n- 参数: [&running_trace_lock]\n- 调用者: __blk_trace_startstop\n- 被调用者: []\n\n5. 函数名: list_add\n- 参数: [&bt->running_list, &running_trace_list]\n- 调用者: __blk_trace_startstop\n- 被调用者: []\n\n6. 函数名: list_del_init\n- 参数: [&bt->running_list]\n- 调用者: __blk_trace_startstop\n- 被调用者: []\n\n7. 函数名: relay_flush\n- 参数: [bt->rchan]\n- 调用者: __blk_trace_startstop\n- 被调用者: []\n\n8. 函数名: trace_note_time\n- 参数: [bt]\n- 调用者: __blk_trace_startstop\n- 被调用者: []"
    },
    {
        "id": 2241,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19768",
        "purpose": "Code purpose:\"\"\"该代码片段用于在Linux内核中跟踪块设备I/O请求的休眠状态，将休眠请求的相关信息记录到跟踪缓冲区中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在__blk_add_trace函数中存在对已释放内存的读取操作，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: blk_add_trace_sleeprq\n- 参数: [ignore, q, bio, rw]\n- 调用者: 未明确（由内核调用）\n- 被调用者: [blk_add_trace_bio, __blk_add_trace]\n\n2. 函数名: blk_add_trace_bio\n- 参数: [q, bio, BLK_TA_SLEEPRQ, 0]\n- 调用者: blk_add_trace_sleeprq\n- 被调用者: []\n\n3. 函数名: __blk_add_trace\n- 参数: [bt, 0, 0, rw, 0, BLK_TA_SLEEPRQ, 0, 0, NULL, 0]\n- 调用者: blk_add_trace_sleeprq\n- 被调用者: []"
    },
    {
        "id": 2242,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19769",
        "purpose": "Code purpose:\"\"\"该代码用于删除文件锁的阻塞请求，处理锁的释放和唤醒被阻塞的请求\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放锁后未正确处理waiter对象的访问，导致可能读取已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: locks_delete_block\n- 参数: [struct file_lock *waiter]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [__locks_wake_up_blocks, __locks_delete_block]\n\n2. 函数名: __locks_wake_up_blocks\n- 参数: [struct file_lock *waiter]\n- 调用者: locks_delete_block\n- 被调用者: 未明确（上下文未提供）\n\n3. 函数名: __locks_delete_block\n- 参数: [struct file_lock *waiter]\n- 调用者: locks_delete_block\n- 被调用者: 未明确（上下文未提供）"
    },
    {
        "id": 2243,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19770",
        "purpose": "Code purpose:\"\"\"该代码用于设置块设备跟踪(blktrace)，包括创建调试文件系统(debugfs)目录和文件，配置跟踪参数，并管理跟踪状态。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在blktrace中错误地使用debugfs导致在删除debugfs文件或目录时出现use-after-free读取漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: do_blk_trace_setup\n- 参数: [struct request_queue *q, char *name, dev_t dev, struct block_device *bdev, struct blk_user_trace_setup *buts]\n- 调用者: 未显示\n- 被调用者: [lockdep_assert_held, strncpy, strreplace, rcu_dereference_protected, pr_warn, kzalloc, alloc_percpu, __alloc_percpu, debugfs_lookup, debugfs_create_dir, debugfs_create_file, relay_open, blk_trace_setup_lba, rcu_assign_pointer, get_probe_ref, dput, blk_trace_free]\n\n2. 函数名: lockdep_assert_held\n- 参数: [&q->blk_trace_mutex]\n- 调用者: do_blk_trace_setup\n- 被调用者: []\n\n3. 函数名: strncpy\n- 参数: [buts->name, name, BLKTRACE_BDEV_SIZE]\n- 调用者: do_blk_trace_setup\n- 被调用者: []\n\n4. 函数名: strreplace\n- 参数: [buts->name, '/', '_']\n- 调用者: do_blk_trace_setup\n- 被调用者: []\n\n5. 函数名: rcu_dereference_protected\n- 参数: [q->blk_trace, lockdep_is_held(&q->blk_trace_mutex)]\n- 调用者: do_blk_trace_setup\n- 被调用者: []\n\n6. 函数名: pr_warn\n- 参数: [\"Concurrent blktraces are not allowed on %s\\n\", buts->name]\n- 调用者: do_blk_trace_setup\n- 被调用者: []\n\n7. 函数名: kzalloc\n- 参数: [sizeof(*bt), GFP_KERNEL]\n- 调用者: do_blk_trace_setup\n- 被调用者: []\n\n8. 函数名: alloc_percpu\n- 参数: [unsigned long]\n- 调用者: do_blk_trace_setup\n- 被调用者: []\n\n9. 函数名: __alloc_percpu\n- 参数: [BLK_TN_MAX_MSG, __alignof__(char)]\n- 调用者: do_blk_trace_setup\n- 被调用者: []\n\n10. 函数名: debugfs_lookup\n- 参数: [buts->name, blk_debugfs_root]\n- 调用者: do_blk_trace_setup\n- 被调用者: []\n\n11. 函数名: debugfs_create_dir\n- 参数: [buts->name, blk_debugfs_root]\n- 调用者: do_blk_trace_setup\n- 被调用者: []\n\n12. 函数名: debugfs_create_file\n- 参数: [\"dropped\", 0444, dir, bt, &blk_dropped_fops]\n- 调用者: do_blk_trace_setup\n- 被调用者: []\n\n13. 函数名: debugfs_create_file\n- 参数: [\"msg\", 0222, dir, bt, &blk_msg_fops]\n- 调用者: do_blk_trace_setup\n- 被调用者: []\n\n14. 函数名: relay_open\n- 参数: [\"trace\", dir, buts->buf_size, buts->buf_nr, &blk_relay_callbacks, bt]\n- 调用者: do_blk_trace_setup\n- 被调用者: []\n\n15. 函数名: blk_trace_setup_lba\n- 参数: [bt, bdev]\n- 调用者: do_blk_trace_setup\n- 被调用者: []\n\n16. 函数名: rcu_assign_pointer\n- 参数: [q->blk_trace, bt]\n- 调用者: do_blk_trace_setup\n- 被调用者: []\n\n17. 函数名: get_probe_ref\n- 参数: []\n- 调用者: do_blk_trace_setup\n- 被调用者: []\n\n18. 函数名: dput\n- 参数: [dir]\n- 调用者: do_blk_trace_setup\n- 被调用者: []\n\n19. 函数名: blk_trace_free\n- 参数: [bt]\n- 调用者: do_blk_trace_setup\n- 被调用者: []"
    },
    {
        "id": 2244,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19807",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中声音定时器的打开功能，包括主从定时器实例的创建和管理，并处理相关的资源分配和同步问题。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码重构后timeri变量被错误地用于不同目的，导致在snd_timer_open和snd_timer_close_locked之间存在释放后使用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_timer_open\n- 参数: [struct snd_timer_instance **ti, char *owner, struct snd_timer_id *tid, unsigned int slave_id]\n- 调用者: N/A (kernel-level function)\n- 被调用者: [snd_timer_instance_new, snd_timer_check_slave, snd_timer_close_locked, snd_timer_find, list_entry, get_device, put_device, mutex_lock, mutex_unlock, pr_debug, kfree, module_put]\n\n2. 函数名: snd_timer_instance_new\n- 参数: [char *owner, struct snd_timer *timer]\n- 调用者: snd_timer_open\n- 被调用者: N/A\n\n3. 函数名: snd_timer_check_slave\n- 参数: [struct snd_timer_instance *timeri]\n- 调用者: snd_timer_open\n- 被调用者: N/A\n\n4. 函数名: snd_timer_close_locked\n- 参数: [struct snd_timer_instance *timeri, struct device **card_dev_to_put]\n- 调用者: snd_timer_open\n- 被调用者: N/A\n\n5. 函数名: snd_timer_find\n- 参数: [struct snd_timer_id *tid]\n- 调用者: snd_timer_open\n- 被调用者: N/A\n\n6. 函数名: snd_timer_request\n- 参数: [struct snd_timer_id *tid]\n- 调用者: snd_timer_open\n- 被调用者: N/A\n\n7. 函数名: snd_timer_check_master\n- 参数: [struct snd_timer_instance *timeri]\n- 调用者: snd_timer_open\n- 被调用者: N/A\n\n8. 函数名: list_entry\n- 参数: [struct list_head *ptr, type, member]\n- 调用者: snd_timer_open\n- 被调用者: N/A\n\n9. 函数名: get_device\n- 参数: [struct device *dev]\n- 调用者: snd_timer_open\n- 被调用者: N/A\n\n10. 函数名: put_device\n- 参数: [struct device *dev]\n- 调用者: snd_timer_open\n- 被调用者: N/A\n\n11. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: snd_timer_open\n- 被调用者: N/A\n\n12. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: snd_timer_open\n- 被调用者: N/A\n\n13. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: snd_timer_open\n- 被调用者: N/A\n\n14. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: snd_timer_open\n- 被调用者: N/A\n\n15. 函数名: module_put\n- 参数: [struct module *module]\n- 调用者: snd_timer_open\n- 被调用者: N/A"
    },
    {
        "id": 2245,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19813",
        "purpose": "Code purpose:\"\"\"该代码用于在btrfs文件系统中查找并返回与给定目录项(dentry)对应的inode，处理子卷和孤儿文件清理等特殊情况\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在btrfs文件系统中，由于未正确处理inode引用计数和同步操作，导致在syncfs系统调用时可能发生释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: btrfs_lookup_dentry\n- 参数: [dir, dentry]\n- 调用者: N/A (top-level function)\n- 被调用者: [btrfs_sb, BTRFS_I, ERR_PTR, btrfs_inode_by_name, btrfs_iget, srcu_read_lock, fixup_tree_root_location, new_simple_dir, srcu_read_unlock, IS_ERR, down_read, sb_rdonly, btrfs_orphan_cleanup, up_read, iput]\n\n2. 函数名: btrfs_sb\n- 参数: [dir->i_sb]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n3. 函数名: BTRFS_I\n- 参数: [dir]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n4. 函数名: ERR_PTR\n- 参数: [-ENAMETOOLONG, ret]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n5. 函数名: btrfs_inode_by_name\n- 参数: [dir, dentry, &location]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n6. 函数名: btrfs_iget\n- 参数: [dir->i_sb, &location, root, NULL], [dir->i_sb, &location, sub_root, NULL]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n7. 函数名: srcu_read_lock\n- 参数: [&fs_info->subvol_srcu]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n8. 函数名: fixup_tree_root_location\n- 参数: [fs_info, dir, dentry, &location, &sub_root]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n9. 函数名: new_simple_dir\n- 参数: [dir->i_sb, &location, sub_root]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n10. 函数名: srcu_read_unlock\n- 参数: [&fs_info->subvol_srcu, index]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n11. 函数名: IS_ERR\n- 参数: [inode]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n12. 函数名: down_read\n- 参数: [&fs_info->cleanup_work_sem]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n13. 函数名: sb_rdonly\n- 参数: [inode->i_sb]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n14. 函数名: btrfs_orphan_cleanup\n- 参数: [sub_root]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n15. 函数名: up_read\n- 参数: [&fs_info->cleanup_work_sem]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n16. 函数名: iput\n- 参数: [inode]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []"
    },
    {
        "id": 2246,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19813",
        "purpose": "Code purpose:\"\"\"该代码用于在btrfs文件系统中获取指定范围的extent映射信息，处理常规、预分配和内联三种类型的extent数据，并管理相关的内存和锁操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在btrfs文件系统中处理extent映射时存在释放后使用(UAF)问题，由于未正确处理extent_map对象的生命周期导致同步操作时可能访问已释放的内存。\"\"\"",
        "functions": "Functions:\n1. 函数名: btrfs_get_extent\n- 参数: [struct btrfs_inode *inode, struct page *page, size_t pg_offset, u64 start, u64 len, int create]\n- 调用者: N/A (top-level function)\n- 被调用者: [lookup_extent_mapping, free_extent_map, alloc_extent_map, btrfs_alloc_path, btrfs_lookup_file_extent, btrfs_item_ptr, btrfs_item_key_to_cpu, btrfs_file_extent_type, btrfs_file_extent_num_bytes, trace_btrfs_get_extent_show_fi_regular, btrfs_file_extent_ram_bytes, ALIGN, trace_btrfs_get_extent_show_fi_inline, btrfs_next_leaf, btrfs_extent_item_to_extent_map, btrfs_file_extent_compression, uncompress_inline, kmap, read_extent_buffer, kunmap, flush_dcache_page, set_extent_uptodate, extent_map_end, btrfs_release_path, btrfs_err, btrfs_add_extent_mapping, btrfs_free_path, trace_btrfs_get_extent, free_extent_map]\n\n2. 函数名: lookup_extent_mapping\n- 参数: [struct extent_map_tree *em_tree, u64 start, u64 len]\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n3. 函数名: free_extent_map\n- 参数: [struct extent_map *em]\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n4. 函数名: alloc_extent_map\n- 参数: []\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n5. 函数名: btrfs_alloc_path\n- 参数: []\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n6. 函数名: btrfs_lookup_file_extent\n- 参数: [NULL, struct btrfs_root *root, struct btrfs_path *path, u64 objectid, u64 start, 0]\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n7. 函数名: btrfs_item_ptr\n- 参数: [struct extent_buffer *leaf, int slot, struct btrfs_file_extent_item]\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n8. 函数名: btrfs_item_key_to_cpu\n- 参数: [struct extent_buffer *leaf, struct btrfs_key *key, int slot]\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n9. 函数名: btrfs_file_extent_type\n- 参数: [struct extent_buffer *leaf, struct btrfs_file_extent_item *item]\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n10. 函数名: btrfs_file_extent_num_bytes\n- 参数: [struct extent_buffer *leaf, struct btrfs_file_extent_item *item]\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n11. 函数名: btrfs_file_extent_ram_bytes\n- 参数: [struct extent_buffer *leaf, struct btrfs_file_extent_item *item]\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n12. 函数名: ALIGN\n- 参数: [u64 value, u64 alignment]\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n13. 函数名: btrfs_next_leaf\n- 参数: [struct btrfs_root *root, struct btrfs_path *path]\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n14. 函数名: btrfs_extent_item_to_extent_map\n- 参数: [struct btrfs_inode *inode, struct btrfs_path *path, struct btrfs_file_extent_item *item, bool new_inline, struct extent_map *em]\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n15. 函数名: btrfs_file_extent_compression\n- 参数: [struct extent_buffer *leaf, struct btrfs_file_extent_item *item]\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n16. 函数名: uncompress_inline\n- 参数: [struct btrfs_path *path, struct page *page, size_t pg_offset, size_t extent_offset, struct btrfs_file_extent_item *item]\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n17. 函数名: kmap\n- 参数: [struct page *page]\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n18. 函数名: read_extent_buffer\n- 参数: [struct extent_buffer *eb, void *dst, unsigned long src, unsigned long len]\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n19. 函数名: kunmap\n- 参数: [struct page *page]\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n20. 函数名: flush_dcache_page\n- 参数: [struct page *page]\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n21. 函数名: set_extent_uptodate\n- 参数: [struct extent_io_tree *tree, u64 start, u64 end, struct extent_state **cached, gfp_t mask]\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n22. 函数名: extent_map_end\n- 参数: [struct extent_map *em]\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n23. 函数名: btrfs_release_path\n- 参数: [struct btrfs_path *path]\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n24. 函数名: btrfs_err\n- 参数: [struct btrfs_fs_info *fs_info, const char *fmt, ...]\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n25. 函数名: btrfs_add_extent_mapping\n- 参数: [struct btrfs_fs_info *fs_info, struct extent_map_tree *em_tree, struct extent_map **em_inout, u64 start, u64 len]\n- 调用者: btrfs_get_extent\n- 被调用者: N/A\n\n26. 函数名: btrfs_free_path\n- 参数: [struct btrfs_path *path]\n- 调用者: btrfs_get_extent\n- 被调用者: N/A"
    },
    {
        "id": 2247,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19813",
        "purpose": "Code purpose:\"\"\"该代码片段是Linux内核中Btrfs文件系统的测试函数，用于测试btrfs_get_extent函数在不同场景下获取文件范围映射的正确性，包括普通范围、预分配范围、压缩范围和空洞范围等情况的处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核5.0.21中，挂载特制的btrfs文件系统镜像后执行某些操作并调用syncfs系统调用时，由于资源释放后仍被访问，导致__mutex_lock中出现释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: test_btrfs_get_extent\n- 参数: [u32 sectorsize, u32 nodesize]\n- 调用者: N/A\n- 被调用者: [btrfs_new_test_inode, test_std_err, btrfs_alloc_dummy_fs_info, btrfs_alloc_dummy_root, alloc_dummy_extent_buffer, btrfs_set_header_nritems, btrfs_set_header_level, btrfs_get_extent, free_extent_map, btrfs_drop_extent_cache, setup_file_extents, iput, btrfs_free_dummy_root, btrfs_free_dummy_fs_info]\n\n2. 函数名: btrfs_new_test_inode\n- 参数: []\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n3. 函数名: test_std_err\n- 参数: [TEST_ALLOC_INODE, TEST_ALLOC_FS_INFO, TEST_ALLOC_ROOT]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n4. 函数名: btrfs_alloc_dummy_fs_info\n- 参数: [nodesize, sectorsize]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n5. 函数名: btrfs_alloc_dummy_root\n- 参数: [fs_info]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n6. 函数名: alloc_dummy_extent_buffer\n- 参数: [fs_info, nodesize]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n7. 函数名: btrfs_set_header_nritems\n- 参数: [root->node, 0]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n8. 函数名: btrfs_set_header_level\n- 参数: [root->node, 0]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n9. 函数名: btrfs_get_extent\n- 参数: [BTRFS_I(inode), NULL, 0, offset, sectorsize, 0]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n10. 函数名: free_extent_map\n- 参数: [em]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n11. 函数名: btrfs_drop_extent_cache\n- 参数: [BTRFS_I(inode), 0, (u64)-1, 0]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n12. 函数名: setup_file_extents\n- 参数: [root, sectorsize]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n13. 函数名: iput\n- 参数: [inode]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n14. 函数名: btrfs_free_dummy_root\n- 参数: [root]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n15. 函数名: btrfs_free_dummy_fs_info\n- 参数: [fs_info]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n16. 函数名: test_err\n- 参数: [error messages]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n17. 函数名: test_msg\n- 参数: [\"running btrfs_get_extent tests\"]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []"
    },
    {
        "id": 2270,
        "cwe": "CWE-416",
        "cve": "CVE-2019-19966",
        "purpose": "Code purpose:\"\"\"初始化cpia2 USB摄像头驱动模块\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核5.1.6之前版本中，cpia2_exit()函数存在释放后使用(UAF)问题，导致拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: cpia2_init\n- 参数: [void]\n- 调用者: __init\n- 被调用者: [LOG, check_parameters, cpia2_usb_init]\n\n2. 函数名: LOG\n- 参数: [\"%s v%s\\n\", ABOUT, CPIA_VERSION]\n- 调用者: cpia2_init\n- 被调用者: []\n\n3. 函数名: check_parameters\n- 参数: []\n- 调用者: cpia2_init\n- 被调用者: []\n\n4. 函数名: cpia2_usb_init\n- 参数: []\n- 调用者: cpia2_init\n- 被调用者: []"
    },
    {
        "id": 2274,
        "cwe": "CWE-416",
        "cve": "CVE-2019-2024",
        "purpose": "Code purpose:\"\"\"该代码用于在em28xx设备上清理和释放DVB扩展相关的资源，包括断开I2C客户端连接、取消注册DVB模块并释放内存。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放dvb结构体后仍然可能通过dev->dvb引用已释放的内存，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: em28xx_dvb_fini\n- 参数: [struct em28xx *dev]\n- 调用者: 未明确（可能是外部调用）\n- 被调用者: [em28xx_uninit_usb_xfer, prevent_sleep, module_put, i2c_unregister_device, em28xx_unregister_dvb, kfree, kref_put]\n\n2. 函数名: em28xx_uninit_usb_xfer\n- 参数: [struct em28xx *dev, EM28XX_DIGITAL_MODE]\n- 调用者: em28xx_dvb_fini\n- 被调用者: []\n\n3. 函数名: prevent_sleep\n- 参数: [&dvb->fe[0]->ops, &dvb->fe[1]->ops]\n- 调用者: em28xx_dvb_fini\n- 被调用者: []\n\n4. 函数名: module_put\n- 参数: [client->dev.driver->owner]\n- 调用者: em28xx_dvb_fini\n- 被调用者: []\n\n5. 函数名: i2c_unregister_device\n- 参数: [client]\n- 调用者: em28xx_dvb_fini\n- 被调用者: []\n\n6. 函数名: em28xx_unregister_dvb\n- 参数: [dvb]\n- 调用者: em28xx_dvb_fini\n- 被调用者: []\n\n7. 函数名: kfree\n- 参数: [dvb]\n- 调用者: em28xx_dvb_fini\n- 被调用者: []\n\n8. 函数名: kref_put\n- 参数: [&dev->ref, em28xx_free_device]\n- 调用者: em28xx_dvb_fini\n- 被调用者: [em28xx_free_device]\n\n9. 函数名: em28xx_free_device\n- 参数: [未明确]\n- 调用者: kref_put\n- 被调用者: []"
    },
    {
        "id": 2275,
        "cwe": "CWE-416",
        "cve": "CVE-2019-2025",
        "purpose": "Code purpose:\"\"\"处理Android Binder驱动中的进程间通信事务，包括事务的创建、数据传输、错误处理以及资源管理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在binder_thread_read函数中，由于不恰当的锁机制导致可能发生释放后使用(use-after-free)的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_transaction\n- 参数: [proc, thread, tr, reply, extra_buffers_size]\n- 调用者: N/A (top-level function)\n- 被调用者: [binder_inner_proc_lock, binder_inner_proc_unlock, binder_user_error, binder_get_txn_from_and_acq_inner, binder_set_nice, binder_get_ref_olocked, binder_get_node_refs_for_txn, security_binder_transaction, list_first_entry_or_null, binder_select_thread_ilocked, atomic_inc_return, binder_transaction_log_add, kzalloc, INIT_LIST_HEAD, binder_stats_created, spin_lock_init, binder_debug, task_euid, task_nice, trace_binder_transaction, binder_alloc_new_buf, IS_ERR, PTR_ERR, copy_from_user, IS_ALIGNED, ALIGN, PTR_ALIGN, binder_validate_object, to_flat_binder_object, binder_translate_binder, binder_translate_handle, to_binder_fd_object, binder_translate_fd, to_binder_fd_array_object, binder_validate_ptr, binder_validate_fixup, binder_translate_fd_array, to_binder_buffer_object, binder_alloc_get_user_buffer_offset, binder_fixup_parent, binder_enqueue_thread_work, binder_pop_transaction_ilocked, binder_enqueue_thread_work_ilocked, wake_up_interruptible_sync, binder_free_transaction, binder_enqueue_deferred_thread_work_ilocked, binder_proc_transaction, binder_pop_transaction_ilocked, binder_thread_dec_tmpref, binder_proc_dec_tmpref, binder_dec_node_tmpref, smp_wmb, WRITE_ONCE, binder_dequeue_work, binder_free_txn_fixups, trace_binder_transaction_failed_buffer_release, binder_transaction_buffer_release, binder_alloc_free_buf, kfree, binder_stats_deleted, binder_dec_node, binder_send_failed_reply]\n\n2. 函数名: binder_inner_proc_lock\n- 参数: [proc]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n3. 函数名: binder_inner_proc_unlock\n- 参数: [proc]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n4. 函数名: binder_user_error\n- 参数: [format, ...]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n5. 函数名: binder_get_txn_from_and_acq_inner\n- 参数: [in_reply_to]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n6. 函数名: binder_set_nice\n- 参数: [saved_priority]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n7. 函数名: binder_get_ref_olocked\n- 参数: [proc, handle, strong]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n8. 函数名: binder_get_node_refs_for_txn\n- 参数: [node, target_proc, return_error]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n9. 函数名: security_binder_transaction\n- 参数: [tsk, target_tsk]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n10. 函数名: list_first_entry_or_null\n- 参数: [list, type, member]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n11. 函数名: binder_select_thread_ilocked\n- 参数: N/A (implied from context)\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n12. 函数名: atomic_inc_return\n- 参数: [binder_last_id]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n13. 函数名: binder_transaction_log_add\n- 参数: [binder_transaction_log]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n14. 函数名: kzalloc\n- 参数: [size, flags]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n15. 函数名: INIT_LIST_HEAD\n- 参数: [list]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n16. 函数名: binder_stats_created\n- 参数: [type]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n17. 函数名: spin_lock_init\n- 参数: [lock]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n18. 函数名: binder_debug\n- 参数: [level, format, ...]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n19. 函数名: task_euid\n- 参数: [tsk]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n20. 函数名: task_nice\n- 参数: [current]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n21. 函数名: trace_binder_transaction\n- 参数: [reply, t, target_node]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n22. 函数名: binder_alloc_new_buf\n- 参数: [alloc, data_size, offsets_size, extra_buffers_size, is_async]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n23. 函数名: IS_ERR\n- 参数: [ptr]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n24. 函数名: PTR_ERR\n- 参数: [ptr]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n25. 函数名: copy_from_user\n- 参数: [to, from, n]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n26. 函数名: IS_ALIGNED\n- 参数: [value, align]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n27. 函数名: ALIGN\n- 参数: [value, align]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n28. 函数名: PTR_ALIGN\n- 参数: [ptr, align]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n29. 函数名: binder_validate_object\n- 参数: [buffer, offset]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n30. 函数名: to_flat_binder_object\n- 参数: [hdr]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n31. 函数名: binder_translate_binder\n- 参数: [fp, t, thread]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n32. 函数名: binder_translate_handle\n- 参数: [fp, t, thread]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n33. 函数名: to_binder_fd_object\n- 参数: [hdr]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n34. 函数名: binder_translate_fd\n- 参数: [fd, t, thread, in_reply_to]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n35. 函数名: to_binder_fd_array_object\n- 参数: [hdr]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n36. 函数名: binder_validate_ptr\n- 参数: [buffer, offset, off_start, index]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n37. 函数名: binder_validate_fixup\n- 参数: [buffer, off_start, parent, parent_offset, last_fixup_obj, last_fixup_min_off]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n38. 函数名: binder_translate_fd_array\n- 参数: [fda, parent, t, thread, in_reply_to]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n39. 函数名: to_binder_buffer_object\n- 参数: [hdr]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n40. 函数名: binder_alloc_get_user_buffer_offset\n- 参数: [alloc]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n41. 函数名: binder_fixup_parent\n- 参数: [t, thread, bp, off_start, index, last_fixup_obj, last_fixup_min_off]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n42. 函数名: binder_enqueue_thread_work\n- 参数: [thread, work]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n43. 函数名: binder_pop_transaction_ilocked\n- 参数: [thread, t]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n44. 函数名: binder_enqueue_thread_work_ilocked\n- 参数: [thread, work]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n45. 函数名: wake_up_interruptible_sync\n- 参数: [wait]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n46. 函数名: binder_free_transaction\n- 参数: [t]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n47. 函数名: binder_enqueue_deferred_thread_work_ilocked\n- 参数: [thread, work]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n48. 函数名: binder_proc_transaction\n- 参数: [t, target_proc, target_thread]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n49. 函数名: binder_thread_dec_tmpref\n- 参数: [thread]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n50. 函数名: binder_proc_dec_tmpref\n- 参数: [proc]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n51. 函数名: binder_dec_node_tmpref\n- 参数: [node]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n52. 函数名: smp_wmb\n- 参数: []\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n53. 函数名: WRITE_ONCE\n- 参数: [var, val]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n54. 函数名: binder_dequeue_work\n- 参数: [proc, work]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n55. 函数名: binder_free_txn_fixups\n- 参数: [t]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n56. 函数名: trace_binder_transaction_failed_buffer_release\n- 参数: [buffer]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n57. 函数名: binder_transaction_buffer_release\n- 参数: [proc, buffer, offp]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n58. 函数名: binder_alloc_free_buf\n- 参数: [alloc, buffer]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n59. 函数名: binder_stats_deleted\n- 参数: [type]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n60. 函数名: binder_dec_node\n- 参数: [node, strong, internal]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n61. 函数名: binder_send_failed_reply\n- 参数: [in_reply_to, return_error]\n- 调用者: binder_transaction\n- 被调用者: N/A"
    },
    {
        "id": 2276,
        "cwe": "CWE-416",
        "cve": "CVE-2019-2025",
        "purpose": "Code purpose:\"\"\"处理Binder IPC通信中的线程写入请求，包括引用计数管理、事务处理和死亡通知等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在binder_thread_read函数中，由于不恰当的锁机制导致存在使用后释放(use-after-free)的可能性\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_thread_write\n- 参数: [struct binder_proc *proc, struct binder_thread *thread, binder_uintptr_t binder_buffer, size_t size, binder_size_t *consumed]\n- 调用者: N/A (kernel-level function)\n- 被调用者: [get_user, trace_binder_command, atomic_inc, binder_inc_ref_for_node, binder_update_ref_for_handle, binder_user_error, binder_debug, binder_get_node, binder_put_node, binder_node_inner_lock, binder_node_inner_unlock, binder_dec_node_nilocked, binder_alloc_prepare_to_free, binder_free_buf, copy_from_user, binder_transaction, binder_inner_proc_lock, binder_inner_proc_unlock, binder_proc_lock, binder_proc_unlock, kzalloc, binder_enqueue_thread_work, binder_get_ref_olocked, kfree, binder_stats_created, binder_enqueue_work_ilocked, binder_wakeup_proc_ilocked, binder_enqueue_thread_work_ilocked, list_for_each_entry, binder_dequeue_work_ilocked]\n\n2. 函数名: binder_inc_ref_for_node\n- 参数: [struct binder_proc *proc, struct binder_node *node, bool strong, NULL, struct binder_ref_data *rdata]\n- 调用者: binder_thread_write\n- 被调用者: []\n\n3. 函数名: binder_update_ref_for_handle\n- 参数: [struct binder_proc *proc, uint32_t target, bool increment, bool strong, struct binder_ref_data *rdata]\n- 调用者: binder_thread_write\n- 被调用者: []\n\n4. 函数名: binder_get_node\n- 参数: [struct binder_proc *proc, binder_uintptr_t node_ptr]\n- 调用者: binder_thread_write\n- 被调用者: []\n\n5. 函数名: binder_put_node\n- 参数: [struct binder_node *node]\n- 调用者: binder_thread_write\n- 被调用者: []\n\n6. 函数名: binder_node_inner_lock\n- 参数: [struct binder_node *node]\n- 调用者: binder_thread_write\n- 被调用者: []\n\n7. 函数名: binder_node_inner_unlock\n- 参数: [struct binder_node *node]\n- 调用者: binder_thread_write\n- 被调用者: []\n\n8. 函数名: binder_dec_node_nilocked\n- 参数: [struct binder_node *node, bool cmd == BC_ACQUIRE_DONE, 0]\n- 调用者: binder_thread_write\n- 被调用者: []\n\n9. 函数名: binder_alloc_prepare_to_free\n- 参数: [struct binder_alloc *alloc, binder_uintptr_t data_ptr]\n- 调用者: binder_thread_write\n- 被调用者: []\n\n10. 函数名: binder_free_buf\n- 参数: [struct binder_proc *proc, struct binder_buffer *buffer]\n- 调用者: binder_thread_write\n- 被调用者: []\n\n11. 函数名: binder_transaction\n- 参数: [struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, bool cmd == BC_REPLY_SG, size_t tr.buffers_size]\n- 调用者: binder_thread_write\n- 被调用者: []\n\n12. 函数名: binder_inner_proc_lock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_thread_write\n- 被调用者: []\n\n13. 函数名: binder_inner_proc_unlock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_thread_write\n- 被调用者: []\n\n14. 函数名: binder_proc_lock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_thread_write\n- 被调用者: []\n\n15. 函数名: binder_proc_unlock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_thread_write\n- 被调用者: []\n\n16. 函数名: binder_get_ref_olocked\n- 参数: [struct binder_proc *proc, uint32_t target, bool false]\n- 调用者: binder_thread_write\n- 被调用者: []\n\n17. 函数名: binder_stats_created\n- 参数: [BINDER_STAT_DEATH]\n- 调用者: binder_thread_write\n- 被调用者: []\n\n18. 函数名: binder_enqueue_work_ilocked\n- 参数: [struct binder_work *work, struct list_head *proc->todo]\n- 调用者: binder_thread_write\n- 被调用者: []\n\n19. 函数名: binder_wakeup_proc_ilocked\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_thread_write\n- 被调用者: []\n\n20. 函数名: binder_enqueue_thread_work_ilocked\n- 参数: [struct binder_thread *thread, struct binder_work *death->work]\n- 调用者: binder_thread_write\n- 被调用者: []\n\n21. 函数名: binder_dequeue_work_ilocked\n- 参数: [struct binder_work *death->work]\n- 调用者: binder_thread_write\n- 被调用者: []"
    },
    {
        "id": 2277,
        "cwe": "CWE-416",
        "cve": "CVE-2019-2025",
        "purpose": "Code purpose:\"\"\"该代码用于在Android内核的Binder驱动中分配新的缓冲区，处理不同大小的内存请求并管理空闲和已分配的缓冲区列表，确保内存分配的正确性和高效性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在binder_thread_read函数中由于不正确的锁机制导致使用后释放(use-after-free)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_alloc_new_buf_locked\n- 参数: [alloc, data_size, offsets_size, extra_buffers_size, is_async]\n- 调用者: N/A (顶级函数)\n- 被调用者: [binder_alloc_get_vma, binder_alloc_debug, ERR_PTR, ALIGN, max, rb_entry, binder_alloc_buffer_size, rb_first, rb_next, rb_erase, binder_insert_free_buffer, binder_insert_allocated_buffer_locked, kzalloc, list_add, WARN_ON, PAGE_ALIGN, binder_update_page_range, pr_err]\n\n2. 函数名: binder_alloc_get_vma\n- 参数: [alloc]\n- 调用者: binder_alloc_new_buf_locked\n- 被调用者: []\n\n3. 函数名: binder_alloc_debug\n- 参数: [debug_type, format_string, ...]\n- 调用者: binder_alloc_new_buf_locked\n- 被调用者: []\n\n4. 函数名: ERR_PTR\n- 参数: [error_code]\n- 调用者: binder_alloc_new_buf_locked\n- 被调用者: []\n\n5. 函数名: ALIGN\n- 参数: [value, alignment]\n- 调用者: binder_alloc_new_buf_locked\n- 被调用者: []\n\n6. 函数名: max\n- 参数: [a, b]\n- 调用者: binder_alloc_new_buf_locked\n- 被调用者: []\n\n7. 函数名: rb_entry\n- 参数: [ptr, type, member]\n- 调用者: binder_alloc_new_buf_locked\n- 被调用者: []\n\n8. 函数名: binder_alloc_buffer_size\n- 参数: [alloc, buffer]\n- 调用者: binder_alloc_new_buf_locked\n- 被调用者: []\n\n9. 函数名: rb_first\n- 参数: [tree]\n- 调用者: binder_alloc_new_buf_locked\n- 被调用者: []\n\n10. 函数名: rb_next\n- 参数: [node]\n- 调用者: binder_alloc_new_buf_locked\n- 被调用者: []\n\n11. 函数名: rb_erase\n- 参数: [node, root]\n- 调用者: binder_alloc_new_buf_locked\n- 被调用者: []\n\n12. 函数名: binder_insert_free_buffer\n- 参数: [alloc, buffer]\n- 调用者: binder_alloc_new_buf_locked\n- 被调用者: []\n\n13. 函数名: binder_insert_allocated_buffer_locked\n- 参数: [alloc, buffer]\n- 调用者: binder_alloc_new_buf_locked\n- 被调用者: []\n\n14. 函数名: kzalloc\n- 参数: [size, flags]\n- 调用者: binder_alloc_new_buf_locked\n- 被调用者: []\n\n15. 函数名: list_add\n- 参数: [new, head]\n- 调用者: binder_alloc_new_buf_locked\n- 被调用者: []\n\n16. 函数名: WARN_ON\n- 参数: [condition]\n- 调用者: binder_alloc_new_buf_locked\n- 被调用者: []\n\n17. 函数名: PAGE_ALIGN\n- 参数: [address]\n- 调用者: binder_alloc_new_buf_locked\n- 被调用者: []\n\n18. 函数名: binder_update_page_range\n- 参数: [alloc, allocate, start, end]\n- 调用者: binder_alloc_new_buf_locked\n- 被调用者: []\n\n19. 函数名: pr_err\n- 参数: [format_string, ...]\n- 调用者: binder_alloc_new_buf_locked\n- 被调用者: []"
    },
    {
        "id": 2278,
        "cwe": "CWE-416",
        "cve": "CVE-2019-2025",
        "purpose": "Code purpose:\"\"\"该代码用于在Android内核的binder驱动中安全地准备释放用户空间指针对应的缓冲区，并防止双重释放问题\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在binder_alloc_prepare_to_free_locked函数中缺乏适当的锁保护，导致在多线程环境下可能发生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_alloc_prepare_to_free_locked\n- 参数: [alloc, user_ptr]\n- 调用者: 未明确显示（通常是外部调用）\n- 被调用者: [rb_entry, BUG_ON, binder_alloc_debug]\n\n2. 函数名: rb_entry\n- 参数: [n, struct binder_buffer, rb_node]\n- 调用者: binder_alloc_prepare_to_free_locked\n- 被调用者: []\n\n3. 函数名: BUG_ON\n- 参数: [buffer->free]\n- 调用者: binder_alloc_prepare_to_free_locked\n- 被调用者: []\n\n4. 函数名: binder_alloc_debug\n- 参数: [BINDER_DEBUG_USER_ERROR, \"%d:%d FREE_BUFFER u%016llx user freed buffer twice\\n\", alloc->pid, current->pid, (u64)user_ptr]\n- 调用者: binder_alloc_prepare_to_free_locked\n- 被调用者: []"
    },
    {
        "id": 2289,
        "cwe": "CWE-416",
        "cve": "CVE-2019-20934",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中执行新程序文件的execve系统调用功能，负责处理程序加载、参数准备和进程执行等核心操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在NUMA系统中，Linux公平调度器不当释放了NUMA故障统计信息，导致show_numa_stats()函数中出现释放后使用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: __do_execve_file\n- 参数: [fd, filename, argv, envp, flags, file]\n- 调用者: N/A (内核内部调用)\n- 被调用者: [PTR_ERR, IS_ERR, atomic_read, rlimit, unshare_files, kzalloc, prepare_bprm_creds, check_unsafe_exec, do_open_execat, sched_exec, kasprintf, close_on_exec, rcu_dereference_raw, bprm_mm_init, prepare_arg_pages, prepare_binprm, copy_strings_kernel, copy_strings, would_dump, exec_binprm, membarrier_execve, rseq_execve, acct_update_integrals, task_numa_free, free_bprm, kfree, putname, put_files_struct, acct_arg_size, mmput, reset_files_struct]\n\n2. 函数名: PTR_ERR\n- 参数: [filename]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n3. 函数名: IS_ERR\n- 参数: [filename]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n4. 函数名: atomic_read\n- 参数: [current_user()->processes]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n5. 函数名: rlimit\n- 参数: [RLIMIT_NPROC]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n6. 函数名: unshare_files\n- 参数: [&displaced]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n7. 函数名: kzalloc\n- 参数: [sizeof(*bprm), GFP_KERNEL]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n8. 函数名: prepare_bprm_creds\n- 参数: [bprm]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n9. 函数名: check_unsafe_exec\n- 参数: [bprm]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n10. 函数名: do_open_execat\n- 参数: [fd, filename, flags]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n11. 函数名: sched_exec\n- 参数: []\n- 调用者: __do_execve_file\n- 被调用者: []\n\n12. 函数名: kasprintf\n- 参数: [GFP_KERNEL, \"/dev/fd/%d\", fd] 或 [GFP_KERNEL, \"/dev/fd/%d/%s\", fd, filename->name]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n13. 函数名: close_on_exec\n- 参数: [fd, rcu_dereference_raw(current->files->fdt)]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n14. 函数名: rcu_dereference_raw\n- 参数: [current->files->fdt]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n15. 函数名: bprm_mm_init\n- 参数: [bprm]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n16. 函数名: prepare_arg_pages\n- 参数: [bprm, argv, envp]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n17. 函数名: prepare_binprm\n- 参数: [bprm]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n18. 函数名: copy_strings_kernel\n- 参数: [1, &bprm->filename, bprm]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n19. 函数名: copy_strings\n- 参数: [bprm->envc, envp, bprm] 或 [bprm->argc, argv, bprm]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n20. 函数名: would_dump\n- 参数: [bprm, bprm->file]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n21. 函数名: exec_binprm\n- 参数: [bprm]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n22. 函数名: membarrier_execve\n- 参数: [current]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n23. 函数名: rseq_execve\n- 参数: [current]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n24. 函数名: acct_update_integrals\n- 参数: [current]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n25. 函数名: task_numa_free\n- 参数: [current]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n26. 函数名: free_bprm\n- 参数: [bprm]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n27. 函数名: kfree\n- 参数: [pathbuf]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n28. 函数名: putname\n- 参数: [filename]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n29. 函数名: put_files_struct\n- 参数: [displaced]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n30. 函数名: acct_arg_size\n- 参数: [bprm, 0]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n31. 函数名: mmput\n- 参数: [bprm->mm]\n- 调用者: __do_execve_file\n- 被调用者: []\n\n32. 函数名: reset_files_struct\n- 参数: [displaced]\n- 调用者: __do_execve_file\n- 被调用者: []"
    },
    {
        "id": 2294,
        "cwe": "CWE-416",
        "cve": "CVE-2019-2213",
        "purpose": "Code purpose:\"\"\"释放binder事务结构体及相关资源，包括解除buffer关联和释放内存\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放binder_transaction结构体时存在竞态条件，导致可能在其他线程仍在使用该结构体时被释放，从而引发use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_free_transaction\n- 参数: [struct binder_transaction *t]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [binder_free_txn_fixups, kfree, binder_stats_deleted]\n\n2. 函数名: binder_free_txn_fixups\n- 参数: [struct binder_transaction *t]\n- 调用者: binder_free_transaction\n- 被调用者: 未明确\n\n3. 函数名: kfree\n- 参数: [void *ptr] (此处为 struct binder_transaction *t)\n- 调用者: binder_free_transaction\n- 被调用者: 未明确\n\n4. 函数名: binder_stats_deleted\n- 参数: [BINDER_STAT_TRANSACTION]\n- 调用者: binder_free_transaction\n- 被调用者: 未明确"
    },
    {
        "id": 2295,
        "cwe": "CWE-416",
        "cve": "CVE-2019-2213",
        "purpose": "Code purpose:\"\"\"释放Binder进程间通信中的缓冲区资源并处理相关事务的清理工作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在binder_free_buf函数中存在竞态条件，导致对已释放的binder_buffer对象可能被再次访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_free_buf\n- 参数: [proc, buffer]\n- 调用者: 未提供\n- 被调用者: [binder_node_inner_lock, binder_dequeue_work_head_ilocked, binder_enqueue_work_ilocked, binder_wakeup_proc_ilocked, binder_node_inner_unlock, trace_binder_transaction_buffer_release, binder_transaction_buffer_release, binder_alloc_free_buf]\n\n2. 函数名: binder_node_inner_lock\n- 参数: [buf_node]\n- 调用者: binder_free_buf\n- 被调用者: 未提供\n\n3. 函数名: binder_dequeue_work_head_ilocked\n- 参数: [&buf_node->async_todo]\n- 调用者: binder_free_buf\n- 被调用者: 未提供\n\n4. 函数名: binder_enqueue_work_ilocked\n- 参数: [w, &proc->todo]\n- 调用者: binder_free_buf\n- 被调用者: 未提供\n\n5. 函数名: binder_wakeup_proc_ilocked\n- 参数: [proc]\n- 调用者: binder_free_buf\n- 被调用者: 未提供\n\n6. 函数名: binder_node_inner_unlock\n- 参数: [buf_node]\n- 调用者: binder_free_buf\n- 被调用者: 未提供\n\n7. 函数名: trace_binder_transaction_buffer_release\n- 参数: [buffer]\n- 调用者: binder_free_buf\n- 被调用者: 未提供\n\n8. 函数名: binder_transaction_buffer_release\n- 参数: [proc, buffer, 0, false]\n- 调用者: binder_free_buf\n- 被调用者: 未提供\n\n9. 函数名: binder_alloc_free_buf\n- 参数: [&proc->alloc, buffer]\n- 调用者: binder_free_buf\n- 被调用者: 未提供"
    },
    {
        "id": 2297,
        "cwe": "CWE-416",
        "cve": "CVE-2019-2215",
        "purpose": "Code purpose:\"\"\"释放binder线程资源并处理相关事务，包括清理线程的事务栈和发送失败回复\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放binder线程时未正确处理事务锁和引用计数，导致释放后仍可能被访问的use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_thread_release\n- 参数: [struct binder_proc *proc, struct binder_thread *thread]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [binder_inner_proc_lock, atomic_inc, rb_erase, spin_lock, binder_debug, spin_unlock, binder_inner_proc_unlock, binder_send_failed_reply, binder_release_work, binder_thread_dec_tmpref]\n\n2. 函数名: binder_inner_proc_lock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_thread_release\n- 被调用者: []\n\n3. 函数名: atomic_inc\n- 参数: [&thread->tmp_ref]\n- 调用者: binder_thread_release\n- 被调用者: []\n\n4. 函数名: rb_erase\n- 参数: [&thread->rb_node, &proc->threads]\n- 调用者: binder_thread_release\n- 被调用者: []\n\n5. 函数名: spin_lock\n- 参数: [&t->lock]\n- 调用者: binder_thread_release\n- 被调用者: []\n\n6. 函数名: binder_debug\n- 参数: [BINDER_DEBUG_DEAD_TRANSACTION, \"release %d:%d transaction %d %s, still active\\n\", proc->pid, thread->pid, t->debug_id, (t->to_thread == thread) ? \"in\" : \"out\"]\n- 调用者: binder_thread_release\n- 被调用者: []\n\n7. 函数名: spin_unlock\n- 参数: [&last_t->lock]\n- 调用者: binder_thread_release\n- 被调用者: []\n\n8. 函数名: binder_inner_proc_unlock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_thread_release\n- 被调用者: []\n\n9. 函数名: binder_send_failed_reply\n- 参数: [send_reply, BR_DEAD_REPLY]\n- 调用者: binder_thread_release\n- 被调用者: []\n\n10. 函数名: binder_release_work\n- 参数: [proc, &thread->todo]\n- 调用者: binder_thread_release\n- 被调用者: []\n\n11. 函数名: binder_thread_dec_tmpref\n- 参数: [thread]\n- 调用者: binder_thread_release\n- 被调用者: []"
    },
    {
        "id": 2298,
        "cwe": "CWE-416",
        "cve": "CVE-2019-25044",
        "purpose": "Code purpose:\"\"\"清理并释放请求队列资源，设置队列状态标志以防止新请求进入，并处理队列中剩余的请求\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在blk_cleanup_queue函数中，由于未正确处理队列资源的释放顺序，导致在队列被标记为DYING后仍可能被访问，从而引发释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: blk_cleanup_queue\n- 参数: [q]\n- 调用者: N/A\n- 被调用者: [mutex_lock, blk_set_queue_dying, blk_queue_flag_set, mutex_unlock, blk_freeze_queue, rq_qos_exit, blk_flush_integrity, del_timer_sync, blk_sync_queue, queue_is_mq, blk_mq_exit_queue, percpu_ref_exit, blk_put_queue]\n\n2. 函数名: mutex_lock\n- 参数: [&q->sysfs_lock]\n- 调用者: blk_cleanup_queue\n- 被调用者: N/A\n\n3. 函数名: blk_set_queue_dying\n- 参数: [q]\n- 调用者: blk_cleanup_queue\n- 被调用者: N/A\n\n4. 函数名: blk_queue_flag_set\n- 参数: [QUEUE_FLAG_NOMERGES, q], [QUEUE_FLAG_NOXMERGES, q], [QUEUE_FLAG_DYING, q], [QUEUE_FLAG_DEAD, q]\n- 调用者: blk_cleanup_queue\n- 被调用者: N/A\n\n5. 函数名: mutex_unlock\n- 参数: [&q->sysfs_lock]\n- 调用者: blk_cleanup_queue\n- 被调用者: N/A\n\n6. 函数名: blk_freeze_queue\n- 参数: [q]\n- 调用者: blk_cleanup_queue\n- 被调用者: N/A\n\n7. 函数名: rq_qos_exit\n- 参数: [q]\n- 调用者: blk_cleanup_queue\n- 被调用者: N/A\n\n8. 函数名: blk_flush_integrity\n- 参数: []\n- 调用者: blk_cleanup_queue\n- 被调用者: N/A\n\n9. 函数名: del_timer_sync\n- 参数: [&q->backing_dev_info->laptop_mode_wb_timer]\n- 调用者: blk_cleanup_queue\n- 被调用者: N/A\n\n10. 函数名: blk_sync_queue\n- 参数: [q]\n- 调用者: blk_cleanup_queue\n- 被调用者: N/A\n\n11. 函数名: queue_is_mq\n- 参数: [q]\n- 调用者: blk_cleanup_queue\n- 被调用者: N/A\n\n12. 函数名: blk_mq_exit_queue\n- 参数: [q]\n- 调用者: blk_cleanup_queue\n- 被调用者: N/A\n\n13. 函数名: percpu_ref_exit\n- 参数: [&q->q_usage_counter]\n- 调用者: blk_cleanup_queue\n- 被调用者: N/A\n\n14. 函数名: blk_put_queue\n- 参数: [q]\n- 调用者: blk_cleanup_queue\n- 被调用者: N/A"
    },
    {
        "id": 2299,
        "cwe": "CWE-416",
        "cve": "CVE-2019-25044",
        "purpose": "Code purpose:\"\"\"释放请求队列中每个硬件上下文的调度标签资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核的块子系统中，由于在释放队列资源后未正确处理硬件上下文(hctx)的引用，导致存在释放后重用(use-after-free)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: blk_mq_sched_tags_teardown\n- 参数: [struct request_queue *q]\n- 调用者: 未显示\n- 被调用者: [queue_for_each_hw_ctx, blk_mq_sched_free_tags]\n\n2. 函数名: queue_for_each_hw_ctx\n- 参数: [struct request_queue *q, struct blk_mq_hw_ctx *hctx, int i]\n- 调用者: blk_mq_sched_tags_teardown\n- 被调用者: 未显示\n\n3. 函数名: blk_mq_sched_free_tags\n- 参数: [struct blk_mq_tag_set *set, struct blk_mq_hw_ctx *hctx, int i]\n- 调用者: blk_mq_sched_tags_teardown\n- 被调用者: 未显示"
    },
    {
        "id": 2300,
        "cwe": "CWE-416",
        "cve": "CVE-2019-25044",
        "purpose": "Code purpose:\"\"\"初始化块设备的多队列调度器，包括分配资源、设置请求队列深度和注册调试接口\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核的块子系统中，由于在释放资源后未正确清理队列调度器相关数据结构，导致存在释放后重用(use-after-free)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: blk_mq_init_sched\n- 参数: [struct request_queue *q, struct elevator_type *e]\n- 调用者: 未显示\n- 被调用者: [blk_mq_sched_alloc_tags, e->ops.init_sched, blk_mq_debugfs_register_sched, e->ops.init_hctx, blk_mq_exit_sched, kobject_put, blk_mq_debugfs_register_sched_hctx, blk_mq_sched_tags_teardown]\n\n2. 函数名: blk_mq_sched_alloc_tags\n- 参数: [struct request_queue *q, struct blk_mq_hw_ctx *hctx, unsigned int i]\n- 调用者: blk_mq_init_sched\n- 被调用者: 未显示\n\n3. 函数名: init_sched\n- 参数: [struct request_queue *q, struct elevator_type *e]\n- 调用者: blk_mq_init_sched\n- 被调用者: 未显示\n\n4. 函数名: blk_mq_debugfs_register_sched\n- 参数: [struct request_queue *q]\n- 调用者: blk_mq_init_sched\n- 被调用者: 未显示\n\n5. 函数名: init_hctx\n- 参数: [struct blk_mq_hw_ctx *hctx, unsigned int i]\n- 调用者: blk_mq_init_sched\n- 被调用者: 未显示\n\n6. 函数名: blk_mq_exit_sched\n- 参数: [struct request_queue *q, struct elevator_queue *eq]\n- 调用者: blk_mq_init_sched\n- 被调用者: 未显示\n\n7. 函数名: kobject_put\n- 参数: [struct kobject *kobj]\n- 调用者: blk_mq_init_sched\n- 被调用者: 未显示\n\n8. 函数名: blk_mq_debugfs_register_sched_hctx\n- 参数: [struct request_queue *q, struct blk_mq_hw_ctx *hctx]\n- 调用者: blk_mq_init_sched\n- 被调用者: 未显示\n\n9. 函数名: blk_mq_sched_tags_teardown\n- 参数: [struct request_queue *q]\n- 调用者: blk_mq_init_sched\n- 被调用者: 未显示"
    },
    {
        "id": 2301,
        "cwe": "CWE-416",
        "cve": "CVE-2019-25044",
        "purpose": "Code purpose:\"\"\"该代码片段实现了Linux内核中块设备队列的退出清理功能，包括I/O调度器退出、块控制组关联解除和后备设备信息引用计数处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核块子系统中，由于在清理队列时存在释放后使用(UAF)问题，导致可能执行任意内核代码并提升权限。\"\"\"",
        "functions": "Functions:\n1. 函数名: blk_exit_queue\n- 参数: [q]\n- 调用者: 未显示\n- 被调用者: [ioc_clear_queue, elevator_exit, blkcg_exit_queue, bdi_put]\n\n2. 函数名: ioc_clear_queue\n- 参数: [q]\n- 调用者: blk_exit_queue\n- 被调用者: 未显示\n\n3. 函数名: elevator_exit\n- 参数: [q, q->elevator]\n- 调用者: blk_exit_queue\n- 被调用者: 未显示\n\n4. 函数名: blkcg_exit_queue\n- 参数: [q]\n- 调用者: blk_exit_queue\n- 被调用者: 未显示\n\n5. 函数名: bdi_put\n- 参数: [q->backing_dev_info]\n- 调用者: blk_exit_queue\n- 被调用者: 未显示"
    },
    {
        "id": 2302,
        "cwe": "CWE-416",
        "cve": "CVE-2019-25045",
        "purpose": "Code purpose:\"\"\"该代码用于在网络命名空间退出时清理XFRM6隧道相关的状态和SPI哈希表\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在XFRM子系统中存在释放后使用的问题，导致xfrm_state_fini时发生panic\"\"\"",
        "functions": "Functions:\n1. 函数名: __net_exit xfrm6_tunnel_net_exit\n- 参数: [struct net *net]\n- 调用者: 未明确（由内核网络子系统调用）\n- 被调用者: [xfrm6_tunnel_pernet, xfrm_flush_gc, xfrm_state_flush, WARN_ON_ONCE]\n\n2. 函数名: xfrm6_tunnel_pernet\n- 参数: [struct net *net]\n- 调用者: __net_exit xfrm6_tunnel_net_exit\n- 被调用者: []\n\n3. 函数名: xfrm_flush_gc\n- 参数: []\n- 调用者: __net_exit xfrm6_tunnel_net_exit\n- 被调用者: []\n\n4. 函数名: xfrm_state_flush\n- 参数: [struct net *net, IPSEC_PROTO_ANY, false, true]\n- 调用者: __net_exit xfrm6_tunnel_net_exit\n- 被调用者: []\n\n5. 函数名: WARN_ON_ONCE\n- 参数: [!hlist_empty(&xfrm6_tn->spi_byaddr[i])], [!hlist_empty(&xfrm6_tn->spi_byspi[i])]\n- 调用者: __net_exit xfrm6_tunnel_net_exit\n- 被调用者: []\n\n6. 函数名: hlist_empty\n- 参数: [&xfrm6_tn->spi_byaddr[i]], [&xfrm6_tn->spi_byspi[i]]\n- 调用者: WARN_ON_ONCE\n- 被调用者: []"
    },
    {
        "id": 2303,
        "cwe": "CWE-416",
        "cve": "CVE-2019-25045",
        "purpose": "Code purpose:\"\"\"解析IPsec请求并构建XFRM模板，用于Linux内核中的安全策略处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在XFRM子系统中处理IPsec请求时存在释放后使用问题，导致xfrm_state_fini崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: parse_ipsecrequest\n- 参数: [struct xfrm_policy *xp, struct sadb_x_ipsecrequest *rq]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [pfkey_mode_to_xfrm, parse_sockaddr_pair, gen_reqid]\n\n2. 函数名: pfkey_mode_to_xfrm\n- 参数: [int mode]\n- 调用者: parse_ipsecrequest\n- 被调用者: []\n\n3. 函数名: parse_sockaddr_pair\n- 参数: [struct sockaddr *addr, int len, struct xfrm_address *saddr, struct xfrm_address *daddr, int *family]\n- 调用者: parse_ipsecrequest\n- 被调用者: []\n\n4. 函数名: gen_reqid\n- 参数: [struct net *net]\n- 调用者: parse_ipsecrequest\n- 被调用者: []\n\n5. 函数名: xp_net\n- 参数: [struct xfrm_policy *xp]\n- 调用者: parse_ipsecrequest\n- 被调用者: []"
    },
    {
        "id": 2304,
        "cwe": "CWE-416",
        "cve": "CVE-2019-25045",
        "purpose": "Code purpose:\"\"\"清理和释放网络命名空间中的XFRM状态相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在xfrm_state_fini函数中释放哈希表内存后，未正确清理或同步相关状态，导致后续可能访问已释放的内存区域，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: xfrm_state_fini\n- 参数: [struct net *net]\n- 调用者: 未显示\n- 被调用者: [flush_work, xfrm_state_flush, WARN_ON, xfrm_hash_free]\n\n2. 函数名: flush_work\n- 参数: [&net->xfrm.state_hash_work], [&xfrm_state_gc_work]\n- 调用者: xfrm_state_fini\n- 被调用者: 未显示\n\n3. 函数名: xfrm_state_flush\n- 参数: [net, IPSEC_PROTO_ANY, false, true]\n- 调用者: xfrm_state_fini\n- 被调用者: 未显示\n\n4. 函数名: WARN_ON\n- 参数: [!list_empty(&net->xfrm.state_all)], [!hlist_empty(net->xfrm.state_byspi)], [!hlist_empty(net->xfrm.state_bysrc)], [!hlist_empty(net->xfrm.state_bydst)]\n- 调用者: xfrm_state_fini\n- 被调用者: 未显示\n\n5. 函数名: xfrm_hash_free\n- 参数: [net->xfrm.state_byspi, sz], [net->xfrm.state_bysrc, sz], [net->xfrm.state_bydst, sz]\n- 调用者: xfrm_state_fini\n- 被调用者: 未显示"
    },
    {
        "id": 2305,
        "cwe": "CWE-416",
        "cve": "CVE-2019-25045",
        "purpose": "Code purpose:\"\"\"验证XFRM用户模板的有效性，包括检查模板数量、模式、地址族和协议类型等参数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未正确验证xfrm_user_tmpl结构体中的family字段导致使用后释放漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: validate_tmpl\n- 参数: [nr, ut, family]\n- 调用者: 未明确显示（应为XFRM子系统相关调用）\n- 被调用者: []"
    },
    {
        "id": 2331,
        "cwe": "CWE-416",
        "cve": "CVE-2019-3896",
        "purpose": "Code purpose:\"\"\"该代码用于递归释放IDR结构中所有层级的内存，并重置IDR结构的状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在idr_remove_all()函数中存在双重释放漏洞，由于对指针p的处理不当，可能导致同一内存块被多次释放\"\"\"",
        "functions": "Functions:\n1. 函数名: idr_remove_all\n- 参数: [struct idr *idp]\n- 调用者: 未显示（外部调用）\n- 被调用者: [free_layer, rcu_assign_pointer]\n\n2. 函数名: free_layer\n- 参数: [struct idr_layer *p]\n- 调用者: idr_remove_all\n- 被调用者: 未显示\n\n3. 函数名: rcu_assign_pointer\n- 参数: [idp->top, NULL]\n- 调用者: idr_remove_all\n- 被调用者: 未显示\n\n4. 函数名: fls\n- 参数: [id]\n- 调用者: idr_remove_all\n- 被调用者: 未显示"
    },
    {
        "id": 2342,
        "cwe": "CWE-416",
        "cve": "CVE-2019-6974",
        "purpose": "Code purpose:\"\"\"该代码用于处理KVM虚拟化环境中创建设备的IOCTL请求，包括设备类型验证、内存分配、设备初始化和文件描述符分配等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于存在竞态条件导致引用计数处理不当，从而引发释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: kvm_ioctl_create_device\n- 参数: [struct kvm *kvm, struct kvm_create_device *cd]\n- 调用者: 未明确（由KVM子系统调用）\n- 被调用者: [kzalloc, mutex_lock, mutex_unlock, kfree, list_add, list_del, anon_inode_getfd, kvm_get_kvm, ops->create, ops->init, ops->destroy]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*dev), GFP_KERNEL]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: []\n\n3. 函数名: mutex_lock\n- 参数: [&kvm->lock]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: []\n\n4. 函数名: mutex_unlock\n- 参数: [&kvm->lock]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: []\n\n5. 函数名: kfree\n- 参数: [dev]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: []\n\n6. 函数名: list_add\n- 参数: [&dev->vm_node, &kvm->devices]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: []\n\n7. 函数名: list_del\n- 参数: [&dev->vm_node]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: []\n\n8. 函数名: anon_inode_getfd\n- 参数: [ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: []\n\n9. 函数名: kvm_get_kvm\n- 参数: [kvm]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: []\n\n10. 函数名: ops->create\n- 参数: [dev, cd->type]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: []\n\n11. 函数名: ops->init\n- 参数: [dev]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: []\n\n12. 函数名: ops->destroy\n- 参数: [dev]\n- 调用者: kvm_ioctl_create_device\n- 被调用者: []"
    },
    {
        "id": 2343,
        "cwe": "CWE-416",
        "cve": "CVE-2019-7221",
        "purpose": "Code purpose:\"\"\"释放KVM虚拟化环境中嵌套虚拟化相关的资源，包括VMCS结构、VPID、页面内存等，并清理相关状态。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放嵌套虚拟化资源时未正确清理所有引用，导致后续可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: free_nested\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: N/A\n- 被调用者: [to_vmx, free_vpid, vmx_disable_shadow_vmcs, vmcs_clear, free_vmcs, kfree, kvm_release_page_dirty, kunmap, kvm_mmu_free_roots, nested_release_evmcs, free_loaded_vmcs]\n\n2. 函数名: to_vmx\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: free_nested\n- 被调用者: N/A\n\n3. 函数名: free_vpid\n- 参数: [vmx->nested.vpid02]\n- 调用者: free_nested\n- 被调用者: N/A\n\n4. 函数名: vmx_disable_shadow_vmcs\n- 参数: [vmx]\n- 调用者: free_nested\n- 被调用者: N/A\n\n5. 函数名: vmcs_clear\n- 参数: [vmx->vmcs01.shadow_vmcs]\n- 调用者: free_nested\n- 被调用者: N/A\n\n6. 函数名: free_vmcs\n- 参数: [vmx->vmcs01.shadow_vmcs]\n- 调用者: free_nested\n- 被调用者: N/A\n\n7. 函数名: kfree\n- 参数: [vmx->nested.cached_vmcs12, vmx->nested.cached_shadow_vmcs12]\n- 调用者: free_nested\n- 被调用者: N/A\n\n8. 函数名: kvm_release_page_dirty\n- 参数: [vmx->nested.apic_access_page, vmx->nested.virtual_apic_page, vmx->nested.pi_desc_page]\n- 调用者: free_nested\n- 被调用者: N/A\n\n9. 函数名: kunmap\n- 参数: [vmx->nested.pi_desc_page]\n- 调用者: free_nested\n- 被调用者: N/A\n\n10. 函数名: kvm_mmu_free_roots\n- 参数: [vcpu, &vcpu->arch.guest_mmu, KVM_MMU_ROOTS_ALL]\n- 调用者: free_nested\n- 被调用者: N/A\n\n11. 函数名: nested_release_evmcs\n- 参数: [vcpu]\n- 调用者: free_nested\n- 被调用者: N/A\n\n12. 函数名: free_loaded_vmcs\n- 参数: [&vmx->nested.vmcs02]\n- 调用者: free_nested\n- 被调用者: N/A"
    },
    {
        "id": 2347,
        "cwe": "CWE-416",
        "cve": "CVE-2019-8912",
        "purpose": "Code purpose:\"\"\"释放AF_ALG套接字相关的资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放sock->sk后未将其置为NULL，导致后续可能出现对已释放内存的使用\"\"\"",
        "functions": "Functions:\n1. 函数名: af_alg_release\n- 参数: [struct socket *sock]\n- 调用者: 未明确（通常是内核中socket释放相关代码）\n- 被调用者: [sock_put]\n\n2. 函数名: sock_put\n- 参数: [struct sock *sk]\n- 调用者: [af_alg_release]\n- 被调用者: 未明确（通常是内核中sock引用计数相关操作）"
    },
    {
        "id": 2348,
        "cwe": "CWE-416",
        "cve": "CVE-2019-8956",
        "purpose": "Code purpose:\"\"\"处理SCTP协议中的消息发送功能，包括解析消息、查找或创建关联、检查发送标志，并将消息发送到指定的关联\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核处理SCTP_SENDALL标志时，sctp_sendmsg()函数中存在释放后使用(UAF)错误，导致内存损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: sctp_sendmsg\n- 参数: [struct sock *sk, struct msghdr *msg, size_t msg_len]\n- 调用者: 无（顶层函数）\n- 被调用者: [sctp_sendmsg_parse, sctp_sendmsg_get_daddr, sctp_style, sctp_sendmsg_check_sflags, sctp_sendmsg_update_sinfo, sctp_sendmsg_to_asoc, iov_iter_revert, sctp_endpoint_lookup_assoc, sctp_sendmsg_new_asoc, sctp_id2assoc, sctp_association_free, release_sock, sctp_error]\n\n2. 函数名: sctp_sendmsg_parse\n- 参数: [struct sock *sk, struct sctp_cmsgs *cmsgs, struct sctp_sndrcvinfo *_sinfo, struct msghdr *msg, size_t msg_len]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n3. 函数名: sctp_sendmsg_get_daddr\n- 参数: [struct sock *sk, struct msghdr *msg, struct sctp_cmsgs *cmsgs]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n4. 函数名: sctp_style\n- 参数: [struct sock *sk, int style]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n5. 函数名: sctp_sendmsg_check_sflags\n- 参数: [struct sctp_association *asoc, __u16 sflags, struct msghdr *msg, size_t msg_len]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n6. 函数名: sctp_sendmsg_update_sinfo\n- 参数: [struct sctp_association *asoc, struct sctp_sndrcvinfo *sinfo, struct sctp_cmsgs *cmsgs]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n7. 函数名: sctp_sendmsg_to_asoc\n- 参数: [struct sctp_association *asoc, struct msghdr *msg, size_t msg_len, struct sctp_transport *transport, struct sctp_sndrcvinfo *sinfo]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n8. 函数名: iov_iter_revert\n- 参数: [struct iov_iter *i, size_t unrolled]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n9. 函数名: sctp_endpoint_lookup_assoc\n- 参数: [struct sctp_endpoint *ep, union sctp_addr *daddr, struct sctp_transport **transport]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n10. 函数名: sctp_sendmsg_new_asoc\n- 参数: [struct sock *sk, __u16 sflags, struct sctp_cmsgs *cmsgs, union sctp_addr *daddr, struct sctp_transport **transport]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n11. 函数名: sctp_id2assoc\n- 参数: [struct sock *sk, sctp_assoc_t id]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n12. 函数名: sctp_association_free\n- 参数: [struct sctp_association *asoc]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n13. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n14. 函数名: sctp_error\n- 参数: [struct sock *sk, int flags, int err]\n- 调用者: sctp_sendmsg\n- 被调用者: []"
    },
    {
        "id": 2350,
        "cwe": "CWE-416",
        "cve": "CVE-2019-9003",
        "purpose": "Code purpose:\"\"\"释放IPMI用户结构体并减少引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放ipmi_user结构体后未正确处理引用计数，导致可能发生use-after-free情况\"\"\"",
        "functions": "Functions:\n1. 函数名: free_user\n- 参数: [struct kref *ref]\n- 调用者: 未明确显示（通常由kref引用计数机制调用）\n- 被调用者: [container_of, kfree]\n\n2. 函数名: container_of\n- 参数: [未明确显示，通常为(ptr, type, member)]\n- 调用者: free_user\n- 被调用者: []\n\n3. 函数名: kfree\n- 参数: [void *ptr]\n- 调用者: free_user\n- 被调用者: []"
    },
    {
        "id": 2351,
        "cwe": "CWE-416",
        "cve": "CVE-2019-9003",
        "purpose": "Code purpose:\"\"\"该代码用于销毁IPMI用户并释放相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ipmi_destroy_user函数中，由于清理操作和kref_put释放操作之间的竞争条件，导致在释放资源后仍可能被访问，从而引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ipmi_destroy_user\n- 参数: [struct ipmi_user *user]\n- 调用者: 未提供（外部调用）\n- 被调用者: [_ipmi_destroy_user, cleanup_srcu_struct, kref_put]\n\n2. 函数名: _ipmi_destroy_user\n- 参数: [struct ipmi_user *user]\n- 调用者: ipmi_destroy_user\n- 被调用者: 未提供\n\n3. 函数名: cleanup_srcu_struct\n- 参数: [&user->release_barrier]\n- 调用者: ipmi_destroy_user\n- 被调用者: 未提供\n\n4. 函数名: kref_put\n- 参数: [&user->refcount, free_user]\n- 调用者: ipmi_destroy_user\n- 被调用者: [free_user]\n\n5. 函数名: free_user\n- 参数: 未提供（通过kref_put间接调用）\n- 调用者: kref_put\n- 被调用者: 未提供"
    },
    {
        "id": 2372,
        "cwe": "CWE-416",
        "cve": "CVE-2020-0030",
        "purpose": "Code purpose:\"\"\"释放binder线程资源并处理未完成的事务，防止内存泄漏和竞态条件导致的使用后释放漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在binder_thread_release函数中，由于存在竞态条件导致在释放线程资源后仍可能被访问，造成释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_thread_release\n- 参数: [struct binder_proc *proc, struct binder_thread *thread]\n- 调用者: 未明确（通常是binder驱动内部调用）\n- 被调用者: [binder_inner_proc_lock, atomic_inc, rb_erase, spin_lock, binder_debug, spin_unlock, wake_up_poll, binder_inner_proc_unlock, binder_send_failed_reply, binder_release_work, binder_thread_dec_tmpref]\n\n2. 函数名: binder_inner_proc_lock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_thread_release\n- 被调用者: []\n\n3. 函数名: atomic_inc\n- 参数: [atomic_t *v]\n- 调用者: binder_thread_release\n- 被调用者: []\n\n4. 函数名: rb_erase\n- 参数: [struct rb_node *node, struct rb_root *root]\n- 调用者: binder_thread_release\n- 被调用者: []\n\n5. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: binder_thread_release\n- 被调用者: []\n\n6. 函数名: binder_debug\n- 参数: [int mask, const char *fmt, ...]\n- 调用者: binder_thread_release\n- 被调用者: []\n\n7. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: binder_thread_release\n- 被调用者: []\n\n8. 函数名: wake_up_poll\n- 参数: [wait_queue_head_t *wq_head, unsigned int key]\n- 调用者: binder_thread_release\n- 被调用者: []\n\n9. 函数名: binder_inner_proc_unlock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_thread_release\n- 被调用者: []\n\n10. 函数名: binder_send_failed_reply\n- 参数: [struct binder_transaction *t, uint32_t error_code]\n- 调用者: binder_thread_release\n- 被调用者: []\n\n11. 函数名: binder_release_work\n- 参数: [struct binder_proc *proc, struct list_head *list]\n- 调用者: binder_thread_release\n- 被调用者: []\n\n12. 函数名: binder_thread_dec_tmpref\n- 参数: [struct binder_thread *thread]\n- 调用者: binder_thread_release\n- 被调用者: []"
    },
    {
        "id": 2377,
        "cwe": "CWE-416",
        "cve": "CVE-2020-0305",
        "purpose": "Code purpose:\"\"\"获取字符设备对应的kobject对象并增加模块引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在cdev_get函数中存在竞态条件，当kobject_get失败时可能导致模块引用计数错误递减，从而引发use-after-free问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: cdev_get\n- 参数: [struct cdev *p]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [try_module_get, kobject_get, module_put]\n\n2. 函数名: try_module_get\n- 参数: [struct module *owner]\n- 调用者: cdev_get\n- 被调用者: []\n\n3. 函数名: kobject_get\n- 参数: [struct kobject *kobj]\n- 调用者: cdev_get\n- 被调用者: []\n\n4. 函数名: module_put\n- 参数: [struct module *owner]\n- 调用者: cdev_get\n- 被调用者: []"
    },
    {
        "id": 2378,
        "cwe": "CWE-416",
        "cve": "CVE-2020-0423",
        "purpose": "Code purpose:\"\"\"释放binder进程中的工作项并清理相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在binder_release_work函数中存在因不恰当的锁机制导致的释放后使用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_release_work\n- 参数: [struct binder_proc *proc, struct list_head *list]\n- 调用者: N/A\n- 被调用者: [binder_dequeue_work_head, container_of, binder_cleanup_transaction, binder_debug, kfree, binder_stats_deleted, pr_err]\n\n2. 函数名: binder_dequeue_work_head\n- 参数: [struct binder_proc *proc, struct list_head *list]\n- 调用者: binder_release_work\n- 被调用者: N/A\n\n3. 函数名: container_of\n- 参数: [w, struct binder_transaction, work]\n- 调用者: binder_release_work\n- 被调用者: N/A\n\n4. 函数名: binder_cleanup_transaction\n- 参数: [struct binder_transaction *t, \"process died.\", BR_DEAD_REPLY]\n- 调用者: binder_release_work\n- 被调用者: N/A\n\n5. 函数名: binder_debug\n- 参数: [BINDER_DEBUG_DEAD_TRANSACTION, \"undelivered TRANSACTION_ERROR: %u\\n\", e->cmd]\n- 调用者: binder_release_work\n- 被调用者: N/A\n\n6. 函数名: kfree\n- 参数: [w]\n- 调用者: binder_release_work\n- 被调用者: N/A\n\n7. 函数名: binder_stats_deleted\n- 参数: [BINDER_STAT_TRANSACTION_COMPLETE]\n- 调用者: binder_release_work\n- 被调用者: N/A\n\n8. 函数名: pr_err\n- 参数: [\"unexpected work type, %d, not freed\\n\", w->type]\n- 调用者: binder_release_work\n- 被调用者: N/A"
    },
    {
        "id": 2379,
        "cwe": "CWE-416",
        "cve": "CVE-2020-0427",
        "purpose": "Code purpose:\"\"\"释放与引脚控制相关的映射内存，处理有或无引脚控制设备两种情况下的内存释放\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放map内存后仍可能被访问，导致释放后使用(use-after-free)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: dt_free_map\n- 参数: [pctldev, map, num_maps]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [pinctrl_ops->dt_free_map, kfree]\n\n2. 函数名: pinctrl_ops->dt_free_map\n- 参数: [pctldev, map, num_maps]（通过函数指针调用）\n- 调用者: dt_free_map\n- 被调用者: 未明确（具体实现取决于pinctrl_ops实例）\n\n3. 函数名: kfree\n- 参数: [map]\n- 调用者: dt_free_map\n- 被调用者: 未明确（内核内存释放函数）"
    },
    {
        "id": 2380,
        "cwe": "CWE-416",
        "cve": "CVE-2020-0427",
        "purpose": "Code purpose:\"\"\"该代码用于在设备树中记住或释放引脚控制映射，包括初始化映射表条目并将转换后的映射表条目注册到系统中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在dt_remember_or_free_map函数中，由于在内存释放后仍可能访问已释放的映射表(map)，导致释放后使用(use-after-free)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: dt_remember_or_free_map\n- 参数: [struct pinctrl *p, const char *statename, struct pinctrl_dev *pctldev, struct pinctrl_map *map, unsigned num_maps]\n- 调用者: 未明确（应为create_pinctrl）\n- 被调用者: [dev_name, kzalloc, dt_free_map, list_add_tail, pinctrl_register_map]\n\n2. 函数名: dev_name\n- 参数: [struct device *dev]\n- 调用者: dt_remember_or_free_map\n- 被调用者: []\n\n3. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: dt_remember_or_free_map\n- 被调用者: []\n\n4. 函数名: dt_free_map\n- 参数: [struct pinctrl_dev *pctldev, struct pinctrl_map *map, unsigned num_maps]\n- 调用者: dt_remember_or_free_map\n- 被调用者: []\n\n5. 函数名: list_add_tail\n- 参数: [struct list_head *new, struct list_head *head]\n- 调用者: dt_remember_or_free_map\n- 被调用者: []\n\n6. 函数名: pinctrl_register_map\n- 参数: [struct pinctrl_map const *map, unsigned num_maps, bool dup]\n- 调用者: dt_remember_or_free_map\n- 被调用者: []"
    },
    {
        "id": 2381,
        "cwe": "CWE-416",
        "cve": "CVE-2020-0429",
        "purpose": "Code purpose:\"\"\"关闭指定L2TP隧道中的所有会话并释放相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放会话资源后仍可能通过回调函数访问已释放的内存，导致释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: l2tp_tunnel_closeall\n- 参数: [struct l2tp_tunnel *tunnel]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [l2tp_info, hlist_for_each_safe, hlist_entry, hlist_del_init, write_unlock_bh, __l2tp_session_unhash, l2tp_session_queue_purge, write_lock_bh, l2tp_session_dec_refcount]\n\n2. 函数名: l2tp_info\n- 参数: [struct l2tp_tunnel *tunnel, int L2TP_MSG_CONTROL, char *format, ...]\n- 调用者: l2tp_tunnel_closeall\n- 被调用者: 未明确（可能是日志打印函数）\n\n3. 函数名: hlist_for_each_safe\n- 参数: [struct hlist_node *walk, struct hlist_node *tmp, struct hlist_head *head]\n- 调用者: l2tp_tunnel_closeall\n- 被调用者: 未明确（宏定义遍历链表）\n\n4. 函数名: hlist_entry\n- 参数: [struct hlist_node *ptr, type, member]\n- 调用者: l2tp_tunnel_closeall\n- 被调用者: 未明确（宏定义获取结构体指针）\n\n5. 函数名: hlist_del_init\n- 参数: [struct hlist_node *n]\n- 调用者: l2tp_tunnel_closeall\n- 被调用者: 未明确（宏定义删除链表节点）\n\n6. 函数名: write_unlock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: l2tp_tunnel_closeall\n- 被调用者: 未明确（释放自旋锁）\n\n7. 函数名: __l2tp_session_unhash\n- 参数: [struct l2tp_session *session]\n- 调用者: l2tp_tunnel_closeall\n- 被调用者: 未明确（上下文未提供）\n\n8. 函数名: l2tp_session_queue_purge\n- 参数: [struct l2tp_session *session]\n- 调用者: l2tp_tunnel_closeall\n- 被调用者: 未明确（上下文未提供）\n\n9. 函数名: write_lock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: l2tp_tunnel_closeall\n- 被调用者: 未明确（获取自旋锁）\n\n10. 函数名: l2tp_session_dec_refcount\n- 参数: [struct l2tp_session *session]\n- 调用者: l2tp_tunnel_closeall\n- 被调用者: 未明确（减少引用计数）"
    },
    {
        "id": 2382,
        "cwe": "CWE-416",
        "cve": "CVE-2020-0429",
        "purpose": "Code purpose:\"\"\"该代码用于删除L2TP会话，包括解除会话关联、清理会话队列并释放相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放session内存后仍然可能通过回调函数deref继续访问该内存，导致释放后重用(use-after-free)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: l2tp_session_delete\n- 参数: [session]\n- 调用者: 未指定\n- 被调用者: [__l2tp_session_unhash, l2tp_session_queue_purge, l2tp_session_dec_refcount]\n\n2. 函数名: __l2tp_session_unhash\n- 参数: [session]\n- 调用者: l2tp_session_delete\n- 被调用者: 未指定\n\n3. 函数名: l2tp_session_queue_purge\n- 参数: [session]\n- 调用者: l2tp_session_delete\n- 被调用者: 未指定\n\n4. 函数名: l2tp_session_dec_refcount\n- 参数: [session]\n- 调用者: l2tp_session_delete\n- 被调用者: 未指定"
    },
    {
        "id": 2387,
        "cwe": "CWE-416",
        "cve": "CVE-2020-0433",
        "purpose": "Code purpose:\"\"\"该代码用于遍历请求队列中所有硬件队列的标签，并对忙碌标签执行回调函数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在blk_mq_queue_tag_busy_iter函数中未正确实现锁定机制，导致可能在使用已释放的内存时出现竞争条件，从而引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: blk_mq_queue_tag_busy_iter\n- 参数: [struct request_queue *q, busy_iter_fn *fn, void *priv]\n- 调用者: 未显示\n- 被调用者: [queue_for_each_hw_ctx, blk_mq_hw_queue_mapped, bt_for_each]\n\n2. 函数名: queue_for_each_hw_ctx\n- 参数: [struct request_queue *q, struct blk_mq_hw_ctx *hctx, int i]\n- 调用者: blk_mq_queue_tag_busy_iter\n- 被调用者: 未显示\n\n3. 函数名: blk_mq_hw_queue_mapped\n- 参数: [struct blk_mq_hw_ctx *hctx]\n- 调用者: blk_mq_queue_tag_busy_iter\n- 被调用者: 未显示\n\n4. 函数名: bt_for_each\n- 参数: [struct blk_mq_hw_ctx *hctx, &tags->breserved_tags, fn, priv, true] 或 [struct blk_mq_hw_ctx *hctx, &tags->bitmap_tags, fn, priv, false]\n- 调用者: blk_mq_queue_tag_busy_iter\n- 被调用者: 未显示"
    },
    {
        "id": 2388,
        "cwe": "CWE-416",
        "cve": "CVE-2020-0433",
        "purpose": "Code purpose:\"\"\"该代码用于动态更新块设备的多硬件队列数量，包括调整队列映射、重新分配硬件上下文以及重新初始化队列等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在blk_mq_queue_tag_busy_iter函数中锁机制使用不当，导致存在释放后使用(UAF)的问题\"\"\"",
        "functions": "Functions:\n1. 函数名: __blk_mq_update_nr_hw_queues\n- 参数: [struct blk_mq_tag_set *set, int nr_hw_queues]\n- 调用者: 未显示\n- 被调用者: [lockdep_assert_held, blk_mq_freeze_queue, blk_mq_elv_switch_none, blk_mq_update_queue_map, blk_mq_realloc_hw_ctxs, blk_mq_queue_reinit, blk_mq_elv_switch_back, blk_mq_unfreeze_queue]\n\n2. 函数名: lockdep_assert_held\n- 参数: [&set->tag_list_lock]\n- 调用者: __blk_mq_update_nr_hw_queues\n- 被调用者: 未显示\n\n3. 函数名: blk_mq_freeze_queue\n- 参数: [q]\n- 调用者: __blk_mq_update_nr_hw_queues\n- 被调用者: 未显示\n\n4. 函数名: blk_mq_elv_switch_none\n- 参数: [&head, q]\n- 调用者: __blk_mq_update_nr_hw_queues\n- 被调用者: 未显示\n\n5. 函数名: blk_mq_update_queue_map\n- 参数: [set]\n- 调用者: __blk_mq_update_nr_hw_queues\n- 被调用者: 未显示\n\n6. 函数名: blk_mq_realloc_hw_ctxs\n- 参数: [set, q]\n- 调用者: __blk_mq_update_nr_hw_queues\n- 被调用者: 未显示\n\n7. 函数名: blk_mq_queue_reinit\n- 参数: [q]\n- 调用者: __blk_mq_update_nr_hw_queues\n- 被调用者: 未显示\n\n8. 函数名: blk_mq_elv_switch_back\n- 参数: [&head, q]\n- 调用者: __blk_mq_update_nr_hw_queues\n- 被调用者: 未显示\n\n9. 函数名: blk_mq_unfreeze_queue\n- 参数: [q]\n- 调用者: __blk_mq_update_nr_hw_queues\n- 被调用者: 未显示"
    },
    {
        "id": 2394,
        "cwe": "CWE-416",
        "cve": "CVE-2020-0466",
        "purpose": "Code purpose:\"\"\"该代码实现了epoll文件描述符的控制操作，包括添加、修改和删除事件监听，并处理相关的循环检测和互斥锁管理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在do_epoll_ctl函数中存在逻辑错误，导致在epoll文件描述符操作期间可能发生释放后使用(use-after-free)的情况。\"\"\"",
        "functions": "Functions:\n1. 函数名: do_epoll_ctl\n- 参数: [epfd, op, fd, epds, nonblock]\n- 调用者: N/A (系统调用)\n- 被调用者: [fdget, file_can_poll, ep_op_has_event, ep_take_care_of_epollwakeup, is_file_epoll, epoll_mutex_lock, mutex_unlock, ep_loop_check, clear_tfile_check_list, get_file, list_add, list_del, fput, ep_find, ep_insert, ep_remove, ep_modify, fdput]\n\n2. 函数名: fdget\n- 参数: [fd]\n- 调用者: do_epoll_ctl\n- 被调用者: []\n\n3. 函数名: file_can_poll\n- 参数: [file]\n- 调用者: do_epoll_ctl\n- 被调用者: []\n\n4. 函数名: ep_op_has_event\n- 参数: [op]\n- 调用者: do_epoll_ctl\n- 被调用者: []\n\n5. 函数名: ep_take_care_of_epollwakeup\n- 参数: [epds]\n- 调用者: do_epoll_ctl\n- 被调用者: []\n\n6. 函数名: is_file_epoll\n- 参数: [file]\n- 调用者: do_epoll_ctl\n- 被调用者: []\n\n7. 函数名: epoll_mutex_lock\n- 参数: [mtx, flag, nonblock]\n- 调用者: do_epoll_ctl\n- 被调用者: []\n\n8. 函数名: mutex_unlock\n- 参数: [mtx]\n- 调用者: do_epoll_ctl\n- 被调用者: []\n\n9. 函数名: ep_loop_check\n- 参数: [ep, file]\n- 调用者: do_epoll_ctl\n- 被调用者: []\n\n10. 函数名: clear_tfile_check_list\n- 参数: []\n- 调用者: do_epoll_ctl\n- 被调用者: []\n\n11. 函数名: get_file\n- 参数: [file]\n- 调用者: do_epoll_ctl\n- 被调用者: []\n\n12. 函数名: list_add\n- 参数: [llink, list]\n- 调用者: do_epoll_ctl\n- 被调用者: []\n\n13. 函数名: list_del\n- 参数: [llink]\n- 调用者: do_epoll_ctl\n- 被调用者: []\n\n14. 函数名: fput\n- 参数: [file]\n- 调用者: do_epoll_ctl\n- 被调用者: []\n\n15. 函数名: ep_find\n- 参数: [ep, file, fd]\n- 调用者: do_epoll_ctl\n- 被调用者: []\n\n16. 函数名: ep_insert\n- 参数: [ep, epds, file, fd, full_check]\n- 调用者: do_epoll_ctl\n- 被调用者: []\n\n17. 函数名: ep_remove\n- 参数: [ep, epi]\n- 调用者: do_epoll_ctl\n- 被调用者: []\n\n18. 函数名: ep_modify\n- 参数: [ep, epi, epds]\n- 调用者: do_epoll_ctl\n- 被调用者: []\n\n19. 函数名: fdput\n- 参数: [fd]\n- 调用者: do_epoll_ctl\n- 被调用者: []"
    },
    {
        "id": 2398,
        "cwe": "CWE-416",
        "cve": "CVE-2020-10690",
        "purpose": "Code purpose:\"\"\"注册并初始化一个PTP(精确时间协议)时钟设备，包括创建相关设备文件、PPS(脉冲每秒)源和posix时钟，同时处理资源分配和错误情况。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于ptp_clock释放与cdev释放之间存在竞态条件，导致设备被移除后进程唤醒时访问了已释放的cdev结构，造成释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ptp_clock_register\n- 参数: [struct ptp_clock_info *info, struct device *parent]\n- 调用者: 无（顶级函数）\n- 被调用者: [ERR_PTR, kzalloc, ida_simple_get, MKDEV, spin_lock_init, mutex_init, init_waitqueue_head, kthread_init_delayed_work, kthread_create_worker, IS_ERR, PTR_ERR, pr_err, ptp_populate_pin_groups, device_create_with_groups, memset, snprintf, pps_register_source, posix_clock_register, pps_unregister_source, device_destroy, ptp_cleanup_pin_groups, kthread_destroy_worker, mutex_destroy, ida_simple_remove, kfree]\n\n2. 函数名: delete_ptp_clock\n- 参数: 无（通过ptp->clock.release间接调用）\n- 调用者: ptp_clock_register（通过clock.release指针）\n- 被调用者: 无（在代码片段中未显示具体实现）\n\n3. 函数名: ptp_aux_kworker\n- 参数: 无（通过kthread_init_delayed_work间接调用）\n- 调用者: ptp_clock_register（通过kthread_init_delayed_work）\n- 被调用者: 无（在代码片段中未显示具体实现）\n\n4. 函数名: ptp_populate_pin_groups\n- 参数: [struct ptp_clock *ptp]\n- 调用者: ptp_clock_register\n- 被调用者: 无（在代码片段中未显示具体实现）\n\n5. 函数名: ptp_cleanup_pin_groups\n- 参数: [struct ptp_clock *ptp]\n- 调用者: ptp_clock_register\n- 被调用者: 无（在代码片段中未显示具体实现）"
    },
    {
        "id": 2399,
        "cwe": "CWE-416",
        "cve": "CVE-2020-10690",
        "purpose": "Code purpose:\"\"\"注销PTP时钟设备并释放相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于ptp_clock释放和cdev释放之间存在竞态条件，导致在资源释放过程中可能发生释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ptp_clock_unregister\n- 参数: [struct ptp_clock *ptp]\n- 调用者: 未指定\n- 被调用者: [wake_up_interruptible, kthread_cancel_delayed_work_sync, kthread_destroy_worker, pps_unregister_source, device_destroy, ptp_cleanup_pin_groups, posix_clock_unregister]\n\n2. 函数名: wake_up_interruptible\n- 参数: [&ptp->tsev_wq]\n- 调用者: ptp_clock_unregister\n- 被调用者: 未指定\n\n3. 函数名: kthread_cancel_delayed_work_sync\n- 参数: [&ptp->aux_work]\n- 调用者: ptp_clock_unregister\n- 被调用者: 未指定\n\n4. 函数名: kthread_destroy_worker\n- 参数: [ptp->kworker]\n- 调用者: ptp_clock_unregister\n- 被调用者: 未指定\n\n5. 函数名: pps_unregister_source\n- 参数: [ptp->pps_source]\n- 调用者: ptp_clock_unregister\n- 被调用者: 未指定\n\n6. 函数名: device_destroy\n- 参数: [ptp_class, ptp->devid]\n- 调用者: ptp_clock_unregister\n- 被调用者: 未指定\n\n7. 函数名: ptp_cleanup_pin_groups\n- 参数: [ptp]\n- 调用者: ptp_clock_unregister\n- 被调用者: 未指定\n\n8. 函数名: posix_clock_unregister\n- 参数: [&ptp->clock]\n- 调用者: ptp_clock_unregister\n- 被调用者: 未指定"
    },
    {
        "id": 2400,
        "cwe": "CWE-416",
        "cve": "CVE-2020-10690",
        "purpose": "Code purpose:\"\"\"释放posix时钟资源并减少引用计数，最后清空文件指针的私有数据\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在释放posix_clock时存在竞态条件，导致在资源释放过程中可能发生use-after-free，当高权限进程分配ptp设备文件后设备被移除时，会访问已释放的cdev结构体。\"\"\"",
        "functions": "Functions:\n1. 函数名: posix_clock_release\n- 参数: [struct inode *inode, struct file *fp]\n- 调用者: 未明确（通常是文件系统操作调用）\n- 被调用者: [kref_put, delete_clock]\n\n2. 函数名: delete_clock\n- 参数: [struct posix_clock *clk]（通过kref_put间接调用）\n- 调用者: kref_put\n- 被调用者: 未明确\n\n3. 函数名: kref_put\n- 参数: [struct kref *kref, void (*release)(struct kref *kref)]\n- 调用者: posix_clock_release\n- 被调用者: [delete_clock]\n\n4. 函数名: release\n- 参数: [struct posix_clock *clk]\n- 调用者: posix_clock_release\n- 被调用者: 未明确"
    },
    {
        "id": 2401,
        "cwe": "CWE-416",
        "cve": "CVE-2020-10690",
        "purpose": "Code purpose:\"\"\"该代码用于注销POSIX时钟设备，包括删除字符设备、设置僵尸标志并释放时钟资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在释放ptp_clock和cdev资源时存在竞态条件，导致cdev结构体在被释放后仍可能被访问，从而引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: posix_clock_unregister\n- 参数: [struct posix_clock *clk]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [cdev_del, down_write, up_write, kref_put]\n\n2. 函数名: cdev_del\n- 参数: [&clk->cdev]\n- 调用者: posix_clock_unregister\n- 被调用者: 未显示\n\n3. 函数名: down_write\n- 参数: [&clk->rwsem]\n- 调用者: posix_clock_unregister\n- 被调用者: 未显示\n\n4. 函数名: up_write\n- 参数: [&clk->rwsem]\n- 调用者: posix_clock_unregister\n- 被调用者: 未显示\n\n5. 函数名: kref_put\n- 参数: [&clk->kref, delete_clock]\n- 调用者: posix_clock_unregister\n- 被调用者: [delete_clock]\n\n6. 函数名: delete_clock\n- 参数: 未显示（通过kref_put调用）\n- 调用者: kref_put\n- 被调用者: 未显示"
    },
    {
        "id": 2402,
        "cwe": "CWE-416",
        "cve": "CVE-2020-10690",
        "purpose": "Code purpose:\"\"\"该代码实现了POSIX时钟设备的打开功能，包括检查设备状态、执行打开操作并管理引用计数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于ptp_clock释放与cdev资源释放之间存在竞争条件，导致进程唤醒时访问了已被释放的cdev结构，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: posix_clock_open\n- 参数: [struct inode *inode, struct file *fp]\n- 调用者: 不适用（内核调用）\n- 被调用者: [container_of, down_read, up_read, kref_get]\n\n2. 函数名: container_of\n- 参数: [inode->i_cdev, struct posix_clock, cdev]\n- 调用者: posix_clock_open\n- 被调用者: []\n\n3. 函数名: down_read\n- 参数: [&clk->rwsem]\n- 调用者: posix_clock_open\n- 被调用者: []\n\n4. 函数名: up_read\n- 参数: [&clk->rwsem]\n- 调用者: posix_clock_open\n- 被调用者: []\n\n5. 函数名: kref_get\n- 参数: [&clk->kref]\n- 调用者: posix_clock_open\n- 被调用者: []"
    },
    {
        "id": 2407,
        "cwe": "CWE-416",
        "cve": "CVE-2020-10720",
        "purpose": "Code purpose:\"\"\"该代码片段实现了Linux内核中GRO(Generic Receive Offload)功能，用于处理网络数据包的接收和重组，以提高网络性能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核GRO实现中，由于未正确处理skb缓冲区，可能导致释放后重用(use-after-free)漏洞，攻击者可利用此漏洞使系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: napi_frags_skb\n- 参数: [struct napi_struct *napi]\n- 调用者: 未提供\n- 被调用者: [skb_reset_mac_header, skb_gro_reset_offset, skb_gro_header_fast, skb_gro_header_hard, skb_gro_header_slow, net_warn_ratelimited, napi_reuse_skb, gro_pull_from_frag0, __skb_pull]\n\n2. 函数名: skb_reset_mac_header\n- 参数: [struct sk_buff *skb]\n- 调用者: napi_frags_skb\n- 被调用者: 未提供\n\n3. 函数名: skb_gro_reset_offset\n- 参数: [struct sk_buff *skb]\n- 调用者: napi_frags_skb\n- 被调用者: 未提供\n\n4. 函数名: skb_gro_header_fast\n- 参数: [struct sk_buff *skb, int offset]\n- 调用者: napi_frags_skb\n- 被调用者: 未提供\n\n5. 函数名: skb_gro_header_hard\n- 参数: [struct sk_buff *skb, unsigned int hlen]\n- 调用者: napi_frags_skb\n- 被调用者: 未提供\n\n6. 函数名: skb_gro_header_slow\n- 参数: [struct sk_buff *skb, unsigned int hlen, int offset]\n- 调用者: napi_frags_skb\n- 被调用者: 未提供\n\n7. 函数名: net_warn_ratelimited\n- 参数: [const char *format, ...]\n- 调用者: napi_frags_skb\n- 被调用者: 未提供\n\n8. 函数名: napi_reuse_skb\n- 参数: [struct napi_struct *napi, struct sk_buff *skb]\n- 调用者: napi_frags_skb\n- 被调用者: 未提供\n\n9. 函数名: gro_pull_from_frag0\n- 参数: [struct sk_buff *skb, unsigned int hlen]\n- 调用者: napi_frags_skb\n- 被调用者: 未提供\n\n10. 函数名: __skb_pull\n- 参数: [struct sk_buff *skb, unsigned int len]\n- 调用者: napi_frags_skb\n- 被调用者: 未提供"
    },
    {
        "id": 2470,
        "cwe": "CWE-416",
        "cve": "CVE-2020-12464",
        "purpose": "Code purpose:\"\"\"取消USB批量传输请求并释放相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在取消USB传输请求时，未正确维护urb对象的引用计数，导致在释放后仍可能被访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: usb_sg_cancel\n- 参数: [struct usb_sg_request *io]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [spin_lock_irqsave, spin_unlock_irqrestore, usb_block_urb, usb_unlink_urb, dev_warn]\n\n2. 函数名: spin_lock_irqsave\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: usb_sg_cancel\n- 被调用者: []\n\n3. 函数名: spin_unlock_irqrestore\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: usb_sg_cancel\n- 被调用者: []\n\n4. 函数名: usb_block_urb\n- 参数: [struct urb *urb]\n- 调用者: usb_sg_cancel\n- 被调用者: []\n\n5. 函数名: usb_unlink_urb\n- 参数: [struct urb *urb]\n- 调用者: usb_sg_cancel\n- 被调用者: []\n\n6. 函数名: dev_warn\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: usb_sg_cancel\n- 被调用者: []"
    },
    {
        "id": 2479,
        "cwe": "CWE-416",
        "cve": "CVE-2020-12657",
        "purpose": "Code purpose:\"\"\"该代码用于处理BFQ调度器中空闲时间片的定时器到期事件，通过调用bfq_idle_slice_timer_body函数来处理当前服务队列的空闲状态。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在bfq_idle_slice_timer函数中，由于存在竞态条件导致in_service_queue指针可能在被释放后仍被使用，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: bfq_idle_slice_timer\n- 参数: [timer]\n- 调用者: hrtimer系统（内核定时器机制）\n- 被调用者: [bfq_idle_slice_timer_body]\n\n2. 函数名: bfq_idle_slice_timer_body\n- 参数: [bfqq]\n- 调用者: bfq_idle_slice_timer\n- 被调用者: []"
    },
    {
        "id": 2512,
        "cwe": "CWE-416",
        "cve": "CVE-2020-14351",
        "purpose": "Code purpose:\"\"\"该代码用于处理Linux内核中perf子系统的内存映射关闭操作，包括释放相关资源和进行内存管理，但存在释放后使用的漏洞风险。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在perf_mmap_close函数中存在use-after-free漏洞，由于在释放环形缓冲区(rb)后仍可能被其他事件引用，导致内存损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: perf_mmap_close\n- 参数: [struct vm_area_struct *vma]\n- 调用者: 未明确（由内核调用）\n- 被调用者: [ring_buffer_get, perf_data_size, rb_has_aux, atomic_dec_and_mutex_lock, perf_pmu_output_stop, atomic_long_sub, atomic64_sub, rb_free_aux, refcount_read, mutex_unlock, atomic_dec, atomic_dec_and_mutex_lock, ring_buffer_attach, atomic_read, rcu_read_lock, list_for_each_entry_rcu, atomic_long_inc_not_zero, rcu_read_unlock, mutex_lock, put_event, free_uid, ring_buffer_put]\n\n2. 函数名: ring_buffer_get\n- 参数: [struct perf_event *event]\n- 调用者: perf_mmap_close\n- 被调用者: []\n\n3. 函数名: perf_data_size\n- 参数: [struct perf_buffer *rb]\n- 调用者: perf_mmap_close\n- 被调用者: []\n\n4. 函数名: rb_has_aux\n- 参数: [struct perf_buffer *rb]\n- 调用者: perf_mmap_close\n- 被调用者: []\n\n5. 函数名: atomic_dec_and_mutex_lock\n- 参数: [&rb->aux_mmap_count, &event->mmap_mutex]\n- 调用者: perf_mmap_close\n- 被调用者: []\n\n6. 函数名: perf_pmu_output_stop\n- 参数: [struct perf_event *event]\n- 调用者: perf_mmap_close\n- 被调用者: []\n\n7. 函数名: atomic_long_sub\n- 参数: [rb->aux_nr_pages - rb->aux_mmap_locked, &mmap_user->locked_vm]\n- 调用者: perf_mmap_close\n- 被调用者: []\n\n8. 函数名: atomic64_sub\n- 参数: [rb->aux_mmap_locked, &vma->vm_mm->pinned_vm]\n- 调用者: perf_mmap_close\n- 被调用者: []\n\n9. 函数名: rb_free_aux\n- 参数: [struct perf_buffer *rb]\n- 调用者: perf_mmap_close\n- 被调用者: []\n\n10. 函数名: refcount_read\n- 参数: [&rb->aux_refcount]\n- 调用者: perf_mmap_close\n- 被调用者: []\n\n11. 函数名: mutex_unlock\n- 参数: [&event->mmap_mutex]\n- 调用者: perf_mmap_close\n- 被调用者: []\n\n12. 函数名: atomic_dec\n- 参数: [&rb->mmap_count]\n- 调用者: perf_mmap_close\n- 被调用者: []\n\n13. 函数名: ring_buffer_attach\n- 参数: [struct perf_event *event, NULL]\n- 调用者: perf_mmap_close\n- 被调用者: []\n\n14. 函数名: atomic_read\n- 参数: [&rb->mmap_count]\n- 调用者: perf_mmap_close\n- 被调用者: []\n\n15. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: perf_mmap_close\n- 被调用者: []\n\n16. 函数名: list_for_each_entry_rcu\n- 参数: [event, &rb->event_list, rb_entry]\n- 调用者: perf_mmap_close\n- 被调用者: []\n\n17. 函数名: atomic_long_inc_not_zero\n- 参数: [&event->refcount]\n- 调用者: perf_mmap_close\n- 被调用者: []\n\n18. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: perf_mmap_close\n- 被调用者: []\n\n19. 函数名: mutex_lock\n- 参数: [&event->mmap_mutex]\n- 调用者: perf_mmap_close\n- 被调用者: []\n\n20. 函数名: put_event\n- 参数: [event]\n- 调用者: perf_mmap_close\n- 被调用者: []\n\n21. 函数名: free_uid\n- 参数: [mmap_user]\n- 调用者: perf_mmap_close\n- 被调用者: []\n\n22. 函数名: ring_buffer_put\n- 参数: [struct perf_buffer *rb]\n- 调用者: perf_mmap_close\n- 被调用者: []"
    },
    {
        "id": 2519,
        "cwe": "CWE-416",
        "cve": "CVE-2020-14381",
        "purpose": "Code purpose:\"\"\"初始化inode结构体，设置文件系统inode的默认属性和操作函数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在文件系统即将卸载时创建futex，由于未正确处理inode初始化与内存释放的竞争条件，导致内存损坏或权限提升漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: inode_init_always\n- 参数: [struct super_block *sb, struct inode *inode]\n- 调用者: 未明确（通常是文件系统相关操作调用）\n- 被调用者: [atomic_set, i_uid_write, i_gid_write, security_inode_alloc, spin_lock_init, lockdep_set_class, init_rwsem, mapping_set_gfp_mask, INIT_HLIST_HEAD, this_cpu_inc]\n\n2. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: inode_init_always\n- 被调用者: 无\n\n3. 函数名: i_uid_write\n- 参数: [struct inode *inode, uid_t uid]\n- 调用者: inode_init_always\n- 被调用者: 无\n\n4. 函数名: i_gid_write\n- 参数: [struct inode *inode, gid_t gid]\n- 调用者: inode_init_always\n- 被调用者: 无\n\n5. 函数名: security_inode_alloc\n- 参数: [struct inode *inode]\n- 调用者: inode_init_always\n- 被调用者: 无\n\n6. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: inode_init_always\n- 被调用者: 无\n\n7. 函数名: lockdep_set_class\n- 参数: [struct lockdep_map *lock, struct lock_class_key *key]\n- 调用者: inode_init_always\n- 被调用者: 无\n\n8. 函数名: init_rwsem\n- 参数: [struct rw_semaphore *sem]\n- 调用者: inode_init_always\n- 被调用者: 无\n\n9. 函数名: mapping_set_gfp_mask\n- 参数: [struct address_space *mapping, gfp_t mask]\n- 调用者: inode_init_always\n- 被调用者: 无\n\n10. 函数名: INIT_HLIST_HEAD\n- 参数: [struct hlist_head *h]\n- 调用者: inode_init_always\n- 被调用者: 无\n\n11. 函数名: this_cpu_inc\n- 参数: [type]\n- 调用者: inode_init_always\n- 被调用者: 无"
    },
    {
        "id": 2520,
        "cwe": "CWE-416",
        "cve": "CVE-2020-14381",
        "purpose": "Code purpose:\"\"\"管理futex键的引用计数，确保在多线程环境下对inode或内存管理结构的正确访问\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在文件系统即将卸载时创建futex，由于未正确处理引用计数和内存屏障，导致内存损坏或权限提升漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: get_futex_key_refs\n- 参数: [key]\n- 调用者: 未明确显示（由内核其他部分调用）\n- 被调用者: [ihold, futex_get_mm, smp_mb]\n\n2. 函数名: ihold\n- 参数: [key->shared.inode]\n- 调用者: get_futex_key_refs\n- 被调用者: 未明确显示\n\n3. 函数名: futex_get_mm\n- 参数: [key]\n- 调用者: get_futex_key_refs\n- 被调用者: 未明确显示\n\n4. 函数名: smp_mb\n- 参数: []\n- 调用者: get_futex_key_refs\n- 被调用者: 未明确显示"
    },
    {
        "id": 2521,
        "cwe": "CWE-416",
        "cve": "CVE-2020-14381",
        "purpose": "Code purpose:\"\"\"释放futex键的引用计数，处理与inode或内存管理结构相关的资源释放\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在文件系统即将卸载时创建futex，由于未正确处理key引用计数导致内存损坏或权限提升漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: drop_futex_key_refs\n- 参数: [key]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [WARN_ON_ONCE, iput, mmdrop]\n\n2. 函数名: WARN_ON_ONCE\n- 参数: [1]\n- 调用者: drop_futex_key_refs\n- 被调用者: []\n\n3. 函数名: iput\n- 参数: [key->shared.inode]\n- 调用者: drop_futex_key_refs\n- 被调用者: []\n\n4. 函数名: mmdrop\n- 参数: [key->private.mm]\n- 调用者: drop_futex_key_refs\n- 被调用者: []"
    },
    {
        "id": 2522,
        "cwe": "CWE-416",
        "cve": "CVE-2020-14381",
        "purpose": "Code purpose:\"\"\"该代码用于获取futex键值，处理用户空间地址到内核空间地址的映射关系，支持私有和共享内存区域的futex操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在文件系统即将卸载时创建futex，由于未正确处理inode引用计数和内存映射状态，导致内存损坏或权限提升漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: get_futex_key\n- 参数: [u32 __user *uaddr, int fshared, union futex_key *key, enum futex_access rw]\n- 调用者: (未明确显示，应为内核中调用futex相关操作的函数)\n- 被调用者: [access_ok, should_fail_futex, get_futex_key_refs, get_user_pages_fast, compound_head, READ_ONCE, lock_page, PageSwapCache, unlock_page, put_page, PageAnon, atomic_inc_not_zero, WARN_ON_ONCE, iput, basepage_index]\n\n2. 函数名: access_ok\n- 参数: [未显示完整参数]\n- 调用者: get_futex_key\n- 被调用者: []\n\n3. 函数名: should_fail_futex\n- 参数: [int fshared]\n- 调用者: get_futex_key\n- 被调用者: []\n\n4. 函数名: get_futex_key_refs\n- 参数: [union futex_key *key]\n- 调用者: get_futex_key\n- 被调用者: []\n\n5. 函数名: get_user_pages_fast\n- 参数: [unsigned long address, int nr_pages, int write, struct page **pages]\n- 调用者: get_futex_key\n- 被调用者: []\n\n6. 函数名: compound_head\n- 参数: [struct page *page]\n- 调用者: get_futex_key\n- 被调用者: []\n\n7. 函数名: READ_ONCE\n- 参数: [variable]\n- 调用者: get_futex_key\n- 被调用者: []\n\n8. 函数名: lock_page\n- 参数: [struct page *page]\n- 调用者: get_futex_key\n- 被调用者: []\n\n9. 函数名: PageSwapCache\n- 参数: [struct page *page]\n- 调用者: get_futex_key\n- 被调用者: []\n\n10. 函数名: unlock_page\n- 参数: [struct page *page]\n- 调用者: get_futex_key\n- 被调用者: []\n\n11. 函数名: put_page\n- 参数: [struct page *page]\n- 调用者: get_futex_key\n- 被调用者: []\n\n12. 函数名: PageAnon\n- 参数: [struct page *page]\n- 调用者: get_futex_key\n- 被调用者: []\n\n13. 函数名: atomic_inc_not_zero\n- 参数: [atomic_t *v]\n- 调用者: get_futex_key\n- 被调用者: []\n\n14. 函数名: WARN_ON_ONCE\n- 参数: [condition]\n- 调用者: get_futex_key\n- 被调用者: []\n\n15. 函数名: iput\n- 参数: [struct inode *inode]\n- 调用者: get_futex_key\n- 被调用者: []\n\n16. 函数名: basepage_index\n- 参数: [struct page *tail]\n- 调用者: get_futex_key\n- 被调用者: []"
    },
    {
        "id": 2540,
        "cwe": "CWE-416",
        "cve": "CVE-2020-14416",
        "purpose": "Code purpose:\"\"\"该代码片段实现了slcan线路规程的关闭功能，包括断开连接、清理资源并注销网络设备。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在slcan_close函数中存在竞态条件，当处理tty->disc_data时未充分保护，可能导致释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: slcan_close\n- 参数: [struct tty_struct *tty]\n- 调用者: 未指定（通常由TTY子系统调用）\n- 被调用者: [spin_lock_bh, spin_unlock_bh, flush_work, unregister_netdev]\n\n2. 函数名: spin_lock_bh\n- 参数: [&sl->lock]\n- 调用者: slcan_close\n- 被调用者: []\n\n3. 函数名: spin_unlock_bh\n- 参数: [&sl->lock]\n- 调用者: slcan_close\n- 被调用者: []\n\n4. 函数名: flush_work\n- 参数: [&sl->tx_work]\n- 调用者: slcan_close\n- 被调用者: []\n\n5. 函数名: unregister_netdev\n- 参数: [sl->dev]\n- 调用者: slcan_close\n- 被调用者: []"
    },
    {
        "id": 2541,
        "cwe": "CWE-416",
        "cve": "CVE-2020-14416",
        "purpose": "Code purpose:\"\"\"在Linux内核中调度slcan设备的传输工作队列\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在slcan_write_wakeup函数中未对tty->disc_data进行空指针或有效性检查，导致在竞态条件下可能发生use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: slcan_write_wakeup\n- 参数: [struct tty_struct *tty]\n- 调用者: 未明确（通常由TTY子系统调用）\n- 被调用者: [schedule_work]\n\n2. 函数名: schedule_work\n- 参数: [&sl->tx_work]\n- 调用者: slcan_write_wakeup\n- 被调用者: 未明确（内核工作队列相关函数）"
    },
    {
        "id": 2543,
        "cwe": "CWE-416",
        "cve": "CVE-2020-15436",
        "purpose": "Code purpose:\"\"\"管理块设备的打开操作，包括权限检查、磁盘分区处理以及设备状态维护\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在错误处理路径中未正确清理块设备结构体引用，导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: __blkdev_get\n- 参数: [struct block_device *bdev, fmode_t mode, int for_part]\n- 调用者: 无（顶级函数）\n- 被调用者: [devcgroup_inode_permission, bdev_get_gendisk, disk_block_events, disk_get_part, disk->fops->open, disk_put_part, put_disk_and_module, bd_set_size, set_init_blocksize, bdev_disk_changed, bdget_disk, __blkdev_get, bdi_get, __blkdev_put, bdput]\n\n2. 函数名: devcgroup_inode_permission\n- 参数: [struct inode *bdev->bd_inode, int perm]\n- 调用者: __blkdev_get\n- 被调用者: 无\n\n3. 函数名: bdev_get_gendisk\n- 参数: [struct block_device *bdev, int *partno]\n- 调用者: __blkdev_get\n- 被调用者: 无\n\n4. 函数名: disk_block_events\n- 参数: [struct gendisk *disk]\n- 调用者: __blkdev_get\n- 被调用者: 无\n\n5. 函数名: disk_get_part\n- 参数: [struct gendisk *disk, int partno]\n- 调用者: __blkdev_get\n- 被调用者: 无\n\n6. 函数名: disk->fops->open\n- 参数: [struct block_device *bdev, fmode_t mode]\n- 调用者: __blkdev_get\n- 被调用者: 无\n\n7. 函数名: disk_put_part\n- 参数: [struct hd_struct *bdev->bd_part]\n- 调用者: __blkdev_get\n- 被调用者: 无\n\n8. 函数名: put_disk_and_module\n- 参数: [struct gendisk *disk]\n- 调用者: __blkdev_get\n- 被调用者: 无\n\n9. 函数名: bd_set_size\n- 参数: [struct block_device *bdev, loff_t size]\n- 调用者: __blkdev_get\n- 被调用者: 无\n\n10. 函数名: set_init_blocksize\n- 参数: [struct block_device *bdev]\n- 调用者: __blkdev_get\n- 被调用者: 无\n\n11. 函数名: bdev_disk_changed\n- 参数: [struct block_device *bdev, bool invalidated]\n- 调用者: __blkdev_get\n- 被调用者: 无\n\n12. 函数名: bdget_disk\n- 参数: [struct gendisk *disk, int partno]\n- 调用者: __blkdev_get\n- 被调用者: 无\n\n13. 函数名: bdi_get\n- 参数: [struct backing_dev_info *disk->queue->backing_dev_info]\n- 调用者: __blkdev_get\n- 被调用者: 无\n\n14. 函数名: __blkdev_put\n- 参数: [struct block_device *bdev->bd_contains, fmode_t mode, int for_part]\n- 调用者: __blkdev_get\n- 被调用者: 无\n\n15. 函数名: bdput\n- 参数: [struct block_device *bdev]\n- 调用者: __blkdev_get\n- 被调用者: 无"
    },
    {
        "id": 2544,
        "cwe": "CWE-416",
        "cve": "CVE-2020-15436",
        "purpose": "Code purpose:\"\"\"该代码用于获取块设备引用并处理独占模式下的设备声明，同时管理设备的写入持有者和事件阻塞状态。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在错误处理路径中未正确释放资源，导致在后续操作中可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: blkdev_get\n- 参数: [bdev, mode, holder]\n- 调用者: N/A\n- 被调用者: [bd_start_claiming, bdput, __blkdev_get, bd_finish_claiming, bd_abort_claiming, mutex_lock, mutex_unlock, disk_block_events]\n\n2. 函数名: bd_start_claiming\n- 参数: [bdev, holder]\n- 调用者: blkdev_get\n- 被调用者: N/A\n\n3. 函数名: bdput\n- 参数: [bdev]\n- 调用者: blkdev_get\n- 被调用者: N/A\n\n4. 函数名: __blkdev_get\n- 参数: [bdev, mode, 0]\n- 调用者: blkdev_get\n- 被调用者: N/A\n\n5. 函数名: bd_finish_claiming\n- 参数: [bdev, whole, holder]\n- 调用者: blkdev_get\n- 被调用者: N/A\n\n6. 函数名: bd_abort_claiming\n- 参数: [bdev, whole, holder]\n- 调用者: blkdev_get\n- 被调用者: N/A\n\n7. 函数名: mutex_lock\n- 参数: [&bdev->bd_mutex]\n- 调用者: blkdev_get\n- 被调用者: N/A\n\n8. 函数名: mutex_unlock\n- 参数: [&bdev->bd_mutex]\n- 调用者: blkdev_get\n- 被调用者: N/A\n\n9. 函数名: disk_block_events\n- 参数: [disk]\n- 调用者: blkdev_get\n- 被调用者: N/A"
    },
    {
        "id": 2548,
        "cwe": "CWE-416",
        "cve": "CVE-2020-16119",
        "purpose": "Code purpose:\"\"\"创建一个新的DCCP子socket来处理传入的连接请求，并初始化相关参数和特性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"DCCP套接字在释放后作为监听器被重用，导致已附加的dccps_hc_tx_ccid对象出现释放后使用(UAF)问题\"\"\"",
        "functions": "Functions:\n1. 函数名: dccp_create_openreq_child\n- 参数: [sk, req, skb]\n- 调用者: 未明确（应为DCCP协议栈相关代码）\n- 被调用者: [inet_csk_clone_lock, dccp_rsk, inet_csk, dccp_sk, sk_free_unlock_clone, dccp_feat_activate_values, dccp_init_xmit_timers, __DCCP_INC_STATS]\n\n2. 函数名: inet_csk_clone_lock\n- 参数: [sk, req, GFP_ATOMIC]\n- 调用者: dccp_create_openreq_child\n- 被调用者: []\n\n3. 函数名: dccp_rsk\n- 参数: [req]\n- 调用者: dccp_create_openreq_child\n- 被调用者: []\n\n4. 函数名: inet_csk\n- 参数: [newsk]\n- 调用者: dccp_create_openreq_child\n- 被调用者: []\n\n5. 函数名: dccp_sk\n- 参数: [newsk]\n- 调用者: dccp_create_openreq_child\n- 被调用者: []\n\n6. 函数名: sk_free_unlock_clone\n- 参数: [newsk]\n- 调用者: dccp_create_openreq_child\n- 被调用者: []\n\n7. 函数名: dccp_feat_activate_values\n- 参数: [newsk, &dreq->dreq_featneg]\n- 调用者: dccp_create_openreq_child\n- 被调用者: []\n\n8. 函数名: dccp_init_xmit_timers\n- 参数: [newsk]\n- 调用者: dccp_create_openreq_child\n- 被调用者: []\n\n9. 函数名: __DCCP_INC_STATS\n- 参数: [DCCP_MIB_PASSIVEOPENS]\n- 调用者: dccp_create_openreq_child\n- 被调用者: []"
    },
    {
        "id": 2580,
        "cwe": "CWE-416",
        "cve": "CVE-2020-25220",
        "purpose": "Code purpose:\"\"\"该代码片段用于在克隆套接字时处理其关联的cgroup引用计数，确保即使cgroup已被删除也能正确获取引用。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在回补CVE-2020-14356补丁时未考虑skcd->no_refcnt标志，导致cgroup引用计数处理不当引发释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: cgroup_sk_clone\n- 参数: [struct sock_cgroup_data *skcd]\n- 调用者: 未明确（通常是内核中socket克隆相关代码）\n- 被调用者: [cgroup_get, sock_cgroup_ptr]\n\n2. 函数名: cgroup_get\n- 参数: [未明确（由sock_cgroup_ptr返回值传入）]\n- 调用者: cgroup_sk_clone\n- 被调用者: []\n\n3. 函数名: sock_cgroup_ptr\n- 参数: [struct sock_cgroup_data *skcd]\n- 调用者: cgroup_sk_clone\n- 被调用者: []"
    },
    {
        "id": 2593,
        "cwe": "CWE-416",
        "cve": "CVE-2020-25656",
        "purpose": "Code purpose:\"\"\"处理键盘功能键的输入输出控制，包括获取和设置键盘功能键字符串\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在KDGKBSENT和KDSKBSENT ioctl操作中存在释放后使用(UAF)漏洞，导致本地用户可越界读取内存数据。\"\"\"",
        "functions": "Functions:\n1. 函数名: vt_do_kdgkb_ioctl\n- 参数: [cmd, user_kdgkb, perm]\n- 调用者: 未显示\n- 被调用者: [capable, kmalloc, copy_from_user, array_index_nospec, copy_to_user, spin_lock_irqsave, memmove, spin_unlock_irqrestore, kfree, strcpy]\n\n2. 函数名: capable\n- 参数: [CAP_SYS_TTY_CONFIG]\n- 调用者: vt_do_kdgkb_ioctl\n- 被调用者: 未显示\n\n3. 函数名: kmalloc\n- 参数: [sizeof(*kbs), GFP_KERNEL]\n- 调用者: vt_do_kdgkb_ioctl\n- 被调用者: 未显示\n\n4. 函数名: copy_from_user\n- 参数: [kbs, user_kdgkb, sizeof(struct kbsentry)]\n- 调用者: vt_do_kdgkb_ioctl\n- 被调用者: 未显示\n\n5. 函数名: array_index_nospec\n- 参数: [kbs->kb_func, MAX_NR_FUNC]\n- 调用者: vt_do_kdgkb_ioctl\n- 被调用者: 未显示\n\n6. 函数名: copy_to_user\n- 参数: [user_kdgkb->kb_string, from, strlen(from) + 1]\n- 调用者: vt_do_kdgkb_ioctl\n- 被调用者: 未显示\n\n7. 函数名: spin_lock_irqsave\n- 参数: [&func_buf_lock, flags]\n- 调用者: vt_do_kdgkb_ioctl\n- 被调用者: 未显示\n\n8. 函数名: memmove\n- 参数: [fj + delta, fj, first_free - fj] 和 [fnw, funcbufptr, fj - funcbufptr] 和 [fnw + (fj - funcbufptr) + delta, fj, first_free - fj]\n- 调用者: vt_do_kdgkb_ioctl\n- 被调用者: 未显示\n\n9. 函数名: spin_unlock_irqrestore\n- 参数: [&func_buf_lock, flags]\n- 调用者: vt_do_kdgkb_ioctl\n- 被调用者: 未显示\n\n10. 函数名: kfree\n- 参数: [fnw] 和 [funcbufptr] 和 [kbs]\n- 调用者: vt_do_kdgkb_ioctl\n- 被调用者: 未显示\n\n11. 函数名: strcpy\n- 参数: [func_table[i], kbs->kb_string]\n- 调用者: vt_do_kdgkb_ioctl\n- 被调用者: 未显示"
    },
    {
        "id": 2594,
        "cwe": "CWE-416",
        "cve": "CVE-2020-25656",
        "purpose": "Code purpose:\"\"\"该代码用于处理键盘功能键的输入，根据输入值从功能表中选择对应的字符串并放入输出队列\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在控制台子系统中处理ioctls KDGKBSENT和KDSKBSENT时存在释放后使用问题，导致内存越界读取访问。\"\"\"",
        "functions": "Functions:\n1. 函数名: k_fn\n- 参数: [vc, value, up_flag]\n- 调用者: 未明确显示（应为处理键盘输入的调用链）\n- 被调用者: [puts_queue, pr_err]\n\n2. 函数名: puts_queue\n- 参数: 未显示完整（至少包含vc和字符串参数）\n- 调用者: k_fn\n- 被调用者: []\n\n3. 函数名: pr_err\n- 参数: [格式化字符串]\n- 调用者: k_fn\n- 被调用者: []"
    },
    {
        "id": 2596,
        "cwe": "CWE-416",
        "cve": "CVE-2020-25669",
        "purpose": "Code purpose:\"\"\"处理Sun键盘的中断请求，包括重置、布局设置和按键事件处理，并将按键状态报告给输入子系统\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在sunkbd_interrupt函数中调度sunkbd_reinit后，sunkbd被释放但sunkbd_reinit中仍保留了对sunkbd的引用，导致释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: sunkbd_interrupt\n- 参数: [serio, data, flags]\n- 调用者: 中断处理系统\n- 被调用者: [serio_get_drvdata, wake_up_interruptible, schedule_work, input_report_key, input_sync, printk]\n\n2. 函数名: serio_get_drvdata\n- 参数: [serio]\n- 调用者: sunkbd_interrupt\n- 被调用者: []\n\n3. 函数名: wake_up_interruptible\n- 参数: [&sunkbd->wait]\n- 调用者: sunkbd_interrupt\n- 被调用者: []\n\n4. 函数名: schedule_work\n- 参数: [&sunkbd->tq]\n- 调用者: sunkbd_interrupt\n- 被调用者: []\n\n5. 函数名: input_report_key\n- 参数: [sunkbd->dev, sunkbd->keycode[data & SUNKBD_KEY], !(data & SUNKBD_RELEASE)]\n- 调用者: sunkbd_interrupt\n- 被调用者: []\n\n6. 函数名: input_sync\n- 参数: [sunkbd->dev]\n- 调用者: sunkbd_interrupt\n- 被调用者: []\n\n7. 函数名: printk\n- 参数: [KERN_WARNING, \"sunkbd.c: Unknown key (scancode %#x) %s.\\n\", data & SUNKBD_KEY, data & SUNKBD_RELEASE ? \"released\" : \"pressed\"]\n- 调用者: sunkbd_interrupt\n- 被调用者: []"
    },
    {
        "id": 2597,
        "cwe": "CWE-416",
        "cve": "CVE-2020-25669",
        "purpose": "Code purpose:\"\"\"该代码片段用于控制sunkbd设备的启用/禁用状态，通过暂停和恢复串行I/O接收来实现状态的切换\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在sunkbd_reinit被sunkbd_interrupt调度后，sunkbd被释放，导致sunkbd_reinit中仍存在对已释放内存的引用，引发释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: sunkbd_enable\n- 参数: [struct sunkbd *sunkbd, bool enable]\n- 调用者: 未提供（根据上下文可能由外部驱动调用）\n- 被调用者: [serio_pause_rx, serio_continue_rx]\n\n2. 函数名: serio_pause_rx\n- 参数: [struct serio *serio] (通过 sunkbd->serio 传递)\n- 调用者: sunkbd_enable\n- 被调用者: 未提供\n\n3. 函数名: serio_continue_rx\n- 参数: [struct serio *serio] (通过 sunkbd->serio 传递)\n- 调用者: sunkbd_enable\n- 被调用者: 未提供\n\n注：根据漏洞描述中提到的其他函数（sunkbd_reinit, sunkbd_interrupt, sunkbd_disconnect）但未在代码片段中展示，故未包含在分析结果中。"
    },
    {
        "id": 2598,
        "cwe": "CWE-416",
        "cve": "CVE-2020-25669",
        "purpose": "Code purpose:\"\"\"该代码用于重新初始化Sun键盘设备，设置LED状态和声音控制，但存在释放后使用漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在sunkbd_reinit函数中使用了已被释放的sunkbd指针，导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: sunkbd_reinit\n- 参数: [work]\n- 调用者: sunkbd_interrupt\n- 被调用者: [container_of, wait_event_interruptible_timeout, test_bit, serio_write]\n\n2. 函数名: container_of\n- 参数: [work, struct sunkbd, tq]\n- 调用者: sunkbd_reinit\n- 被调用者: []\n\n3. 函数名: wait_event_interruptible_timeout\n- 参数: [sunkbd->wait, sunkbd->reset >= 0, HZ]\n- 调用者: sunkbd_reinit\n- 被调用者: []\n\n4. 函数名: test_bit\n- 参数: [LED_CAPSL, sunkbd->dev->led], [LED_SCROLLL, sunkbd->dev->led], [LED_COMPOSE, sunkbd->dev->led], [LED_NUML, sunkbd->dev->led], [SND_CLICK, sunkbd->dev->snd], [SND_BELL, sunkbd->dev->snd]\n- 调用者: sunkbd_reinit\n- 被调用者: []\n\n5. 函数名: serio_write\n- 参数: [sunkbd->serio, SUNKBD_CMD_SETLED], [sunkbd->serio, (!!test_bit(...) << 3) | ...], [sunkbd->serio, SUNKBD_CMD_NOCLICK - !!test_bit(...)], [sunkbd->serio, SUNKBD_CMD_BELLOFF - !!test_bit(...)]\n- 调用者: sunkbd_reinit\n- 被调用者: []"
    },
    {
        "id": 2610,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27066",
        "purpose": "Code purpose:\"\"\"释放xfrm策略资源并处理相关定时器和队列\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在xfrm_policy_kill函数中缺乏适当的锁机制，导致在释放policy对象后可能被继续访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: xfrm_policy_kill\n- 参数: [struct xfrm_policy *policy]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [atomic_inc, del_timer, xfrm_pol_put, skb_queue_purge]\n\n2. 函数名: atomic_inc\n- 参数: [&policy->genid]\n- 调用者: xfrm_policy_kill\n- 被调用者: []\n\n3. 函数名: del_timer\n- 参数: [&policy->polq.hold_timer], [&policy->timer]\n- 调用者: xfrm_policy_kill\n- 被调用者: []\n\n4. 函数名: xfrm_pol_put\n- 参数: [policy]\n- 调用者: xfrm_policy_kill\n- 被调用者: []\n\n5. 函数名: skb_queue_purge\n- 参数: [&policy->polq.hold_queue]\n- 调用者: xfrm_policy_kill\n- 被调用者: []"
    },
    {
        "id": 2611,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27067",
        "purpose": "Code purpose:\"\"\"该代码用于在L2TP以太网设备卸载时，从网络设备列表中删除私有数据并释放设备引用计数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在释放设备资源(dev_put)前未充分处理多线程竞争条件，导致在l2tp_eth_lock解锁后可能发生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: l2tp_eth_dev_uninit\n- 参数: [struct net_device *dev]\n- 调用者: 未显示（由系统或上层网络模块调用）\n- 被调用者: [netdev_priv, l2tp_eth_pernet, dev_net, spin_lock, list_del_init, spin_unlock, dev_put]\n\n2. 函数名: netdev_priv\n- 参数: [struct net_device *dev]\n- 调用者: l2tp_eth_dev_uninit\n- 被调用者: 未显示（内核内部函数）\n\n3. 函数名: l2tp_eth_pernet\n- 参数: [struct net *net]\n- 调用者: l2tp_eth_dev_uninit\n- 被调用者: 未显示（内核内部函数）\n\n4. 函数名: dev_net\n- 参数: [struct net_device *dev]\n- 调用者: l2tp_eth_dev_uninit\n- 被调用者: 未显示（内核内部函数）\n\n5. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: l2tp_eth_dev_uninit\n- 被调用者: 未显示（内核同步原语）\n\n6. 函数名: list_del_init\n- 参数: [struct list_head *entry]\n- 调用者: l2tp_eth_dev_uninit\n- 被调用者: 未显示（内核链表操作函数）\n\n7. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: l2tp_eth_dev_uninit\n- 被调用者: 未显示（内核同步原语）\n\n8. 函数名: dev_put\n- 参数: [struct net_device *dev]\n- 调用者: l2tp_eth_dev_uninit\n- 被调用者: 未显示（内核引用计数函数）"
    },
    {
        "id": 2612,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27067",
        "purpose": "Code purpose:\"\"\"创建一个L2TP以太网会话并初始化相关网络设备\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于l2tp子系统中存在竞态条件，导致在释放后仍可能被使用(use-after-free)的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: l2tp_eth_create\n- 参数: [struct net *net, struct l2tp_tunnel *tunnel, u32 session_id, u32 peer_session_id, struct l2tp_session_cfg *cfg]\n- 调用者: 未显示\n- 被调用者: [strlcpy, strcpy, l2tp_session_create, alloc_netdev, dev_net_set, l2tp_eth_adjust_mtu, netdev_priv, INIT_LIST_HEAD, l2tp_session_priv, register_netdev, __module_get, dev_hold, l2tp_eth_pernet, free_netdev, l2tp_session_delete]\n\n2. 函数名: l2tp_session_create\n- 参数: [sizeof(*spriv), tunnel, session_id, peer_session_id, cfg]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n3. 函数名: alloc_netdev\n- 参数: [sizeof(*priv), name, name_assign_type, l2tp_eth_dev_setup]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n4. 函数名: dev_net_set\n- 参数: [dev, net]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n5. 函数名: l2tp_eth_adjust_mtu\n- 参数: [tunnel, session, dev]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n6. 函数名: netdev_priv\n- 参数: [dev]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n7. 函数名: INIT_LIST_HEAD\n- 参数: [&priv->list]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n8. 函数名: l2tp_session_priv\n- 参数: [session]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n9. 函数名: register_netdev\n- 参数: [dev]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n10. 函数名: __module_get\n- 参数: [THIS_MODULE]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n11. 函数名: dev_hold\n- 参数: [dev]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n12. 函数名: l2tp_eth_pernet\n- 参数: [dev_net(dev)]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n13. 函数名: free_netdev\n- 参数: [dev]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示\n\n14. 函数名: l2tp_session_delete\n- 参数: [session]\n- 调用者: l2tp_eth_create\n- 被调用者: 未显示"
    },
    {
        "id": 2613,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27067",
        "purpose": "Code purpose:\"\"\"初始化L2TP以太网伪线支持，注册网络操作和网络设备操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于l2tp子系统中存在竞争条件导致的使用后释放(UAF)问题\"\"\"",
        "functions": "Functions:\n1. 函数名: l2tp_eth_init\n- 参数: [void]\n- 调用者: 模块初始化调用\n- 被调用者: [l2tp_nl_register_ops, register_pernet_device, l2tp_nl_unregister_ops]\n\n2. 函数名: l2tp_nl_register_ops\n- 参数: [L2TP_PWTYPE_ETH, &l2tp_eth_nl_cmd_ops]\n- 调用者: l2tp_eth_init\n- 被调用者: []\n\n3. 函数名: register_pernet_device\n- 参数: [&l2tp_eth_net_ops]\n- 调用者: l2tp_eth_init\n- 被调用者: []\n\n4. 函数名: l2tp_nl_unregister_ops\n- 参数: [L2TP_PWTYPE_ETH]\n- 调用者: l2tp_eth_init\n- 被调用者: []"
    },
    {
        "id": 2614,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27067",
        "purpose": "Code purpose:\"\"\"在l2tp子系统中注销网络命名空间操作和网络层操作，用于模块退出时的清理工作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在l2tp子系统中存在竞态条件导致释放后使用(use-after-free)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: l2tp_eth_exit\n- 参数: []\n- 调用者: __exit\n- 被调用者: [unregister_pernet_device, l2tp_nl_unregister_ops]\n\n2. 函数名: unregister_pernet_device\n- 参数: [&l2tp_eth_net_ops]\n- 调用者: l2tp_eth_exit\n- 被调用者: []\n\n3. 函数名: l2tp_nl_unregister_ops\n- 参数: [L2TP_PWTYPE_ETH]\n- 调用者: l2tp_eth_exit\n- 被调用者: []"
    },
    {
        "id": 2619,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27418",
        "purpose": "Code purpose:\"\"\"该代码用于调整虚拟控制台(vgacon)的显示尺寸，包括宽度和高度的验证和调整操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在vgacon_resize函数中，由于缺乏对释放后内存的适当检查和管理，导致攻击者可能通过vgacon_invert_region函数访问已释放的内存区域，从而获取敏感信息。\"\"\"",
        "functions": "Functions:\n1. 函数名: vgacon_resize\n- 参数: [struct vc_data *c, unsigned int width, unsigned int height, unsigned int user]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [vgacon_doresize]\n\n2. 函数名: vgacon_doresize\n- 参数: 未明确（从调用上下文推断至少包含[c, width, height]）\n- 调用者: vgacon_resize\n- 被调用者: 未明确"
    },
    {
        "id": 2621,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27675",
        "purpose": "Code purpose:\"\"\"该代码用于根据事件通道号(evtchn)获取对应的中断请求号(irq)，并进行边界检查和空指针检查\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环中存在竞态条件，允许在事件处理过程中删除事件通道，导致可能发生释放后使用或空指针解引用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: get_evtchn_to_irq\n- 参数: [evtchn_port_t evtchn]\n- 调用者: 未明确（上下文不足）\n- 被调用者: [xen_evtchn_max_channels]\n\n2. 函数名: xen_evtchn_max_channels\n- 参数: []\n- 调用者: get_evtchn_to_irq\n- 被调用者: 未明确（上下文不足）"
    },
    {
        "id": 2622,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27675",
        "purpose": "Code purpose:\"\"\"清除指定行中所有事件通道到中断号的映射关系\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环期间允许移除事件通道，导致竞态条件可能引发释放后使用或空指针解引用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: clear_evtchn_to_irq_row\n- 参数: [row]\n- 调用者: 未明确显示（根据上下文可能由事件处理相关函数调用）\n- 被调用者: []"
    },
    {
        "id": 2623,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27675",
        "purpose": "Code purpose:\"\"\"该代码用于在Xen虚拟化环境中释放中断请求(IRQ)资源，包括从链表中删除中断信息、释放内存以及处理传统中断描述符。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环中存在竞态条件，允许在事件处理过程中删除事件通道，导致可能发生释放后使用或空指针解引用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: xen_free_irq\n- 参数: [unsigned irq]\n- 调用者: 未指定\n- 被调用者: [info_for_irq, WARN_ON, list_del, set_info_for_irq, kfree, nr_legacy_irqs, irq_free_desc]\n\n2. 函数名: info_for_irq\n- 参数: [unsigned irq]\n- 调用者: xen_free_irq\n- 被调用者: 未指定\n\n3. 函数名: WARN_ON\n- 参数: [condition]\n- 调用者: xen_free_irq\n- 被调用者: 未指定\n\n4. 函数名: list_del\n- 参数: [struct list_head *entry]\n- 调用者: xen_free_irq\n- 被调用者: 未指定\n\n5. 函数名: set_info_for_irq\n- 参数: [unsigned irq, struct irq_info *info]\n- 调用者: xen_free_irq\n- 被调用者: 未指定\n\n6. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: xen_free_irq\n- 被调用者: 未指定\n\n7. 函数名: nr_legacy_irqs\n- 参数: []\n- 调用者: xen_free_irq\n- 被调用者: 未指定\n\n8. 函数名: irq_free_desc\n- 参数: [unsigned int irq]\n- 调用者: xen_free_irq\n- 被调用者: 未指定"
    },
    {
        "id": 2624,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27675",
        "purpose": "Code purpose:\"\"\"管理Xen事件通道与IRQ之间的映射关系，包括分配和设置映射\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环中存在竞态条件，允许在事件处理过程中删除事件通道，导致可能发生释放后使用或空指针解引用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: set_evtchn_to_irq\n- 参数: [evtchn_port_t evtchn, unsigned int irq]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [xen_evtchn_max_channels, EVTCHN_ROW, EVTCHN_COL, get_zeroed_page, clear_evtchn_to_irq_row]\n\n2. 函数名: xen_evtchn_max_channels\n- 参数: []\n- 调用者: set_evtchn_to_irq\n- 被调用者: 未明确（上下文未提供）\n\n3. 函数名: EVTCHN_ROW\n- 参数: [evtchn_port_t evtchn]\n- 调用者: set_evtchn_to_irq\n- 被调用者: 未明确（上下文未提供）\n\n4. 函数名: EVTCHN_COL\n- 参数: [evtchn_port_t evtchn]\n- 调用者: set_evtchn_to_irq\n- 被调用者: 未明确（上下文未提供）\n\n5. 函数名: get_zeroed_page\n- 参数: [GFP_KERNEL]\n- 调用者: set_evtchn_to_irq\n- 被调用者: 未明确（上下文未提供）\n\n6. 函数名: clear_evtchn_to_irq_row\n- 参数: [unsigned row]\n- 调用者: set_evtchn_to_irq\n- 被调用者: 未明确（上下文未提供）"
    },
    {
        "id": 2625,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27675",
        "purpose": "Code purpose:\"\"\"处理Xen事件通道的上调事件，循环检查并处理来自Hypervisor的事件通知\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环期间允许移除事件通道，导致竞态条件可能引发释放后使用或空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: __xen_evtchn_do_upcall\n- 参数: []\n- 调用者: 未显示\n- 被调用者: [__this_cpu_read, smp_processor_id, xen_evtchn_handle_events, BUG_ON, virt_rmb]\n\n2. 函数名: __this_cpu_read\n- 参数: [xen_vcpu]\n- 调用者: __xen_evtchn_do_upcall\n- 被调用者: 未显示\n\n3. 函数名: smp_processor_id\n- 参数: []\n- 调用者: __xen_evtchn_do_upcall\n- 被调用者: 未显示\n\n4. 函数名: xen_evtchn_handle_events\n- 参数: [cpu]\n- 调用者: __xen_evtchn_do_upcall\n- 被调用者: 未显示\n\n5. 函数名: BUG_ON\n- 参数: [!irqs_disabled()]\n- 调用者: __xen_evtchn_do_upcall\n- 被调用者: 未显示\n\n6. 函数名: virt_rmb\n- 参数: []\n- 调用者: __xen_evtchn_do_upcall\n- 被调用者: 未显示"
    },
    {
        "id": 2626,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27675",
        "purpose": "Code purpose:\"\"\"该代码用于根据给定的IRQ号获取对应的事件通道(evtchn)，并进行有效性检查\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环中存在竞态条件，允许在事件处理过程中移除事件通道，导致可能发生释放后使用或空指针解引用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: evtchn_from_irq\n- 参数: [unsigned irq]\n- 调用者: 未指定（由外部调用）\n- 被调用者: [WARN, info_for_irq]\n\n2. 函数名: WARN\n- 参数: [condition, format, ...]\n- 调用者: evtchn_from_irq\n- 被调用者: []\n\n3. 函数名: info_for_irq\n- 参数: [unsigned irq]\n- 调用者: evtchn_from_irq\n- 被调用者: []"
    },
    {
        "id": 2629,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27784",
        "purpose": "Code purpose:\"\"\"分配并初始化一个USB打印机设备功能的结构体，包括设置各种回调函数和初始化相关数据结构\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在printer_ioctl()中访问已被gprinter_free()释放的printer_dev实例，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: gprinter_alloc\n- 参数: [struct usb_function_instance *fi]\n- 调用者: (未在代码片段中显示)\n- 被调用者: [container_of, mutex_lock, mutex_unlock, kzalloc, ERR_PTR, INIT_LIST_HEAD, spin_lock_init, mutex_init, init_waitqueue_head]\n\n2. 函数名: printer_func_bind\n- 参数: (未在代码片段中显示)\n- 调用者: gprinter_alloc\n- 被调用者: (未在代码片段中显示)\n\n3. 函数名: printer_func_setup\n- 参数: (未在代码片段中显示)\n- 调用者: gprinter_alloc\n- 被调用者: (未在代码片段中显示)\n\n4. 函数名: printer_func_unbind\n- 参数: (未在代码片段中显示)\n- 调用者: gprinter_alloc\n- 被调用者: (未在代码片段中显示)\n\n5. 函数名: printer_func_set_alt\n- 参数: (未在代码片段中显示)\n- 调用者: gprinter_alloc\n- 被调用者: (未在代码片段中显示)\n\n6. 函数名: printer_func_disable\n- 参数: (未在代码片段中显示)\n- 调用者: gprinter_alloc\n- 被调用者: (未在代码片段中显示)\n\n7. 函数名: gprinter_req_match\n- 参数: (未在代码片段中显示)\n- 调用者: gprinter_alloc\n- 被调用者: (未在代码片段中显示)\n\n8. 函数名: gprinter_free\n- 参数: (未在代码片段中显示)\n- 调用者: gprinter_alloc\n- 被调用者: (未在代码片段中显示)"
    },
    {
        "id": 2630,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27784",
        "purpose": "Code purpose:\"\"\"该代码片段实现了打印机设备的关闭功能，包括重置设备状态标志和清理文件描述符的私有数据。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在printer_close函数中未正确管理dev对象的生命周期，导致后续printer_ioctl可能访问已被gprinter_free释放的内存，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: printer_close\n- 参数: [struct inode *inode, struct file *fd]\n- 调用者: 未明确显示（通常由文件操作结构体中的close回调触发）\n- 被调用者: [spin_lock_irqsave, spin_unlock_irqrestore, DBG]"
    },
    {
        "id": 2631,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27784",
        "purpose": "Code purpose:\"\"\"该代码实现了打印机设备的打开功能，包括设备状态检查和打开状态设置，并将设备实例与文件描述符关联。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在printer_open函数中，当设备被释放后仍可能被访问，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: printer_open\n- 参数: [struct inode *inode, struct file *fd]\n- 调用者: 未明确显示（通常由文件系统操作调用）\n- 被调用者: [container_of, spin_lock_irqsave, spin_unlock_irqrestore, DBG]\n\n2. 函数名: container_of\n- 参数: [inode->i_cdev, struct printer_dev, printer_cdev]\n- 调用者: printer_open\n- 被调用者: []\n\n3. 函数名: spin_lock_irqsave\n- 参数: [&dev->lock, flags]\n- 调用者: printer_open\n- 被调用者: []\n\n4. 函数名: spin_unlock_irqrestore\n- 参数: [&dev->lock, flags]\n- 调用者: printer_open\n- 被调用者: []\n\n5. 函数名: DBG\n- 参数: [dev, \"printer_open returned %x\\n\", ret]\n- 调用者: printer_open\n- 被调用者: []"
    },
    {
        "id": 2632,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27784",
        "purpose": "Code purpose:\"\"\"释放USB打印机设备结构体并减少相关选项的引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在gprinter_free()函数中释放了dev实例后，printer_ioctl()仍可能尝试访问该已被释放的内存，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: gprinter_free\n- 参数: [f]\n- 调用者: 未明确（由USB功能子系统调用）\n- 被调用者: [func_to_printer, container_of, kfree, mutex_lock, mutex_unlock]\n\n2. 函数名: func_to_printer\n- 参数: [f]\n- 调用者: gprinter_free\n- 被调用者: []\n\n3. 函数名: container_of\n- 参数: [f->fi, struct f_printer_opts, func_inst]\n- 调用者: gprinter_free\n- 被调用者: []\n\n4. 函数名: kfree\n- 参数: [dev]\n- 调用者: gprinter_free\n- 被调用者: []\n\n5. 函数名: mutex_lock\n- 参数: [&opts->lock]\n- 调用者: gprinter_free\n- 被调用者: []\n\n6. 函数名: mutex_unlock\n- 参数: [&opts->lock]\n- 调用者: gprinter_free\n- 被调用者: []"
    },
    {
        "id": 2633,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27786",
        "purpose": "Code purpose:\"\"\"该代码实现了从MIDI设备内核缓冲区读取数据到用户空间或内核空间的功能，处理环形缓冲区的指针更新和数据拷贝。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放锁后执行用户空间内存拷贝操作时，可能导致竞态条件下的use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_rawmidi_kernel_read1\n- 参数: [struct snd_rawmidi_substream *substream, unsigned char __user *userbuf, unsigned char *kernelbuf, long count]\n- 调用者: 未明确显示（通常由内核MIDI子系统调用）\n- 被调用者: [spin_lock_irqsave, memcpy, copy_to_user, spin_unlock_irqrestore]\n\n2. 函数名: spin_lock_irqsave\n- 参数: [&runtime->lock, flags]\n- 调用者: snd_rawmidi_kernel_read1\n- 被调用者: []\n\n3. 函数名: memcpy\n- 参数: [kernelbuf + result, runtime->buffer + appl_ptr, count1]\n- 调用者: snd_rawmidi_kernel_read1\n- 被调用者: []\n\n4. 函数名: copy_to_user\n- 参数: [userbuf + result, runtime->buffer + appl_ptr, count1]\n- 调用者: snd_rawmidi_kernel_read1\n- 被调用者: []\n\n5. 函数名: spin_unlock_irqrestore\n- 参数: [&runtime->lock, flags]\n- 调用者: snd_rawmidi_kernel_read1\n- 被调用者: []"
    },
    {
        "id": 2634,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27786",
        "purpose": "Code purpose:\"\"\"处理MIDI设备的原始数据写入操作，包括从用户空间或内核空间缓冲区向MIDI运行时缓冲区复制数据\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放锁后执行用户空间内存拷贝操作时，可能导致竞态条件下的use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_rawmidi_kernel_write1\n- 参数: [struct snd_rawmidi_substream *substream, const unsigned char __user *userbuf, const unsigned char *kernelbuf, long count]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [spin_lock_irqsave, spin_unlock_irqrestore, memcpy, copy_from_user, snd_rawmidi_output_trigger]\n\n2. 函数名: spin_lock_irqsave\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: snd_rawmidi_kernel_write1\n- 被调用者: []\n\n3. 函数名: spin_unlock_irqrestore\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: snd_rawmidi_kernel_write1\n- 被调用者: []\n\n4. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: snd_rawmidi_kernel_write1\n- 被调用者: []\n\n5. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: snd_rawmidi_kernel_write1\n- 被调用者: []\n\n6. 函数名: snd_rawmidi_output_trigger\n- 参数: [struct snd_rawmidi_substream *substream, int up]\n- 调用者: snd_rawmidi_kernel_write1\n- 被调用者: []"
    },
    {
        "id": 2635,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27786",
        "purpose": "Code purpose:\"\"\"调整MIDI运行时缓冲区的大小，根据输入参数重新分配内存并更新相关指针和参数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在调整MIDI运行时缓冲区大小时，旧缓冲区在释放后可能被重新使用，导致释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: resize_runtime_buffer\n- 参数: [struct snd_rawmidi_runtime *runtime, struct snd_rawmidi_params *params, bool is_input]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [kvzalloc, spin_lock_irq, __reset_runtime_ptrs, spin_unlock_irq, kvfree]\n\n2. 函数名: __reset_runtime_ptrs\n- 参数: [struct snd_rawmidi_runtime *runtime, bool is_input]\n- 调用者: resize_runtime_buffer\n- 被调用者: 未明确"
    },
    {
        "id": 2636,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27820",
        "purpose": "Code purpose:\"\"\"在移除Nouveau DRM设备时执行清理操作，包括注销设备、释放资源和删除相关设备对象\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在设备移除过程中，由于未正确处理设备对象的引用计数，导致在后续操作中可能访问已被释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: nouveau_drm_device_remove\n- 参数: [struct drm_device *dev]\n- 调用者: 未显示\n- 被调用者: [nouveau_drm, drm_dev_unregister, nvxx_client, nvkm_device_find, nouveau_drm_device_fini, drm_dev_put, nvkm_device_del]\n\n2. 函数名: nouveau_drm\n- 参数: [struct drm_device *dev]\n- 调用者: nouveau_drm_device_remove\n- 被调用者: 未显示\n\n3. 函数名: drm_dev_unregister\n- 参数: [struct drm_device *dev]\n- 调用者: nouveau_drm_device_remove\n- 被调用者: 未显示\n\n4. 函数名: nvxx_client\n- 参数: [struct nvkm_object *]\n- 调用者: nouveau_drm_device_remove\n- 被调用者: 未显示\n\n5. 函数名: nvkm_device_find\n- 参数: [struct nvkm_client *client]\n- 调用者: nouveau_drm_device_remove\n- 被调用者: 未显示\n\n6. 函数名: nouveau_drm_device_fini\n- 参数: [struct drm_device *dev]\n- 调用者: nouveau_drm_device_remove\n- 被调用者: 未显示\n\n7. 函数名: drm_dev_put\n- 参数: [struct drm_device *dev]\n- 调用者: nouveau_drm_device_remove\n- 被调用者: 未显示\n\n8. 函数名: nvkm_device_del\n- 参数: [struct nvkm_device **]\n- 调用者: nouveau_drm_device_remove\n- 被调用者: 未显示"
    },
    {
        "id": 2641,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27835",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中hfi1驱动程序的文件关闭功能，包括释放相关资源、清理上下文状态和事件处理等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在文件关闭操作后，由于未正确处理引用计数和资源释放顺序，导致在fork后ioctl操作可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: hfi1_file_close\n- 参数: [struct inode *inode, struct file *fp]\n- 调用者: 无（内核文件操作函数指针）\n- 被调用者: [flush_wc, hfi1_user_sdma_free_queues, hfi1_put_proc_affinity, hfi1_user_exp_rcv_free, hfi1_rcd_put, uctxt_offset, spin_lock_irqsave, __clear_bit, bitmap_empty, spin_unlock_irqrestore, hfi1_rcvctrl, hfi1_clear_ctxt_jkey, sc_disable, set_pio_integrity, hfi1_free_ctxt_rcv_groups, hfi1_clear_ctxt_pkey, deallocate_ctxt, mmdrop, atomic_dec_and_test, complete, cleanup_srcu_struct, kfree]\n\n2. 函数名: flush_wc\n- 参数: []\n- 调用者: hfi1_file_close\n- 被调用者: []\n\n3. 函数名: hfi1_user_sdma_free_queues\n- 参数: [struct hfi1_filedata *fdata, struct hfi1_ctxtdata *uctxt]\n- 调用者: hfi1_file_close\n- 被调用者: []\n\n4. 函数名: hfi1_put_proc_affinity\n- 参数: [fdata->rec_cpu_num]\n- 调用者: hfi1_file_close\n- 被调用者: []\n\n5. 函数名: hfi1_user_exp_rcv_free\n- 参数: [struct hfi1_filedata *fdata]\n- 调用者: hfi1_file_close\n- 被调用者: []\n\n6. 函数名: hfi1_rcd_put\n- 参数: [struct hfi1_ctxtdata *uctxt]\n- 调用者: hfi1_file_close\n- 被调用者: []\n\n7. 函数名: uctxt_offset\n- 参数: [struct hfi1_ctxtdata *uctxt]\n- 调用者: hfi1_file_close\n- 被调用者: []\n\n8. 函数名: spin_lock_irqsave\n- 参数: [&dd->uctxt_lock, flags]\n- 调用者: hfi1_file_close\n- 被调用者: []\n\n9. 函数名: __clear_bit\n- 参数: [fdata->subctxt, uctxt->in_use_ctxts]\n- 调用者: hfi1_file_close\n- 被调用者: []\n\n10. 函数名: bitmap_empty\n- 参数: [uctxt->in_use_ctxts, HFI1_MAX_SHARED_CTXTS]\n- 调用者: hfi1_file_close\n- 被调用者: []\n\n11. 函数名: spin_unlock_irqrestore\n- 参数: [&dd->uctxt_lock, flags]\n- 调用者: hfi1_file_close\n- 被调用者: []\n\n12. 函数名: hfi1_rcvctrl\n- 参数: [dd, HFI1_RCVCTRL_CTXT_DIS | HFI1_RCVCTRL_TIDFLOW_DIS | HFI1_RCVCTRL_INTRAVAIL_DIS | HFI1_RCVCTRL_TAILUPD_DIS | HFI1_RCVCTRL_ONE_PKT_EGR_DIS | HFI1_RCVCTRL_NO_RHQ_DROP_DIS | HFI1_RCVCTRL_NO_EGR_DROP_DIS | HFI1_RCVCTRL_URGENT_DIS, uctxt]\n- 调用者: hfi1_file_close\n- 被调用者: []\n\n13. 函数名: hfi1_clear_ctxt_jkey\n- 参数: [dd, uctxt]\n- 调用者: hfi1_file_close\n- 被调用者: []\n\n14. 函数名: sc_disable\n- 参数: [uctxt->sc]\n- 调用者: hfi1_file_close\n- 被调用者: []\n\n15. 函数名: set_pio_integrity\n- 参数: [uctxt->sc]\n- 调用者: hfi1_file_close\n- 被调用者: []\n\n16. 函数名: hfi1_free_ctxt_rcv_groups\n- 参数: [uctxt]\n- 调用者: hfi1_file_close\n- 被调用者: []\n\n17. 函数名: hfi1_clear_ctxt_pkey\n- 参数: [dd, uctxt]\n- 调用者: hfi1_file_close\n- 被调用者: []\n\n18. 函数名: deallocate_ctxt\n- 参数: [uctxt]\n- 调用者: hfi1_file_close\n- 被调用者: []\n\n19. 函数名: mmdrop\n- 参数: [fdata->mm]\n- 调用者: hfi1_file_close\n- 被调用者: []\n\n20. 函数名: atomic_dec_and_test\n- 参数: [&dd->user_refcount]\n- 调用者: hfi1_file_close\n- 被调用者: []\n\n21. 函数名: complete\n- 参数: [&dd->user_comp]\n- 调用者: hfi1_file_close\n- 被调用者: []\n\n22. 函数名: cleanup_srcu_struct\n- 参数: [&fdata->pq_srcu]\n- 调用者: hfi1_file_close\n- 被调用者: []\n\n23. 函数名: kfree\n- 参数: [fdata]\n- 调用者: hfi1_file_close\n- 被调用者: []"
    },
    {
        "id": 2642,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27835",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核infiniband hfi1驱动中打开设备文件时的初始化操作，包括分配文件数据结构、初始化锁和引用计数等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在fork后子进程继承了父进程的文件描述符，当子进程退出时可能导致mm结构被释放，而父进程继续使用已释放的mm结构，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: hfi1_file_open\n- 参数: [struct inode *inode, struct file *fp]\n- 调用者: 内核文件操作子系统\n- 被调用者: [container_of, atomic_inc_not_zero, kzalloc, init_srcu_struct, spin_lock_init, mmgrab, kfree, atomic_dec_and_test, complete]\n\n2. 函数名: container_of\n- 参数: [inode->i_cdev, struct hfi1_devdata, user_cdev]\n- 调用者: hfi1_file_open\n- 被调用者: []\n\n3. 函数名: atomic_inc_not_zero\n- 参数: [&dd->user_refcount]\n- 调用者: hfi1_file_open\n- 被调用者: []\n\n4. 函数名: kzalloc\n- 参数: [sizeof(*fd), GFP_KERNEL]\n- 调用者: hfi1_file_open\n- 被调用者: []\n\n5. 函数名: init_srcu_struct\n- 参数: [&fd->pq_srcu]\n- 调用者: hfi1_file_open\n- 被调用者: []\n\n6. 函数名: spin_lock_init\n- 参数: [&fd->pq_rcu_lock]\n- 调用者: hfi1_file_open\n- 被调用者: []\n\n7. 函数名: spin_lock_init\n- 参数: [&fd->tid_lock]\n- 调用者: hfi1_file_open\n- 被调用者: []\n\n8. 函数名: spin_lock_init\n- 参数: [&fd->invalid_lock]\n- 调用者: hfi1_file_open\n- 被调用者: []\n\n9. 函数名: mmgrab\n- 参数: [fd->mm]\n- 调用者: hfi1_file_open\n- 被调用者: []\n\n10. 函数名: kfree\n- 参数: [fd]\n- 调用者: hfi1_file_open\n- 被调用者: []\n\n11. 函数名: atomic_dec_and_test\n- 参数: [&dd->user_refcount]\n- 调用者: hfi1_file_open\n- 被调用者: []\n\n12. 函数名: complete\n- 参数: [&dd->user_comp]\n- 调用者: hfi1_file_open\n- 被调用者: []"
    },
    {
        "id": 2643,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27835",
        "purpose": "Code purpose:\"\"\"该代码实现了在Linux内核infiniband hfi1驱动中向MMU(内存管理单元)红黑树中插入节点的功能，包括搜索、插入和错误处理等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核hfi1驱动程序中，当用户调用Ioctl操作后，存在释放后重用(use-after-free)漏洞，导致系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: hfi1_mmu_rb_insert\n- 参数: [handler, mnode]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [trace_hfi1_mmu_rb_insert, spin_lock_irqsave, __mmu_rb_search, __mmu_int_rb_insert, list_add, handler->ops->insert, __mmu_int_rb_remove, list_del, spin_unlock_irqrestore]\n\n2. 函数名: trace_hfi1_mmu_rb_insert\n- 参数: [mnode->addr, mnode->len]\n- 调用者: hfi1_mmu_rb_insert\n- 被调用者: []\n\n3. 函数名: spin_lock_irqsave\n- 参数: [&handler->lock, flags]\n- 调用者: hfi1_mmu_rb_insert\n- 被调用者: []\n\n4. 函数名: __mmu_rb_search\n- 参数: [handler, mnode->addr, mnode->len]\n- 调用者: hfi1_mmu_rb_insert\n- 被调用者: []\n\n5. 函数名: __mmu_int_rb_insert\n- 参数: [mnode, &handler->root]\n- 调用者: hfi1_mmu_rb_insert\n- 被调用者: []\n\n6. 函数名: list_add\n- 参数: [&mnode->list, &handler->lru_list]\n- 调用者: hfi1_mmu_rb_insert\n- 被调用者: []\n\n7. 函数名: handler->ops->insert\n- 参数: [handler->ops_arg, mnode]\n- 调用者: hfi1_mmu_rb_insert\n- 被调用者: []\n\n8. 函数名: __mmu_int_rb_remove\n- 参数: [mnode, &handler->root]\n- 调用者: hfi1_mmu_rb_insert\n- 被调用者: []\n\n9. 函数名: list_del\n- 参数: [&mnode->list]\n- 调用者: hfi1_mmu_rb_insert\n- 被调用者: []\n\n10. 函数名: spin_unlock_irqrestore\n- 参数: [&handler->lock, flags]\n- 调用者: hfi1_mmu_rb_insert\n- 被调用者: []"
    },
    {
        "id": 2644,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27835",
        "purpose": "Code purpose:\"\"\"该代码用于处理Linux内核infiniband hfi1驱动中的内存管理，负责从LRU列表中安全地移除并释放指定的内存块节点。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放内存后仍可能被访问，导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: hfi1_mmu_rb_evict\n- 参数: [handler, evict_arg]\n- 调用者: 未明确（由系统调用触发）\n- 被调用者: [INIT_LIST_HEAD, spin_lock_irqsave, list_for_each_entry_safe_reverse, __mmu_int_rb_remove, list_move, spin_unlock_irqrestore, list_empty, list_first_entry, list_del]\n\n2. 函数名: INIT_LIST_HEAD\n- 参数: [&del_list]\n- 调用者: hfi1_mmu_rb_evict\n- 被调用者: []\n\n3. 函数名: spin_lock_irqsave\n- 参数: [&handler->lock, flags]\n- 调用者: hfi1_mmu_rb_evict\n- 被调用者: []\n\n4. 函数名: list_for_each_entry_safe_reverse\n- 参数: [rbnode, ptr, &handler->lru_list, list]\n- 调用者: hfi1_mmu_rb_evict\n- 被调用者: []\n\n5. 函数名: handler->ops->evict\n- 参数: [handler->ops_arg, rbnode, evict_arg, &stop]\n- 调用者: hfi1_mmu_rb_evict\n- 被调用者: []\n\n6. 函数名: __mmu_int_rb_remove\n- 参数: [rbnode, &handler->root]\n- 调用者: hfi1_mmu_rb_evict\n- 被调用者: []\n\n7. 函数名: list_move\n- 参数: [&rbnode->list, &del_list]\n- 调用者: hfi1_mmu_rb_evict\n- 被调用者: []\n\n8. 函数名: spin_unlock_irqrestore\n- 参数: [&handler->lock, flags]\n- 调用者: hfi1_mmu_rb_evict\n- 被调用者: []\n\n9. 函数名: list_empty\n- 参数: [&del_list]\n- 调用者: hfi1_mmu_rb_evict\n- 被调用者: []\n\n10. 函数名: list_first_entry\n- 参数: [&del_list, struct mmu_rb_node, list]\n- 调用者: hfi1_mmu_rb_evict\n- 被调用者: []\n\n11. 函数名: list_del\n- 参数: [&rbnode->list]\n- 调用者: hfi1_mmu_rb_evict\n- 被调用者: []\n\n12. 函数名: handler->ops->remove\n- 参数: [handler->ops_arg, rbnode]\n- 调用者: hfi1_mmu_rb_evict\n- 被调用者: []"
    },
    {
        "id": 2645,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27835",
        "purpose": "Code purpose:\"\"\"在hfi1驱动中根据地址和长度搜索并移除RB树节点，除非完全匹配则保留\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放mmu_rb_node节点后未清空指针，导致后续可能发生对已释放内存的引用\"\"\"",
        "functions": "Functions:\n1. 函数名: hfi1_mmu_rb_remove_unless_exact\n- 参数: [handler, addr, len, rb_node]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [__mmu_rb_search, __mmu_int_rb_remove, list_del, spin_lock_irqsave, spin_unlock_irqrestore]\n\n2. 函数名: __mmu_rb_search\n- 参数: [handler, addr, len]\n- 调用者: hfi1_mmu_rb_remove_unless_exact\n- 被调用者: 未明确（可能为内部实现）\n\n3. 函数名: __mmu_int_rb_remove\n- 参数: [node, &handler->root]\n- 调用者: hfi1_mmu_rb_remove_unless_exact\n- 被调用者: 未明确（可能为内部实现）\n\n4. 函数名: list_del\n- 参数: [&node->list]\n- 调用者: hfi1_mmu_rb_remove_unless_exact\n- 被调用者: 未明确（可能为内核链表操作函数）\n\n5. 函数名: spin_lock_irqsave\n- 参数: [&handler->lock, flags]\n- 调用者: hfi1_mmu_rb_remove_unless_exact\n- 被调用者: 未明确（内核自旋锁函数）\n\n6. 函数名: spin_unlock_irqrestore\n- 参数: [&handler->lock, flags]\n- 调用者: hfi1_mmu_rb_remove_unless_exact\n- 被调用者: 未明确（内核自旋锁函数）"
    },
    {
        "id": 2646,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27835",
        "purpose": "Code purpose:\"\"\"从内存管理器的红黑树和LRU列表中安全移除指定节点并执行相关清理操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放mmu_rb_node节点后，handler->ops->remove操作仍可能访问该节点，导致释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: hfi1_mmu_rb_remove\n- 参数: [handler, node]\n- 调用者: 未明确（由调用者检查指针有效性）\n- 被调用者: [trace_hfi1_mmu_rb_remove, spin_lock_irqsave, __mmu_int_rb_remove, list_del, spin_unlock_irqrestore, handler->ops->remove]\n\n2. 函数名: trace_hfi1_mmu_rb_remove\n- 参数: [node->addr, node->len]\n- 调用者: hfi1_mmu_rb_remove\n- 被调用者: []\n\n3. 函数名: spin_lock_irqsave\n- 参数: [&handler->lock, flags]\n- 调用者: hfi1_mmu_rb_remove\n- 被调用者: []\n\n4. 函数名: __mmu_int_rb_remove\n- 参数: [node, &handler->root]\n- 调用者: hfi1_mmu_rb_remove\n- 被调用者: []\n\n5. 函数名: list_del\n- 参数: [&node->list]\n- 调用者: hfi1_mmu_rb_remove\n- 被调用者: []\n\n6. 函数名: spin_unlock_irqrestore\n- 参数: [&handler->lock, flags]\n- 调用者: hfi1_mmu_rb_remove\n- 被调用者: []\n\n7. 函数名: handler->ops->remove\n- 参数: [handler->ops_arg, node]\n- 调用者: hfi1_mmu_rb_remove\n- 被调用者: []"
    },
    {
        "id": 2647,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27835",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的hfi1驱动中取消注册MMU(内存管理单元)的RB(红黑树)处理程序，并清理相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放handler内存后仍可能被访问，导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: hfi1_mmu_rb_unregister\n- 参数: [struct mmu_rb_handler *handler]\n- 调用者: 未显示\n- 被调用者: [mmu_notifier_unregister, flush_work, INIT_LIST_HEAD, spin_lock_irqsave, rb_first_cached, rb_entry, rb_erase_cached, list_move, spin_unlock_irqrestore, do_remove, kfree]\n\n2. 函数名: mmu_notifier_unregister\n- 参数: [&handler->mn, handler->mm]\n- 调用者: hfi1_mmu_rb_unregister\n- 被调用者: 未显示\n\n3. 函数名: flush_work\n- 参数: [&handler->del_work]\n- 调用者: hfi1_mmu_rb_unregister\n- 被调用者: 未显示\n\n4. 函数名: INIT_LIST_HEAD\n- 参数: [&del_list]\n- 调用者: hfi1_mmu_rb_unregister\n- 被调用者: 未显示\n\n5. 函数名: spin_lock_irqsave\n- 参数: [&handler->lock, flags]\n- 调用者: hfi1_mmu_rb_unregister\n- 被调用者: 未显示\n\n6. 函数名: rb_first_cached\n- 参数: [&handler->root]\n- 调用者: hfi1_mmu_rb_unregister\n- 被调用者: 未显示\n\n7. 函数名: rb_entry\n- 参数: [node, struct mmu_rb_node, node]\n- 调用者: hfi1_mmu_rb_unregister\n- 被调用者: 未显示\n\n8. 函数名: rb_erase_cached\n- 参数: [node, &handler->root]\n- 调用者: hfi1_mmu_rb_unregister\n- 被调用者: 未显示\n\n9. 函数名: list_move\n- 参数: [&rbnode->list, &del_list]\n- 调用者: hfi1_mmu_rb_unregister\n- 被调用者: 未显示\n\n10. 函数名: spin_unlock_irqrestore\n- 参数: [&handler->lock, flags]\n- 调用者: hfi1_mmu_rb_unregister\n- 被调用者: 未显示\n\n11. 函数名: do_remove\n- 参数: [handler, &del_list]\n- 调用者: hfi1_mmu_rb_unregister\n- 被调用者: 未显示\n\n12. 函数名: kfree\n- 参数: [handler]\n- 调用者: hfi1_mmu_rb_unregister\n- 被调用者: 未显示"
    },
    {
        "id": 2648,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27835",
        "purpose": "Code purpose:\"\"\"该代码用于设置HFI1驱动中的接收缓冲区数组条目，包括分配内存、映射DMA地址、管理内存页和建立通知机制等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在fork后使用已释放的内存资源导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: set_rcvarray_entry\n- 参数: [struct hfi1_filedata *fd, struct tid_user_buf *tbuf, u32 rcventry, struct tid_group *grp, u16 pageidx, unsigned int npages]\n- 调用者: 未显示\n- 被调用者: [kzalloc, pci_map_single, dma_mapping_error, kfree, page_to_phys, memcpy, mmu_interval_notifier_insert, mmu_interval_read_begin, hfi1_put_tid, trace_hfi1_exp_tid_reg, pci_unmap_single]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*node) + (sizeof(struct page *) * npages), GFP_KERNEL]\n- 调用者: set_rcvarray_entry\n- 被调用者: 未显示\n\n3. 函数名: pci_map_single\n- 参数: [dd->pcidev, __va(page_to_phys(pages[0])), npages * PAGE_SIZE, PCI_DMA_FROMDEVICE]\n- 调用者: set_rcvarray_entry\n- 被调用者: 未显示\n\n4. 函数名: dma_mapping_error\n- 参数: [&dd->pcidev->dev, phys]\n- 调用者: set_rcvarray_entry\n- 被调用者: 未显示\n\n5. 函数名: kfree\n- 参数: [node]\n- 调用者: set_rcvarray_entry\n- 被调用者: 未显示\n\n6. 函数名: page_to_phys\n- 参数: [pages[0]]\n- 调用者: set_rcvarray_entry\n- 被调用者: 未显示\n\n7. 函数名: memcpy\n- 参数: [node->pages, pages, sizeof(struct page *) * npages]\n- 调用者: set_rcvarray_entry\n- 被调用者: 未显示\n\n8. 函数名: mmu_interval_notifier_insert\n- 参数: [&node->notifier, fd->mm, tbuf->vaddr + (pageidx * PAGE_SIZE), npages * PAGE_SIZE, &tid_mn_ops]\n- 调用者: set_rcvarray_entry\n- 被调用者: 未显示\n\n9. 函数名: mmu_interval_read_begin\n- 参数: [&node->notifier]\n- 调用者: set_rcvarray_entry\n- 被调用者: 未显示\n\n10. 函数名: hfi1_put_tid\n- 参数: [dd, rcventry, PT_EXPECTED, phys, ilog2(npages) + 1]\n- 调用者: set_rcvarray_entry\n- 被调用者: 未显示\n\n11. 函数名: trace_hfi1_exp_tid_reg\n- 参数: [uctxt->ctxt, fd->subctxt, rcventry, npages, node->notifier.interval_tree.start, node->phys, phys]\n- 调用者: set_rcvarray_entry\n- 被调用者: 未显示\n\n12. 函数名: pci_unmap_single\n- 参数: [dd->pcidev, phys, npages * PAGE_SIZE, PCI_DMA_FROMDEVICE]\n- 调用者: set_rcvarray_entry\n- 被调用者: 未显示"
    },
    {
        "id": 2649,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27835",
        "purpose": "Code purpose:\"\"\"释放已映射或未映射的接收页面，并更新已固定页面的计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在fork后子进程继续使用父进程中已被释放的页面指针，导致释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: unpin_rcv_pages\n- 参数: [struct hfi1_filedata *fd, struct tid_user_buf *tidbuf, struct tid_rb_node *node, unsigned int idx, unsigned int npages, bool mapped]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [pci_unmap_single, hfi1_release_user_pages]\n\n2. 函数名: pci_unmap_single\n- 参数: [dd->pcidev, node->dma_addr, node->npages * PAGE_SIZE, PCI_DMA_FROMDEVICE]\n- 调用者: unpin_rcv_pages\n- 被调用者: []\n\n3. 函数名: hfi1_release_user_pages\n- 参数: [fd->mm, pages, npages, mapped]\n- 调用者: unpin_rcv_pages\n- 被调用者: []"
    },
    {
        "id": 2650,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27835",
        "purpose": "Code purpose:\"\"\"该代码用于处理用户空间缓冲区到内核空间的页锁定操作，包括验证缓冲区大小、分配页指针数组、锁定用户内存页并更新相关计数信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在fork后未正确处理内存页面的引用计数，导致释放后仍被使用的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: pin_rcv_pages\n- 参数: [fd, tidbuf]\n- 调用者: 未明确（由系统调用或驱动内部调用）\n- 被调用者: [num_user_pages, hfi1_can_pin_pages, hfi1_acquire_user_pages, kcalloc, kfree, dd_dev_err]\n\n2. 函数名: num_user_pages\n- 参数: [vaddr, length]\n- 调用者: pin_rcv_pages\n- 被调用者: []\n\n3. 函数名: hfi1_can_pin_pages\n- 参数: [dd, mm, tid_n_pinned, npages]\n- 调用者: pin_rcv_pages\n- 被调用者: []\n\n4. 函数名: hfi1_acquire_user_pages\n- 参数: [mm, vaddr, npages, true, pages]\n- 调用者: pin_rcv_pages\n- 被调用者: []\n\n5. 函数名: kcalloc\n- 参数: [npages, sizeof(*pages), GFP_KERNEL]\n- 调用者: pin_rcv_pages\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [pages]\n- 调用者: pin_rcv_pages\n- 被调用者: []\n\n7. 函数名: dd_dev_err\n- 参数: [dd, \"Expected buffer too big\"]\n- 调用者: pin_rcv_pages\n- 被调用者: []"
    },
    {
        "id": 2651,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27835",
        "purpose": "Code purpose:\"\"\"为HFI1设备的用户空间DMA操作分配和管理队列资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在fork操作后，子进程可能继续使用父进程中已释放的内存资源，导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: hfi1_user_sdma_alloc_queues\n- 参数: [struct hfi1_ctxtdata *uctxt, struct hfi1_filedata *fd]\n- 调用者: 未显示（应为外部调用）\n- 被调用者: [kzalloc, atomic_set, init_waitqueue_head, iowait_init, kcalloc, snprintf, kmem_cache_create, dd_dev_err, vmalloc_user, PAGE_ALIGN, hfi1_mmu_rb_register, rcu_assign_pointer, vfree, kfree, kmem_cache_destroy]\n\n2. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: hfi1_user_sdma_alloc_queues\n- 被调用者: []\n\n3. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: hfi1_user_sdma_alloc_queues\n- 被调用者: []\n\n4. 函数名: init_waitqueue_head\n- 参数: [wait_queue_head_t *q]\n- 调用者: hfi1_user_sdma_alloc_queues\n- 被调用者: []\n\n5. 函数名: iowait_init\n- 参数: [struct iowait *wait, u32 tx_limit, void *priv, void (*func)(struct work_struct *work), void (*tx_ring)(struct work_struct *work), void (*wakeup)(struct work_struct *work), void (*sdma_drained)(struct work_struct *work), void (*pio_drained)(struct work_struct *work)]\n- 调用者: hfi1_user_sdma_alloc_queues\n- 被调用者: []\n\n6. 函数名: kcalloc\n- 参数: [size_t n, size_t size, gfp_t flags]\n- 调用者: hfi1_user_sdma_alloc_queues\n- 被调用者: []\n\n7. 函数名: snprintf\n- 参数: [char *str, size_t size, const char *format, ...]\n- 调用者: hfi1_user_sdma_alloc_queues\n- 被调用者: []\n\n8. 函数名: kmem_cache_create\n- 参数: [const char *name, size_t size, size_t align, unsigned long flags, void (*ctor)(void *)]\n- 调用者: hfi1_user_sdma_alloc_queues\n- 被调用者: []\n\n9. 函数名: dd_dev_err\n- 参数: [struct hfi1_devdata *dd, const char *fmt, ...]\n- 调用者: hfi1_user_sdma_alloc_queues\n- 被调用者: []\n\n10. 函数名: vmalloc_user\n- 参数: [size_t size]\n- 调用者: hfi1_user_sdma_alloc_queues\n- 被调用者: []\n\n11. 函数名: PAGE_ALIGN\n- 参数: [size_t size]\n- 调用者: hfi1_user_sdma_alloc_queues\n- 被调用者: []\n\n12. 函数名: hfi1_mmu_rb_register\n- 参数: [void *ops_arg, struct mm_struct *mm, struct mmu_rb_ops *ops, struct workqueue_struct *wq, struct mmu_rb_handler **handler]\n- 调用者: hfi1_user_sdma_alloc_queues\n- 被调用者: []\n\n13. 函数名: rcu_assign_pointer\n- 参数: [typeof(*p) *p, typeof(*p) v]\n- 调用者: hfi1_user_sdma_alloc_queues\n- 被调用者: []\n\n14. 函数名: vfree\n- 参数: [const void *addr]\n- 调用者: hfi1_user_sdma_alloc_queues\n- 被调用者: []\n\n15. 函数名: kfree\n- 参数: [const void *x]\n- 调用者: hfi1_user_sdma_alloc_queues\n- 被调用者: []\n\n16. 函数名: kmem_cache_destroy\n- 参数: [struct kmem_cache *s]\n- 调用者: hfi1_user_sdma_alloc_queues\n- 被调用者: []"
    },
    {
        "id": 2652,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27835",
        "purpose": "Code purpose:\"\"\"释放SDMA内存映射节点中已固定的页面并更新锁定计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核infiniband hfi1驱动中，当用户打开设备文件并fork后调用Ioctl时，存在释放后使用(UAF)漏洞，导致系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: unpin_sdma_pages\n- 参数: [struct sdma_mmu_node *node]\n- 调用者: 未提供\n- 被调用者: [unpin_vector_pages, atomic_sub]\n\n2. 函数名: unpin_vector_pages\n- 参数: [node->pq->mm, node->pages, 0, node->npages]\n- 调用者: unpin_sdma_pages\n- 被调用者: 未提供\n\n3. 函数名: atomic_sub\n- 参数: [node->npages, &node->pq->n_locked]\n- 调用者: unpin_sdma_pages\n- 被调用者: 未提供"
    },
    {
        "id": 2653,
        "cwe": "CWE-416",
        "cve": "CVE-2020-27835",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的hfi1驱动中固定用户请求的SDMA页面，处理页面锁定和内存管理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在fork后使用已释放的内存页指针导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: pin_sdma_pages\n- 参数: [req, iovec, node, npages]\n- 调用者: 未显示\n- 被调用者: [kcalloc, memcpy, hfi1_can_pin_pages, atomic_read, sdma_cache_evict, hfi1_acquire_user_pages, kfree, unpin_vector_pages, atomic_add]\n\n2. 函数名: kcalloc\n- 参数: [npages, sizeof(*pages), GFP_KERNEL]\n- 调用者: pin_sdma_pages\n- 被调用者: 未显示\n\n3. 函数名: memcpy\n- 参数: [pages, node->pages, node->npages * sizeof(*pages)]\n- 调用者: pin_sdma_pages\n- 被调用者: 未显示\n\n4. 函数名: hfi1_can_pin_pages\n- 参数: [pq->dd, pq->mm, atomic_read(&pq->n_locked), npages]\n- 调用者: pin_sdma_pages\n- 被调用者: 未显示\n\n5. 函数名: atomic_read\n- 参数: [&pq->n_locked]\n- 调用者: pin_sdma_pages\n- 被调用者: 未显示\n\n6. 函数名: sdma_cache_evict\n- 参数: [pq, npages]\n- 调用者: pin_sdma_pages\n- 被调用者: 未显示\n\n7. 函数名: hfi1_acquire_user_pages\n- 参数: [pq->mm, ((unsigned long)iovec->iov.iov_base + (node->npages * PAGE_SIZE)), npages, 0, pages + node->npages]\n- 调用者: pin_sdma_pages\n- 被调用者: 未显示\n\n8. 函数名: kfree\n- 参数: [pages]\n- 调用者: pin_sdma_pages\n- 被调用者: 未显示\n\n9. 函数名: unpin_vector_pages\n- 参数: [pq->mm, pages, node->npages, pinned]\n- 调用者: pin_sdma_pages\n- 被调用者: 未显示\n\n10. 函数名: atomic_add\n- 参数: [pinned, &pq->n_locked]\n- 调用者: pin_sdma_pages\n- 被调用者: 未显示"
    },
    {
        "id": 2699,
        "cwe": "CWE-416",
        "cve": "CVE-2020-29569",
        "purpose": "Code purpose:\"\"\"该代码用于处理Xen虚拟化环境中块设备前端的断开连接操作，包括停止相关线程、释放资源并清理环形缓冲区等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核线程处理程序未及时将ring->xenblkd置为NULL，导致前端快速切换连接/断开状态时可能使用已释放的指针\"\"\"",
        "functions": "Functions:\n1. 函数名: xen_blkif_disconnect\n- 参数: [struct xen_blkif *blkif]\n- 调用者: 未显示\n- 被调用者: [kthread_stop, wake_up, atomic_read, unbind_from_irqhandler, xenbus_unmap_ring_vfree, xen_blkbk_free_caches, kfree, list_del, BUG_ON, WARN_ON]\n\n2. 函数名: kthread_stop\n- 参数: [ring->xenblkd]\n- 调用者: xen_blkif_disconnect\n- 被调用者: 未显示\n\n3. 函数名: wake_up\n- 参数: [&ring->shutdown_wq]\n- 调用者: xen_blkif_disconnect\n- 被调用者: 未显示\n\n4. 函数名: atomic_read\n- 参数: [&ring->inflight]\n- 调用者: xen_blkif_disconnect\n- 被调用者: 未显示\n\n5. 函数名: unbind_from_irqhandler\n- 参数: [ring->irq, ring]\n- 调用者: xen_blkif_disconnect\n- 被调用者: 未显示\n\n6. 函数名: xenbus_unmap_ring_vfree\n- 参数: [blkif->be->dev, ring->blk_ring]\n- 调用者: xen_blkif_disconnect\n- 被调用者: 未显示\n\n7. 函数名: xen_blkbk_free_caches\n- 参数: [ring]\n- 调用者: xen_blkif_disconnect\n- 被调用者: 未显示\n\n8. 函数名: kfree\n- 参数: [req->segments[j], req->indirect_pages[j], req, blkif->rings]\n- 调用者: xen_blkif_disconnect\n- 被调用者: 未显示\n\n9. 函数名: list_del\n- 参数: [&req->free_list]\n- 调用者: xen_blkif_disconnect\n- 被调用者: 未显示\n\n10. 函数名: BUG_ON\n- 参数: [atomic_read(&ring->persistent_gnt_in_use) != 0, !list_empty(&ring->persistent_purge_list), !RB_EMPTY_ROOT(&ring->persistent_gnts), ring->free_pages.num_pages != 0, ring->persistent_gnt_c != 0]\n- 调用者: xen_blkif_disconnect\n- 被调用者: 未显示\n\n11. 函数名: WARN_ON\n- 参数: [i != (XEN_BLKIF_REQS_PER_PAGE * blkif->nr_ring_pages)]\n- 调用者: xen_blkif_disconnect\n- 被调用者: 未显示"
    },
    {
        "id": 2700,
        "cwe": "CWE-416",
        "cve": "CVE-2020-29660",
        "purpose": "Code purpose:\"\"\"该代码用于在SAK(安全注意键)触发时，终止与指定tty终端相关的所有进程，包括会话内的进程和打开该tty的进程。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于tty子系统中的锁机制不一致，导致在TIOCGSID操作时可能发生释放后重用(read-after-free)的安全问题\"\"\"",
        "functions": "Functions:\n1. 函数名: __do_SAK\n- 参数: [struct tty_struct *tty]\n- 调用者: 未显示\n- 被调用者: [tty_hangup, tty_ldisc_flush, tty_driver_flush_buffer, read_lock, do_each_pid_task, task_pid_nr, tty_notice, group_send_sig_info, while_each_pid_task, do_each_thread, task_lock, iterate_fd, task_unlock, while_each_thread, read_unlock]\n\n2. 函数名: tty_hangup\n- 参数: [struct tty_struct *tty]\n- 调用者: __do_SAK\n- 被调用者: 未显示\n\n3. 函数名: tty_ldisc_flush\n- 参数: [struct tty_struct *tty]\n- 调用者: __do_SAK\n- 被调用者: 未显示\n\n4. 函数名: tty_driver_flush_buffer\n- 参数: [struct tty_struct *tty]\n- 调用者: __do_SAK\n- 被调用者: 未显示\n\n5. 函数名: read_lock\n- 参数: [&tasklist_lock]\n- 调用者: __do_SAK\n- 被调用者: 未显示\n\n6. 函数名: do_each_pid_task\n- 参数: [session, PIDTYPE_SID, p]\n- 调用者: __do_SAK\n- 被调用者: 未显示\n\n7. 函数名: task_pid_nr\n- 参数: [p]\n- 调用者: __do_SAK\n- 被调用者: 未显示\n\n8. 函数名: tty_notice\n- 参数: [tty, \"SAK: killed process %d (%s): by session\\n\", task_pid_nr(p), p->comm]\n- 调用者: __do_SAK\n- 被调用者: 未显示\n\n9. 函数名: group_send_sig_info\n- 参数: [SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID]\n- 调用者: __do_SAK\n- 被调用者: 未显示\n\n10. 函数名: while_each_pid_task\n- 参数: [session, PIDTYPE_SID, p]\n- 调用者: __do_SAK\n- 被调用者: 未显示\n\n11. 函数名: do_each_thread\n- 参数: [g, p]\n- 调用者: __do_SAK\n- 被调用者: 未显示\n\n12. 函数名: task_lock\n- 参数: [p]\n- 调用者: __do_SAK\n- 被调用者: 未显示\n\n13. 函数名: iterate_fd\n- 参数: [p->files, 0, this_tty, tty]\n- 调用者: __do_SAK\n- 被调用者: 未显示\n\n14. 函数名: task_unlock\n- 参数: [p]\n- 调用者: __do_SAK\n- 被调用者: 未显示\n\n15. 函数名: while_each_thread\n- 参数: [g, p]\n- 调用者: __do_SAK\n- 被调用者: 未显示\n\n16. 函数名: read_unlock\n- 参数: [&tasklist_lock]\n- 调用者: __do_SAK\n- 被调用者: 未显示"
    },
    {
        "id": 2701,
        "cwe": "CWE-416",
        "cve": "CVE-2020-29660",
        "purpose": "Code purpose:\"\"\"该代码用于在进程退出或失去控制终端时，正确处理与控制终端(tty)相关的会话和进程组关系，包括发送信号和清理资源。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在释放tty结构体后未正确同步锁状态，导致存在读取后释放(read-after-free)的风险。\"\"\"",
        "functions": "Functions:\n1. 函数名: disassociate_ctty\n- 参数: [on_exit]\n- 调用者: N/A\n- 被调用者: [get_current_tty, tty_vhangup_session, tty_get_pgrp, kill_pgrp, put_pid, tty_kref_put, spin_lock_irq, spin_unlock_irq, tty_kref_get, spin_lock_irqsave, spin_unlock_irqrestore, read_lock, session_clear_tty, read_unlock]\n\n2. 函数名: get_current_tty\n- 参数: []\n- 调用者: disassociate_ctty\n- 被调用者: []\n\n3. 函数名: tty_vhangup_session\n- 参数: [tty]\n- 调用者: disassociate_ctty\n- 被调用者: []\n\n4. 函数名: tty_get_pgrp\n- 参数: [tty]\n- 调用者: disassociate_ctty\n- 被调用者: []\n\n5. 函数名: kill_pgrp\n- 参数: [tty_pgrp, SIGHUP, on_exit]\n- 调用者: disassociate_ctty\n- 被调用者: []\n\n6. 函数名: put_pid\n- 参数: [tty_pgrp]\n- 调用者: disassociate_ctty\n- 被调用者: []\n\n7. 函数名: tty_kref_put\n- 参数: [tty]\n- 调用者: disassociate_ctty\n- 被调用者: []\n\n8. 函数名: spin_lock_irq\n- 参数: [&current->sighand->siglock]\n- 调用者: disassociate_ctty\n- 被调用者: []\n\n9. 函数名: spin_unlock_irq\n- 参数: [&current->sighand->siglock]\n- 调用者: disassociate_ctty\n- 被调用者: []\n\n10. 函数名: tty_kref_get\n- 参数: [current->signal->tty]\n- 调用者: disassociate_ctty\n- 被调用者: []\n\n11. 函数名: spin_lock_irqsave\n- 参数: [&tty->ctrl_lock, flags]\n- 调用者: disassociate_ctty\n- 被调用者: []\n\n12. 函数名: spin_unlock_irqrestore\n- 参数: [&tty->ctrl_lock, flags]\n- 调用者: disassociate_ctty\n- 被调用者: []\n\n13. 函数名: read_lock\n- 参数: [&tasklist_lock]\n- 调用者: disassociate_ctty\n- 被调用者: []\n\n14. 函数名: session_clear_tty\n- 参数: [task_session(current)]\n- 调用者: disassociate_ctty\n- 被调用者: []\n\n15. 函数名: read_unlock\n- 参数: [&tasklist_lock]\n- 调用者: disassociate_ctty\n- 被调用者: []"
    },
    {
        "id": 2702,
        "cwe": "CWE-416",
        "cve": "CVE-2020-29660",
        "purpose": "Code purpose:\"\"\"设置当前进程的控制终端并更新相关进程组和会话信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放tty->session和tty->pgrp后未保持锁保护的情况下访问tty->session，导致可能发生读取释放后内存的竞争条件\"\"\"",
        "functions": "Functions:\n1. 函数名: __proc_set_tty\n- 参数: [struct tty_struct *tty]\n- 调用者: 不适用（静态函数）\n- 被调用者: [spin_lock_irqsave, put_pid, get_pid, task_pgrp, spin_unlock_irqrestore, task_session, tty_debug, tty_kref_put, tty_kref_get]\n\n2. 函数名: spin_lock_irqsave\n- 参数: [&tty->ctrl_lock, flags]\n- 调用者: __proc_set_tty\n- 被调用者: []\n\n3. 函数名: put_pid\n- 参数: [tty->session], [tty->pgrp], [current->signal->tty_old_pgrp]\n- 调用者: __proc_set_tty\n- 被调用者: []\n\n4. 函数名: get_pid\n- 参数: [task_pgrp(current)], [task_session(current)]\n- 调用者: __proc_set_tty\n- 被调用者: []\n\n5. 函数名: task_pgrp\n- 参数: [current]\n- 调用者: __proc_set_tty\n- 被调用者: []\n\n6. 函数名: spin_unlock_irqrestore\n- 参数: [&tty->ctrl_lock, flags]\n- 调用者: __proc_set_tty\n- 被调用者: []\n\n7. 函数名: task_session\n- 参数: [current]\n- 调用者: __proc_set_tty\n- 被调用者: []\n\n8. 函数名: tty_debug\n- 参数: [tty, \"current tty %s not NULL!!\\n\", current->signal->tty->name]\n- 调用者: __proc_set_tty\n- 被调用者: []\n\n9. 函数名: tty_kref_put\n- 参数: [current->signal->tty]\n- 调用者: __proc_set_tty\n- 被调用者: []\n\n10. 函数名: tty_kref_get\n- 参数: [tty]\n- 调用者: __proc_set_tty\n- 被调用者: []"
    },
    {
        "id": 2703,
        "cwe": "CWE-416",
        "cve": "CVE-2020-29660",
        "purpose": "Code purpose:\"\"\"该代码用于获取终端会话ID并返回给用户空间，同时进行一些权限和状态检查\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺乏适当的锁保护，导致在检查real_tty->session时可能发生读取释放后内存(read-after-free)的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: tiocgsid\n- 参数: [tty, real_tty, p]\n- 调用者: 未明确（由内核tty子系统调用）\n- 被调用者: [put_user, pid_vnr]\n\n2. 函数名: put_user\n- 参数: [value, ptr]\n- 调用者: tiocgsid\n- 被调用者: []\n\n3. 函数名: pid_vnr\n- 参数: [pid]\n- 调用者: tiocgsid\n- 被调用者: []"
    },
    {
        "id": 2704,
        "cwe": "CWE-416",
        "cve": "CVE-2020-29660",
        "purpose": "Code purpose:\"\"\"该代码用于设置终端的前台进程组ID，涉及权限检查、进程组查找和锁定操作，以确保安全地更新终端控制信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在tty子系统中的锁机制不一致，导致在TIOCGSID操作时可能发生读取释放后内存的竞态条件问题\"\"\"",
        "functions": "Functions:\n1. 函数名: tiocspgrp\n- 参数: [tty, real_tty, p]\n- 调用者: 未显示（系统调用或内核其他部分）\n- 被调用者: [tty_check_change, get_user, find_vpid, session_of_pgrp, put_pid, get_pid, spin_lock_irq, spin_unlock_irq, rcu_read_lock, rcu_read_unlock]\n\n2. 函数名: tty_check_change\n- 参数: [real_tty]\n- 调用者: tiocspgrp\n- 被调用者: 未显示\n\n3. 函数名: get_user\n- 参数: [pgrp_nr, p]\n- 调用者: tiocspgrp\n- 被调用者: 未显示\n\n4. 函数名: find_vpid\n- 参数: [pgrp_nr]\n- 调用者: tiocspgrp\n- 被调用者: 未显示\n\n5. 函数名: session_of_pgrp\n- 参数: [pgrp]\n- 调用者: tiocspgrp\n- 被调用者: 未显示\n\n6. 函数名: put_pid\n- 参数: [real_tty->pgrp]\n- 调用者: tiocspgrp\n- 被调用者: 未显示\n\n7. 函数名: get_pid\n- 参数: [pgrp]\n- 调用者: tiocspgrp\n- 被调用者: 未显示\n\n8. 函数名: spin_lock_irq\n- 参数: [&real_tty->ctrl_lock]\n- 调用者: tiocspgrp\n- 被调用者: 未显示\n\n9. 函数名: spin_unlock_irq\n- 参数: [&real_tty->ctrl_lock]\n- 调用者: tiocspgrp\n- 被调用者: 未显示\n\n10. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: tiocspgrp\n- 被调用者: 未显示\n\n11. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: tiocspgrp\n- 被调用者: 未显示"
    },
    {
        "id": 2717,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36313",
        "purpose": "Code purpose:\"\"\"该代码用于在KVM虚拟化环境中处理s390架构的CMMA(协作内存管理辅助)脏页位图获取操作，包括遍历内存槽中的脏页并清除相应标志位。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在KVM子系统中，删除内存槽后未正确处理后续访问，导致可以越界访问已删除的内存槽。\"\"\"",
        "functions": "Functions:\n1. 函数名: kvm_s390_get_cmma\n- 参数: [kvm, args, res, bufsize]\n- 调用者: 未显示\n- 被调用者: [kvm_memslots, kvm_s390_next_dirty_cmma, gfn_to_memslot, gfn_to_hva, kvm_is_error_hva, test_and_clear_bit, kvm_second_dirty_bitmap, atomic64_dec, get_pgste]\n\n2. 函数名: kvm_memslots\n- 参数: [kvm]\n- 调用者: kvm_s390_get_cmma\n- 被调用者: 未显示\n\n3. 函数名: kvm_s390_next_dirty_cmma\n- 参数: [slots, start_gfn]\n- 调用者: kvm_s390_get_cmma\n- 被调用者: 未显示\n\n4. 函数名: gfn_to_memslot\n- 参数: [kvm, cur_gfn]\n- 调用者: kvm_s390_get_cmma\n- 被调用者: 未显示\n\n5. 函数名: gfn_to_hva\n- 参数: [kvm, cur_gfn]\n- 调用者: kvm_s390_get_cmma\n- 被调用者: 未显示\n\n6. 函数名: kvm_is_error_hva\n- 参数: [hva]\n- 调用者: kvm_s390_get_cmma\n- 被调用者: 未显示\n\n7. 函数名: test_and_clear_bit\n- 参数: [cur_gfn - ms->base_gfn, kvm_second_dirty_bitmap(ms)]\n- 调用者: kvm_s390_get_cmma\n- 被调用者: 未显示\n\n8. 函数名: kvm_second_dirty_bitmap\n- 参数: [ms]\n- 调用者: kvm_s390_get_cmma\n- 被调用者: 未显示\n\n9. 函数名: atomic64_dec\n- 参数: [&kvm->arch.cmma_dirty_pages]\n- 调用者: kvm_s390_get_cmma\n- 被调用者: 未显示\n\n10. 函数名: get_pgste\n- 参数: [kvm->mm, hva, &pgstev]\n- 调用者: kvm_s390_get_cmma\n- 被调用者: 未显示"
    },
    {
        "id": 2718,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36313",
        "purpose": "Code purpose:\"\"\"在KVM内存管理子系统中通过二分查找算法搜索与给定客户帧号(gfn)匹配的内存槽(memslot)。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在删除内存槽后未正确更新相关索引，导致后续访问可能越界访问已删除的内存槽\"\"\"",
        "functions": "Functions:\n1. 函数名: search_memslots\n- 参数: [struct kvm_memslots *slots, gfn_t gfn]\n- 调用者: 未明确（由KVM子系统调用）\n- 被调用者: [atomic_read, atomic_set]\n\n2. 函数名: atomic_read\n- 参数: [&slots->lru_slot]\n- 调用者: search_memslots\n- 被调用者: []\n\n3. 函数名: atomic_set\n- 参数: [&slots->lru_slot, start]\n- 调用者: search_memslots\n- 被调用者: []"
    },
    {
        "id": 2719,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36313",
        "purpose": "Code purpose:\"\"\"该代码用于在KVM子系统中删除内存槽(memslot)并更新相关索引信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在删除内存槽后未正确更新索引，导致后续访问可能越界\"\"\"",
        "functions": "Functions:\n1. 函数名: kvm_memslot_delete\n- 参数: [slots, memslot]\n- 调用者: 未明确显示（通常由KVM子系统相关代码调用）\n- 被调用者: [WARN_ON]\n\n2. 函数名: WARN_ON\n- 参数: [condition]\n- 调用者: kvm_memslot_delete\n- 被调用者: []"
    },
    {
        "id": 2752,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36385",
        "purpose": "Code purpose:\"\"\"该代码实现了将RDMA用户连接管理上下文从一个文件描述符迁移到另一个文件描述符的功能，包括迁移事件和更新上下文列表。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ucma_migrate_id函数中，当ucma_close被调用时，ctx可能通过ctx_list被访问，导致在迁移过程中出现use-after-free问题\"\"\"",
        "functions": "Functions:\n1. 函数名: ucma_migrate_id\n- 参数: [struct ucma_file *new_file, const char __user *inbuf, int in_len, int out_len]\n- 调用者: 未明确（由内核调用）\n- 被调用者: [copy_from_user, fdget, ucma_get_ctx, rdma_lock_handler, mutex_lock, mutex_unlock, ucma_lock_files, xa_lock, list_move_tail, ucma_move_events, xa_unlock, ucma_unlock_files, copy_to_user, u64_to_user_ptr, rdma_unlock_handler, ucma_put_ctx, fdput]\n\n2. 函数名: copy_from_user\n- 参数: [&cmd, inbuf, sizeof(cmd)]\n- 调用者: ucma_migrate_id\n- 被调用者: []\n\n3. 函数名: fdget\n- 参数: [cmd.fd]\n- 调用者: ucma_migrate_id\n- 被调用者: []\n\n4. 函数名: ucma_get_ctx\n- 参数: [f.file->private_data, cmd.id]\n- 调用者: ucma_migrate_id\n- 被调用者: []\n\n5. 函数名: rdma_lock_handler\n- 参数: [ctx->cm_id]\n- 调用者: ucma_migrate_id\n- 被调用者: []\n\n6. 函数名: mutex_lock\n- 参数: [&cur_file->mut]\n- 调用者: ucma_migrate_id\n- 被调用者: []\n\n7. 函数名: mutex_unlock\n- 参数: [&cur_file->mut]\n- 调用者: ucma_migrate_id\n- 被调用者: []\n\n8. 函数名: ucma_lock_files\n- 参数: [cur_file, new_file]\n- 调用者: ucma_migrate_id\n- 被调用者: []\n\n9. 函数名: xa_lock\n- 参数: [&ctx_table]\n- 调用者: ucma_migrate_id\n- 被调用者: []\n\n10. 函数名: list_move_tail\n- 参数: [&ctx->list, &new_file->ctx_list]\n- 调用者: ucma_migrate_id\n- 被调用者: []\n\n11. 函数名: ucma_move_events\n- 参数: [ctx, new_file]\n- 调用者: ucma_migrate_id\n- 被调用者: []\n\n12. 函数名: xa_unlock\n- 参数: [&ctx_table]\n- 调用者: ucma_migrate_id\n- 被调用者: []\n\n13. 函数名: ucma_unlock_files\n- 参数: [cur_file, new_file]\n- 调用者: ucma_migrate_id\n- 被调用者: []\n\n14. 函数名: copy_to_user\n- 参数: [u64_to_user_ptr(cmd.response), &resp, sizeof(resp)]\n- 调用者: ucma_migrate_id\n- 被调用者: [u64_to_user_ptr]\n\n15. 函数名: u64_to_user_ptr\n- 参数: [cmd.response]\n- 调用者: copy_to_user\n- 被调用者: []\n\n16. 函数名: rdma_unlock_handler\n- 参数: [ctx->cm_id]\n- 调用者: ucma_migrate_id\n- 被调用者: []\n\n17. 函数名: ucma_put_ctx\n- 参数: [ctx]\n- 调用者: ucma_migrate_id\n- 被调用者: []\n\n18. 函数名: fdput\n- 参数: [f]\n- 调用者: ucma_migrate_id\n- 被调用者: []"
    },
    {
        "id": 2754,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36387",
        "purpose": "Code purpose:\"\"\"在io_uring子系统中处理I/O请求的重新提交，包括获取内存映射和准备重新提交条件\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_rw_resubmit函数中，由于未正确处理io_kiocb结构体的引用计数，导致在异步任务处理时可能发生释放后使用的问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_rw_resubmit\n- 参数: [struct callback_head *cb]\n- 调用者: 未明确显示（通常由内核任务调度机制调用）\n- 被调用者: [container_of, io_sq_thread_acquire_mm, io_resubmit_prep, refcount_inc, io_queue_async_work]\n\n2. 函数名: container_of\n- 参数: [cb, struct io_kiocb, task_work]\n- 调用者: io_rw_resubmit\n- 被调用者: []\n\n3. 函数名: io_sq_thread_acquire_mm\n- 参数: [ctx, req]\n- 调用者: io_rw_resubmit\n- 被调用者: []\n\n4. 函数名: io_resubmit_prep\n- 参数: [req, err]\n- 调用者: io_rw_resubmit\n- 被调用者: []\n\n5. 函数名: refcount_inc\n- 参数: [&req->refs]\n- 调用者: io_rw_resubmit\n- 被调用者: []\n\n6. 函数名: io_queue_async_work\n- 参数: [req]\n- 调用者: io_rw_resubmit\n- 被调用者: []"
    },
    {
        "id": 2755,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36387",
        "purpose": "Code purpose:\"\"\"处理IO轮询任务并通过回调机制提交下一个请求\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核5.8.2之前版本中，fs/io_uring.c的io_poll_task_func函数存在引用计数管理不当，导致io_async_task_func相关上下文引用被释放后仍被使用的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: io_poll_task_func\n- 参数: [struct callback_head *cb]\n- 调用者: 未显示\n- 被调用者: [container_of, io_poll_task_handler, __io_req_task_submit]\n\n2. 函数名: io_poll_task_handler\n- 参数: [struct io_kiocb *req, struct io_kiocb **nxt]\n- 调用者: io_poll_task_func\n- 被调用者: 未显示\n\n3. 函数名: __io_req_task_submit\n- 参数: [struct io_kiocb *nxt]\n- 调用者: io_poll_task_func\n- 被调用者: 未显示\n\n4. 函数名: container_of\n- 参数: [struct callback_head *cb, struct io_kiocb, task_work]\n- 调用者: io_poll_task_func\n- 被调用者: 未显示"
    },
    {
        "id": 2756,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36387",
        "purpose": "Code purpose:\"\"\"处理异步I/O请求的任务工作，包括轮询状态检查、哈希节点删除和请求提交或取消\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_async_task_func函数中，由于未正确维护ctx引用计数，导致在异步任务处理过程中可能发生上下文(ctx)的提前释放，从而引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_async_task_func\n- 参数: [struct callback_head *cb]\n- 调用者: 未明确显示（可能是内核任务调度机制）\n- 被调用者: [container_of, trace_io_uring_task_run, io_poll_rewait, spin_unlock_irq, hash_hashed, hash_del, io_poll_remove_double, READ_ONCE, __io_req_task_submit, __io_req_task_cancel, kfree]\n\n2. 函数名: container_of\n- 参数: [cb, struct io_kiocb, task_work]\n- 调用者: io_async_task_func\n- 被调用者: []\n\n3. 函数名: trace_io_uring_task_run\n- 参数: [req->ctx, req->opcode, req->user_data]\n- 调用者: io_async_task_func\n- 被调用者: []\n\n4. 函数名: io_poll_rewait\n- 参数: [req, &apoll->poll]\n- 调用者: io_async_task_func\n- 被调用者: []\n\n5. 函数名: spin_unlock_irq\n- 参数: [&ctx->completion_lock]\n- 调用者: io_async_task_func\n- 被调用者: []\n\n6. 函数名: hash_hashed\n- 参数: [&req->hash_node]\n- 调用者: io_async_task_func\n- 被调用者: []\n\n7. 函数名: hash_del\n- 参数: [&req->hash_node]\n- 调用者: io_async_task_func\n- 被调用者: []\n\n8. 函数名: io_poll_remove_double\n- 参数: [req, apoll->double_poll]\n- 调用者: io_async_task_func\n- 被调用者: []\n\n9. 函数名: READ_ONCE\n- 参数: [apoll->poll.canceled]\n- 调用者: io_async_task_func\n- 被调用者: []\n\n10. 函数名: __io_req_task_submit\n- 参数: [req]\n- 调用者: io_async_task_func\n- 被调用者: []\n\n11. 函数名: __io_req_task_cancel\n- 参数: [req, -ECANCELED]\n- 调用者: io_async_task_func\n- 被调用者: []\n\n12. 函数名: kfree\n- 参数: [apoll->double_poll, apoll]\n- 调用者: io_async_task_func\n- 被调用者: []"
    },
    {
        "id": 2757,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36387",
        "purpose": "Code purpose:\"\"\"处理异步I/O请求的唤醒和任务提交，在页面等待队列匹配时执行任务提交或取消操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_async_buf_func函数中，由于未正确处理io_kiocb请求的引用计数，导致在异步操作中可能发生释放后重用(use-after-free)的情况。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_async_buf_func\n- 参数: [struct wait_queue_entry *wait, unsigned mode, int sync, void *arg]\n- 调用者: N/A (内核回调函数)\n- 被调用者: [wake_page_match, list_del_init, init_task_work, refcount_inc, io_req_task_work_add, io_wq_get_task, task_work_add, wake_up_process]\n\n2. 函数名: wake_page_match\n- 参数: [struct wait_page_queue *wpq, struct wait_page_key *key]\n- 调用者: io_async_buf_func\n- 被调用者: N/A\n\n3. 函数名: list_del_init\n- 参数: [struct list_head *entry]\n- 调用者: io_async_buf_func\n- 被调用者: N/A\n\n4. 函数名: init_task_work\n- 参数: [struct callback_head *twork, task_work_func_t func]\n- 调用者: io_async_buf_func\n- 被调用者: N/A\n\n5. 函数名: refcount_inc\n- 参数: [atomic_t *r]\n- 调用者: io_async_buf_func\n- 被调用者: N/A\n\n6. 函数名: io_req_task_work_add\n- 参数: [struct io_kiocb *req, struct callback_head *twork]\n- 调用者: io_async_buf_func\n- 被调用者: N/A\n\n7. 函数名: io_wq_get_task\n- 参数: [struct io_wq *wq]\n- 调用者: io_async_buf_func\n- 被调用者: N/A\n\n8. 函数名: task_work_add\n- 参数: [struct task_struct *tsk, struct callback_head *twork, bool notify]\n- 调用者: io_async_buf_func\n- 被调用者: N/A\n\n9. 函数名: wake_up_process\n- 参数: [struct task_struct *tsk]\n- 调用者: io_async_buf_func\n- 被调用者: N/A"
    },
    {
        "id": 2758,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36387",
        "purpose": "Code purpose:\"\"\"处理IO请求的异步唤醒操作，包括事件匹配检查、任务工作添加和取消处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_async_wake函数中，当io_req_task_work_add失败时，未正确处理上下文引用计数导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: __io_async_wake\n- 参数: [req, poll, mask, func]\n- 调用者: 未明确显示（上下文缺失）\n- 被调用者: [list_del_init, trace_io_uring_task_add, init_task_work, io_req_task_work_add, WRITE_ONCE, io_wq_get_task, task_work_add, wake_up_process]\n\n2. 函数名: list_del_init\n- 参数: [&poll->wait.entry]\n- 调用者: __io_async_wake\n- 被调用者: []\n\n3. 函数名: trace_io_uring_task_add\n- 参数: [req->ctx, req->opcode, req->user_data, mask]\n- 调用者: __io_async_wake\n- 被调用者: []\n\n4. 函数名: init_task_work\n- 参数: [&req->task_work, func]\n- 调用者: __io_async_wake\n- 被调用者: []\n\n5. 函数名: io_req_task_work_add\n- 参数: [req, &req->task_work]\n- 调用者: __io_async_wake\n- 被调用者: []\n\n6. 函数名: WRITE_ONCE\n- 参数: [poll->canceled, true]\n- 调用者: __io_async_wake\n- 被调用者: []\n\n7. 函数名: io_wq_get_task\n- 参数: [req->ctx->io_wq]\n- 调用者: __io_async_wake\n- 被调用者: []\n\n8. 函数名: task_work_add\n- 参数: [tsk, &req->task_work, 0]\n- 调用者: __io_async_wake\n- 被调用者: []\n\n9. 函数名: wake_up_process\n- 参数: [tsk]\n- 调用者: __io_async_wake\n- 被调用者: []"
    },
    {
        "id": 2759,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36387",
        "purpose": "Code purpose:\"\"\"该代码片段用于管理IO请求的任务队列，包括任务提交和取消的处理，并确保任务被正确添加到工作队列中执行\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_req_task_queue函数中，当io_req_task_work_add失败时，错误处理路径中未正确管理ctx引用计数，导致后续可能发生use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_req_task_queue\n- 参数: [struct io_kiocb *req]\n- 调用者: 未显示\n- 被调用者: [init_task_work, io_req_task_work_add, io_wq_get_task, task_work_add, wake_up_process]\n\n2. 函数名: init_task_work\n- 参数: [&req->task_work, io_req_task_submit/io_req_task_cancel]\n- 调用者: io_req_task_queue\n- 被调用者: 未显示\n\n3. 函数名: io_req_task_work_add\n- 参数: [req, &req->task_work]\n- 调用者: io_req_task_queue\n- 被调用者: 未显示\n\n4. 函数名: io_wq_get_task\n- 参数: [req->ctx->io_wq]\n- 调用者: io_req_task_queue\n- 被调用者: 未显示\n\n5. 函数名: task_work_add\n- 参数: [tsk, &req->task_work, 0]\n- 调用者: io_req_task_queue\n- 被调用者: 未显示\n\n6. 函数名: wake_up_process\n- 参数: [tsk]\n- 调用者: io_req_task_queue\n- 被调用者: 未显示"
    },
    {
        "id": 2760,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36387",
        "purpose": "Code purpose:\"\"\"处理IO请求的重新提交，当遇到特定错误或不在工作线程中时返回false，否则尝试添加任务工作并返回结果\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_rw_reissue函数中，由于未正确处理任务工作项和上下文引用，导致在异步任务处理时可能发生释放后使用(UAF)的问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_rw_reissue\n- 参数: [req, res]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [init_task_work, io_req_task_work_add, io_wq_current_is_worker]\n\n2. 函数名: init_task_work\n- 参数: [&req->task_work, io_rw_resubmit]\n- 调用者: io_rw_reissue\n- 被调用者: 未明确（上下文未提供）\n\n3. 函数名: io_req_task_work_add\n- 参数: [req, &req->task_work]\n- 调用者: io_rw_reissue\n- 被调用者: 未明确（上下文未提供）\n\n4. 函数名: io_wq_current_is_worker\n- 参数: []\n- 调用者: io_rw_reissue\n- 被调用者: 未明确（上下文未提供）\n\n5. 函数名: io_rw_resubmit\n- 参数: 未明确（仅作为函数指针传递）\n- 调用者: 通过init_task_work初始化后由内核任务调度调用\n- 被调用者: 未明确（上下文未提供）"
    },
    {
        "id": 2761,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36387",
        "purpose": "Code purpose:\"\"\"通过回调函数提交异步I/O请求任务\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核5.8.2之前版本中，fs/io_uring.c存在io_async_task_func与ctx引用持有相关的释放后使用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_req_task_submit\n- 参数: [struct callback_head *cb]\n- 调用者: 未明确（由系统或内核其他部分调用）\n- 被调用者: [container_of, __io_req_task_submit]\n\n2. 函数名: container_of\n- 参数: [cb, struct io_kiocb, task_work]（根据上下文推断）\n- 调用者: io_req_task_submit\n- 被调用者: []\n\n3. 函数名: __io_req_task_submit\n- 参数: [struct io_kiocb *req]\n- 调用者: io_req_task_submit\n- 被调用者: []"
    },
    {
        "id": 2763,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36557",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中安装控制台终端，处理终端驱动程序和tty结构的关联及初始化工作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在VT_DISALLOCATE ioctl操作与tty关闭/打开之间存在竞态条件，导致对已释放的vc_data结构体的后续使用，引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: con_install\n- 参数: [driver, tty]\n- 调用者: 未明确显示（应为tty子系统调用）\n- 被调用者: [console_lock, vc_allocate, tty_port_install, console_unlock]\n\n2. 函数名: console_lock\n- 参数: []\n- 调用者: con_install\n- 被调用者: []\n\n3. 函数名: vc_allocate\n- 参数: [currcons]\n- 调用者: con_install\n- 被调用者: []\n\n4. 函数名: tty_port_install\n- 参数: [&vc->port, driver, tty]\n- 调用者: con_install\n- 被调用者: []\n\n5. 函数名: console_unlock\n- 参数: []\n- 调用者: con_install\n- 被调用者: []"
    },
    {
        "id": 2764,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36557",
        "purpose": "Code purpose:\"\"\"分配并初始化虚拟控制台数据结构，包括内存分配、屏幕缓冲区设置和系统通知等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在VT_DISALLOCATE ioctl操作与tty设备的关闭/打开之间存在竞争条件，导致内核在释放vc_data结构后仍可能被访问，造成释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: vc_allocate\n- 参数: [unsigned int currcons]\n- 调用者: 未显示\n- 被调用者: [kzalloc, tty_port_init, INIT_WORK, visual_init, con_set_default_unimap, kzalloc, vc_init, vcs_make_sysfs, atomic_notifier_call_chain, visual_deinit, kfree]\n\n2. 函数名: WARN_CONSOLE_UNLOCKED\n- 参数: []\n- 调用者: vc_allocate\n- 被调用者: []\n\n3. 函数名: kzalloc\n- 参数: [sizeof(struct vc_data), GFP_KERNEL]\n- 调用者: vc_allocate\n- 被调用者: []\n\n4. 函数名: tty_port_init\n- 参数: [&vc->port]\n- 调用者: vc_allocate\n- 被调用者: []\n\n5. 函数名: INIT_WORK\n- 参数: [&vc_cons[currcons].SAK_work, vc_SAK]\n- 调用者: vc_allocate\n- 被调用者: []\n\n6. 函数名: visual_init\n- 参数: [vc, currcons, 1]\n- 调用者: vc_allocate\n- 被调用者: []\n\n7. 函数名: con_set_default_unimap\n- 参数: [vc]\n- 调用者: vc_allocate\n- 被调用者: []\n\n8. 函数名: vc_init\n- 参数: [vc, vc->vc_rows, vc->vc_cols, 1]\n- 调用者: vc_allocate\n- 被调用者: []\n\n9. 函数名: vcs_make_sysfs\n- 参数: [currcons]\n- 调用者: vc_allocate\n- 被调用者: []\n\n10. 函数名: atomic_notifier_call_chain\n- 参数: [&vt_notifier_list, VT_ALLOCATE, &param]\n- 调用者: vc_allocate\n- 被调用者: []\n\n11. 函数名: visual_deinit\n- 参数: [vc]\n- 调用者: vc_allocate\n- 被调用者: []\n\n12. 函数名: kfree\n- 参数: [vc]\n- 调用者: vc_allocate\n- 被调用者: []"
    },
    {
        "id": 2765,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36557",
        "purpose": "Code purpose:\"\"\"该代码用于释放指定的虚拟控制台资源，包括检查控制台是否繁忙、解除分配以及清理相关数据结构。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在VT_DISALLOCATE ioctl操作与tty设备关闭/打开之间存在竞争条件，导致释放后使用(use-after-free)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: vt_disallocate\n- 参数: [unsigned int vc_num]\n- 调用者: 未显示\n- 被调用者: [console_lock, vt_busy, vc_deallocate, console_unlock, tty_port_destroy, kfree]\n\n2. 函数名: console_lock\n- 参数: []\n- 调用者: vt_disallocate\n- 被调用者: 未显示\n\n3. 函数名: vt_busy\n- 参数: [unsigned int vc_num]\n- 调用者: vt_disallocate\n- 被调用者: 未显示\n\n4. 函数名: vc_deallocate\n- 参数: [unsigned int vc_num]\n- 调用者: vt_disallocate\n- 被调用者: 未显示\n\n5. 函数名: console_unlock\n- 参数: []\n- 调用者: vt_disallocate\n- 被调用者: 未显示\n\n6. 函数名: tty_port_destroy\n- 参数: [&vc->port]\n- 调用者: vt_disallocate\n- 被调用者: 未显示\n\n7. 函数名: kfree\n- 参数: [vc]\n- 调用者: vt_disallocate\n- 被调用者: 未显示"
    },
    {
        "id": 2766,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36557",
        "purpose": "Code purpose:\"\"\"该代码用于释放所有未使用的虚拟控制台资源，包括销毁端口和释放内存。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放虚拟终端(vc)资源时，由于缺少对资源状态的同步保护，导致在并发操作中可能出现释放后仍被访问的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: vt_disallocate_all\n- 参数: []\n- 调用者: N/A\n- 被调用者: [console_lock, vt_busy, vc_deallocate, console_unlock, tty_port_destroy, kfree]\n\n2. 函数名: console_lock\n- 参数: []\n- 调用者: vt_disallocate_all\n- 被调用者: []\n\n3. 函数名: vt_busy\n- 参数: [i]\n- 调用者: vt_disallocate_all\n- 被调用者: []\n\n4. 函数名: vc_deallocate\n- 参数: [i]\n- 调用者: vt_disallocate_all\n- 被调用者: []\n\n5. 函数名: console_unlock\n- 参数: []\n- 调用者: vt_disallocate_all\n- 被调用者: []\n\n6. 函数名: tty_port_destroy\n- 参数: [&vc[i]->port]\n- 调用者: vt_disallocate_all\n- 被调用者: []\n\n7. 函数名: kfree\n- 参数: [vc[i]]\n- 调用者: vt_disallocate_all\n- 被调用者: []"
    },
    {
        "id": 2770,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36694",
        "purpose": "Code purpose:\"\"\"为网络过滤表分配并初始化计数器，用于原子快照式记录数据包处理状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发替换iptables规则时，由于对每CPU序列计数的处理不当，导致数据包处理上下文中出现释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: alloc_counters\n- 参数: [const struct xt_table *table]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [vzalloc, ERR_PTR, get_counters]\n\n2. 函数名: vzalloc\n- 参数: [unsigned int countersize]\n- 调用者: alloc_counters\n- 被调用者: []\n\n3. 函数名: ERR_PTR\n- 参数: [long -ENOMEM]\n- 调用者: alloc_counters\n- 被调用者: []\n\n4. 函数名: get_counters\n- 参数: [const struct xt_table_info *private, struct xt_counters *counters]\n- 调用者: alloc_counters\n- 被调用者: []"
    },
    {
        "id": 2771,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36694",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中netfilter模块的ARP表处理功能，用于根据ARP数据包和iptables规则进行数据包过滤和决策处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发替换iptables规则时，由于对每CPU序列计数的处理不当，导致数据包处理上下文中出现释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: arpt_do_table\n- 参数: [struct sk_buff *skb, const struct nf_hook_state *state, struct xt_table *table]\n- 调用者: N/A (内核调用)\n- 被调用者: [pskb_may_pull, arp_hdr_len, READ_ONCE, smp_processor_id, get_entry, arp_packet_match, arpt_next_entry, xt_get_this_cpu_counter, ADD_COUNTER, arpt_get_target_c, xt_write_recseq_begin, xt_write_recseq_end, local_bh_disable, local_bh_enable]\n\n2. 函数名: pskb_may_pull\n- 参数: [struct sk_buff *skb, unsigned int len]\n- 调用者: arpt_do_table\n- 被调用者: N/A\n\n3. 函数名: arp_hdr_len\n- 参数: [struct net_device *dev]\n- 调用者: arpt_do_table\n- 被调用者: N/A\n\n4. 函数名: READ_ONCE\n- 参数: [volatile void *ptr]\n- 调用者: arpt_do_table\n- 被调用者: N/A\n\n5. 函数名: smp_processor_id\n- 参数: []\n- 调用者: arpt_do_table\n- 被调用者: N/A\n\n6. 函数名: get_entry\n- 参数: [const void *table_base, unsigned int offset]\n- 调用者: arpt_do_table\n- 被调用者: N/A\n\n7. 函数名: arp_packet_match\n- 参数: [const struct arphdr *arp, struct net_device *dev, const char *indev, const char *outdev, struct arpt_arp *arpinfo]\n- 调用者: arpt_do_table\n- 被调用者: N/A\n\n8. 函数名: arpt_next_entry\n- 参数: [struct arpt_entry *entry]\n- 调用者: arpt_do_table\n- 被调用者: N/A\n\n9. 函数名: xt_get_this_cpu_counter\n- 参数: [struct xt_counters *counter]\n- 调用者: arpt_do_table\n- 被调用者: N/A\n\n10. 函数名: ADD_COUNTER\n- 参数: [struct xt_counters counter, unsigned int len, unsigned int packets]\n- 调用者: arpt_do_table\n- 被调用者: N/A\n\n11. 函数名: arpt_get_target_c\n- 参数: [struct arpt_entry *e]\n- 调用者: arpt_do_table\n- 被调用者: N/A\n\n12. 函数名: xt_write_recseq_begin\n- 参数: []\n- 调用者: arpt_do_table\n- 被调用者: N/A\n\n13. 函数名: xt_write_recseq_end\n- 参数: [unsigned int addend]\n- 调用者: arpt_do_table\n- 被调用者: N/A\n\n14. 函数名: local_bh_disable\n- 参数: []\n- 调用者: arpt_do_table\n- 被调用者: N/A\n\n15. 函数名: local_bh_enable\n- 参数: []\n- 调用者: arpt_do_table\n- 被调用者: N/A"
    },
    {
        "id": 2772,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36694",
        "purpose": "Code purpose:\"\"\"该代码用于从用户空间获取网络表信息并返回给用户，处理ARP表的相关操作，包括查找、锁定表以及处理兼容性问题。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发替换iptables规则时，由于对每CPU序列计数的处理不当，导致数据包处理上下文中出现释放后使用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: get_info\n- 参数: [struct net *net, void __user *user, const int *len]\n- 调用者: N/A\n- 被调用者: [copy_from_user, xt_request_find_table_lock, IS_ERR, compat_table_info, xt_compat_flush_offsets, memset, memcpy, strcpy, copy_to_user, xt_table_unlock, module_put, PTR_ERR, xt_compat_lock, xt_compat_unlock]\n\n2. 函数名: copy_from_user\n- 参数: [name, user, sizeof(name)]\n- 调用者: get_info\n- 被调用者: N/A\n\n3. 函数名: xt_request_find_table_lock\n- 参数: [net, NFPROTO_ARP, name]\n- 调用者: get_info\n- 被调用者: N/A\n\n4. 函数名: IS_ERR\n- 参数: [t]\n- 调用者: get_info\n- 被调用者: N/A\n\n5. 函数名: compat_table_info\n- 参数: [private, &tmp]\n- 调用者: get_info\n- 被调用者: N/A\n\n6. 函数名: xt_compat_flush_offsets\n- 参数: [NFPROTO_ARP]\n- 调用者: get_info\n- 被调用者: N/A\n\n7. 函数名: memset\n- 参数: [&info, 0, sizeof(info)]\n- 调用者: get_info\n- 被调用者: N/A\n\n8. 函数名: memcpy\n- 参数: [info.hook_entry, private->hook_entry, sizeof(info.hook_entry)]\n- 调用者: get_info\n- 被调用者: N/A\n\n9. 函数名: memcpy\n- 参数: [info.underflow, private->underflow, sizeof(info.underflow)]\n- 调用者: get_info\n- 被调用者: N/A\n\n10. 函数名: strcpy\n- 参数: [info.name, name]\n- 调用者: get_info\n- 被调用者: N/A\n\n11. 函数名: copy_to_user\n- 参数: [user, &info, *len]\n- 调用者: get_info\n- 被调用者: N/A\n\n12. 函数名: xt_table_unlock\n- 参数: [t]\n- 调用者: get_info\n- 被调用者: N/A\n\n13. 函数名: module_put\n- 参数: [t->me]\n- 调用者: get_info\n- 被调用者: N/A\n\n14. 函数名: PTR_ERR\n- 参数: [t]\n- 调用者: get_info\n- 被调用者: N/A\n\n15. 函数名: xt_compat_lock\n- 参数: [NFPROTO_ARP]\n- 调用者: get_info\n- 被调用者: N/A\n\n16. 函数名: xt_compat_unlock\n- 参数: [NFPROTO_ARP]\n- 调用者: get_info\n- 被调用者: N/A"
    },
    {
        "id": 2773,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36694",
        "purpose": "Code purpose:\"\"\"将内核中的netfilter规则表条目以兼容格式复制到用户空间\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发替换iptables规则时，由于对每CPU序列计数的处理不当，导致数据包处理上下文中出现释放后使用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: compat_copy_entries_to_user\n- 参数: [total_size, table, userptr]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [alloc_counters, PTR_ERR, compat_copy_entry_to_user, vfree]\n\n2. 函数名: alloc_counters\n- 参数: [table]\n- 调用者: compat_copy_entries_to_user\n- 被调用者: 未明确\n\n3. 函数名: PTR_ERR\n- 参数: [counters]\n- 调用者: compat_copy_entries_to_user\n- 被调用者: 未明确\n\n4. 函数名: compat_copy_entry_to_user\n- 参数: [iter, pos, size, counters, i]\n- 调用者: compat_copy_entries_to_user\n- 被调用者: 未明确\n\n5. 函数名: vfree\n- 参数: [counters]\n- 调用者: compat_copy_entries_to_user\n- 被调用者: 未明确"
    },
    {
        "id": 2774,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36694",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核网络过滤模块中处理并发iptables规则替换时添加计数器，但存在并发处理不当导致释放后使用漏洞的风险\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发替换iptables规则时，由于对每CPU序列计数的处理不当，导致数据包处理上下文中出现释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: do_add_counters\n- 参数: [struct net *net, sockptr_t arg, unsigned int len]\n- 调用者: N/A\n- 被调用者: [xt_copy_counters, xt_find_table_lock, local_bh_disable, xt_write_recseq_begin, xt_entry_foreach, xt_get_this_cpu_counter, ADD_COUNTER, xt_write_recseq_end, local_bh_enable, xt_table_unlock, module_put, vfree]\n\n2. 函数名: xt_copy_counters\n- 参数: [sockptr_t arg, unsigned int len, struct xt_counters_info *tmp]\n- 调用者: do_add_counters\n- 被调用者: N/A\n\n3. 函数名: xt_find_table_lock\n- 参数: [struct net *net, NFPROTO_ARP, tmp.name]\n- 调用者: do_add_counters\n- 被调用者: N/A\n\n4. 函数名: local_bh_disable\n- 参数: []\n- 调用者: do_add_counters\n- 被调用者: N/A\n\n5. 函数名: xt_write_recseq_begin\n- 参数: []\n- 调用者: do_add_counters\n- 被调用者: N/A\n\n6. 函数名: xt_entry_foreach\n- 参数: [iter, private->entries, private->size]\n- 调用者: do_add_counters\n- 被调用者: N/A\n\n7. 函数名: xt_get_this_cpu_counter\n- 参数: [&iter->counters]\n- 调用者: do_add_counters\n- 被调用者: N/A\n\n8. 函数名: ADD_COUNTER\n- 参数: [*tmp, paddc[i].bcnt, paddc[i].pcnt]\n- 调用者: do_add_counters\n- 被调用者: N/A\n\n9. 函数名: xt_write_recseq_end\n- 参数: [addend]\n- 调用者: do_add_counters\n- 被调用者: N/A\n\n10. 函数名: local_bh_enable\n- 参数: []\n- 调用者: do_add_counters\n- 被调用者: N/A\n\n11. 函数名: xt_table_unlock\n- 参数: [t]\n- 调用者: do_add_counters\n- 被调用者: N/A\n\n12. 函数名: module_put\n- 参数: [t->me]\n- 调用者: do_add_counters\n- 被调用者: N/A\n\n13. 函数名: vfree\n- 参数: [paddc]\n- 调用者: do_add_counters\n- 被调用者: N/A"
    },
    {
        "id": 2775,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36694",
        "purpose": "Code purpose:\"\"\"该代码用于从用户空间获取ARP表条目并将其复制到内核空间进行处理，同时确保数据的一致性和正确性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发替换iptables规则时，由于对每CPU序列计数处理不当，导致数据包处理上下文中出现释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: get_entries\n- 参数: [struct net *net, struct arpt_get_entries __user *uptr, const int *len]\n- 调用者: 未明确（应为外部调用）\n- 被调用者: [copy_from_user, xt_find_table_lock, IS_ERR, copy_entries_to_user, module_put, xt_table_unlock, PTR_ERR]\n\n2. 函数名: copy_from_user\n- 参数: [&get, uptr, sizeof(get)]\n- 调用者: get_entries\n- 被调用者: 未明确（应为内核函数）\n\n3. 函数名: xt_find_table_lock\n- 参数: [net, NFPROTO_ARP, get.name]\n- 调用者: get_entries\n- 被调用者: 未明确（应为内核函数）\n\n4. 函数名: IS_ERR\n- 参数: [t]\n- 调用者: get_entries\n- 被调用者: 未明确（应为内核宏）\n\n5. 函数名: copy_entries_to_user\n- 参数: [private->size, t, uptr->entrytable]\n- 调用者: get_entries\n- 被调用者: 未明确（应为内核函数）\n\n6. 函数名: module_put\n- 参数: [t->me]\n- 调用者: get_entries\n- 被调用者: 未明确（应为内核函数）\n\n7. 函数名: xt_table_unlock\n- 参数: [t]\n- 调用者: get_entries\n- 被调用者: 未明确（应为内核函数）\n\n8. 函数名: PTR_ERR\n- 参数: [t]\n- 调用者: get_entries\n- 被调用者: 未明确（应为内核宏）"
    },
    {
        "id": 2776,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36694",
        "purpose": "Code purpose:\"\"\"将内核中的网络过滤表条目及其计数器复制到用户空间\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发替换iptables规则时，由于对每CPU序列计数的处理不当，导致数据包处理上下文中出现释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: copy_entries_to_user\n- 参数: [total_size, table, userptr]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [alloc_counters, PTR_ERR, copy_to_user, arpt_get_target_c, xt_target_to_user, vfree]\n\n2. 函数名: alloc_counters\n- 参数: [table]\n- 调用者: copy_entries_to_user\n- 被调用者: 未明确（上下文未提供）\n\n3. 函数名: PTR_ERR\n- 参数: [counters]\n- 调用者: copy_entries_to_user\n- 被调用者: 未明确（上下文未提供）\n\n4. 函数名: copy_to_user\n- 参数: [userptr + off, e, sizeof(*e)] 和 [userptr + off + offsetof(struct arpt_entry, counters), &counters[num], sizeof(counters[num])]\n- 调用者: copy_entries_to_user\n- 被调用者: 未明确（上下文未提供）\n\n5. 函数名: arpt_get_target_c\n- 参数: [e]\n- 调用者: copy_entries_to_user\n- 被调用者: 未明确（上下文未提供）\n\n6. 函数名: xt_target_to_user\n- 参数: [t, userptr + off + e->target_offset]\n- 调用者: copy_entries_to_user\n- 被调用者: 未明确（上下文未提供）\n\n7. 函数名: vfree\n- 参数: [counters]\n- 调用者: copy_entries_to_user\n- 被调用者: 未明确（上下文未提供）"
    },
    {
        "id": 2777,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36694",
        "purpose": "Code purpose:\"\"\"为网络过滤表分配并初始化计数器，获取当前计数器的原子快照\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发替换iptables规则时，由于对每CPU序列计数的处理不当，导致数据包处理上下文中出现释放后使用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: alloc_counters\n- 参数: [const struct xt_table *table]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [vzalloc, ERR_PTR, get_counters]\n\n2. 函数名: vzalloc\n- 参数: [unsigned int countersize]\n- 调用者: alloc_counters\n- 被调用者: []\n\n3. 函数名: ERR_PTR\n- 参数: [-ENOMEM]\n- 调用者: alloc_counters\n- 被调用者: []\n\n4. 函数名: get_counters\n- 参数: [const struct xt_table_info *private, struct xt_counters *counters]\n- 调用者: alloc_counters\n- 被调用者: []"
    },
    {
        "id": 2778,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36694",
        "purpose": "Code purpose:\"\"\"该代码用于从用户空间获取iptables规则条目并复制到内核空间进行处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发替换iptables规则时，由于对每CPU序列计数的处理不当，导致数据包处理上下文中出现释放后重用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: get_entries\n- 参数: [struct net *net, struct ipt_get_entries __user *uptr, const int *len]\n- 调用者: 未指定\n- 被调用者: [copy_from_user, xt_find_table_lock, IS_ERR, copy_entries_to_user, module_put, xt_table_unlock, PTR_ERR]\n\n2. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: get_entries\n- 被调用者: 未指定\n\n3. 函数名: xt_find_table_lock\n- 参数: [struct net *net, int af, const char *name]\n- 调用者: get_entries\n- 被调用者: 未指定\n\n4. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: get_entries\n- 被调用者: 未指定\n\n5. 函数名: copy_entries_to_user\n- 参数: [unsigned int total_size, struct xt_table *table, void __user *userptr]\n- 调用者: get_entries\n- 被调用者: 未指定\n\n6. 函数名: module_put\n- 参数: [struct module *module]\n- 调用者: get_entries\n- 被调用者: 未指定\n\n7. 函数名: xt_table_unlock\n- 参数: [struct xt_table *t]\n- 调用者: get_entries\n- 被调用者: 未指定\n\n8. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: get_entries\n- 被调用者: 未指定"
    },
    {
        "id": 2779,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36694",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中netfilter框架的iptables规则匹配和处理功能，负责对网络数据包进行过滤和转发决策。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发替换iptables规则时，由于对每CPU序列计数的处理不当，导致数据包处理上下文中可能出现释放后重用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: ipt_do_table\n- 参数: [struct sk_buff *skb, const struct nf_hook_state *state, struct xt_table *table]\n- 调用者: 未显示\n- 被调用者: [ip_hdr, ntohs, xt_write_recseq_begin, READ_ONCE, smp_processor_id, get_entry, ip_packet_match, ipt_next_entry, xt_ematch_foreach, xt_get_this_cpu_counter, ADD_COUNTER, ipt_get_target_c, trace_packet, xt_write_recseq_end]\n\n2. 函数名: ip_hdr\n- 参数: [struct sk_buff *skb]\n- 调用者: ipt_do_table\n- 被调用者: 未显示\n\n3. 函数名: ntohs\n- 参数: [unsigned short]\n- 调用者: ipt_do_table\n- 被调用者: 未显示\n\n4. 函数名: xt_write_recseq_begin\n- 参数: []\n- 调用者: ipt_do_table\n- 被调用者: 未显示\n\n5. 函数名: READ_ONCE\n- 参数: [variable]\n- 调用者: ipt_do_table\n- 被调用者: 未显示\n\n6. 函数名: smp_processor_id\n- 参数: []\n- 调用者: ipt_do_table\n- 被调用者: 未显示\n\n7. 函数名: get_entry\n- 参数: [const void *table_base, unsigned int offset]\n- 调用者: ipt_do_table\n- 被调用者: 未显示\n\n8. 函数名: ip_packet_match\n- 参数: [const struct iphdr *ip, const char *indev, const char *outdev, const struct ipt_ip *ipinfo, unsigned int fragoff]\n- 调用者: ipt_do_table\n- 被调用者: 未显示\n\n9. 函数名: ipt_next_entry\n- 参数: [struct ipt_entry *entry]\n- 调用者: ipt_do_table\n- 被调用者: 未显示\n\n10. 函数名: xt_ematch_foreach\n- 参数: [ematch, e]\n- 调用者: ipt_do_table\n- 被调用者: 未显示\n\n11. 函数名: xt_get_this_cpu_counter\n- 参数: [struct xt_counters *counter]\n- 调用者: ipt_do_table\n- 被调用者: 未显示\n\n12. 函数名: ADD_COUNTER\n- 参数: [struct xt_counters counter, unsigned int len, unsigned int packets]\n- 调用者: ipt_do_table\n- 被调用者: 未显示\n\n13. 函数名: ipt_get_target_c\n- 参数: [struct ipt_entry *e]\n- 调用者: ipt_do_table\n- 被调用者: 未显示\n\n14. 函数名: trace_packet\n- 参数: [struct net *net, struct sk_buff *skb, unsigned int hook, struct net_device *in, struct net_device *out, const char *tablename, const struct xt_table_info *private, struct ipt_entry *e]\n- 调用者: ipt_do_table\n- 被调用者: 未显示\n\n15. 函数名: xt_write_recseq_end\n- 参数: [unsigned int addend]\n- 调用者: ipt_do_table\n- 被调用者: 未显示"
    },
    {
        "id": 2780,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36694",
        "purpose": "Code purpose:\"\"\"该代码用于从用户空间获取并验证网络过滤表(iptables)的信息，然后将相关信息复制回用户空间。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核在并发替换iptables规则时错误处理了每CPU序列计数，导致数据包处理上下文中出现释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: get_info\n- 参数: [struct net *net, void __user *user, const int *len]\n- 调用者: 未显示\n- 被调用者: [copy_from_user, xt_request_find_table_lock, IS_ERR, compat_table_info, xt_compat_flush_offsets, memset, memcpy, strcpy, copy_to_user, xt_table_unlock, module_put, PTR_ERR, xt_compat_lock, xt_compat_unlock]\n\n2. 函数名: copy_from_user\n- 参数: [name, user, sizeof(name)]\n- 调用者: get_info\n- 被调用者: 未显示\n\n3. 函数名: xt_request_find_table_lock\n- 参数: [net, AF_INET, name]\n- 调用者: get_info\n- 被调用者: 未显示\n\n4. 函数名: IS_ERR\n- 参数: [t]\n- 调用者: get_info\n- 被调用者: 未显示\n\n5. 函数名: compat_table_info\n- 参数: [private, &tmp]\n- 调用者: get_info\n- 被调用者: 未显示\n\n6. 函数名: xt_compat_flush_offsets\n- 参数: [AF_INET]\n- 调用者: get_info\n- 被调用者: 未显示\n\n7. 函数名: memset\n- 参数: [&info, 0, sizeof(info)]\n- 调用者: get_info\n- 被调用者: 未显示\n\n8. 函数名: memcpy\n- 参数: [info.hook_entry, private->hook_entry, sizeof(info.hook_entry)]\n- 调用者: get_info\n- 被调用者: 未显示\n\n9. 函数名: memcpy\n- 参数: [info.underflow, private->underflow, sizeof(info.underflow)]\n- 调用者: get_info\n- 被调用者: 未显示\n\n10. 函数名: strcpy\n- 参数: [info.name, name]\n- 调用者: get_info\n- 被调用者: 未显示\n\n11. 函数名: copy_to_user\n- 参数: [user, &info, *len]\n- 调用者: get_info\n- 被调用者: 未显示\n\n12. 函数名: xt_table_unlock\n- 参数: [t]\n- 调用者: get_info\n- 被调用者: 未显示\n\n13. 函数名: module_put\n- 参数: [t->me]\n- 调用者: get_info\n- 被调用者: 未显示\n\n14. 函数名: PTR_ERR\n- 参数: [t]\n- 调用者: get_info\n- 被调用者: 未显示\n\n15. 函数名: xt_compat_lock\n- 参数: [AF_INET]\n- 调用者: get_info\n- 被调用者: 未显示\n\n16. 函数名: xt_compat_unlock\n- 参数: [AF_INET]\n- 调用者: get_info\n- 被调用者: 未显示"
    },
    {
        "id": 2781,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36694",
        "purpose": "Code purpose:\"\"\"将iptables规则条目从内核空间复制到用户空间，同时处理兼容性问题\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发替换iptables规则时，由于对每CPU序列计数的处理不当，导致数据包处理上下文中出现释放后重用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: compat_copy_entries_to_user\n- 参数: [total_size, table, userptr]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [alloc_counters, PTR_ERR, compat_copy_entry_to_user, vfree, xt_entry_foreach]\n\n2. 函数名: alloc_counters\n- 参数: [table]\n- 调用者: compat_copy_entries_to_user\n- 被调用者: 未明确\n\n3. 函数名: PTR_ERR\n- 参数: [counters]\n- 调用者: compat_copy_entries_to_user\n- 被调用者: 未明确\n\n4. 函数名: compat_copy_entry_to_user\n- 参数: [iter, pos, size, counters, i]\n- 调用者: compat_copy_entries_to_user\n- 被调用者: 未明确\n\n5. 函数名: vfree\n- 参数: [counters]\n- 调用者: compat_copy_entries_to_user\n- 被调用者: 未明确\n\n6. 函数名: xt_entry_foreach\n- 参数: [iter, private->entries, total_size]\n- 调用者: compat_copy_entries_to_user\n- 被调用者: 未明确"
    },
    {
        "id": 2782,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36694",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核网络过滤模块中处理并发iptables规则替换时的计数器添加操作，但存在并发处理不当导致的使用后释放漏洞。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发替换iptables规则时，由于对每CPU序列计数的处理不当，导致数据包处理上下文中出现释放后重用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: do_add_counters\n- 参数: [struct net *net, sockptr_t arg, unsigned int len]\n- 调用者: 未显示\n- 被调用者: [xt_copy_counters, xt_find_table_lock, local_bh_disable, xt_write_recseq_begin, xt_entry_foreach, xt_get_this_cpu_counter, ADD_COUNTER, xt_write_recseq_end, local_bh_enable, xt_table_unlock, module_put, vfree]\n\n2. 函数名: xt_copy_counters\n- 参数: [sockptr_t arg, unsigned int len, struct xt_counters_info *tmp]\n- 调用者: do_add_counters\n- 被调用者: 未显示\n\n3. 函数名: xt_find_table_lock\n- 参数: [struct net *net, AF_INET, tmp.name]\n- 调用者: do_add_counters\n- 被调用者: 未显示\n\n4. 函数名: local_bh_disable\n- 参数: []\n- 调用者: do_add_counters\n- 被调用者: 未显示\n\n5. 函数名: xt_write_recseq_begin\n- 参数: []\n- 调用者: do_add_counters\n- 被调用者: 未显示\n\n6. 函数名: xt_entry_foreach\n- 参数: [iter, private->entries, private->size]\n- 调用者: do_add_counters\n- 被调用者: 未显示\n\n7. 函数名: xt_get_this_cpu_counter\n- 参数: [&iter->counters]\n- 调用者: do_add_counters\n- 被调用者: 未显示\n\n8. 函数名: ADD_COUNTER\n- 参数: [*tmp, paddc[i].bcnt, paddc[i].pcnt]\n- 调用者: do_add_counters\n- 被调用者: 未显示\n\n9. 函数名: xt_write_recseq_end\n- 参数: [addend]\n- 调用者: do_add_counters\n- 被调用者: 未显示\n\n10. 函数名: local_bh_enable\n- 参数: []\n- 调用者: do_add_counters\n- 被调用者: 未显示\n\n11. 函数名: xt_table_unlock\n- 参数: [t]\n- 调用者: do_add_counters\n- 被调用者: 未显示\n\n12. 函数名: module_put\n- 参数: [t->me]\n- 调用者: do_add_counters\n- 被调用者: 未显示\n\n13. 函数名: vfree\n- 参数: [paddc]\n- 调用者: do_add_counters\n- 被调用者: 未显示"
    },
    {
        "id": 2783,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36694",
        "purpose": "Code purpose:\"\"\"将内核中的iptables规则条目及其计数器复制到用户空间\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发替换iptables规则时，由于对每CPU序列计数的处理不当，导致数据包处理上下文中出现释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: copy_entries_to_user\n- 参数: [total_size, table, userptr]\n- 调用者: 未明确显示（由外部调用）\n- 被调用者: [alloc_counters, copy_to_user, xt_match_to_user, ipt_get_target_c, xt_target_to_user, vfree]\n\n2. 函数名: alloc_counters\n- 参数: [table]\n- 调用者: copy_entries_to_user\n- 被调用者: 未明确显示\n\n3. 函数名: copy_to_user\n- 参数: [userptr + off, e, sizeof(*e)] 和 [userptr + off + offsetof(struct ipt_entry, counters), &counters[num], sizeof(counters[num])]\n- 调用者: copy_entries_to_user\n- 被调用者: 未明确显示\n\n4. 函数名: xt_match_to_user\n- 参数: [m, userptr + off + i]\n- 调用者: copy_entries_to_user\n- 被调用者: 未明确显示\n\n5. 函数名: ipt_get_target_c\n- 参数: [e]\n- 调用者: copy_entries_to_user\n- 被调用者: 未明确显示\n\n6. 函数名: xt_target_to_user\n- 参数: [t, userptr + off + e->target_offset]\n- 调用者: copy_entries_to_user\n- 被调用者: 未明确显示\n\n7. 函数名: vfree\n- 参数: [counters]\n- 调用者: copy_entries_to_user\n- 被调用者: 未明确显示"
    },
    {
        "id": 2784,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36694",
        "purpose": "Code purpose:\"\"\"该代码用于从用户空间获取网络表信息并返回给用户，涉及并发情况下的表查找和锁定操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发替换iptables规则时，由于对每CPU序列计数的处理不当，导致数据包处理上下文中出现释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: get_info\n- 参数: [struct net *net, void __user *user, const int *len]\n- 调用者: N/A\n- 被调用者: [copy_from_user, xt_request_find_table_lock, IS_ERR, compat_table_info, xt_compat_flush_offsets, memset, memcpy, strcpy, copy_to_user, xt_table_unlock, module_put, PTR_ERR, xt_compat_lock, xt_compat_unlock]\n\n2. 函数名: copy_from_user\n- 参数: [name, user, sizeof(name)]\n- 调用者: get_info\n- 被调用者: N/A\n\n3. 函数名: xt_request_find_table_lock\n- 参数: [net, AF_INET6, name]\n- 调用者: get_info\n- 被调用者: N/A\n\n4. 函数名: IS_ERR\n- 参数: [t]\n- 调用者: get_info\n- 被调用者: N/A\n\n5. 函数名: compat_table_info\n- 参数: [private, &tmp]\n- 调用者: get_info\n- 被调用者: N/A\n\n6. 函数名: xt_compat_flush_offsets\n- 参数: [AF_INET6]\n- 调用者: get_info\n- 被调用者: N/A\n\n7. 函数名: memset\n- 参数: [&info, 0, sizeof(info)]\n- 调用者: get_info\n- 被调用者: N/A\n\n8. 函数名: memcpy\n- 参数: [info.hook_entry, private->hook_entry, sizeof(info.hook_entry)]\n- 调用者: get_info\n- 被调用者: N/A\n\n9. 函数名: memcpy\n- 参数: [info.underflow, private->underflow, sizeof(info.underflow)]\n- 调用者: get_info\n- 被调用者: N/A\n\n10. 函数名: strcpy\n- 参数: [info.name, name]\n- 调用者: get_info\n- 被调用者: N/A\n\n11. 函数名: copy_to_user\n- 参数: [user, &info, *len]\n- 调用者: get_info\n- 被调用者: N/A\n\n12. 函数名: xt_table_unlock\n- 参数: [t]\n- 调用者: get_info\n- 被调用者: N/A\n\n13. 函数名: module_put\n- 参数: [t->me]\n- 调用者: get_info\n- 被调用者: N/A\n\n14. 函数名: PTR_ERR\n- 参数: [t]\n- 调用者: get_info\n- 被调用者: N/A\n\n15. 函数名: xt_compat_lock\n- 参数: [AF_INET6]\n- 调用者: get_info\n- 被调用者: N/A\n\n16. 函数名: xt_compat_unlock\n- 参数: [AF_INET6]\n- 调用者: get_info\n- 被调用者: N/A"
    },
    {
        "id": 2785,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36694",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中IPv6数据包通过netfilter框架进行规则匹配和过滤的功能，包括处理跳转栈、匹配规则、执行目标动作等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发替换iptables规则时，由于对每CPU序列计数的处理不当，导致数据包处理上下文中出现释放后使用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: ip6t_do_table\n- 参数: [struct sk_buff *skb, const struct nf_hook_state *state, struct xt_table *table]\n- 调用者: 未显示\n- 被调用者: [local_bh_disable, xt_write_recseq_begin, READ_ONCE, smp_processor_id, get_entry, ip6_packet_match, ip6t_next_entry, xt_ematch_foreach, xt_get_this_cpu_counter, ADD_COUNTER, ip6t_get_target_c, trace_packet, xt_write_recseq_end, local_bh_enable]\n\n2. 函数名: ip6_packet_match\n- 参数: [struct sk_buff *skb, const char *indev, const char *outdev, struct ip6t_ip6 *ip6, unsigned int *thoff, unsigned int *fragoff, bool *hotdrop]\n- 调用者: ip6t_do_table\n- 被调用者: 未显示\n\n3. 函数名: ip6t_next_entry\n- 参数: [struct ip6t_entry *e]\n- 调用者: ip6t_do_table\n- 被调用者: 未显示\n\n4. 函数名: xt_ematch_foreach\n- 参数: [struct xt_entry_match *ematch, struct ip6t_entry *e]\n- 调用者: ip6t_do_table\n- 被调用者: 未显示\n\n5. 函数名: xt_get_this_cpu_counter\n- 参数: [struct xt_counters *counter]\n- 调用者: ip6t_do_table\n- 被调用者: 未显示\n\n6. 函数名: ADD_COUNTER\n- 参数: [struct xt_counters *counter, unsigned int len, unsigned int packets]\n- 调用者: ip6t_do_table\n- 被调用者: 未显示\n\n7. 函数名: ip6t_get_target_c\n- 参数: [struct ip6t_entry *e]\n- 调用者: ip6t_do_table\n- 被调用者: 未显示\n\n8. 函数名: trace_packet\n- 参数: [struct net *net, struct sk_buff *skb, unsigned int hook, struct net_device *in, struct net_device *out, const char *tablename, const struct xt_table_info *private, struct ip6t_entry *e]\n- 调用者: ip6t_do_table\n- 被调用者: 未显示\n\n9. 函数名: local_bh_disable\n- 参数: []\n- 调用者: ip6t_do_table\n- 被调用者: 未显示\n\n10. 函数名: xt_write_recseq_begin\n- 参数: []\n- 调用者: ip6t_do_table\n- 被调用者: 未显示\n\n11. 函数名: READ_ONCE\n- 参数: [struct xt_table_info *private]\n- 调用者: ip6t_do_table\n- 被调用者: 未显示\n\n12. 函数名: smp_processor_id\n- 参数: []\n- 调用者: ip6t_do_table\n- 被调用者: 未显示\n\n13. 函数名: get_entry\n- 参数: [const void *table_base, unsigned int hook_entry]\n- 调用者: ip6t_do_table\n- 被调用者: 未显示\n\n14. 函数名: xt_write_recseq_end\n- 参数: [unsigned int addend]\n- 调用者: ip6t_do_table\n- 被调用者: 未显示\n\n15. 函数名: local_bh_enable\n- 参数: []\n- 调用者: ip6t_do_table\n- 被调用者: 未显示"
    },
    {
        "id": 2786,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36694",
        "purpose": "Code purpose:\"\"\"该代码用于从用户空间获取IPv6防火墙规则条目并在内核中进行处理，然后将匹配的条目复制回用户空间。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发替换iptables规则时，由于对每CPU序列计数的处理不当，导致数据包处理上下文中出现释放后重用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: get_entries\n- 参数: [struct net *net, struct ip6t_get_entries __user *uptr, const int *len]\n- 调用者: 未显示\n- 被调用者: [copy_from_user, xt_find_table_lock, IS_ERR, module_put, xt_table_unlock, PTR_ERR, copy_entries_to_user]\n\n2. 函数名: copy_from_user\n- 参数: [&get, uptr, sizeof(get)]\n- 调用者: get_entries\n- 被调用者: 未显示\n\n3. 函数名: xt_find_table_lock\n- 参数: [net, AF_INET6, get.name]\n- 调用者: get_entries\n- 被调用者: 未显示\n\n4. 函数名: IS_ERR\n- 参数: [t]\n- 调用者: get_entries\n- 被调用者: 未显示\n\n5. 函数名: module_put\n- 参数: [t->me]\n- 调用者: get_entries\n- 被调用者: 未显示\n\n6. 函数名: xt_table_unlock\n- 参数: [t]\n- 调用者: get_entries\n- 被调用者: 未显示\n\n7. 函数名: PTR_ERR\n- 参数: [t]\n- 调用者: get_entries\n- 被调用者: 未显示\n\n8. 函数名: copy_entries_to_user\n- 参数: [private->size, t, uptr->entrytable]\n- 调用者: get_entries\n- 被调用者: 未显示"
    },
    {
        "id": 2787,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36694",
        "purpose": "Code purpose:\"\"\"将内核中的iptables规则条目以兼容格式复制到用户空间\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发替换iptables规则时，由于对每CPU序列计数的处理不当，导致数据包处理上下文中出现释放后重用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: compat_copy_entries_to_user\n- 参数: [total_size, table, userptr]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [alloc_counters, PTR_ERR, compat_copy_entry_to_user, vfree]\n\n2. 函数名: alloc_counters\n- 参数: [table]\n- 调用者: compat_copy_entries_to_user\n- 被调用者: 未明确\n\n3. 函数名: PTR_ERR\n- 参数: [counters]\n- 调用者: compat_copy_entries_to_user\n- 被调用者: 未明确\n\n4. 函数名: compat_copy_entry_to_user\n- 参数: [iter, pos, size, counters, i]\n- 调用者: compat_copy_entries_to_user\n- 被调用者: 未明确\n\n5. 函数名: vfree\n- 参数: [counters]\n- 调用者: compat_copy_entries_to_user\n- 被调用者: 未明确"
    },
    {
        "id": 2788,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36694",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核网络过滤模块中处理并发iptables规则替换时的计数器添加操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发替换iptables规则时，由于对每CPU序列计数的处理不当，导致数据包处理上下文中出现释放后使用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: do_add_counters\n- 参数: [struct net *net, sockptr_t arg, unsigned int len]\n- 调用者: 未指定\n- 被调用者: [xt_copy_counters, xt_find_table_lock, PTR_ERR, local_bh_disable, xt_write_recseq_begin, xt_entry_foreach, xt_get_this_cpu_counter, ADD_COUNTER, xt_write_recseq_end, local_bh_enable, xt_table_unlock, module_put, vfree]\n\n2. 函数名: xt_copy_counters\n- 参数: [sockptr_t arg, unsigned int len, struct xt_counters_info *tmp]\n- 调用者: do_add_counters\n- 被调用者: 未指定\n\n3. 函数名: xt_find_table_lock\n- 参数: [struct net *net, AF_INET6, tmp.name]\n- 调用者: do_add_counters\n- 被调用者: 未指定\n\n4. 函数名: PTR_ERR\n- 参数: [paddc/t]\n- 调用者: do_add_counters\n- 被调用者: 未指定\n\n5. 函数名: local_bh_disable\n- 参数: []\n- 调用者: do_add_counters\n- 被调用者: 未指定\n\n6. 函数名: xt_write_recseq_begin\n- 参数: []\n- 调用者: do_add_counters\n- 被调用者: 未指定\n\n7. 函数名: xt_entry_foreach\n- 参数: [iter, private->entries, private->size]\n- 调用者: do_add_counters\n- 被调用者: 未指定\n\n8. 函数名: xt_get_this_cpu_counter\n- 参数: [&iter->counters]\n- 调用者: do_add_counters\n- 被调用者: 未指定\n\n9. 函数名: ADD_COUNTER\n- 参数: [*tmp, paddc[i].bcnt, paddc[i].pcnt]\n- 调用者: do_add_counters\n- 被调用者: 未指定\n\n10. 函数名: xt_write_recseq_end\n- 参数: [addend]\n- 调用者: do_add_counters\n- 被调用者: 未指定\n\n11. 函数名: local_bh_enable\n- 参数: []\n- 调用者: do_add_counters\n- 被调用者: 未指定\n\n12. 函数名: xt_table_unlock\n- 参数: [t]\n- 调用者: do_add_counters\n- 被调用者: 未指定\n\n13. 函数名: module_put\n- 参数: [t->me]\n- 调用者: do_add_counters\n- 被调用者: 未指定\n\n14. 函数名: vfree\n- 参数: [paddc]\n- 调用者: do_add_counters\n- 被调用者: 未指定"
    },
    {
        "id": 2789,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36694",
        "purpose": "Code purpose:\"\"\"将内核中的iptables规则条目及其计数器复制到用户空间\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发替换iptables规则时，由于对每CPU序列计数的处理不当，导致数据包处理上下文中出现释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: copy_entries_to_user\n- 参数: [total_size, table, userptr]\n- 调用者: 未显示\n- 被调用者: [alloc_counters, PTR_ERR, copy_to_user, xt_match_to_user, ip6t_get_target_c, xt_target_to_user, vfree]\n\n2. 函数名: alloc_counters\n- 参数: [table]\n- 调用者: copy_entries_to_user\n- 被调用者: 未显示\n\n3. 函数名: PTR_ERR\n- 参数: [counters]\n- 调用者: copy_entries_to_user\n- 被调用者: 未显示\n\n4. 函数名: copy_to_user\n- 参数: [userptr + off, e, sizeof(*e)] 和 [userptr + off + offsetof(struct ip6t_entry, counters), &counters[num], sizeof(counters[num])]\n- 调用者: copy_entries_to_user\n- 被调用者: 未显示\n\n5. 函数名: xt_match_to_user\n- 参数: [m, userptr + off + i]\n- 调用者: copy_entries_to_user\n- 被调用者: 未显示\n\n6. 函数名: ip6t_get_target_c\n- 参数: [e]\n- 调用者: copy_entries_to_user\n- 被调用者: 未显示\n\n7. 函数名: xt_target_to_user\n- 参数: [t, userptr + off + e->target_offset]\n- 调用者: copy_entries_to_user\n- 被调用者: 未显示\n\n8. 函数名: vfree\n- 参数: [counters]\n- 调用者: copy_entries_to_user\n- 被调用者: 未显示"
    },
    {
        "id": 2790,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36694",
        "purpose": "Code purpose:\"\"\"注册并管理netfilter中的xt_table规则表，处理并发规则替换时的同步问题\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发替换iptables规则时，由于对每CPU序列计数的处理不当，导致在数据包处理上下文中出现释放后重用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: xt_register_table\n- 参数: [net, input_table, bootstrap, newinfo]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [kmemdup, mutex_lock, list_for_each_entry, strcmp, xt_replace_table, pr_debug, list_add, mutex_unlock, kfree, ERR_PTR]\n\n2. 函数名: kmemdup\n- 参数: [input_table, sizeof(struct xt_table), GFP_KERNEL]\n- 调用者: xt_register_table\n- 被调用者: 未明确（内核函数）\n\n3. 函数名: mutex_lock\n- 参数: [&xt[table->af].mutex]\n- 调用者: xt_register_table\n- 被调用者: 未明确（内核同步原语）\n\n4. 函数名: list_for_each_entry\n- 参数: [t, &net->xt.tables[table->af], list]\n- 调用者: xt_register_table\n- 被调用者: 未明确（内核链表宏）\n\n5. 函数名: strcmp\n- 参数: [t->name, table->name]\n- 调用者: xt_register_table\n- 被调用者: 未明确（标准库函数）\n\n6. 函数名: xt_replace_table\n- 参数: [table, 0, newinfo, &ret]\n- 调用者: xt_register_table\n- 被调用者: 未明确（内核函数）\n\n7. 函数名: pr_debug\n- 参数: [\"table->private->number = %u\\n\", private->number]\n- 调用者: xt_register_table\n- 被调用者: 未明确（内核打印函数）\n\n8. 函数名: list_add\n- 参数: [&table->list, &net->xt.tables[table->af]]\n- 调用者: xt_register_table\n- 被调用者: 未明确（内核链表操作）\n\n9. 函数名: mutex_unlock\n- 参数: [&xt[table->af].mutex]\n- 调用者: xt_register_table\n- 被调用者: 未明确（内核同步原语）\n\n10. 函数名: kfree\n- 参数: [table]\n- 调用者: xt_register_table\n- 被调用者: 未明确（内核内存释放）\n\n11. 函数名: ERR_PTR\n- 参数: [ret]\n- 调用者: xt_register_table\n- 被调用者: 未明确（内核错误处理宏）"
    },
    {
        "id": 2791,
        "cwe": "CWE-416",
        "cve": "CVE-2020-36694",
        "purpose": "Code purpose:\"\"\"该代码用于注销一个netfilter表并释放相关资源，返回表的私有信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发替换iptables规则时，由于未正确处理每CPU序列计数，导致释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: xt_unregister_table\n- 参数: [struct xt_table *table]\n- 调用者: 未提供\n- 被调用者: [mutex_lock, list_del, mutex_unlock, audit_log_nfcfg, kfree]\n\n2. 函数名: mutex_lock\n- 参数: [&xt[table->af].mutex]\n- 调用者: xt_unregister_table\n- 被调用者: 未提供\n\n3. 函数名: list_del\n- 参数: [&table->list]\n- 调用者: xt_unregister_table\n- 被调用者: 未提供\n\n4. 函数名: mutex_unlock\n- 参数: [&xt[table->af].mutex]\n- 调用者: xt_unregister_table\n- 被调用者: 未提供\n\n5. 函数名: audit_log_nfcfg\n- 参数: [table->name, table->af, private->number, AUDIT_XT_OP_UNREGISTER, GFP_KERNEL]\n- 调用者: xt_unregister_table\n- 被调用者: 未提供\n\n6. 函数名: kfree\n- 参数: [table]\n- 调用者: xt_unregister_table\n- 被调用者: 未提供"
    },
    {
        "id": 2798,
        "cwe": "CWE-416",
        "cve": "CVE-2020-7053",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中i915显卡驱动对gem上下文销毁的IOCTL操作处理功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放上下文资源后未正确处理互斥锁，导致后续操作可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: i915_gem_context_destroy_ioctl\n- 参数: [struct drm_device *dev, void *data, struct drm_file *file]\n- 调用者: 无（系统调用接口）\n- 被调用者: [i915_gem_context_lookup, mutex_lock_interruptible, idr_remove, context_close, mutex_unlock, i915_gem_context_put]\n\n2. 函数名: i915_gem_context_lookup\n- 参数: [struct drm_i915_file_private *file_priv, args->ctx_id]\n- 调用者: i915_gem_context_destroy_ioctl\n- 被调用者: 无\n\n3. 函数名: mutex_lock_interruptible\n- 参数: [&dev->struct_mutex]\n- 调用者: i915_gem_context_destroy_ioctl\n- 被调用者: 无\n\n4. 函数名: idr_remove\n- 参数: [&file_priv->context_idr, ctx->user_handle]\n- 调用者: i915_gem_context_destroy_ioctl\n- 被调用者: 无\n\n5. 函数名: context_close\n- 参数: [ctx]\n- 调用者: i915_gem_context_destroy_ioctl\n- 被调用者: 无\n\n6. 函数名: mutex_unlock\n- 参数: [&dev->struct_mutex]\n- 调用者: i915_gem_context_destroy_ioctl\n- 被调用者: 无\n\n7. 函数名: i915_gem_context_put\n- 参数: [ctx]\n- 调用者: i915_gem_context_destroy_ioctl\n- 被调用者: 无"
    },
    {
        "id": 2799,
        "cwe": "CWE-416",
        "cve": "CVE-2020-7053",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中注册一个gem上下文，并将其与用户空间的文件私有数据关联，同时分配唯一标识符以便用户空间访问。\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放上下文资源时未正确处理ppgtt指针，导致后续可能发生对已释放内存的写入操作\"\"\"",
        "functions": "Functions:\n1. 函数名: gem_context_register\n- 参数: [struct i915_gem_context *ctx, struct drm_i915_file_private *fpriv]\n- 调用者: 未明确（应为i915_gem_context_create_ioctl等上下文创建函数）\n- 被调用者: [get_task_pid, kasprintf, pid_nr, idr_alloc, kfree, fetch_and_zero, put_pid]\n\n2. 函数名: get_task_pid\n- 参数: [current, PIDTYPE_PID]\n- 调用者: gem_context_register\n- 被调用者: []\n\n3. 函数名: kasprintf\n- 参数: [GFP_KERNEL, \"%s[%d]\", current->comm, pid_nr(ctx->pid)]\n- 调用者: gem_context_register\n- 被调用者: []\n\n4. 函数名: pid_nr\n- 参数: [ctx->pid]\n- 调用者: gem_context_register\n- 被调用者: []\n\n5. 函数名: idr_alloc\n- 参数: [&fpriv->context_idr, ctx, DEFAULT_CONTEXT_HANDLE, 0, GFP_KERNEL]\n- 调用者: gem_context_register\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [fetch_and_zero(&ctx->name)]\n- 调用者: gem_context_register\n- 被调用者: []\n\n7. 函数名: fetch_and_zero\n- 参数: [&ctx->name]\n- 调用者: gem_context_register\n- 被调用者: []\n\n8. 函数名: put_pid\n- 参数: [fetch_and_zero(&ctx->pid)]\n- 调用者: gem_context_register\n- 被调用者: []\n\n9. 函数名: fetch_and_zero\n- 参数: [&ctx->pid]\n- 调用者: gem_context_register\n- 被调用者: []"
    },
    {
        "id": 2800,
        "cwe": "CWE-416",
        "cve": "CVE-2020-7053",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中i915显卡驱动创建GPU上下文的功能，包括权限检查、资源分配和上下文注册等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在i915_gem_context_create_ioctl函数中，当gem_context_register失败时直接调用context_close释放上下文，但未正确处理互斥锁保护下的资源释放，导致后续可能发生对已释放内存的写操作\"\"\"",
        "functions": "Functions:\n1. 函数名: i915_gem_context_create_ioctl\n- 参数: [struct drm_device *dev, void *data, struct drm_file *file]\n- 调用者: 未显示（通常由DRM子系统调用）\n- 被调用者: [to_i915, DRIVER_CAPS, i915_terminally_wedged, client_is_banned, i915_mutex_lock_interruptible, i915_gem_create_context, gem_context_register, mutex_unlock, context_close]\n\n2. 函数名: to_i915\n- 参数: [struct drm_device *dev]\n- 调用者: i915_gem_context_create_ioctl\n- 被调用者: []\n\n3. 函数名: DRIVER_CAPS\n- 参数: [struct drm_i915_private *i915]\n- 调用者: i915_gem_context_create_ioctl\n- 被调用者: []\n\n4. 函数名: i915_terminally_wedged\n- 参数: [struct drm_i915_private *i915]\n- 调用者: i915_gem_context_create_ioctl\n- 被调用者: []\n\n5. 函数名: client_is_banned\n- 参数: [struct drm_i915_file_private *file_priv]\n- 调用者: i915_gem_context_create_ioctl\n- 被调用者: []\n\n6. 函数名: i915_mutex_lock_interruptible\n- 参数: [struct drm_device *dev]\n- 调用者: i915_gem_context_create_ioctl\n- 被调用者: []\n\n7. 函数名: i915_gem_create_context\n- 参数: [struct drm_i915_private *i915]\n- 调用者: i915_gem_context_create_ioctl\n- 被调用者: []\n\n8. 函数名: gem_context_register\n- 参数: [struct i915_gem_context *ctx, struct drm_i915_file_private *file_priv]\n- 调用者: i915_gem_context_create_ioctl\n- 被调用者: []\n\n9. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: i915_gem_context_create_ioctl\n- 被调用者: []\n\n10. 函数名: context_close\n- 参数: [struct i915_gem_context *ctx]\n- 调用者: i915_gem_context_create_ioctl\n- 被调用者: []"
    },
    {
        "id": 2801,
        "cwe": "CWE-416",
        "cve": "CVE-2020-7053",
        "purpose": "Code purpose:\"\"\"清理并销毁与DRM文件关联的GPU上下文资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在i915_gem_context_close函数中，由于未正确处理上下文资源的释放顺序，导致在释放资源后仍可能被访问，从而引发释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: i915_gem_context_close\n- 参数: [struct drm_file *file]\n- 调用者: 未明确显示（可能是外部调用）\n- 被调用者: [lockdep_assert_held, idr_for_each, idr_destroy]\n\n2. 函数名: lockdep_assert_held\n- 参数: [&file_priv->dev_priv->drm.struct_mutex]\n- 调用者: i915_gem_context_close\n- 被调用者: []\n\n3. 函数名: idr_for_each\n- 参数: [&file_priv->context_idr, context_idr_cleanup, NULL]\n- 调用者: i915_gem_context_close\n- 被调用者: [context_idr_cleanup]\n\n4. 函数名: idr_destroy\n- 参数: [&file_priv->context_idr]\n- 调用者: i915_gem_context_close\n- 被调用者: []\n\n5. 函数名: context_idr_cleanup\n- 参数: [未明确显示，但作为回调函数被idr_for_each调用]\n- 调用者: idr_for_each\n- 被调用者: []"
    },
    {
        "id": 2802,
        "cwe": "CWE-416",
        "cve": "CVE-2020-7053",
        "purpose": "Code purpose:\"\"\"清理并关闭指定的i915_gem_context结构体\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在i915_gem_context_destroy_ioctl操作中，由于未正确处理上下文对象的引用计数，导致在context_close函数调用后可能发生对已释放内存的写入操作，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: context_idr_cleanup\n- 参数: [id, p, data]\n- 调用者: 未明确（由IDR清理机制调用）\n- 被调用者: [context_close]\n\n2. 函数名: context_close\n- 参数: [ctx]\n- 调用者: context_idr_cleanup\n- 被调用者: 未明确（根据漏洞描述可能涉及i915_ppgtt_close）"
    },
    {
        "id": 2803,
        "cwe": "CWE-416",
        "cve": "CVE-2020-7053",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中创建并注册一个新的i915图形内存管理上下文，处理相关的错误情况并释放资源。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在i915_gem_context_open函数中，当错误处理路径跳转到err_ctx标签时，未正确清理上下文资源，导致后续可能发生对已释放内存的写入操作，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: i915_gem_context_open\n- 参数: [struct drm_i915_private *i915, struct drm_file *file]\n- 调用者: N/A\n- 被调用者: [idr_init, mutex_lock, i915_gem_create_context, gem_context_register, mutex_unlock, context_close, idr_destroy, PTR_ERR]\n\n2. 函数名: idr_init\n- 参数: [&file_priv->context_idr]\n- 调用者: i915_gem_context_open\n- 被调用者: N/A\n\n3. 函数名: mutex_lock\n- 参数: [&i915->drm.struct_mutex]\n- 调用者: i915_gem_context_open\n- 被调用者: N/A\n\n4. 函数名: i915_gem_create_context\n- 参数: [i915]\n- 调用者: i915_gem_context_open\n- 被调用者: N/A\n\n5. 函数名: gem_context_register\n- 参数: [ctx, file_priv]\n- 调用者: i915_gem_context_open\n- 被调用者: N/A\n\n6. 函数名: mutex_unlock\n- 参数: [&i915->drm.struct_mutex]\n- 调用者: i915_gem_context_open\n- 被调用者: N/A\n\n7. 函数名: context_close\n- 参数: [ctx]\n- 调用者: i915_gem_context_open\n- 被调用者: N/A\n\n8. 函数名: idr_destroy\n- 参数: [&file_priv->context_idr]\n- 调用者: i915_gem_context_open\n- 被调用者: N/A\n\n9. 函数名: PTR_ERR\n- 参数: [ctx]\n- 调用者: i915_gem_context_open\n- 被调用者: N/A"
    },
    {
        "id": 2804,
        "cwe": "CWE-416",
        "cve": "CVE-2020-8428",
        "purpose": "Code purpose:\"\"\"处理文件路径查找和打开操作，包括处理特殊文件、权限检查以及处理可能的截断操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核的do_last函数中，当处理文件创建操作时，may_create_in_sticky函数可能在被释放的父目录inode上执行检查，导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: do_last\n- 参数: [nd, file, op]\n- 调用者: N/A (top-level function)\n- 被调用者: [handle_dots, lookup_fast, complete_walk, audit_inode, mnt_want_write, inode_lock, inode_lock_shared, lookup_open, inode_unlock, inode_unlock_shared, follow_managed, step_into, may_create_in_sticky, may_open, vfs_open, ima_file_check, handle_truncate, mnt_drop_write]\n\n2. 函数名: handle_dots\n- 参数: [nd, last_type]\n- 调用者: do_last\n- 被调用者: []\n\n3. 函数名: lookup_fast\n- 参数: [nd, path, inode, seq]\n- 调用者: do_last\n- 被调用者: []\n\n4. 函数名: complete_walk\n- 参数: [nd]\n- 调用者: do_last\n- 被调用者: []\n\n5. 函数名: audit_inode\n- 参数: [name, dentry, flags]\n- 调用者: do_last\n- 被调用者: []\n\n6. 函数名: mnt_want_write\n- 参数: [mnt]\n- 调用者: do_last\n- 被调用者: []\n\n7. 函数名: inode_lock\n- 参数: [inode]\n- 调用者: do_last\n- 被调用者: []\n\n8. 函数名: inode_lock_shared\n- 参数: [inode]\n- 调用者: do_last\n- 被调用者: []\n\n9. 函数名: lookup_open\n- 参数: [nd, path, file, op, got_write]\n- 调用者: do_last\n- 被调用者: []\n\n10. 函数名: inode_unlock\n- 参数: [inode]\n- 调用者: do_last\n- 被调用者: []\n\n11. 函数名: inode_unlock_shared\n- 参数: [inode]\n- 调用者: do_last\n- 被调用者: []\n\n12. 函数名: follow_managed\n- 参数: [path, nd]\n- 调用者: do_last\n- 被调用者: []\n\n13. 函数名: step_into\n- 参数: [nd, path, flags, inode, seq]\n- 调用者: do_last\n- 被调用者: []\n\n14. 函数名: may_create_in_sticky\n- 参数: [dir, inode]\n- 调用者: do_last\n- 被调用者: []\n\n15. 函数名: may_open\n- 参数: [path, acc_mode, open_flag]\n- 调用者: do_last\n- 被调用者: []\n\n16. 函数名: vfs_open\n- 参数: [path, file]\n- 调用者: do_last\n- 被调用者: []\n\n17. 函数名: ima_file_check\n- 参数: [file, acc_mode]\n- 调用者: do_last\n- 被调用者: []\n\n18. 函数名: handle_truncate\n- 参数: [file]\n- 调用者: do_last\n- 被调用者: []\n\n19. 函数名: mnt_drop_write\n- 参数: [mnt]\n- 调用者: do_last\n- 被调用者: []"
    },
    {
        "id": 2805,
        "cwe": "CWE-416",
        "cve": "CVE-2020-8648",
        "purpose": "Code purpose:\"\"\"处理终端选择操作，包括字符、单词、行的选择，并将选择内容存储到缓冲区中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放sel_buffer指针后仍可能被后续代码使用，导致释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: set_selection_kernel\n- 参数: [struct tiocl_selection *v, struct tty_struct *tty]\n- 调用者: N/A\n- 被调用者: [min_t, poke_blanked_console, clear_selection, mouse_reporting, mouse_report, swap, vt_do_kdgkbmode, isspace, sel_pos, inword, highlight_pointer, atedge, highlight, kmalloc_array, printk, kfree, store_utf8]\n\n2. 函数名: min_t\n- 参数: [type, a, b]\n- 调用者: set_selection_kernel\n- 被调用者: N/A\n\n3. 函数名: poke_blanked_console\n- 参数: []\n- 调用者: set_selection_kernel\n- 被调用者: N/A\n\n4. 函数名: clear_selection\n- 参数: []\n- 调用者: set_selection_kernel\n- 被调用者: N/A\n\n5. 函数名: mouse_reporting\n- 参数: []\n- 调用者: set_selection_kernel\n- 被调用者: N/A\n\n6. 函数名: mouse_report\n- 参数: [struct tty_struct *tty, int button, int x, int y]\n- 调用者: set_selection_kernel\n- 被调用者: N/A\n\n7. 函数名: swap\n- 参数: [a, b]\n- 调用者: set_selection_kernel\n- 被调用者: N/A\n\n8. 函数名: vt_do_kdgkbmode\n- 参数: [int console]\n- 调用者: set_selection_kernel\n- 被调用者: N/A\n\n9. 函数名: isspace\n- 参数: [int c]\n- 调用者: set_selection_kernel\n- 被调用者: N/A\n\n10. 函数名: sel_pos\n- 参数: [int i]\n- 调用者: set_selection_kernel\n- 被调用者: N/A\n\n11. 函数名: inword\n- 参数: [u32 c]\n- 调用者: set_selection_kernel\n- 被调用者: N/A\n\n12. 函数名: highlight_pointer\n- 参数: [int pos]\n- 调用者: set_selection_kernel\n- 被调用者: N/A\n\n13. 函数名: atedge\n- 参数: [int pos, int size_row]\n- 调用者: set_selection_kernel\n- 被调用者: N/A\n\n14. 函数名: highlight\n- 参数: [int start, int end]\n- 调用者: set_selection_kernel\n- 被调用者: N/A\n\n15. 函数名: kmalloc_array\n- 参数: [size_t n, size_t size, gfp_t flags]\n- 调用者: set_selection_kernel\n- 被调用者: N/A\n\n16. 函数名: printk\n- 参数: [const char *fmt, ...]\n- 调用者: set_selection_kernel\n- 被调用者: N/A\n\n17. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: set_selection_kernel\n- 被调用者: N/A\n\n18. 函数名: store_utf8\n- 参数: [u32 c, char *p]\n- 调用者: set_selection_kernel\n- 被调用者: N/A"
    },
    {
        "id": 2806,
        "cwe": "CWE-416",
        "cve": "CVE-2020-8648",
        "purpose": "Code purpose:\"\"\"该代码片段实现了Linux内核中从选择缓冲区粘贴内容到终端的功能，包括处理粘贴过程中的流控和信号中断。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在n_tty_receive_buf_common函数中存在释放后使用漏洞，当处理粘贴缓冲区数据时可能导致对已释放内存的访问\"\"\"",
        "functions": "Functions:\n1. 函数名: paste_selection\n- 参数: [struct tty_struct *tty]\n- 调用者: N/A\n- 被调用者: [console_lock, poke_blanked_console, console_unlock, tty_ldisc_ref_wait, tty_buffer_lock_exclusive, add_wait_queue, set_current_state, signal_pending, tty_throttled, schedule, __set_current_state, tty_ldisc_receive_buf, remove_wait_queue, tty_buffer_unlock_exclusive, tty_ldisc_deref]\n\n2. 函数名: console_lock\n- 参数: []\n- 调用者: paste_selection\n- 被调用者: []\n\n3. 函数名: poke_blanked_console\n- 参数: []\n- 调用者: paste_selection\n- 被调用者: []\n\n4. 函数名: console_unlock\n- 参数: []\n- 调用者: paste_selection\n- 被调用者: []\n\n5. 函数名: tty_ldisc_ref_wait\n- 参数: [struct tty_struct *tty]\n- 调用者: paste_selection\n- 被调用者: []\n\n6. 函数名: tty_buffer_lock_exclusive\n- 参数: [struct tty_port *port]\n- 调用者: paste_selection\n- 被调用者: []\n\n7. 函数名: add_wait_queue\n- 参数: [wait_queue_head_t *q, wait_queue_entry_t *wait]\n- 调用者: paste_selection\n- 被调用者: []\n\n8. 函数名: set_current_state\n- 参数: [long state]\n- 调用者: paste_selection\n- 被调用者: []\n\n9. 函数名: signal_pending\n- 参数: [struct task_struct *p]\n- 调用者: paste_selection\n- 被调用者: []\n\n10. 函数名: tty_throttled\n- 参数: [struct tty_struct *tty]\n- 调用者: paste_selection\n- 被调用者: []\n\n11. 函数名: schedule\n- 参数: []\n- 调用者: paste_selection\n- 被调用者: []\n\n12. 函数名: __set_current_state\n- 参数: [long state]\n- 调用者: paste_selection\n- 被调用者: []\n\n13. 函数名: tty_ldisc_receive_buf\n- 参数: [struct tty_ldisc *ld, const unsigned char *cp, char *fp, int count]\n- 调用者: paste_selection\n- 被调用者: []\n\n14. 函数名: remove_wait_queue\n- 参数: [wait_queue_head_t *q, wait_queue_entry_t *wait]\n- 调用者: paste_selection\n- 被调用者: []\n\n15. 函数名: tty_buffer_unlock_exclusive\n- 参数: [struct tty_port *port]\n- 调用者: paste_selection\n- 被调用者: []\n\n16. 函数名: tty_ldisc_deref\n- 参数: [struct tty_ldisc *ld]\n- 调用者: paste_selection\n- 被调用者: []"
    },
    {
        "id": 2816,
        "cwe": "CWE-416",
        "cve": "CVE-2021-0342",
        "purpose": "Code purpose:\"\"\"处理从用户空间接收到的网络数据包，构建并传递内核网络栈所需的sk_buff结构，同时支持多种特性如零拷贝、GRO等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在tun_get_user函数中存在内存释放后继续使用的情况，导致内存损坏，可能引发本地权限提升。\"\"\"",
        "functions": "Functions:\n1. 函数名: tun_get_user\n- 参数: [tun, tfile, msg_control, from, noblock, more]\n- 调用者: N/A (top-level function)\n- 被调用者: [iov_iter_count, copy_from_iter_full, iov_iter_advance, tun16_to_cpu, cpu_to_tun16, tun_napi_frags_enabled, tun_can_build_skb, tun_build_skb, tun_napi_alloc_frags, tun_alloc_skb, zerocopy_sg_from_iter, skb_copy_datagram_from_iter, virtio_net_hdr_to_skb, eth_type_trans, do_xdp_generic, __skb_get_hash_symmetric, eth_get_headlen, napi_gro_frags, napi_schedule, tun_rx_batched, netif_rx_ni, tun_flow_update]\n\n2. 函数名: iov_iter_count\n- 参数: [from]\n- 调用者: tun_get_user\n- 被调用者: []\n\n3. 函数名: copy_from_iter_full\n- 参数: [&pi, sizeof(pi), from], [&gso, sizeof(gso), from]\n- 调用者: tun_get_user\n- 被调用者: []\n\n4. 函数名: iov_iter_advance\n- 参数: [from, vnet_hdr_sz - sizeof(gso)], [&i, copylen]\n- 调用者: tun_get_user\n- 被调用者: []\n\n5. 函数名: tun16_to_cpu\n- 参数: [tun, gso.csum_start], [tun, gso.csum_offset], [tun, gso.hdr_len]\n- 调用者: tun_get_user\n- 被调用者: []\n\n6. 函数名: cpu_to_tun16\n- 参数: [tun, tun16_to_cpu(tun, gso.csum_start) + tun16_to_cpu(tun, gso.csum_offset) + 2]\n- 调用者: tun_get_user\n- 被调用者: []\n\n7. 函数名: tun_napi_frags_enabled\n- 参数: [tfile]\n- 调用者: tun_get_user\n- 被调用者: []\n\n8. 函数名: tun_can_build_skb\n- 参数: [tun, tfile, len, noblock, zerocopy]\n- 调用者: tun_get_user\n- 被调用者: []\n\n9. 函数名: tun_build_skb\n- 参数: [tun, tfile, from, &gso, len, &skb_xdp]\n- 调用者: tun_get_user\n- 被调用者: []\n\n10. 函数名: tun_napi_alloc_frags\n- 参数: [tfile, copylen, from]\n- 调用者: tun_get_user\n- 被调用者: []\n\n11. 函数名: tun_alloc_skb\n- 参数: [tfile, align, copylen, linear, noblock]\n- 调用者: tun_get_user\n- 被调用者: []\n\n12. 函数名: zerocopy_sg_from_iter\n- 参数: [skb, from]\n- 调用者: tun_get_user\n- 被调用者: []\n\n13. 函数名: skb_copy_datagram_from_iter\n- 参数: [skb, 0, from, len]\n- 调用者: tun_get_user\n- 被调用者: []\n\n14. 函数名: virtio_net_hdr_to_skb\n- 参数: [skb, &gso, tun_is_little_endian(tun)]\n- 调用者: tun_get_user\n- 被调用者: []\n\n15. 函数名: eth_type_trans\n- 参数: [skb, tun->dev]\n- 调用者: tun_get_user\n- 被调用者: []\n\n16. 函数名: do_xdp_generic\n- 参数: [xdp_prog, skb]\n- 调用者: tun_get_user\n- 被调用者: []\n\n17. 函数名: __skb_get_hash_symmetric\n- 参数: [skb]\n- 调用者: tun_get_user\n- 被调用者: []\n\n18. 函数名: eth_get_headlen\n- 参数: [tun->dev, skb->data, skb_headlen(skb)]\n- 调用者: tun_get_user\n- 被调用者: []\n\n19. 函数名: napi_gro_frags\n- 参数: [&tfile->napi]\n- 调用者: tun_get_user\n- 被调用者: []\n\n20. 函数名: napi_schedule\n- 参数: [&tfile->napi]\n- 调用者: tun_get_user\n- 被调用者: []\n\n21. 函数名: tun_rx_batched\n- 参数: [tun, tfile, skb, more]\n- 调用者: tun_get_user\n- 被调用者: []\n\n22. 函数名: netif_rx_ni\n- 参数: [skb]\n- 调用者: tun_get_user\n- 被调用者: []\n\n23. 函数名: tun_flow_update\n- 参数: [tun, rxhash, tfile]\n- 调用者: tun_get_user\n- 被调用者: []"
    },
    {
        "id": 2829,
        "cwe": "CWE-416",
        "cve": "CVE-2021-0707",
        "purpose": "Code purpose:\"\"\"释放DMA缓冲区资源并清理相关数据结构，防止内存泄漏和资源占用\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在dma_buf_release函数中，由于在释放dmabuf内存后可能仍存在对该内存的引用，导致了释放后使用(UAF)的内存损坏漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: dma_buf_release\n- 参数: [struct dentry *dentry]\n- 调用者: 未明确显示（通常是文件系统操作相关调用）\n- 被调用者: [mutex_lock, list_del, mutex_unlock, dma_resv_fini, module_put, kfree]\n\n2. 函数名: mutex_lock\n- 参数: [&db_list.lock]\n- 调用者: dma_buf_release\n- 被调用者: []\n\n3. 函数名: list_del\n- 参数: [&dmabuf->list_node]\n- 调用者: dma_buf_release\n- 被调用者: []\n\n4. 函数名: mutex_unlock\n- 参数: [&db_list.lock]\n- 调用者: dma_buf_release\n- 被调用者: []\n\n5. 函数名: dma_resv_fini\n- 参数: [dmabuf->resv]\n- 调用者: dma_buf_release\n- 被调用者: []\n\n6. 函数名: module_put\n- 参数: [dmabuf->owner]\n- 调用者: dma_buf_release\n- 被调用者: []\n\n7. 函数名: kfree\n- 参数: [dmabuf->name, dmabuf]\n- 调用者: dma_buf_release\n- 被调用者: []"
    },
    {
        "id": 2832,
        "cwe": "CWE-416",
        "cve": "CVE-2021-0935",
        "purpose": "Code purpose:\"\"\"该代码实现了IPv6数据报的连接功能，处理IPv6套接字连接请求并设置相关地址和端口信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在ip6_datagram_connect函数中存在对已释放内存的后续使用(use-after-free)，导致可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: __ip6_datagram_connect\n- 参数: [sk, uaddr, addr_len]\n- 调用者: N/A (顶层函数)\n- 被调用者: [inet_sk, inet6_sk, __ipv6_only_sock, __ip4_datagram_connect, ipv6_addr_any, ipv6_addr_v4mapped, ipv6_addr_set_v4mapped, ipv6_addr_type, ipv6_mapped_addr_any, sk_dev_equal_l3scope, ip6_datagram_dst_update, memset, sk_set_txhash]\n\n2. 函数名: inet_sk\n- 参数: [sk]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n3. 函数名: inet6_sk\n- 参数: [sk]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n4. 函数名: __ipv6_only_sock\n- 参数: [sk]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n5. 函数名: __ip4_datagram_connect\n- 参数: [sk, uaddr, addr_len]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n6. 函数名: ipv6_addr_any\n- 参数: [&usin->sin6_addr]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n7. 函数名: ipv6_addr_v4mapped\n- 参数: [&sk->sk_v6_rcv_saddr]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n8. 函数名: ipv6_addr_set_v4mapped\n- 参数: [htonl(INADDR_LOOPBACK), &usin->sin6_addr]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n9. 函数名: ipv6_addr_type\n- 参数: [&usin->sin6_addr]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n10. 函数名: ipv6_mapped_addr_any\n- 参数: [&np->saddr]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n11. 函数名: sk_dev_equal_l3scope\n- 参数: [sk, usin->sin6_scope_id]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n12. 函数名: ip6_datagram_dst_update\n- 参数: [sk, true]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n13. 函数名: memset\n- 参数: [&sk->sk_v6_daddr, 0, sizeof(sk->sk_v6_daddr)]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n14. 函数名: sk_set_txhash\n- 参数: [sk]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []"
    },
    {
        "id": 2838,
        "cwe": "CWE-416",
        "cve": "CVE-2021-0941",
        "purpose": "Code purpose:\"\"\"调整网络数据包(skb)的头部空间大小，包括扩展或收缩空间，并处理相关的校验和重置操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在bpf_skb_adjust_room函数中，由于对sk_buff对象的操作可能导致释放后使用(use-after-free)，从而引发越界读取漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: bpf_skb_adjust_room\n- 参数: [struct sk_buff *skb, s32 len_diff, u32 mode, u64 flags]\n- 调用者: 未指定\n- 被调用者: [abs, bpf_skb_net_base_len, __bpf_skb_max_len, htons, skb_mac_header_len, bpf_skb_net_shrink, bpf_skb_net_grow, __skb_reset_checksum_unnecessary, bpf_compute_data_pointers]\n\n2. 函数名: abs\n- 参数: [s32 len_diff]\n- 调用者: bpf_skb_adjust_room\n- 被调用者: []\n\n3. 函数名: bpf_skb_net_base_len\n- 参数: [struct sk_buff *skb]\n- 调用者: bpf_skb_adjust_room\n- 被调用者: []\n\n4. 函数名: __bpf_skb_max_len\n- 参数: [struct sk_buff *skb]\n- 调用者: bpf_skb_adjust_room\n- 被调用者: []\n\n5. 函数名: htons\n- 参数: [u16 proto]\n- 调用者: bpf_skb_adjust_room\n- 被调用者: []\n\n6. 函数名: skb_mac_header_len\n- 参数: [struct sk_buff *skb]\n- 调用者: bpf_skb_adjust_room\n- 被调用者: []\n\n7. 函数名: bpf_skb_net_shrink\n- 参数: [struct sk_buff *skb, u32 off, u32 len_diff_abs, u64 flags]\n- 调用者: bpf_skb_adjust_room\n- 被调用者: []\n\n8. 函数名: bpf_skb_net_grow\n- 参数: [struct sk_buff *skb, u32 off, u32 len_diff_abs, u64 flags]\n- 调用者: bpf_skb_adjust_room\n- 被调用者: []\n\n9. 函数名: __skb_reset_checksum_unnecessary\n- 参数: [struct sk_buff *skb]\n- 调用者: bpf_skb_adjust_room\n- 被调用者: []\n\n10. 函数名: bpf_compute_data_pointers\n- 参数: [struct sk_buff *skb]\n- 调用者: bpf_skb_adjust_room\n- 被调用者: []"
    },
    {
        "id": 2839,
        "cwe": "CWE-416",
        "cve": "CVE-2021-0941",
        "purpose": "Code purpose:\"\"\"该代码用于扩展网络数据包(skb)的头部空间(head_room)，并在新空间中填充零值，同时重置MAC头指针，主要用于网络数据包重定向到L2设备时的处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在__bpf_skb_change_head函数中，由于对skb缓冲区的头部空间扩展操作后未正确验证内存状态，可能导致释放后使用(UAF)的越界读取漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: __bpf_skb_change_head\n- 参数: [struct sk_buff *skb, u32 head_room, u64 flags]\n- 调用者: 未明确（可能是BPF相关调用）\n- 被调用者: [__bpf_skb_max_len, skb_is_gso, skb_cow, __skb_push, memset, skb_reset_mac_header]\n\n2. 函数名: __bpf_skb_max_len\n- 参数: [struct sk_buff *skb]\n- 调用者: __bpf_skb_change_head\n- 被调用者: []\n\n3. 函数名: skb_is_gso\n- 参数: [struct sk_buff *skb]\n- 调用者: __bpf_skb_change_head\n- 被调用者: []\n\n4. 函数名: skb_cow\n- 参数: [struct sk_buff *skb, u32 head_room]\n- 调用者: __bpf_skb_change_head\n- 被调用者: []\n\n5. 函数名: __skb_push\n- 参数: [struct sk_buff *skb, u32 head_room]\n- 调用者: __bpf_skb_change_head\n- 被调用者: []\n\n6. 函数名: memset\n- 参数: [void *skb->data, int 0, size_t head_room]\n- 调用者: __bpf_skb_change_head\n- 被调用者: []\n\n7. 函数名: skb_reset_mac_header\n- 参数: [struct sk_buff *skb]\n- 调用者: __bpf_skb_change_head\n- 被调用者: []"
    },
    {
        "id": 2840,
        "cwe": "CWE-416",
        "cve": "CVE-2021-0941",
        "purpose": "Code purpose:\"\"\"该代码用于修改网络数据包(skb)的尾部长度，包括增长或截断操作，同时处理相关的校验和及GSO(Generic Segmentation Offload)重置，是eBPF程序中用于控制消息回复的慢路径辅助函数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在__bpf_skb_change_tail函数中，由于对skb缓冲区进行修改后未正确处理其状态，可能导致释放后使用(UAF)的情况发生。\"\"\"",
        "functions": "Functions:\n1. 函数名: __bpf_skb_change_tail\n- 参数: [struct sk_buff *skb, u32 new_len, u64 flags]\n- 调用者: 未显示（外部调用）\n- 被调用者: [__bpf_skb_max_len, __bpf_skb_min_len, __bpf_try_make_writable, bpf_skb_grow_rcsum, bpf_skb_trim_rcsum, skb_is_gso, skb_gso_reset]\n\n2. 函数名: __bpf_skb_max_len\n- 参数: [struct sk_buff *skb]\n- 调用者: __bpf_skb_change_tail\n- 被调用者: []\n\n3. 函数名: __bpf_skb_min_len\n- 参数: [struct sk_buff *skb]\n- 调用者: __bpf_skb_change_tail\n- 被调用者: []\n\n4. 函数名: __bpf_try_make_writable\n- 参数: [struct sk_buff *skb, unsigned int len]\n- 调用者: __bpf_skb_change_tail\n- 被调用者: []\n\n5. 函数名: bpf_skb_grow_rcsum\n- 参数: [struct sk_buff *skb, unsigned int new_len]\n- 调用者: __bpf_skb_change_tail\n- 被调用者: []\n\n6. 函数名: bpf_skb_trim_rcsum\n- 参数: [struct sk_buff *skb, unsigned int new_len]\n- 调用者: __bpf_skb_change_tail\n- 被调用者: []\n\n7. 函数名: skb_is_gso\n- 参数: [struct sk_buff *skb]\n- 调用者: __bpf_skb_change_tail\n- 被调用者: []\n\n8. 函数名: skb_gso_reset\n- 参数: [struct sk_buff *skb]\n- 调用者: __bpf_skb_change_tail\n- 被调用者: []"
    },
    {
        "id": 2841,
        "cwe": "CWE-416",
        "cve": "CVE-2021-1048",
        "purpose": "Code purpose:\"\"\"检查事件轮询文件描述符的循环依赖关系，防止内存损坏和权限提升漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ep_loop_check_proc函数中存在释放后使用(UAF)问题，可能导致内存损坏\"\"\"",
        "functions": "Functions:\n1. 函数名: ep_loop_check_proc\n- 参数: [priv, cookie, call_nests]\n- 调用者: ep_call_nested\n- 被调用者: [mutex_lock_nested, rb_first_cached, rb_next, rb_entry, is_file_epoll, ep_call_nested, get_file, list_add, mutex_unlock]\n\n2. 函数名: mutex_lock_nested\n- 参数: [&ep->mtx, call_nests + 1]\n- 调用者: ep_loop_check_proc\n- 被调用者: []\n\n3. 函数名: rb_first_cached\n- 参数: [&ep->rbr]\n- 调用者: ep_loop_check_proc\n- 被调用者: []\n\n4. 函数名: rb_next\n- 参数: [rbp]\n- 调用者: ep_loop_check_proc\n- 被调用者: []\n\n5. 函数名: rb_entry\n- 参数: [rbp, struct epitem, rbn]\n- 调用者: ep_loop_check_proc\n- 被调用者: []\n\n6. 函数名: is_file_epoll\n- 参数: [epi->ffd.file]\n- 调用者: ep_loop_check_proc\n- 被调用者: []\n\n7. 函数名: ep_call_nested\n- 参数: [&poll_loop_ncalls, ep_loop_check_proc, epi->ffd.file, ep_tovisit, current]\n- 调用者: ep_loop_check_proc\n- 被调用者: []\n\n8. 函数名: get_file\n- 参数: [epi->ffd.file]\n- 调用者: ep_loop_check_proc\n- 被调用者: []\n\n9. 函数名: list_add\n- 参数: [&ep->visited_list_link, &visited_list], [&epi->ffd.file->f_tfile_llink, &tfile_check_list]\n- 调用者: ep_loop_check_proc\n- 被调用者: []\n\n10. 函数名: mutex_unlock\n- 参数: [&ep->mtx]\n- 调用者: ep_loop_check_proc\n- 被调用者: []"
    },
    {
        "id": 2868,
        "cwe": "CWE-416",
        "cve": "CVE-2021-20292",
        "purpose": "Code purpose:\"\"\"为Nouveau DRM子系统创建TTM (Translation Table Maps) 结构体，并根据设备家族选择不同的后端函数指针\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在操作对象前未验证对象是否存在，导致可能对空对象进行操作\"\"\"",
        "functions": "Functions:\n1. 函数名: nouveau_sgdma_create_ttm\n- 参数: [struct ttm_buffer_object *bo, uint32_t page_flags]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [nouveau_bdev, kzalloc, ttm_dma_tt_init]\n\n2. 函数名: nouveau_bdev\n- 参数: [struct ttm_buffer_object *bo->bdev]\n- 调用者: nouveau_sgdma_create_ttm\n- 被调用者: 未明确\n\n3. 函数名: kzalloc\n- 参数: [sizeof(*nvbe), GFP_KERNEL]\n- 调用者: nouveau_sgdma_create_ttm\n- 被调用者: 未明确\n\n4. 函数名: ttm_dma_tt_init\n- 参数: [&nvbe->ttm, bo, page_flags]\n- 调用者: nouveau_sgdma_create_ttm\n- 被调用者: [ttm_tt_destroy]\n\n5. 函数名: ttm_tt_destroy\n- 参数: 未明确（由ttm_dma_tt_init调用）\n- 调用者: ttm_dma_tt_init\n- 被调用者: [nouveau_sgdma_destroy]\n\n6. 函数名: nouveau_sgdma_destroy\n- 参数: 未明确（由ttm_tt_destroy调用）\n- 调用者: ttm_tt_destroy\n- 被调用者: 未明确"
    },
    {
        "id": 2869,
        "cwe": "CWE-416",
        "cve": "CVE-2021-20292",
        "purpose": "Code purpose:\"\"\"初始化TTM DMA传输表并分配页目录\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在操作对象前未验证对象是否存在\"\"\"",
        "functions": "Functions:\n1. 函数名: ttm_dma_tt_init\n- 参数: [ttm_dma, bo, page_flags]\n- 调用者: 未提供\n- 被调用者: [ttm_tt_init_fields, ttm_dma_tt_alloc_page_directory, ttm_tt_destroy]\n\n2. 函数名: ttm_tt_init_fields\n- 参数: [ttm, bo, page_flags]\n- 调用者: ttm_dma_tt_init\n- 被调用者: 未提供\n\n3. 函数名: ttm_dma_tt_alloc_page_directory\n- 参数: [ttm_dma]\n- 调用者: ttm_dma_tt_init\n- 被调用者: 未提供\n\n4. 函数名: ttm_tt_destroy\n- 参数: [ttm]\n- 调用者: ttm_dma_tt_init\n- 被调用者: 未提供"
    },
    {
        "id": 2870,
        "cwe": "CWE-416",
        "cve": "CVE-2021-20292",
        "purpose": "Code purpose:\"\"\"初始化TTM(TTM缓冲区对象)页表目录，并在分配失败时进行清理操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ttm_tt_init函数中未验证ttm对象是否存在就直接进行操作，导致释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ttm_tt_init\n- 参数: [struct ttm_tt *ttm, struct ttm_buffer_object *bo, uint32_t page_flags]\n- 调用者: 未指定\n- 被调用者: [ttm_tt_init_fields, ttm_tt_alloc_page_directory, ttm_tt_destroy]\n\n2. 函数名: ttm_tt_init_fields\n- 参数: [struct ttm_tt *ttm, struct ttm_buffer_object *bo, uint32_t page_flags]\n- 调用者: ttm_tt_init\n- 被调用者: 未指定\n\n3. 函数名: ttm_tt_alloc_page_directory\n- 参数: [struct ttm_tt *ttm]\n- 调用者: ttm_tt_init\n- 被调用者: 未指定\n\n4. 函数名: ttm_tt_destroy\n- 参数: [struct ttm_tt *ttm]\n- 调用者: ttm_tt_init\n- 被调用者: 未指定"
    },
    {
        "id": 2871,
        "cwe": "CWE-416",
        "cve": "CVE-2021-20292",
        "purpose": "Code purpose:\"\"\"初始化TTM(Translation Table Maps)数据结构，包括分配页目录并根据标志位选择不同的分配方式\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在操作对象前未验证对象是否存在，导致可能对空对象进行操作\"\"\"",
        "functions": "Functions:\n1. 函数名: ttm_sg_tt_init\n- 参数: [struct ttm_dma_tt *ttm_dma, struct ttm_buffer_object *bo, uint32_t page_flags]\n- 调用者: 未指定\n- 被调用者: [ttm_tt_init_fields, INIT_LIST_HEAD, ttm_sg_tt_alloc_page_directory, ttm_dma_tt_alloc_page_directory, ttm_tt_destroy]\n\n2. 函数名: ttm_tt_init_fields\n- 参数: [struct ttm_tt *ttm, struct ttm_buffer_object *bo, uint32_t page_flags]\n- 调用者: ttm_sg_tt_init\n- 被调用者: 未指定\n\n3. 函数名: INIT_LIST_HEAD\n- 参数: [&ttm_dma->pages_list]\n- 调用者: ttm_sg_tt_init\n- 被调用者: 未指定\n\n4. 函数名: ttm_sg_tt_alloc_page_directory\n- 参数: [struct ttm_dma_tt *ttm_dma]\n- 调用者: ttm_sg_tt_init\n- 被调用者: 未指定\n\n5. 函数名: ttm_dma_tt_alloc_page_directory\n- 参数: [struct ttm_dma_tt *ttm_dma]\n- 调用者: ttm_sg_tt_init\n- 被调用者: 未指定\n\n6. 函数名: ttm_tt_destroy\n- 参数: [struct ttm_tt *ttm]\n- 调用者: ttm_sg_tt_init\n- 被调用者: 未指定"
    },
    {
        "id": 2890,
        "cwe": "CWE-416",
        "cve": "CVE-2021-23134",
        "purpose": "Code purpose:\"\"\"该代码实现了NFC LLCP套接字的连接功能，包括验证连接参数、设备状态检查、资源分配和连接建立过程。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放设备资源后仍可能访问已释放的本地连接对象，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: llcp_sock_connect\n- 参数: [sock, _addr, len, flags]\n- 调用者: 无（系统调用）\n- 被调用者: [nfc_llcp_sock, lock_sock, nfc_get_device, nfc_llcp_find_local, device_lock, device_unlock, nfc_llcp_local_get, nfc_llcp_get_local_ssap, nfc_llcp_local_put, min_t, kmemdup, nfc_llcp_sock_link, nfc_llcp_send_connect, sock_wait_state, sock_sndtimeo, release_sock, nfc_llcp_sock_unlink, kfree, nfc_llcp_put_ssap, nfc_put_device]\n\n2. 函数名: nfc_llcp_sock\n- 参数: [sk]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n3. 函数名: lock_sock\n- 参数: [sk]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n4. 函数名: nfc_get_device\n- 参数: [addr->dev_idx]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n5. 函数名: nfc_llcp_find_local\n- 参数: [dev]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n6. 函数名: device_lock\n- 参数: [&dev->dev]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n7. 函数名: device_unlock\n- 参数: [&dev->dev]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n8. 函数名: nfc_llcp_local_get\n- 参数: [local]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n9. 函数名: nfc_llcp_get_local_ssap\n- 参数: [local]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n10. 函数名: nfc_llcp_local_put\n- 参数: [llcp_sock->local]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n11. 函数名: min_t\n- 参数: [unsigned int, addr->service_name_len, NFC_LLCP_MAX_SERVICE_NAME]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n12. 函数名: kmemdup\n- 参数: [addr->service_name, llcp_sock->service_name_len, GFP_KERNEL]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n13. 函数名: nfc_llcp_sock_link\n- 参数: [&local->connecting_sockets, sk]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n14. 函数名: nfc_llcp_send_connect\n- 参数: [llcp_sock]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n15. 函数名: sock_wait_state\n- 参数: [sk, LLCP_CONNECTED, sock_sndtimeo(sk, flags & O_NONBLOCK)]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n16. 函数名: sock_sndtimeo\n- 参数: [sk, flags & O_NONBLOCK]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n17. 函数名: release_sock\n- 参数: [sk]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n18. 函数名: nfc_llcp_sock_unlink\n- 参数: [&local->connecting_sockets, sk]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n19. 函数名: kfree\n- 参数: [llcp_sock->service_name]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n20. 函数名: nfc_llcp_put_ssap\n- 参数: [local, llcp_sock->ssap]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n21. 函数名: nfc_put_device\n- 参数: [dev]\n- 调用者: llcp_sock_connect\n- 被调用者: 无"
    },
    {
        "id": 2916,
        "cwe": "CWE-416",
        "cve": "CVE-2021-28691",
        "purpose": "Code purpose:\"\"\"该代码用于建立和管理Xen虚拟网络后端设备的数据连接，包括初始化环形缓冲区、创建内核线程处理网络数据收发以及绑定事件通道到中断处理程序。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当恶意或错误的网络PV前端发送畸形数据包时，会导致Linux netback禁用接口并终止队列0的接收内核线程，而在后端销毁时，由于该线程已退出，kthread_stop将操作一个已释放的指针，从而引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: xenvif_connect_data\n- 参数: [struct xenvif_queue *queue, unsigned long tx_ring_ref, unsigned long rx_ring_ref, unsigned int tx_evtchn, unsigned int rx_evtchn]\n- 调用者: N/A (top-level function)\n- 被调用者: [xenvif_to_xenbus_device, xenvif_map_frontend_data_rings, init_waitqueue_head, atomic_set, netif_napi_add, kthread_run, IS_ERR, bind_interdomain_evtchn_to_irqhandler_lateeoi, disable_irq, snprintf, pr_warn, xenvif_disconnect_queue]\n\n2. 函数名: xenvif_to_xenbus_device\n- 参数: [struct xenvif *vif]\n- 调用者: xenvif_connect_data\n- 被调用者: N/A\n\n3. 函数名: xenvif_map_frontend_data_rings\n- 参数: [struct xenvif_queue *queue, unsigned long tx_ring_ref, unsigned long rx_ring_ref]\n- 调用者: xenvif_connect_data\n- 被调用者: N/A\n\n4. 函数名: init_waitqueue_head\n- 参数: [wait_queue_head_t *q]\n- 调用者: xenvif_connect_data\n- 被调用者: N/A\n\n5. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: xenvif_connect_data\n- 被调用者: N/A\n\n6. 函数名: netif_napi_add\n- 参数: [struct net_device *dev, struct napi_struct *napi, int (*poll)(struct napi_struct *, int), int weight]\n- 调用者: xenvif_connect_data\n- 被调用者: N/A\n\n7. 函数名: kthread_run\n- 参数: [int (*threadfn)(void *data), void *data, const char namefmt[], ...]\n- 调用者: xenvif_connect_data\n- 被调用者: N/A\n\n8. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: xenvif_connect_data\n- 被调用者: N/A\n\n9. 函数名: bind_interdomain_evtchn_to_irqhandler_lateeoi\n- 参数: [struct xenbus_device *dev, evtchn_port_t evtchn, irq_handler_t handler, unsigned long irqflags, const char *devname, void *dev_id]\n- 调用者: xenvif_connect_data\n- 被调用者: N/A\n\n10. 函数名: disable_irq\n- 参数: [unsigned int irq]\n- 调用者: xenvif_connect_data\n- 被调用者: N/A\n\n11. 函数名: snprintf\n- 参数: [char *str, size_t size, const char *format, ...]\n- 调用者: xenvif_connect_data\n- 被调用者: N/A\n\n12. 函数名: pr_warn\n- 参数: [const char *fmt, ...]\n- 调用者: xenvif_connect_data\n- 被调用者: N/A\n\n13. 函数名: xenvif_disconnect_queue\n- 参数: [struct xenvif_queue *queue]\n- 调用者: xenvif_connect_data\n- 被调用者: N/A\n\n14. 函数名: xenvif_kthread_guest_rx\n- 参数: [void *data]\n- 调用者: kthread_run (indirectly via xenvif_connect_data)\n- 被调用者: N/A\n\n15. 函数名: xenvif_dealloc_kthread\n- 参数: [void *data]\n- 调用者: kthread_run (indirectly via xenvif_connect_data)\n- 被调用者: N/A\n\n16. 函数名: xenvif_interrupt\n- 参数: [int irq, void *dev_id]\n- 调用者: bind_interdomain_evtchn_to_irqhandler_lateeoi (indirectly via xenvif_connect_data)\n- 被调用者: N/A\n\n17. 函数名: xenvif_tx_interrupt\n- 参数: [int irq, void *dev_id]\n- 调用者: bind_interdomain_evtchn_to_irqhandler_lateeoi (indirectly via xenvif_connect_data)\n- 被调用者: N/A\n\n18. 函数名: xenvif_rx_interrupt\n- 参数: [int irq, void *dev_id]\n- 调用者: bind_interdomain_evtchn_to_irqhandler_lateeoi (indirectly via xenvif_connect_data)\n- 被调用者: N/A\n\n19. 函数名: xenvif_poll\n- 参数: [struct napi_struct *napi, int weight]\n- 调用者: netif_napi_add (indirectly via xenvif_connect_data)\n- 被调用者: N/A"
    },
    {
        "id": 2917,
        "cwe": "CWE-416",
        "cve": "CVE-2021-28691",
        "purpose": "Code purpose:\"\"\"该代码用于安全断开并清理Xen虚拟网络后端队列的相关资源，包括停止内核线程、删除NAPI轮询处理以及解除中断处理程序等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当恶意前端发送畸形数据包导致接收内核线程提前终止时，后端销毁时对已释放的线程指针调用kthread_stop引发use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: xenvif_disconnect_queue\n- 参数: [struct xenvif_queue *queue]\n- 调用者: 未显示\n- 被调用者: [kthread_stop, netif_napi_del, unbind_from_irqhandler, xenvif_unmap_frontend_data_rings]\n\n2. 函数名: kthread_stop\n- 参数: [queue->task, queue->dealloc_task]\n- 调用者: xenvif_disconnect_queue\n- 被调用者: 未显示\n\n3. 函数名: netif_napi_del\n- 参数: [&queue->napi]\n- 调用者: xenvif_disconnect_queue\n- 被调用者: 未显示\n\n4. 函数名: unbind_from_irqhandler\n- 参数: [queue->tx_irq, queue], [queue->rx_irq, queue]\n- 调用者: xenvif_disconnect_queue\n- 被调用者: 未显示\n\n5. 函数名: xenvif_unmap_frontend_data_rings\n- 参数: [queue]\n- 调用者: xenvif_disconnect_queue\n- 被调用者: 未显示"
    },
    {
        "id": 2948,
        "cwe": "CWE-416",
        "cve": "CVE-2021-29266",
        "purpose": "Code purpose:\"\"\"释放vhost_vdpa结构中config_ctx指向的eventfd上下文资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在重新打开字符设备时，v->config_ctx持有无效值导致释放后使用\"\"\"",
        "functions": "Functions:\n1. 函数名: vhost_vdpa_config_put\n- 参数: [struct vhost_vdpa *v]\n- 调用者: 未明确（由漏洞描述推测可能由字符设备操作相关代码调用）\n- 被调用者: [eventfd_ctx_put]\n\n2. 函数名: eventfd_ctx_put\n- 参数: [未明确（应为eventfd_ctx对象指针）]\n- 调用者: [vhost_vdpa_config_put]\n- 被调用者: 未明确（内核基础函数）"
    },
    {
        "id": 2956,
        "cwe": "CWE-416",
        "cve": "CVE-2021-29657",
        "purpose": "Code purpose:\"\"\"该代码用于在AMD KVM虚拟化环境中进入嵌套SVM客户模式，设置相关控制结构并加载客户机状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在嵌套SVM虚拟机运行时存在VMCB12双重获取导致的TOCTOU竞争条件，使得AMD KVM客户机可以绕过主机操作系统MSR的访问控制\"\"\"",
        "functions": "Functions:\n1. 函数名: enter_svm_guest_mode\n- 参数: [svm, vmcb12_gpa, vmcb12]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [load_nested_vmcb_control, nested_prepare_vmcb_save, nested_prepare_vmcb_control, nested_svm_load_cr3, svm_set_gif]\n\n2. 函数名: load_nested_vmcb_control\n- 参数: [svm, &vmcb12->control]\n- 调用者: enter_svm_guest_mode\n- 被调用者: []\n\n3. 函数名: nested_prepare_vmcb_save\n- 参数: [svm, vmcb12]\n- 调用者: enter_svm_guest_mode\n- 被调用者: []\n\n4. 函数名: nested_prepare_vmcb_control\n- 参数: [svm]\n- 调用者: enter_svm_guest_mode\n- 被调用者: []\n\n5. 函数名: nested_svm_load_cr3\n- 参数: [&svm->vcpu, vmcb12->save.cr3, nested_npt_enabled(svm)]\n- 调用者: enter_svm_guest_mode\n- 被调用者: [nested_npt_enabled]\n\n6. 函数名: nested_npt_enabled\n- 参数: [svm]\n- 调用者: nested_svm_load_cr3\n- 被调用者: []\n\n7. 函数名: svm_set_gif\n- 参数: [svm, true]\n- 调用者: enter_svm_guest_mode\n- 被调用者: []"
    },
    {
        "id": 2957,
        "cwe": "CWE-416",
        "cve": "CVE-2021-29657",
        "purpose": "Code purpose:\"\"\"该代码实现了AMD KVM中嵌套虚拟化环境下虚拟机运行(vmrun)的功能，处理虚拟机控制块(VMCB)的切换和状态保存，但存在VMCB12双重获取导致的竞争条件漏洞。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在nested_svm_vmrun函数中存在对VMCB12的双重获取(TOCTOU竞态条件)，导致在嵌套虚拟化环境中可能绕过主机操作系统MSR的访问控制，造成释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: nested_svm_vmrun\n- 参数: [struct vcpu_svm *svm]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [is_smm, kvm_queue_exception, kvm_vcpu_map, gpa_to_gfn, kvm_inject_gp, kvm_skip_emulated_instruction, WARN_ON_ONCE, nested_vmcb_checks, trace_kvm_nested_vmrun, trace_kvm_nested_intercepts, kvm_clear_exception_queue, kvm_clear_interrupt_queue, kvm_read_cr0, kvm_get_rflags, kvm_rip_read, kvm_read_cr3, copy_vmcb_control_area, enter_svm_guest_mode, nested_svm_vmrun_msrpm, nested_svm_vmexit, kvm_vcpu_unmap]\n\n2. 函数名: is_smm\n- 参数: [struct vcpu *vcpu]\n- 调用者: nested_svm_vmrun\n- 被调用者: []\n\n3. 函数名: kvm_queue_exception\n- 参数: [struct vcpu *vcpu, int nr]\n- 调用者: nested_svm_vmrun\n- 被调用者: []\n\n4. 函数名: kvm_vcpu_map\n- 参数: [struct vcpu *vcpu, gfn_t gfn, struct kvm_host_map *map]\n- 调用者: nested_svm_vmrun\n- 被调用者: []\n\n5. 函数名: gpa_to_gfn\n- 参数: [gpa_t gpa]\n- 调用者: nested_svm_vmrun\n- 被调用者: []\n\n6. 函数名: kvm_inject_gp\n- 参数: [struct vcpu *vcpu, u32 error_code]\n- 调用者: nested_svm_vmrun\n- 被调用者: []\n\n7. 函数名: kvm_skip_emulated_instruction\n- 参数: [struct vcpu *vcpu]\n- 调用者: nested_svm_vmrun\n- 被调用者: []\n\n8. 函数名: WARN_ON_ONCE\n- 参数: [bool condition]\n- 调用者: nested_svm_vmrun\n- 被调用者: []\n\n9. 函数名: nested_vmcb_checks\n- 参数: [struct vcpu_svm *svm, struct vmcb *vmcb12]\n- 调用者: nested_svm_vmrun\n- 被调用者: []\n\n10. 函数名: trace_kvm_nested_vmrun\n- 参数: [u64 rip, u64 vmcb12_gpa, u64 vmcb12_rip, u32 int_ctl, u32 event_inj, u32 nested_ctl]\n- 调用者: nested_svm_vmrun\n- 被调用者: []\n\n11. 函数名: trace_kvm_nested_intercepts\n- 参数: [u16 cr_intercepts_low, u16 cr_intercepts_high, u32 exception_intercepts, u32 word3_intercepts, u32 word4_intercepts, u32 word5_intercepts]\n- 调用者: nested_svm_vmrun\n- 被调用者: []\n\n12. 函数名: kvm_clear_exception_queue\n- 参数: [struct vcpu *vcpu]\n- 调用者: nested_svm_vmrun\n- 被调用者: []\n\n13. 函数名: kvm_clear_interrupt_queue\n- 参数: [struct vcpu *vcpu]\n- 调用者: nested_svm_vmrun\n- 被调用者: []\n\n14. 函数名: kvm_read_cr0\n- 参数: [struct vcpu *vcpu]\n- 调用者: nested_svm_vmrun\n- 被调用者: []\n\n15. 函数名: kvm_get_rflags\n- 参数: [struct vcpu *vcpu]\n- 调用者: nested_svm_vmrun\n- 被调用者: []\n\n16. 函数名: kvm_rip_read\n- 参数: [struct vcpu *vcpu]\n- 调用者: nested_svm_vmrun\n- 被调用者: []\n\n17. 函数名: kvm_read_cr3\n- 参数: [struct vcpu *vcpu]\n- 调用者: nested_svm_vmrun\n- 被调用者: []\n\n18. 函数名: copy_vmcb_control_area\n- 参数: [struct vmcb_control_area *dst, struct vmcb_control_area *src]\n- 调用者: nested_svm_vmrun\n- 被调用者: []\n\n19. 函数名: enter_svm_guest_mode\n- 参数: [struct vcpu_svm *svm, u64 vmcb12_gpa, struct vmcb *vmcb12]\n- 调用者: nested_svm_vmrun\n- 被调用者: []\n\n20. 函数名: nested_svm_vmrun_msrpm\n- 参数: [struct vcpu_svm *svm]\n- 调用者: nested_svm_vmrun\n- 被调用者: []\n\n21. 函数名: nested_svm_vmexit\n- 参数: [struct vcpu_svm *svm]\n- 调用者: nested_svm_vmrun\n- 被调用者: []\n\n22. 函数名: kvm_vcpu_unmap\n- 参数: [struct vcpu *vcpu, struct kvm_host_map *map, bool dirty]\n- 调用者: nested_svm_vmrun\n- 被调用者: []"
    },
    {
        "id": 2966,
        "cwe": "CWE-416",
        "cve": "CVE-2021-32606",
        "purpose": "Code purpose:\"\"\"该代码实现了CAN ISO-TP套接字选项的设置功能，包括各种ISO-TP协议相关参数的配置和验证。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在CAN ISOTP套接字选项设置过程中存在释放后使用(use-after-free)问题，导致可利用此漏洞进行权限提升\"\"\"",
        "functions": "Functions:\n1. 函数名: isotp_setsockopt\n- 参数: [struct socket *sock, int level, int optname, sockptr_t optval, unsigned int optlen]\n- 调用者: 未明确显示（通常由内核网络栈调用）\n- 被调用者: [copy_from_sockptr, memcpy, padlen]\n\n2. 函数名: copy_from_sockptr\n- 参数: [void *dst, sockptr_t src, size_t size]\n- 调用者: isotp_setsockopt\n- 被调用者: []\n\n3. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: isotp_setsockopt\n- 被调用者: []\n\n4. 函数名: padlen\n- 参数: [未明确显示参数，推测为某种长度参数]\n- 调用者: isotp_setsockopt\n- 被调用者: []"
    },
    {
        "id": 2967,
        "cwe": "CWE-416",
        "cve": "CVE-2021-32606",
        "purpose": "Code purpose:\"\"\"该代码实现了ISOTP协议套接字的绑定功能，包括地址验证、网络设备检查和接收过滤器注册等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在CAN ISOTP SF_BROADCAST支持中未正确处理socket选项设置，导致存在释放后使用(UAF)漏洞，可能被利用进行权限提升。\"\"\"",
        "functions": "Functions:\n1. 函数名: isotp_bind\n- 参数: [struct socket *sock, struct sockaddr *uaddr, int len]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [isotp_sk, sock_net, dev_get_by_index, dev_put, can_rx_register, can_rx_unregister, lock_sock, release_sock]\n\n2. 函数名: isotp_sk\n- 参数: [struct sock *sk]\n- 调用者: isotp_bind\n- 被调用者: []\n\n3. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: isotp_bind\n- 被调用者: []\n\n4. 函数名: dev_get_by_index\n- 参数: [struct net *net, int ifindex]\n- 调用者: isotp_bind\n- 被调用者: []\n\n5. 函数名: dev_put\n- 参数: [struct net_device *dev]\n- 调用者: isotp_bind\n- 被调用者: []\n\n6. 函数名: can_rx_register\n- 参数: [struct net *net, struct net_device *dev, canid_t rx_id, canid_t mask, void (*func)(struct sk_buff *, void *), void *data, char *ident, struct sock *sk]\n- 调用者: isotp_bind\n- 被调用者: []\n\n7. 函数名: can_rx_unregister\n- 参数: [struct net *net, struct net_device *dev, canid_t rx_id, canid_t mask, void (*func)(struct sk_buff *, void *), void *data]\n- 调用者: isotp_bind\n- 被调用者: []\n\n8. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: isotp_bind\n- 被调用者: []\n\n9. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: isotp_bind\n- 被调用者: []\n\n10. 函数名: isotp_rcv\n- 参数: [struct sk_buff *skb, void *data]\n- 调用者: 未显示（作为回调函数）\n- 被调用者: []\n\n11. 函数名: sk->sk_error_report\n- 参数: [struct sock *sk]\n- 调用者: isotp_bind\n- 被调用者: []"
    },
    {
        "id": 2968,
        "cwe": "CWE-416",
        "cve": "CVE-2021-33034",
        "purpose": "Code purpose:\"\"\"处理蓝牙HCI逻辑链路完成事件，创建AMP通道并与BR/EDR通道进行逻辑连接确认\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在销毁hci_chan时存在释放后使用问题，导致可以写入任意值\"\"\"",
        "functions": "Functions:\n1. 函数名: hci_loglink_complete_evt\n- 参数: [struct hci_dev *hdev, struct sk_buff *skb]\n- 调用者: 未显示（事件处理调用）\n- 被调用者: [hci_conn_hash_lookup_handle, hci_chan_create, le16_to_cpu, l2cap_chan_lock, l2cap_logical_cfm, hci_conn_hold, l2cap_chan_unlock]\n\n2. 函数名: hci_conn_hash_lookup_handle\n- 参数: [struct hci_dev *hdev, ev->phy_handle]\n- 调用者: hci_loglink_complete_evt\n- 被调用者: 未显示\n\n3. 函数名: hci_chan_create\n- 参数: [struct hci_conn *hcon]\n- 调用者: hci_loglink_complete_evt\n- 被调用者: 未显示\n\n4. 函数名: le16_to_cpu\n- 参数: [ev->handle]\n- 调用者: hci_loglink_complete_evt\n- 被调用者: 未显示\n\n5. 函数名: l2cap_chan_lock\n- 参数: [struct l2cap_chan *bredr_chan]\n- 调用者: hci_loglink_complete_evt\n- 被调用者: 未显示\n\n6. 函数名: l2cap_logical_cfm\n- 参数: [bredr_chan, hchan, 0]\n- 调用者: hci_loglink_complete_evt\n- 被调用者: 未显示\n\n7. 函数名: hci_conn_hold\n- 参数: [struct hci_conn *hcon]\n- 调用者: hci_loglink_complete_evt\n- 被调用者: 未显示\n\n8. 函数名: l2cap_chan_unlock\n- 参数: [struct l2cap_chan *bredr_chan]\n- 调用者: hci_loglink_complete_evt\n- 被调用者: 未显示"
    },
    {
        "id": 2969,
        "cwe": "CWE-416",
        "cve": "CVE-2021-33034",
        "purpose": "Code purpose:\"\"\"处理蓝牙设备逻辑链接断开事件，包括查找对应通道并销毁逻辑链接\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放hci_chan后未及时清除引用，导致后续操作中可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: hci_disconn_loglink_complete_evt\n- 参数: [struct hci_dev *hdev, struct sk_buff *skb]\n- 调用者: 未显示（由事件处理机制调用）\n- 被调用者: [le16_to_cpu, hci_dev_lock, hci_chan_lookup_handle, amp_destroy_logical_link, hci_dev_unlock]\n\n2. 函数名: le16_to_cpu\n- 参数: [ev->handle]\n- 调用者: hci_disconn_loglink_complete_evt\n- 被调用者: []\n\n3. 函数名: hci_dev_lock\n- 参数: [hdev]\n- 调用者: hci_disconn_loglink_complete_evt\n- 被调用者: []\n\n4. 函数名: hci_chan_lookup_handle\n- 参数: [hdev, le16_to_cpu(ev->handle)]\n- 调用者: hci_disconn_loglink_complete_evt\n- 被调用者: []\n\n5. 函数名: amp_destroy_logical_link\n- 参数: [hchan, ev->reason]\n- 调用者: hci_disconn_loglink_complete_evt\n- 被调用者: []\n\n6. 函数名: hci_dev_unlock\n- 参数: [hdev]\n- 调用者: hci_disconn_loglink_complete_evt\n- 被调用者: []"
    },
    {
        "id": 2977,
        "cwe": "CWE-416",
        "cve": "CVE-2021-3347",
        "purpose": "Code purpose:\"\"\"该代码用于修复futex（快速用户空间互斥锁）的PI（优先级继承）状态所有者，处理锁竞争和所有权转移问题，确保在多线程环境下正确更新锁的所有权信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在PI futex的故障处理过程中，由于未能正确管理内核栈上的引用，导致在释放后仍被使用，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: fixup_pi_state_owner\n- 参数: [u32 __user *uaddr, struct futex_q *q, struct task_struct *argowner]\n- 调用者: 未明确显示（通常是内核中处理futex的代码）\n- 被调用者: [__rt_mutex_futex_trylock, rt_mutex_owner, task_pid_vnr, get_futex_value_locked, cmpxchg_futex_value_locked, fault_in_user_writeable, cond_resched, raw_spin_lock_irq, raw_spin_unlock_irq, spin_unlock, spin_lock, raw_spin_lock, raw_spin_unlock, WARN_ON, WARN_ON_ONCE, list_empty, list_del_init, list_add]\n\n2. 函数名: __rt_mutex_futex_trylock\n- 参数: [未显示完整参数，至少包含&pi_state->pi_mutex]\n- 调用者: fixup_pi_state_owner\n- 被调用者: []\n\n3. 函数名: rt_mutex_owner\n- 参数: [未显示完整参数，至少包含&pi_state->pi_mutex]\n- 调用者: fixup_pi_state_owner\n- 被调用者: []\n\n4. 函数名: task_pid_vnr\n- 参数: [newowner]\n- 调用者: fixup_pi_state_owner\n- 被调用者: []\n\n5. 函数名: get_futex_value_locked\n- 参数: [&uval, uaddr]\n- 调用者: fixup_pi_state_owner\n- 被调用者: []\n\n6. 函数名: cmpxchg_futex_value_locked\n- 参数: [&curval, uaddr, uval, newval]\n- 调用者: fixup_pi_state_owner\n- 被调用者: []\n\n7. 函数名: fault_in_user_writeable\n- 参数: [uaddr]\n- 调用者: fixup_pi_state_owner\n- 被调用者: []\n\n8. 函数名: cond_resched\n- 参数: []\n- 调用者: fixup_pi_state_owner\n- 被调用者: []\n\n9. 函数名: raw_spin_lock_irq\n- 参数: [&pi_state->pi_mutex.wait_lock]\n- 调用者: fixup_pi_state_owner\n- 被调用者: []\n\n10. 函数名: raw_spin_unlock_irq\n- 参数: [&pi_state->pi_mutex.wait_lock]\n- 调用者: fixup_pi_state_owner\n- 被调用者: []\n\n11. 函数名: spin_unlock\n- 参数: [q->lock_ptr]\n- 调用者: fixup_pi_state_owner\n- 被调用者: []\n\n12. 函数名: spin_lock\n- 参数: [q->lock_ptr]\n- 调用者: fixup_pi_state_owner\n- 被调用者: []\n\n13. 函数名: raw_spin_lock\n- 参数: [&pi_state->owner->pi_lock, &newowner->pi_lock]\n- 调用者: fixup_pi_state_owner\n- 被调用者: []\n\n14. 函数名: raw_spin_unlock\n- 参数: [&pi_state->owner->pi_lock, &newowner->pi_lock]\n- 调用者: fixup_pi_state_owner\n- 被调用者: []\n\n15. 函数名: WARN_ON\n- 参数: [list_empty(&pi_state->list), !list_empty(&pi_state->list)]\n- 调用者: fixup_pi_state_owner\n- 被调用者: []\n\n16. 函数名: WARN_ON_ONCE\n- 参数: [1, argowner != current]\n- 调用者: fixup_pi_state_owner\n- 被调用者: []\n\n17. 函数名: list_empty\n- 参数: [&pi_state->list]\n- 调用者: fixup_pi_state_owner\n- 被调用者: []\n\n18. 函数名: list_del_init\n- 参数: [&pi_state->list]\n- 调用者: fixup_pi_state_owner\n- 被调用者: []\n\n19. 函数名: list_add\n- 参数: [&pi_state->list, &newowner->pi_state_list]\n- 调用者: fixup_pi_state_owner\n- 被调用者: []"
    },
    {
        "id": 2978,
        "cwe": "CWE-416",
        "cve": "CVE-2021-3347",
        "purpose": "Code purpose:\"\"\"该代码用于修复futex锁的所有权问题，处理在获取锁或锁被窃取时的状态修正，确保正确的进程拥有锁的所有权。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在PI futexes处理过程中存在内核栈上的释放后使用(UAF)问题，导致本地用户可能在内核执行代码。\"\"\"",
        "functions": "Functions:\n1. 函数名: fixup_owner\n- 参数: [u32 __user *uaddr, struct futex_q *q, int locked]\n- 调用者: (未在代码片段中显示)\n- 被调用者: [fixup_pi_state_owner, rt_mutex_owner]\n\n2. 函数名: fixup_pi_state_owner\n- 参数: [u32 __user *uaddr, struct futex_q *q, struct task_struct *new_owner]\n- 调用者: fixup_owner\n- 被调用者: (未在代码片段中显示)\n\n3. 函数名: rt_mutex_owner\n- 参数: [struct rt_mutex *lock]\n- 调用者: fixup_owner\n- 被调用者: (未在代码片段中显示)"
    },
    {
        "id": 2979,
        "cwe": "CWE-416",
        "cve": "CVE-2021-3347",
        "purpose": "Code purpose:\"\"\"实现futex的等待和重新排队机制，支持优先级继承(PI)以解决优先级反转问题\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核在处理PI futexes时存在栈上引用已释放内存的问题，导致本地用户可利用该漏洞执行内核代码。\"\"\"",
        "functions": "Functions:\n1. 函数名: futex_wait_requeue_pi\n- 参数: [u32 __user *uaddr, unsigned int flags, u32 val, ktime_t *abs_time, u32 bitset, u32 __user *uaddr2]\n- 调用者: 未显示\n- 被调用者: [futex_setup_timer, rt_mutex_init_waiter, get_futex_key, futex_wait_setup, queue_unlock, futex_wait_queue_me, handle_early_requeue_pi_wakeup, fixup_pi_state_owner, put_pi_state, get_pi_state, rt_mutex_wait_proxy_lock, rt_mutex_cleanup_proxy_lock, debug_rt_mutex_free_waiter, fixup_owner, unqueue_me_pi, rt_mutex_futex_unlock, hrtimer_cancel, destroy_hrtimer_on_stack]\n\n2. 函数名: futex_setup_timer\n- 参数: [ktime_t *abs_time, struct hrtimer_sleeper *timeout, unsigned int flags, current->timer_slack_ns]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n3. 函数名: rt_mutex_init_waiter\n- 参数: [struct rt_mutex_waiter *rt_waiter]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n4. 函数名: get_futex_key\n- 参数: [u32 __user *uaddr2, flags & FLAGS_SHARED, union futex_key *key2, FUTEX_WRITE]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n5. 函数名: futex_wait_setup\n- 参数: [u32 __user *uaddr, u32 val, unsigned int flags, struct futex_q *q, struct futex_hash_bucket **hb]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n6. 函数名: queue_unlock\n- 参数: [struct futex_hash_bucket *hb]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n7. 函数名: futex_wait_queue_me\n- 参数: [struct futex_hash_bucket *hb, struct futex_q *q, struct hrtimer_sleeper *to]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n8. 函数名: handle_early_requeue_pi_wakeup\n- 参数: [struct futex_hash_bucket *hb, struct futex_q *q, union futex_key *key2, struct hrtimer_sleeper *to]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n9. 函数名: fixup_pi_state_owner\n- 参数: [u32 __user *uaddr2, struct futex_q *q, current]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n10. 函数名: put_pi_state\n- 参数: [struct futex_pi_state *pi_state]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n11. 函数名: get_pi_state\n- 参数: [struct futex_pi_state *pi_state]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n12. 函数名: rt_mutex_wait_proxy_lock\n- 参数: [struct rt_mutex *pi_mutex, struct hrtimer_sleeper *to, struct rt_mutex_waiter *rt_waiter]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n13. 函数名: rt_mutex_cleanup_proxy_lock\n- 参数: [struct rt_mutex *pi_mutex, struct rt_mutex_waiter *rt_waiter]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n14. 函数名: debug_rt_mutex_free_waiter\n- 参数: [struct rt_mutex_waiter *rt_waiter]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n15. 函数名: fixup_owner\n- 参数: [u32 __user *uaddr2, struct futex_q *q, !ret]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n16. 函数名: unqueue_me_pi\n- 参数: [struct futex_q *q]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n17. 函数名: rt_mutex_futex_unlock\n- 参数: [struct rt_mutex *pi_mutex]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n18. 函数名: hrtimer_cancel\n- 参数: [struct hrtimer *timer]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示\n\n19. 函数名: destroy_hrtimer_on_stack\n- 参数: [struct hrtimer *timer]\n- 调用者: futex_wait_requeue_pi\n- 被调用者: 未显示"
    },
    {
        "id": 2980,
        "cwe": "CWE-416",
        "cve": "CVE-2021-3348",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的NBD(网络块设备)驱动中添加一个新的socket连接，处理设备设置过程中的连接管理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在设备设置过程中，当处理I/O请求时存在对已释放内存的引用，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nbd_add_socket\n- 参数: [struct nbd_device *nbd, unsigned long arg, bool netlink]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [nbd_get_socket, dev_err, kzalloc, krealloc, kfree, mutex_init, sockfd_put, atomic_inc]\n\n2. 函数名: nbd_get_socket\n- 参数: [struct nbd_device *nbd, unsigned long arg, int *err]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确\n\n3. 函数名: dev_err\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确\n\n4. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确\n\n5. 函数名: krealloc\n- 参数: [const void *p, size_t new_size, gfp_t flags]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确\n\n6. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确\n\n7. 函数名: mutex_init\n- 参数: [struct mutex *lock]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确\n\n8. 函数名: sockfd_put\n- 参数: [struct socket *sock]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确\n\n9. 函数名: atomic_inc\n- 参数: [atomic_t *v]\n- 调用者: nbd_add_socket\n- 被调用者: 未明确"
    },
    {
        "id": 3007,
        "cwe": "CWE-416",
        "cve": "CVE-2021-3483",
        "purpose": "Code purpose:\"\"\"该代码实现了Nosy驱动程序的ioctl接口，用于处理设备统计信息获取、启动、停止和过滤设置等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在NOSY_IOC_START操作中，设备可以被重复插入到双向链表中，导致后续移除操作时出现释放后使用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: nosy_ioctl\n- 参数: [struct file *file, unsigned int cmd, unsigned long arg]\n- 调用者: 内核IOCTL处理机制\n- 被调用者: [spin_lock_irq, spin_unlock_irq, copy_to_user, list_add_tail, list_del_init]\n\n2. 函数名: spin_lock_irq\n- 参数: [spinlock_t *lock]\n- 调用者: nosy_ioctl\n- 被调用者: []\n\n3. 函数名: spin_unlock_irq\n- 参数: [spinlock_t *lock]\n- 调用者: nosy_ioctl\n- 被调用者: []\n\n4. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: nosy_ioctl\n- 被调用者: []\n\n5. 函数名: list_add_tail\n- 参数: [struct list_head *new, struct list_head *head]\n- 调用者: nosy_ioctl\n- 被调用者: []\n\n6. 函数名: list_del_init\n- 参数: [struct list_head *entry]\n- 调用者: nosy_ioctl\n- 被调用者: []"
    },
    {
        "id": 3017,
        "cwe": "CWE-416",
        "cve": "CVE-2021-3543",
        "purpose": "Code purpose:\"\"\"处理Nitro Enclaves内核驱动中创建虚拟机并管理相关文件描述符的IOCTL操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在NE_CREATE_VM命令处理中，当copy_to_user失败时，对enclave_file进行了两次fput操作而未检查其是否为NULL，可能导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: ne_ioctl\n- 参数: [struct file *file, unsigned int cmd, unsigned long arg]\n- 调用者: 无（内核驱动接口函数）\n- 被调用者: [mutex_lock, ne_create_vm_ioctl, mutex_unlock, copy_to_user, fget, fput, put_unused_fd]\n\n2. 函数名: mutex_lock\n- 参数: [&ne_pci_dev->enclaves_list_mutex]\n- 调用者: ne_ioctl\n- 被调用者: 无\n\n3. 函数名: ne_create_vm_ioctl\n- 参数: [ne_pci_dev, &slot_uid]\n- 调用者: ne_ioctl\n- 被调用者: 无\n\n4. 函数名: mutex_unlock\n- 参数: [&ne_pci_dev->enclaves_list_mutex]\n- 调用者: ne_ioctl\n- 被调用者: 无\n\n5. 函数名: copy_to_user\n- 参数: [(void __user *)arg, &slot_uid, sizeof(slot_uid)]\n- 调用者: ne_ioctl\n- 被调用者: 无\n\n6. 函数名: fget\n- 参数: [enclave_fd]\n- 调用者: ne_ioctl\n- 被调用者: 无\n\n7. 函数名: fput\n- 参数: [enclave_file]\n- 调用者: ne_ioctl\n- 被调用者: 无\n\n8. 函数名: put_unused_fd\n- 参数: [enclave_fd]\n- 调用者: ne_ioctl\n- 被调用者: 无"
    },
    {
        "id": 3042,
        "cwe": "CWE-416",
        "cve": "CVE-2021-3715",
        "purpose": "Code purpose:\"\"\"该代码用于处理Linux内核流量控制子系统中路由决策分类器的过滤器变更操作，包括创建、修改和删除过滤器，以实现网络流量的分类控制。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在修改路由分类过滤器时未正确处理引用计数，导致释放后重用(use-after-free)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: route4_change\n- 参数: [net, in_skb, tp, base, handle, tca, arg, ovr, rtnl_held, extack]\n- 调用者: 未明确（由内核网络子系统调用）\n- 被调用者: [nla_parse_nested_deprecated, kzalloc, tcf_exts_init, route4_set_parms, rtnl_dereference, tcf_block_netif_keep_dst, rcu_assign_pointer, tcf_unbind_filter, tcf_exts_get_net, tcf_queue_work, tcf_exts_destroy, kfree]\n\n2. 函数名: nla_parse_nested_deprecated\n- 参数: [tb, TCA_ROUTE4_MAX, opt, route4_policy, NULL]\n- 调用者: route4_change\n- 被调用者: 未明确（内核网络属性解析函数）\n\n3. 函数名: kzalloc\n- 参数: [sizeof(struct route4_filter), GFP_KERNEL]\n- 调用者: route4_change\n- 被调用者: 未明确（内核内存分配函数）\n\n4. 函数名: tcf_exts_init\n- 参数: [&f->exts, net, TCA_ROUTE4_ACT, TCA_ROUTE4_POLICE]\n- 调用者: route4_change\n- 被调用者: 未明确（流量控制扩展初始化函数）\n\n5. 函数名: route4_set_parms\n- 参数: [net, tp, base, f, handle, head, tb, tca[TCA_RATE], new, ovr, extack]\n- 调用者: route4_change\n- 被调用者: 未明确（参数设置函数）\n\n6. 函数名: rtnl_dereference\n- 参数: [*fp], [head->table[th]], [*fp]\n- 调用者: route4_change\n- 被调用者: 未明确（RCU解引用函数）\n\n7. 函数名: tcf_block_netif_keep_dst\n- 参数: [tp->chain->block]\n- 调用者: route4_change\n- 被调用者: 未明确（网络接口保持函数）\n\n8. 函数名: rcu_assign_pointer\n- 参数: [f->next, f1], [*fp, f]\n- 调用者: route4_change\n- 被调用者: 未明确（RCU指针赋值函数）\n\n9. 函数名: tcf_unbind_filter\n- 参数: [tp, &fold->res]\n- 调用者: route4_change\n- 被调用者: 未明确（过滤器解绑函数）\n\n10. 函数名: tcf_exts_get_net\n- 参数: [&fold->exts]\n- 调用者: route4_change\n- 被调用者: 未明确（获取网络命名空间函数）\n\n11. 函数名: tcf_queue_work\n- 参数: [&fold->rwork, route4_delete_filter_work]\n- 调用者: route4_change\n- 被调用者: 未明确（工作队列调度函数）\n\n12. 函数名: tcf_exts_destroy\n- 参数: [&f->exts]\n- 调用者: route4_change\n- 被调用者: 未明确（扩展销毁函数）\n\n13. 函数名: kfree\n- 参数: [f]\n- 调用者: route4_change\n- 被调用者: 未明确（内核内存释放函数）"
    },
    {
        "id": 3043,
        "cwe": "CWE-416",
        "cve": "CVE-2021-37159",
        "purpose": "Code purpose:\"\"\"创建一个USB网络设备并进行初始化配置，包括分配资源、设置端点和注册网络设备\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放网络设备时未检查NETREG_REGISTERED状态就调用unregister_netdev，导致use-after-free和双重释放问题\"\"\"",
        "functions": "Functions:\n1. 函数名: hso_create_net_device\n- 参数: [struct usb_interface *interface, int port_spec]\n- 调用者: 未显示\n- 被调用者: [hso_create_device, alloc_netdev, hso_net_init, netdev_priv, hso_get_ep, SET_NETDEV_DEV, SET_NETDEV_DEVTYPE, usb_alloc_urb, kzalloc, add_net_device, register_netdev, hso_log_port, hso_create_rfkill, hso_free_net_device]\n\n2. 函数名: hso_create_device\n- 参数: [struct usb_interface *interface, int port_spec]\n- 调用者: hso_create_net_device\n- 被调用者: 未显示\n\n3. 函数名: hso_net_init\n- 参数: 未显示\n- 调用者: alloc_netdev\n- 被调用者: 未显示\n\n4. 函数名: hso_get_ep\n- 参数: [struct usb_interface *interface, USB_ENDPOINT_XFER_BULK, USB_DIR_IN/USB_DIR_OUT]\n- 调用者: hso_create_net_device\n- 被调用者: 未显示\n\n5. 函数名: usb_alloc_urb\n- 参数: [0, GFP_KERNEL]\n- 调用者: hso_create_net_device\n- 被调用者: 未显示\n\n6. 函数名: kzalloc\n- 参数: [MUX_BULK_RX_BUF_SIZE/MUX_BULK_TX_BUF_SIZE, GFP_KERNEL]\n- 调用者: hso_create_net_device\n- 被调用者: 未显示\n\n7. 函数名: add_net_device\n- 参数: [struct hso_device *hso_dev]\n- 调用者: hso_create_net_device\n- 被调用者: 未显示\n\n8. 函数名: register_netdev\n- 参数: [struct net_device *net]\n- 调用者: hso_create_net_device\n- 被调用者: 未显示\n\n9. 函数名: hso_log_port\n- 参数: [struct hso_device *hso_dev]\n- 调用者: hso_create_net_device\n- 被调用者: 未显示\n\n10. 函数名: hso_create_rfkill\n- 参数: [struct hso_device *hso_dev, struct usb_interface *interface]\n- 调用者: hso_create_net_device\n- 被调用者: 未显示\n\n11. 函数名: hso_free_net_device\n- 参数: [struct hso_device *hso_dev, bool]\n- 调用者: hso_create_net_device\n- 被调用者: 未显示"
    },
    {
        "id": 3065,
        "cwe": "CWE-416",
        "cve": "CVE-2021-3760",
        "purpose": "Code purpose:\"\"\"处理NCI核心连接关闭响应，释放相关连接信息并完成请求\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放conn_info后未将其指针置空，导致后续可能发生对已释放内存的引用（use-after-free）。\"\"\"",
        "functions": "Functions:\n1. 函数名: nci_core_conn_close_rsp_packet\n- 参数: [ndev, skb]\n- 调用者: 未明确（由NFC协议栈调用）\n- 被调用者: [nci_get_conn_info_by_conn_id, list_del, devm_kfree, nci_req_complete, pr_debug]\n\n2. 函数名: nci_get_conn_info_by_conn_id\n- 参数: [ndev, ndev->cur_conn_id]\n- 调用者: nci_core_conn_close_rsp_packet\n- 被调用者: 未明确\n\n3. 函数名: list_del\n- 参数: [&conn_info->list]\n- 调用者: nci_core_conn_close_rsp_packet\n- 被调用者: 未明确\n\n4. 函数名: devm_kfree\n- 参数: [&ndev->nfc_dev->dev, conn_info]\n- 调用者: nci_core_conn_close_rsp_packet\n- 被调用者: 未明确\n\n5. 函数名: nci_req_complete\n- 参数: [ndev, status]\n- 调用者: nci_core_conn_close_rsp_packet\n- 被调用者: 未明确\n\n6. 函数名: pr_debug\n- 参数: [\"status 0x%x\\n\", status]\n- 调用者: nci_core_conn_close_rsp_packet\n- 被调用者: 未明确"
    },
    {
        "id": 3079,
        "cwe": "CWE-416",
        "cve": "CVE-2021-38204",
        "purpose": "Code purpose:\"\"\"该代码用于在MAX-3421 USB主机控制器驱动中选择和启动USB请求块(URB)进行数据传输\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在移除MAX-3421 USB设备时，由于未正确处理锁和资源释放，导致在特定情况下发生use-after-free错误。\"\"\"",
        "functions": "Functions:\n1. 函数名: max3421_select_and_start_urb\n- 参数: [struct usb_hcd *hcd]\n- 调用者: 未显示\n- 被调用者: [to_spi_device, hcd_to_max3421, list_for_each, container_of, usb_endpoint_type, list_empty, list_first_entry, dev_dbg, frame_diff, list_move_tail, usb_endpoint_num, usb_endpoint_xfer_control, usb_settoggle, max3421_set_address, max3421_set_speed, max3421_next_transfer]\n\n2. 函数名: to_spi_device\n- 参数: [hcd->self.controller]\n- 调用者: max3421_select_and_start_urb\n- 被调用者: 未显示\n\n3. 函数名: hcd_to_max3421\n- 参数: [hcd]\n- 调用者: max3421_select_and_start_urb\n- 被调用者: 未显示\n\n4. 函数名: list_for_each\n- 参数: [pos, &max3421_hcd->ep_list]\n- 调用者: max3421_select_and_start_urb\n- 被调用者: 未显示\n\n5. 函数名: container_of\n- 参数: [pos, struct max3421_ep, ep_list]\n- 调用者: max3421_select_and_start_urb\n- 被调用者: 未显示\n\n6. 函数名: usb_endpoint_type\n- 参数: [&ep->desc]\n- 调用者: max3421_select_and_start_urb\n- 被调用者: 未显示\n\n7. 函数名: list_empty\n- 参数: [&ep->urb_list]\n- 调用者: max3421_select_and_start_urb\n- 被调用者: 未显示\n\n8. 函数名: list_first_entry\n- 参数: [&ep->urb_list, struct urb, urb_list]\n- 调用者: max3421_select_and_start_urb\n- 被调用者: 未显示\n\n9. 函数名: dev_dbg\n- 参数: [&spi->dev, \"%s: URB %p unlinked=%d\", __func__, urb, urb->unlinked]\n- 调用者: max3421_select_and_start_urb\n- 被调用者: 未显示\n\n10. 函数名: frame_diff\n- 参数: [max3421_ep->last_active, max3421_hcd->frame_number]\n- 调用者: max3421_select_and_start_urb\n- 被调用者: 未显示\n\n11. 函数名: list_move_tail\n- 参数: [pos, &max3421_hcd->ep_list]\n- 调用者: max3421_select_and_start_urb\n- 被调用者: 未显示\n\n12. 函数名: usb_endpoint_num\n- 参数: [&urb->ep->desc]\n- 调用者: max3421_select_and_start_urb\n- 被调用者: 未显示\n\n13. 函数名: usb_endpoint_xfer_control\n- 参数: [&ep->desc]\n- 调用者: max3421_select_and_start_urb\n- 被调用者: 未显示\n\n14. 函数名: usb_settoggle\n- 参数: [urb->dev, epnum, 0, 1]\n- 调用者: max3421_select_and_start_urb\n- 被调用者: 未显示\n\n15. 函数名: max3421_set_address\n- 参数: [hcd, urb->dev, epnum, force_toggles]\n- 调用者: max3421_select_and_start_urb\n- 被调用者: 未显示\n\n16. 函数名: max3421_set_speed\n- 参数: [hcd, urb->dev]\n- 调用者: max3421_select_and_start_urb\n- 被调用者: 未显示\n\n17. 函数名: max3421_next_transfer\n- 参数: [hcd, 0]\n- 调用者: max3421_select_and_start_urb\n- 被调用者: 未显示"
    },
    {
        "id": 3080,
        "cwe": "CWE-416",
        "cve": "CVE-2021-38204",
        "purpose": "Code purpose:\"\"\"处理MAX-3421 USB主机控制器完成URB(USB请求块)后的清理和回调工作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在移除MAX-3421 USB设备时，由于未正确处理当前URB（USB Request Block）的引用计数，导致在设备移除后可能发生use-after-free情况。\"\"\"",
        "functions": "Functions:\n1. 函数名: max3421_urb_done\n- 参数: [struct usb_hcd *hcd]\n- 调用者: 未明确显示（应为内核USB子系统调用）\n- 被调用者: [hcd_to_max3421, spin_lock_irqsave, usb_hcd_unlink_urb_from_ep, spin_unlock_irqrestore, usb_hcd_giveback_urb]\n\n2. 函数名: hcd_to_max3421\n- 参数: [struct usb_hcd *hcd]\n- 调用者: max3421_urb_done\n- 被调用者: []\n\n3. 函数名: spin_lock_irqsave\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: max3421_urb_done\n- 被调用者: []\n\n4. 函数名: usb_hcd_unlink_urb_from_ep\n- 参数: [struct usb_hcd *hcd, struct urb *urb]\n- 调用者: max3421_urb_done\n- 被调用者: []\n\n5. 函数名: spin_unlock_irqrestore\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: max3421_urb_done\n- 被调用者: []\n\n6. 函数名: usb_hcd_giveback_urb\n- 参数: [struct usb_hcd *hcd, struct urb *urb, int status]\n- 调用者: max3421_urb_done\n- 被调用者: []"
    },
    {
        "id": 3092,
        "cwe": "CWE-416",
        "cve": "CVE-2021-39634",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中epoll机制的事件插入功能，用于监控文件描述符上的事件并通知用户空间程序。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在epoll的实现中，当错误处理路径中释放epitem结构体后，仍可能被后续操作访问，导致释放后重用(use-after-free)。\"\"\"",
        "functions": "Functions:\n1. 函数名: ep_insert\n- 参数: [struct eventpoll *ep, const struct epoll_event *event, struct file *tfile, int fd, int full_check]\n- 调用者: 未明确（通常是epoll系统调用的实现）\n- 被调用者: [atomic_long_read, kmem_cache_alloc, INIT_LIST_HEAD, ep_set_ffd, ep_create_wakeup_source, RCU_INIT_POINTER, init_poll_funcptr, ep_item_poll, spin_lock, list_add_tail_rcu, spin_unlock, ep_rbtree_insert, reverse_path_check, write_lock_irq, ep_set_busy_poll_napi_id, ep_is_linked, list_add_tail, ep_pm_stay_awake, waitqueue_active, wake_up, write_unlock_irq, atomic_long_inc, ep_poll_safewake, list_del_rcu, rb_erase_cached, ep_unregister_pollwait, list_del_init, wakeup_source_unregister, ep_wakeup_source, kmem_cache_free]\n\n2. 函数名: atomic_long_read\n- 参数: [&ep->user->epoll_watches]\n- 调用者: ep_insert\n- 被调用者: []\n\n3. 函数名: kmem_cache_alloc\n- 参数: [epi_cache, GFP_KERNEL]\n- 调用者: ep_insert\n- 被调用者: []\n\n4. 函数名: INIT_LIST_HEAD\n- 参数: [&epi->rdllink], [&epi->fllink], [&epi->pwqlist]\n- 调用者: ep_insert\n- 被调用者: []\n\n5. 函数名: ep_set_ffd\n- 参数: [&epi->ffd, tfile, fd]\n- 调用者: ep_insert\n- 被调用者: []\n\n6. 函数名: ep_create_wakeup_source\n- 参数: [epi]\n- 调用者: ep_insert\n- 被调用者: []\n\n7. 函数名: RCU_INIT_POINTER\n- 参数: [epi->ws, NULL]\n- 调用者: ep_insert\n- 被调用者: []\n\n8. 函数名: init_poll_funcptr\n- 参数: [&epq.pt, ep_ptable_queue_proc]\n- 调用者: ep_insert\n- 被调用者: []\n\n9. 函数名: ep_item_poll\n- 参数: [epi, &epq.pt, 1]\n- 调用者: ep_insert\n- 被调用者: []\n\n10. 函数名: spin_lock\n- 参数: [&tfile->f_lock]\n- 调用者: ep_insert\n- 被调用者: []\n\n11. 函数名: list_add_tail_rcu\n- 参数: [&epi->fllink, &tfile->f_ep_links]\n- 调用者: ep_insert\n- 被调用者: []\n\n12. 函数名: spin_unlock\n- 参数: [&tfile->f_lock]\n- 调用者: ep_insert\n- 被调用者: []\n\n13. 函数名: ep_rbtree_insert\n- 参数: [ep, epi]\n- 调用者: ep_insert\n- 被调用者: []\n\n14. 函数名: reverse_path_check\n- 参数: []\n- 调用者: ep_insert\n- 被调用者: []\n\n15. 函数名: write_lock_irq\n- 参数: [&ep->lock]\n- 调用者: ep_insert\n- 被调用者: []\n\n16. 函数名: ep_set_busy_poll_napi_id\n- 参数: [epi]\n- 调用者: ep_insert\n- 被调用者: []\n\n17. 函数名: ep_is_linked\n- 参数: [epi]\n- 调用者: ep_insert\n- 被调用者: []\n\n18. 函数名: list_add_tail\n- 参数: [&epi->rdllink, &ep->rdllist]\n- 调用者: ep_insert\n- 被调用者: []\n\n19. 函数名: ep_pm_stay_awake\n- 参数: [epi]\n- 调用者: ep_insert\n- 被调用者: []\n\n20. 函数名: waitqueue_active\n- 参数: [&ep->wq], [&ep->poll_wait]\n- 调用者: ep_insert\n- 被调用者: []\n\n21. 函数名: wake_up\n- 参数: [&ep->wq]\n- 调用者: ep_insert\n- 被调用者: []\n\n22. 函数名: write_unlock_irq\n- 参数: [&ep->lock]\n- 调用者: ep_insert\n- 被调用者: []\n\n23. 函数名: atomic_long_inc\n- 参数: [&ep->user->epoll_watches]\n- 调用者: ep_insert\n- 被调用者: []\n\n24. 函数名: ep_poll_safewake\n- 参数: [ep, NULL]\n- 调用者: ep_insert\n- 被调用者: []\n\n25. 函数名: list_del_rcu\n- 参数: [&epi->fllink]\n- 调用者: ep_insert\n- 被调用者: []\n\n26. 函数名: rb_erase_cached\n- 参数: [&epi->rbn, &ep->rbr]\n- 调用者: ep_insert\n- 被调用者: []\n\n27. 函数名: ep_unregister_pollwait\n- 参数: [ep, epi]\n- 调用者: ep_insert\n- 被调用者: []\n\n28. 函数名: list_del_init\n- 参数: [&epi->rdllink]\n- 调用者: ep_insert\n- 被调用者: []\n\n29. 函数名: wakeup_source_unregister\n- 参数: [ep_wakeup_source(epi)]\n- 调用者: ep_insert\n- 被调用者: []\n\n30. 函数名: ep_wakeup_source\n- 参数: [epi]\n- 调用者: ep_insert\n- 被调用者: []\n\n31. 函数名: kmem_cache_free\n- 参数: [epi_cache, epi]\n- 调用者: ep_insert\n- 被调用者: []"
    },
    {
        "id": 3094,
        "cwe": "CWE-416",
        "cve": "CVE-2021-39656",
        "purpose": "Code purpose:\"\"\"该代码用于处理configfs文件系统中文件的打开操作，包括权限检查、属性设置和缓冲区分配等，以实现对配置项的读写访问。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在__configfs_open_file函数中，由于不恰当的锁管理导致可能发生use-after-free情况\"\"\"",
        "functions": "Functions:\n1. 函数名: __configfs_open_file\n- 参数: [struct inode *inode, struct file *file, int type]\n- 调用者: (未在代码片段中显示)\n- 被调用者: [kzalloc, down_read, up_read, to_item, to_attr, to_bin_attr, try_module_get, module_put, config_item_put, kfree, mutex_init]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(struct configfs_buffer), GFP_KERNEL]\n- 调用者: __configfs_open_file\n- 被调用者: (内核内存分配函数)\n\n3. 函数名: down_read\n- 参数: [&frag->frag_sem]\n- 调用者: __configfs_open_file\n- 被调用者: (内核同步原语)\n\n4. 函数名: up_read\n- 参数: [&frag->frag_sem]\n- 调用者: __configfs_open_file\n- 被调用者: (内核同步原语)\n\n5. 函数名: to_item\n- 参数: [dentry->d_parent]\n- 调用者: __configfs_open_file\n- 被调用者: (未在代码片段中显示)\n\n6. 函数名: to_attr\n- 参数: [dentry]\n- 调用者: __configfs_open_file\n- 被调用者: (未在代码片段中显示)\n\n7. 函数名: to_bin_attr\n- 参数: [dentry]\n- 调用者: __configfs_open_file\n- 被调用者: (未在代码片段中显示)\n\n8. 函数名: try_module_get\n- 参数: [buffer->owner]\n- 调用者: __configfs_open_file\n- 被调用者: (内核模块引用计数函数)\n\n9. 函数名: module_put\n- 参数: [buffer->owner]\n- 调用者: __configfs_open_file\n- 被调用者: (内核模块引用计数函数)\n\n10. 函数名: config_item_put\n- 参数: [buffer->item]\n- 调用者: __configfs_open_file\n- 被调用者: (未在代码片段中显示)\n\n11. 函数名: kfree\n- 参数: [buffer]\n- 调用者: __configfs_open_file\n- 被调用者: (内核内存释放函数)\n\n12. 函数名: mutex_init\n- 参数: [&buffer->mutex]\n- 调用者: __configfs_open_file\n- 被调用者: (内核互斥锁初始化函数)"
    },
    {
        "id": 3108,
        "cwe": "CWE-416",
        "cve": "CVE-2021-39800",
        "purpose": "Code purpose:\"\"\"该代码实现了Android内核中ION内存管理子系统的ioctl接口，用于处理内存分配、释放、共享等操作的控制命令。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ion_ioctl函数中存在释放后使用(use-after-free)问题，导致可能泄露内核头部数据\"\"\"",
        "functions": "Functions:\n1. 函数名: ion_ioctl\n- 参数: [struct file *filp, unsigned int cmd, unsigned long arg]\n- 调用者: 无（系统调用接口）\n- 被调用者: [ion_ioctl_dir, _IOC_SIZE, copy_from_user, validate_ioctl_arg, memset, ion_alloc, PTR_ERR, ion_handle_get_by_id_nolock, ion_free_nolock, ion_handle_put_nolock, ion_share_dma_buf_fd_nolock, ion_import_dma_buf_fd, ion_sync_for_device, ion_query_heaps, copy_to_user, ion_free]\n\n2. 函数名: ion_ioctl_dir\n- 参数: [unsigned int cmd]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n3. 函数名: _IOC_SIZE\n- 参数: [unsigned int cmd]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n4. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n5. 函数名: validate_ioctl_arg\n- 参数: [unsigned int cmd, union ion_ioctl_arg *data]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n6. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n7. 函数名: ion_alloc\n- 参数: [struct ion_client *client, size_t len, size_t align, unsigned int heap_id_mask, unsigned int flags]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n8. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n9. 函数名: ion_handle_get_by_id_nolock\n- 参数: [struct ion_client *client, int id]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n10. 函数名: ion_free_nolock\n- 参数: [struct ion_client *client, struct ion_handle *handle]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n11. 函数名: ion_handle_put_nolock\n- 参数: [struct ion_handle *handle]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n12. 函数名: ion_share_dma_buf_fd_nolock\n- 参数: [struct ion_client *client, struct ion_handle *handle]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n13. 函数名: ion_import_dma_buf_fd\n- 参数: [struct ion_client *client, int fd]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n14. 函数名: ion_sync_for_device\n- 参数: [struct ion_client *client, int fd]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n15. 函数名: ion_query_heaps\n- 参数: [struct ion_client *client, struct ion_heap_query *query]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n16. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n17. 函数名: ion_free\n- 参数: [struct ion_client *client, struct ion_handle *handle]\n- 调用者: ion_ioctl\n- 被调用者: 无"
    },
    {
        "id": 3109,
        "cwe": "CWE-416",
        "cve": "CVE-2021-39800",
        "purpose": "Code purpose:\"\"\"该代码用于在Android内核中分配ION内存缓冲区，处理客户端的请求并返回对应的内存句柄\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在ion_alloc函数中存在对ion_buffer_create创建的buffer对象在ion_handle_create后立即释放，可能导致后续操作中对已释放buffer的引用，造成use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ion_alloc\n- 参数: [client, len, align, heap_id_mask, flags]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [PAGE_ALIGN, down_read, plist_for_each_entry, ion_buffer_create, up_read, IS_ERR, ERR_CAST, ion_handle_create, ion_buffer_put, mutex_lock, ion_handle_add, mutex_unlock, ion_handle_put, ERR_PTR]\n\n2. 函数名: ion_buffer_create\n- 参数: [heap, dev, len, align, flags]\n- 调用者: ion_alloc\n- 被调用者: 未显示（假设是内部实现）\n\n3. 函数名: ion_handle_create\n- 参数: [client, buffer]\n- 调用者: ion_alloc\n- 被调用者: 未显示（假设是内部实现）\n\n4. 函数名: ion_buffer_put\n- 参数: [buffer]\n- 调用者: ion_alloc\n- 被调用者: 未显示（假设是内部实现）\n\n5. 函数名: ion_handle_add\n- 参数: [client, handle]\n- 调用者: ion_alloc\n- 被调用者: 未显示（假设是内部实现）\n\n6. 函数名: ion_handle_put\n- 参数: [handle]\n- 调用者: ion_alloc\n- 被调用者: 未显示（假设是内部实现）"
    },
    {
        "id": 3110,
        "cwe": "CWE-416",
        "cve": "CVE-2021-39801",
        "purpose": "Code purpose:\"\"\"该代码实现了Android内核中ION内存管理子系统的ioctl接口，用于处理内存分配、释放、共享等操作的控制命令。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ion_ioctl函数中，由于对cleanup_handle的处理缺乏适当的锁保护，可能导致在释放后仍被使用的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: ion_ioctl\n- 参数: [struct file *filp, unsigned int cmd, unsigned long arg]\n- 调用者: 无（系统调用接口）\n- 被调用者: [ion_ioctl_dir, _IOC_SIZE, copy_from_user, validate_ioctl_arg, memset, ion_alloc, PTR_ERR, ion_handle_get_by_id_nolock, ion_free_nolock, ion_handle_put_nolock, ion_share_dma_buf_fd_nolock, ion_import_dma_buf_fd, ion_sync_for_device, ion_query_heaps, copy_to_user, ion_free]\n\n2. 函数名: ion_ioctl_dir\n- 参数: [unsigned int cmd]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n3. 函数名: _IOC_SIZE\n- 参数: [unsigned int cmd]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n4. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n5. 函数名: validate_ioctl_arg\n- 参数: [unsigned int cmd, union ion_ioctl_arg *data]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n6. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n7. 函数名: ion_alloc\n- 参数: [struct ion_client *client, size_t len, size_t align, unsigned int heap_id_mask, unsigned int flags]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n8. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n9. 函数名: ion_handle_get_by_id_nolock\n- 参数: [struct ion_client *client, int id]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n10. 函数名: ion_free_nolock\n- 参数: [struct ion_client *client, struct ion_handle *handle]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n11. 函数名: ion_handle_put_nolock\n- 参数: [struct ion_handle *handle]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n12. 函数名: ion_share_dma_buf_fd_nolock\n- 参数: [struct ion_client *client, struct ion_handle *handle]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n13. 函数名: ion_import_dma_buf_fd\n- 参数: [struct ion_client *client, int fd]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n14. 函数名: ion_sync_for_device\n- 参数: [struct ion_client *client, int fd]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n15. 函数名: ion_query_heaps\n- 参数: [struct ion_client *client, struct ion_heap_query *query]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n16. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: ion_ioctl\n- 被调用者: 无\n\n17. 函数名: ion_free\n- 参数: [struct ion_client *client, struct ion_handle *handle]\n- 调用者: ion_ioctl\n- 被调用者: 无"
    },
    {
        "id": 3111,
        "cwe": "CWE-416",
        "cve": "CVE-2021-39801",
        "purpose": "Code purpose:\"\"\"该代码用于在Android内核中为客户端分配ION内存缓冲区，处理不同堆的优先级选择并返回内存句柄\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ion_ioctl中由于不正确的锁机制导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ion_alloc\n- 参数: [client, len, align, heap_id_mask, flags]\n- 调用者: N/A (top-level function)\n- 被调用者: [PAGE_ALIGN, down_read, plist_for_each_entry, ion_buffer_create, up_read, IS_ERR, ERR_CAST, ion_handle_create, ion_buffer_put, mutex_lock, ion_handle_add, mutex_unlock, ion_handle_put, ERR_PTR]\n\n2. 函数名: ion_buffer_create\n- 参数: [heap, dev, len, align, flags]\n- 调用者: ion_alloc\n- 被调用者: N/A (assumed external implementation)\n\n3. 函数名: ion_handle_create\n- 参数: [client, buffer]\n- 调用者: ion_alloc\n- 被调用者: N/A (assumed external implementation)\n\n4. 函数名: ion_buffer_put\n- 参数: [buffer]\n- 调用者: ion_alloc\n- 被调用者: N/A (assumed external implementation)\n\n5. 函数名: ion_handle_add\n- 参数: [client, handle]\n- 调用者: ion_alloc\n- 被调用者: N/A (assumed external implementation)\n\n6. 函数名: ion_handle_put\n- 参数: [handle]\n- 调用者: ion_alloc\n- 被调用者: N/A (assumed external implementation)"
    },
    {
        "id": 3123,
        "cwe": "CWE-416",
        "cve": "CVE-2021-4028",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中RDMA通信管理器监听功能，处理套接字绑定和监听请求，并管理连接状态转换。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在RDMA通信管理器监听器代码中存在释放后使用(UAF)漏洞，由于未正确处理监听状态转换和重用地址检查，导致本地攻击者可利用此漏洞操作已释放的列表元素。\"\"\"",
        "functions": "Functions:\n1. 函数名: rdma_listen\n- 参数: [struct rdma_cm_id *id, int backlog]\n- 调用者: 无（顶级函数）\n- 被调用者: [container_of, cma_comp_exch, rdma_bind_addr, cma_src_addr, WARN_ON, mutex_lock, cma_check_port, mutex_unlock, rdma_cap_ib_cm, cma_ib_listen, rdma_cap_iw_cm, cma_iw_listen, cma_listen_on_all, cma_comp_exch]\n\n2. 函数名: container_of\n- 参数: [ptr, type, member]\n- 调用者: rdma_listen\n- 被调用者: 无\n\n3. 函数名: cma_comp_exch\n- 参数: [struct rdma_id_private *id_priv, old_state, new_state]\n- 调用者: rdma_listen\n- 被调用者: 无\n\n4. 函数名: rdma_bind_addr\n- 参数: [struct rdma_cm_id *id, struct sockaddr *addr]\n- 调用者: rdma_listen\n- 被调用者: 无\n\n5. 函数名: cma_src_addr\n- 参数: [struct rdma_id_private *id_priv]\n- 调用者: rdma_listen\n- 被调用者: 无\n\n6. 函数名: WARN_ON\n- 参数: [condition]\n- 调用者: rdma_listen\n- 被调用者: 无\n\n7. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: rdma_listen\n- 被调用者: 无\n\n8. 函数名: cma_check_port\n- 参数: [struct list_head *bind_list, struct rdma_id_private *id_priv, int port]\n- 调用者: rdma_listen\n- 被调用者: 无\n\n9. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: rdma_listen\n- 被调用者: 无\n\n10. 函数名: rdma_cap_ib_cm\n- 参数: [struct ib_device *device, int port_num]\n- 调用者: rdma_listen\n- 被调用者: 无\n\n11. 函数名: cma_ib_listen\n- 参数: [struct rdma_id_private *id_priv]\n- 调用者: rdma_listen\n- 被调用者: 无\n\n12. 函数名: rdma_cap_iw_cm\n- 参数: [struct ib_device *device, int port_num]\n- 调用者: rdma_listen\n- 被调用者: 无\n\n13. 函数名: cma_iw_listen\n- 参数: [struct rdma_id_private *id_priv, int backlog]\n- 调用者: rdma_listen\n- 被调用者: 无\n\n14. 函数名: cma_listen_on_all\n- 参数: [struct rdma_id_private *id_priv]\n- 调用者: rdma_listen\n- 被调用者: 无"
    },
    {
        "id": 3137,
        "cwe": "CWE-416",
        "cve": "CVE-2021-4154",
        "purpose": "Code purpose:\"\"\"解析cgroup v1文件系统上下文参数并设置相关配置\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在cgroup1_parse_param函数中处理fsconfig系统调用参数时，对param->string指针的管理不当导致释放后重用(UAF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: cgroup1_parse_param\n- 参数: [struct fs_context *fc, struct fs_parameter *param]\n- 调用者: fsconfig syscall\n- 被调用者: [cgroup_fc2context, fs_parse, strcmp, invalf, invalfc, for_each_subsys, cgroup_ssid_enabled, cgroup1_ssid_disabled, isalnum]\n\n2. 函数名: cgroup_fc2context\n- 参数: [struct fs_context *fc]\n- 调用者: cgroup1_parse_param\n- 被调用者: []\n\n3. 函数名: fs_parse\n- 参数: [struct fs_context *fc, cgroup1_fs_parameters, struct fs_parameter *param, struct fs_parse_result *result]\n- 调用者: cgroup1_parse_param\n- 被调用者: []\n\n4. 函数名: strcmp\n- 参数: [const char *str1, const char *str2]\n- 调用者: cgroup1_parse_param\n- 被调用者: []\n\n5. 函数名: invalf\n- 参数: [struct fs_context *fc, const char *fmt]\n- 调用者: cgroup1_parse_param\n- 被调用者: []\n\n6. 函数名: invalfc\n- 参数: [struct fs_context *fc, const char *fmt, ...]\n- 调用者: cgroup1_parse_param\n- 被调用者: []\n\n7. 函数名: for_each_subsys\n- 参数: [struct cgroup_subsys *ss, int i]\n- 调用者: cgroup1_parse_param\n- 被调用者: []\n\n8. 函数名: cgroup_ssid_enabled\n- 参数: [int i]\n- 调用者: cgroup1_parse_param\n- 被调用者: []\n\n9. 函数名: cgroup1_ssid_disabled\n- 参数: [int i]\n- 调用者: cgroup1_parse_param\n- 被调用者: []\n\n10. 函数名: isalnum\n- 参数: [int c]\n- 调用者: cgroup1_parse_param\n- 被调用者: []"
    },
    {
        "id": 3145,
        "cwe": "CWE-416",
        "cve": "CVE-2021-4202",
        "purpose": "Code purpose:\"\"\"该代码用于在NFC控制器接口(NCI)中序列化处理请求，确保在设备可用时安全执行请求操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在设备被移除时，nci_request函数未能正确处理数据竞争条件，导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nci_request\n- 参数: [struct nci_dev *ndev, void (*req)(struct nci_dev *ndev, const void *opt), const void *opt, __u32 timeout]\n- 调用者: 未指定\n- 被调用者: [test_bit, mutex_lock, __nci_request, mutex_unlock]\n\n2. 函数名: req\n- 参数: [struct nci_dev *ndev, const void *opt]\n- 调用者: __nci_request\n- 被调用者: 未指定\n\n3. 函数名: test_bit\n- 参数: [NCI_UP, &ndev->flags]\n- 调用者: nci_request\n- 被调用者: 未指定\n\n4. 函数名: mutex_lock\n- 参数: [&ndev->req_lock]\n- 调用者: nci_request\n- 被调用者: 未指定\n\n5. 函数名: __nci_request\n- 参数: [struct nci_dev *ndev, void (*req)(struct nci_dev *ndev, const void *opt), const void *opt, __u32 timeout]\n- 调用者: nci_request\n- 被调用者: [req]\n\n6. 函数名: mutex_unlock\n- 参数: [&ndev->req_lock]\n- 调用者: nci_request\n- 被调用者: 未指定"
    },
    {
        "id": 3159,
        "cwe": "CWE-416",
        "cve": "CVE-2021-43057",
        "purpose": "Code purpose:\"\"\"该代码用于在SELinux环境下检查父进程是否有权限通过ptrace跟踪当前进程\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在访问另一个任务的主观凭证时存在竞态条件，导致释放后使用(UAF)漏洞，可能引发内存损坏和权限提升\"\"\"",
        "functions": "Functions:\n1. 函数名: selinux_ptrace_traceme\n- 参数: [struct task_struct *parent]\n- 调用者: 未显示（由内核调用）\n- 被调用者: [avc_has_perm, task_sid_subj, task_sid_obj]\n\n2. 函数名: avc_has_perm\n- 参数: [&selinux_state, task_sid_subj(parent), task_sid_obj(current), SECCLASS_PROCESS, PROCESS__PTRACE, NULL]\n- 调用者: selinux_ptrace_traceme\n- 被调用者: []\n\n3. 函数名: task_sid_subj\n- 参数: [struct task_struct *parent]\n- 调用者: selinux_ptrace_traceme\n- 被调用者: []\n\n4. 函数名: task_sid_obj\n- 参数: [current]\n- 调用者: selinux_ptrace_traceme\n- 被调用者: []"
    },
    {
        "id": 3160,
        "cwe": "CWE-416",
        "cve": "CVE-2021-43057",
        "purpose": "Code purpose:\"\"\"该代码实现了SELinux对消息队列接收操作的权限检查功能，验证目标任务是否有权限从指定消息队列读取消息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在访问另一个任务的主观凭证时未正确处理引用计数，导致释放后重用(UAF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: selinux_msg_queue_msgrcv\n- 参数: [struct kern_ipc_perm *msq, struct msg_msg *msg, struct task_struct *target, long type, int mode]\n- 调用者: 未显示\n- 被调用者: [task_sid_subj, selinux_ipc, selinux_msg_msg, avc_has_perm]\n\n2. 函数名: task_sid_subj\n- 参数: [struct task_struct *target]\n- 调用者: selinux_msg_queue_msgrcv\n- 被调用者: 未显示\n\n3. 函数名: selinux_ipc\n- 参数: [struct kern_ipc_perm *msq]\n- 调用者: selinux_msg_queue_msgrcv\n- 被调用者: 未显示\n\n4. 函数名: selinux_msg_msg\n- 参数: [struct msg_msg *msg]\n- 调用者: selinux_msg_queue_msgrcv\n- 被调用者: 未显示\n\n5. 函数名: avc_has_perm\n- 参数: [struct selinux_state *, u32 sid, u32 sid, u16 secclass, u32 perms, struct common_audit_data *ad]\n- 调用者: selinux_msg_queue_msgrcv\n- 被调用者: 未显示"
    },
    {
        "id": 3161,
        "cwe": "CWE-416",
        "cve": "CVE-2021-43057",
        "purpose": "Code purpose:\"\"\"该代码片段实现了Smack安全模块中获取进程属性的功能，主要是复制当前任务的Smack标签字符串并返回其长度。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在访问另一个任务的主观凭证时未正确处理内存引用，导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: smack_getprocattr\n- 参数: [struct task_struct *p, char *name, char **value]\n- 调用者: 未明确（由内核调用）\n- 被调用者: [strcmp, kstrdup, strlen]\n\n2. 函数名: strcmp\n- 参数: [const char *s1, const char *s2]\n- 调用者: smack_getprocattr\n- 被调用者: []\n\n3. 函数名: kstrdup\n- 参数: [const char *s, gfp_t gfp]\n- 调用者: smack_getprocattr\n- 被调用者: []\n\n4. 函数名: strlen\n- 参数: [const char *s]\n- 调用者: smack_getprocattr\n- 被调用者: []"
    },
    {
        "id": 3162,
        "cwe": "CWE-416",
        "cve": "CVE-2021-43057",
        "purpose": "Code purpose:\"\"\"该代码片段实现了对任务结构体进行安全检查，验证当前任务是否有权限访问指定任务的安全标记(Smack)信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在访问另一个任务的主观凭证时存在释放后使用问题，导致内存损坏和权限提升漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: smk_curacc_on_task\n- 参数: [struct task_struct *p, int access, const char *caller]\n- 调用者: 未显示\n- 被调用者: [smk_of_task_struct_subj, smk_ad_init, smk_ad_setfield_u_tsk, smk_curacc, smk_bu_task]\n\n2. 函数名: smk_of_task_struct_subj\n- 参数: [struct task_struct *p]\n- 调用者: smk_curacc_on_task\n- 被调用者: 未显示\n\n3. 函数名: smk_ad_init\n- 参数: [struct smk_audit_info *ad, const char *caller, int LSM_AUDIT_DATA_TASK]\n- 调用者: smk_curacc_on_task\n- 被调用者: 未显示\n\n4. 函数名: smk_ad_setfield_u_tsk\n- 参数: [struct smk_audit_info *ad, struct task_struct *p]\n- 调用者: smk_curacc_on_task\n- 被调用者: 未显示\n\n5. 函数名: smk_curacc\n- 参数: [struct smack_known *skp, int access, struct smk_audit_info *ad]\n- 调用者: smk_curacc_on_task\n- 被调用者: 未显示\n\n6. 函数名: smk_bu_task\n- 参数: [struct task_struct *p, int access, int rc]\n- 调用者: smk_curacc_on_task\n- 被调用者: 未显示"
    },
    {
        "id": 3183,
        "cwe": "CWE-416",
        "cve": "CVE-2021-45868",
        "purpose": "Code purpose:\"\"\"该代码用于递归删除配额树中的节点，并处理相关的磁盘块释放和写入操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未验证从磁盘读取的配额树中的块号，可能导致使用已释放的内存\"\"\"",
        "functions": "Functions:\n1. 函数名: remove_tree\n- 参数: [struct qtree_mem_dqinfo *info, struct dquot *dquot, uint *blk, int depth]\n- 调用者: 未明确（可能是外部调用或递归调用）\n- 被调用者: [read_blk, free_dqentry, remove_tree, put_free_dqblk, write_blk, kfree]\n\n2. 函数名: read_blk\n- 参数: [struct qtree_mem_dqinfo *info, uint blk, char *buf]\n- 调用者: remove_tree\n- 被调用者: 未明确\n\n3. 函数名: free_dqentry\n- 参数: [struct qtree_mem_dqinfo *info, struct dquot *dquot, uint blk]\n- 调用者: remove_tree\n- 被调用者: 未明确\n\n4. 函数名: put_free_dqblk\n- 参数: [struct qtree_mem_dqinfo *info, char *buf, uint blk]\n- 调用者: remove_tree\n- 被调用者: 未明确\n\n5. 函数名: write_blk\n- 参数: [struct qtree_mem_dqinfo *info, uint blk, char *buf]\n- 调用者: remove_tree\n- 被调用者: 未明确\n\n6. 函数名: kfree\n- 参数: [void *buf]\n- 调用者: remove_tree\n- 被调用者: 未明确\n\n7. 函数名: quota_error\n- 参数: [struct super_block *sb, const char *fmt, ...]\n- 调用者: remove_tree\n- 被调用者: 未明确\n\n8. 函数名: get_index\n- 参数: [struct qtree_mem_dqinfo *info, qid_t id, int depth]\n- 调用者: remove_tree\n- 被调用者: 未明确\n\n9. 函数名: le32_to_cpu\n- 参数: [__le32 val]\n- 调用者: remove_tree\n- 被调用者: 未明确\n\n10. 函数名: cpu_to_le32\n- 参数: [uint32_t val]\n- 调用者: remove_tree\n- 被调用者: 未明确"
    },
    {
        "id": 3184,
        "cwe": "CWE-416",
        "cve": "CVE-2021-45868",
        "purpose": "Code purpose:\"\"\"在配额树中查找指定配额条目的位置\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未验证从磁盘读取的配额树块号的有效性，可能导致后续操作中使用已释放的内存\"\"\"",
        "functions": "Functions:\n1. 函数名: find_tree_dqentry\n- 参数: [struct qtree_mem_dqinfo *info, struct dquot *dquot, uint blk, int depth]\n- 调用者: 未明确（可能是外部调用或递归调用）\n- 被调用者: [read_blk, quota_error, le32_to_cpu, get_index, find_tree_dqentry, find_block_dqentry, kfree]\n\n2. 函数名: read_blk\n- 参数: [struct qtree_mem_dqinfo *info, uint blk, char *buf]\n- 调用者: find_tree_dqentry\n- 被调用者: 未明确\n\n3. 函数名: quota_error\n- 参数: [struct super_block *dq_sb, const char *fmt, ...]\n- 调用者: find_tree_dqentry\n- 被调用者: 未明确\n\n4. 函数名: le32_to_cpu\n- 参数: [__le32]\n- 调用者: find_tree_dqentry\n- 被调用者: 未明确\n\n5. 函数名: get_index\n- 参数: [struct qtree_mem_dqinfo *info, uint dq_id, int depth]\n- 调用者: find_tree_dqentry\n- 被调用者: 未明确\n\n6. 函数名: find_block_dqentry\n- 参数: [struct qtree_mem_dqinfo *info, struct dquot *dquot, uint blk]\n- 调用者: find_tree_dqentry\n- 被调用者: 未明确\n\n7. 函数名: kfree\n- 参数: [void *buf]\n- 调用者: find_tree_dqentry\n- 被调用者: 未明确"
    },
    {
        "id": 3210,
        "cwe": "CWE-416",
        "cve": "CVE-2022-0487",
        "purpose": "Code purpose:\"\"\"该代码实现了在移除MOXA ART平台设备时，释放相关DMA通道、移除MMC主机并重置硬件寄存器的功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放host资源后仍然访问了host->base指针，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: moxart_remove\n- 参数: [struct platform_device *pdev]\n- 调用者: 未显示（通常由平台驱动框架调用）\n- 被调用者: [dev_get_drvdata, mmc_priv, dev_set_drvdata, IS_ERR_OR_NULL, dma_release_channel, mmc_remove_host, mmc_free_host, writel, readl]\n\n2. 函数名: dev_get_drvdata\n- 参数: [struct device *dev]\n- 调用者: moxart_remove\n- 被调用者: 无显示（内核API）\n\n3. 函数名: mmc_priv\n- 参数: [struct mmc_host *mmc]\n- 调用者: moxart_remove\n- 被调用者: 无显示（内核MMC子系统API）\n\n4. 函数名: dev_set_drvdata\n- 参数: [struct device *dev, void *data]\n- 调用者: moxart_remove\n- 被调用者: 无显示（内核API）\n\n5. 函数名: IS_ERR_OR_NULL\n- 参数: [const void *ptr]\n- 调用者: moxart_remove\n- 被调用者: 无显示（内核错误处理宏）\n\n6. 函数名: dma_release_channel\n- 参数: [struct dma_chan *chan]\n- 调用者: moxart_remove\n- 被调用者: 无显示（内核DMA子系统API）\n\n7. 函数名: mmc_remove_host\n- 参数: [struct mmc_host *mmc]\n- 调用者: moxart_remove\n- 被调用者: 无显示（内核MMC子系统API）\n\n8. 函数名: mmc_free_host\n- 参数: [struct mmc_host *mmc]\n- 调用者: moxart_remove\n- 被调用者: 无显示（内核MMC子系统API）\n\n9. 函数名: writel\n- 参数: [u32 value, volatile void __iomem *addr]\n- 调用者: moxart_remove\n- 被调用者: 无显示（内核I/O操作函数）\n\n10. 函数名: readl\n- 参数: [volatile void __iomem *addr]\n- 调用者: moxart_remove\n- 被调用者: 无显示（内核I/O操作函数）"
    },
    {
        "id": 3217,
        "cwe": "CWE-416",
        "cve": "CVE-2022-0646",
        "purpose": "Code purpose:\"\"\"关闭MCTP串行通信设备并释放相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在关闭MCTP串行设备时，先调用了unregister_netdev释放了网络设备资源，之后又调用了cancel_work_sync尝试取消可能引用已释放资源的工作队列，导致了释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: mctp_serial_close\n- 参数: [tty]\n- 调用者: 未明确（应为Linux内核中调用tty关闭操作的代码）\n- 被调用者: [unregister_netdev, cancel_work_sync, ida_free]\n\n2. 函数名: unregister_netdev\n- 参数: [dev->netdev]\n- 调用者: mctp_serial_close\n- 被调用者: []\n\n3. 函数名: cancel_work_sync\n- 参数: [&dev->tx_work]\n- 调用者: mctp_serial_close\n- 被调用者: []\n\n4. 函数名: ida_free\n- 参数: [&mctp_serial_ida, idx]\n- 调用者: mctp_serial_close\n- 被调用者: []"
    },
    {
        "id": 3230,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1011",
        "purpose": "Code purpose:\"\"\"该代码用于在FUSE文件系统中处理页面数据的复制操作，包括页面清零、数据填充和缓存刷新等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在FUSE文件系统中处理write()操作时，由于未正确管理页面引用计数导致释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: fuse_copy_page\n- 参数: [struct fuse_copy_state *cs, struct page **pagep, unsigned offset, unsigned count, int zeroing]\n- 调用者: (未在代码片段中显示)\n- 被调用者: [clear_highpage, fuse_ref_page, fuse_try_move_page, fuse_copy_fill, kmap_local_page, kunmap_local, fuse_copy_do, flush_dcache_page]\n\n2. 函数名: clear_highpage\n- 参数: [struct page *page]\n- 调用者: fuse_copy_page\n- 被调用者: (未在代码片段中显示)\n\n3. 函数名: fuse_ref_page\n- 参数: [struct fuse_copy_state *cs, struct page *page, unsigned offset, unsigned count]\n- 调用者: fuse_copy_page\n- 被调用者: (未在代码片段中显示)\n\n4. 函数名: fuse_try_move_page\n- 参数: [struct fuse_copy_state *cs, struct page **pagep]\n- 调用者: fuse_copy_page\n- 被调用者: (未在代码片段中显示)\n\n5. 函数名: fuse_copy_fill\n- 参数: [struct fuse_copy_state *cs]\n- 调用者: fuse_copy_page\n- 被调用者: (未在代码片段中显示)\n\n6. 函数名: kmap_local_page\n- 参数: [struct page *page]\n- 调用者: fuse_copy_page\n- 被调用者: (未在代码片段中显示)\n\n7. 函数名: kunmap_local\n- 参数: [void *mapaddr]\n- 调用者: fuse_copy_page\n- 被调用者: (未在代码片段中显示)\n\n8. 函数名: fuse_copy_do\n- 参数: [struct fuse_copy_state *cs, void **buf, unsigned *count]\n- 调用者: fuse_copy_page\n- 被调用者: (未在代码片段中显示)\n\n9. 函数名: flush_dcache_page\n- 参数: [struct page *page]\n- 调用者: fuse_copy_page\n- 被调用者: (未在代码片段中显示)"
    },
    {
        "id": 3231,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1011",
        "purpose": "Code purpose:\"\"\"该代码用于处理FUSE文件系统中用户空间与内核空间之间的页面数据传输，包括获取用户空间页面并准备在内核中使用\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在FUSE文件系统中处理用户空间内存地址时，未正确管理内存生命周期，导致在write操作后可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: fuse_get_user_pages\n- 参数: [struct fuse_args_pages *ap, struct iov_iter *ii, size_t *nbytesp, int write, unsigned int max_pages]\n- 调用者: 未显示\n- 被调用者: [iov_iter_is_kvec, fuse_get_user_addr, fuse_get_frag_size, iov_iter_advance, iov_iter_get_pages, DIV_ROUND_UP, fuse_page_descs_length_init]\n\n2. 函数名: iov_iter_is_kvec\n- 参数: [struct iov_iter *ii]\n- 调用者: fuse_get_user_pages\n- 被调用者: 未显示\n\n3. 函数名: fuse_get_user_addr\n- 参数: [struct iov_iter *ii]\n- 调用者: fuse_get_user_pages\n- 被调用者: 未显示\n\n4. 函数名: fuse_get_frag_size\n- 参数: [struct iov_iter *ii, size_t *nbytesp]\n- 调用者: fuse_get_user_pages\n- 被调用者: 未显示\n\n5. 函数名: iov_iter_advance\n- 参数: [struct iov_iter *ii, size_t frag_size]\n- 调用者: fuse_get_user_pages\n- 被调用者: 未显示\n\n6. 函数名: iov_iter_get_pages\n- 参数: [struct iov_iter *ii, &ap->pages[ap->num_pages], *nbytesp - nbytes, max_pages - ap->num_pages, &start]\n- 调用者: fuse_get_user_pages\n- 被调用者: 未显示\n\n7. 函数名: DIV_ROUND_UP\n- 参数: [ret, PAGE_SIZE]\n- 调用者: fuse_get_user_pages\n- 被调用者: 未显示\n\n8. 函数名: fuse_page_descs_length_init\n- 参数: [ap->descs, ap->num_pages, npages]\n- 调用者: fuse_get_user_pages\n- 被调用者: 未显示"
    },
    {
        "id": 3241,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1043",
        "purpose": "Code purpose:\"\"\"该代码用于在io_uring实现中注册当前进程的凭证到personalities数组中，并返回分配的ID\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_register_personality函数中，当xa_alloc_cyclic分配失败时，对creds引用的释放操作put_cred(creds)可能引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_register_personality\n- 参数: [struct io_ring_ctx *ctx]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [get_current_cred, xa_alloc_cyclic, put_cred]\n\n2. 函数名: get_current_cred\n- 参数: []\n- 调用者: io_register_personality\n- 被调用者: []\n\n3. 函数名: xa_alloc_cyclic\n- 参数: [&ctx->personalities, &id, (void *)creds, XA_LIMIT(0, USHRT_MAX), &ctx->pers_next, GFP_KERNEL]\n- 调用者: io_register_personality\n- 被调用者: []\n\n4. 函数名: put_cred\n- 参数: [const struct cred *creds]\n- 调用者: io_register_personality\n- 被调用者: []"
    },
    {
        "id": 3242,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1048",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核声音子系统中处理PCM子流的附加操作，包括子流分配、资源初始化和状态管理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ALSA PCM子系统中，由于对PCM hw_params的并发调用处理不当，导致存在释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_pcm_attach_substream\n- 参数: [struct snd_pcm *pcm, int stream, struct file *file, struct snd_pcm_substream **rsubstream]\n- 调用者: N/A\n- 被调用者: [snd_BUG_ON, snd_ctl_get_preferred_subdevice, SUBSTREAM_BUSY, kzalloc, alloc_pages_exact, memset, free_pages_exact, init_waitqueue_head, get_pid, task_pid]\n\n2. 函数名: snd_BUG_ON\n- 参数: [condition]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: N/A\n\n3. 函数名: snd_ctl_get_preferred_subdevice\n- 参数: [struct snd_card *card, int type]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: N/A\n\n4. 函数名: SUBSTREAM_BUSY\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: N/A\n\n5. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: N/A\n\n6. 函数名: alloc_pages_exact\n- 参数: [size_t size, gfp_t gfp_mask]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: N/A\n\n7. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: N/A\n\n8. 函数名: free_pages_exact\n- 参数: [void *virt, size_t size]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: N/A\n\n9. 函数名: init_waitqueue_head\n- 参数: [wait_queue_head_t *q]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: N/A\n\n10. 函数名: get_pid\n- 参数: [struct pid *pid]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: N/A\n\n11. 函数名: task_pid\n- 参数: [struct task_struct *task]\n- 调用者: snd_pcm_attach_substream\n- 被调用者: N/A"
    },
    {
        "id": 3243,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1048",
        "purpose": "Code purpose:\"\"\"释放PCM子流相关资源并清理运行时状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放PCM子流运行时资源时，由于缺乏适当的同步机制，导致存在竞争条件可能引发释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_pcm_detach_substream\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: 未明确（外部调用）\n- 被调用者: [PCM_RUNTIME_CHECK, free_pages_exact, kfree, spin_lock_irq, spin_unlock_irq, put_pid]\n\n2. 函数名: PCM_RUNTIME_CHECK\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_detach_substream\n- 被调用者: 未明确（可能为宏或内联函数）\n\n3. 函数名: free_pages_exact\n- 参数: [void *addr, size_t size]\n- 调用者: snd_pcm_detach_substream\n- 被调用者: 未明确（内核函数）\n\n4. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: snd_pcm_detach_substream\n- 被调用者: 未明确（内核函数）\n\n5. 函数名: spin_lock_irq\n- 参数: [spinlock_t *lock]\n- 调用者: snd_pcm_detach_substream\n- 被调用者: 未明确（内核函数）\n\n6. 函数名: spin_unlock_irq\n- 参数: [spinlock_t *lock]\n- 调用者: snd_pcm_detach_substream\n- 被调用者: 未明确（内核函数）\n\n7. 函数名: put_pid\n- 参数: [struct pid *pid]\n- 调用者: snd_pcm_detach_substream\n- 被调用者: 未明确（内核函数）"
    },
    {
        "id": 3244,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1048",
        "purpose": "Code purpose:\"\"\"释放PCM子流硬件资源并将状态设置为OPEN\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ALSA PCM子系统中，由于对PCM hw_params的并发调用处理不当，导致在释放硬件资源后仍可能被使用，从而引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_pcm_hw_free\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: 外部调用（如ioctl等）\n- 被调用者: [PCM_RUNTIME_CHECK, snd_pcm_stream_lock_irq, snd_pcm_stream_unlock_irq, atomic_read, do_hw_free, snd_pcm_set_state, cpu_latency_qos_remove_request]\n\n2. 函数名: PCM_RUNTIME_CHECK\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_hw_free\n- 被调用者: []\n\n3. 函数名: snd_pcm_stream_lock_irq\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_hw_free\n- 被调用者: []\n\n4. 函数名: snd_pcm_stream_unlock_irq\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_hw_free\n- 被调用者: []\n\n5. 函数名: atomic_read\n- 参数: [&substream->mmap_count]\n- 调用者: snd_pcm_hw_free\n- 被调用者: []\n\n6. 函数名: do_hw_free\n- 参数: [struct snd_pcm_substream *substream]\n- 调用者: snd_pcm_hw_free\n- 被调用者: []\n\n7. 函数名: snd_pcm_set_state\n- 参数: [struct snd_pcm_substream *substream, SNDRV_PCM_STATE_OPEN]\n- 调用者: snd_pcm_hw_free\n- 被调用者: []\n\n8. 函数名: cpu_latency_qos_remove_request\n- 参数: [&substream->latency_pm_qos_req]\n- 调用者: snd_pcm_hw_free\n- 被调用者: []"
    },
    {
        "id": 3245,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1048",
        "purpose": "Code purpose:\"\"\"该代码用于处理PCM子流的硬件参数设置，包括参数验证、缓冲区分配、状态转换等操作，是Linux内核声音子系统的一部分。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核声音子系统中，PCM hw_params的并发调用导致释放后使用漏洞，当用户触发hw_free ioctls或其他ioctls的竞争条件时，可能造成系统崩溃或权限提升。\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_pcm_hw_params\n- 参数: [substream, params]\n- 调用者: N/A\n- 被调用者: [PCM_RUNTIME_CHECK, snd_pcm_stream_lock_irq, snd_pcm_stream_unlock_irq, atomic_read, snd_pcm_sync_stop, snd_pcm_hw_refine, snd_pcm_hw_params_choose, fixup_unreferenced_params, snd_pcm_lib_malloc_pages, memset, snd_pcm_timer_resolution_change, snd_pcm_set_state, cpu_latency_qos_request_active, cpu_latency_qos_remove_request, period_to_usecs, cpu_latency_qos_add_request, snd_pcm_lib_free_pages]\n\n2. 函数名: PCM_RUNTIME_CHECK\n- 参数: [substream]\n- 调用者: snd_pcm_hw_params\n- 被调用者: N/A\n\n3. 函数名: snd_pcm_stream_lock_irq\n- 参数: [substream]\n- 调用者: snd_pcm_hw_params\n- 被调用者: N/A\n\n4. 函数名: snd_pcm_stream_unlock_irq\n- 参数: [substream]\n- 调用者: snd_pcm_hw_params\n- 被调用者: N/A\n\n5. 函数名: atomic_read\n- 参数: [&substream->mmap_count]\n- 调用者: snd_pcm_hw_params\n- 被调用者: N/A\n\n6. 函数名: snd_pcm_sync_stop\n- 参数: [substream, true]\n- 调用者: snd_pcm_hw_params\n- 被调用者: N/A\n\n7. 函数名: snd_pcm_hw_refine\n- 参数: [substream, params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: N/A\n\n8. 函数名: snd_pcm_hw_params_choose\n- 参数: [substream, params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: N/A\n\n9. 函数名: fixup_unreferenced_params\n- 参数: [substream, params]\n- 调用者: snd_pcm_hw_params\n- 被调用者: N/A\n\n10. 函数名: snd_pcm_lib_malloc_pages\n- 参数: [substream, params_buffer_bytes(params)]\n- 调用者: snd_pcm_hw_params\n- 被调用者: N/A\n\n11. 函数名: memset\n- 参数: [runtime->dma_area, 0, size]\n- 调用者: snd_pcm_hw_params\n- 被调用者: N/A\n\n12. 函数名: snd_pcm_timer_resolution_change\n- 参数: [substream]\n- 调用者: snd_pcm_hw_params\n- 被调用者: N/A\n\n13. 函数名: snd_pcm_set_state\n- 参数: [substream, SNDRV_PCM_STATE_SETUP/SNDRV_PCM_STATE_OPEN]\n- 调用者: snd_pcm_hw_params\n- 被调用者: N/A\n\n14. 函数名: cpu_latency_qos_request_active\n- 参数: [&substream->latency_pm_qos_req]\n- 调用者: snd_pcm_hw_params\n- 被调用者: N/A\n\n15. 函数名: cpu_latency_qos_remove_request\n- 参数: [&substream->latency_pm_qos_req]\n- 调用者: snd_pcm_hw_params\n- 被调用者: N/A\n\n16. 函数名: period_to_usecs\n- 参数: [runtime]\n- 调用者: snd_pcm_hw_params\n- 被调用者: N/A\n\n17. 函数名: cpu_latency_qos_add_request\n- 参数: [&substream->latency_pm_qos_req, usecs]\n- 调用者: snd_pcm_hw_params\n- 被调用者: N/A\n\n18. 函数名: snd_pcm_lib_free_pages\n- 参数: [substream]\n- 调用者: snd_pcm_hw_params\n- 被调用者: N/A"
    },
    {
        "id": 3246,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1055",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中流量控制(TC)子系统的链管理功能，包括创建、删除和查询过滤链，并处理相关的网络控制消息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在tc_ctl_chain函数中，对tcf_chain对象的引用计数管理不当，可能导致在释放后仍被使用的情况，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: tc_ctl_chain\n- 参数: [skb, n, extack]\n- 调用者: 无（顶级函数）\n- 被调用者: [sock_net, nlmsg_parse_deprecated, nlmsg_data, tcf_block_find, nla_get_u32, mutex_lock, tcf_chain_lookup, tcf_chain_held_by_acts_only, tcf_chain_hold, tcf_chain_create, mutex_unlock, tc_chain_tmplt_add, tc_chain_notify, tfilter_notify_chain, tcf_chain_flush, tcf_chain_put_explicitly_created, tcf_chain_put, tcf_block_release]\n\n2. 函数名: sock_net\n- 参数: [skb->sk]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n3. 函数名: nlmsg_parse_deprecated\n- 参数: [n, sizeof(*t), tca, TCA_MAX, rtm_tca_policy, extack]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n4. 函数名: nlmsg_data\n- 参数: [n]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n5. 函数名: tcf_block_find\n- 参数: [net, &q, &parent, &cl, t->tcm_ifindex, t->tcm_block_index, extack]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n6. 函数名: nla_get_u32\n- 参数: [tca[TCA_CHAIN]]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n7. 函数名: mutex_lock\n- 参数: [&block->lock]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n8. 函数名: tcf_chain_lookup\n- 参数: [block, chain_index]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n9. 函数名: tcf_chain_held_by_acts_only\n- 参数: [chain]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n10. 函数名: tcf_chain_hold\n- 参数: [chain]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n11. 函数名: tcf_chain_create\n- 参数: [block, chain_index]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n12. 函数名: mutex_unlock\n- 参数: [&block->lock]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n13. 函数名: tc_chain_tmplt_add\n- 参数: [chain, net, tca, extack]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n14. 函数名: tc_chain_notify\n- 参数: [chain, NULL, 0, NLM_F_CREATE | NLM_F_EXCL, RTM_NEWCHAIN, false] 和 [chain, skb, n->nlmsg_seq, n->nlmsg_flags, n->nlmsg_type, true]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n15. 函数名: tfilter_notify_chain\n- 参数: [net, skb, block, q, parent, n, chain, RTM_DELTFILTER]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n16. 函数名: tcf_chain_flush\n- 参数: [chain, true]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n17. 函数名: tcf_chain_put_explicitly_created\n- 参数: [chain]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n18. 函数名: tcf_chain_put\n- 参数: [chain]\n- 调用者: tc_ctl_chain\n- 被调用者: 无\n\n19. 函数名: tcf_block_release\n- 参数: [q, block, true]\n- 调用者: tc_ctl_chain\n- 被调用者: 无"
    },
    {
        "id": 3247,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1055",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中流量控制(TC)子系统的新过滤器创建功能，处理网络过滤器的添加、修改和通知等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在tc_new_tfilter函数中，由于对chain和tp对象的引用计数管理不当，可能导致在并发操作中出现释放后重用(use-after-free)的情况。\"\"\"",
        "functions": "Functions:\n1. 函数名: tc_new_tfilter\n- 参数: [struct sk_buff *skb, struct nlmsghdr *n, struct netlink_ext_ack *extack]\n- 调用者: 无（内核回调函数）\n- 被调用者: [sock_net, netlink_ns_capable, nlmsg_parse_deprecated, nlmsg_data, __tcf_qdisc_find, tcf_proto_check_kind, rtnl_lock, __tcf_qdisc_cl_find, __tcf_block_find, tcf_chain_get, mutex_lock, tcf_chain_tp_find, tcf_auto_prio, tcf_chain_tp_prev, mutex_unlock, tcf_proto_create, tcf_chain_tp_insert_unique, nla_strcmp, tfilter_put, tfilter_notify, tcf_chain_tp_delete_empty, tcf_proto_put, tcf_chain_put, tcf_block_release, rtnl_unlock]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n3. 函数名: netlink_ns_capable\n- 参数: [struct sk_buff *skb, struct user_namespace *ns, int cap]\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n4. 函数名: nlmsg_parse_deprecated\n- 参数: [struct nlmsghdr *nlh, int hdrlen, struct nlattr *tb[], int maxtype, const struct nla_policy *policy, struct netlink_ext_ack *extack]\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n5. 函数名: nlmsg_data\n- 参数: [const struct nlmsghdr *nlh]\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n6. 函数名: __tcf_qdisc_find\n- 参数: [struct net *net, struct Qdisc **q, u32 *parent, int ifindex, bool rtnl_held, struct netlink_ext_ack *extack]\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n7. 函数名: tcf_proto_check_kind\n- 参数: [struct nlattr *kind, char *name]\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n8. 函数名: rtnl_lock\n- 参数: []\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n9. 函数名: __tcf_qdisc_cl_find\n- 参数: [struct Qdisc *q, u32 parent, unsigned long *cl, int ifindex, struct netlink_ext_ack *extack]\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n10. 函数名: __tcf_block_find\n- 参数: [struct net *net, struct Qdisc *q, unsigned long cl, int ifindex, u32 block_index, struct netlink_ext_ack *extack]\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n11. 函数名: tcf_chain_get\n- 参数: [struct tcf_block *block, u32 chain_index, bool create]\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n12. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n13. 函数名: tcf_chain_tp_find\n- 参数: [struct tcf_chain *chain, struct tcf_chain_info *chain_info, u32 protocol, u32 prio, bool prio_allocate]\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n14. 函数名: tcf_auto_prio\n- 参数: [struct tcf_proto *tp]\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n15. 函数名: tcf_chain_tp_prev\n- 参数: [struct tcf_chain *chain, struct tcf_chain_info *chain_info]\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n16. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n17. 函数名: tcf_proto_create\n- 参数: [char *name, u32 protocol, u32 prio, struct tcf_chain *chain, bool rtnl_held, struct netlink_ext_ack *extack]\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n18. 函数名: tcf_chain_tp_insert_unique\n- 参数: [struct tcf_chain *chain, struct tcf_proto *tp_new, u32 protocol, u32 prio, bool rtnl_held]\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n19. 函数名: nla_strcmp\n- 参数: [struct nlattr *nla, const char *str]\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n20. 函数名: tfilter_put\n- 参数: [struct tcf_proto *tp, void *fh]\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n21. 函数名: tfilter_notify\n- 参数: [struct net *net, struct sk_buff *oskb, struct nlmsghdr *n, struct tcf_proto *tp, struct tcf_block *block, struct Qdisc *q, u32 parent, void *fh, int event, bool rtnl_held, bool unicast]\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n22. 函数名: tcf_chain_tp_delete_empty\n- 参数: [struct tcf_chain *chain, struct tcf_proto *tp, bool rtnl_held, struct netlink_ext_ack *extack]\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n23. 函数名: tcf_proto_put\n- 参数: [struct tcf_proto *tp, bool rtnl_held, struct netlink_ext_ack *extack]\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n24. 函数名: tcf_chain_put\n- 参数: [struct tcf_chain *chain]\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n25. 函数名: tcf_block_release\n- 参数: [struct Qdisc *q, struct tcf_block *block, bool rtnl_held]\n- 调用者: tc_new_tfilter\n- 被调用者: 无\n\n26. 函数名: rtnl_unlock\n- 参数: []\n- 调用者: tc_new_tfilter\n- 被调用者: 无"
    },
    {
        "id": 3250,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1158",
        "purpose": "Code purpose:\"\"\"该代码用于在KVM虚拟化环境中原子性地比较并交换客户机的页表项，但存在用户可控参数导致越界写入的安全漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在计算页框号(pfn)时错误地使用了用户可控的vaddr和vm_pgoff作为偏移量，导致可能越界写入内核内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: FNAME(cmpxchg_gpte)\n- 参数: [vcpu, mmu, ptep_user, index, orig_pte, new_pte]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [get_user_pages_fast, kmap_atomic, CMPXCHG, kunmap_atomic, kvm_release_page_dirty, mmap_read_lock, find_vma_intersection, mmap_read_unlock, memremap, memunmap]\n\n2. 函数名: get_user_pages_fast\n- 参数: [(unsigned long)ptep_user, 1, FOLL_WRITE, &page]\n- 调用者: FNAME(cmpxchg_gpte)\n- 被调用者: 未明确（系统/内核函数）\n\n3. 函数名: kmap_atomic\n- 参数: [page]\n- 调用者: FNAME(cmpxchg_gpte)\n- 被调用者: 未明确（系统/内核函数）\n\n4. 函数名: CMPXCHG\n- 参数: [&table[index], orig_pte, new_pte]\n- 调用者: FNAME(cmpxchg_gpte)\n- 被调用者: 未明确（系统/内核函数）\n\n5. 函数名: kunmap_atomic\n- 参数: [table]\n- 调用者: FNAME(cmpxchg_gpte)\n- 被调用者: 未明确（系统/内核函数）\n\n6. 函数名: kvm_release_page_dirty\n- 参数: [page]\n- 调用者: FNAME(cmpxchg_gpte)\n- 被调用者: 未明确（系统/内核函数）\n\n7. 函数名: mmap_read_lock\n- 参数: [current->mm]\n- 调用者: FNAME(cmpxchg_gpte)\n- 被调用者: 未明确（系统/内核函数）\n\n8. 函数名: find_vma_intersection\n- 参数: [current->mm, vaddr, vaddr + PAGE_SIZE]\n- 调用者: FNAME(cmpxchg_gpte)\n- 被调用者: 未明确（系统/内核函数）\n\n9. 函数名: mmap_read_unlock\n- 参数: [current->mm]\n- 调用者: FNAME(cmpxchg_gpte)\n- 被调用者: 未明确（系统/内核函数）\n\n10. 函数名: memremap\n- 参数: [paddr, PAGE_SIZE, MEMREMAP_WB]\n- 调用者: FNAME(cmpxchg_gpte)\n- 被调用者: 未明确（系统/内核函数）\n\n11. 函数名: memunmap\n- 参数: [table]\n- 调用者: FNAME(cmpxchg_gpte)\n- 被调用者: 未明确（系统/内核函数）"
    },
    {
        "id": 3251,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1184",
        "purpose": "Code purpose:\"\"\"该代码实现了ext4文件系统中目录块的分裂操作，用于在目录项插入时处理目录块空间不足的情况，通过重新分配和移动目录项来维护目录结构。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在dx_insert_block()函数中存在释放后重用问题，当处理目录块分割时可能导致对已释放内存的访问，造成拒绝服务。\"\"\"",
        "functions": "Functions:\n1. 函数名: do_split\n- 参数: [handle_t *handle, struct inode *dir, struct buffer_head **bh, struct dx_frame *frame, struct dx_hash_info *hinfo]\n- 调用者: 未显示\n- 被调用者: [ext4_append, brelse, ext4_journal_get_write_access, dx_make_map, dx_sort_map, dx_move_dirents, dx_pack_dirents, ext4_rec_len_to_disk, ext4_initialize_dirent_tail, dx_show_leaf, swap, dx_insert_block, ext4_handle_dirty_dirblock, ext4_handle_dirty_dx_node, ext4_std_error]\n\n2. 函数名: ext4_append\n- 参数: [handle_t *handle, struct inode *dir, ext4_lblk_t *newblock]\n- 调用者: do_split\n- 被调用者: 未显示\n\n3. 函数名: brelse\n- 参数: [struct buffer_head *bh]\n- 调用者: do_split\n- 被调用者: 未显示\n\n4. 函数名: ext4_journal_get_write_access\n- 参数: [handle_t *handle, struct super_block *sb, struct buffer_head *bh, enum ext4_journal_trigger_type type]\n- 调用者: do_split\n- 被调用者: 未显示\n\n5. 函数名: dx_make_map\n- 参数: [struct inode *dir, struct ext4_dir_entry_2 *de, unsigned blocksize, struct dx_hash_info *hinfo, struct dx_map_entry *map]\n- 调用者: do_split\n- 被调用者: 未显示\n\n6. 函数名: dx_sort_map\n- 参数: [struct dx_map_entry *map, unsigned count]\n- 调用者: do_split\n- 被调用者: 未显示\n\n7. 函数名: dx_move_dirents\n- 参数: [struct inode *dir, char *data1, char *data2, struct dx_map_entry *map, unsigned count, unsigned blocksize]\n- 调用者: do_split\n- 被调用者: 未显示\n\n8. 函数名: dx_pack_dirents\n- 参数: [struct inode *dir, char *data1, unsigned blocksize]\n- 调用者: do_split\n- 被调用者: 未显示\n\n9. 函数名: ext4_rec_len_to_disk\n- 参数: [char *start, char *end, unsigned blocksize]\n- 调用者: do_split\n- 被调用者: 未显示\n\n10. 函数名: ext4_initialize_dirent_tail\n- 参数: [struct buffer_head *bh, unsigned blocksize]\n- 调用者: do_split\n- 被调用者: 未显示\n\n11. 函数名: dx_show_leaf\n- 参数: [struct inode *dir, struct dx_hash_info *hinfo, struct ext4_dir_entry_2 *de, unsigned blocksize, int leaf]\n- 调用者: do_split\n- 被调用者: 未显示\n\n12. 函数名: swap\n- 参数: [struct buffer_head **bh, struct buffer_head *bh2]\n- 调用者: do_split\n- 被调用者: 未显示\n\n13. 函数名: dx_insert_block\n- 参数: [struct dx_frame *frame, u32 hash, ext4_lblk_t block]\n- 调用者: do_split\n- 被调用者: 未显示\n\n14. 函数名: ext4_handle_dirty_dirblock\n- 参数: [handle_t *handle, struct inode *dir, struct buffer_head *bh]\n- 调用者: do_split\n- 被调用者: 未显示\n\n15. 函数名: ext4_handle_dirty_dx_node\n- 参数: [handle_t *handle, struct inode *dir, struct buffer_head *bh]\n- 调用者: do_split\n- 被调用者: 未显示\n\n16. 函数名: ext4_std_error\n- 参数: [struct super_block *sb, int err]\n- 调用者: do_split\n- 被调用者: 未显示"
    },
    {
        "id": 3252,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1195",
        "purpose": "Code purpose:\"\"\"该代码用于在MKISS协议实现中关闭TTY设备连接，释放相关网络设备和缓冲区资源，并确保资源安全回收。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在mkiss_close函数中，由于资源释放和引用计数检查的顺序不当，可能导致在引用计数未减至零时就释放了资源，从而引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: mkiss_close\n- 参数: [struct tty_struct *tty]\n- 调用者: 未显示（由tty子系统调用）\n- 被调用者: [write_lock_irq, write_unlock_irq, refcount_dec_and_test, wait_for_completion, netif_stop_queue, unregister_netdev, kfree, free_netdev]\n\n2. 函数名: write_lock_irq\n- 参数: [&disc_data_lock]\n- 调用者: mkiss_close\n- 被调用者: []\n\n3. 函数名: write_unlock_irq\n- 参数: [&disc_data_lock]\n- 调用者: mkiss_close\n- 被调用者: []\n\n4. 函数名: refcount_dec_and_test\n- 参数: [&ax->refcnt]\n- 调用者: mkiss_close\n- 被调用者: []\n\n5. 函数名: wait_for_completion\n- 参数: [&ax->dead]\n- 调用者: mkiss_close\n- 被调用者: []\n\n6. 函数名: netif_stop_queue\n- 参数: [ax->dev]\n- 调用者: mkiss_close\n- 被调用者: []\n\n7. 函数名: unregister_netdev\n- 参数: [ax->dev]\n- 调用者: mkiss_close\n- 被调用者: []\n\n8. 函数名: kfree\n- 参数: [ax->rbuff], [ax->xbuff]\n- 调用者: mkiss_close\n- 被调用者: []\n\n9. 函数名: free_netdev\n- 参数: [ax->dev]\n- 调用者: mkiss_close\n- 被调用者: []"
    },
    {
        "id": 3253,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1198",
        "purpose": "Code purpose:\"\"\"关闭6pack驱动设备的连接并释放相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在sixpack_close函数中，释放sp->dev后未清空指针，导致后续可能访问已释放的内存区域，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: sixpack_close\n- 参数: [struct tty_struct *tty]\n- 调用者: 未显示（通常由TTY子系统调用）\n- 被调用者: [write_lock_irq, write_unlock_irq, refcount_dec_and_test, wait_for_completion, netif_stop_queue, del_timer_sync, unregister_netdev, kfree, free_netdev]\n\n2. 函数名: write_lock_irq\n- 参数: [&disc_data_lock]\n- 调用者: sixpack_close\n- 被调用者: []\n\n3. 函数名: write_unlock_irq\n- 参数: [&disc_data_lock]\n- 调用者: sixpack_close\n- 被调用者: []\n\n4. 函数名: refcount_dec_and_test\n- 参数: [&sp->refcnt]\n- 调用者: sixpack_close\n- 被调用者: []\n\n5. 函数名: wait_for_completion\n- 参数: [&sp->dead]\n- 调用者: sixpack_close\n- 被调用者: []\n\n6. 函数名: netif_stop_queue\n- 参数: [sp->dev]\n- 调用者: sixpack_close\n- 被调用者: []\n\n7. 函数名: del_timer_sync\n- 参数: [&sp->tx_t]\n- 调用者: sixpack_close\n- 被调用者: []\n\n8. 函数名: del_timer_sync\n- 参数: [&sp->resync_t]\n- 调用者: sixpack_close\n- 被调用者: []\n\n9. 函数名: unregister_netdev\n- 参数: [sp->dev]\n- 调用者: sixpack_close\n- 被调用者: []\n\n10. 函数名: kfree\n- 参数: [sp->rbuff]\n- 调用者: sixpack_close\n- 被调用者: []\n\n11. 函数名: kfree\n- 参数: [sp->xbuff]\n- 调用者: sixpack_close\n- 被调用者: []\n\n12. 函数名: free_netdev\n- 参数: [sp->dev]\n- 调用者: sixpack_close\n- 被调用者: []"
    },
    {
        "id": 3254,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1204",
        "purpose": "Code purpose:\"\"\"释放AX.25协议套接字资源并处理不同状态下的连接断开逻辑\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放套接字资源后仍可能访问已被释放的ax25对象，导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ax25_release\n- 参数: [struct socket *sock]\n- 调用者: 无（系统调用或协议栈调用）\n- 被调用者: [sock_hold, sock_orphan, lock_sock, sk_to_ax25, release_sock, ax25_disconnect, ax25_destroy_socket, ax25_send_control, sock_flag, ax25_clear_queues, ax25_stop_t2timer, ax25_stop_t3timer, ax25_stop_idletimer, ax25_calculate_t1, ax25_start_t1timer, sock_set_flag, sock_put]\n\n2. 函数名: sock_hold\n- 参数: [struct sock *sk]\n- 调用者: ax25_release\n- 被调用者: 无\n\n3. 函数名: sock_orphan\n- 参数: [struct sock *sk]\n- 调用者: ax25_release\n- 被调用者: 无\n\n4. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: ax25_release\n- 被调用者: 无\n\n5. 函数名: sk_to_ax25\n- 参数: [struct sock *sk]\n- 调用者: ax25_release\n- 被调用者: 无\n\n6. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: ax25_release\n- 被调用者: 无\n\n7. 函数名: ax25_disconnect\n- 参数: [ax25_cb *ax25, int]\n- 调用者: ax25_release\n- 被调用者: 无\n\n8. 函数名: ax25_destroy_socket\n- 参数: [ax25_cb *ax25]\n- 调用者: ax25_release\n- 被调用者: 无\n\n9. 函数名: ax25_send_control\n- 参数: [ax25_cb *ax25, int, int, int]\n- 调用者: ax25_release\n- 被调用者: 无\n\n10. 函数名: sock_flag\n- 参数: [struct sock *sk, int]\n- 调用者: ax25_release\n- 被调用者: 无\n\n11. 函数名: ax25_clear_queues\n- 参数: [ax25_cb *ax25]\n- 调用者: ax25_release\n- 被调用者: 无\n\n12. 函数名: ax25_stop_t2timer\n- 参数: [ax25_cb *ax25]\n- 调用者: ax25_release\n- 被调用者: 无\n\n13. 函数名: ax25_stop_t3timer\n- 参数: [ax25_cb *ax25]\n- 调用者: ax25_release\n- 被调用者: 无\n\n14. 函数名: ax25_stop_idletimer\n- 参数: [ax25_cb *ax25]\n- 调用者: ax25_release\n- 被调用者: 无\n\n15. 函数名: ax25_calculate_t1\n- 参数: [ax25_cb *ax25]\n- 调用者: ax25_release\n- 被调用者: 无\n\n16. 函数名: ax25_start_t1timer\n- 参数: [ax25_cb *ax25]\n- 调用者: ax25_release\n- 被调用者: 无\n\n17. 函数名: sock_set_flag\n- 参数: [struct sock *sk, int]\n- 调用者: ax25_release\n- 被调用者: 无\n\n18. 函数名: sock_put\n- 参数: [struct sock *sk]\n- 调用者: ax25_release\n- 被调用者: 无"
    },
    {
        "id": 3258,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1280",
        "purpose": "Code purpose:\"\"\"该代码实现了DRM（Direct Rendering Manager）子系统中获取显示连接器信息的核心功能，包括连接器属性、可用编码器和显示模式的查询与复制到用户空间。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在drm_lease_held函数中存在竞态条件问题，导致引用计数管理不当，可能引发释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: drm_mode_getconnector\n- 参数: [struct drm_device *dev, void *data, struct drm_file *file_priv]\n- 调用者: 未显示（系统调用或驱动接口）\n- 被调用者: [drm_core_check_feature, drm_connector_lookup, hweight32, drm_connector_for_each_possible_encoder, put_user, drm_is_current_master, drm_dbg_kms, drm_mode_expose_to_userspace, drm_mode_convert_to_umode, copy_to_user, drm_connector_get_encoder, drm_mode_object_get_properties, drm_connector_put]\n\n2. 函数名: drm_core_check_feature\n- 参数: [struct drm_device *dev, DRIVER_MODESET]\n- 调用者: drm_mode_getconnector\n- 被调用者: 未显示\n\n3. 函数名: drm_connector_lookup\n- 参数: [struct drm_device *dev, struct drm_file *file_priv, out_resp->connector_id]\n- 调用者: drm_mode_getconnector\n- 被调用者: 未显示\n\n4. 函数名: hweight32\n- 参数: [connector->possible_encoders]\n- 调用者: drm_mode_getconnector\n- 被调用者: 未显示\n\n5. 函数名: put_user\n- 参数: [encoder->base.id, encoder_ptr + copied]\n- 调用者: drm_mode_getconnector\n- 被调用者: 未显示\n\n6. 函数名: drm_is_current_master\n- 参数: [file_priv]\n- 调用者: drm_mode_getconnector\n- 被调用者: 未显示\n\n7. 函数名: drm_dbg_kms\n- 参数: [dev, \"User-space requested a forced probe...\", connector->base.id, connector->name]\n- 调用者: drm_mode_getconnector\n- 被调用者: 未显示\n\n8. 函数名: drm_mode_expose_to_userspace\n- 参数: [mode, &connector->modes, file_priv]\n- 调用者: drm_mode_getconnector\n- 被调用者: 未显示\n\n9. 函数名: drm_mode_convert_to_umode\n- 参数: [&u_mode, mode]\n- 调用者: drm_mode_getconnector\n- 被调用者: 未显示\n\n10. 函数名: copy_to_user\n- 参数: [mode_ptr + copied, &u_mode, sizeof(u_mode)]\n- 调用者: drm_mode_getconnector\n- 被调用者: 未显示\n\n11. 函数名: drm_connector_get_encoder\n- 参数: [connector]\n- 调用者: drm_mode_getconnector\n- 被调用者: 未显示\n\n12. 函数名: drm_mode_object_get_properties\n- 参数: [&connector->base, file_priv->atomic, (uint32_t __user *)(unsigned long)(out_resp->props_ptr), (uint64_t __user *)(unsigned long)(out_resp->prop_values_ptr), &out_resp->count_props]\n- 调用者: drm_mode_getconnector\n- 被调用者: 未显示\n\n13. 函数名: drm_connector_put\n- 参数: [connector]\n- 调用者: drm_mode_getconnector\n- 被调用者: 未显示"
    },
    {
        "id": 3259,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1419",
        "purpose": "Code purpose:\"\"\"该代码用于在虚拟图形执行管理器(VGEM)中创建和管理图形内存对象(GEM)，包括对象创建、句柄分配和引用计数管理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于并发操作导致引用计数减少，从而在vgem_gem_dumb_create中访问了已被释放的drm_vgem_gem_object\"\"\"",
        "functions": "Functions:\n1. 函数名: vgem_gem_create\n- 参数: [dev, file, handle, size]\n- 调用者: 未明确（可能是外部调用）\n- 被调用者: [__vgem_gem_create, ERR_CAST, drm_gem_handle_create, drm_gem_object_put_unlocked, ERR_PTR]\n\n2. 函数名: __vgem_gem_create\n- 参数: [dev, size]\n- 调用者: vgem_gem_create\n- 被调用者: 未明确\n\n3. 函数名: ERR_CAST\n- 参数: [obj]\n- 调用者: vgem_gem_create\n- 被调用者: 未明确\n\n4. 函数名: drm_gem_handle_create\n- 参数: [file, &obj->base, handle]\n- 调用者: vgem_gem_create\n- 被调用者: 未明确\n\n5. 函数名: drm_gem_object_put_unlocked\n- 参数: [&obj->base]\n- 调用者: vgem_gem_create\n- 被调用者: 未明确\n\n6. 函数名: ERR_PTR\n- 参数: [ret]\n- 调用者: vgem_gem_create\n- 被调用者: 未明确"
    },
    {
        "id": 3260,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1419",
        "purpose": "Code purpose:\"\"\"该代码用于在虚拟图形执行管理器(vgem)中创建一个哑缓冲区(dumb buffer)对象，并设置其大小和步长(pitch)参数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发操作中，ioctl$DRM_IOCTL_MODE_DESTROY_DUMB会减少drm_vgem_gem_object的引用计数，而vgem_gem_dumb_create可能同时访问已被释放的对象，导致释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: vgem_gem_dumb_create\n- 参数: [file, dev, args]\n- 调用者: 未明确（由DRM框架调用）\n- 被调用者: [DIV_ROUND_UP, vgem_gem_create, IS_ERR, PTR_ERR, DRM_DEBUG]\n\n2. 函数名: DIV_ROUND_UP\n- 参数: [args->bpp, 8]\n- 调用者: vgem_gem_dumb_create\n- 被调用者: []\n\n3. 函数名: vgem_gem_create\n- 参数: [dev, file, &args->handle, size]\n- 调用者: vgem_gem_dumb_create\n- 被调用者: []\n\n4. 函数名: IS_ERR\n- 参数: [gem_object]\n- 调用者: vgem_gem_dumb_create\n- 被调用者: []\n\n5. 函数名: PTR_ERR\n- 参数: [gem_object]\n- 调用者: vgem_gem_dumb_create\n- 被调用者: []\n\n6. 函数名: DRM_DEBUG\n- 参数: [\"Created object of size %lld\\n\", size]\n- 调用者: vgem_gem_dumb_create\n- 被调用者: []"
    },
    {
        "id": 3266,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1652",
        "purpose": "Code purpose:\"\"\"该代码用于处理软盘驱动器的错误计数和相应状态管理，包括错误计数增加、错误阈值判断以及根据错误级别执行重置或重新校准操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于bad_flp_intr函数中存在并发环境下的use-after-free漏洞，导致本地攻击者可通过特制程序执行任意代码\"\"\"",
        "functions": "Functions:\n1. 函数名: bad_flp_intr\n- 参数: []\n- 调用者: 未显示在代码片段中\n- 被调用者: [next_valid_format, INFBOUND, cont->done]\n\n2. 函数名: next_valid_format\n- 参数: [current_drive]\n- 调用者: bad_flp_intr\n- 被调用者: []\n\n3. 函数名: INFBOUND\n- 参数: [write_errors[current_drive].badness, err_count]\n- 调用者: bad_flp_intr\n- 被调用者: []\n\n4. 函数名: cont->done\n- 参数: [0]\n- 调用者: bad_flp_intr\n- 被调用者: []"
    },
    {
        "id": 3267,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1652",
        "purpose": "Code purpose:\"\"\"格式化软盘驱动器并处理格式化请求，包括参数验证和错误处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在bad_flp_intr函数中存在并发情况下的释放后使用(use-after-free)缺陷，导致本地攻击者能够执行任意代码\"\"\"",
        "functions": "Functions:\n1. 函数名: do_format\n- 参数: [drive, tmp_format_req]\n- 调用者: 未显示\n- 被调用者: [lock_fdc, set_floppy, process_fd_request, wait_til_done]\n\n2. 函数名: lock_fdc\n- 参数: [drive]\n- 调用者: do_format\n- 被调用者: 未显示\n\n3. 函数名: set_floppy\n- 参数: [drive]\n- 调用者: do_format\n- 被调用者: 未显示\n\n4. 函数名: process_fd_request\n- 参数: []\n- 调用者: do_format\n- 被调用者: 未显示\n\n5. 函数名: wait_til_done\n- 参数: [redo_format, true]\n- 调用者: do_format\n- 被调用者: 未显示"
    },
    {
        "id": 3268,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1652",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中软盘驱动器的请求处理功能，包括驱动器选择、电机控制、磁盘状态检测和读写请求调度等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在bad_flp_intr函数中存在并发情况下的释放后使用(use-after-free)缺陷，导致本地攻击者可能执行任意代码\"\"\"",
        "functions": "Functions:\n1. 函数名: redo_fd_request\n- 参数: []\n- 调用者: \n- 被调用者: [floppy_off, spin_lock_irq, spin_unlock_irq, set_next_request, unlock_fdc, set_fdc, reschedule_timeout, set_floppy, start_motor, disk_change, test_bit, request_done, next_valid_format, make_raw_rw_request, twaddle, schedule_bh, debugt]\n\n2. 函数名: floppy_off\n- 参数: [current_drive]\n- 调用者: redo_fd_request\n- 被调用者: []\n\n3. 函数名: spin_lock_irq\n- 参数: [&floppy_lock]\n- 调用者: redo_fd_request\n- 被调用者: []\n\n4. 函数名: spin_unlock_irq\n- 参数: [&floppy_lock]\n- 调用者: redo_fd_request\n- 被调用者: []\n\n5. 函数名: set_next_request\n- 参数: []\n- 调用者: redo_fd_request\n- 被调用者: []\n\n6. 函数名: unlock_fdc\n- 参数: []\n- 调用者: redo_fd_request\n- 被调用者: []\n\n7. 函数名: set_fdc\n- 参数: [drive]\n- 调用者: redo_fd_request\n- 被调用者: []\n\n8. 函数名: reschedule_timeout\n- 参数: [current_drive, \"redo fd request\"]\n- 调用者: redo_fd_request\n- 被调用者: []\n\n9. 函数名: set_floppy\n- 参数: [drive]\n- 调用者: redo_fd_request\n- 被调用者: []\n\n10. 函数名: start_motor\n- 参数: [redo_fd_request]\n- 调用者: redo_fd_request\n- 被调用者: []\n\n11. 函数名: disk_change\n- 参数: [current_drive]\n- 调用者: redo_fd_request\n- 被调用者: []\n\n12. 函数名: test_bit\n- 参数: [current_drive, &fake_change], [FD_DISK_CHANGED_BIT, &drive_state[current_drive].flags], [FD_NEED_TWADDLE_BIT, &drive_state[current_drive].flags]\n- 调用者: redo_fd_request\n- 被调用者: []\n\n13. 函数名: request_done\n- 参数: [0], [tmp]\n- 调用者: redo_fd_request\n- 被调用者: []\n\n14. 函数名: next_valid_format\n- 参数: [current_drive]\n- 调用者: redo_fd_request\n- 被调用者: []\n\n15. 函数名: make_raw_rw_request\n- 参数: []\n- 调用者: redo_fd_request\n- 被调用者: []\n\n16. 函数名: twaddle\n- 参数: [current_fdc, current_drive]\n- 调用者: redo_fd_request\n- 被调用者: []\n\n17. 函数名: schedule_bh\n- 参数: [floppy_start]\n- 调用者: redo_fd_request\n- 被调用者: []\n\n18. 函数名: debugt\n- 参数: [__func__, \"queue fd request\"]\n- 调用者: redo_fd_request\n- 被调用者: []"
    },
    {
        "id": 3269,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1652",
        "purpose": "Code purpose:\"\"\"从floppy_reqs链表中获取并移除第一个请求，初始化其错误计数并返回是否存在有效请求的布尔值\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在并发环境下，由于未正确处理请求队列的删除操作，导致在bad_flp_intr函数中可能发生use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: set_next_request\n- 参数: []\n- 调用者: 未明确（可能是外部调用）\n- 被调用者: [list_first_entry_or_null, list_del_init]"
    },
    {
        "id": 3270,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1652",
        "purpose": "Code purpose:\"\"\"处理软盘控制器(FDC)的错误状态并返回相应的错误代码\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在bad_flp_intr函数中存在并发情况下的释放后使用(use-after-free)缺陷，导致本地攻击者可执行任意代码。\"\"\"",
        "functions": "Functions:\n1. 函数名: interpret_errors\n- 参数: []\n- 调用者: 未显示（由外部调用）\n- 被调用者: [DPRINT, clear_bit, cont->done, set_bit, print_errors]\n\n2. 函数名: DPRINT\n- 参数: [字符串参数]\n- 调用者: interpret_errors\n- 被调用者: []\n\n3. 函数名: clear_bit\n- 参数: [FD_DISK_WRITABLE_BIT, &drive_state[current_drive].flags]\n- 调用者: interpret_errors\n- 被调用者: []\n\n4. 函数名: cont->done\n- 参数: [0]\n- 调用者: interpret_errors\n- 被调用者: []\n\n5. 函数名: set_bit\n- 参数: [FD_NEED_TWADDLE_BIT, &drive_state[current_drive].flags]\n- 调用者: interpret_errors\n- 被调用者: []\n\n6. 函数名: print_errors\n- 参数: []\n- 调用者: interpret_errors\n- 被调用者: []\n\n7. 函数名: cont->error\n- 参数: []\n- 调用者: interpret_errors\n- 被调用者: []"
    },
    {
        "id": 3275,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1679",
        "purpose": "Code purpose:\"\"\"该代码用于初始化并探测Atheros无线适配器设备，包括分配硬件资源、初始化服务和设备，处理可能的错误情况。\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ath9k_htc_probe_device函数中，当ath9k_htc_wait_for_target失败时，错误处理路径可能导致已释放的hif_dev结构体被后续操作继续访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ath9k_htc_probe_device\n- 参数: [htc_handle, dev, devid, product, drv_info]\n- 调用者: 未显示\n- 被调用者: [ieee80211_alloc_hw, ath9k_htc_wait_for_target, ath9k_init_wmi, ath9k_init_htc_services, ath9k_init_device, ath9k_stop_wmi, ath9k_hif_usb_dealloc_urbs, ath9k_destroy_wmi, ieee80211_free_hw]\n\n2. 函数名: ieee80211_alloc_hw\n- 参数: [sizeof(struct ath9k_htc_priv), &ath9k_htc_ops]\n- 调用者: ath9k_htc_probe_device\n- 被调用者: 未显示\n\n3. 函数名: ath9k_htc_wait_for_target\n- 参数: [priv]\n- 调用者: ath9k_htc_probe_device\n- 被调用者: 未显示\n\n4. 函数名: ath9k_init_wmi\n- 参数: [priv]\n- 调用者: ath9k_htc_probe_device\n- 被调用者: 未显示\n\n5. 函数名: ath9k_init_htc_services\n- 参数: [priv, devid, drv_info]\n- 调用者: ath9k_htc_probe_device\n- 被调用者: 未显示\n\n6. 函数名: ath9k_init_device\n- 参数: [priv, devid, product, drv_info]\n- 调用者: ath9k_htc_probe_device\n- 被调用者: 未显示\n\n7. 函数名: ath9k_stop_wmi\n- 参数: [priv]\n- 调用者: ath9k_htc_probe_device\n- 被调用者: 未显示\n\n8. 函数名: ath9k_hif_usb_dealloc_urbs\n- 参数: [hif_dev]\n- 调用者: ath9k_htc_probe_device\n- 被调用者: 未显示\n\n9. 函数名: ath9k_destroy_wmi\n- 参数: [priv]\n- 调用者: ath9k_htc_probe_device\n- 被调用者: 未显示\n\n10. 函数名: ieee80211_free_hw\n- 参数: [hw]\n- 调用者: ath9k_htc_probe_device\n- 被调用者: 未显示"
    },
    {
        "id": 3277,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1734",
        "purpose": "Code purpose:\"\"\"该代码用于注销NFC设备并释放相关资源，包括中止正在进行的固件下载、释放GPIO资源、注销NCI设备以及释放内存。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在清理设备注册过程中，由于缺乏同步机制，导致固件下载例程可能访问已被释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: nfcmrvl_nci_unregister_dev\n- 参数: [struct nfcmrvl_private *priv]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [nfcmrvl_fw_dnld_abort, nfcmrvl_fw_dnld_deinit, gpio_is_valid, gpio_free, nci_unregister_device, nci_free_device, kfree]\n\n2. 函数名: nfcmrvl_fw_dnld_abort\n- 参数: [struct nfcmrvl_private *priv]\n- 调用者: nfcmrvl_nci_unregister_dev\n- 被调用者: []\n\n3. 函数名: nfcmrvl_fw_dnld_deinit\n- 参数: [struct nfcmrvl_private *priv]\n- 调用者: nfcmrvl_nci_unregister_dev\n- 被调用者: []\n\n4. 函数名: gpio_is_valid\n- 参数: [int number]\n- 调用者: nfcmrvl_nci_unregister_dev\n- 被调用者: []\n\n5. 函数名: gpio_free\n- 参数: [unsigned gpio]\n- 调用者: nfcmrvl_nci_unregister_dev\n- 被调用者: []\n\n6. 函数名: nci_unregister_device\n- 参数: [struct nci_dev *ndev]\n- 调用者: nfcmrvl_nci_unregister_dev\n- 被调用者: []\n\n7. 函数名: nci_free_device\n- 参数: [struct nci_dev *ndev]\n- 调用者: nfcmrvl_nci_unregister_dev\n- 被调用者: []\n\n8. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: nfcmrvl_nci_unregister_dev\n- 被调用者: []"
    },
    {
        "id": 3278,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1786",
        "purpose": "Code purpose:\"\"\"在io_uring子系统中管理空闲工作线程，将标记为FREE的工作线程添加到空闲列表\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring子系统中，当多个任务在设置了IORING_SETUP_IOPOLL的环上完成提交时，由于释放后使用(use-after-free)导致权限提升或系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: __io_worker_idle\n- 参数: [wqe, worker]\n- 调用者: 未明确（由Linux内核的io_uring子系统调用）\n- 被调用者: [hlist_nulls_add_head_rcu]"
    },
    {
        "id": 3279,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1786",
        "purpose": "Code purpose:\"\"\"该代码用于处理io_uring子系统中IO工作线程的退出流程，包括引用计数管理、状态更新和资源释放。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring子系统中，当使用IORING_SETUP_IOPOLL设置环形队列且多个任务同时完成提交时，由于引用计数管理不当导致释放后重用(use-after-free)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: io_worker_exit\n- 参数: [worker]\n- 调用者: 未明确显示（通常是内核中调用工作线程退出的代码）\n- 被调用者: [io_wqe_get_acct, set_current_state, refcount_dec_and_test, schedule, __set_current_state, preempt_disable, atomic_dec, preempt_enable, raw_spin_lock_irq, hlist_nulls_del_rcu, list_del_rcu, raw_spin_unlock_irq, kfree_rcu, complete]\n\n2. 函数名: io_wqe_get_acct\n- 参数: [worker]\n- 调用者: io_worker_exit\n- 被调用者: []\n\n3. 函数名: set_current_state\n- 参数: [TASK_INTERRUPTIBLE]\n- 调用者: io_worker_exit\n- 被调用者: []\n\n4. 函数名: refcount_dec_and_test\n- 参数: [&worker->ref]\n- 调用者: io_worker_exit\n- 被调用者: []\n\n5. 函数名: schedule\n- 参数: []\n- 调用者: io_worker_exit\n- 被调用者: []\n\n6. 函数名: __set_current_state\n- 参数: [TASK_RUNNING]\n- 调用者: io_worker_exit\n- 被调用者: []\n\n7. 函数名: preempt_disable\n- 参数: []\n- 调用者: io_worker_exit\n- 被调用者: []\n\n8. 函数名: atomic_dec\n- 参数: [&acct->nr_running], [&wqe->wq->user->processes]\n- 调用者: io_worker_exit\n- 被调用者: []\n\n9. 函数名: preempt_enable\n- 参数: []\n- 调用者: io_worker_exit\n- 被调用者: []\n\n10. 函数名: raw_spin_lock_irq\n- 参数: [&wqe->lock]\n- 调用者: io_worker_exit\n- 被调用者: []\n\n11. 函数名: hlist_nulls_del_rcu\n- 参数: [&worker->nulls_node]\n- 调用者: io_worker_exit\n- 被调用者: []\n\n12. 函数名: list_del_rcu\n- 参数: [&worker->all_list]\n- 调用者: io_worker_exit\n- 被调用者: []\n\n13. 函数名: raw_spin_unlock_irq\n- 参数: [&wqe->lock]\n- 调用者: io_worker_exit\n- 被调用者: []\n\n14. 函数名: kfree_rcu\n- 参数: [worker, rcu]\n- 调用者: io_worker_exit\n- 被调用者: []\n\n15. 函数名: complete\n- 参数: [&wqe->wq->done]\n- 调用者: io_worker_exit\n- 被调用者: []"
    },
    {
        "id": 3280,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1786",
        "purpose": "Code purpose:\"\"\"处理io_uring子系统中工作队列的异步I/O任务，包括获取、执行和释放工作任务\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring子系统中，当设置IORING_SETUP_IOPOLL并使用多个任务完成提交时，由于释放后重用（use-after-free）导致权限提升或系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: io_worker_handle_work\n- 参数: [worker]\n- 调用者: N/A\n- 被调用者: [io_get_next_work, __io_worker_busy, wq_list_empty, raw_spin_unlock_irq, io_assign_current_work, io_get_work_hash, wq_next_work, wq->do_work, wq->free_work, io_wq_is_hashed, io_wqe_enqueue, raw_spin_lock_irq]\n\n2. 函数名: io_get_next_work\n- 参数: [wqe]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A\n\n3. 函数名: __io_worker_busy\n- 参数: [wqe, worker, work]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A\n\n4. 函数名: wq_list_empty\n- 参数: [&wqe->work_list]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A\n\n5. 函数名: raw_spin_unlock_irq\n- 参数: [&wqe->lock]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A\n\n6. 函数名: io_assign_current_work\n- 参数: [worker, work]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A\n\n7. 函数名: io_get_work_hash\n- 参数: [work]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A\n\n8. 函数名: wq_next_work\n- 参数: [work]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A\n\n9. 函数名: wq->do_work\n- 参数: [work]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A\n\n10. 函数名: wq->free_work\n- 参数: [work]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A\n\n11. 函数名: io_wq_is_hashed\n- 参数: [linked]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A\n\n12. 函数名: io_wqe_enqueue\n- 参数: [wqe, linked]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A\n\n13. 函数名: raw_spin_lock_irq\n- 参数: [&wqe->lock]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A"
    },
    {
        "id": 3281,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1786",
        "purpose": "Code purpose:\"\"\"该代码用于检查IO请求任务和文件是否匹配，以决定是否取消或继续处理IO请求\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring子系统中，当多个任务在设置了IORING_SETUP_IOPOLL的环上完成提交时，由于未正确处理任务退出(PF_EXITING)状态下的资源访问，导致释放后重用(use-after-free)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_match_task\n- 参数: [head, task, files]\n- 调用者: 未明确（可能是内核中调用该函数的其他部分）\n- 被调用者: [未明确（可能涉及宏展开的io_for_each_link）]\n\n注：由于代码片段中io_for_each_link可能是一个宏定义而非函数调用，且未提供其实现，因此无法确定其是否为被调用函数。其他被调用函数如PF_EXITING标志检查等属于内核内部操作，不属于明确的函数调用。"
    },
    {
        "id": 3282,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1786",
        "purpose": "Code purpose:\"\"\"为异步I/O请求准备相关工作结构，包括设置并发标志和根据文件类型处理工作项哈希或解绑\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring子系统中，当设置IORING_SETUP_IOPOLL标志且多个任务在同一个环上完成提交时，由于不当的内存管理导致了释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_prep_async_work\n- 参数: [struct io_kiocb *req]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [io_req_init_async, io_wq_hash_work]\n\n2. 函数名: io_req_init_async\n- 参数: [struct io_kiocb *req]\n- 调用者: io_prep_async_work\n- 被调用者: []\n\n3. 函数名: io_wq_hash_work\n- 参数: [&req->work, file_inode(req->file)]\n- 调用者: io_prep_async_work\n- 被调用者: []\n\n4. 函数名: file_inode\n- 参数: [req->file]\n- 调用者: io_prep_async_work\n- 被调用者: []"
    },
    {
        "id": 3283,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1786",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的io_uring子系统中展示与任务凭证相关的用户ID、组ID和权限能力信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring子系统中，当使用IORING_SETUP_IOPOLL设置环形队列并有多任务完成提交时，对iod->creds的引用可能导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: io_uring_show_cred\n- 参数: [id, p, data]\n- 调用者: 未明确（由内核调用）\n- 被调用者: [seq_user_ns, seq_printf, seq_put_decimal_ull, from_kuid_munged, from_kgid_munged, seq_puts, seq_put_hex_ll, seq_putc]\n\n2. 函数名: seq_user_ns\n- 参数: [m]\n- 调用者: io_uring_show_cred\n- 被调用者: 未明确\n\n3. 函数名: seq_printf\n- 参数: [m, format, id]\n- 调用者: io_uring_show_cred\n- 被调用者: 未明确\n\n4. 函数名: seq_put_decimal_ull\n- 参数: [m, prefix, value]\n- 调用者: io_uring_show_cred\n- 被调用者: 未明确\n\n5. 函数名: from_kuid_munged\n- 参数: [uns, cred->uid/cred->euid/cred->suid/cred->fsuid]\n- 调用者: io_uring_show_cred\n- 被调用者: 未明确\n\n6. 函数名: from_kgid_munged\n- 参数: [uns, cred->gid/cred->egid/cred->sgid/cred->fsgid/gi->gid[g]]\n- 调用者: io_uring_show_cred\n- 被调用者: 未明确\n\n7. 函数名: seq_puts\n- 参数: [m, string]\n- 调用者: io_uring_show_cred\n- 被调用者: 未明确\n\n8. 函数名: seq_put_hex_ll\n- 参数: [m, NULL, cap.cap[CAP_LAST_U32 - __capi], 8]\n- 调用者: io_uring_show_cred\n- 被调用者: 未明确\n\n9. 函数名: seq_putc\n- 参数: [m, '\\n']\n- 调用者: io_uring_show_cred\n- 被调用者: 未明确"
    },
    {
        "id": 3284,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1786",
        "purpose": "Code purpose:\"\"\"初始化异步IO请求并管理身份引用的引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring子系统中，当多个任务在设置了IORING_SETUP_IOPOLL的环上完成提交时，由于对身份引用的不当管理导致了释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: io_req_init_async\n- 参数: [struct io_kiocb *req]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [__io_req_init_async, refcount_inc]\n\n2. 函数名: __io_req_init_async\n- 参数: [struct io_kiocb *req]\n- 调用者: io_req_init_async\n- 被调用者: 未明确\n\n3. 函数名: refcount_inc\n- 参数: [&req->work.identity->count]\n- 调用者: io_req_init_async\n- 被调用者: 未明确"
    },
    {
        "id": 3285,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1786",
        "purpose": "Code purpose:\"\"\"为任务分配并初始化io_uring任务上下文，包括内存分配、计数器初始化、工作队列设置等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring子系统中，当设置IORING_SETUP_IOPOLL且多个任务在同一个环上完成提交时，由于释放后重用(UAF)导致系统崩溃或权限提升\"\"\"",
        "functions": "Functions:\n1. 函数名: io_uring_alloc_task_context\n- 参数: [task_struct *task, io_ring_ctx *ctx]\n- 调用者: 未显示\n- 被调用者: [kmalloc, percpu_counter_init, kfree, io_init_wq_offload, percpu_counter_destroy, xa_init, init_waitqueue_head, atomic_set, io_init_identity, spin_lock_init, INIT_WQ_LIST, init_task_work]\n\n2. 函数名: kmalloc\n- 参数: [sizeof(*tctx), GFP_KERNEL]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未显示\n\n3. 函数名: percpu_counter_init\n- 参数: [&tctx->inflight, 0, GFP_KERNEL]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未显示\n\n4. 函数名: kfree\n- 参数: [tctx]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未显示\n\n5. 函数名: io_init_wq_offload\n- 参数: [ctx]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未显示\n\n6. 函数名: percpu_counter_destroy\n- 参数: [&tctx->inflight]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未显示\n\n7. 函数名: xa_init\n- 参数: [&tctx->xa]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未显示\n\n8. 函数名: init_waitqueue_head\n- 参数: [&tctx->wait]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未显示\n\n9. 函数名: atomic_set\n- 参数: [&tctx->in_idle, 0]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未显示\n\n10. 函数名: io_init_identity\n- 参数: [&tctx->__identity]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未显示\n\n11. 函数名: spin_lock_init\n- 参数: [&tctx->task_lock]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未显示\n\n12. 函数名: INIT_WQ_LIST\n- 参数: [&tctx->task_list]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未显示\n\n13. 函数名: init_task_work\n- 参数: [&tctx->task_work, tctx_task_work]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未显示"
    },
    {
        "id": 3286,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1786",
        "purpose": "Code purpose:\"\"\"初始化io_uring请求并设置相关参数，包括操作码、标志位、用户数据等，同时进行权限和资源检查\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring子系统中，当多个任务在设置了IORING_SETUP_IOPOLL的环上完成提交时，由于资源释放后仍被使用，导致了释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_init_req\n- 参数: [ctx, req, sqe]\n- 调用者: N/A\n- 被调用者: [READ_ONCE, refcount_set, io_sq_thread_acquire_mm_files, io_check_restriction, idr_find, refcount_inc, __io_req_init_async, get_cred, blk_start_plug, io_file_get]\n\n2. 函数名: READ_ONCE\n- 参数: [variable]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n3. 函数名: refcount_set\n- 参数: [ref, value]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n4. 函数名: io_sq_thread_acquire_mm_files\n- 参数: [ctx, req]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n5. 函数名: io_check_restriction\n- 参数: [ctx, req, sqe_flags]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n6. 函数名: idr_find\n- 参数: [idr, id]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n7. 函数名: refcount_inc\n- 参数: [ref]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n8. 函数名: __io_req_init_async\n- 参数: [req]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n9. 函数名: get_cred\n- 参数: [cred]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n10. 函数名: blk_start_plug\n- 参数: [plug]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n11. 函数名: io_file_get\n- 参数: [state, req, fd, fixed]\n- 调用者: io_init_req\n- 被调用者: N/A"
    },
    {
        "id": 3287,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1786",
        "purpose": "Code purpose:\"\"\"该代码用于在io_uring子系统中注销指定ID的用户身份信息，并释放相关资源。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_unregister_personality函数中，由于对iod对象的引用计数管理不当，可能导致在释放后仍被使用的情况。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_unregister_personality\n- 参数: [struct io_ring_ctx *ctx, unsigned id]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [idr_remove, put_cred, refcount_dec_and_test, kfree]\n\n2. 函数名: idr_remove\n- 参数: [未明确（上下文未提供具体参数）]\n- 调用者: io_unregister_personality\n- 被调用者: 未明确（上下文未提供）\n\n3. 函数名: put_cred\n- 参数: [未明确（上下文未提供具体参数）]\n- 调用者: io_unregister_personality\n- 被调用者: 未明确（上下文未提供）\n\n4. 函数名: refcount_dec_and_test\n- 参数: [未明确（上下文未提供具体参数）]\n- 调用者: io_unregister_personality\n- 被调用者: 未明确（上下文未提供）\n\n5. 函数名: kfree\n- 参数: [未明确（上下文未提供具体参数）]\n- 调用者: io_unregister_personality\n- 被调用者: 未明确（上下文未提供）"
    },
    {
        "id": 3288,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1786",
        "purpose": "Code purpose:\"\"\"释放与任务相关的io_uring资源，包括身份信息和任务上下文\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring子系统中，当多个任务在设置了IORING_SETUP_IOPOLL的环上完成提交时，存在释放后使用(use-after-free)漏洞，导致权限提升或系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: __io_uring_free\n- 参数: [tsk]\n- 调用者: 未明确（可能是内核其他模块）\n- 被调用者: [WARN_ON_ONCE, xa_empty, refcount_read, kfree, percpu_counter_destroy]\n\n2. 函数名: WARN_ON_ONCE\n- 参数: [condition]\n- 调用者: __io_uring_free\n- 被调用者: []\n\n3. 函数名: xa_empty\n- 参数: [&tctx->xa]\n- 调用者: __io_uring_free\n- 被调用者: []\n\n4. 函数名: refcount_read\n- 参数: [&tctx->identity->count]\n- 调用者: __io_uring_free\n- 被调用者: []\n\n5. 函数名: kfree\n- 参数: [tctx->identity], [tctx]\n- 调用者: __io_uring_free\n- 被调用者: []\n\n6. 函数名: percpu_counter_destroy\n- 参数: [&tctx->inflight]\n- 调用者: __io_uring_free\n- 被调用者: []"
    },
    {
        "id": 3289,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1786",
        "purpose": "Code purpose:\"\"\"处理io_uring子系统中异步I/O请求的提交、执行和完成流程，包括权限管理、错误处理和超时控制\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring子系统中，当多个任务在设置了IORING_SETUP_IOPOLL的环上完成提交时，由于对请求对象(req)的生命周期管理不当，导致了释放后重用(UAF)的问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: __io_queue_sqe\n- 参数: [struct io_kiocb *req]\n- 调用者: 未显示\n- 被调用者: [io_prep_linked_timeout, override_creds, io_issue_sqe, revert_creds, io_arm_poll_handler, io_queue_async_work, io_put_req, io_submit_flush_completions, req_set_fail_links, io_req_complete, io_queue_linked_timeout]\n\n2. 函数名: io_prep_linked_timeout\n- 参数: [struct io_kiocb *req]\n- 调用者: __io_queue_sqe\n- 被调用者: 未显示\n\n3. 函数名: override_creds\n- 参数: [const struct cred *new]\n- 调用者: __io_queue_sqe\n- 被调用者: 未显示\n\n4. 函数名: io_issue_sqe\n- 参数: [struct io_kiocb *req, int flags]\n- 调用者: __io_queue_sqe\n- 被调用者: 未显示\n\n5. 函数名: revert_creds\n- 参数: [const struct cred *old]\n- 调用者: __io_queue_sqe\n- 被调用者: 未显示\n\n6. 函数名: io_arm_poll_handler\n- 参数: [struct io_kiocb *req]\n- 调用者: __io_queue_sqe\n- 被调用者: 未显示\n\n7. 函数名: io_queue_async_work\n- 参数: [struct io_kiocb *req]\n- 调用者: __io_queue_sqe\n- 被调用者: 未显示\n\n8. 函数名: io_put_req\n- 参数: [struct io_kiocb *req]\n- 调用者: __io_queue_sqe\n- 被调用者: 未显示\n\n9. 函数名: io_submit_flush_completions\n- 参数: [struct io_comp_state *cs, struct io_ring_ctx *ctx]\n- 调用者: __io_queue_sqe\n- 被调用者: 未显示\n\n10. 函数名: req_set_fail_links\n- 参数: [struct io_kiocb *req]\n- 调用者: __io_queue_sqe\n- 被调用者: 未显示\n\n11. 函数名: io_req_complete\n- 参数: [struct io_kiocb *req, int ret]\n- 调用者: __io_queue_sqe\n- 被调用者: 未显示\n\n12. 函数名: io_queue_linked_timeout\n- 参数: [struct io_kiocb *req]\n- 调用者: __io_queue_sqe\n- 被调用者: 未显示"
    },
    {
        "id": 3290,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1786",
        "purpose": "Code purpose:\"\"\"该代码用于在io_uring子系统中注册一个新的身份标识(personality)，包括分配内存、初始化身份信息、获取当前凭证并将其与环上下文关联起来\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_register_personality函数中，当idr_alloc_cyclic分配失败时，释放了id->creds和id，但未从personality_idr中移除引用，导致后续可能发生use-after-free。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_register_personality\n- 参数: [struct io_ring_ctx *ctx]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [kmalloc, io_init_identity, get_current_cred, idr_alloc_cyclic, put_cred, kfree]\n\n2. 函数名: kmalloc\n- 参数: [sizeof(*id), GFP_KERNEL]\n- 调用者: io_register_personality\n- 被调用者: []\n\n3. 函数名: io_init_identity\n- 参数: [struct io_identity *id]\n- 调用者: io_register_personality\n- 被调用者: []\n\n4. 函数名: get_current_cred\n- 参数: []\n- 调用者: io_register_personality\n- 被调用者: []\n\n5. 函数名: idr_alloc_cyclic\n- 参数: [&ctx->personality_idr, id, 1, USHRT_MAX, GFP_KERNEL]\n- 调用者: io_register_personality\n- 被调用者: []\n\n6. 函数名: put_cred\n- 参数: [id->creds]\n- 调用者: io_register_personality\n- 被调用者: []\n\n7. 函数名: kfree\n- 参数: [id]\n- 调用者: io_register_personality\n- 被调用者: []"
    },
    {
        "id": 3291,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1786",
        "purpose": "Code purpose:\"\"\"清理io_uring请求的工作标志和资源，处理正在进行的请求并释放相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在多个任务同时完成提交时，由于未正确处理io_uring子系统中IOPOLL设置的环形队列，导致释放后使用(UAF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: io_req_clean_work\n- 参数: [struct io_kiocb *req]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [atomic_read, wake_up, spin_lock_irqsave, spin_unlock_irqrestore, list_del, io_put_identity]\n\n2. 函数名: atomic_read\n- 参数: [&tctx->in_idle]\n- 调用者: io_req_clean_work\n- 被调用者: []\n\n3. 函数名: wake_up\n- 参数: [&tctx->wait]\n- 调用者: io_req_clean_work\n- 被调用者: []\n\n4. 函数名: spin_lock_irqsave\n- 参数: [&ctx->inflight_lock, flags]\n- 调用者: io_req_clean_work\n- 被调用者: []\n\n5. 函数名: spin_unlock_irqrestore\n- 参数: [&ctx->inflight_lock, flags]\n- 调用者: io_req_clean_work\n- 被调用者: []\n\n6. 函数名: list_del\n- 参数: [&req->inflight_entry]\n- 调用者: io_req_clean_work\n- 被调用者: []\n\n7. 函数名: io_put_identity\n- 参数: [req->task->io_uring, req]\n- 调用者: io_req_clean_work\n- 被调用者: []"
    },
    {
        "id": 3296,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1882",
        "purpose": "Code purpose:\"\"\"该代码用于向监控列表中添加一个新的监控项，并处理相关的引用计数和权限检查，以防止重复添加和资源超限。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放pipe_info后仍可能通过post_one_notification操作已释放的管道资源，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: add_watch_to_object\n- 参数: [watch, wlist]\n- 调用者: N/A\n- 被调用者: [rcu_access_pointer, hlist_for_each_entry, get_current_cred, rcu_assign_pointer, atomic_inc_return, task_rlimit, atomic_dec, put_cred, spin_lock_bh, kref_get, hlist_add_head, spin_unlock_bh]\n\n2. 函数名: rcu_access_pointer\n- 参数: [watch->queue]\n- 调用者: add_watch_to_object\n- 被调用者: N/A\n\n3. 函数名: hlist_for_each_entry\n- 参数: [w, &wlist->watchers, list_node]\n- 调用者: add_watch_to_object\n- 被调用者: N/A\n\n4. 函数名: get_current_cred\n- 参数: []\n- 调用者: add_watch_to_object\n- 被调用者: N/A\n\n5. 函数名: rcu_assign_pointer\n- 参数: [watch->watch_list, wlist]\n- 调用者: add_watch_to_object\n- 被调用者: N/A\n\n6. 函数名: atomic_inc_return\n- 参数: [&watch->cred->user->nr_watches]\n- 调用者: add_watch_to_object\n- 被调用者: N/A\n\n7. 函数名: task_rlimit\n- 参数: [current, RLIMIT_NOFILE]\n- 调用者: add_watch_to_object\n- 被调用者: N/A\n\n8. 函数名: atomic_dec\n- 参数: [&watch->cred->user->nr_watches]\n- 调用者: add_watch_to_object\n- 被调用者: N/A\n\n9. 函数名: put_cred\n- 参数: [watch->cred]\n- 调用者: add_watch_to_object\n- 被调用者: N/A\n\n10. 函数名: spin_lock_bh\n- 参数: [&wqueue->lock]\n- 调用者: add_watch_to_object\n- 被调用者: N/A\n\n11. 函数名: kref_get\n- 参数: [&wqueue->usage]\n- 调用者: add_watch_to_object\n- 被调用者: N/A\n\n12. 函数名: kref_get\n- 参数: [&watch->usage]\n- 调用者: add_watch_to_object\n- 被调用者: N/A\n\n13. 函数名: hlist_add_head\n- 参数: [&watch->queue_node, &wqueue->watches]\n- 调用者: add_watch_to_object\n- 被调用者: N/A\n\n14. 函数名: spin_unlock_bh\n- 参数: [&wqueue->lock]\n- 调用者: add_watch_to_object\n- 被调用者: N/A\n\n15. 函数名: hlist_add_head\n- 参数: [&watch->list_node, &wlist->watchers]\n- 调用者: add_watch_to_object\n- 被调用者: N/A"
    },
    {
        "id": 3297,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1882",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理管道通知队列，将通知从观察队列复制到管道缓冲区，并管理相关的内存和同步操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在pipe的post_one_notification()操作中，存在对已释放的pipe_inode_info结构体的引用，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: post_one_notification\n- 参数: [wqueue, n]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [find_first_bit, get_page, kmap_atomic, memcpy, kunmap_atomic, smp_store_release, test_and_clear_bit, wake_up_interruptible_sync_poll_locked, spin_unlock_irq, kill_fasync]\n\n2. 函数名: find_first_bit\n- 参数: [wqueue->notes_bitmap, wqueue->nr_notes]\n- 调用者: post_one_notification\n- 被调用者: 未明确（底层位操作函数）\n\n3. 函数名: get_page\n- 参数: [page]\n- 调用者: post_one_notification\n- 被调用者: 未明确（内核页引用计数函数）\n\n4. 函数名: kmap_atomic\n- 参数: [page]\n- 调用者: post_one_notification\n- 被调用者: 未明确（内核内存映射函数）\n\n5. 函数名: memcpy\n- 参数: [p + offset, n, len]\n- 调用者: post_one_notification\n- 被调用者: 未明确（标准内存拷贝函数）\n\n6. 函数名: kunmap_atomic\n- 参数: [p]\n- 调用者: post_one_notification\n- 被调用者: 未明确（内核内存取消映射函数）\n\n7. 函数名: smp_store_release\n- 参数: [&pipe->head, head + 1]\n- 调用者: post_one_notification\n- 被调用者: 未明确（内存屏障/原子操作函数）\n\n8. 函数名: test_and_clear_bit\n- 参数: [note, wqueue->notes_bitmap]\n- 调用者: post_one_notification\n- 被调用者: 未明确（原子位操作函数）\n\n9. 函数名: wake_up_interruptible_sync_poll_locked\n- 参数: [&pipe->rd_wait, EPOLLIN | EPOLLRDNORM]\n- 调用者: post_one_notification\n- 被调用者: 未明确（内核唤醒函数）\n\n10. 函数名: spin_unlock_irq\n- 参数: [&pipe->rd_wait.lock]\n- 调用者: post_one_notification\n- 被调用者: 未明确（自旋锁释放函数）\n\n11. 函数名: kill_fasync\n- 参数: [&pipe->fasync_readers, SIGIO, POLL_IN]\n- 调用者: post_one_notification\n- 被调用者: 未明确（异步通知函数）"
    },
    {
        "id": 3298,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1882",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理并发送watch通知到指定的watch队列，包括过滤和安全检查等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在调用free_pipe_info()释放管道信息后，仍可能通过post_one_notification()操作已释放的管道通知，导致释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: __post_watch_notification\n- 参数: [wlist, n, cred, id]\n- 调用者: N/A\n- 被调用者: [WARN_ON, rcu_read_lock, hlist_for_each_entry_rcu, rcu_dereference, filter_watch_notification, security_post_notification, post_one_notification, rcu_read_unlock]\n\n2. 函数名: WARN_ON\n- 参数: [1]\n- 调用者: __post_watch_notification\n- 被调用者: N/A\n\n3. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: __post_watch_notification\n- 被调用者: N/A\n\n4. 函数名: hlist_for_each_entry_rcu\n- 参数: [watch, &wlist->watchers, list_node]\n- 调用者: __post_watch_notification\n- 被调用者: N/A\n\n5. 函数名: rcu_dereference\n- 参数: [watch->queue]\n- 调用者: __post_watch_notification\n- 被调用者: N/A\n\n6. 函数名: rcu_dereference\n- 参数: [wqueue->filter]\n- 调用者: __post_watch_notification\n- 被调用者: N/A\n\n7. 函数名: filter_watch_notification\n- 参数: [wf, n]\n- 调用者: __post_watch_notification\n- 被调用者: N/A\n\n8. 函数名: security_post_notification\n- 参数: [watch->cred, cred, n]\n- 调用者: __post_watch_notification\n- 被调用者: N/A\n\n9. 函数名: post_one_notification\n- 参数: [wqueue, n]\n- 调用者: __post_watch_notification\n- 被调用者: N/A\n\n10. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: __post_watch_notification\n- 被调用者: N/A"
    },
    {
        "id": 3299,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1882",
        "purpose": "Code purpose:\"\"\"该代码用于从监视列表中移除指定的监视项，并在移除时发送通知，同时处理相关的引用计数和资源释放。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放pipe_info后仍通过post_one_notification()操作管道通知，导致释放后使用(UAF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: remove_watch_from_object\n- 参数: [struct watch_list *wlist, struct watch_queue *wq, u64 id, bool all]\n- 调用者: N/A\n- 被调用者: [rcu_read_lock, spin_lock, hlist_for_each_entry, rcu_access_pointer, spin_unlock, hlist_del_init_rcu, rcu_assign_pointer, post_one_notification, rcu_dereference, spin_lock_bh, hlist_unhashed, put_watch, spin_unlock_bh, rcu_read_unlock, hlist_empty, rcu_read_lock]\n\n2. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: remove_watch_from_object\n- 被调用者: N/A\n\n3. 函数名: spin_lock\n- 参数: [&wlist->lock]\n- 调用者: remove_watch_from_object\n- 被调用者: N/A\n\n4. 函数名: hlist_for_each_entry\n- 参数: [watch, &wlist->watchers, list_node]\n- 调用者: remove_watch_from_object\n- 被调用者: N/A\n\n5. 函数名: rcu_access_pointer\n- 参数: [watch->queue]\n- 调用者: remove_watch_from_object\n- 被调用者: N/A\n\n6. 函数名: spin_unlock\n- 参数: [&wlist->lock]\n- 调用者: remove_watch_from_object\n- 被调用者: N/A\n\n7. 函数名: hlist_del_init_rcu\n- 参数: [&watch->list_node]\n- 调用者: remove_watch_from_object\n- 被调用者: N/A\n\n8. 函数名: rcu_assign_pointer\n- 参数: [watch->watch_list, NULL]\n- 调用者: remove_watch_from_object\n- 被调用者: N/A\n\n9. 函数名: post_one_notification\n- 参数: [wqueue, &n.watch]\n- 调用者: remove_watch_from_object\n- 被调用者: N/A\n\n10. 函数名: rcu_dereference\n- 参数: [watch->queue]\n- 调用者: remove_watch_from_object\n- 被调用者: N/A\n\n11. 函数名: spin_lock_bh\n- 参数: [&wqueue->lock]\n- 调用者: remove_watch_from_object\n- 被调用者: N/A\n\n12. 函数名: hlist_unhashed\n- 参数: [&watch->queue_node]\n- 调用者: remove_watch_from_object\n- 被调用者: N/A\n\n13. 函数名: put_watch\n- 参数: [watch]\n- 调用者: remove_watch_from_object\n- 被调用者: N/A\n\n14. 函数名: spin_unlock_bh\n- 参数: [&wqueue->lock]\n- 调用者: remove_watch_from_object\n- 被调用者: N/A\n\n15. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: remove_watch_from_object\n- 被调用者: N/A\n\n16. 函数名: hlist_empty\n- 参数: [&wlist->watchers]\n- 调用者: remove_watch_from_object\n- 被调用者: N/A"
    },
    {
        "id": 3305,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1973",
        "purpose": "Code purpose:\"\"\"该代码用于读取和验证NTFS日志中的重启区域信息，以恢复文件系统状态。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在重新分配日志页面内存时未正确处理原有内存释放，导致后续可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: log_read_rst\n- 参数: [log, l_size, first, info]\n- 调用者: 未显示\n- 被调用者: [kmalloc, memset, read_log_page, is_rst_page_hdr_valid, le16_to_cpu, is_rst_area_valid, le32_to_cpu, kfree, kzalloc, is_client_area_valid, le64_to_cpu]\n\n2. 函数名: read_log_page\n- 参数: [log, vbo, &r_page, &usa_error]\n- 调用者: log_read_rst\n- 被调用者: 未显示\n\n3. 函数名: is_rst_page_hdr_valid\n- 参数: [vbo, r_page]\n- 调用者: log_read_rst\n- 被调用者: 未显示\n\n4. 函数名: is_rst_area_valid\n- 参数: [r_page]\n- 调用者: log_read_rst\n- 被调用者: 未显示\n\n5. 函数名: is_client_area_valid\n- 参数: [r_page, usa_error]\n- 调用者: log_read_rst\n- 被调用者: 未显示\n\n6. 函数名: kmalloc\n- 参数: [DefaultLogPageSize, GFP_NOFS]\n- 调用者: log_read_rst\n- 被调用者: 未显示\n\n7. 函数名: memset\n- 参数: [info, 0, sizeof(struct restart_info)]\n- 调用者: log_read_rst\n- 被调用者: 未显示\n\n8. 函数名: le16_to_cpu\n- 参数: [r_page->ra_off]\n- 调用者: log_read_rst\n- 被调用者: 未显示\n\n9. 函数名: le32_to_cpu\n- 参数: [r_page->sys_page_size]\n- 调用者: log_read_rst\n- 被调用者: 未显示\n\n10. 函数名: kfree\n- 参数: [r_page]\n- 调用者: log_read_rst\n- 被调用者: 未显示\n\n11. 函数名: kzalloc\n- 参数: [sys_page_size, GFP_NOFS]\n- 调用者: log_read_rst\n- 被调用者: 未显示\n\n12. 函数名: le64_to_cpu\n- 参数: [r_page->rhdr.lsn], [ra->current_lsn]\n- 调用者: log_read_rst\n- 被调用者: 未显示"
    },
    {
        "id": 3306,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1973",
        "purpose": "Code purpose:\"\"\"该代码用于实现NTFS文件系统的日志重放功能，处理文件系统崩溃后的恢复操作，包括读取日志记录、重建事务表和脏页表、执行重做和撤销操作以恢复文件系统一致性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在日志重放过程中，由于对内存释放后的对象进行了不当访问，导致了释放后重用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: log_replay\n- 参数: [struct ntfs_inode *ni, bool *initialized]\n- 调用者: N/A (top-level function)\n- 被调用者: [log_read_rst, log_init_pg_hdr, log_create, log_create_ra, read_log_page, enum_rstbl, free_rsttbl_idx, alloc_rsttbl_from_idx, read_log_rec_lcb, check_log_rec, check_rstbl, kmemdup, lcb_put, read_rst_area, init_rsttbl, extend_rsttbl, find_dp, run_lookup_entry, run_add_entry, ntfs_iget5, attr_create_nonres_log, ni_find_attr, run_unpack, do_action, read_next_log_rec, ntfs_update_mftmirr, ntfs_fix_pre_write, ntfs_sb_write_run, run_close, iput, kfree]\n\n2. 函数名: log_read_rst\n- 参数: [struct ntfs_log *log, u32 l_size, bool first, struct restart_info *rst_info]\n- 调用者: log_replay\n- 被调用者: []\n\n3. 函数名: log_init_pg_hdr\n- 参数: [struct ntfs_log *log, u32 page_size, u32 sys_page_size, u16 major_ver, u16 minor_ver]\n- 调用者: log_replay\n- 被调用者: []\n\n4. 函数名: log_create\n- 参数: [struct ntfs_log *log, u32 l_size, u64 last_lsn, u32 open_log_count, bool wrapped, bool use_multi_page]\n- 调用者: log_replay\n- 被调用者: []\n\n5. 函数名: log_create_ra\n- 参数: [struct ntfs_log *log]\n- 调用者: log_replay\n- 被调用者: []\n\n6. 函数名: read_log_page\n- 参数: [struct ntfs_log *log, u32 page_size, struct RECORD_PAGE_HDR **sp, bool *usa_error]\n- 调用者: log_replay\n- 被调用者: []\n\n7. 函数名: enum_rstbl\n- 参数: [struct RESTART_TABLE *tbl, void *e]\n- 调用者: log_replay\n- 被调用者: []\n\n8. 函数名: free_rsttbl_idx\n- 参数: [struct RESTART_TABLE *tbl, u32 off]\n- 调用者: log_replay\n- 被调用者: []\n\n9. 函数名: alloc_rsttbl_from_idx\n- 参数: [struct RESTART_TABLE **tbl, u32 idx]\n- 调用者: log_replay\n- 被调用者: []\n\n10. 函数名: read_log_rec_lcb\n- 参数: [struct ntfs_log *log, u64 lsn, const struct LCB_CTX *ctx, struct lcb **lcb]\n- 调用者: log_replay\n- 被调用者: []\n\n11. 函数名: check_log_rec\n- 参数: [const struct LOG_REC_HDR *lrh, u32 rec_len, u32 transact_id, u32 bytes_per_attr_entry]\n- 调用者: log_replay\n- 被调用者: []\n\n12. 函数名: check_rstbl\n- 参数: [const struct RESTART_TABLE *rt, u32 len]\n- 调用者: log_replay\n- 被调用者: []\n\n13. 函数名: lcb_put\n- 参数: [struct lcb *lcb]\n- 调用者: log_replay\n- 被调用者: []\n\n14. 函数名: read_rst_area\n- 参数: [struct ntfs_log *log, struct NTFS_RESTART **rst, u64 *lsn]\n- 调用者: log_replay\n- 被调用者: []\n\n15. 函数名: init_rsttbl\n- 参数: [u32 bytes_per_entry, u32 num_entries]\n- 调用者: log_replay\n- 被调用者: []\n\n16. 函数名: extend_rsttbl\n- 参数: [struct RESTART_TABLE *tbl, u32 add, u32 free_goal]\n- 调用者: log_replay\n- 被调用者: []\n\n17. 函数名: find_dp\n- 参数: [struct RESTART_TABLE *dptbl, u32 target_attr, u64 vcn]\n- 调用者: log_replay\n- 被调用者: []\n\n18. 函数名: run_lookup_entry\n- 参数: [struct runs_tree *run, CLST vcn, CLST *lcn, CLST *len, size_t *index]\n- 调用者: log_replay\n- 被调用者: []\n\n19. 函数名: run_add_entry\n- 参数: [struct runs_tree *run, CLST vcn, CLST lcn, CLST len, bool is_mft]\n- 调用者: log_replay\n- 被调用者: []\n\n20. 函数名: ntfs_iget5\n- 参数: [struct super_block *sb, const struct MFT_REF *ref, const struct cpu_str *name]\n- 调用者: log_replay\n- 被调用者: []\n\n21. 函数名: attr_create_nonres_log\n- 参数: [struct ntfs_sb_info *sbi, enum ATTR_TYPE type, u64 size, const __le16 *name, u8 name_len, u16 flags]\n- 调用者: log_replay\n- 被调用者: []\n\n22. 函数名: ni_find_attr\n- 参数: [struct ntfs_inode *ni, struct ATTRIB *attr, struct ATTR_LIST_ENTRY *le, enum ATTR_TYPE type, const __le16 *name, u8 name_len, const CLST *vcn, struct mft_inode **mi]\n- 调用者: log_replay\n- 被调用者: []\n\n23. 函数名: run_unpack\n- 参数: [struct runs_tree *run, struct ntfs_sb_info *sbi, CLST ino, CLST svcn, CLST evcn, CLST vcn, u8 *run_buf, u8 run_buf_size]\n- 调用者: log_replay\n- 被调用者: []\n\n24. 函数名: do_action\n- 参数: [struct ntfs_log *log, struct OPEN_ATTR_ENRTY *oe, struct LOG_REC_HDR *lrh, u16 op, void *data, u32 dlen, u32 rec_len, u64 *transact_id]\n- 调用者: log_replay\n- 被调用者: []\n\n25. 函数名: read_next_log_rec\n- 参数: [struct ntfs_log *log, struct lcb *lcb, u64 *lsn]\n- 调用者: log_replay\n- 被调用者: []\n\n26. 函数名: ntfs_update_mftmirr\n- 参数: [struct ntfs_sb_info *sbi, int wait]\n- 调用者: log_replay\n- 被调用者: []\n\n27. 函数名: ntfs_fix_pre_write\n- 参数: [struct NTFS_RECORD_HEADER *rhdr, u32 bytes]\n- 调用者: log_replay\n- 被调用者: []\n\n28. 函数名: ntfs_sb_write_run\n- 参数: [struct ntfs_sb_info *sbi, struct runs_tree *run, u64 vbo, void *buf, u32 bytes, int sync]\n- 调用者: log_replay\n- 被调用者: []\n\n29. 函数名: run_close\n- 参数: [struct runs_tree *run]\n- 调用者: log_replay\n- 被调用者: []\n\n30. 函数名: iput\n- 参数: [struct inode *inode]\n- 调用者: log_replay\n- 被调用者: []\n\n31. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: log_replay\n- 被调用者: []"
    },
    {
        "id": 3322,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1976",
        "purpose": "Code purpose:\"\"\"计算IO-URING任务中未完成请求的数量，当请求未被跟踪时返回所有CPU核心上的总和\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当tracked为false时直接返回percpu_counter_sum(&tctx->inflight)可能导致对已释放的tctx->inflight内存进行访问，造成use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: tctx_inflight\n- 参数: [tctx, tracked]\n- 调用者: 未提供（上下文不足）\n- 被调用者: [percpu_counter_sum]"
    },
    {
        "id": 3323,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1976",
        "purpose": "Code purpose:\"\"\"检查IO请求的任务匹配情况，决定是否取消所有请求\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于io_match_task_safe函数在处理IO-URING请求时未能正确验证任务指针，导致可能发生释放后重用(UAF)的内存破坏漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_match_task_safe\n- 参数: [head, task, cancel_all]\n- 调用者: 未提供（需更多上下文）\n- 被调用者: []"
    },
    {
        "id": 3324,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1976",
        "purpose": "Code purpose:\"\"\"该代码用于在IO_URING实现中添加任务工作项并管理任务运行状态，可能涉及内存操作和任务调度\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring的实现中，由于请求处理过程中存在竞态条件，导致在释放资源后仍可能被访问，从而引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: __io_req_task_work_add\n- 参数: [struct io_kiocb *req, struct io_uring_task *tctx, struct io_wq_work_list *list]\n- 调用者: 未显示\n- 被调用者: [io_drop_inflight_file, spin_lock_irqsave, wq_list_add_tail, spin_unlock_irqrestore, atomic_or, task_work_add, wq_list_merge, container_of, llist_add, schedule_delayed_work]\n\n2. 函数名: io_drop_inflight_file\n- 参数: [struct io_kiocb *req]\n- 调用者: __io_req_task_work_add\n- 被调用者: 未显示\n\n3. 函数名: spin_lock_irqsave\n- 参数: [&tctx->task_lock, flags]\n- 调用者: __io_req_task_work_add\n- 被调用者: 未显示\n\n4. 函数名: wq_list_add_tail\n- 参数: [&req->io_task_work.node, list]\n- 调用者: __io_req_task_work_add\n- 被调用者: 未显示\n\n5. 函数名: spin_unlock_irqrestore\n- 参数: [&tctx->task_lock, flags]\n- 调用者: __io_req_task_work_add\n- 被调用者: 未显示\n\n6. 函数名: atomic_or\n- 参数: [IORING_SQ_TASKRUN, &ctx->rings->sq_flags]\n- 调用者: __io_req_task_work_add\n- 被调用者: 未显示\n\n7. 函数名: task_work_add\n- 参数: [req->task, &tctx->task_work, ctx->notify_method]\n- 调用者: __io_req_task_work_add\n- 被调用者: 未显示\n\n8. 函数名: wq_list_merge\n- 参数: [&tctx->prio_task_list, &tctx->task_list]\n- 调用者: __io_req_task_work_add\n- 被调用者: 未显示\n\n9. 函数名: container_of\n- 参数: [node, struct io_kiocb, io_task_work.node]\n- 调用者: __io_req_task_work_add\n- 被调用者: 未显示\n\n10. 函数名: llist_add\n- 参数: [&req->io_task_work.fallback_node, &req->ctx->fallback_llist]\n- 调用者: __io_req_task_work_add\n- 被调用者: 未显示\n\n11. 函数名: schedule_delayed_work\n- 参数: [&req->ctx->fallback_work, 1]\n- 调用者: __io_req_task_work_add\n- 被调用者: 未显示"
    },
    {
        "id": 3325,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1976",
        "purpose": "Code purpose:\"\"\"该代码用于处理IO-URING中的轮询事件检查，包括事件状态验证、多事件处理和完成队列填充等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_poll_check_events函数中，由于对请求的poll_refs引用计数管理不当，可能导致在请求被取消后仍被使用，造成释放后重用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_poll_check_events\n- 参数: [struct io_kiocb *req, bool *locked]\n- 调用者: 未明确（应为IO-URING子系统中的其他函数）\n- 被调用者: [atomic_read, WARN_ON_ONCE, io_assign_file, vfs_poll, io_fill_cqe_aux, io_commit_cqring, io_cqring_ev_posted, io_tw_lock, io_issue_sqe, atomic_sub_return]\n\n2. 函数名: atomic_read\n- 参数: [&req->poll_refs]\n- 调用者: io_poll_check_events\n- 被调用者: []\n\n3. 函数名: WARN_ON_ONCE\n- 参数: [!(v & IO_POLL_REF_MASK)]\n- 调用者: io_poll_check_events\n- 被调用者: []\n\n4. 函数名: io_assign_file\n- 参数: [req, flags]\n- 调用者: io_poll_check_events\n- 被调用者: []\n\n5. 函数名: vfs_poll\n- 参数: [req->file, &pt]\n- 调用者: io_poll_check_events\n- 被调用者: []\n\n6. 函数名: io_fill_cqe_aux\n- 参数: [ctx, req->cqe.user_data, mask, IORING_CQE_F_MORE]\n- 调用者: io_poll_check_events\n- 被调用者: []\n\n7. 函数名: io_commit_cqring\n- 参数: [ctx]\n- 调用者: io_poll_check_events\n- 被调用者: []\n\n8. 函数名: io_cqring_ev_posted\n- 参数: [ctx]\n- 调用者: io_poll_check_events\n- 被调用者: []\n\n9. 函数名: io_tw_lock\n- 参数: [req->ctx, locked]\n- 调用者: io_poll_check_events\n- 被调用者: []\n\n10. 函数名: io_issue_sqe\n- 参数: [req, IO_URING_F_NONBLOCK|IO_URING_F_COMPLETE_DEFER]\n- 调用者: io_poll_check_events\n- 被调用者: []\n\n11. 函数名: atomic_sub_return\n- 参数: [v & IO_POLL_REF_MASK, &req->poll_refs]\n- 调用者: io_poll_check_events\n- 被调用者: []"
    },
    {
        "id": 3326,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1976",
        "purpose": "Code purpose:\"\"\"清理IO-URING请求中的相关资源，包括缓冲区、异步数据、凭证等，并重置请求标志位\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_clean_op函数中处理IO-URING请求时，由于未能正确管理请求对象的内存释放顺序或状态，导致存在释放后重用(use-after-free)的情况。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_clean_op\n- 参数: [struct io_kiocb *req]\n- 调用者: 未显示\n- 被调用者: [spin_lock, io_put_kbuf_comp, spin_unlock, kfree, putname, __io_xattr_finish, put_cred]\n\n2. 函数名: spin_lock\n- 参数: [&req->ctx->completion_lock]\n- 调用者: io_clean_op\n- 被调用者: 未显示\n\n3. 函数名: io_put_kbuf_comp\n- 参数: [req]\n- 调用者: io_clean_op\n- 被调用者: 未显示\n\n4. 函数名: spin_unlock\n- 参数: [&req->ctx->completion_lock]\n- 调用者: io_clean_op\n- 被调用者: 未显示\n\n5. 函数名: kfree\n- 参数: [io->free_iovec, io->free_iov, req->apoll->double_poll, req->apoll, req->async_data]\n- 调用者: io_clean_op\n- 被调用者: 未显示\n\n6. 函数名: putname\n- 参数: [req->open.filename, req->rename.oldpath, req->rename.newpath, req->unlink.filename, req->mkdir.filename, req->symlink.oldpath, req->symlink.newpath, req->hardlink.oldpath, req->hardlink.newpath, req->statx.filename]\n- 调用者: io_clean_op\n- 被调用者: 未显示\n\n7. 函数名: __io_xattr_finish\n- 参数: [req]\n- 调用者: io_clean_op\n- 被调用者: 未显示\n\n8. 函数名: put_cred\n- 参数: [req->creds]\n- 调用者: io_clean_op\n- 被调用者: 未显示"
    },
    {
        "id": 3327,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1976",
        "purpose": "Code purpose:\"\"\"为任务分配并初始化IO_URING任务上下文，包括注册的环形缓冲区、工作队列等资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring_alloc_task_context函数中，由于未正确处理任务上下文的内存释放路径，可能导致在后续操作中出现释放后重用(use-after-free)的情况。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_uring_alloc_task_context\n- 参数: [task_struct *task, io_ring_ctx *ctx]\n- 调用者: 未提供\n- 被调用者: [kzalloc, kcalloc, kfree, percpu_counter_init, percpu_counter_destroy, io_init_wq_offload, xa_init, init_waitqueue_head, atomic_set, spin_lock_init, INIT_WQ_LIST, init_task_work]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*tctx), GFP_KERNEL]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未提供\n\n3. 函数名: kcalloc\n- 参数: [IO_RINGFD_REG_MAX, sizeof(struct file *), GFP_KERNEL]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未提供\n\n4. 函数名: kfree\n- 参数: [tctx], [tctx->registered_rings]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未提供\n\n5. 函数名: percpu_counter_init\n- 参数: [&tctx->inflight, 0, GFP_KERNEL]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未提供\n\n6. 函数名: percpu_counter_destroy\n- 参数: [&tctx->inflight]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未提供\n\n7. 函数名: io_init_wq_offload\n- 参数: [ctx, task]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未提供\n\n8. 函数名: xa_init\n- 参数: [&tctx->xa]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未提供\n\n9. 函数名: init_waitqueue_head\n- 参数: [&tctx->wait]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未提供\n\n10. 函数名: atomic_set\n- 参数: [&tctx->in_idle, 0]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未提供\n\n11. 函数名: spin_lock_init\n- 参数: [&tctx->task_lock]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未提供\n\n12. 函数名: INIT_WQ_LIST\n- 参数: [&tctx->task_list], [&tctx->prio_task_list]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未提供\n\n13. 函数名: init_task_work\n- 参数: [&tctx->task_work, tctx_task_work]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未提供"
    },
    {
        "id": 3328,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1976",
        "purpose": "Code purpose:\"\"\"该代码用于通过文件描述符获取对应的文件结构体，并检查是否为io_uring文件类型以设置相应标志位\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_file_get_normal函数中，当获取的文件操作指针等于io_uring_fops时，未正确处理文件引用计数，可能导致后续使用已被释放的内存。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_file_get_normal\n- 参数: [req, fd]\n- 调用者: 未明确（由IO-URING子系统调用）\n- 被调用者: [fget, trace_io_uring_file_get]\n\n2. 函数名: fget\n- 参数: [fd]\n- 调用者: io_file_get_normal\n- 被调用者: 未明确（内核文件系统函数）\n\n3. 函数名: trace_io_uring_file_get\n- 参数: [req->ctx, req, req->cqe.user_data, fd]\n- 调用者: io_file_get_normal\n- 被调用者: 未明确（跟踪/调试函数）"
    },
    {
        "id": 3329,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1976",
        "purpose": "Code purpose:\"\"\"检查IO请求任务是否匹配当前任务或是否需要取消所有请求\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确持有或检查锁，导致在IO-URING请求处理过程中可能出现竞态条件，引发释放后重用(UAF)的内存破坏问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_match_task\n- 参数: [head, task, cancel_all]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: []"
    },
    {
        "id": 3330,
        "cwe": "CWE-416",
        "cve": "CVE-2022-1998",
        "purpose": "Code purpose:\"\"\"将文件系统通知事件的相关信息从内核空间复制到用户空间，包括事件元数据、文件描述符和进程ID文件描述符等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在copy_event_to_user函数中，当copy_info_records_to_user调用失败时，未正确清理已分配的fd和pidfd资源，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: copy_event_to_user\n- 参数: [struct fsnotify_group *group, struct fanotify_event *event, char __user *buf, size_t count]\n- 调用者: N/A\n- 被调用者: [fanotify_event_path, fanotify_event_info, FAN_GROUP_FLAG, fanotify_event_len, pid_vnr, task_tgid, create_fd, pid_has_task, pidfd_create, copy_to_user, fd_install, copy_info_records_to_user, put_unused_fd, fput, close_fd]\n\n2. 函数名: fanotify_event_path\n- 参数: [struct fanotify_event *event]\n- 调用者: copy_event_to_user\n- 被调用者: N/A\n\n3. 函数名: fanotify_event_info\n- 参数: [struct fanotify_event *event]\n- 调用者: copy_event_to_user\n- 被调用者: N/A\n\n4. 函数名: FAN_GROUP_FLAG\n- 参数: [struct fsnotify_group *group, int flag]\n- 调用者: copy_event_to_user\n- 被调用者: N/A\n\n5. 函数名: fanotify_event_len\n- 参数: [unsigned int info_mode, struct fanotify_event *event]\n- 调用者: copy_event_to_user\n- 被调用者: N/A\n\n6. 函数名: pid_vnr\n- 参数: [struct pid *pid]\n- 调用者: copy_event_to_user\n- 被调用者: N/A\n\n7. 函数名: task_tgid\n- 参数: [struct task_struct *task]\n- 调用者: copy_event_to_user\n- 被调用者: N/A\n\n8. 函数名: create_fd\n- 参数: [struct fsnotify_group *group, struct path *path, struct file **file]\n- 调用者: copy_event_to_user\n- 被调用者: N/A\n\n9. 函数名: pid_has_task\n- 参数: [struct pid *pid, enum pid_type type]\n- 调用者: copy_event_to_user\n- 被调用者: N/A\n\n10. 函数名: pidfd_create\n- 参数: [struct pid *pid, unsigned int flags]\n- 调用者: copy_event_to_user\n- 被调用者: N/A\n\n11. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: copy_event_to_user\n- 被调用者: N/A\n\n12. 函数名: fd_install\n- 参数: [int fd, struct file *file]\n- 调用者: copy_event_to_user\n- 被调用者: N/A\n\n13. 函数名: copy_info_records_to_user\n- 参数: [struct fanotify_event *event, struct fanotify_info *info, unsigned int info_mode, int pidfd, char __user *buf, size_t count]\n- 调用者: copy_event_to_user\n- 被调用者: N/A\n\n14. 函数名: put_unused_fd\n- 参数: [int fd]\n- 调用者: copy_event_to_user\n- 被调用者: N/A\n\n15. 函数名: fput\n- 参数: [struct file *file]\n- 调用者: copy_event_to_user\n- 被调用者: N/A\n\n16. 函数名: close_fd\n- 参数: [int fd]\n- 调用者: copy_event_to_user\n- 被调用者: N/A"
    },
    {
        "id": 3343,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20158",
        "purpose": "Code purpose:\"\"\"该代码实现了从网络数据包套接字接收消息的功能，包括处理数据包的各种标志、虚拟网络头、错误队列以及消息地址信息等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在backing-dev.c中的bdi_put和bdi_unregister函数中存在释放后使用(use-after-free)问题，导致内存损坏\"\"\"",
        "functions": "Functions:\n1. 函数名: packet_recvmsg\n- 参数: [struct socket *sock, struct msghdr *msg, size_t len, int flags]\n- 调用者: 未显示（由socket层调用）\n- 被调用者: [sock_recv_errqueue, skb_recv_datagram, packet_rcv_try_clear_pressure, packet_rcv_vnet, skb_copy_datagram_msg, sock_recv_ts_and_drops, memset, memcpy, put_cmsg, skb_free_datagram]\n\n2. 函数名: sock_recv_errqueue\n- 参数: [struct sock *sk, struct msghdr *msg, size_t len, SOL_PACKET, PACKET_TX_TIMESTAMP]\n- 调用者: packet_recvmsg\n- 被调用者: []\n\n3. 函数名: skb_recv_datagram\n- 参数: [struct sock *sk, int flags, flags & MSG_DONTWAIT, &err]\n- 调用者: packet_recvmsg\n- 被调用者: []\n\n4. 函数名: packet_rcv_try_clear_pressure\n- 参数: [pkt_sk(sk)]\n- 调用者: packet_recvmsg\n- 被调用者: []\n\n5. 函数名: packet_rcv_vnet\n- 参数: [struct msghdr *msg, struct sk_buff *skb, &len]\n- 调用者: packet_recvmsg\n- 被调用者: []\n\n6. 函数名: skb_copy_datagram_msg\n- 参数: [struct sk_buff *skb, 0, msg, copied]\n- 调用者: packet_recvmsg\n- 被调用者: []\n\n7. 函数名: sock_recv_ts_and_drops\n- 参数: [msg, sk, skb]\n- 调用者: packet_recvmsg\n- 被调用者: []\n\n8. 函数名: memset\n- 参数: [msg->msg_name + offsetof(struct sockaddr_ll, sll_addr), 0, sizeof(sll->sll_addr)]\n- 调用者: packet_recvmsg\n- 被调用者: []\n\n9. 函数名: memcpy\n- 参数: [msg->msg_name, &PACKET_SKB_CB(skb)->sa, copy_len]\n- 调用者: packet_recvmsg\n- 被调用者: []\n\n10. 函数名: put_cmsg\n- 参数: [msg, SOL_PACKET, PACKET_AUXDATA, sizeof(aux), &aux]\n- 调用者: packet_recvmsg\n- 被调用者: []\n\n11. 函数名: skb_free_datagram\n- 参数: [sk, skb]\n- 调用者: packet_recvmsg\n- 被调用者: []"
    },
    {
        "id": 3344,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20158",
        "purpose": "Code purpose:\"\"\"处理网络数据包的接收和解析，包括数据包过滤、内存管理、状态标记以及将数据包传递给用户空间。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在backing-dev.c中的bdi_put和bdi_unregister函数中存在释放后使用(UAF)问题，导致内存损坏\"\"\"",
        "functions": "Functions:\n1. 函数名: tpacket_rcv\n- 参数: [struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev]\n- 调用者: 网络数据包接收处理流程\n- 被调用者: [run_filter, __packet_rcv_has_room, skb_push, skb_pull, skb_clone, skb_get, skb_set_owner_r, skb_shared, skb_copy_bits, tpacket_get_timestamp, ktime_get_real_ts64, dev_parse_header, flush_dcache_page, pgv_to_page, __packet_set_status, __clear_bit, consume_skb, kfree_skb, virtio_net_hdr_from_skb, prb_clear_blk_fill_status, packet_increment_rx_head, __set_bit, test_bit, packet_current_rx_frame, skb_network_offset, skb_mac_header, skb_vlan_tag_present, skb_vlan_tag_get, atomic_inc, atomic_read, memset, BUILD_BUG_ON]\n\n2. 函数名: run_filter\n- 参数: [struct sk_buff *skb, struct sock *sk, int snaplen]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n3. 函数名: __packet_rcv_has_room\n- 参数: [struct packet_sock *po, struct sk_buff *skb]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n4. 函数名: packet_current_rx_frame\n- 参数: [struct packet_sock *po, struct sk_buff *skb, unsigned int status, unsigned int len]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n5. 函数名: packet_increment_rx_head\n- 参数: [struct packet_sock *po, struct packet_ring_buffer *rb]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n6. 函数名: tpacket_get_timestamp\n- 参数: [struct sk_buff *skb, struct timespec64 *ts, unsigned int flags]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n7. 函数名: virtio_net_hdr_from_skb\n- 参数: [struct sk_buff *skb, void *hdr, bool le, bool has_data_valid, int vlan_hlen]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n8. 函数名: prb_clear_blk_fill_status\n- 参数: [struct packet_ring_buffer *rb]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n9. 函数名: __packet_set_status\n- 参数: [struct packet_sock *po, void *frame, int status]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n10. 函数名: dev_parse_header\n- 参数: [struct sk_buff *skb, u8 *haddr]\n- 调用者: tpacket_rcv\n- 被调用者: []"
    },
    {
        "id": 3351,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20409",
        "purpose": "Code purpose:\"\"\"该代码实现了IO工作队列中工作项的处理逻辑，包括获取工作项、执行工作、处理依赖关系以及管理工作队列状态等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_worker_handle_work函数中，由于对释放后的work对象可能进行了后续操作，导致了use-after-free内存破坏漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_worker_handle_work\n- 参数: [worker]\n- 调用者: N/A (顶层函数)\n- 被调用者: [io_get_next_work, __io_worker_busy, wq_list_empty, raw_spin_unlock_irq, io_assign_current_work, io_get_work_hash, wq_next_work, wq->do_work, wq->free_work, io_wq_is_hashed, io_wqe_enqueue, raw_spin_lock_irq]\n\n2. 函数名: io_get_next_work\n- 参数: [wqe]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A\n\n3. 函数名: __io_worker_busy\n- 参数: [wqe, worker, work]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A\n\n4. 函数名: wq_list_empty\n- 参数: [&wqe->work_list]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A\n\n5. 函数名: raw_spin_unlock_irq\n- 参数: [&wqe->lock]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A\n\n6. 函数名: io_assign_current_work\n- 参数: [worker, work]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A\n\n7. 函数名: io_get_work_hash\n- 参数: [work]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A\n\n8. 函数名: wq_next_work\n- 参数: [work]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A\n\n9. 函数名: wq->do_work\n- 参数: [work]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A\n\n10. 函数名: wq->free_work\n- 参数: [work]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A\n\n11. 函数名: io_wq_is_hashed\n- 参数: [linked]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A\n\n12. 函数名: io_wqe_enqueue\n- 参数: [wqe, linked]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A\n\n13. 函数名: raw_spin_lock_irq\n- 参数: [&wqe->lock]\n- 调用者: io_worker_handle_work\n- 被调用者: N/A"
    },
    {
        "id": 3352,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20409",
        "purpose": "Code purpose:\"\"\"该代码用于安全地释放IO工作线程资源，包括引用计数管理、状态更新和内存释放，但存在释放后使用(UAF)漏洞风险。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在释放worker后仍可能通过引用计数操作访问已释放的内存，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: io_worker_exit\n- 参数: [worker]\n- 调用者: 未显示\n- 被调用者: [io_wqe_get_acct, set_current_state, refcount_dec_and_test, schedule, __set_current_state, preempt_disable, atomic_dec, preempt_enable, raw_spin_lock_irq, hlist_nulls_del_rcu, list_del_rcu, raw_spin_unlock_irq, kfree_rcu, complete]\n\n2. 函数名: io_wqe_get_acct\n- 参数: [worker]\n- 调用者: io_worker_exit\n- 被调用者: 未显示\n\n3. 函数名: set_current_state\n- 参数: [TASK_INTERRUPTIBLE]\n- 调用者: io_worker_exit\n- 被调用者: 未显示\n\n4. 函数名: refcount_dec_and_test\n- 参数: [&worker->ref]\n- 调用者: io_worker_exit\n- 被调用者: 未显示\n\n5. 函数名: schedule\n- 参数: []\n- 调用者: io_worker_exit\n- 被调用者: 未显示\n\n6. 函数名: __set_current_state\n- 参数: [TASK_RUNNING]\n- 调用者: io_worker_exit\n- 被调用者: 未显示\n\n7. 函数名: preempt_disable\n- 参数: []\n- 调用者: io_worker_exit\n- 被调用者: 未显示\n\n8. 函数名: atomic_dec\n- 参数: [&acct->nr_running], [&wqe->wq->user->processes]\n- 调用者: io_worker_exit\n- 被调用者: 未显示\n\n9. 函数名: preempt_enable\n- 参数: []\n- 调用者: io_worker_exit\n- 被调用者: 未显示\n\n10. 函数名: raw_spin_lock_irq\n- 参数: [&wqe->lock]\n- 调用者: io_worker_exit\n- 被调用者: 未显示\n\n11. 函数名: hlist_nulls_del_rcu\n- 参数: [&worker->nulls_node]\n- 调用者: io_worker_exit\n- 被调用者: 未显示\n\n12. 函数名: list_del_rcu\n- 参数: [&worker->all_list]\n- 调用者: io_worker_exit\n- 被调用者: 未显示\n\n13. 函数名: raw_spin_unlock_irq\n- 参数: [&wqe->lock]\n- 调用者: io_worker_exit\n- 被调用者: 未显示\n\n14. 函数名: kfree_rcu\n- 参数: [worker, rcu]\n- 调用者: io_worker_exit\n- 被调用者: 未显示\n\n15. 函数名: complete\n- 参数: [&wqe->wq->done]\n- 调用者: io_worker_exit\n- 被调用者: 未显示"
    },
    {
        "id": 3353,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20409",
        "purpose": "Code purpose:\"\"\"在持有锁的情况下，将空闲的io_worker标记为FREE状态并添加到wqe的空闲列表中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在释放后继续使用(use-after-free)worker对象，导致内存损坏漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: __io_worker_idle\n- 参数: [wqe, worker]\n- 调用者: 未明确（需上下文确定）\n- 被调用者: [hlist_nulls_add_head_rcu]"
    },
    {
        "id": 3354,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20409",
        "purpose": "Code purpose:\"\"\"该代码用于检查IO请求是否与给定任务或文件集匹配，以决定是否取消或继续处理请求\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在io_match_task函数中可能访问已被释放的req->work.identity->files指针，导致内存损坏的释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: io_match_task\n- 参数: [struct io_kiocb *head, struct task_struct *task, struct files_struct *files]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [io_for_each_link]\n\n2. 函数名: io_for_each_link\n- 参数: [struct io_kiocb *req, struct io_kiocb *head]\n- 调用者: io_match_task\n- 被调用者: []"
    },
    {
        "id": 3355,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20409",
        "purpose": "Code purpose:\"\"\"准备异步I/O请求的工作结构，根据请求类型和标志设置相应的工作属性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在io_identity_cow函数中存在释放后重用(use-after-free)的内存错误，导致内存损坏漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_prep_async_work\n- 参数: [struct io_kiocb *req]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [io_req_init_async, io_wq_hash_work]\n\n2. 函数名: io_req_init_async\n- 参数: [struct io_kiocb *req]\n- 调用者: io_prep_async_work\n- 被调用者: []\n\n3. 函数名: io_wq_hash_work\n- 参数: [&req->work, file_inode(req->file)]\n- 调用者: io_prep_async_work\n- 被调用者: []\n\n4. 函数名: file_inode\n- 参数: [req->file]\n- 调用者: io_prep_async_work (通过io_wq_hash_work间接调用)\n- 被调用者: []"
    },
    {
        "id": 3356,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20409",
        "purpose": "Code purpose:\"\"\"该代码用于在io_uring子系统中显示进程的凭据信息，包括用户ID、组ID、组列表和有效能力集。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring_show_cred函数中，由于对已释放的iod->creds指针进行了后续访问，导致了释放后使用(UAF)的内存破坏漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_uring_show_cred\n- 参数: [id, p, data]\n- 调用者: 未显示\n- 被调用者: [seq_user_ns, seq_printf, seq_put_decimal_ull, from_kuid_munged, from_kgid_munged, seq_puts, seq_put_hex_ll, seq_putc]\n\n2. 函数名: seq_user_ns\n- 参数: [m]\n- 调用者: io_uring_show_cred\n- 被调用者: 未显示\n\n3. 函数名: seq_printf\n- 参数: [m, format, id]\n- 调用者: io_uring_show_cred\n- 被调用者: 未显示\n\n4. 函数名: seq_put_decimal_ull\n- 参数: [m, prefix, value]\n- 调用者: io_uring_show_cred\n- 被调用者: 未显示\n\n5. 函数名: from_kuid_munged\n- 参数: [uns, uid]\n- 调用者: io_uring_show_cred\n- 被调用者: 未显示\n\n6. 函数名: from_kgid_munged\n- 参数: [uns, gid]\n- 调用者: io_uring_show_cred\n- 被调用者: 未显示\n\n7. 函数名: seq_puts\n- 参数: [m, s]\n- 调用者: io_uring_show_cred\n- 被调用者: 未显示\n\n8. 函数名: seq_put_hex_ll\n- 参数: [m, prefix, value, size]\n- 调用者: io_uring_show_cred\n- 被调用者: 未显示\n\n9. 函数名: seq_putc\n- 参数: [m, c]\n- 调用者: io_uring_show_cred\n- 被调用者: 未显示"
    },
    {
        "id": 3357,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20409",
        "purpose": "Code purpose:\"\"\"初始化异步IO请求并处理身份引用的计数增加\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在io_req_init_async函数中对tctx->identity的引用未进行适当的同步保护，可能导致在引用时该内存已被释放，造成释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_req_init_async\n- 参数: [struct io_kiocb *req]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [__io_req_init_async, refcount_inc]\n\n2. 函数名: __io_req_init_async\n- 参数: [struct io_kiocb *req]\n- 调用者: io_req_init_async\n- 被调用者: []\n\n3. 函数名: refcount_inc\n- 参数: [&req->work.identity->count]\n- 调用者: io_req_init_async\n- 被调用者: []"
    },
    {
        "id": 3358,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20409",
        "purpose": "Code purpose:\"\"\"为任务分配并初始化io_uring任务上下文结构体，包括内存分配、计数器初始化、工作队列设置等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在io_uring_alloc_task_context函数中分配的任务上下文tctx可能在使用后被释放，导致后续使用时出现释放后重用(UAF)的内存损坏问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_uring_alloc_task_context\n- 参数: [task_struct *task, io_ring_ctx *ctx]\n- 调用者: 未指定\n- 被调用者: [kmalloc, percpu_counter_init, kfree, io_init_wq_offload, percpu_counter_destroy, xa_init, init_waitqueue_head, atomic_set, io_init_identity, spin_lock_init, INIT_WQ_LIST, init_task_work]\n\n2. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未指定\n\n3. 函数名: percpu_counter_init\n- 参数: [struct percpu_counter *fbc, s64 amount, gfp_t gfp]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未指定\n\n4. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未指定\n\n5. 函数名: io_init_wq_offload\n- 参数: [io_ring_ctx *ctx]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未指定\n\n6. 函数名: percpu_counter_destroy\n- 参数: [struct percpu_counter *fbc]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未指定\n\n7. 函数名: xa_init\n- 参数: [struct xarray *xa]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未指定\n\n8. 函数名: init_waitqueue_head\n- 参数: [wait_queue_head_t *q]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未指定\n\n9. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未指定\n\n10. 函数名: io_init_identity\n- 参数: [未指定]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未指定\n\n11. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未指定\n\n12. 函数名: INIT_WQ_LIST\n- 参数: [未指定]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未指定\n\n13. 函数名: init_task_work\n- 参数: [struct callback_head *twork, task_work_func_t func]\n- 调用者: io_uring_alloc_task_context\n- 被调用者: 未指定"
    },
    {
        "id": 3359,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20409",
        "purpose": "Code purpose:\"\"\"初始化io_uring请求结构体并验证相关参数的有效性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_identity_cow函数中存在对已释放的io_identity对象的引用，导致内存损坏的use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: io_init_req\n- 参数: [ctx, req, sqe]\n- 调用者: N/A\n- 被调用者: [READ_ONCE, refcount_set, io_sq_thread_acquire_mm_files, io_check_restriction, idr_find, refcount_inc, __io_req_init_async, get_cred, blk_start_plug, io_file_get]\n\n2. 函数名: READ_ONCE\n- 参数: [variable]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n3. 函数名: refcount_set\n- 参数: [ref, value]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n4. 函数名: io_sq_thread_acquire_mm_files\n- 参数: [ctx, req]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n5. 函数名: io_check_restriction\n- 参数: [ctx, req, sqe_flags]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n6. 函数名: idr_find\n- 参数: [idr, id]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n7. 函数名: refcount_inc\n- 参数: [count]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n8. 函数名: __io_req_init_async\n- 参数: [req]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n9. 函数名: get_cred\n- 参数: [creds]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n10. 函数名: blk_start_plug\n- 参数: [plug]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n11. 函数名: io_file_get\n- 参数: [state, req, fd, fixed]\n- 调用者: io_init_req\n- 被调用者: N/A"
    },
    {
        "id": 3360,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20409",
        "purpose": "Code purpose:\"\"\"该代码用于从io_ring_ctx结构中注销指定ID的身份信息，并释放相关资源。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放iod内存后仍可能通过引用计数操作访问已释放的内存，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: io_unregister_personality\n- 参数: [struct io_ring_ctx *ctx, unsigned id]\n- 调用者: 未明确（上下文不足）\n- 被调用者: [idr_remove, put_cred, refcount_dec_and_test, kfree]\n\n2. 函数名: idr_remove\n- 参数: [&ctx->personality_idr, id]\n- 调用者: io_unregister_personality\n- 被调用者: 未明确（上下文不足）\n\n3. 函数名: put_cred\n- 参数: [iod->creds]\n- 调用者: io_unregister_personality\n- 被调用者: 未明确（上下文不足）\n\n4. 函数名: refcount_dec_and_test\n- 参数: [&iod->count]\n- 调用者: io_unregister_personality\n- 被调用者: 未明确（上下文不足）\n\n5. 函数名: kfree\n- 参数: [iod]\n- 调用者: io_unregister_personality\n- 被调用者: 未明确（上下文不足）"
    },
    {
        "id": 3361,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20409",
        "purpose": "Code purpose:\"\"\"释放与任务关联的io_uring资源，包括身份信息和任务上下文\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在释放tctx->identity内存后可能仍被引用，导致内存释放后使用(UAF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: __io_uring_free\n- 参数: [struct task_struct *tsk]\n- 调用者: 未明确显示（通常由内核其他部分调用）\n- 被调用者: [WARN_ON_ONCE, xa_empty, refcount_read, kfree, percpu_counter_destroy]\n\n2. 函数名: WARN_ON_ONCE\n- 参数: [bool condition]\n- 调用者: __io_uring_free\n- 被调用者: []\n\n3. 函数名: xa_empty\n- 参数: [struct xarray *xa]\n- 调用者: __io_uring_free\n- 被调用者: []\n\n4. 函数名: refcount_read\n- 参数: [const refcount_t *r]\n- 调用者: __io_uring_free\n- 被调用者: []\n\n5. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: __io_uring_free\n- 被调用者: []\n\n6. 函数名: percpu_counter_destroy\n- 参数: [struct percpu_counter *fbc]\n- 调用者: __io_uring_free\n- 被调用者: []"
    },
    {
        "id": 3362,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20409",
        "purpose": "Code purpose:\"\"\"处理IO请求队列中的请求，包括权限控制、请求执行、异步处理和超时管理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在io_identity_cow函数中存在释放后使用(UAF)问题，导致内存损坏的可能性\"\"\"",
        "functions": "Functions:\n1. 函数名: __io_queue_sqe\n- 参数: [struct io_kiocb *req]\n- 调用者: 未显示\n- 被调用者: [io_prep_linked_timeout, override_creds, io_issue_sqe, revert_creds, io_arm_poll_handler, io_queue_async_work, io_put_req, io_req_complete, io_queue_linked_timeout, io_submit_flush_completions]\n\n2. 函数名: io_prep_linked_timeout\n- 参数: [struct io_kiocb *req]\n- 调用者: __io_queue_sqe\n- 被调用者: 未显示\n\n3. 函数名: override_creds\n- 参数: [const struct cred *creds]\n- 调用者: __io_queue_sqe\n- 被调用者: 未显示\n\n4. 函数名: io_issue_sqe\n- 参数: [struct io_kiocb *req, int flags]\n- 调用者: __io_queue_sqe\n- 被调用者: 未显示\n\n5. 函数名: revert_creds\n- 参数: [const struct cred *old_creds]\n- 调用者: __io_queue_sqe\n- 被调用者: 未显示\n\n6. 函数名: io_arm_poll_handler\n- 参数: [struct io_kiocb *req]\n- 调用者: __io_queue_sqe\n- 被调用者: 未显示\n\n7. 函数名: io_queue_async_work\n- 参数: [struct io_kiocb *req]\n- 调用者: __io_queue_sqe\n- 被调用者: 未显示\n\n8. 函数名: io_put_req\n- 参数: [struct io_kiocb *req]\n- 调用者: __io_queue_sqe\n- 被调用者: 未显示\n\n9. 函数名: io_req_complete\n- 参数: [struct io_kiocb *req, int ret]\n- 调用者: __io_queue_sqe\n- 被调用者: 未显示\n\n10. 函数名: io_queue_linked_timeout\n- 参数: [struct io_kiocb *linked_timeout]\n- 调用者: __io_queue_sqe\n- 被调用者: 未显示\n\n11. 函数名: io_submit_flush_completions\n- 参数: [struct io_comp_state *cs, struct io_ring_ctx *ctx]\n- 调用者: __io_queue_sqe\n- 被调用者: 未显示"
    },
    {
        "id": 3363,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20409",
        "purpose": "Code purpose:\"\"\"为io_uring注册新的人格标识，包括分配内存、初始化身份信息和凭据，并将其添加到循环分配器中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在idr_alloc_cyclic调用失败后未正确清理io_identity结构体，导致后续可能发生释放后使用(UAF)的内存损坏问题\"\"\"",
        "functions": "Functions:\n1. 函数名: io_register_personality\n- 参数: [struct io_ring_ctx *ctx]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [kmalloc, io_init_identity, get_current_cred, idr_alloc_cyclic, put_cred, kfree]\n\n2. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: io_register_personality\n- 被调用者: []\n\n3. 函数名: io_init_identity\n- 参数: [struct io_identity *id]\n- 调用者: io_register_personality\n- 被调用者: []\n\n4. 函数名: get_current_cred\n- 参数: []\n- 调用者: io_register_personality\n- 被调用者: []\n\n5. 函数名: idr_alloc_cyclic\n- 参数: [struct idr *idr, void *ptr, int start, int end, gfp_t gfp_mask]\n- 调用者: io_register_personality\n- 被调用者: []\n\n6. 函数名: put_cred\n- 参数: [const struct cred *cred]\n- 调用者: io_register_personality\n- 被调用者: []\n\n7. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: io_register_personality\n- 被调用者: []"
    },
    {
        "id": 3364,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20409",
        "purpose": "Code purpose:\"\"\"清理io_uring请求的工作标志和资源，包括处理正在进行的请求和释放相关身份信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_req_clean_work函数中，由于未正确处理io_uring任务的引用计数，导致在释放资源后仍可能被访问，造成释放后重用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_req_clean_work\n- 参数: [struct io_kiocb *req]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [atomic_read, wake_up, spin_lock_irqsave, list_del, spin_unlock_irqrestore, io_put_identity]\n\n2. 函数名: atomic_read\n- 参数: [&tctx->in_idle]\n- 调用者: io_req_clean_work\n- 被调用者: []\n\n3. 函数名: wake_up\n- 参数: [&tctx->wait]\n- 调用者: io_req_clean_work\n- 被调用者: []\n\n4. 函数名: spin_lock_irqsave\n- 参数: [&ctx->inflight_lock, flags]\n- 调用者: io_req_clean_work\n- 被调用者: []\n\n5. 函数名: list_del\n- 参数: [&req->inflight_entry]\n- 调用者: io_req_clean_work\n- 被调用者: []\n\n6. 函数名: spin_unlock_irqrestore\n- 参数: [&ctx->inflight_lock, flags]\n- 调用者: io_req_clean_work\n- 被调用者: []\n\n7. 函数名: io_put_identity\n- 参数: [req->task->io_uring, req]\n- 调用者: io_req_clean_work\n- 被调用者: []"
    },
    {
        "id": 3365,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20421",
        "purpose": "Code purpose:\"\"\"该代码用于在Android内核的binder驱动中增加对binder节点的引用计数，并处理可能的引用竞争情况\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放new_ref后仍可能被使用，导致释放后重用(UAF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_inc_ref_for_node\n- 参数: [struct binder_proc *proc, struct binder_node *node, bool strong, struct list_head *target_list, struct binder_ref_data *rdata]\n- 调用者: N/A\n- 被调用者: [binder_proc_lock, binder_get_ref_for_node_olocked, binder_proc_unlock, kzalloc, binder_inc_ref_olocked, kfree]\n\n2. 函数名: binder_proc_lock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_inc_ref_for_node\n- 被调用者: N/A\n\n3. 函数名: binder_get_ref_for_node_olocked\n- 参数: [struct binder_proc *proc, struct binder_node *node, struct binder_ref *new_ref]\n- 调用者: binder_inc_ref_for_node\n- 被调用者: N/A\n\n4. 函数名: binder_proc_unlock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_inc_ref_for_node\n- 被调用者: N/A\n\n5. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: binder_inc_ref_for_node\n- 被调用者: N/A\n\n6. 函数名: binder_inc_ref_olocked\n- 参数: [struct binder_ref *ref, bool strong, struct list_head *target_list]\n- 调用者: binder_inc_ref_for_node\n- 被调用者: N/A\n\n7. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: binder_inc_ref_for_node\n- 被调用者: N/A"
    },
    {
        "id": 3385,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20566",
        "purpose": "Code purpose:\"\"\"处理L2CAP协议中LE(低功耗蓝牙)信道的信用值更新，确保不超过最大信用限制并在信用可用时恢复发送数据。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放l2cap_chan对象时未正确加锁，导致存在释放后使用的风险\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_le_credits\n- 参数: [struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [l2cap_get_chan_by_dcid, l2cap_send_disconn_req, l2cap_chan_unlock, l2cap_le_flowctl_send]\n\n2. 函数名: l2cap_get_chan_by_dcid\n- 参数: [struct l2cap_conn *conn, u16 cid]\n- 调用者: l2cap_le_credits\n- 被调用者: []\n\n3. 函数名: l2cap_send_disconn_req\n- 参数: [struct l2cap_chan *chan, int err]\n- 调用者: l2cap_le_credits\n- 被调用者: []\n\n4. 函数名: l2cap_chan_unlock\n- 参数: [struct l2cap_chan *chan]\n- 调用者: l2cap_le_credits\n- 被调用者: []\n\n5. 函数名: l2cap_le_flowctl_send\n- 参数: [struct l2cap_chan *chan]\n- 调用者: l2cap_le_credits\n- 被调用者: []\n\n6. 函数名: __le16_to_cpu\n- 参数: [u16 val]\n- 调用者: l2cap_le_credits\n- 被调用者: []\n\n7. 函数名: chan->ops->resume\n- 参数: [struct l2cap_chan *chan]\n- 调用者: l2cap_le_credits\n- 被调用者: []"
    },
    {
        "id": 3386,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20566",
        "purpose": "Code purpose:\"\"\"通过互斥锁保护，根据指定的CID从L2CAP连接中获取对应的通道并锁定该通道\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放通道资源时未正确加锁，导致存在竞争条件下可能发生释放后使用(UAF)的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_get_chan_by_dcid\n- 参数: [conn, cid]\n- 调用者: 未显示（上下文不足）\n- 被调用者: [mutex_lock, __l2cap_get_chan_by_dcid, l2cap_chan_lock, mutex_unlock]\n\n2. 函数名: mutex_lock\n- 参数: [&conn->chan_lock]\n- 调用者: l2cap_get_chan_by_dcid\n- 被调用者: 未显示（系统/内核函数）\n\n3. 函数名: __l2cap_get_chan_by_dcid\n- 参数: [conn, cid]\n- 调用者: l2cap_get_chan_by_dcid\n- 被调用者: 未显示（上下文不足）\n\n4. 函数名: l2cap_chan_lock\n- 参数: [c]\n- 调用者: l2cap_get_chan_by_dcid\n- 被调用者: 未显示（上下文不足）\n\n5. 函数名: mutex_unlock\n- 参数: [&conn->chan_lock]\n- 调用者: l2cap_get_chan_by_dcid\n- 被调用者: 未显示（系统/内核函数）"
    },
    {
        "id": 3387,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20566",
        "purpose": "Code purpose:\"\"\"该代码实现了L2CAP协议中通道移动状态的管理和确认机制，处理不同移动状态下的逻辑链路建立和确认流程。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在l2cap_chan_put函数中存在因不恰当的锁机制导致的释放后使用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_move_continue\n- 参数: [struct l2cap_conn *conn, u16 icid, u16 result]\n- 调用者: 未显示\n- 被调用者: [l2cap_get_chan_by_scid, l2cap_send_move_chan_cfm_icid, __clear_chan_timer, __set_chan_timer, l2cap_send_move_chan_cfm, l2cap_logical_cfm, l2cap_move_done, l2cap_chan_unlock]\n\n2. 函数名: l2cap_get_chan_by_scid\n- 参数: [struct l2cap_conn *conn, u16 icid]\n- 调用者: l2cap_move_continue\n- 被调用者: 未显示\n\n3. 函数名: l2cap_send_move_chan_cfm_icid\n- 参数: [struct l2cap_conn *conn, u16 icid]\n- 调用者: l2cap_move_continue\n- 被调用者: 未显示\n\n4. 函数名: __clear_chan_timer\n- 参数: [struct l2cap_chan *chan]\n- 调用者: l2cap_move_continue\n- 被调用者: 未显示\n\n5. 函数名: __set_chan_timer\n- 参数: [struct l2cap_chan *chan, L2CAP_MOVE_ERTX_TIMEOUT]\n- 调用者: l2cap_move_continue\n- 被调用者: 未显示\n\n6. 函数名: l2cap_send_move_chan_cfm\n- 参数: [struct l2cap_chan *chan, L2CAP_MC_CONFIRMED/L2CAP_MC_UNCONFIRMED]\n- 调用者: l2cap_move_continue\n- 被调用者: 未显示\n\n7. 函数名: l2cap_logical_cfm\n- 参数: [struct l2cap_chan *chan, struct hci_chan *hchan, L2CAP_MR_SUCCESS]\n- 调用者: l2cap_move_continue\n- 被调用者: 未显示\n\n8. 函数名: l2cap_move_done\n- 参数: [struct l2cap_chan *chan]\n- 调用者: l2cap_move_continue\n- 被调用者: 未显示\n\n9. 函数名: l2cap_chan_unlock\n- 参数: [struct l2cap_chan *chan]\n- 调用者: l2cap_move_continue\n- 被调用者: 未显示"
    },
    {
        "id": 3388,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20566",
        "purpose": "Code purpose:\"\"\"处理L2CAP协议中移动通道确认响应的功能，包括验证响应、查找对应通道、清除定时器、更新通道状态等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放通道资源时未正确加锁，导致存在释放后使用的风险\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_move_channel_confirm_rsp\n- 参数: [struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u16 cmd_len, void *data]\n- 调用者: 未显示\n- 被调用者: [le16_to_cpu, l2cap_get_chan_by_scid, __clear_chan_timer, __release_logical_link, l2cap_move_done, l2cap_chan_unlock]\n\n2. 函数名: le16_to_cpu\n- 参数: [rsp->icid]\n- 调用者: l2cap_move_channel_confirm_rsp\n- 被调用者: 未显示\n\n3. 函数名: l2cap_get_chan_by_scid\n- 参数: [conn, icid]\n- 调用者: l2cap_move_channel_confirm_rsp\n- 被调用者: 未显示\n\n4. 函数名: __clear_chan_timer\n- 参数: [chan]\n- 调用者: l2cap_move_channel_confirm_rsp\n- 被调用者: 未显示\n\n5. 函数名: __release_logical_link\n- 参数: [chan]\n- 调用者: l2cap_move_channel_confirm_rsp\n- 被调用者: 未显示\n\n6. 函数名: l2cap_move_done\n- 参数: [chan]\n- 调用者: l2cap_move_channel_confirm_rsp\n- 被调用者: 未显示\n\n7. 函数名: l2cap_chan_unlock\n- 参数: [chan]\n- 调用者: l2cap_move_channel_confirm_rsp\n- 被调用者: 未显示"
    },
    {
        "id": 3389,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20566",
        "purpose": "Code purpose:\"\"\"通过锁定连接和通道来获取指定SCID的L2CAP通道\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放通道资源时未正确加锁，导致存在竞争条件下可能发生释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_get_chan_by_scid\n- 参数: [conn, cid]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [mutex_lock, __l2cap_get_chan_by_scid, l2cap_chan_lock, mutex_unlock]\n\n2. 函数名: mutex_lock\n- 参数: [&conn->chan_lock]\n- 调用者: l2cap_get_chan_by_scid\n- 被调用者: []\n\n3. 函数名: __l2cap_get_chan_by_scid\n- 参数: [conn, cid]\n- 调用者: l2cap_get_chan_by_scid\n- 被调用者: []\n\n4. 函数名: l2cap_chan_lock\n- 参数: [c]\n- 调用者: l2cap_get_chan_by_scid\n- 被调用者: []\n\n5. 函数名: mutex_unlock\n- 参数: [&conn->chan_lock]\n- 调用者: l2cap_get_chan_by_scid\n- 被调用者: []"
    },
    {
        "id": 3390,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20566",
        "purpose": "Code purpose:\"\"\"处理L2CAP协议中的配置响应，包括解析响应数据、更新通道状态以及处理不同的配置结果情况\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在l2cap_chan_put函数中存在因不恰当的锁机制导致的释放后使用(use-after-free)问题\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_config_rsp\n- 参数: [conn, cmd, cmd_len, data]\n- 调用者: 未显示\n- 被调用者: [__le16_to_cpu, BT_DBG, l2cap_get_chan_by_scid, l2cap_conf_rfc_get, clear_bit, set_bit, test_bit, l2cap_parse_conf_rsp, l2cap_send_disconn_req, l2cap_send_efs_conf_rsp, l2cap_check_efs, amp_create_logical_link, l2cap_send_cmd, l2cap_get_ident, l2cap_chan_set_err, __set_chan_timer, set_default_fcs, l2cap_ertm_init, l2cap_chan_ready, l2cap_chan_unlock]\n\n2. 函数名: __le16_to_cpu\n- 参数: [rsp->scid, rsp->flags, rsp->result]\n- 调用者: l2cap_config_rsp\n- 被调用者: 未显示\n\n3. 函数名: BT_DBG\n- 参数: [\"scid 0x%4.4x flags 0x%2.2x result 0x%2.2x len %d\", scid, flags, result, len]\n- 调用者: l2cap_config_rsp\n- 被调用者: 未显示\n\n4. 函数名: l2cap_get_chan_by_scid\n- 参数: [conn, scid]\n- 调用者: l2cap_config_rsp\n- 被调用者: 未显示\n\n5. 函数名: l2cap_conf_rfc_get\n- 参数: [chan, rsp->data, len]\n- 调用者: l2cap_config_rsp\n- 被调用者: 未显示\n\n6. 函数名: clear_bit\n- 参数: [CONF_REM_CONF_PEND, &chan->conf_state]\n- 调用者: l2cap_config_rsp\n- 被调用者: 未显示\n\n7. 函数名: set_bit\n- 参数: [CONF_REM_CONF_PEND, &chan->conf_state], [CONF_INPUT_DONE, &chan->conf_state], [CONF_OUTPUT_DONE, &chan->conf_state]\n- 调用者: l2cap_config_rsp\n- 被调用者: 未显示\n\n8. 函数名: test_bit\n- 参数: [CONF_LOC_CONF_PEND, &chan->conf_state]\n- 调用者: l2cap_config_rsp\n- 被调用者: 未显示\n\n9. 函数名: l2cap_parse_conf_rsp\n- 参数: [chan, rsp->data, len, buf, sizeof(buf), &result], [chan, rsp->data, len, req, sizeof(req), &result]\n- 调用者: l2cap_config_rsp\n- 被调用者: 未显示\n\n10. 函数名: l2cap_send_disconn_req\n- 参数: [chan, ECONNRESET], [chan, -err]\n- 调用者: l2cap_config_rsp\n- 被调用者: 未显示\n\n11. 函数名: l2cap_send_efs_conf_rsp\n- 参数: [chan, buf, cmd->ident, 0]\n- 调用者: l2cap_config_rsp\n- 被调用者: 未显示\n\n12. 函数名: l2cap_check_efs\n- 参数: [chan]\n- 调用者: l2cap_config_rsp\n- 被调用者: 未显示\n\n13. 函数名: amp_create_logical_link\n- 参数: [chan]\n- 调用者: l2cap_config_rsp\n- 被调用者: 未显示\n\n14. 函数名: l2cap_send_cmd\n- 参数: [conn, l2cap_get_ident(conn), L2CAP_CONF_REQ, len, req]\n- 调用者: l2cap_config_rsp\n- 被调用者: 未显示\n\n15. 函数名: l2cap_get_ident\n- 参数: [conn]\n- 调用者: l2cap_config_rsp\n- 被调用者: 未显示\n\n16. 函数名: l2cap_chan_set_err\n- 参数: [chan, ECONNRESET]\n- 调用者: l2cap_config_rsp\n- 被调用者: 未显示\n\n17. 函数名: __set_chan_timer\n- 参数: [chan, L2CAP_DISC_REJ_TIMEOUT]\n- 调用者: l2cap_config_rsp\n- 被调用者: 未显示\n\n18. 函数名: set_default_fcs\n- 参数: [chan]\n- 调用者: l2cap_config_rsp\n- 被调用者: 未显示\n\n19. 函数名: l2cap_ertm_init\n- 参数: [chan]\n- 调用者: l2cap_config_rsp\n- 被调用者: 未显示\n\n20. 函数名: l2cap_chan_ready\n- 参数: [chan]\n- 调用者: l2cap_config_rsp\n- 被调用者: 未显示\n\n21. 函数名: l2cap_chan_unlock\n- 参数: [chan]\n- 调用者: l2cap_config_rsp\n- 被调用者: 未显示"
    },
    {
        "id": 3391,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20566",
        "purpose": "Code purpose:\"\"\"处理L2CAP协议中通道移动请求，验证请求参数并决定是否允许通道移动，最终发送响应结果\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放l2cap_chan结构体时未正确加锁，导致存在释放后使用(UAF)的风险\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_move_channel_req\n- 参数: [struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u16 cmd_len, void *data]\n- 调用者: 未显示\n- 被调用者: [le16_to_cpu, l2cap_get_chan_by_dcid, l2cap_send_cmd, hci_dev_get, hci_dev_put, __chan_is_moving, bacmp, l2cap_move_setup, l2cap_send_move_chan_rsp, l2cap_chan_unlock]\n\n2. 函数名: le16_to_cpu\n- 参数: [req->icid]\n- 调用者: l2cap_move_channel_req\n- 被调用者: 未显示\n\n3. 函数名: l2cap_get_chan_by_dcid\n- 参数: [conn, icid]\n- 调用者: l2cap_move_channel_req\n- 被调用者: 未显示\n\n4. 函数名: l2cap_send_cmd\n- 参数: [conn, cmd->ident, L2CAP_MOVE_CHAN_RSP, sizeof(rsp), &rsp]\n- 调用者: l2cap_move_channel_req\n- 被调用者: 未显示\n\n5. 函数名: hci_dev_get\n- 参数: [req->dest_amp_id]\n- 调用者: l2cap_move_channel_req\n- 被调用者: 未显示\n\n6. 函数名: hci_dev_put\n- 参数: [hdev]\n- 调用者: l2cap_move_channel_req\n- 被调用者: 未显示\n\n7. 函数名: __chan_is_moving\n- 参数: [chan]\n- 调用者: l2cap_move_channel_req\n- 被调用者: 未显示\n\n8. 函数名: bacmp\n- 参数: [&conn->hcon->src, &conn->hcon->dst]\n- 调用者: l2cap_move_channel_req\n- 被调用者: 未显示\n\n9. 函数名: l2cap_move_setup\n- 参数: [chan]\n- 调用者: l2cap_move_channel_req\n- 被调用者: 未显示\n\n10. 函数名: l2cap_send_move_chan_rsp\n- 参数: [chan, result]\n- 调用者: l2cap_move_channel_req\n- 被调用者: 未显示\n\n11. 函数名: l2cap_chan_unlock\n- 参数: [chan]\n- 调用者: l2cap_move_channel_req\n- 被调用者: 未显示"
    },
    {
        "id": 3392,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20566",
        "purpose": "Code purpose:\"\"\"通过标识符获取L2CAP通道并加锁，确保在多线程环境下的安全访问\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在获取通道后未正确维持锁定状态，导致可能在使用已被释放的内存时出现竞争条件\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_get_chan_by_ident\n- 参数: [conn, ident]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [mutex_lock, __l2cap_get_chan_by_ident, l2cap_chan_lock, mutex_unlock]\n\n2. 函数名: mutex_lock\n- 参数: [&conn->chan_lock]\n- 调用者: l2cap_get_chan_by_ident\n- 被调用者: []\n\n3. 函数名: __l2cap_get_chan_by_ident\n- 参数: [conn, ident]\n- 调用者: l2cap_get_chan_by_ident\n- 被调用者: []\n\n4. 函数名: l2cap_chan_lock\n- 参数: [c]\n- 调用者: l2cap_get_chan_by_ident\n- 被调用者: []\n\n5. 函数名: mutex_unlock\n- 参数: [&conn->chan_lock]\n- 调用者: l2cap_get_chan_by_ident\n- 被调用者: []"
    },
    {
        "id": 3393,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20566",
        "purpose": "Code purpose:\"\"\"该代码用于在全局固定通道列表中查找匹配特定条件的L2CAP通道\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放l2cap_chan结构体时存在不恰当的锁保护，导致可能在使用已被释放的内存(use-after-free)。\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_global_fixed_chan\n- 参数: [struct l2cap_chan *c, struct hci_conn *hcon]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [bdaddr_src_type, read_lock, list_next_entry, list_entry, list_for_each_entry_from, bacmp, l2cap_chan_hold, read_unlock]\n\n2. 函数名: bdaddr_src_type\n- 参数: [struct hci_conn *hcon]\n- 调用者: l2cap_global_fixed_chan\n- 被调用者: 未明确\n\n3. 函数名: read_lock\n- 参数: [&chan_list_lock]\n- 调用者: l2cap_global_fixed_chan\n- 被调用者: 未明确\n\n4. 函数名: list_next_entry\n- 参数: [c, global_l]\n- 调用者: l2cap_global_fixed_chan\n- 被调用者: 未明确\n\n5. 函数名: list_entry\n- 参数: [chan_list.next, typeof(*c), global_l]\n- 调用者: l2cap_global_fixed_chan\n- 被调用者: 未明确\n\n6. 函数名: list_for_each_entry_from\n- 参数: [c, &chan_list, global_l]\n- 调用者: l2cap_global_fixed_chan\n- 被调用者: 未明确\n\n7. 函数名: bacmp\n- 参数: [&c->src, &hcon->src], [&c->src, BDADDR_ANY]\n- 调用者: l2cap_global_fixed_chan\n- 被调用者: 未明确\n\n8. 函数名: l2cap_chan_hold\n- 参数: [c]\n- 调用者: l2cap_global_fixed_chan\n- 被调用者: 未明确\n\n9. 函数名: read_unlock\n- 参数: [&chan_list_lock]\n- 调用者: l2cap_global_fixed_chan\n- 被调用者: 未明确"
    },
    {
        "id": 3394,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20566",
        "purpose": "Code purpose:\"\"\"通过遍历全局通道列表并根据PSM、地址和链接类型匹配来查找并返回符合条件的L2CAP通道\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放l2cap_chan结构体时未正确加锁，导致存在释放后使用(UAF)的风险\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_global_chan_by_psm\n- 参数: [state, psm, src, dst, link_type]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [read_lock, list_for_each_entry, bacmp, l2cap_chan_hold, read_unlock]\n\n2. 函数名: read_lock\n- 参数: [&chan_list_lock]\n- 调用者: l2cap_global_chan_by_psm\n- 被调用者: 未明确（系统/内核函数）\n\n3. 函数名: list_for_each_entry\n- 参数: [c, &chan_list, global_l]\n- 调用者: l2cap_global_chan_by_psm\n- 被调用者: 未明确（内核链表宏）\n\n4. 函数名: bacmp\n- 参数: [&c->src, src], [&c->dst, dst], [&c->src, BDADDR_ANY], [&c->dst, BDADDR_ANY]\n- 调用者: l2cap_global_chan_by_psm\n- 被调用者: 未明确（蓝牙地址比较函数）\n\n5. 函数名: l2cap_chan_hold\n- 参数: [c], [c1]\n- 调用者: l2cap_global_chan_by_psm\n- 被调用者: 未明确（引用计数增加函数）\n\n6. 函数名: read_unlock\n- 参数: [&chan_list_lock]\n- 调用者: l2cap_global_chan_by_psm\n- 被调用者: 未明确（系统/内核函数）"
    },
    {
        "id": 3395,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20566",
        "purpose": "Code purpose:\"\"\"处理L2CAP协议中通道移动确认请求，包括验证请求、更新通道状态并发送响应\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放通道(chan)后未正确保持锁状态，导致可能在使用已被释放的内存(use-after-free)。\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_move_channel_confirm\n- 参数: [struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u16 cmd_len, void *data]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [le16_to_cpu, BT_DBG, l2cap_get_chan_by_dcid, l2cap_send_move_chan_cfm_rsp, __release_logical_link, l2cap_move_done, l2cap_chan_unlock]\n\n2. 函数名: le16_to_cpu\n- 参数: [u16]\n- 调用者: l2cap_move_channel_confirm\n- 被调用者: []\n\n3. 函数名: BT_DBG\n- 参数: [const char *format, ...]\n- 调用者: l2cap_move_channel_confirm\n- 被调用者: []\n\n4. 函数名: l2cap_get_chan_by_dcid\n- 参数: [struct l2cap_conn *conn, u16 dcid]\n- 调用者: l2cap_move_channel_confirm\n- 被调用者: []\n\n5. 函数名: l2cap_send_move_chan_cfm_rsp\n- 参数: [struct l2cap_conn *conn, u8 ident, u16 icid]\n- 调用者: l2cap_move_channel_confirm\n- 被调用者: []\n\n6. 函数名: __release_logical_link\n- 参数: [struct l2cap_chan *chan]\n- 调用者: l2cap_move_channel_confirm\n- 被调用者: []\n\n7. 函数名: l2cap_move_done\n- 参数: [struct l2cap_chan *chan]\n- 调用者: l2cap_move_channel_confirm\n- 被调用者: []\n\n8. 函数名: l2cap_chan_unlock\n- 参数: [struct l2cap_chan *chan]\n- 调用者: l2cap_move_channel_confirm\n- 被调用者: []"
    },
    {
        "id": 3396,
        "cwe": "CWE-416",
        "cve": "CVE-2022-20566",
        "purpose": "Code purpose:\"\"\"该代码用于处理L2CAP通道移动失败的情况，包括清理定时器、处理移动角色变更以及发送确认消息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放通道资源前未正确加锁，导致存在竞争条件下可能发生释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_move_fail\n- 参数: [conn, ident, icid, result]\n- 调用者: 未提供\n- 被调用者: [l2cap_get_chan_by_ident, l2cap_send_move_chan_cfm_icid, __clear_chan_timer, l2cap_move_done, l2cap_send_move_chan_cfm, l2cap_chan_unlock]\n\n2. 函数名: l2cap_get_chan_by_ident\n- 参数: [conn, ident]\n- 调用者: l2cap_move_fail\n- 被调用者: 未提供\n\n3. 函数名: l2cap_send_move_chan_cfm_icid\n- 参数: [conn, icid]\n- 调用者: l2cap_move_fail\n- 被调用者: 未提供\n\n4. 函数名: __clear_chan_timer\n- 参数: [chan]\n- 调用者: l2cap_move_fail\n- 被调用者: 未提供\n\n5. 函数名: l2cap_move_done\n- 参数: [chan]\n- 调用者: l2cap_move_fail\n- 被调用者: 未提供\n\n6. 函数名: l2cap_send_move_chan_cfm\n- 参数: [chan, L2CAP_MC_UNCONFIRMED]\n- 调用者: l2cap_move_fail\n- 被调用者: 未提供\n\n7. 函数名: l2cap_chan_unlock\n- 参数: [chan]\n- 调用者: l2cap_move_fail\n- 被调用者: 未提供"
    },
    {
        "id": 3416,
        "cwe": "CWE-416",
        "cve": "CVE-2022-22942",
        "purpose": "Code purpose:\"\"\"处理虚拟机图形设备的命令缓冲区执行，包括命令验证、资源绑定、栅栏创建和同步文件处理等功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于vmwgfx驱动中存在悬垂的'file'指针，未正确清理或保护，导致非特权用户可以通过该指针访问其他进程打开的文件\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_execbuf_process\n- 参数: [struct drm_file *file_priv, struct vmw_private *dev_priv, void __user *user_commands, void *kernel_commands, uint32_t command_size, uint64_t throttle_us, uint32_t dx_context_handle, struct drm_vmw_fence_rep __user *user_fence_rep, struct vmw_fence_obj **out_fence, uint32_t flags]\n- 调用者: N/A (top-level function)\n- 被调用者: [get_unused_fd_flags, vmw_execbuf_cmdbuf, mutex_lock_interruptible, vmw_resize_cmd_bounce, copy_from_user, vmw_fpriv, vmw_binding_state_reset, vmwgfx_ht_create, vmw_execbuf_tie_context, vmw_cmd_check_all, vmw_resources_reserve, vmw_validation_bo_reserve, vmw_validation_bo_validate, vmw_validation_res_validate, vmw_validation_drop_ht, vmw_rebind_contexts, vmw_execbuf_submit_fifo, vmw_execbuf_submit_cmdbuf, vmw_query_bo_switch_commit, vmw_execbuf_fence_commands, vmw_execbuf_bindings_commit, vmw_bind_dx_query_mob, vmw_validation_res_unreserve, vmw_validation_bo_fence, __vmw_execbuf_release_pinned_bo, sync_file_create, put_unused_fd, vmw_fence_obj_wait, fd_install, vmw_execbuf_copy_fence_user, vmw_fence_obj_unreference, vmw_cmdbuf_res_commit, vmw_validation_unref_lists, vmw_cmdbuf_header_free, vmw_resource_relocations_free, vmw_free_relocations, vmw_cmdbuf_res_revert]\n\n2. 函数名: vmw_execbuf_cmdbuf\n- 参数: [struct vmw_private *dev_priv, void __user *user_commands, void *kernel_commands, uint32_t command_size, struct vmw_cmdbuf_header **header]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n3. 函数名: vmw_resize_cmd_bounce\n- 参数: [struct vmw_sw_context *sw_context, uint32_t command_size]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n4. 函数名: vmw_execbuf_tie_context\n- 参数: [struct vmw_private *dev_priv, struct vmw_sw_context *sw_context, uint32_t dx_context_handle]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n5. 函数名: vmw_cmd_check_all\n- 参数: [struct vmw_private *dev_priv, struct vmw_sw_context *sw_context, void *kernel_commands, uint32_t command_size]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n6. 函数名: vmw_resources_reserve\n- 参数: [struct vmw_sw_context *sw_context]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n7. 函数名: vmw_validation_bo_reserve\n- 参数: [struct vmw_validation_context *val_ctx, bool interruptible]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n8. 函数名: vmw_validation_bo_validate\n- 参数: [struct vmw_validation_context *val_ctx, bool interruptible]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n9. 函数名: vmw_validation_res_validate\n- 参数: [struct vmw_validation_context *val_ctx, bool interruptible]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n10. 函数名: vmw_validation_drop_ht\n- 参数: [struct vmw_validation_context *val_ctx]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n11. 函数名: vmw_rebind_contexts\n- 参数: [struct vmw_sw_context *sw_context]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n12. 函数名: vmw_execbuf_submit_fifo\n- 参数: [struct vmw_private *dev_priv, void *kernel_commands, uint32_t command_size, struct vmw_sw_context *sw_context]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n13. 函数名: vmw_execbuf_submit_cmdbuf\n- 参数: [struct vmw_private *dev_priv, struct vmw_cmdbuf_header *header, uint32_t command_size, struct vmw_sw_context *sw_context]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n14. 函数名: vmw_query_bo_switch_commit\n- 参数: [struct vmw_private *dev_priv, struct vmw_sw_context *sw_context]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n15. 函数名: vmw_execbuf_fence_commands\n- 参数: [struct drm_file *file_priv, struct vmw_private *dev_priv, struct vmw_fence_obj **fence, uint32_t *handle]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n16. 函数名: vmw_execbuf_bindings_commit\n- 参数: [struct vmw_sw_context *sw_context, bool backoff]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n17. 函数名: vmw_bind_dx_query_mob\n- 参数: [struct vmw_sw_context *sw_context]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n18. 函数名: vmw_validation_res_unreserve\n- 参数: [struct vmw_validation_context *val_ctx, bool backoff]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n19. 函数名: vmw_validation_bo_fence\n- 参数: [struct vmw_validation_context *val_ctx, struct vmw_fence_obj *fence]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n20. 函数名: __vmw_execbuf_release_pinned_bo\n- 参数: [struct vmw_private *dev_priv, struct vmw_fence_obj *fence]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n21. 函数名: vmw_execbuf_copy_fence_user\n- 参数: [struct vmw_private *dev_priv, struct vmw_fpriv *vmw_fp, int ret, struct drm_vmw_fence_rep __user *user_fence_rep, struct vmw_fence_obj *fence, uint32_t handle, int32_t out_fence_fd, struct sync_file *sync_file]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n22. 函数名: vmw_cmdbuf_res_commit\n- 参数: [struct list_head *list]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n23. 函数名: vmw_validation_unref_lists\n- 参数: [struct vmw_validation_context *val_ctx]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n24. 函数名: vmw_cmdbuf_header_free\n- 参数: [struct vmw_cmdbuf_header *header]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n25. 函数名: vmw_resource_relocations_free\n- 参数: [struct list_head *list]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n26. 函数名: vmw_free_relocations\n- 参数: [struct vmw_sw_context *sw_context]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A\n\n27. 函数名: vmw_cmdbuf_res_revert\n- 参数: [struct list_head *list]\n- 调用者: vmw_execbuf_process\n- 被调用者: N/A"
    },
    {
        "id": 3417,
        "cwe": "CWE-416",
        "cve": "CVE-2022-22942",
        "purpose": "Code purpose:\"\"\"处理虚拟机图形驱动中的围栏事件IOCTL请求，包括查找或创建围栏对象、管理引用计数以及将围栏信息复制回用户空间。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码中存在对已释放的'file'指针的引用，导致可利用悬垂指针获取其他进程打开的文件访问权限。\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_fence_event_ioctl\n- 参数: [struct drm_device *dev, void *data, struct drm_file *file_priv]\n- 调用者: 外部调用（IOCTL处理）\n- 被调用者: [vmw_priv, vmw_fpriv, vmw_fence_obj_lookup, container_of, vmw_fence_obj_reference, ttm_ref_object_add, ttm_base_object_unref, vmw_execbuf_fence_commands, vmw_event_fence_action_create, vmw_execbuf_copy_fence_user, vmw_fence_obj_unreference, ttm_ref_object_base_unref]\n\n2. 函数名: vmw_priv\n- 参数: [struct drm_device *dev]\n- 调用者: vmw_fence_event_ioctl\n- 被调用者: []\n\n3. 函数名: vmw_fpriv\n- 参数: [struct drm_file *file_priv]\n- 调用者: vmw_fence_event_ioctl\n- 被调用者: []\n\n4. 函数名: vmw_fence_obj_lookup\n- 参数: [struct ttm_object_file *tfile, uint32_t handle]\n- 调用者: vmw_fence_event_ioctl\n- 被调用者: []\n\n5. 函数名: container_of\n- 参数: [struct ttm_base_object *base, struct vmw_user_fence, member]\n- 调用者: vmw_fence_event_ioctl\n- 被调用者: []\n\n6. 函数名: vmw_fence_obj_reference\n- 参数: [struct vmw_fence_obj *fence]\n- 调用者: vmw_fence_event_ioctl\n- 被调用者: []\n\n7. 函数名: ttm_ref_object_add\n- 参数: [struct ttm_object_file *tfile, struct ttm_base_object *base, NULL, bool]\n- 调用者: vmw_fence_event_ioctl\n- 被调用者: []\n\n8. 函数名: ttm_base_object_unref\n- 参数: [struct ttm_base_object **base]\n- 调用者: vmw_fence_event_ioctl\n- 被调用者: []\n\n9. 函数名: vmw_execbuf_fence_commands\n- 参数: [struct drm_file *file_priv, struct vmw_private *dev_priv, struct vmw_fence_obj **fence, uint32_t *handle]\n- 调用者: vmw_fence_event_ioctl\n- 被调用者: []\n\n10. 函数名: vmw_event_fence_action_create\n- 参数: [struct drm_file *file_priv, struct vmw_fence_obj *fence, uint32_t flags, uint64_t user_data, bool]\n- 调用者: vmw_fence_event_ioctl\n- 被调用者: []\n\n11. 函数名: vmw_execbuf_copy_fence_user\n- 参数: [struct vmw_private *dev_priv, struct vmw_fpriv *vmw_fp, int ret, struct drm_vmw_fence_rep __user *user_fence_rep, struct vmw_fence_obj *fence, uint32_t handle, int, NULL]\n- 调用者: vmw_fence_event_ioctl\n- 被调用者: []\n\n12. 函数名: vmw_fence_obj_unreference\n- 参数: [struct vmw_fence_obj **fence]\n- 调用者: vmw_fence_event_ioctl\n- 被调用者: []\n\n13. 函数名: ttm_ref_object_base_unref\n- 参数: [struct ttm_object_file *tfile, uint32_t handle]\n- 调用者: vmw_fence_event_ioctl\n- 被调用者: []"
    },
    {
        "id": 3418,
        "cwe": "CWE-416",
        "cve": "CVE-2022-22942",
        "purpose": "Code purpose:\"\"\"该代码用于在虚拟机图形驱动中完成验证操作并处理相关的围栏对象，包括创建、复制和释放围栏对象。\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码中存在悬垂指针问题，未正确管理文件指针的生命周期，导致攻击者可能通过该指针访问其他进程已打开的文件。\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_kms_helper_validation_finish\n- 参数: [dev_priv, file_priv, ctx, out_fence, user_fence_rep]\n- 调用者: N/A\n- 被调用者: [vmw_execbuf_fence_commands, vmw_validation_done, vmw_execbuf_copy_fence_user, vmw_fpriv, vmw_fence_obj_unreference]\n\n2. 函数名: vmw_execbuf_fence_commands\n- 参数: [file_priv, dev_priv, fence, handle]\n- 调用者: vmw_kms_helper_validation_finish\n- 被调用者: N/A\n\n3. 函数名: vmw_validation_done\n- 参数: [ctx, fence]\n- 调用者: vmw_kms_helper_validation_finish\n- 被调用者: N/A\n\n4. 函数名: vmw_execbuf_copy_fence_user\n- 参数: [dev_priv, vmw_fpriv(file_priv), ret, user_fence_rep, fence, handle, -1, NULL]\n- 调用者: vmw_kms_helper_validation_finish\n- 被调用者: N/A\n\n5. 函数名: vmw_fpriv\n- 参数: [file_priv]\n- 调用者: vmw_kms_helper_validation_finish\n- 被调用者: N/A\n\n6. 函数名: vmw_fence_obj_unreference\n- 参数: [fence]\n- 调用者: vmw_kms_helper_validation_finish\n- 被调用者: N/A"
    },
    {
        "id": 3428,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2318",
        "purpose": "Code purpose:\"\"\"该代码用于启动ROSE协议的T2定时器，设置定时器到期处理函数和到期时间，并将其添加到内核定时器队列中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在删除定时器后未正确清理或保护相关资源，导致定时器处理程序可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: rose_start_t2timer\n- 参数: [sk]\n- 调用者: 未提供\n- 被调用者: [rose_sk, del_timer, add_timer]\n\n2. 函数名: rose_sk\n- 参数: [sk]\n- 调用者: rose_start_t2timer\n- 被调用者: 未提供\n\n3. 函数名: del_timer\n- 参数: [&rose->timer]\n- 调用者: rose_start_t2timer\n- 被调用者: 未提供\n\n4. 函数名: add_timer\n- 参数: [&rose->timer]\n- 调用者: rose_start_t2timer\n- 被调用者: 未提供"
    },
    {
        "id": 3429,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2318",
        "purpose": "Code purpose:\"\"\"该代码用于启动或重置ROSE协议套接字的空闲定时器，在指定空闲时间后触发超时处理函数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在删除定时器后未正确清理相关资源，导致定时器处理程序可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: rose_start_idletimer\n- 参数: [sk]\n- 调用者: 未提供\n- 被调用者: [rose_sk, del_timer, add_timer]\n\n2. 函数名: rose_sk\n- 参数: [sk]\n- 调用者: rose_start_idletimer\n- 被调用者: 未提供\n\n3. 函数名: del_timer\n- 参数: [&rose->idletimer]\n- 调用者: rose_start_idletimer\n- 被调用者: 未提供\n\n4. 函数名: add_timer\n- 参数: [&rose->idletimer]\n- 调用者: rose_start_idletimer\n- 被调用者: 未提供\n\n5. 函数名: rose_idletimer_expiry\n- 参数: 未提供\n- 调用者: 通过函数指针调用\n- 被调用者: 未提供"
    },
    {
        "id": 3430,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2318",
        "purpose": "Code purpose:\"\"\"该代码用于启动ROSE协议的T1定时器，设置定时器到期时的处理函数和到期时间，并将其添加到内核定时器队列中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在删除定时器后未正确清理或保护相关资源，导致定时器处理程序可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: rose_start_t1timer\n- 参数: [struct sock *sk]\n- 调用者: 未指定\n- 被调用者: [rose_sk, del_timer, add_timer]\n\n2. 函数名: rose_sk\n- 参数: [struct sock *sk]\n- 调用者: rose_start_t1timer\n- 被调用者: 未指定\n\n3. 函数名: del_timer\n- 参数: [&rose->timer]\n- 调用者: rose_start_t1timer\n- 被调用者: 未指定\n\n4. 函数名: add_timer\n- 参数: [&rose->timer]\n- 调用者: rose_start_t1timer\n- 被调用者: 未指定\n\n5. 函数名: rose_timer_expiry\n- 参数: 未指定\n- 调用者: 通过函数指针调用\n- 被调用者: 未指定"
    },
    {
        "id": 3431,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2318",
        "purpose": "Code purpose:\"\"\"该代码用于启动ROSE协议的定时器，设置定时器到期时的处理函数和到期时间\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在删除定时器后未正确检查或处理定时器结构体的使用，导致释放后重用(UAF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: rose_start_hbtimer\n- 参数: [struct sock *sk]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [rose_sk, del_timer, add_timer]\n\n2. 函数名: rose_sk\n- 参数: [struct sock *sk]\n- 调用者: rose_start_hbtimer\n- 被调用者: []\n\n3. 函数名: del_timer\n- 参数: [&rose->timer]\n- 调用者: rose_start_hbtimer\n- 被调用者: []\n\n4. 函数名: add_timer\n- 参数: [&rose->timer]\n- 调用者: rose_start_hbtimer\n- 被调用者: []\n\n5. 函数名: rose_timer_expiry\n- 参数: 未明确（作为函数指针赋值）\n- 调用者: 未明确（由定时器触发）\n- 被调用者: []"
    },
    {
        "id": 3432,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2318",
        "purpose": "Code purpose:\"\"\"该代码用于处理ROSE协议中的心跳超时事件，管理套接字状态并处理接收缓冲区条件，但存在释放后使用漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在rose_heartbeat_expiry函数中，由于定时器处理程序未能正确管理套接字引用计数，导致在释放套接字后仍可能被访问，从而引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: rose_heartbeat_expiry\n- 参数: [struct timer_list *t]\n- 调用者: timer handler\n- 被调用者: [bh_lock_sock, sock_flag, bh_unlock_sock, rose_destroy_socket, atomic_read, rose_write_internal, rose_stop_timer, rose_start_heartbeat]\n\n2. 函数名: bh_lock_sock\n- 参数: [struct sock *sk]\n- 调用者: rose_heartbeat_expiry\n- 被调用者: []\n\n3. 函数名: sock_flag\n- 参数: [struct sock *sk, int flag]\n- 调用者: rose_heartbeat_expiry\n- 被调用者: []\n\n4. 函数名: bh_unlock_sock\n- 参数: [struct sock *sk]\n- 调用者: rose_heartbeat_expiry\n- 被调用者: []\n\n5. 函数名: rose_destroy_socket\n- 参数: [struct sock *sk]\n- 调用者: rose_heartbeat_expiry\n- 被调用者: []\n\n6. 函数名: atomic_read\n- 参数: [atomic_t *v]\n- 调用者: rose_heartbeat_expiry\n- 被调用者: []\n\n7. 函数名: rose_write_internal\n- 参数: [struct sock *sk, int frametype]\n- 调用者: rose_heartbeat_expiry\n- 被调用者: []\n\n8. 函数名: rose_stop_timer\n- 参数: [struct sock *sk]\n- 调用者: rose_heartbeat_expiry\n- 被调用者: []\n\n9. 函数名: rose_start_heartbeat\n- 参数: [struct sock *sk]\n- 调用者: rose_heartbeat_expiry\n- 被调用者: []"
    },
    {
        "id": 3433,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2318",
        "purpose": "Code purpose:\"\"\"该代码用于启动ROSE协议的定时心跳功能，通过设置定时器来定期触发心跳超时处理函数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在删除定时器后未正确清理或保护相关资源，导致定时器处理程序可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: rose_start_heartbeat\n- 参数: [struct sock *sk]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [del_timer, add_timer]\n\n2. 函数名: del_timer\n- 参数: [&sk->sk_timer]\n- 调用者: rose_start_heartbeat\n- 被调用者: []\n\n3. 函数名: add_timer\n- 参数: [&sk->sk_timer]\n- 调用者: rose_start_heartbeat\n- 被调用者: []\n\n4. 函数名: rose_heartbeat_expiry\n- 参数: 未明确（通过函数指针设置）\n- 调用者: 通过sk->sk_timer.function调用\n- 被调用者: []"
    },
    {
        "id": 3434,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2318",
        "purpose": "Code purpose:\"\"\"该代码片段用于停止ROSE协议的套接字心跳定时器\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在删除定时器时未正确处理套接字对象的引用计数，导致定时器处理程序可能访问已被释放的内存\"\"\"",
        "functions": "Functions:\n1. 函数名: rose_stop_heartbeat\n- 参数: [struct sock *sk]\n- 调用者: 未提供\n- 被调用者: [del_timer]\n\n2. 函数名: del_timer\n- 参数: [&sk->sk_timer]\n- 调用者: rose_stop_heartbeat\n- 被调用者: 未提供"
    },
    {
        "id": 3435,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2318",
        "purpose": "Code purpose:\"\"\"该代码片段用于删除与指定socket关联的rose协议空闲定时器\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在删除rose套接字的空闲定时器时，未正确处理定时器与套接字之间的引用关系，导致定时器处理程序可能访问已释放的内存\"\"\"",
        "functions": "Functions:\n1. 函数名: rose_stop_idletimer\n- 参数: [sk]\n- 调用者: 未提供\n- 被调用者: [del_timer, rose_sk]\n\n2. 函数名: del_timer\n- 参数: [&rose_sk(sk)->idletimer]\n- 调用者: rose_stop_idletimer\n- 被调用者: 未提供\n\n3. 函数名: rose_sk\n- 参数: [sk]\n- 调用者: rose_stop_idletimer\n- 被调用者: 未提供"
    },
    {
        "id": 3436,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2318",
        "purpose": "Code purpose:\"\"\"该代码用于处理ROSE协议套接字的空闲定时器到期事件，包括清除队列、发送清除请求、更新套接字状态并关闭连接。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在定时器处理程序中存在释放后使用漏洞，当处理空闲定时器到期时可能导致对已释放的sock结构体的访问。\"\"\"",
        "functions": "Functions:\n1. 函数名: rose_idletimer_expiry\n- 参数: [struct timer_list *t]\n- 调用者: 定时器回调\n- 被调用者: [from_timer, bh_lock_sock, rose_clear_queues, rose_write_internal, rose_sk, rose_start_t3timer, sock_flag, sk->sk_state_change, sock_set_flag, bh_unlock_sock]\n\n2. 函数名: from_timer\n- 参数: [rose, t, idletimer]\n- 调用者: rose_idletimer_expiry\n- 被调用者: []\n\n3. 函数名: bh_lock_sock\n- 参数: [sk]\n- 调用者: rose_idletimer_expiry\n- 被调用者: []\n\n4. 函数名: rose_clear_queues\n- 参数: [sk]\n- 调用者: rose_idletimer_expiry\n- 被调用者: []\n\n5. 函数名: rose_write_internal\n- 参数: [sk, ROSE_CLEAR_REQUEST]\n- 调用者: rose_idletimer_expiry\n- 被调用者: []\n\n6. 函数名: rose_sk\n- 参数: [sk]\n- 调用者: rose_idletimer_expiry\n- 被调用者: []\n\n7. 函数名: rose_start_t3timer\n- 参数: [sk]\n- 调用者: rose_idletimer_expiry\n- 被调用者: []\n\n8. 函数名: sock_flag\n- 参数: [sk, SOCK_DEAD]\n- 调用者: rose_idletimer_expiry\n- 被调用者: []\n\n9. 函数名: sk->sk_state_change\n- 参数: [sk]\n- 调用者: rose_idletimer_expiry\n- 被调用者: []\n\n10. 函数名: sock_set_flag\n- 参数: [sk, SOCK_DEAD]\n- 调用者: rose_idletimer_expiry\n- 被调用者: []\n\n11. 函数名: bh_unlock_sock\n- 参数: [sk]\n- 调用者: rose_idletimer_expiry\n- 被调用者: []"
    },
    {
        "id": 3437,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2318",
        "purpose": "Code purpose:\"\"\"该代码用于启动ROSE协议的T3定时器，设置定时器到期时的处理函数和到期时间，并将其添加到内核定时器队列中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在删除定时器后未正确检查或处理定时器结构体的使用，导致可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: rose_start_t3timer\n- 参数: [struct sock *sk]\n- 调用者: 未指定\n- 被调用者: [rose_sk, del_timer, add_timer]\n\n2. 函数名: rose_sk\n- 参数: [struct sock *sk]\n- 调用者: rose_start_t3timer\n- 被调用者: 未指定\n\n3. 函数名: del_timer\n- 参数: [struct timer_list *timer]\n- 调用者: rose_start_t3timer\n- 被调用者: 未指定\n\n4. 函数名: add_timer\n- 参数: [struct timer_list *timer]\n- 调用者: rose_start_t3timer\n- 被调用者: 未指定\n\n5. 函数名: rose_timer_expiry\n- 参数: 未指定\n- 调用者: 通过函数指针调用\n- 被调用者: 未指定"
    },
    {
        "id": 3438,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2318",
        "purpose": "Code purpose:\"\"\"该代码用于停止与ROSE协议套接字相关的定时器\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在rose_stop_timer函数中，由于未正确处理定时器与套接字对象之间的生命周期关系，导致定时器处理程序可能访问已被释放的内存区域，从而引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: rose_stop_timer\n- 参数: [struct sock *sk]\n- 调用者: 未提供\n- 被调用者: [del_timer, rose_sk]\n\n2. 函数名: del_timer\n- 参数: [未提供(但应为timer结构体指针)]\n- 调用者: rose_stop_timer\n- 被调用者: 未提供\n\n3. 函数名: rose_sk\n- 参数: [struct sock *sk]\n- 调用者: rose_stop_timer\n- 被调用者: 未提供"
    },
    {
        "id": 3439,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2318",
        "purpose": "Code purpose:\"\"\"该代码用于处理ROSE协议中不同状态下的定时器到期事件，包括发送清除请求、断开连接和处理确认等待等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在rose_timer_expiry函数中，当处理ROSE_STATE_2状态时，释放了rose->neighbour资源后仍可能被后续代码访问，导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: rose_timer_expiry\n- 参数: [struct timer_list *t]\n- 调用者: 定时器回调\n- 被调用者: [from_timer, bh_lock_sock, rose_write_internal, rose_start_t3timer, rose_disconnect, rose_enquiry_response, bh_unlock_sock]\n\n2. 函数名: from_timer\n- 参数: [rose, t, timer]\n- 调用者: rose_timer_expiry\n- 被调用者: []\n\n3. 函数名: bh_lock_sock\n- 参数: [struct sock *sk]\n- 调用者: rose_timer_expiry\n- 被调用者: []\n\n4. 函数名: rose_write_internal\n- 参数: [struct sock *sk, ROSE_CLEAR_REQUEST]\n- 调用者: rose_timer_expiry\n- 被调用者: []\n\n5. 函数名: rose_start_t3timer\n- 参数: [struct sock *sk]\n- 调用者: rose_timer_expiry\n- 被调用者: []\n\n6. 函数名: rose_disconnect\n- 参数: [struct sock *sk, ETIMEDOUT, -1, -1]\n- 调用者: rose_timer_expiry\n- 被调用者: []\n\n7. 函数名: rose_enquiry_response\n- 参数: [struct sock *sk]\n- 调用者: rose_timer_expiry\n- 被调用者: []\n\n8. 函数名: bh_unlock_sock\n- 参数: [struct sock *sk]\n- 调用者: rose_timer_expiry\n- 被调用者: []"
    },
    {
        "id": 3470,
        "cwe": "CWE-416",
        "cve": "CVE-2022-24122",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中分配和管理用户命名空间的引用计数对象(ucounts)，确保每个用户命名空间和用户ID组合有唯一的引用计数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当ucounts对象在其命名空间被释放后仍被使用时，会导致use-after-free漏洞，从而可能引发权限提升。\"\"\"",
        "functions": "Functions:\n1. 函数名: alloc_ucounts\n- 参数: [struct user_namespace *ns, kuid_t uid]\n- 调用者: N/A (顶级函数)\n- 被调用者: [ucounts_hashentry, find_ucounts, kzalloc, atomic_set, kfree, hlist_add_head, get_ucounts_or_wrap, put_ucounts]\n\n2. 函数名: ucounts_hashentry\n- 参数: [struct user_namespace *ns, kuid_t uid]\n- 调用者: alloc_ucounts\n- 被调用者: []\n\n3. 函数名: find_ucounts\n- 参数: [struct user_namespace *ns, kuid_t uid, struct hlist_head *hashent]\n- 调用者: alloc_ucounts\n- 被调用者: []\n\n4. 函数名: kzalloc\n- 参数: [sizeof(*new), GFP_KERNEL]\n- 调用者: alloc_ucounts\n- 被调用者: []\n\n5. 函数名: atomic_set\n- 参数: [&new->count, 1]\n- 调用者: alloc_ucounts\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [new]\n- 调用者: alloc_ucounts\n- 被调用者: []\n\n7. 函数名: hlist_add_head\n- 参数: [&new->node, hashent]\n- 调用者: alloc_ucounts\n- 被调用者: []\n\n8. 函数名: get_ucounts_or_wrap\n- 参数: [ucounts]\n- 调用者: alloc_ucounts\n- 被调用者: []\n\n9. 函数名: put_ucounts\n- 参数: [ucounts]\n- 调用者: alloc_ucounts\n- 被调用者: []"
    },
    {
        "id": 3471,
        "cwe": "CWE-416",
        "cve": "CVE-2022-24122",
        "purpose": "Code purpose:\"\"\"该代码用于在引用计数减至零时释放ucounts结构体及其相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当ucounts对象的引用计数递减并释放锁后，该对象可能在其命名空间被销毁后仍然存在，导致use-after-free和权限提升漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: put_ucounts\n- 参数: [struct ucounts *ucounts]\n- 调用者: 未提供（上下文缺失）\n- 被调用者: [atomic_dec_and_lock_irqsave, hlist_del_init, spin_unlock_irqrestore, kfree]\n\n2. 函数名: atomic_dec_and_lock_irqsave\n- 参数: [&ucounts->count, &ucounts_lock, flags]\n- 调用者: put_ucounts\n- 被调用者: 未提供（系统/内核函数）\n\n3. 函数名: hlist_del_init\n- 参数: [&ucounts->node]\n- 调用者: put_ucounts\n- 被调用者: 未提供（系统/内核函数）\n\n4. 函数名: spin_unlock_irqrestore\n- 参数: [&ucounts_lock, flags]\n- 调用者: put_ucounts\n- 被调用者: 未提供（系统/内核函数）\n\n5. 函数名: kfree\n- 参数: [ucounts]\n- 调用者: put_ucounts\n- 被调用者: 未提供（系统/内核函数）"
    },
    {
        "id": 3477,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2585",
        "purpose": "Code purpose:\"\"\"处理进程执行新程序时的各种资源清理和权限设置，包括线程组处理、文件描述符关闭、内存映射释放、信号处理重置等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在非主线程执行exec时，已设置的POSIX CPU定时器未被正确清理，导致释放后仍留在列表中引发use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: begin_new_exec\n- 参数: [struct linux_binprm * bprm]\n- 调用者: N/A\n- 被调用者: [bprm_creds_from_file, de_thread, io_uring_task_cancel, unshare_files, set_mm_exe_file, would_dump, acct_arg_size, exec_mmap, exit_itimers, flush_itimer_signals, unshare_sighand, flush_thread, clear_syscall_work_syscall_user_dispatch, do_close_on_exec, set_dumpable, perf_event_exec, __set_task_comm, flush_signal_handlers, set_cred_ucounts, security_bprm_committing_creds, commit_creds, perf_event_exit_task, security_bprm_committed_creds, get_unused_fd_flags, fd_install, up_write]\n\n2. 函数名: bprm_creds_from_file\n- 参数: [struct linux_binprm * bprm]\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n3. 函数名: de_thread\n- 参数: [struct task_struct * me]\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n4. 函数名: io_uring_task_cancel\n- 参数: []\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n5. 函数名: unshare_files\n- 参数: []\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n6. 函数名: set_mm_exe_file\n- 参数: [struct mm_struct * mm, struct file * file]\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n7. 函数名: would_dump\n- 参数: [struct linux_binprm * bprm, struct file * file]\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n8. 函数名: acct_arg_size\n- 参数: [struct linux_binprm * bprm, int size]\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n9. 函数名: exec_mmap\n- 参数: [struct mm_struct * mm]\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n10. 函数名: exit_itimers\n- 参数: [struct task_struct * me]\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n11. 函数名: flush_itimer_signals\n- 参数: []\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n12. 函数名: unshare_sighand\n- 参数: [struct task_struct * me]\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n13. 函数名: flush_thread\n- 参数: []\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n14. 函数名: clear_syscall_work_syscall_user_dispatch\n- 参数: [struct task_struct * me]\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n15. 函数名: do_close_on_exec\n- 参数: [struct files_struct * files]\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n16. 函数名: set_dumpable\n- 参数: [struct mm_struct * mm, int value]\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n17. 函数名: perf_event_exec\n- 参数: []\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n18. 函数名: __set_task_comm\n- 参数: [struct task_struct * me, const char * buf, bool exec]\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n19. 函数名: flush_signal_handlers\n- 参数: [struct task_struct * me, int default_handler]\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n20. 函数名: set_cred_ucounts\n- 参数: [struct cred * cred]\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n21. 函数名: security_bprm_committing_creds\n- 参数: [struct linux_binprm * bprm]\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n22. 函数名: commit_creds\n- 参数: [struct cred * cred]\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n23. 函数名: perf_event_exit_task\n- 参数: [struct task_struct * me]\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n24. 函数名: security_bprm_committed_creds\n- 参数: [struct linux_binprm * bprm]\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n25. 函数名: get_unused_fd_flags\n- 参数: [int flags]\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n26. 函数名: fd_install\n- 参数: [int fd, struct file * file]\n- 调用者: begin_new_exec\n- 被调用者: N/A\n\n27. 函数名: up_write\n- 参数: [struct rw_semaphore * sem]\n- 调用者: begin_new_exec\n- 被调用者: N/A"
    },
    {
        "id": 3478,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2586",
        "purpose": "Code purpose:\"\"\"该代码用于全局查找NFT集合，首先通过名称查找，若失败则尝试通过ID查找\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于NFT集合查找函数未验证目标表是否与当前表匹配，导致可以引用不同表中的集合，在表被删除后引发释放后使用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_set_lookup_global\n- 参数: [const struct net *net, const struct nft_table *table, const struct nlattr *nla_set_name, const struct nlattr *nla_set_id, u8 genmask]\n- 调用者: 未提供\n- 被调用者: [nft_set_lookup, nft_set_lookup_byid]\n\n2. 函数名: nft_set_lookup\n- 参数: [const struct nft_table *table, const struct nlattr *nla_set_name, u8 genmask]\n- 调用者: nft_set_lookup_global\n- 被调用者: 未提供\n\n3. 函数名: nft_set_lookup_byid\n- 参数: [const struct net *net, const struct nlattr *nla_set_id, u8 genmask]\n- 调用者: nft_set_lookup_global\n- 被调用者: 未提供"
    },
    {
        "id": 3483,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2602",
        "purpose": "Code purpose:\"\"\"该代码用于在io_uring中处理Unix域套接字文件描述符传递时的引用计数和垃圾回收\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放skb后未正确清理引用计数，导致后续使用时可能发生释放后重用(UAF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: __io_scm_file_account\n- 参数: [struct io_ring_ctx *ctx, struct file *file]\n- 调用者: 未提供\n- 被调用者: [io_file_need_scm, spin_lock_irq, skb_peek, __skb_unlink, spin_unlock_irq, kzalloc, alloc_skb, kfree, get_uid, get_file, unix_inflight, skb_queue_head, fput]\n\n2. 函数名: io_file_need_scm\n- 参数: [struct file *file]\n- 调用者: __io_scm_file_account\n- 被调用者: 未提供\n\n3. 函数名: spin_lock_irq\n- 参数: [&head->lock]\n- 调用者: __io_scm_file_account\n- 被调用者: 未提供\n\n4. 函数名: skb_peek\n- 参数: [head]\n- 调用者: __io_scm_file_account\n- 被调用者: 未提供\n\n5. 函数名: __skb_unlink\n- 参数: [skb, head]\n- 调用者: __io_scm_file_account\n- 被调用者: 未提供\n\n6. 函数名: spin_unlock_irq\n- 参数: [&head->lock]\n- 调用者: __io_scm_file_account\n- 被调用者: 未提供\n\n7. 函数名: kzalloc\n- 参数: [sizeof(*fpl), GFP_KERNEL]\n- 调用者: __io_scm_file_account\n- 被调用者: 未提供\n\n8. 函数名: alloc_skb\n- 参数: [0, GFP_KERNEL]\n- 调用者: __io_scm_file_account\n- 被调用者: 未提供\n\n9. 函数名: kfree\n- 参数: [fpl]\n- 调用者: __io_scm_file_account\n- 被调用者: 未提供\n\n10. 函数名: get_uid\n- 参数: [current_user()]\n- 调用者: __io_scm_file_account\n- 被调用者: 未提供\n\n11. 函数名: get_file\n- 参数: [file]\n- 调用者: __io_scm_file_account\n- 被调用者: 未提供\n\n12. 函数名: unix_inflight\n- 参数: [fpl->user, file]\n- 调用者: __io_scm_file_account\n- 被调用者: 未提供\n\n13. 函数名: skb_queue_head\n- 参数: [head, skb]\n- 调用者: __io_scm_file_account\n- 被调用者: 未提供\n\n14. 函数名: fput\n- 参数: [file]\n- 调用者: __io_scm_file_account\n- 被调用者: 未提供"
    },
    {
        "id": 3484,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2602",
        "purpose": "Code purpose:\"\"\"该代码实现了Unix域套接字的垃圾回收机制，用于检测和清理形成循环引用的套接字对象，防止内存泄漏。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Unix SCM垃圾回收过程中，由于未正确处理引用计数导致释放后重用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: unix_gc\n- 参数: []\n- 调用者: N/A\n- 被调用者: [scan_children, __skb_queue_purge, list_for_each_entry_safe, list_for_each_entry, list_move_tail, __set_bit, atomic_long_read, file_count, list_add, list_move, list_del, skb_queue_head_init, list_empty, list_entry, __clear_bit, wake_up]\n\n2. 函数名: scan_children\n- 参数: [&u->sk, dec_inflight, NULL], [&u->sk, inc_inflight_move_tail, NULL], [&u->sk, inc_inflight, &hitlist]\n- 调用者: unix_gc\n- 被调用者: N/A\n\n3. 函数名: __skb_queue_purge\n- 参数: [&hitlist]\n- 调用者: unix_gc\n- 被调用者: N/A\n\n4. 函数名: list_for_each_entry_safe\n- 参数: [u, next, &gc_inflight_list, link]\n- 调用者: unix_gc\n- 被调用者: N/A\n\n5. 函数名: list_for_each_entry\n- 参数: [u, &gc_candidates, link]\n- 调用者: unix_gc\n- 被调用者: N/A\n\n6. 函数名: list_move_tail\n- 参数: [&u->link, &gc_candidates], [&u->link, &gc_inflight_list]\n- 调用者: unix_gc\n- 被调用者: N/A\n\n7. 函数名: __set_bit\n- 参数: [UNIX_GC_CANDIDATE, &u->gc_flags], [UNIX_GC_MAYBE_CYCLE, &u->gc_flags]\n- 调用者: unix_gc\n- 被调用者: N/A\n\n8. 函数名: atomic_long_read\n- 参数: [&u->inflight]\n- 调用者: unix_gc\n- 被调用者: N/A\n\n9. 函数名: file_count\n- 参数: [u->sk.sk_socket->file]\n- 调用者: unix_gc\n- 被调用者: N/A\n\n10. 函数名: list_add\n- 参数: [&cursor, &gc_candidates]\n- 调用者: unix_gc\n- 被调用者: N/A\n\n11. 函数名: list_move\n- 参数: [&cursor, &u->link]\n- 调用者: unix_gc\n- 被调用者: N/A\n\n12. 函数名: list_del\n- 参数: [&cursor]\n- 调用者: unix_gc\n- 被调用者: N/A\n\n13. 函数名: skb_queue_head_init\n- 参数: [&hitlist]\n- 调用者: unix_gc\n- 被调用者: N/A\n\n14. 函数名: list_empty\n- 参数: [&not_cycle_list]\n- 调用者: unix_gc\n- 被调用者: N/A\n\n15. 函数名: list_entry\n- 参数: [not_cycle_list.next, struct unix_sock, link], [cursor.next, struct unix_sock, link]\n- 调用者: unix_gc\n- 被调用者: N/A\n\n16. 函数名: __clear_bit\n- 参数: [UNIX_GC_MAYBE_CYCLE, &u->gc_flags], [UNIX_GC_CANDIDATE, &u->gc_flags]\n- 调用者: unix_gc\n- 被调用者: N/A\n\n17. 函数名: wake_up\n- 参数: [&unix_gc_wait]\n- 调用者: unix_gc\n- 被调用者: N/A"
    },
    {
        "id": 3507,
        "cwe": "CWE-416",
        "cve": "CVE-2022-28893",
        "purpose": "Code purpose:\"\"\"该代码用于处理RPC传输层的连接操作，包括检查传输状态、处理连接等待和关闭情况，并尝试建立新的连接\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放xprt资源前未确保socket处于预期状态，导致释放后可能访问无效状态\"\"\"",
        "functions": "Functions:\n1. 函数名: xprt_connect\n- 参数: [task]\n- 调用者: N/A\n- 被调用者: [xprt_bound, xprt_lock_write, test_and_clear_bit, trace_xprt_disconnect_cleanup, xprt->ops->close, xprt_connected, rpc_sleep_on_timeout, xprt_request_timeout, test_bit, xprt_test_and_set_connecting, xprt->ops->connect, xprt_clear_connecting, rpc_wake_up_queued_task, xprt_release_write]\n\n2. 函数名: xprt_bound\n- 参数: [xprt]\n- 调用者: xprt_connect\n- 被调用者: N/A\n\n3. 函数名: xprt_lock_write\n- 参数: [xprt, task]\n- 调用者: xprt_connect\n- 被调用者: N/A\n\n4. 函数名: test_and_clear_bit\n- 参数: [XPRT_CLOSE_WAIT, &xprt->state]\n- 调用者: xprt_connect\n- 被调用者: N/A\n\n5. 函数名: trace_xprt_disconnect_cleanup\n- 参数: [xprt]\n- 调用者: xprt_connect\n- 被调用者: N/A\n\n6. 函数名: xprt->ops->close\n- 参数: [xprt]\n- 调用者: xprt_connect\n- 被调用者: N/A\n\n7. 函数名: xprt_connected\n- 参数: [xprt]\n- 调用者: xprt_connect\n- 被调用者: N/A\n\n8. 函数名: rpc_sleep_on_timeout\n- 参数: [&xprt->pending, task, NULL, xprt_request_timeout(task->tk_rqstp)]\n- 调用者: xprt_connect\n- 被调用者: [xprt_request_timeout]\n\n9. 函数名: xprt_request_timeout\n- 参数: [task->tk_rqstp]\n- 调用者: rpc_sleep_on_timeout\n- 被调用者: N/A\n\n10. 函数名: test_bit\n- 参数: [XPRT_CLOSING, &xprt->state]\n- 调用者: xprt_connect\n- 被调用者: N/A\n\n11. 函数名: xprt_test_and_set_connecting\n- 参数: [xprt]\n- 调用者: xprt_connect\n- 被调用者: N/A\n\n12. 函数名: xprt->ops->connect\n- 参数: [xprt, task]\n- 调用者: xprt_connect\n- 被调用者: N/A\n\n13. 函数名: xprt_clear_connecting\n- 参数: [xprt]\n- 调用者: xprt_connect\n- 被调用者: N/A\n\n14. 函数名: rpc_wake_up_queued_task\n- 参数: [&xprt->pending, task]\n- 调用者: xprt_connect\n- 被调用者: N/A\n\n15. 函数名: xprt_release_write\n- 参数: [xprt, task]\n- 调用者: xprt_connect\n- 被调用者: N/A\n\n16. 函数名: trace_xprt_connect\n- 参数: [xprt]\n- 调用者: xprt_connect\n- 被调用者: N/A"
    },
    {
        "id": 3508,
        "cwe": "CWE-416",
        "cve": "CVE-2022-28893",
        "purpose": "Code purpose:\"\"\"该代码用于处理SUNRPC子系统中的本地请求发送，包括流式传输管理、错误处理和连接状态维护\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放xs_xprt资源前未确保socket处于预期状态\"\"\"",
        "functions": "Functions:\n1. 函数名: xs_local_send_request\n- 参数: [struct rpc_rqst *req]\n- 调用者: N/A (top-level function)\n- 被调用者: [container_of, xs_stream_record_marker, xs_send_request_was_aborted, xs_close, xs_pktdump, sk_stream_is_writeable, ktime_get, xprt_sock_sendmsg, xs_stream_nospace]\n\n2. 函数名: container_of\n- 参数: [xprt, struct sock_xprt, xprt]\n- 调用者: xs_local_send_request\n- 被调用者: []\n\n3. 函数名: xs_stream_record_marker\n- 参数: [xdr]\n- 调用者: xs_local_send_request\n- 被调用者: []\n\n4. 函数名: xs_send_request_was_aborted\n- 参数: [transport, req]\n- 调用者: xs_local_send_request\n- 被调用者: []\n\n5. 函数名: xs_close\n- 参数: [xprt]\n- 调用者: xs_local_send_request\n- 被调用者: []\n\n6. 函数名: xs_pktdump\n- 参数: [\"packet data:\", req->rq_svec->iov_base, req->rq_svec->iov_len]\n- 调用者: xs_local_send_request\n- 被调用者: []\n\n7. 函数名: sk_stream_is_writeable\n- 参数: [transport->inet]\n- 调用者: xs_local_send_request\n- 被调用者: []\n\n8. 函数名: ktime_get\n- 参数: []\n- 调用者: xs_local_send_request\n- 被调用者: []\n\n9. 函数名: xprt_sock_sendmsg\n- 参数: [transport->sock, &msg, xdr, transport->xmit.offset, rm, &sent]\n- 调用者: xs_local_send_request\n- 被调用者: []\n\n10. 函数名: xs_stream_nospace\n- 参数: [req, vm_wait]\n- 调用者: xs_local_send_request\n- 被调用者: []"
    },
    {
        "id": 3509,
        "cwe": "CWE-416",
        "cve": "CVE-2022-28893",
        "purpose": "Code purpose:\"\"\"该代码用于重置和清理SUNRPC子系统中传输层的socket连接及相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放SUNRPC传输资源前未确保socket处于预期状态\"\"\"",
        "functions": "Functions:\n1. 函数名: xs_reset_transport\n- 参数: [struct sock_xprt *transport]\n- 调用者: 未指定\n- 被调用者: [atomic_read, sk_clear_memalloc, kernel_sock_shutdown, mutex_lock, lock_sock, xs_restore_old_callbacks, xprt_clear_connected, xs_sock_reset_connection_flags, xs_stream_reset_connect, release_sock, mutex_unlock, trace_rpc_socket_close, fput, xprt_disconnect_done]\n\n2. 函数名: atomic_read\n- 参数: [&transport->xprt.swapper]\n- 调用者: xs_reset_transport\n- 被调用者: []\n\n3. 函数名: sk_clear_memalloc\n- 参数: [sk]\n- 调用者: xs_reset_transport\n- 被调用者: []\n\n4. 函数名: kernel_sock_shutdown\n- 参数: [sock, SHUT_RDWR]\n- 调用者: xs_reset_transport\n- 被调用者: []\n\n5. 函数名: mutex_lock\n- 参数: [&transport->recv_mutex]\n- 调用者: xs_reset_transport\n- 被调用者: []\n\n6. 函数名: lock_sock\n- 参数: [sk]\n- 调用者: xs_reset_transport\n- 被调用者: []\n\n7. 函数名: xs_restore_old_callbacks\n- 参数: [transport, sk]\n- 调用者: xs_reset_transport\n- 被调用者: []\n\n8. 函数名: xprt_clear_connected\n- 参数: [xprt]\n- 调用者: xs_reset_transport\n- 被调用者: []\n\n9. 函数名: xs_sock_reset_connection_flags\n- 参数: [xprt]\n- 调用者: xs_reset_transport\n- 被调用者: []\n\n10. 函数名: xs_stream_reset_connect\n- 参数: [transport]\n- 调用者: xs_reset_transport\n- 被调用者: []\n\n11. 函数名: release_sock\n- 参数: [sk]\n- 调用者: xs_reset_transport\n- 被调用者: []\n\n12. 函数名: mutex_unlock\n- 参数: [&transport->recv_mutex]\n- 调用者: xs_reset_transport\n- 被调用者: []\n\n13. 函数名: trace_rpc_socket_close\n- 参数: [xprt, sock]\n- 调用者: xs_reset_transport\n- 被调用者: []\n\n14. 函数名: fput\n- 参数: [filp]\n- 调用者: xs_reset_transport\n- 被调用者: []\n\n15. 函数名: xprt_disconnect_done\n- 参数: [xprt]\n- 调用者: xs_reset_transport\n- 被调用者: []"
    },
    {
        "id": 3514,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2938",
        "purpose": "Code purpose:\"\"\"该代码实现了cgroup压力信息的写入功能，包括创建新的压力触发器并替换旧的触发器\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在cgroup_pressure_write函数中，由于对psi_trigger_replace操作后未正确处理内存释放，导致存在释放后使用(Use-after-free)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: cgroup_pressure_write\n- 参数: [struct kernfs_open_file *of, char *buf, size_t nbytes, enum psi_res res]\n- 调用者: (未显示)\n- 被调用者: [cgroup_kn_lock_live, cgroup_get, cgroup_kn_unlock, cgroup_ino, psi_trigger_create, cgroup_put, PTR_ERR, psi_trigger_replace]\n\n2. 函数名: cgroup_kn_lock_live\n- 参数: [struct kernfs_node *kn, bool drain_offline]\n- 调用者: cgroup_pressure_write\n- 被调用者: (未显示)\n\n3. 函数名: cgroup_get\n- 参数: [struct cgroup *cgrp]\n- 调用者: cgroup_pressure_write\n- 被调用者: (未显示)\n\n4. 函数名: cgroup_kn_unlock\n- 参数: [struct kernfs_node *kn]\n- 调用者: cgroup_pressure_write\n- 被调用者: (未显示)\n\n5. 函数名: cgroup_ino\n- 参数: [struct cgroup *cgrp]\n- 调用者: cgroup_pressure_write\n- 被调用者: (未显示)\n\n6. 函数名: psi_trigger_create\n- 参数: [struct psi_group *psi, char *buf, size_t nbytes, enum psi_res res]\n- 调用者: cgroup_pressure_write\n- 被调用者: (未显示)\n\n7. 函数名: cgroup_put\n- 参数: [struct cgroup *cgrp]\n- 调用者: cgroup_pressure_write\n- 被调用者: (未显示)\n\n8. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: cgroup_pressure_write\n- 被调用者: (未显示)\n\n9. 函数名: psi_trigger_replace\n- 参数: [struct psi_trigger **old, struct psi_trigger *new]\n- 调用者: cgroup_pressure_write\n- 被调用者: (未显示)"
    },
    {
        "id": 3515,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2938",
        "purpose": "Code purpose:\"\"\"释放cgroup压力监控相关的资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放cgroup压力信息时未正确处理psi_trigger_replace函数调用，导致内存损坏或系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: cgroup_pressure_release\n- 参数: [struct kernfs_open_file *of]\n- 调用者: 未明确（由内核调用）\n- 被调用者: [psi_trigger_replace]\n\n2. 函数名: psi_trigger_replace\n- 参数: [&ctx->psi.trigger, NULL]\n- 调用者: cgroup_pressure_release\n- 被调用者: 未明确"
    },
    {
        "id": 3516,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2938",
        "purpose": "Code purpose:\"\"\"释放与压力停滞信息(PSI)相关的文件操作资源，包括替换触发器和关闭文件\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在psi_fop_release函数中，未正确验证seq指针的有效性可能导致释放后使用(use-after-free)的内存损坏问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: psi_fop_release\n- 参数: [struct inode *inode, struct file *file]\n- 调用者: 未明确（由文件操作结构调用）\n- 被调用者: [psi_trigger_replace, single_release]\n\n2. 函数名: psi_trigger_replace\n- 参数: [&seq->private, NULL]\n- 调用者: psi_fop_release\n- 被调用者: 未明确\n\n3. 函数名: single_release\n- 参数: [struct inode *inode, struct file *file]\n- 调用者: psi_fop_release\n- 被调用者: 未明确"
    },
    {
        "id": 3517,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2938",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中创建和管理压力停滞信息(PSI)触发器，用于监控系统资源压力状态。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放psi_trigger结构体时未正确管理引用计数，导致释放后使用(use-after-free)的内存破坏漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: psi_trigger_create\n- 参数: [struct psi_group *group, char *buf, size_t nbytes, enum psi_res res]\n- 调用者: 未显示\n- 被调用者: [static_branch_likely, sscanf, ERR_PTR, kmalloc, window_reset, init_waitqueue_head, kref_init, mutex_lock, rcu_access_pointer, kthread_create, IS_ERR, kfree, mutex_unlock, ERR_CAST, atomic_set, wake_up_process, rcu_assign_pointer, list_add, div_u64, min]\n\n2. 函数名: static_branch_likely\n- 参数: [&psi_disabled]\n- 调用者: psi_trigger_create\n- 被调用者: 未显示\n\n3. 函数名: sscanf\n- 参数: [buf, \"some %u %u\", &threshold_us, &window_us], [buf, \"full %u %u\", &threshold_us, &window_us]\n- 调用者: psi_trigger_create\n- 被调用者: 未显示\n\n4. 函数名: ERR_PTR\n- 参数: [-EOPNOTSUPP], [-EINVAL], [-ENOMEM]\n- 调用者: psi_trigger_create\n- 被调用者: 未显示\n\n5. 函数名: kmalloc\n- 参数: [sizeof(*t), GFP_KERNEL]\n- 调用者: psi_trigger_create\n- 被调用者: 未显示\n\n6. 函数名: window_reset\n- 参数: [&t->win, 0, 0, 0]\n- 调用者: psi_trigger_create\n- 被调用者: 未显示\n\n7. 函数名: init_waitqueue_head\n- 参数: [&t->event_wait]\n- 调用者: psi_trigger_create\n- 被调用者: 未显示\n\n8. 函数名: kref_init\n- 参数: [&t->refcount]\n- 调用者: psi_trigger_create\n- 被调用者: 未显示\n\n9. 函数名: mutex_lock\n- 参数: [&group->trigger_lock]\n- 调用者: psi_trigger_create\n- 被调用者: 未显示\n\n10. 函数名: rcu_access_pointer\n- 参数: [group->poll_task]\n- 调用者: psi_trigger_create\n- 被调用者: 未显示\n\n11. 函数名: kthread_create\n- 参数: [psi_poll_worker, group, \"psimon\"]\n- 调用者: psi_trigger_create\n- 被调用者: 未显示\n\n12. 函数名: IS_ERR\n- 参数: [task]\n- 调用者: psi_trigger_create\n- 被调用者: 未显示\n\n13. 函数名: kfree\n- 参数: [t]\n- 调用者: psi_trigger_create\n- 被调用者: 未显示\n\n14. 函数名: mutex_unlock\n- 参数: [&group->trigger_lock]\n- 调用者: psi_trigger_create\n- 被调用者: 未显示\n\n15. 函数名: ERR_CAST\n- 参数: [task]\n- 调用者: psi_trigger_create\n- 被调用者: 未显示\n\n16. 函数名: atomic_set\n- 参数: [&group->poll_wakeup, 0]\n- 调用者: psi_trigger_create\n- 被调用者: 未显示\n\n17. 函数名: wake_up_process\n- 参数: [task]\n- 调用者: psi_trigger_create\n- 被调用者: 未显示\n\n18. 函数名: rcu_assign_pointer\n- 参数: [group->poll_task, task]\n- 调用者: psi_trigger_create\n- 被调用者: 未显示\n\n19. 函数名: list_add\n- 参数: [&t->node, &group->triggers]\n- 调用者: psi_trigger_create\n- 被调用者: 未显示\n\n20. 函数名: div_u64\n- 参数: [t->win.size, UPDATES_PER_WINDOW]\n- 调用者: psi_trigger_create\n- 被调用者: 未显示\n\n21. 函数名: min\n- 参数: [group->poll_min_period, div_u64(t->win.size, UPDATES_PER_WINDOW)]\n- 调用者: psi_trigger_create\n- 被调用者: 未显示"
    },
    {
        "id": 3518,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2938",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中压力停滞信息(PSI)功能的写入操作，处理用户空间传入的数据并创建相应的触发器\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证用户输入数据的大小和内容，导致在psi_write函数中可能发生内存损坏或系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: psi_write\n- 参数: [file, user_buf, nbytes, res]\n- 调用者: 未显示（由文件操作调用）\n- 被调用者: [static_branch_likely, copy_from_user, psi_trigger_create, IS_ERR, PTR_ERR, mutex_lock, psi_trigger_replace, mutex_unlock]\n\n2. 函数名: static_branch_likely\n- 参数: [&psi_disabled]\n- 调用者: psi_write\n- 被调用者: []\n\n3. 函数名: copy_from_user\n- 参数: [buf, user_buf, buf_size]\n- 调用者: psi_write\n- 被调用者: []\n\n4. 函数名: psi_trigger_create\n- 参数: [&psi_system, buf, nbytes, res]\n- 调用者: psi_write\n- 被调用者: []\n\n5. 函数名: IS_ERR\n- 参数: [new]\n- 调用者: psi_write\n- 被调用者: []\n\n6. 函数名: PTR_ERR\n- 参数: [new]\n- 调用者: psi_write\n- 被调用者: []\n\n7. 函数名: mutex_lock\n- 参数: [&seq->lock]\n- 调用者: psi_write\n- 被调用者: []\n\n8. 函数名: psi_trigger_replace\n- 参数: [&seq->private, new]\n- 调用者: psi_write\n- 被调用者: []\n\n9. 函数名: mutex_unlock\n- 参数: [&seq->lock]\n- 调用者: psi_write\n- 被调用者: []"
    },
    {
        "id": 3519,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2938",
        "purpose": "Code purpose:\"\"\"该代码用于实现Linux内核中压力停滞信息(PSI)功能的触发器轮询机制，处理事件通知和资源管理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在psi_trigger_poll函数中，由于对trigger_ptr的引用计数管理不当，可能导致释放后使用(UAF)的内存破坏问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: psi_trigger_poll\n- 参数: [trigger_ptr, file, wait]\n- 调用者: 未明确（由系统调用或内核其他部分调用）\n- 被调用者: [static_branch_likely, rcu_read_lock, rcu_dereference, rcu_read_unlock, kref_get, poll_wait, cmpxchg, kref_put, psi_trigger_destroy]\n\n2. 函数名: static_branch_likely\n- 参数: [&psi_disabled]\n- 调用者: psi_trigger_poll\n- 被调用者: []\n\n3. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: psi_trigger_poll\n- 被调用者: []\n\n4. 函数名: rcu_dereference\n- 参数: [*(void __rcu __force **)trigger_ptr]\n- 调用者: psi_trigger_poll\n- 被调用者: []\n\n5. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: psi_trigger_poll\n- 被调用者: []\n\n6. 函数名: kref_get\n- 参数: [&t->refcount]\n- 调用者: psi_trigger_poll\n- 被调用者: []\n\n7. 函数名: poll_wait\n- 参数: [file, &t->event_wait, wait]\n- 调用者: psi_trigger_poll\n- 被调用者: []\n\n8. 函数名: cmpxchg\n- 参数: [&t->event, 1, 0]\n- 调用者: psi_trigger_poll\n- 被调用者: []\n\n9. 函数名: kref_put\n- 参数: [&t->refcount, psi_trigger_destroy]\n- 调用者: psi_trigger_poll\n- 被调用者: [psi_trigger_destroy]\n\n10. 函数名: psi_trigger_destroy\n- 参数: [未明确（由kref_put传递）]\n- 调用者: kref_put\n- 被调用者: []"
    },
    {
        "id": 3526,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2977",
        "purpose": "Code purpose:\"\"\"该代码用于注销TPM芯片时清理相关资源，包括移除sysfs接口、注销硬件随机数生成器、拆除bios日志以及删除字符设备等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在虚拟化TPM设备注销过程中，由于未正确处理资源释放顺序，导致存在use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: tpm_chip_unregister\n- 参数: [struct tpm_chip *chip]\n- 调用者: 未显示\n- 被调用者: [tpm_del_legacy_sysfs, hwrng_unregister, tpm_bios_log_teardown, cdev_device_del, tpm_del_char_device]\n\n2. 函数名: tpm_del_legacy_sysfs\n- 参数: [struct tpm_chip *chip]\n- 调用者: tpm_chip_unregister\n- 被调用者: 未显示\n\n3. 函数名: hwrng_unregister\n- 参数: [&chip->hwrng]\n- 调用者: tpm_chip_unregister\n- 被调用者: 未显示\n\n4. 函数名: tpm_bios_log_teardown\n- 参数: [struct tpm_chip *chip]\n- 调用者: tpm_chip_unregister\n- 被调用者: 未显示\n\n5. 函数名: cdev_device_del\n- 参数: [&chip->cdevs, &chip->devs]\n- 调用者: tpm_chip_unregister\n- 被调用者: 未显示\n\n6. 函数名: tpm_del_char_device\n- 参数: [struct tpm_chip *chip]\n- 调用者: tpm_chip_unregister\n- 被调用者: 未显示"
    },
    {
        "id": 3527,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2977",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中添加TPM(可信平台模块)字符设备，并处理设备添加过程中的错误情况，同时管理设备的可用性状态。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在TPM设备添加过程中，未能正确处理设备引用计数，导致在特定条件下可能发生释放后使用(UAF)的情况。\"\"\"",
        "functions": "Functions:\n1. 函数名: tpm_add_char_device\n- 参数: [struct tpm_chip *chip]\n- 调用者: 未显示在代码片段中\n- 被调用者: [cdev_device_add, dev_err, dev_name, MAJOR, MINOR, tpm_is_firmware_upgrade, mutex_lock, idr_replace, mutex_unlock]\n\n2. 函数名: cdev_device_add\n- 参数: [&chip->cdev, &chip->dev] 或 [&chip->cdevs, &chip->devs]\n- 调用者: tpm_add_char_device\n- 被调用者: 未显示在代码片段中\n\n3. 函数名: dev_err\n- 参数: [&chip->dev, \"unable to cdev_device_add() %s, major %d, minor %d, err=%d\\n\", dev_name(&chip->dev), MAJOR(chip->dev.devt), MINOR(chip->dev.devt), rc] 或 [&chip->devs, \"unable to cdev_device_add() %s, major %d, minor %d, err=%d\\n\", dev_name(&chip->devs), MAJOR(chip->devs.devt), MINOR(chip->devs.devt), rc]\n- 调用者: tpm_add_char_device\n- 被调用者: 未显示在代码片段中\n\n4. 函数名: dev_name\n- 参数: [&chip->dev] 或 [&chip->devs]\n- 调用者: tpm_add_char_device\n- 被调用者: 未显示在代码片段中\n\n5. 函数名: MAJOR\n- 参数: [chip->dev.devt] 或 [chip->devs.devt]\n- 调用者: tpm_add_char_device\n- 被调用者: 未显示在代码片段中\n\n6. 函数名: MINOR\n- 参数: [chip->dev.devt] 或 [chip->devs.devt]\n- 调用者: tpm_add_char_device\n- 被调用者: 未显示在代码片段中\n\n7. 函数名: tpm_is_firmware_upgrade\n- 参数: [chip]\n- 调用者: tpm_add_char_device\n- 被调用者: 未显示在代码片段中\n\n8. 函数名: mutex_lock\n- 参数: [&idr_lock]\n- 调用者: tpm_add_char_device\n- 被调用者: 未显示在代码片段中\n\n9. 函数名: idr_replace\n- 参数: [&dev_nums_idr, chip, chip->dev_num]\n- 调用者: tpm_add_char_device\n- 被调用者: 未显示在代码片段中\n\n10. 函数名: mutex_unlock\n- 参数: [&idr_lock]\n- 调用者: tpm_add_char_device\n- 被调用者: 未显示在代码片段中"
    },
    {
        "id": 3528,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2977",
        "purpose": "Code purpose:\"\"\"该代码用于分配和初始化TPM(可信平台模块)芯片结构体，包括设备号分配、设备初始化和空间设置等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在虚拟化TPM设备配置下，由于未正确处理设备引用计数，导致存在use-after-free漏洞，可能被本地攻击者利用进行权限提升。\"\"\"",
        "functions": "Functions:\n1. 函数名: tpm_chip_alloc\n- 参数: [struct device *pdev, const struct tpm_class_ops *ops]\n- 调用者: 未显示\n- 被调用者: [kzalloc, mutex_init, init_rwsem, mutex_lock, idr_alloc, mutex_unlock, dev_err, kfree, device_initialize, get_device, MKDEV, dev_set_name, cdev_init, tpm2_init_space, put_device]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*chip), GFP_KERNEL]\n- 调用者: tpm_chip_alloc\n- 被调用者: 未显示\n\n3. 函数名: mutex_init\n- 参数: [&chip->tpm_mutex]\n- 调用者: tpm_chip_alloc\n- 被调用者: 未显示\n\n4. 函数名: init_rwsem\n- 参数: [&chip->ops_sem]\n- 调用者: tpm_chip_alloc\n- 被调用者: 未显示\n\n5. 函数名: mutex_lock\n- 参数: [&idr_lock]\n- 调用者: tpm_chip_alloc\n- 被调用者: 未显示\n\n6. 函数名: idr_alloc\n- 参数: [&dev_nums_idr, NULL, 0, TPM_NUM_DEVICES, GFP_KERNEL]\n- 调用者: tpm_chip_alloc\n- 被调用者: 未显示\n\n7. 函数名: mutex_unlock\n- 参数: [&idr_lock]\n- 调用者: tpm_chip_alloc\n- 被调用者: 未显示\n\n8. 函数名: dev_err\n- 参数: [pdev, \"No available tpm device numbers\"]\n- 调用者: tpm_chip_alloc\n- 被调用者: 未显示\n\n9. 函数名: kfree\n- 参数: [chip]\n- 调用者: tpm_chip_alloc\n- 被调用者: 未显示\n\n10. 函数名: device_initialize\n- 参数: [&chip->dev]\n- 调用者: tpm_chip_alloc\n- 被调用者: 未显示\n\n11. 函数名: device_initialize\n- 参数: [&chip->devs]\n- 调用者: tpm_chip_alloc\n- 被调用者: 未显示\n\n12. 函数名: get_device\n- 参数: [&chip->dev]\n- 调用者: tpm_chip_alloc\n- 被调用者: 未显示\n\n13. 函数名: MKDEV\n- 参数: [MISC_MAJOR, TPM_MINOR]\n- 调用者: tpm_chip_alloc\n- 被调用者: 未显示\n\n14. 函数名: MKDEV\n- 参数: [MAJOR(tpm_devt), chip->dev_num]\n- 调用者: tpm_chip_alloc\n- 被调用者: 未显示\n\n15. 函数名: MKDEV\n- 参数: [MAJOR(tpm_devt), chip->dev_num + TPM_NUM_DEVICES]\n- 调用者: tpm_chip_alloc\n- 被调用者: 未显示\n\n16. 函数名: dev_set_name\n- 参数: [&chip->dev, \"tpm%d\", chip->dev_num]\n- 调用者: tpm_chip_alloc\n- 被调用者: 未显示\n\n17. 函数名: dev_set_name\n- 参数: [&chip->devs, \"tpmrm%d\", chip->dev_num]\n- 调用者: tpm_chip_alloc\n- 被调用者: 未显示\n\n18. 函数名: cdev_init\n- 参数: [&chip->cdev, &tpm_fops]\n- 调用者: tpm_chip_alloc\n- 被调用者: 未显示\n\n19. 函数名: cdev_init\n- 参数: [&chip->cdevs, &tpmrm_fops]\n- 调用者: tpm_chip_alloc\n- 被调用者: 未显示\n\n20. 函数名: tpm2_init_space\n- 参数: [&chip->work_space, TPM2_SPACE_BUFFER_SIZE]\n- 调用者: tpm_chip_alloc\n- 被调用者: 未显示\n\n21. 函数名: put_device\n- 参数: [&chip->devs]\n- 调用者: tpm_chip_alloc\n- 被调用者: 未显示\n\n22. 函数名: put_device\n- 参数: [&chip->dev]\n- 调用者: tpm_chip_alloc\n- 被调用者: 未显示"
    },
    {
        "id": 3529,
        "cwe": "CWE-416",
        "cve": "CVE-2022-2978",
        "purpose": "Code purpose:\"\"\"初始化inode结构体并设置其默认值，包括文件系统相关信息、操作函数指针和各种状态标志\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核NILFS文件系统中，当security_inode_alloc失败后未正确处理inode的释放，导致后续可能发生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: inode_init_always\n- 参数: [struct super_block *sb, struct inode *inode]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [atomic64_set, atomic_set, i_uid_write, i_gid_write, security_inode_alloc, spin_lock_init, lockdep_set_class, init_rwsem, lockdep_set_class_and_name, mapping_set_gfp_mask, INIT_HLIST_HEAD, this_cpu_inc]\n\n2. 函数名: atomic64_set\n- 参数: [atomic64_t *v, long i]\n- 调用者: inode_init_always\n- 被调用者: []\n\n3. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: inode_init_always\n- 被调用者: []\n\n4. 函数名: i_uid_write\n- 参数: [struct inode *inode, uid_t uid]\n- 调用者: inode_init_always\n- 被调用者: []\n\n5. 函数名: i_gid_write\n- 参数: [struct inode *inode, gid_t gid]\n- 调用者: inode_init_always\n- 被调用者: []\n\n6. 函数名: security_inode_alloc\n- 参数: [struct inode *inode]\n- 调用者: inode_init_always\n- 被调用者: []\n\n7. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: inode_init_always\n- 被调用者: []\n\n8. 函数名: lockdep_set_class\n- 参数: [struct lockdep_map *lock, struct lock_class_key *key]\n- 调用者: inode_init_always\n- 被调用者: []\n\n9. 函数名: init_rwsem\n- 参数: [struct rw_semaphore *sem]\n- 调用者: inode_init_always\n- 被调用者: []\n\n10. 函数名: lockdep_set_class_and_name\n- 参数: [struct lockdep_map *lock, struct lock_class_key *key, const char *name]\n- 调用者: inode_init_always\n- 被调用者: []\n\n11. 函数名: mapping_set_gfp_mask\n- 参数: [struct address_space *mapping, gfp_t mask]\n- 调用者: inode_init_always\n- 被调用者: []\n\n12. 函数名: INIT_HLIST_HEAD\n- 参数: [struct hlist_head *h]\n- 调用者: inode_init_always\n- 被调用者: []\n\n13. 函数名: this_cpu_inc\n- 参数: [type]\n- 调用者: inode_init_always\n- 被调用者: []"
    },
    {
        "id": 3564,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3176",
        "purpose": "Code purpose:\"\"\"该代码片段用于从io_uring中移除轮询条目，处理单次和双重轮询的情况\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核io_uring在处理POLLFREE通知时存在缺陷，当signalfd或binder fd被轮询且等待队列被释放时，未能正确处理POLLFREE导致释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: io_poll_remove_entries\n- 参数: [struct io_kiocb *req]\n- 调用者: 未提供\n- 被调用者: [io_poll_get_single, io_poll_get_double, io_poll_remove_entry]\n\n2. 函数名: io_poll_get_single\n- 参数: [struct io_kiocb *req]\n- 调用者: io_poll_remove_entries\n- 被调用者: 未提供\n\n3. 函数名: io_poll_get_double\n- 参数: [struct io_kiocb *req]\n- 调用者: io_poll_remove_entries\n- 被调用者: 未提供\n\n4. 函数名: io_poll_remove_entry\n- 参数: [struct io_poll_iocb *poll]\n- 调用者: io_poll_remove_entries\n- 被调用者: 未提供"
    },
    {
        "id": 3565,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3176",
        "purpose": "Code purpose:\"\"\"处理io_uring中的poll事件唤醒，检查事件匹配并执行相应的poll操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"io_uring poll未处理POLLFREE通知，导致当signalfd或binder fd的等待队列被释放时可能发生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: io_poll_wake\n- 参数: [wait, mode, sync, key]\n- 调用者: N/A (内核等待队列唤醒回调)\n- 被调用者: [container_of, key_to_poll, io_poll_get_ownership, list_del_init, __io_poll_execute]\n\n2. 函数名: container_of\n- 参数: [wait, struct io_poll_iocb, wait]\n- 调用者: io_poll_wake\n- 被调用者: N/A\n\n3. 函数名: key_to_poll\n- 参数: [key]\n- 调用者: io_poll_wake\n- 被调用者: N/A\n\n4. 函数名: io_poll_get_ownership\n- 参数: [req]\n- 调用者: io_poll_wake\n- 被调用者: N/A\n\n5. 函数名: list_del_init\n- 参数: [&poll->wait.entry]\n- 调用者: io_poll_wake\n- 被调用者: N/A\n\n6. 函数名: __io_poll_execute\n- 参数: [req, mask]\n- 调用者: io_poll_wake\n- 被调用者: N/A"
    },
    {
        "id": 3566,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3176",
        "purpose": "Code purpose:\"\"\"从等待队列中安全移除一个IO轮询条目并清理相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"io_uring poll未处理POLLFREE通知，导致当signalfd或binder fd的等待队列被释放时可能发生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: io_poll_remove_entry\n- 参数: [struct io_poll_iocb *poll]\n- 调用者: 未明确（由上下文推断可能是io_uring相关调用）\n- 被调用者: [spin_lock_irq, list_del_init, spin_unlock_irq]\n\n2. 函数名: spin_lock_irq\n- 参数: [&head->lock]\n- 调用者: io_poll_remove_entry\n- 被调用者: []\n\n3. 函数名: list_del_init\n- 参数: [&poll->wait.entry]\n- 调用者: io_poll_remove_entry\n- 被调用者: []\n\n4. 函数名: spin_unlock_irq\n- 参数: [&head->lock]\n- 调用者: io_poll_remove_entry\n- 被调用者: []"
    },
    {
        "id": 3568,
        "cwe": "CWE-416",
        "cve": "CVE-2022-32250",
        "purpose": "Code purpose:\"\"\"该代码用于在netfilter框架中为NFT集合元素分配并初始化表达式，同时验证表达式是否符合状态性和垃圾回收的要求\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于NFT_STATEFUL_EXPR检查不正确导致释放后使用(use-after-free)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_set_elem_expr_alloc\n- 参数: [const struct nft_ctx *ctx, const struct nft_set *set, const struct nlattr *attr]\n- 调用者: 未显示\n- 被调用者: [nft_expr_init, nft_expr_destroy]\n\n2. 函数名: nft_expr_init\n- 参数: [const struct nft_ctx *ctx, const struct nlattr *attr]\n- 调用者: nft_set_elem_expr_alloc\n- 被调用者: 未显示\n\n3. 函数名: nft_expr_destroy\n- 参数: [const struct nft_ctx *ctx, struct nft_expr *expr]\n- 调用者: nft_set_elem_expr_alloc\n- 被调用者: 未显示"
    },
    {
        "id": 3569,
        "cwe": "CWE-416",
        "cve": "CVE-2022-32250",
        "purpose": "Code purpose:\"\"\"初始化并返回一个nft_expr结构体，用于处理netfilter表达式\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于NFT_STATEFUL_EXPR检查不正确导致在错误处理路径中可能发生释放后使用(use-after-free)\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_expr_init\n- 参数: [const struct nft_ctx *ctx, const struct nlattr *nla]\n- 调用者: 未显示\n- 被调用者: [nf_tables_expr_parse, kzalloc, nf_tables_newexpr, kfree, module_put, ERR_PTR]\n\n2. 函数名: nf_tables_expr_parse\n- 参数: [const struct nft_ctx *ctx, const struct nlattr *nla, struct nft_expr_info *expr_info]\n- 调用者: nft_expr_init\n- 被调用者: 未显示\n\n3. 函数名: kzalloc\n- 参数: [expr_info.ops->size, GFP_KERNEL_ACCOUNT]\n- 调用者: nft_expr_init\n- 被调用者: 未显示\n\n4. 函数名: nf_tables_newexpr\n- 参数: [const struct nft_ctx *ctx, struct nft_expr_info *expr_info, struct nft_expr *expr]\n- 调用者: nft_expr_init\n- 被调用者: 未显示\n\n5. 函数名: kfree\n- 参数: [expr]\n- 调用者: nft_expr_init\n- 被调用者: 未显示\n\n6. 函数名: module_put\n- 参数: [owner]\n- 调用者: nft_expr_init\n- 被调用者: 未显示\n\n7. 函数名: ERR_PTR\n- 参数: [err]\n- 调用者: nft_expr_init\n- 被调用者: 未显示"
    },
    {
        "id": 3570,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3239",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中Empia 28xx系列电视卡USB设备的探测、初始化和配置功能，包括设备资源分配、接口检测、传输模式设置等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在em28xx_usb_probe函数中，当设备初始化失败时未正确清理已分配的资源和引用计数，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: em28xx_usb_probe\n- 参数: [struct usb_interface *intf, const struct usb_device_id *id]\n- 调用者: 内核USB子系统\n- 被调用者: [usb_get_dev, interface_to_usbdev, find_first_zero_bit, test_and_set_bit, dev_err, dev_info, kzalloc, kcalloc, kfree, em28xx_check_usb_descriptor, snprintf, mutex_init, em28xx_init_dev, em28xx_duplicate_dev, em28xx_write_reg, mdelay, kref_init, request_modules, media_device_register, clear_bit, usb_put_dev]\n\n2. 函数名: find_first_zero_bit\n- 参数: [em28xx_devused, EM28XX_MAXBOARDS]\n- 调用者: em28xx_usb_probe\n- 被调用者: []\n\n3. 函数名: test_and_set_bit\n- 参数: [nr, em28xx_devused]\n- 调用者: em28xx_usb_probe\n- 被调用者: []\n\n4. 函数名: usb_get_dev\n- 参数: [interface_to_usbdev(intf)]\n- 调用者: em28xx_usb_probe\n- 被调用者: []\n\n5. 函数名: interface_to_usbdev\n- 参数: [intf]\n- 调用者: em28xx_usb_probe\n- 被调用者: []\n\n6. 函数名: kzalloc\n- 参数: [sizeof(*dev), GFP_KERNEL]\n- 调用者: em28xx_usb_probe\n- 被调用者: []\n\n7. 函数名: kcalloc\n- 参数: [intf->num_altsetting, sizeof(dev->alt_max_pkt_size_isoc[0]), GFP_KERNEL]\n- 调用者: em28xx_usb_probe\n- 被调用者: []\n\n8. 函数名: kfree\n- 参数: [dev]\n- 调用者: em28xx_usb_probe\n- 被调用者: []\n\n9. 函数名: em28xx_check_usb_descriptor\n- 参数: [dev, udev, intf, i, ep, &has_vendor_audio, &has_video, &has_dvb]\n- 调用者: em28xx_usb_probe\n- 被调用者: []\n\n10. 函数名: snprintf\n- 参数: [dev->name, 28, \"em28xx\"]\n- 调用者: em28xx_usb_probe\n- 被调用者: []\n\n11. 函数名: mutex_init\n- 参数: [&dev->lock]\n- 调用者: em28xx_usb_probe\n- 被调用者: []\n\n12. 函数名: em28xx_init_dev\n- 参数: [dev, udev, intf, nr]\n- 调用者: em28xx_usb_probe\n- 被调用者: []\n\n13. 函数名: em28xx_duplicate_dev\n- 参数: [dev]\n- 调用者: em28xx_usb_probe\n- 被调用者: []\n\n14. 函数名: em28xx_write_reg\n- 参数: [dev, 0x0b, 0x96], [dev, 0x0b, 0x80], [dev, 0x0b, 0x82]\n- 调用者: em28xx_usb_probe\n- 被调用者: []\n\n15. 函数名: mdelay\n- 参数: [100]\n- 调用者: em28xx_usb_probe\n- 被调用者: []\n\n16. 函数名: kref_init\n- 参数: [&dev->ref], [&dev->dev_next->ref]\n- 调用者: em28xx_usb_probe\n- 被调用者: []\n\n17. 函数名: request_modules\n- 参数: [dev]\n- 调用者: em28xx_usb_probe\n- 被调用者: []\n\n18. 函数名: media_device_register\n- 参数: [dev->media_dev]\n- 调用者: em28xx_usb_probe\n- 被调用者: []\n\n19. 函数名: clear_bit\n- 参数: [nr, em28xx_devused]\n- 调用者: em28xx_usb_probe\n- 被调用者: []\n\n20. 函数名: usb_put_dev\n- 参数: [udev]\n- 调用者: em28xx_usb_probe\n- 被调用者: []"
    },
    {
        "id": 3594,
        "cwe": "CWE-416",
        "cve": "CVE-2022-33981",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中软盘驱动程序的IOCTL命令处理功能，包括软盘弹出、格式化、参数设置等操作控制。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在raw_cmd_ioctl函数中，由于并发操作导致释放后的raw_cmd被继续使用，造成了use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: fd_locked_ioctl\n- 参数: [struct block_device *bdev, fmode_t mode, unsigned int cmd, unsigned long param]\n- 调用者: 未显示\n- 被调用者: [normalize_ioctl, fd_copyin, fd_eject, lock_fdc, process_fd_request, invalidate_drive, set_geometry, get_floppy_geometry, poll_drive, do_format, user_reset_fdc, raw_cmd_ioctl, twaddle, fd_copyout]\n\n2. 函数名: normalize_ioctl\n- 参数: [unsigned int *cmd, int *size]\n- 调用者: fd_locked_ioctl\n- 被调用者: 未显示\n\n3. 函数名: fd_copyin\n- 参数: [void __user *param, void *inparam, int size]\n- 调用者: fd_locked_ioctl\n- 被调用者: 未显示\n\n4. 函数名: fd_eject\n- 参数: [int drive]\n- 调用者: fd_locked_ioctl\n- 被调用者: 未显示\n\n5. 函数名: lock_fdc\n- 参数: [int drive]\n- 调用者: fd_locked_ioctl\n- 被调用者: 未显示\n\n6. 函数名: process_fd_request\n- 参数: []\n- 调用者: fd_locked_ioctl\n- 被调用者: 未显示\n\n7. 函数名: invalidate_drive\n- 参数: [struct block_device *bdev]\n- 调用者: fd_locked_ioctl\n- 被调用者: 未显示\n\n8. 函数名: set_geometry\n- 参数: [int cmd, struct floppy_struct *g, int drive, int type, struct block_device *bdev]\n- 调用者: fd_locked_ioctl\n- 被调用者: 未显示\n\n9. 函数名: get_floppy_geometry\n- 参数: [int drive, int type, struct floppy_struct **outparam]\n- 调用者: fd_locked_ioctl\n- 被调用者: 未显示\n\n10. 函数名: poll_drive\n- 参数: [bool, int]\n- 调用者: fd_locked_ioctl\n- 被调用者: 未显示\n\n11. 函数名: do_format\n- 参数: [int drive, struct format_descr *f]\n- 调用者: fd_locked_ioctl\n- 被调用者: 未显示\n\n12. 函数名: user_reset_fdc\n- 参数: [int drive, int param, bool]\n- 调用者: fd_locked_ioctl\n- 被调用者: 未显示\n\n13. 函数名: raw_cmd_ioctl\n- 参数: [int cmd, void __user *param]\n- 调用者: fd_locked_ioctl\n- 被调用者: 未显示\n\n14. 函数名: twaddle\n- 参数: [int current_fdc, int current_drive]\n- 调用者: fd_locked_ioctl\n- 被调用者: 未显示\n\n15. 函数名: fd_copyout\n- 参数: [void __user *param, const void *outparam, int size]\n- 调用者: fd_locked_ioctl\n- 被调用者: 未显示"
    },
    {
        "id": 3595,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3424",
        "purpose": "Code purpose:\"\"\"处理用户对GRU驱动程序的调用请求，包括对回调指针的验证、线程状态管理以及上下文更新等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在gru_handle_user_call_os函数中，由于对用户提供的回调指针(cb)检查不充分，可能导致释放后重用(use-after-free)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: gru_handle_user_call_os\n- 参数: [unsigned long cb]\n- 调用者: 未显示\n- 被调用者: [get_cb_number, gru_find_lock_gts, gru_dbg, gru_check_context_placement, gru_update_cch, thread_cbr_number, get_tfh_by_index, get_gseg_base_address_cb, gru_user_dropin, gru_unlock_gts]\n\n2. 函数名: get_cb_number\n- 参数: [void *cb]\n- 调用者: gru_handle_user_call_os\n- 被调用者: 未显示\n\n3. 函数名: gru_find_lock_gts\n- 参数: [unsigned long cb]\n- 调用者: gru_handle_user_call_os\n- 被调用者: 未显示\n\n4. 函数名: gru_dbg\n- 参数: [grudev, \"address 0x%lx, gid %d, gts 0x%p\\n\", cb, gts->ts_gru ? gts->ts_gru->gs_gid : -1, gts]\n- 调用者: gru_handle_user_call_os\n- 被调用者: 未显示\n\n5. 函数名: gru_check_context_placement\n- 参数: [gts]\n- 调用者: gru_handle_user_call_os\n- 被调用者: 未显示\n\n6. 函数名: gru_update_cch\n- 参数: [gts]\n- 调用者: gru_handle_user_call_os\n- 被调用者: 未显示\n\n7. 函数名: thread_cbr_number\n- 参数: [gts, ucbnum]\n- 调用者: gru_handle_user_call_os\n- 被调用者: 未显示\n\n8. 函数名: get_tfh_by_index\n- 参数: [gts->ts_gru, cbrnum]\n- 调用者: gru_handle_user_call_os\n- 被调用者: 未显示\n\n9. 函数名: get_gseg_base_address_cb\n- 参数: [gts->ts_gru->gs_gru_base_vaddr, gts->ts_ctxnum, ucbnum]\n- 调用者: gru_handle_user_call_os\n- 被调用者: 未显示\n\n10. 函数名: gru_user_dropin\n- 参数: [gts, tfh, cbk]\n- 调用者: gru_handle_user_call_os\n- 被调用者: 未显示\n\n11. 函数名: gru_unlock_gts\n- 参数: [gts]\n- 调用者: gru_handle_user_call_os\n- 被调用者: 未显示"
    },
    {
        "id": 3596,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3424",
        "purpose": "Code purpose:\"\"\"该代码用于设置GRU驱动程序的上下文选项，包括选择blade/chiplet、注册GSEG所有者以及设置CCH切片选项等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在gru_set_context_option函数中，由于对gts对象的引用计数管理不当，在gru_unlock_gts调用后可能导致已释放的内存被继续使用，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: gru_set_context_option\n- 参数: [unsigned long arg]\n- 调用者: 未显示\n- 被调用者: [copy_from_user, gru_dbg, gru_find_lock_gts, gru_alloc_locked_gts, gru_check_context_placement, gru_unlock_gts]\n\n2. 函数名: copy_from_user\n- 参数: [&req, (void __user *)arg, sizeof(req)]\n- 调用者: gru_set_context_option\n- 被调用者: 未显示\n\n3. 函数名: gru_dbg\n- 参数: [grudev, \"op %d, gseg 0x%lx, value1 0x%lx\\n\", req.op, req.gseg, req.val1]\n- 调用者: gru_set_context_option\n- 被调用者: 未显示\n\n4. 函数名: gru_find_lock_gts\n- 参数: [req.gseg]\n- 调用者: gru_set_context_option\n- 被调用者: 未显示\n\n5. 函数名: gru_alloc_locked_gts\n- 参数: [req.gseg]\n- 调用者: gru_set_context_option\n- 被调用者: 未显示\n\n6. 函数名: gru_check_context_placement\n- 参数: [gts]\n- 调用者: gru_set_context_option\n- 被调用者: 未显示\n\n7. 函数名: gru_unlock_gts\n- 参数: [gts]\n- 调用者: gru_set_context_option\n- 被调用者: 未显示"
    },
    {
        "id": 3597,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3424",
        "purpose": "Code purpose:\"\"\"处理内存页错误并管理GRU线程状态的上下文分配和映射\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在gru_fault函数中，由于未能正确处理线程状态(gts)的锁定和释放，可能导致在再次尝试获取上下文时(goto again)出现竞争条件，从而引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: gru_fault\n- 参数: [struct vm_fault *vmf]\n- 调用者: 未显示（由内核调用）\n- 被调用者: [gru_dbg, gru_find_thread_state, mutex_lock, preempt_disable, gru_check_context_placement, gru_assign_gru_context, preempt_enable, mutex_unlock, set_current_state, schedule_timeout, gru_steal_context, gru_load_context, gseg_physical_address, remap_pfn_range]\n\n2. 函数名: gru_dbg\n- 参数: [grudev, \"vma %p, vaddr 0x%lx (0x%lx)\\n\", vma, vaddr, GSEG_BASE(vaddr)]\n- 调用者: gru_fault\n- 被调用者: []\n\n3. 函数名: gru_find_thread_state\n- 参数: [vma, TSID(vaddr, vma)]\n- 调用者: gru_fault\n- 被调用者: []\n\n4. 函数名: mutex_lock\n- 参数: [&gts->ts_ctxlock]\n- 调用者: gru_fault\n- 被调用者: []\n\n5. 函数名: preempt_disable\n- 参数: []\n- 调用者: gru_fault\n- 被调用者: []\n\n6. 函数名: gru_check_context_placement\n- 参数: [gts]\n- 调用者: gru_fault\n- 被调用者: []\n\n7. 函数名: gru_assign_gru_context\n- 参数: [gts]\n- 调用者: gru_fault\n- 被调用者: []\n\n8. 函数名: preempt_enable\n- 参数: []\n- 调用者: gru_fault\n- 被调用者: []\n\n9. 函数名: mutex_unlock\n- 参数: [&gts->ts_ctxlock]\n- 调用者: gru_fault\n- 被调用者: []\n\n10. 函数名: set_current_state\n- 参数: [TASK_INTERRUPTIBLE]\n- 调用者: gru_fault\n- 被调用者: []\n\n11. 函数名: schedule_timeout\n- 参数: [GRU_ASSIGN_DELAY]\n- 调用者: gru_fault\n- 被调用者: []\n\n12. 函数名: gru_steal_context\n- 参数: [gts]\n- 调用者: gru_fault\n- 被调用者: []\n\n13. 函数名: gru_load_context\n- 参数: [gts]\n- 调用者: gru_fault\n- 被调用者: []\n\n14. 函数名: gseg_physical_address\n- 参数: [gts->ts_gru, gts->ts_ctxnum]\n- 调用者: gru_fault\n- 被调用者: []\n\n15. 函数名: remap_pfn_range\n- 参数: [vma, vaddr & ~(GRU_GSEG_PAGESIZE - 1), paddr >> PAGE_SHIFT, GRU_GSEG_PAGESIZE, vma->vm_page_prot]\n- 调用者: gru_fault\n- 被调用者: []"
    },
    {
        "id": 3598,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3424",
        "purpose": "Code purpose:\"\"\"检查并验证GRU线程状态中的上下文放置是否正确，必要时卸载或重定向中断。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在gru_check_chiplet_assignment函数检查失败后，gru_unload_context释放了资源，但后续的gru_retarget_intr可能继续访问已释放的资源，导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: gru_check_context_placement\n- 参数: [struct gru_thread_state *gts]\n- 调用者: 未明确（可能是外部调用）\n- 被调用者: [gru_check_chiplet_assignment, gru_unload_context, gru_retarget_intr]\n\n2. 函数名: gru_check_chiplet_assignment\n- 参数: [struct gru_state *gru, struct gru_thread_state *gts]\n- 调用者: gru_check_context_placement\n- 被调用者: []\n\n3. 函数名: gru_unload_context\n- 参数: [struct gru_thread_state *gts, int 1]\n- 调用者: gru_check_context_placement\n- 被调用者: []\n\n4. 函数名: gru_retarget_intr\n- 参数: [struct gru_thread_state *gts]\n- 调用者: gru_check_context_placement\n- 被调用者: []"
    },
    {
        "id": 3605,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3523",
        "purpose": "Code purpose:\"\"\"该代码用于在KVM虚拟化环境中释放UVMEMM内存页，处理页面的移出和共享标志的移除操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放内存后仍可能通过vma指针访问已释放的内存区域，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: kvmppc_uvmem_drop_pages\n- 参数: [slot, kvm, skip_page_out]\n- 调用者: 未显示\n- 被调用者: [mmap_read_lock, vma_lookup, pr_err, mutex_lock, kvmppc_gfn_is_uvmem_pfn, pfn_to_page, __kvmppc_svm_page_out, kvmppc_gfn_remove, mutex_unlock, mmap_read_unlock]\n\n2. 函数名: vma_lookup\n- 参数: [kvm->mm, addr]\n- 调用者: kvmppc_uvmem_drop_pages\n- 被调用者: 未显示\n\n3. 函数名: pr_err\n- 参数: [format string, gfn]\n- 调用者: kvmppc_uvmem_drop_pages\n- 被调用者: 未显示\n\n4. 函数名: mutex_lock\n- 参数: [&kvm->arch.uvmem_lock]\n- 调用者: kvmppc_uvmem_drop_pages\n- 被调用者: 未显示\n\n5. 函数名: kvmppc_gfn_is_uvmem_pfn\n- 参数: [gfn, kvm, &uvmem_pfn]\n- 调用者: kvmppc_uvmem_drop_pages\n- 被调用者: 未显示\n\n6. 函数名: pfn_to_page\n- 参数: [uvmem_pfn]\n- 调用者: kvmppc_uvmem_drop_pages\n- 被调用者: 未显示\n\n7. 函数名: __kvmppc_svm_page_out\n- 参数: [vma, addr, addr + PAGE_SIZE, PAGE_SHIFT, kvm, pvt->gpa]\n- 调用者: kvmppc_uvmem_drop_pages\n- 被调用者: 未显示\n\n8. 函数名: kvmppc_gfn_remove\n- 参数: [gfn, kvm]\n- 调用者: kvmppc_uvmem_drop_pages\n- 被调用者: 未显示\n\n9. 函数名: mutex_unlock\n- 参数: [&kvm->arch.uvmem_lock]\n- 调用者: kvmppc_uvmem_drop_pages\n- 被调用者: 未显示\n\n10. 函数名: mmap_read_lock\n- 参数: [kvm->mm]\n- 调用者: kvmppc_uvmem_drop_pages\n- 被调用者: 未显示\n\n11. 函数名: mmap_read_unlock\n- 参数: [kvm->mm]\n- 调用者: kvmppc_uvmem_drop_pages\n- 被调用者: 未显示"
    },
    {
        "id": 3606,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3523",
        "purpose": "Code purpose:\"\"\"该代码用于处理KVM虚拟化环境中安全虚拟机(SVM)的页面换出操作，检查参数有效性并执行页面换出功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放内存后仍可能访问vma结构体，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: kvmppc_h_svm_page_out\n- 参数: [kvm, gpa, flags, page_shift]\n- 调用者: 未显示\n- 被调用者: [srcu_read_lock, mmap_read_lock, gfn_to_hva, kvm_is_error_hva, find_vma_intersection, kvmppc_svm_page_out, mmap_read_unlock, srcu_read_unlock]\n\n2. 函数名: srcu_read_lock\n- 参数: [&kvm->srcu]\n- 调用者: kvmppc_h_svm_page_out\n- 被调用者: 未显示\n\n3. 函数名: mmap_read_lock\n- 参数: [kvm->mm]\n- 调用者: kvmppc_h_svm_page_out\n- 被调用者: 未显示\n\n4. 函数名: gfn_to_hva\n- 参数: [kvm, gfn]\n- 调用者: kvmppc_h_svm_page_out\n- 被调用者: 未显示\n\n5. 函数名: kvm_is_error_hva\n- 参数: [start]\n- 调用者: kvmppc_h_svm_page_out\n- 被调用者: 未显示\n\n6. 函数名: find_vma_intersection\n- 参数: [kvm->mm, start, end]\n- 调用者: kvmppc_h_svm_page_out\n- 被调用者: 未显示\n\n7. 函数名: kvmppc_svm_page_out\n- 参数: [vma, start, end, page_shift, kvm, gpa]\n- 调用者: kvmppc_h_svm_page_out\n- 被调用者: 未显示\n\n8. 函数名: mmap_read_unlock\n- 参数: [kvm->mm]\n- 调用者: kvmppc_h_svm_page_out\n- 被调用者: 未显示\n\n9. 函数名: srcu_read_unlock\n- 参数: [&kvm->srcu, srcu_idx]\n- 调用者: kvmppc_h_svm_page_out\n- 被调用者: 未显示"
    },
    {
        "id": 3607,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3523",
        "purpose": "Code purpose:\"\"\"该代码片段实现了KVM虚拟化中用户空间内存页迁移到RAM的功能，处理页面错误时可能触发使用后释放漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在kvmppc_uvmem_migrate_to_ram函数中，对vmf->page->zone_device_data的使用未进行空指针检查，可能导致释放后重用(use-after-free)。\"\"\"",
        "functions": "Functions:\n1. 函数名: kvmppc_uvmem_migrate_to_ram\n- 参数: [struct vm_fault *vmf]\n- 调用者: 未明确（由内核内存管理子系统调用）\n- 被调用者: [kvmppc_svm_page_out]\n\n2. 函数名: kvmppc_svm_page_out\n- 参数: [struct vm_area_struct *vma, unsigned long address, unsigned long end, unsigned int shift, struct kvm *kvm, unsigned long gpa]\n- 调用者: kvmppc_uvmem_migrate_to_ram\n- 被调用者: []"
    },
    {
        "id": 3608,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3523",
        "purpose": "Code purpose:\"\"\"该代码片段实现了KVM虚拟化环境中将主机内存页面迁移到客户机内存的功能，包括页面迁移设置、验证和最终执行。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在kvmppc_svm_page_in函数中，由于对migrate_vma结构体的使用不当，可能导致在内存迁移过程中出现释放后重用(UAF)的情况。\"\"\"",
        "functions": "Functions:\n1. 函数名: kvmppc_svm_page_in\n- 参数: [vma, start, end, gpa, kvm, page_shift, pagein]\n- 调用者: 未显示\n- 被调用者: [memset, migrate_vma_setup, kvmppc_uvmem_get_page, migrate_pfn_to_page, uv_page_in, migrate_pfn, page_to_pfn, migrate_vma_pages, migrate_vma_finalize]\n\n2. 函数名: memset\n- 参数: [&mig, 0, sizeof(mig)]\n- 调用者: kvmppc_svm_page_in\n- 被调用者: []\n\n3. 函数名: migrate_vma_setup\n- 参数: [&mig]\n- 调用者: kvmppc_svm_page_in\n- 被调用者: []\n\n4. 函数名: kvmppc_uvmem_get_page\n- 参数: [gpa, kvm]\n- 调用者: kvmppc_svm_page_in\n- 被调用者: []\n\n5. 函数名: migrate_pfn_to_page\n- 参数: [*mig.src]\n- 调用者: kvmppc_svm_page_in\n- 被调用者: []\n\n6. 函数名: uv_page_in\n- 参数: [kvm->arch.lpid, pfn << page_shift, gpa, 0, page_shift]\n- 调用者: kvmppc_svm_page_in\n- 被调用者: []\n\n7. 函数名: migrate_pfn\n- 参数: [page_to_pfn(dpage)]\n- 调用者: kvmppc_svm_page_in\n- 被调用者: []\n\n8. 函数名: page_to_pfn\n- 参数: [dpage]\n- 调用者: kvmppc_svm_page_in\n- 被调用者: []\n\n9. 函数名: migrate_vma_pages\n- 参数: [&mig]\n- 调用者: kvmppc_svm_page_in\n- 被调用者: []\n\n10. 函数名: migrate_vma_finalize\n- 参数: [&mig]\n- 调用者: kvmppc_svm_page_in\n- 被调用者: []"
    },
    {
        "id": 3609,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3523",
        "purpose": "Code purpose:\"\"\"处理SVM(共享虚拟内存)范围内的CPU页错误，将虚拟内存从VRAM迁移到RAM\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放内存后仍可能访问已被释放的parent或prange结构体，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: svm_migrate_to_ram\n- 参数: [struct vm_fault *vmf]\n- 调用者: 未显示（由内核页错误处理程序调用）\n- 被调用者: [kfd_lookup_process_by_mm, kfd_unref_process, svm_range_from_addr, svm_range_split_by_granularity, svm_migrate_vram_to_ram, svm_range_add_list_work, schedule_deferred_list_work, svm_range_lock, svm_range_unlock, mutex_lock, mutex_unlock, mutex_lock_nested]\n\n2. 函数名: kfd_lookup_process_by_mm\n- 参数: [struct mm_struct *mm]\n- 调用者: svm_migrate_to_ram\n- 被调用者: 未显示\n\n3. 函数名: kfd_unref_process\n- 参数: [struct kfd_process *p]\n- 调用者: svm_migrate_to_ram\n- 被调用者: 未显示\n\n4. 函数名: svm_range_from_addr\n- 参数: [struct svm_range_list *svms, unsigned long addr, struct svm_range **parent]\n- 调用者: svm_migrate_to_ram\n- 被调用者: 未显示\n\n5. 函数名: svm_range_split_by_granularity\n- 参数: [struct kfd_process *p, struct mm_struct *mm, unsigned long addr, struct svm_range *parent, struct svm_range *prange]\n- 调用者: svm_migrate_to_ram\n- 被调用者: 未显示\n\n6. 函数名: svm_migrate_vram_to_ram\n- 参数: [struct svm_range *prange, struct mm_struct *mm, enum kfd_migrate_trigger trigger]\n- 调用者: svm_migrate_to_ram\n- 被调用者: 未显示\n\n7. 函数名: svm_range_add_list_work\n- 参数: [struct svm_range_list *svms, struct svm_range *prange, struct mm_struct *mm, enum svm_work_list_ops op]\n- 调用者: svm_migrate_to_ram\n- 被调用者: 未显示\n\n8. 函数名: schedule_deferred_list_work\n- 参数: [struct svm_range_list *svms]\n- 调用者: svm_migrate_to_ram\n- 被调用者: 未显示\n\n9. 函数名: svm_range_lock\n- 参数: [struct svm_range *prange]\n- 调用者: svm_migrate_to_ram\n- 被调用者: 未显示\n\n10. 函数名: svm_range_unlock\n- 参数: [struct svm_range *prange]\n- 调用者: svm_migrate_to_ram\n- 被调用者: 未显示\n\n11. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: svm_migrate_to_ram\n- 被调用者: 未显示\n\n12. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: svm_migrate_to_ram\n- 被调用者: 未显示\n\n13. 函数名: mutex_lock_nested\n- 参数: [struct mutex *lock, int subclass]\n- 调用者: svm_migrate_to_ram\n- 被调用者: 未显示"
    },
    {
        "id": 3610,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3523",
        "purpose": "Code purpose:\"\"\"该代码片段实现了将内存区域从系统内存迁移到显存的功能，主要用于AMD GPU设备的内存管理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在内存迁移过程中未正确处理内存释放与后续访问的关系，导致存在释放后使用(use-after-free)的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: svm_migrate_vma_to_vram\n- 参数: [struct amdgpu_device *adev, struct svm_range *prange, struct vm_area_struct *vma, uint64_t start, uint64_t end, uint32_t trigger]\n- 调用者: 未显示\n- 被调用者: [container_of, kvcalloc, kfd_smi_event_migration_start, migrate_vma_setup, svm_migrate_copy_to_vram, migrate_vma_pages, svm_migrate_successful_pages, svm_migrate_copy_done, migrate_vma_finalize, kfd_smi_event_migration_end, svm_range_dma_unmap, svm_range_free_dma_mappings, kvfree, svm_range_get_pdd_by_adev, WRITE_ONCE]\n\n2. 函数名: container_of\n- 参数: [prange->svms, struct kfd_process, svms]\n- 调用者: svm_migrate_vma_to_vram\n- 被调用者: 无\n\n3. 函数名: kvcalloc\n- 参数: [npages, 2 * sizeof(*migrate.src) + sizeof(uint64_t) + sizeof(dma_addr_t), GFP_KERNEL]\n- 调用者: svm_migrate_vma_to_vram\n- 被调用者: 无\n\n4. 函数名: kfd_smi_event_migration_start\n- 参数: [adev->kfd.dev, p->lead_thread->pid, start >> PAGE_SHIFT, end >> PAGE_SHIFT, 0, adev->kfd.dev->id, prange->prefetch_loc, prange->preferred_loc, trigger]\n- 调用者: svm_migrate_vma_to_vram\n- 被调用者: 无\n\n5. 函数名: migrate_vma_setup\n- 参数: [&migrate]\n- 调用者: svm_migrate_vma_to_vram\n- 被调用者: 无\n\n6. 函数名: svm_migrate_copy_to_vram\n- 参数: [adev, prange, &migrate, &mfence, scratch]\n- 调用者: svm_migrate_vma_to_vram\n- 被调用者: 无\n\n7. 函数名: migrate_vma_pages\n- 参数: [&migrate]\n- 调用者: svm_migrate_vma_to_vram\n- 被调用者: 无\n\n8. 函数名: svm_migrate_successful_pages\n- 参数: [&migrate]\n- 调用者: svm_migrate_vma_to_vram\n- 被调用者: 无\n\n9. 函数名: svm_migrate_copy_done\n- 参数: [adev, mfence]\n- 调用者: svm_migrate_vma_to_vram\n- 被调用者: 无\n\n10. 函数名: migrate_vma_finalize\n- 参数: [&migrate]\n- 调用者: svm_migrate_vma_to_vram\n- 被调用者: 无\n\n11. 函数名: kfd_smi_event_migration_end\n- 参数: [adev->kfd.dev, p->lead_thread->pid, start >> PAGE_SHIFT, end >> PAGE_SHIFT, 0, adev->kfd.dev->id, trigger]\n- 调用者: svm_migrate_vma_to_vram\n- 被调用者: 无\n\n12. 函数名: svm_range_dma_unmap\n- 参数: [adev->dev, scratch, 0, npages]\n- 调用者: svm_migrate_vma_to_vram\n- 被调用者: 无\n\n13. 函数名: svm_range_free_dma_mappings\n- 参数: [prange]\n- 调用者: svm_migrate_vma_to_vram\n- 被调用者: 无\n\n14. 函数名: kvfree\n- 参数: [buf]\n- 调用者: svm_migrate_vma_to_vram\n- 被调用者: 无\n\n15. 函数名: svm_range_get_pdd_by_adev\n- 参数: [prange, adev]\n- 调用者: svm_migrate_vma_to_vram\n- 被调用者: 无\n\n16. 函数名: WRITE_ONCE\n- 参数: [pdd->page_in, pdd->page_in + cpages]\n- 调用者: svm_migrate_vma_to_vram\n- 被调用者: 无"
    },
    {
        "id": 3611,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3523",
        "purpose": "Code purpose:\"\"\"将VRAM内存范围从源GPU迁移到目标GPU，期间通过系统内存作为中转桥梁\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在svm_migrate_vram_to_vram函数中，由于对prange对象的实际位置(actual_loc)检查不足，可能导致在对象已被释放后仍被访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: svm_migrate_vram_to_vram\n- 参数: [struct svm_range *prange, uint32_t best_loc, struct mm_struct *mm, uint32_t trigger]\n- 调用者: 未显示\n- 被调用者: [svm_migrate_vram_to_ram, svm_migrate_ram_to_vram]\n\n2. 函数名: svm_migrate_vram_to_ram\n- 参数: [struct svm_range *prange, struct mm_struct *mm, uint32_t trigger]\n- 调用者: svm_migrate_vram_to_vram\n- 被调用者: 未显示\n\n3. 函数名: svm_migrate_ram_to_vram\n- 参数: [struct svm_range *prange, uint32_t best_loc, struct mm_struct *mm, uint32_t trigger]\n- 调用者: svm_migrate_vram_to_vram\n- 被调用者: 未显示"
    },
    {
        "id": 3612,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3523",
        "purpose": "Code purpose:\"\"\"该代码片段实现了在SVM(Shared Virtual Memory)范围内处理BO(Buffer Object)的驱逐工作，包括内存迁移和资源释放等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放svm_bo对象后，由于未正确处理引用计数和同步机制，导致后续代码可能继续访问已被释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: svm_range_evict_svm_bo_worker\n- 参数: [work]\n- 调用者: 未知（由工作队列机制调用）\n- 被调用者: [container_of, svm_bo_ref_unless_zero, mmget_not_zero, svm_range_bo_unref, mmap_read_lock, spin_lock, list_empty, list_first_entry, list_del_init, spin_unlock, pr_debug, mutex_lock, svm_migrate_vram_to_ram, pr_info_once, mutex_unlock, mmap_read_unlock, mmput, dma_fence_signal, WARN_ONCE, kref_read]\n\n2. 函数名: svm_bo_ref_unless_zero\n- 参数: [svm_bo]\n- 调用者: svm_range_evict_svm_bo_worker\n- 被调用者: []\n\n3. 函数名: mmget_not_zero\n- 参数: [svm_bo->eviction_fence->mm]\n- 调用者: svm_range_evict_svm_bo_worker\n- 被调用者: []\n\n4. 函数名: svm_range_bo_unref\n- 参数: [svm_bo]\n- 调用者: svm_range_evict_svm_bo_worker\n- 被调用者: []\n\n5. 函数名: mmap_read_lock\n- 参数: [mm]\n- 调用者: svm_range_evict_svm_bo_worker\n- 被调用者: []\n\n6. 函数名: spin_lock\n- 参数: [&svm_bo->list_lock]\n- 调用者: svm_range_evict_svm_bo_worker\n- 被调用者: []\n\n7. 函数名: list_empty\n- 参数: [&svm_bo->range_list]\n- 调用者: svm_range_evict_svm_bo_worker\n- 被调用者: []\n\n8. 函数名: list_first_entry\n- 参数: [&svm_bo->range_list, struct svm_range, svm_bo_list]\n- 调用者: svm_range_evict_svm_bo_worker\n- 被调用者: []\n\n9. 函数名: list_del_init\n- 参数: [&prange->svm_bo_list]\n- 调用者: svm_range_evict_svm_bo_worker\n- 被调用者: []\n\n10. 函数名: spin_unlock\n- 参数: [&svm_bo->list_lock]\n- 调用者: svm_range_evict_svm_bo_worker\n- 被调用者: []\n\n11. 函数名: pr_debug\n- 参数: [\"svms 0x%p [0x%lx 0x%lx]\\n\", prange->svms, prange->start, prange->last]\n- 调用者: svm_range_evict_svm_bo_worker\n- 被调用者: []\n\n12. 函数名: mutex_lock\n- 参数: [&prange->migrate_mutex]\n- 调用者: svm_range_evict_svm_bo_worker\n- 被调用者: []\n\n13. 函数名: svm_migrate_vram_to_ram\n- 参数: [prange, mm, KFD_MIGRATE_TRIGGER_TTM_EVICTION]\n- 调用者: svm_range_evict_svm_bo_worker\n- 被调用者: []\n\n14. 函数名: pr_info_once\n- 参数: [\"Migration failed during eviction\"]\n- 调用者: svm_range_evict_svm_bo_worker\n- 被调用者: []\n\n15. 函数名: mutex_unlock\n- 参数: [&prange->migrate_mutex]\n- 调用者: svm_range_evict_svm_bo_worker\n- 被调用者: []\n\n16. 函数名: mmap_read_unlock\n- 参数: [mm]\n- 调用者: svm_range_evict_svm_bo_worker\n- 被调用者: []\n\n17. 函数名: mmput\n- 参数: [mm]\n- 调用者: svm_range_evict_svm_bo_worker\n- 被调用者: []\n\n18. 函数名: dma_fence_signal\n- 参数: [&svm_bo->eviction_fence->base]\n- 调用者: svm_range_evict_svm_bo_worker\n- 被调用者: []\n\n19. 函数名: WARN_ONCE\n- 参数: [!r && kref_read(&svm_bo->kref) != 1, \"This was not the last reference\\n\"]\n- 调用者: svm_range_evict_svm_bo_worker\n- 被调用者: []\n\n20. 函数名: kref_read\n- 参数: [&svm_bo->kref]\n- 调用者: WARN_ONCE\n- 被调用者: []"
    },
    {
        "id": 3613,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3523",
        "purpose": "Code purpose:\"\"\"该代码片段用于在SVM范围内根据最佳预取位置触发内存迁移操作，包括从VRAM迁移到RAM或迁移到指定VRAM位置\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在svm_range_trigger_migration函数中，对内存迁移操作后的内存区域可能存在释放后使用(use-after-free)的情况，导致安全漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: svm_range_trigger_migration\n- 参数: [struct mm_struct *mm, struct svm_range *prange, bool *migrated]\n- 调用者: 未提供\n- 被调用者: [svm_range_best_prefetch_location, svm_migrate_vram_to_ram, svm_migrate_to_vram]\n\n2. 函数名: svm_range_best_prefetch_location\n- 参数: [struct svm_range *prange]\n- 调用者: svm_range_trigger_migration\n- 被调用者: 未提供\n\n3. 函数名: svm_migrate_vram_to_ram\n- 参数: [struct svm_range *prange, struct mm_struct *mm, int KFD_MIGRATE_TRIGGER_PREFETCH]\n- 调用者: svm_range_trigger_migration\n- 被调用者: 未提供\n\n4. 函数名: svm_migrate_to_vram\n- 参数: [struct svm_range *prange, uint32_t best_loc, struct mm_struct *mm, int KFD_MIGRATE_TRIGGER_PREFETCH]\n- 调用者: svm_range_trigger_migration\n- 被调用者: 未提供"
    },
    {
        "id": 3614,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3523",
        "purpose": "Code purpose:\"\"\"该代码用于处理AMD GPU设备中共享虚拟内存(SVM)范围的页面恢复操作，包括处理页面错误、内存迁移和验证映射等任务。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在svm_range_restore_pages函数中，由于对mm_struct对象的引用计数管理不当，可能导致在mmput(mm)调用后仍存在对该对象的后续使用，从而引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: svm_range_restore_pages\n- 参数: [struct amdgpu_device *adev, unsigned int pasid, uint64_t addr, bool write_fault]\n- 调用者: N/A\n- 被调用者: [kfd_lookup_process_by_pasid, get_task_mm, svm_range_from_addr, svm_range_create_unregistered_range, svm_range_skip_recover, amdgpu_gmc_filter_faults_remove, find_vma, svm_fault_allowed, svm_range_best_restore_location, kfd_smi_event_page_fault_start, svm_migrate_to_vram, svm_migrate_vram_to_ram, svm_range_validate_and_map, kfd_smi_event_page_fault_end, svm_range_count_fault, mmput, kfd_unref_process]\n\n2. 函数名: kfd_lookup_process_by_pasid\n- 参数: [unsigned int pasid]\n- 调用者: svm_range_restore_pages\n- 被调用者: N/A\n\n3. 函数名: get_task_mm\n- 参数: [struct task_struct *task]\n- 调用者: svm_range_restore_pages\n- 被调用者: N/A\n\n4. 函数名: svm_range_from_addr\n- 参数: [struct svm_range_list *svms, uint64_t addr, void *dummy]\n- 调用者: svm_range_restore_pages\n- 被调用者: N/A\n\n5. 函数名: svm_range_create_unregistered_range\n- 参数: [struct amdgpu_device *adev, struct kfd_process *p, struct mm_struct *mm, uint64_t addr]\n- 调用者: svm_range_restore_pages\n- 被调用者: N/A\n\n6. 函数名: svm_range_skip_recover\n- 参数: [struct svm_range *prange]\n- 调用者: svm_range_restore_pages\n- 被调用者: N/A\n\n7. 函数名: amdgpu_gmc_filter_faults_remove\n- 参数: [struct amdgpu_device *adev, uint64_t addr, unsigned int pasid]\n- 调用者: svm_range_restore_pages\n- 被调用者: N/A\n\n8. 函数名: find_vma\n- 参数: [struct mm_struct *mm, unsigned long addr]\n- 调用者: svm_range_restore_pages\n- 被调用者: N/A\n\n9. 函数名: svm_fault_allowed\n- 参数: [struct vm_area_struct *vma, bool write_fault]\n- 调用者: svm_range_restore_pages\n- 被调用者: N/A\n\n10. 函数名: svm_range_best_restore_location\n- 参数: [struct svm_range *prange, struct amdgpu_device *adev, int32_t *gpuidx]\n- 调用者: svm_range_restore_pages\n- 被调用者: N/A\n\n11. 函数名: kfd_smi_event_page_fault_start\n- 参数: [struct kfd_dev *dev, pid_t pid, uint64_t address, bool write_fault, ktime_t timestamp]\n- 调用者: svm_range_restore_pages\n- 被调用者: N/A\n\n12. 函数名: svm_migrate_to_vram\n- 参数: [struct svm_range *prange, int32_t best_loc, struct mm_struct *mm, enum kfd_migrate_trigger trigger]\n- 调用者: svm_range_restore_pages\n- 被调用者: N/A\n\n13. 函数名: svm_migrate_vram_to_ram\n- 参数: [struct svm_range *prange, struct mm_struct *mm, enum kfd_migrate_trigger trigger]\n- 调用者: svm_range_restore_pages\n- 被调用者: N/A\n\n14. 函数名: svm_range_validate_and_map\n- 参数: [struct mm_struct *mm, struct svm_range *prange, int32_t gpuidx, bool wait, bool intr, bool ignore_huge_pages]\n- 调用者: svm_range_restore_pages\n- 被调用者: N/A\n\n15. 函数名: kfd_smi_event_page_fault_end\n- 参数: [struct kfd_dev *dev, pid_t pid, uint64_t address, bool migration]\n- 调用者: svm_range_restore_pages\n- 被调用者: N/A\n\n16. 函数名: svm_range_count_fault\n- 参数: [struct amdgpu_device *adev, struct kfd_process *p, int32_t gpuidx]\n- 调用者: svm_range_restore_pages\n- 被调用者: N/A\n\n17. 函数名: mmput\n- 参数: [struct mm_struct *mm]\n- 调用者: svm_range_restore_pages\n- 被调用者: N/A\n\n18. 函数名: kfd_unref_process\n- 参数: [struct kfd_process *p]\n- 调用者: svm_range_restore_pages\n- 被调用者: N/A"
    },
    {
        "id": 3615,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3523",
        "purpose": "Code purpose:\"\"\"该代码实现了将内存页面从系统内存迁移到设备内存的功能，并验证迁移后的数据。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在内存迁移过程中，由于未正确处理内存区域的引用计数，导致在内存释放后仍可能被访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: dmirror_migrate_to_device\n- 参数: [dmirror, cmd]\n- 调用者: 未显示\n- 被调用者: [mmget_not_zero, vma_lookup, min, migrate_vma_setup, dmirror_migrate_alloc_and_copy, migrate_vma_pages, dmirror_migrate_finalize_and_map, migrate_vma_finalize, dmirror_bounce_init, dmirror_do_read, copy_to_user, dmirror_bounce_fini]\n\n2. 函数名: mmget_not_zero\n- 参数: [mm]\n- 调用者: dmirror_migrate_to_device\n- 被调用者: 未显示\n\n3. 函数名: vma_lookup\n- 参数: [mm, addr]\n- 调用者: dmirror_migrate_to_device\n- 被调用者: 未显示\n\n4. 函数名: min\n- 参数: [end, addr + (ARRAY_SIZE(src_pfns) << PAGE_SHIFT)]\n- 调用者: dmirror_migrate_to_device\n- 被调用者: 未显示\n\n5. 函数名: migrate_vma_setup\n- 参数: [&args]\n- 调用者: dmirror_migrate_to_device\n- 被调用者: 未显示\n\n6. 函数名: dmirror_migrate_alloc_and_copy\n- 参数: [&args, dmirror]\n- 调用者: dmirror_migrate_to_device\n- 被调用者: 未显示\n\n7. 函数名: migrate_vma_pages\n- 参数: [&args]\n- 调用者: dmirror_migrate_to_device\n- 被调用者: 未显示\n\n8. 函数名: dmirror_migrate_finalize_and_map\n- 参数: [&args, dmirror]\n- 调用者: dmirror_migrate_to_device\n- 被调用者: 未显示\n\n9. 函数名: migrate_vma_finalize\n- 参数: [&args]\n- 调用者: dmirror_migrate_to_device\n- 被调用者: 未显示\n\n10. 函数名: dmirror_bounce_init\n- 参数: [&bounce, start, size]\n- 调用者: dmirror_migrate_to_device\n- 被调用者: 未显示\n\n11. 函数名: dmirror_do_read\n- 参数: [dmirror, start, end, &bounce]\n- 调用者: dmirror_migrate_to_device\n- 被调用者: 未显示\n\n12. 函数名: copy_to_user\n- 参数: [u64_to_user_ptr(cmd->ptr), bounce.ptr, bounce.size]\n- 调用者: dmirror_migrate_to_device\n- 被调用者: 未显示\n\n13. 函数名: dmirror_bounce_fini\n- 参数: [&bounce]\n- 调用者: dmirror_migrate_to_device\n- 被调用者: 未显示"
    },
    {
        "id": 3616,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3523",
        "purpose": "Code purpose:\"\"\"将设备内存中的数据迁移到系统内存中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在内存迁移过程中，由于未正确处理内存引用计数，导致在释放内存后仍可能被访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: dmirror_migrate_to_system\n- 参数: [dmirror, cmd]\n- 调用者: 未显示\n- 被调用者: [mmget_not_zero, vma_lookup, min, migrate_vma_setup, dmirror_devmem_fault_alloc_and_copy, migrate_vma_pages, dmirror_successful_migrated_pages, migrate_vma_finalize, mmap_read_unlock, mmput]\n\n2. 函数名: mmget_not_zero\n- 参数: [mm]\n- 调用者: dmirror_migrate_to_system\n- 被调用者: 未显示\n\n3. 函数名: vma_lookup\n- 参数: [mm, addr]\n- 调用者: dmirror_migrate_to_system\n- 被调用者: 未显示\n\n4. 函数名: min\n- 参数: [end, addr + (ARRAY_SIZE(src_pfns) << PAGE_SHIFT)]\n- 调用者: dmirror_migrate_to_system\n- 被调用者: 未显示\n\n5. 函数名: migrate_vma_setup\n- 参数: [&args]\n- 调用者: dmirror_migrate_to_system\n- 被调用者: 未显示\n\n6. 函数名: dmirror_devmem_fault_alloc_and_copy\n- 参数: [&args, dmirror]\n- 调用者: dmirror_migrate_to_system\n- 被调用者: 未显示\n\n7. 函数名: migrate_vma_pages\n- 参数: [&args]\n- 调用者: dmirror_migrate_to_system\n- 被调用者: 未显示\n\n8. 函数名: dmirror_successful_migrated_pages\n- 参数: [&args]\n- 调用者: dmirror_migrate_to_system\n- 被调用者: 未显示\n\n9. 函数名: migrate_vma_finalize\n- 参数: [&args]\n- 调用者: dmirror_migrate_to_system\n- 被调用者: 未显示\n\n10. 函数名: mmap_read_unlock\n- 参数: [mm]\n- 调用者: dmirror_migrate_to_system\n- 被调用者: 未显示\n\n11. 函数名: mmput\n- 参数: [mm]\n- 调用者: dmirror_migrate_to_system\n- 被调用者: 未显示"
    },
    {
        "id": 3617,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3523",
        "purpose": "Code purpose:\"\"\"该代码实现了设备内存镜像的页面错误处理功能，包括设置迁移参数、分配和复制页面以及完成迁移过程。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在dmirror_devmem_fault函数中，对zone_device_data指针的使用未进行充分验证，可能导致在释放后仍被访问的use-after-free问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: dmirror_devmem_fault\n- 参数: [struct vm_fault *vmf]\n- 调用者: 未指定（由内核调用）\n- 被调用者: [migrate_vma_setup, dmirror_devmem_fault_alloc_and_copy, migrate_vma_pages, migrate_vma_finalize]\n\n2. 函数名: migrate_vma_setup\n- 参数: [struct migrate_vma *args]\n- 调用者: dmirror_devmem_fault\n- 被调用者: 未指定\n\n3. 函数名: dmirror_devmem_fault_alloc_and_copy\n- 参数: [struct migrate_vma *args, struct dmirror *dmirror]\n- 调用者: dmirror_devmem_fault\n- 被调用者: 未指定\n\n4. 函数名: migrate_vma_pages\n- 参数: [struct migrate_vma *args]\n- 调用者: dmirror_devmem_fault\n- 被调用者: 未指定\n\n5. 函数名: migrate_vma_finalize\n- 参数: [struct migrate_vma *args]\n- 调用者: dmirror_devmem_fault\n- 被调用者: 未指定\n\n6. 函数名: dmirror_select_device\n- 参数: [struct dmirror *dmirror]\n- 调用者: dmirror_devmem_fault\n- 被调用者: 未指定"
    },
    {
        "id": 3618,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3523",
        "purpose": "Code purpose:\"\"\"处理Linux内核中内存管理模块的交换页(swap page)错误，包括从交换区读取页面、处理页面错误、更新页表等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在内存管理函数do_swap_page中，存在对已释放交换缓存的后续访问，导致释放后重用(UAF)问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: do_swap_page\n- 参数: [struct vm_fault *vmf]\n- 调用者: 未显示（由内核页错误处理机制调用）\n- 被调用者: [pte_unmap_same, pte_to_swp_entry, non_swap_entry, is_migration_entry, migration_entry_wait, is_device_exclusive_entry, pfn_swap_entry_to_page, remove_device_exclusive_entry, is_device_private_entry, is_hwpoison_entry, is_swapin_error_entry, is_pte_marker_entry, handle_pte_marker, print_bad_pte, get_swap_device, swap_cache_get_folio, folio_file_page, __swap_count, vma_alloc_folio, __folio_set_locked, __folio_set_swapbacked, mem_cgroup_swapin_charge_folio, mem_cgroup_swapin_uncharge_swap, get_shadow_from_swap_cache, workingset_refault, folio_add_lru, folio_set_swap_entry, swap_readpage, swapin_readahead, page_folio, pte_offset_map_lock, pte_same, folio_lock_or_retry, folio_test_swapcache, page_private, ksm_might_need_to_copy, lru_add_drain, cgroup_throttle_swaprate, folio_test_uptodate, swap_free, should_try_to_free_swap, folio_free_swap, inc_mm_counter_fast, dec_mm_counter_fast, mk_pte, maybe_mkwrite, pte_mkdirty, flush_icache_page, pte_swp_soft_dirty, pte_mksoft_dirty, pte_swp_uffd_wp, pte_mkuffd_wp, pte_wrprotect, page_add_new_anon_rmap, folio_add_lru_vma, page_add_anon_rmap, set_pte_at, arch_do_swap_page, do_wp_page, update_mmu_cache, pte_unmap_unlock, put_swap_device, folio_unlock, folio_put]\n\n2. 函数名: pte_unmap_same\n- 参数: [struct vm_fault *vmf]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n3. 函数名: pte_to_swp_entry\n- 参数: [pte_t pte]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n4. 函数名: non_swap_entry\n- 参数: [swp_entry_t entry]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n5. 函数名: is_migration_entry\n- 参数: [swp_entry_t entry]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n6. 函数名: migration_entry_wait\n- 参数: [struct mm_struct *mm, pmd_t *pmd, unsigned long address]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n7. 函数名: is_device_exclusive_entry\n- 参数: [swp_entry_t entry]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n8. 函数名: pfn_swap_entry_to_page\n- 参数: [swp_entry_t entry]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n9. 函数名: remove_device_exclusive_entry\n- 参数: [struct vm_fault *vmf]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n10. 函数名: is_device_private_entry\n- 参数: [swp_entry_t entry]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n11. 函数名: is_hwpoison_entry\n- 参数: [swp_entry_t entry]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n12. 函数名: is_swapin_error_entry\n- 参数: [swp_entry_t entry]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n13. 函数名: is_pte_marker_entry\n- 参数: [swp_entry_t entry]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n14. 函数名: handle_pte_marker\n- 参数: [struct vm_fault *vmf]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n15. 函数名: print_bad_pte\n- 参数: [struct vm_area_struct *vma, unsigned long addr, pte_t pte, void *arg]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n16. 函数名: get_swap_device\n- 参数: [swp_entry_t entry]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n17. 函数名: swap_cache_get_folio\n- 参数: [swp_entry_t entry, struct vm_area_struct *vma, unsigned long addr]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n18. 函数名: folio_file_page\n- 参数: [struct folio *folio, pgoff_t index]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n19. 函数名: __swap_count\n- 参数: [swp_entry_t entry]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n20. 函数名: vma_alloc_folio\n- 参数: [gfp_t gfp, int order, struct vm_area_struct *vma, unsigned long addr, bool hugepage]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n21. 函数名: __folio_set_locked\n- 参数: [struct folio *folio]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n22. 函数名: __folio_set_swapbacked\n- 参数: [struct folio *folio]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n23. 函数名: mem_cgroup_swapin_charge_folio\n- 参数: [struct folio *folio, struct mm_struct *mm, gfp_t gfp, swp_entry_t entry]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n24. 函数名: mem_cgroup_swapin_uncharge_swap\n- 参数: [swp_entry_t entry]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n25. 函数名: get_shadow_from_swap_cache\n- 参数: [swp_entry_t entry]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n26. 函数名: workingset_refault\n- 参数: [struct folio *folio, void *shadow]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n27. 函数名: folio_add_lru\n- 参数: [struct folio *folio]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n28. 函数名: folio_set_swap_entry\n- 参数: [struct folio *folio, swp_entry_t entry]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n29. 函数名: swap_readpage\n- 参数: [struct page *page, bool synchronous, struct swap_iocb **plug]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n30. 函数名: swapin_readahead\n- 参数: [swp_entry_t entry, gfp_t gfp_mask, struct vm_fault *vmf]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n31. 函数名: page_folio\n- 参数: [struct page *page]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n32. 函数名: pte_offset_map_lock\n- 参数: [struct mm_struct *mm, pmd_t *pmd, unsigned long address, spinlock_t **ptl]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n33. 函数名: pte_same\n- 参数: [pte_t a, pte_t b]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n34. 函数名: folio_lock_or_retry\n- 参数: [struct folio *folio, struct mm_struct *mm, unsigned int flags]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n35. 函数名: folio_test_swapcache\n- 参数: [struct folio *folio]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n36. 函数名: page_private\n- 参数: [struct page *page]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n37. 函数名: ksm_might_need_to_copy\n- 参数: [struct page *page, struct vm_area_struct *vma, unsigned long addr]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n38. 函数名: lru_add_drain\n- 参数: []\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n39. 函数名: cgroup_throttle_swaprate\n- 参数: [struct page *page, gfp_t gfp_mask]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n40. 函数名: folio_test_uptodate\n- 参数: [struct folio *folio]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n41. 函数名: swap_free\n- 参数: [swp_entry_t entry]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n42. 函数名: should_try_to_free_swap\n- 参数: [struct folio *folio, struct vm_area_struct *vma, unsigned int flags]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n43. 函数名: folio_free_swap\n- 参数: [struct folio *folio]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n44. 函数名: inc_mm_counter_fast\n- 参数: [struct mm_struct *mm, int member]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n45. 函数名: dec_mm_counter_fast\n- 参数: [struct mm_struct *mm, int member]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n46. 函数名: mk_pte\n- 参数: [struct page *page, pgprot_t prot]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n47. 函数名: maybe_mkwrite\n- 参数: [pte_t pte, struct vm_area_struct *vma]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n48. 函数名: pte_mkdirty\n- 参数: [pte_t pte]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n49. 函数名: flush_icache_page\n- 参数: [struct vm_area_struct *vma, struct page *page]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n50. 函数名: pte_swp_soft_dirty\n- 参数: [pte_t pte]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n51. 函数名: pte_mksoft_dirty\n- 参数: [pte_t pte]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n52. 函数名: pte_swp_uffd_wp\n- 参数: [pte_t pte]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n53. 函数名: pte_mkuffd_wp\n- 参数: [pte_t pte]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n54. 函数名: pte_wrprotect\n- 参数: [pte_t pte]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n55. 函数名: page_add_new_anon_rmap\n- 参数: [struct page *page, struct vm_area_struct *vma, unsigned long address]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n56. 函数名: folio_add_lru_vma\n- 参数: [struct folio *folio, struct vm_area_struct *vma]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n57. 函数名: page_add_anon_rmap\n- 参数: [struct page *page, struct vm_area_struct *vma, unsigned long address, rmap_t flags]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n58. 函数名: set_pte_at\n- 参数: [struct mm_struct *mm, unsigned long addr, pte_t *ptep, pte_t pte]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n59. 函数名: arch_do_swap_page\n- 参数: [struct mm_struct *mm, struct vm_area_struct *vma, unsigned long addr, pte_t *ptep, pte_t orig_pte]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n60. 函数名: do_wp_page\n- 参数: [struct vm_fault *vmf]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n61. 函数名: update_mmu_cache\n- 参数: [struct vm_area_struct *vma, unsigned long addr, pte_t *ptep]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n62. 函数名: pte_unmap_unlock\n- 参数: [pte_t *pte, spinlock_t *ptl]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n63. 函数名: put_swap_device\n- 参数: [struct swap_info_struct *si]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n64. 函数名: folio_unlock\n- 参数: [struct folio *folio]\n- 调用者: do_swap_page\n- 被调用者: 未显示\n\n65. 函数名: folio_put\n- 参数: [struct folio *folio]\n- 调用者: do_swap_page\n- 被调用者: 未显示"
    },
    {
        "id": 3619,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3523",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中迁移内存页面的内容，包括处理映射关系和根据迁移模式决定复制或标记页面\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在迁移页面时未正确处理写回完成状态，导致释放后使用(use-after-free)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: migrate_folio\n- 参数: [struct address_space *mapping, struct folio *dst, struct folio *src, enum migrate_mode mode]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [folio_test_writeback, folio_migrate_mapping, folio_migrate_copy, folio_migrate_flags]\n\n2. 函数名: folio_test_writeback\n- 参数: [struct folio *src]\n- 调用者: migrate_folio\n- 被调用者: 未明确\n\n3. 函数名: folio_migrate_mapping\n- 参数: [struct address_space *mapping, struct folio *dst, struct folio *src, int 0]\n- 调用者: migrate_folio\n- 被调用者: 未明确\n\n4. 函数名: folio_migrate_copy\n- 参数: [struct folio *dst, struct folio *src]\n- 调用者: migrate_folio\n- 被调用者: 未明确\n\n5. 函数名: folio_migrate_flags\n- 参数: [struct folio *dst, struct folio *src]\n- 调用者: migrate_folio\n- 被调用者: 未明确"
    },
    {
        "id": 3620,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3523",
        "purpose": "Code purpose:\"\"\"该代码用于实现内存页迁移功能，处理虚拟内存区域(VMA)中的页面迁移操作，包括设备私有页和一致性页的特殊处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在内存迁移过程中，由于未正确处理内存页面的释放和通知机制，导致在后续操作中可能访问已释放的内存区域，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: migrate_vma_pages\n- 参数: [struct migrate_vma *migrate]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [migrate_pfn_to_page, mmu_notifier_range_init_owner, mmu_notifier_invalidate_range_start, migrate_vma_insert_page, page_mapping, is_device_private_page, is_device_coherent_page, is_zone_device_page, migrate_folio, mmu_notifier_invalidate_range_only_end]\n\n2. 函数名: migrate_pfn_to_page\n- 参数: [unsigned long pfn]\n- 调用者: migrate_vma_pages\n- 被调用者: []\n\n3. 函数名: mmu_notifier_range_init_owner\n- 参数: [struct mmu_notifier_range *range, enum mmu_notifier_event event, unsigned flags, struct vm_area_struct *vma, struct mm_struct *mm, unsigned long start, unsigned long end, void *owner]\n- 调用者: migrate_vma_pages\n- 被调用者: []\n\n4. 函数名: mmu_notifier_invalidate_range_start\n- 参数: [struct mmu_notifier_range *range]\n- 调用者: migrate_vma_pages\n- 被调用者: []\n\n5. 函数名: migrate_vma_insert_page\n- 参数: [struct migrate_vma *migrate, unsigned long addr, struct page *page, unsigned long *src]\n- 调用者: migrate_vma_pages\n- 被调用者: []\n\n6. 函数名: page_mapping\n- 参数: [struct page *page]\n- 调用者: migrate_vma_pages\n- 被调用者: []\n\n7. 函数名: is_device_private_page\n- 参数: [struct page *page]\n- 调用者: migrate_vma_pages\n- 被调用者: []\n\n8. 函数名: is_device_coherent_page\n- 参数: [struct page *page]\n- 调用者: migrate_vma_pages\n- 被调用者: []\n\n9. 函数名: is_zone_device_page\n- 参数: [struct page *page]\n- 调用者: migrate_vma_pages\n- 被调用者: []\n\n10. 函数名: migrate_folio\n- 参数: [struct address_space *mapping, struct folio *dst, struct folio *src, enum migrate_mode mode]\n- 调用者: migrate_vma_pages\n- 被调用者: []\n\n11. 函数名: mmu_notifier_invalidate_range_only_end\n- 参数: [struct mmu_notifier_range *range]\n- 调用者: migrate_vma_pages\n- 被调用者: []\n\n12. 函数名: page_folio\n- 参数: [struct page *page]\n- 调用者: migrate_vma_pages\n- 被调用者: []"
    },
    {
        "id": 3621,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3523",
        "purpose": "Code purpose:\"\"\"该代码用于设置和管理内存迁移操作，包括验证输入参数、收集和解除映射待迁移的内存页\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在migrate_vma_setup函数中，由于未正确验证和处理内存页面的锁定状态，导致在页面迁移过程中可能发生释放后使用(UAF)的情况。\"\"\"",
        "functions": "Functions:\n1. 函数名: migrate_vma_setup\n- 参数: [struct migrate_vma *args]\n- 调用者: 未明确显示（由外部调用）\n- 被调用者: [is_vm_hugetlb_page, vma_is_dax, memset, migrate_vma_collect, migrate_vma_unmap]\n\n2. 函数名: is_vm_hugetlb_page\n- 参数: [args->vma]\n- 调用者: migrate_vma_setup\n- 被调用者: []\n\n3. 函数名: vma_is_dax\n- 参数: [args->vma]\n- 调用者: migrate_vma_setup\n- 被调用者: []\n\n4. 函数名: memset\n- 参数: [args->src, 0, sizeof(*args->src) * nr_pages]\n- 调用者: migrate_vma_setup\n- 被调用者: []\n\n5. 函数名: migrate_vma_collect\n- 参数: [args]\n- 调用者: migrate_vma_setup\n- 被调用者: []\n\n6. 函数名: migrate_vma_unmap\n- 参数: [args]\n- 调用者: migrate_vma_setup\n- 被调用者: []"
    },
    {
        "id": 3622,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3523",
        "purpose": "Code purpose:\"\"\"该代码用于迁移虚拟内存区域中的页面，处理页面映射和隔离，并在迁移失败时恢复页面状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在迁移虚拟内存区域时，由于未正确处理页面引用计数和LRU列表管理，导致页面在释放后仍可能被访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: migrate_vma_unmap\n- 参数: [struct migrate_vma *migrate]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [lru_add_drain, migrate_pfn_to_page, is_zone_device_page, PageLRU, lru_add_drain_all, isolate_lru_page, put_page, page_folio, folio_mapped, try_to_migrate, page_mapped, migrate_vma_check_page, get_page, putback_lru_page, remove_migration_ptes, folio_unlock, folio_put]\n\n2. 函数名: lru_add_drain\n- 参数: []\n- 调用者: migrate_vma_unmap\n- 被调用者: []\n\n3. 函数名: migrate_pfn_to_page\n- 参数: [migrate->src[i]]\n- 调用者: migrate_vma_unmap\n- 被调用者: []\n\n4. 函数名: is_zone_device_page\n- 参数: [page]\n- 调用者: migrate_vma_unmap\n- 被调用者: []\n\n5. 函数名: PageLRU\n- 参数: [page]\n- 调用者: migrate_vma_unmap\n- 被调用者: []\n\n6. 函数名: lru_add_drain_all\n- 参数: []\n- 调用者: migrate_vma_unmap\n- 被调用者: []\n\n7. 函数名: isolate_lru_page\n- 参数: [page]\n- 调用者: migrate_vma_unmap\n- 被调用者: []\n\n8. 函数名: put_page\n- 参数: [page]\n- 调用者: migrate_vma_unmap\n- 被调用者: []\n\n9. 函数名: page_folio\n- 参数: [page]\n- 调用者: migrate_vma_unmap\n- 被调用者: []\n\n10. 函数名: folio_mapped\n- 参数: [folio]\n- 调用者: migrate_vma_unmap\n- 被调用者: []\n\n11. 函数名: try_to_migrate\n- 参数: [folio, 0]\n- 调用者: migrate_vma_unmap\n- 被调用者: []\n\n12. 函数名: page_mapped\n- 参数: [page]\n- 调用者: migrate_vma_unmap\n- 被调用者: []\n\n13. 函数名: migrate_vma_check_page\n- 参数: [page]\n- 调用者: migrate_vma_unmap\n- 被调用者: []\n\n14. 函数名: get_page\n- 参数: [page]\n- 调用者: migrate_vma_unmap\n- 被调用者: []\n\n15. 函数名: putback_lru_page\n- 参数: [page]\n- 调用者: migrate_vma_unmap\n- 被调用者: []\n\n16. 函数名: remove_migration_ptes\n- 参数: [folio, folio, false]\n- 调用者: migrate_vma_unmap\n- 被调用者: []\n\n17. 函数名: folio_unlock\n- 参数: [folio]\n- 调用者: migrate_vma_unmap\n- 被调用者: []\n\n18. 函数名: folio_put\n- 参数: [folio]\n- 调用者: migrate_vma_unmap\n- 被调用者: []"
    },
    {
        "id": 3628,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3534",
        "purpose": "Code purpose:\"\"\"该代码用于统计并更新给定名称在哈希表中的重复出现次数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在btf_dump_name_dups函数中，对hashmap的操作可能导致释放后重用(use-after-free)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: btf_dump_name_dups\n- 参数: [struct btf_dump *d, struct hashmap *name_map, const char *orig_name]\n- 调用者: 未提供（代码片段中未显示）\n- 被调用者: [hashmap__find, hashmap__set]"
    },
    {
        "id": 3629,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3534",
        "purpose": "Code purpose:\"\"\"释放BTF(BPF Type Format)转储结构体及其相关资源的内存\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在btf_dump__free函数中释放资源后，可能存在后续对已释放内存的访问，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: btf_dump__free\n- 参数: [struct btf_dump *d]\n- 调用者: 未显示\n- 被调用者: [free, IS_ERR_OR_NULL, hashmap__free]\n\n2. 函数名: free\n- 参数: [void *ptr]\n- 调用者: btf_dump__free\n- 被调用者: 无\n\n3. 函数名: IS_ERR_OR_NULL\n- 参数: [const void *ptr]\n- 调用者: btf_dump__free\n- 被调用者: 无\n\n4. 函数名: hashmap__free\n- 参数: [struct hashmap *map]\n- 调用者: btf_dump__free\n- 被调用者: 无"
    },
    {
        "id": 3651,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3586",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核网络调度器sch_sfb的入队功能，用于管理网络数据包的排队和流量控制。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在sch_sfb入队函数中，当SKB被入队到子队列并被释放后，仍然错误地使用了该SKB的cb字段，导致了释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: sfb_enqueue\n- 参数: [skb, sch, to_free]\n- 调用者: 无（作为队列操作的回调函数被内核调度）\n- 被调用者: [qdisc_qstats_overlimit, qdisc_qstats_drop, sfb_swap_slot, sfb_classify, siphash_1u32, skb_get_hash_perturb, sfb_skb_cb, decrement_prob, increment_prob, sfb_rate_limit, prandom_u32, INET_ECN_set_ce, qdisc_enqueue, qdisc_qstats_backlog_inc, increment_qlen, qdisc_drop, kfree_skb]\n\n2. 函数名: qdisc_qstats_overlimit\n- 参数: [sch]\n- 调用者: sfb_enqueue\n- 被调用者: 无\n\n3. 函数名: qdisc_qstats_drop\n- 参数: [sch]\n- 调用者: sfb_enqueue\n- 被调用者: 无\n\n4. 函数名: sfb_swap_slot\n- 参数: [q]\n- 调用者: sfb_enqueue\n- 被调用者: 无\n\n5. 函数名: sfb_classify\n- 参数: [skb, fl, ret, salt]\n- 调用者: sfb_enqueue\n- 被调用者: 无\n\n6. 函数名: siphash_1u32\n- 参数: [salt, &q->bins[slot].perturbation]\n- 调用者: sfb_enqueue\n- 被调用者: 无\n\n7. 函数名: skb_get_hash_perturb\n- 参数: [skb, &q->bins[slot].perturbation]\n- 调用者: sfb_enqueue\n- 被调用者: 无\n\n8. 函数名: sfb_skb_cb\n- 参数: [skb]\n- 调用者: sfb_enqueue\n- 被调用者: 无\n\n9. 函数名: decrement_prob\n- 参数: [b, q]\n- 调用者: sfb_enqueue\n- 被调用者: 无\n\n10. 函数名: increment_prob\n- 参数: [b, q]\n- 调用者: sfb_enqueue\n- 被调用者: 无\n\n11. 函数名: sfb_rate_limit\n- 参数: [skb, q]\n- 调用者: sfb_enqueue\n- 被调用者: 无\n\n12. 函数名: prandom_u32\n- 参数: 无\n- 调用者: sfb_enqueue\n- 被调用者: 无\n\n13. 函数名: INET_ECN_set_ce\n- 参数: [skb]\n- 调用者: sfb_enqueue\n- 被调用者: 无\n\n14. 函数名: qdisc_enqueue\n- 参数: [skb, child, to_free]\n- 调用者: sfb_enqueue\n- 被调用者: 无\n\n15. 函数名: qdisc_qstats_backlog_inc\n- 参数: [sch, skb]\n- 调用者: sfb_enqueue\n- 被调用者: 无\n\n16. 函数名: increment_qlen\n- 参数: [skb, q]\n- 调用者: sfb_enqueue\n- 被调用者: 无\n\n17. 函数名: qdisc_drop\n- 参数: [skb, sch, to_free]\n- 调用者: sfb_enqueue\n- 被调用者: 无\n\n18. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: sfb_enqueue\n- 被调用者: 无"
    },
    {
        "id": 3678,
        "cwe": "CWE-416",
        "cve": "CVE-2022-38457",
        "purpose": "Code purpose:\"\"\"通过RCU机制查找并返回与给定key匹配的ttm_base_object对象，同时增加引用计数以防止对象被释放\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ttm_base_object_lookup函数中，由于未正确处理引用计数可能导致在对象被释放后仍被访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ttm_base_object_lookup\n- 参数: [struct ttm_object_file *tfile, uint64_t key]\n- 调用者: 未明确（可能是外部调用）\n- 被调用者: [ttm_tfile_find_ref_rcu, hlist_entry, kref_get_unless_zero]\n\n2. 函数名: ttm_tfile_find_ref_rcu\n- 参数: [struct ttm_object_file *tfile, uint64_t key, struct vmwgfx_hash_item **hash]\n- 调用者: ttm_base_object_lookup\n- 被调用者: 未明确\n\n3. 函数名: hlist_entry\n- 参数: [struct vmwgfx_hash_item *hash, struct ttm_ref_object, hash]\n- 调用者: ttm_base_object_lookup\n- 被调用者: 未明确\n\n4. 函数名: kref_get_unless_zero\n- 参数: [struct kref *refcount]\n- 调用者: ttm_base_object_lookup\n- 被调用者: 未明确"
    },
    {
        "id": 3679,
        "cwe": "CWE-416",
        "cve": "CVE-2022-38457",
        "purpose": "Code purpose:\"\"\"该代码片段实现了在vmwgfx驱动中处理DX绑定流输出命令的功能，包括验证上下文、查找流输出资源、设置大小并执行资源切换备份操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在函数vmw_cmd_dx_bind_streamoutput中，对资源res的操作可能导致在释放后仍被使用的情况，从而引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_cmd_dx_bind_streamoutput\n- 参数: [dev_priv, sw_context, header]\n- 调用者: 未指定\n- 被调用者: [has_sm5_context, vmw_dx_streamoutput_lookup, vmw_context_res_man, IS_ERR, PTR_ERR, vmw_dx_streamoutput_set_size, vmw_execbuf_res_noctx_val_add, vmw_cmd_res_switch_backup]\n\n2. 函数名: has_sm5_context\n- 参数: [dev_priv]\n- 调用者: vmw_cmd_dx_bind_streamoutput\n- 被调用者: []\n\n3. 函数名: vmw_dx_streamoutput_lookup\n- 参数: [vmw_context_res_man(ctx_node->ctx), cmd->body.soid]\n- 调用者: vmw_cmd_dx_bind_streamoutput\n- 被调用者: []\n\n4. 函数名: vmw_context_res_man\n- 参数: [ctx_node->ctx]\n- 调用者: vmw_cmd_dx_bind_streamoutput\n- 被调用者: []\n\n5. 函数名: IS_ERR\n- 参数: [res]\n- 调用者: vmw_cmd_dx_bind_streamoutput\n- 被调用者: []\n\n6. 函数名: PTR_ERR\n- 参数: [res]\n- 调用者: vmw_cmd_dx_bind_streamoutput\n- 被调用者: []\n\n7. 函数名: vmw_dx_streamoutput_set_size\n- 参数: [res, cmd->body.sizeInBytes]\n- 调用者: vmw_cmd_dx_bind_streamoutput\n- 被调用者: []\n\n8. 函数名: vmw_execbuf_res_noctx_val_add\n- 参数: [sw_context, res, VMW_RES_DIRTY_NONE]\n- 调用者: vmw_cmd_dx_bind_streamoutput\n- 被调用者: []\n\n9. 函数名: vmw_cmd_res_switch_backup\n- 参数: [dev_priv, sw_context, res, &cmd->body.mobid, cmd->body.offsetInBytes]\n- 调用者: vmw_cmd_dx_bind_streamoutput\n- 被调用者: []"
    },
    {
        "id": 3680,
        "cwe": "CWE-416",
        "cve": "CVE-2022-38457",
        "purpose": "Code purpose:\"\"\"将SVGAGuestPtr转换为vmw_buffer_object并进行验证和重定位处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在vmw_translate_guest_ptr函数中，vmw_bo对象在ttm_bo_put释放后被继续通过reloc->vbo引用，导致释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_translate_guest_ptr\n- 参数: [dev_priv, sw_context, ptr, vmw_bo_p]\n- 调用者: 未指定\n- 被调用者: [vmw_validation_preload_bo, vmw_user_bo_noref_lookup, vmw_validation_add_bo, ttm_bo_put, vmw_validation_mem_alloc, list_add_tail]\n\n2. 函数名: vmw_validation_preload_bo\n- 参数: [sw_context->ctx]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: 未指定\n\n3. 函数名: vmw_user_bo_noref_lookup\n- 参数: [sw_context->filp, handle]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: 未指定\n\n4. 函数名: vmw_validation_add_bo\n- 参数: [sw_context->ctx, vmw_bo, false, false]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: 未指定\n\n5. 函数名: ttm_bo_put\n- 参数: [&vmw_bo->base]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: 未指定\n\n6. 函数名: vmw_validation_mem_alloc\n- 参数: [sw_context->ctx, sizeof(*reloc)]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: 未指定\n\n7. 函数名: list_add_tail\n- 参数: [&reloc->head, &sw_context->bo_relocations]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: 未指定"
    },
    {
        "id": 3681,
        "cwe": "CWE-416",
        "cve": "CVE-2022-38457",
        "purpose": "Code purpose:\"\"\"该代码片段用于在vmwgfx驱动中处理DX上下文的绑定操作，包括资源查找、验证和添加等步骤。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在函数vmw_execbuf_tie_context中，资源res在被释放后仍可能通过sw_context->dx_ctx_node被访问，导致释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_execbuf_tie_context\n- 参数: [dev_priv, sw_context, handle]\n- 调用者: 未提供\n- 被调用者: [vmw_execbuf_res_size, vmw_validation_preload_res, vmw_user_resource_noref_lookup_handle, vmw_execbuf_res_noref_val_add, vmw_execbuf_info_from_res, vmw_context_res_man]\n\n2. 函数名: vmw_execbuf_res_size\n- 参数: [dev_priv, vmw_res_dx_context]\n- 调用者: vmw_execbuf_tie_context\n- 被调用者: 未提供\n\n3. 函数名: vmw_validation_preload_res\n- 参数: [sw_context->ctx, size]\n- 调用者: vmw_execbuf_tie_context\n- 被调用者: 未提供\n\n4. 函数名: vmw_user_resource_noref_lookup_handle\n- 参数: [dev_priv, sw_context->fp->tfile, handle, user_context_converter]\n- 调用者: vmw_execbuf_tie_context\n- 被调用者: 未提供\n\n5. 函数名: vmw_execbuf_res_noref_val_add\n- 参数: [sw_context, res, VMW_RES_DIRTY_SET]\n- 调用者: vmw_execbuf_tie_context\n- 被调用者: 未提供\n\n6. 函数名: vmw_execbuf_info_from_res\n- 参数: [sw_context, res]\n- 调用者: vmw_execbuf_tie_context\n- 被调用者: 未提供\n\n7. 函数名: vmw_context_res_man\n- 参数: [res]\n- 调用者: vmw_execbuf_tie_context\n- 被调用者: 未提供"
    },
    {
        "id": 3682,
        "cwe": "CWE-416",
        "cve": "CVE-2022-38457",
        "purpose": "Code purpose:\"\"\"该代码片段实现了虚拟机图形驱动中绑定着色器资源的操作，包括上下文验证、资源查找和备份切换等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在vmw_cmd_dx_bind_shader函数中，对资源检查后未正确管理上下文资源的生命周期，导致释放后仍被使用的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_cmd_dx_bind_shader\n- 参数: [dev_priv, sw_context, header]\n- 调用者: 未显示\n- 被调用者: [vmw_cmd_res_check, vmw_shader_lookup, vmw_execbuf_res_noctx_val_add, vmw_cmd_res_switch_backup]\n\n2. 函数名: vmw_cmd_res_check\n- 参数: [dev_priv, sw_context, vmw_res_context, VMW_RES_DIRTY_SET, user_context_converter, &cmd->body.cid, &ctx]\n- 调用者: vmw_cmd_dx_bind_shader\n- 被调用者: 未显示\n\n3. 函数名: vmw_shader_lookup\n- 参数: [vmw_context_res_man(ctx), cmd->body.shid, 0]\n- 调用者: vmw_cmd_dx_bind_shader\n- 被调用者: 未显示\n\n4. 函数名: vmw_execbuf_res_noctx_val_add\n- 参数: [sw_context, res, VMW_RES_DIRTY_NONE]\n- 调用者: vmw_cmd_dx_bind_shader\n- 被调用者: 未显示\n\n5. 函数名: vmw_cmd_res_switch_backup\n- 参数: [dev_priv, sw_context, res, &cmd->body.mobid, cmd->body.offsetInBytes]\n- 调用者: vmw_cmd_dx_bind_shader\n- 被调用者: 未显示"
    },
    {
        "id": 3683,
        "cwe": "CWE-416",
        "cve": "CVE-2022-38457",
        "purpose": "Code purpose:\"\"\"该代码片段实现了虚拟机图形驱动中设置着色器的功能，包括验证着色器类型、查找着色器资源并建立绑定关系。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在函数vmw_cmd_dx_set_shader中，对资源res的使用未进行充分的引用计数管理，可能导致释放后重用(UAF)的情况发生。\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_cmd_dx_set_shader\n- 参数: [dev_priv, sw_context, header]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [has_sm5_context, container_of, vmw_shader_lookup, vmw_execbuf_res_noctx_val_add, vmw_binding_add]\n\n2. 函数名: has_sm5_context\n- 参数: [dev_priv]\n- 调用者: vmw_cmd_dx_set_shader\n- 被调用者: []\n\n3. 函数名: container_of\n- 参数: [header, typeof(*cmd), header]\n- 调用者: vmw_cmd_dx_set_shader\n- 被调用者: []\n\n4. 函数名: vmw_shader_lookup\n- 参数: [sw_context->man, cmd->body.shaderId, 0]\n- 调用者: vmw_cmd_dx_set_shader\n- 被调用者: []\n\n5. 函数名: vmw_execbuf_res_noctx_val_add\n- 参数: [sw_context, res, VMW_RES_DIRTY_NONE]\n- 调用者: vmw_cmd_dx_set_shader\n- 被调用者: []\n\n6. 函数名: vmw_binding_add\n- 参数: [ctx_node->staged, &binding.bi, binding.shader_slot, 0]\n- 调用者: vmw_cmd_dx_set_shader\n- 被调用者: []"
    },
    {
        "id": 3684,
        "cwe": "CWE-416",
        "cve": "CVE-2022-38457",
        "purpose": "Code purpose:\"\"\"该代码用于处理虚拟机图形驱动中设置DX流输出的命令，包括验证上下文、资源查找和绑定操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在函数vmw_cmd_dx_set_streamoutput中，当资源查找失败时直接返回0而没有释放资源，可能导致后续使用已释放的资源，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_cmd_dx_set_streamoutput\n- 参数: [dev_priv, sw_context, header]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [container_of, DRM_ERROR, has_sm5_context, vmw_dx_streamoutput_lookup, IS_ERR, vmw_execbuf_res_noctx_val_add, vmw_binding_add]\n\n2. 函数名: container_of\n- 参数: [header, typeof(*cmd), header]\n- 调用者: vmw_cmd_dx_set_streamoutput\n- 被调用者: 无\n\n3. 函数名: DRM_ERROR\n- 参数: [\"DX Context not set.\"], [\"Error creating resource validation node.\"]\n- 调用者: vmw_cmd_dx_set_streamoutput\n- 被调用者: 无\n\n4. 函数名: has_sm5_context\n- 参数: [dev_priv]\n- 调用者: vmw_cmd_dx_set_streamoutput\n- 被调用者: 无\n\n5. 函数名: vmw_dx_streamoutput_lookup\n- 参数: [vmw_context_res_man(ctx_node->ctx), cmd->body.soid]\n- 调用者: vmw_cmd_dx_set_streamoutput\n- 被调用者: 无\n\n6. 函数名: IS_ERR\n- 参数: [res]\n- 调用者: vmw_cmd_dx_set_streamoutput\n- 被调用者: 无\n\n7. 函数名: vmw_execbuf_res_noctx_val_add\n- 参数: [sw_context, res, VMW_RES_DIRTY_NONE]\n- 调用者: vmw_cmd_dx_set_streamoutput\n- 被调用者: 无\n\n8. 函数名: vmw_binding_add\n- 参数: [sw_context->dx_ctx_node->staged, &binding.bi, 0, binding.slot]\n- 调用者: vmw_cmd_dx_set_streamoutput\n- 被调用者: 无\n\n9. 函数名: vmw_context_res_man\n- 参数: [ctx_node->ctx]\n- 调用者: vmw_cmd_dx_set_streamoutput (通过vmw_dx_streamoutput_lookup间接调用)\n- 被调用者: 无"
    },
    {
        "id": 3685,
        "cwe": "CWE-416",
        "cve": "CVE-2022-38457",
        "purpose": "Code purpose:\"\"\"该代码用于处理虚拟机图形设备驱动中设置着色器的命令，包括验证着色器类型、检查资源有效性以及管理上下文绑定关系。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在函数'vmw_cmd_res_check'中存在释放后重用(UAF)漏洞，攻击者可通过本地用户账户利用此漏洞提升权限或导致拒绝服务。\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_cmd_set_shader\n- 参数: [dev_priv, sw_context, header]\n- 调用者: N/A (顶层函数)\n- 被调用者: [container_of, VMW_DECLARE_CMD_VAR, vmw_cmd_res_check, vmw_shader_lookup, vmw_execbuf_res_noctx_val_add, vmw_resource_relocation_add, vmw_ptr_diff, vmw_execbuf_info_from_res, vmw_binding_add]\n\n2. 函数名: vmw_cmd_res_check\n- 参数: [dev_priv, sw_context, vmw_res_context, VMW_RES_DIRTY_SET, user_context_converter, &cmd->body.cid, &ctx]\n- 调用者: vmw_cmd_set_shader\n- 被调用者: N/A (假设是底层函数)\n\n3. 函数名: vmw_shader_lookup\n- 参数: [vmw_context_res_man(ctx), cmd->body.shid, cmd->body.type]\n- 调用者: vmw_cmd_set_shader\n- 被调用者: N/A (假设是底层函数)\n\n4. 函数名: vmw_execbuf_res_noctx_val_add\n- 参数: [sw_context, res, VMW_RES_DIRTY_NONE]\n- 调用者: vmw_cmd_set_shader\n- 被调用者: N/A (假设是底层函数)\n\n5. 函数名: vmw_resource_relocation_add\n- 参数: [sw_context, res, vmw_ptr_diff(sw_context->buf_start, &cmd->body.shid), vmw_res_rel_normal]\n- 调用者: vmw_cmd_set_shader\n- 被调用者: [vmw_ptr_diff]\n\n6. 函数名: vmw_ptr_diff\n- 参数: [sw_context->buf_start, &cmd->body.shid]\n- 调用者: vmw_resource_relocation_add\n- 被调用者: N/A (假设是底层函数)\n\n7. 函数名: vmw_execbuf_info_from_res\n- 参数: [sw_context, ctx]\n- 调用者: vmw_cmd_set_shader\n- 被调用者: N/A (假设是底层函数)\n\n8. 函数名: vmw_binding_add\n- 参数: [ctx_info->staged, &binding.bi, binding.shader_slot, 0]\n- 调用者: vmw_cmd_set_shader\n- 被调用者: N/A (假设是底层函数)\n\n9. 函数名: container_of\n- 参数: [header, typeof(*cmd), header]\n- 调用者: vmw_cmd_set_shader\n- 被调用者: N/A (标准宏/函数)"
    },
    {
        "id": 3686,
        "cwe": "CWE-416",
        "cve": "CVE-2022-38457",
        "purpose": "Code purpose:\"\"\"该代码用于检查和管理虚拟机图形设备驱动中的资源引用和验证，确保资源访问的有效性和安全性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在函数vmw_cmd_res_check中，当资源查找失败时未正确清理缓存条目，导致后续可能引用已释放的内存，造成释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_cmd_res_check\n- 参数: [struct vmw_private *dev_priv, struct vmw_sw_context *sw_context, enum vmw_res_type res_type, u32 dirty, const struct vmw_user_resource_conv *converter, uint32_t *id_loc, struct vmw_resource **p_res]\n- 调用者: N/A\n- 被调用者: [vmw_validation_res_set_dirty, vmw_execbuf_res_size, vmw_validation_preload_res, vmw_user_resource_noref_lookup_handle, vmw_execbuf_res_noref_val_add, vmw_resource_relocation_add, vmw_ptr_diff]\n\n2. 函数名: vmw_validation_res_set_dirty\n- 参数: [sw_context->ctx, rcache->private, dirty]\n- 调用者: vmw_cmd_res_check\n- 被调用者: N/A\n\n3. 函数名: vmw_execbuf_res_size\n- 参数: [dev_priv, res_type]\n- 调用者: vmw_cmd_res_check\n- 被调用者: N/A\n\n4. 函数名: vmw_validation_preload_res\n- 参数: [sw_context->ctx, size]\n- 调用者: vmw_cmd_res_check\n- 被调用者: N/A\n\n5. 函数名: vmw_user_resource_noref_lookup_handle\n- 参数: [dev_priv, sw_context->fp->tfile, *id_loc, converter]\n- 调用者: vmw_cmd_res_check\n- 被调用者: N/A\n\n6. 函数名: vmw_execbuf_res_noref_val_add\n- 参数: [sw_context, res, dirty]\n- 调用者: vmw_cmd_res_check\n- 被调用者: N/A\n\n7. 函数名: vmw_resource_relocation_add\n- 参数: [sw_context, res, vmw_ptr_diff(sw_context->buf_start, id_loc), vmw_res_rel_normal]\n- 调用者: vmw_cmd_res_check\n- 被调用者: N/A\n\n8. 函数名: vmw_ptr_diff\n- 参数: [sw_context->buf_start, id_loc]\n- 调用者: vmw_cmd_res_check\n- 被调用者: N/A"
    },
    {
        "id": 3687,
        "cwe": "CWE-416",
        "cve": "CVE-2022-38457",
        "purpose": "Code purpose:\"\"\"该代码用于在vmwgfx驱动中管理上下文资源，包括添加cotables和绑定资源到验证列表，并处理DX上下文相关的查询内存对象。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放资源后仍可能被访问，导致释放后使用(UAF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_resource_context_res_add\n- 参数: [dev_priv, sw_context, ctx]\n- 调用者: N/A\n- 被调用者: [has_sm5_context, has_sm4_context, vmw_res_type, vmw_context_cotable, IS_ERR, vmw_execbuf_res_noctx_val_add, mutex_lock, vmw_context_binding_list, list_for_each_entry, vmw_view_res_val_add, vmw_binding_dirtying, vmw_context_get_dx_query_mob, vmw_validation_add_bo, mutex_unlock]\n\n2. 函数名: has_sm5_context\n- 参数: [ctx->dev_priv]\n- 调用者: vmw_resource_context_res_add\n- 被调用者: N/A\n\n3. 函数名: has_sm4_context\n- 参数: [dev_priv]\n- 调用者: vmw_resource_context_res_add\n- 被调用者: N/A\n\n4. 函数名: vmw_res_type\n- 参数: [ctx], [entry->res]\n- 调用者: vmw_resource_context_res_add\n- 被调用者: N/A\n\n5. 函数名: vmw_context_cotable\n- 参数: [ctx, i]\n- 调用者: vmw_resource_context_res_add\n- 被调用者: N/A\n\n6. 函数名: IS_ERR\n- 参数: [res]\n- 调用者: vmw_resource_context_res_add\n- 被调用者: N/A\n\n7. 函数名: vmw_execbuf_res_noctx_val_add\n- 参数: [sw_context, res, VMW_RES_DIRTY_SET], [sw_context, entry->res, vmw_binding_dirtying(entry->bt)]\n- 调用者: vmw_resource_context_res_add\n- 被调用者: N/A\n\n8. 函数名: mutex_lock\n- 参数: [&dev_priv->binding_mutex]\n- 调用者: vmw_resource_context_res_add\n- 被调用者: N/A\n\n9. 函数名: vmw_context_binding_list\n- 参数: [ctx]\n- 调用者: vmw_resource_context_res_add\n- 被调用者: N/A\n\n10. 函数名: list_for_each_entry\n- 参数: [entry, binding_list, ctx_list]\n- 调用者: vmw_resource_context_res_add\n- 被调用者: N/A\n\n11. 函数名: vmw_view_res_val_add\n- 参数: [sw_context, entry->res]\n- 调用者: vmw_resource_context_res_add\n- 被调用者: N/A\n\n12. 函数名: vmw_binding_dirtying\n- 参数: [entry->bt]\n- 调用者: vmw_resource_context_res_add\n- 被调用者: N/A\n\n13. 函数名: vmw_context_get_dx_query_mob\n- 参数: [ctx]\n- 调用者: vmw_resource_context_res_add\n- 被调用者: N/A\n\n14. 函数名: vmw_validation_add_bo\n- 参数: [sw_context->ctx, dx_query_mob, true, false]\n- 调用者: vmw_resource_context_res_add\n- 被调用者: N/A\n\n15. 函数名: mutex_unlock\n- 参数: [&dev_priv->binding_mutex]\n- 调用者: vmw_resource_context_res_add\n- 被调用者: N/A"
    },
    {
        "id": 3688,
        "cwe": "CWE-416",
        "cve": "CVE-2022-38457",
        "purpose": "Code purpose:\"\"\"该代码片段用于在vmwgfx驱动中验证并添加视图资源及其指向的资源到执行缓冲区上下文，确保资源在视图验证时不会被交换出去\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在函数vmw_view_res_val_add中，由于未正确处理资源引用计数，导致在视图验证过程中可能发生资源被释放后仍被访问的use-after-free问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_view_res_val_add\n- 参数: [struct vmw_sw_context *sw_context, struct vmw_resource *view]\n- 调用者: 未显示\n- 被调用者: [vmw_execbuf_res_noctx_val_add, vmw_view_srf, vmw_view_dirtying]\n\n2. 函数名: vmw_execbuf_res_noctx_val_add\n- 参数: [struct vmw_sw_context *sw_context, struct vmw_resource *res, enum vmw_res_dirty dirty]\n- 调用者: vmw_view_res_val_add\n- 被调用者: 未显示\n\n3. 函数名: vmw_view_srf\n- 参数: [struct vmw_resource *view]\n- 调用者: vmw_view_res_val_add\n- 被调用者: 未显示\n\n4. 函数名: vmw_view_dirtying\n- 参数: [struct vmw_resource *view]\n- 调用者: vmw_view_res_val_add\n- 被调用者: 未显示"
    },
    {
        "id": 3689,
        "cwe": "CWE-416",
        "cve": "CVE-2022-38457",
        "purpose": "Code purpose:\"\"\"将用户空间的MOB缓冲区ID转换为内核空间的缓冲区对象，并进行验证和重定位处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在函数vmw_translate_mob_ptr中，vmw_bo对象在通过ttm_bo_put释放后仍被保存在reloc结构体中并被后续使用，导致释放后重用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_translate_mob_ptr\n- 参数: [dev_priv, sw_context, id, vmw_bo_p]\n- 调用者: 未指定\n- 被调用者: [vmw_validation_preload_bo, vmw_user_bo_noref_lookup, vmw_validation_add_bo, ttm_bo_put, vmw_validation_mem_alloc, list_add_tail]\n\n2. 函数名: vmw_validation_preload_bo\n- 参数: [sw_context->ctx]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: 未指定\n\n3. 函数名: vmw_user_bo_noref_lookup\n- 参数: [sw_context->filp, handle]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: 未指定\n\n4. 函数名: vmw_validation_add_bo\n- 参数: [sw_context->ctx, vmw_bo, true, false]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: 未指定\n\n5. 函数名: ttm_bo_put\n- 参数: [&vmw_bo->base]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: 未指定\n\n6. 函数名: vmw_validation_mem_alloc\n- 参数: [sw_context->ctx, sizeof(*reloc)]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: 未指定\n\n7. 函数名: list_add_tail\n- 参数: [&reloc->head, &sw_context->bo_relocations]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: 未指定"
    },
    {
        "id": 3699,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3977",
        "purpose": "Code purpose:\"\"\"该代码实现了MCTP协议中分配和管理通信标签的功能，通过ioctl接口允许用户空间程序请求分配一个新的通信标签。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在同时执行DROPTAG ioctl和socket关闭操作时，由于未正确处理键对象的引用计数，导致释放后重用(use-after-free)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: mctp_ioctl_alloctag\n- 参数: [msk, arg]\n- 调用者: 未显示\n- 被调用者: [sock_net, copy_from_user, mctp_alloc_local_tag, IS_ERR, PTR_ERR, copy_to_user, spin_lock_irqsave, __mctp_key_remove, mctp_key_unref]\n\n2. 函数名: sock_net\n- 参数: [&msk->sk]\n- 调用者: mctp_ioctl_alloctag\n- 被调用者: 未显示\n\n3. 函数名: copy_from_user\n- 参数: [&ctl, (void __user *)arg, sizeof(ctl)]\n- 调用者: mctp_ioctl_alloctag\n- 被调用者: 未显示\n\n4. 函数名: mctp_alloc_local_tag\n- 参数: [msk, ctl.peer_addr, MCTP_ADDR_ANY, true, &tag]\n- 调用者: mctp_ioctl_alloctag\n- 被调用者: 未显示\n\n5. 函数名: IS_ERR\n- 参数: [key]\n- 调用者: mctp_ioctl_alloctag\n- 被调用者: 未显示\n\n6. 函数名: PTR_ERR\n- 参数: [key]\n- 调用者: mctp_ioctl_alloctag\n- 被调用者: 未显示\n\n7. 函数名: copy_to_user\n- 参数: [(void __user *)arg, &ctl, sizeof(ctl)]\n- 调用者: mctp_ioctl_alloctag\n- 被调用者: 未显示\n\n8. 函数名: spin_lock_irqsave\n- 参数: [&key->lock, flags]\n- 调用者: mctp_ioctl_alloctag\n- 被调用者: 未显示\n\n9. 函数名: __mctp_key_remove\n- 参数: [key, net, flags, MCTP_TRACE_KEY_DROPPED]\n- 调用者: mctp_ioctl_alloctag\n- 被调用者: 未显示\n\n10. 函数名: mctp_key_unref\n- 参数: [key]\n- 调用者: mctp_ioctl_alloctag\n- 被调用者: 未显示"
    },
    {
        "id": 3700,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3977",
        "purpose": "Code purpose:\"\"\"管理组件传输协议(MCTP)中释放密钥资源并清理相关数据结构\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在同时调用DROPTAG ioctl和socket关闭时，由于释放后使用(key对象在释放后仍可能被访问)，导致UAF漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: __mctp_key_remove\n- 参数: [key, net, flags, reason]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [trace_mctp_key_release, mctp_dev_release_key, spin_unlock_irqrestore, hlist_del, mctp_key_unref, kfree_skb]\n\n2. 函数名: trace_mctp_key_release\n- 参数: [key, reason]\n- 调用者: __mctp_key_remove\n- 被调用者: []\n\n3. 函数名: mctp_dev_release_key\n- 参数: [key->dev, key]\n- 调用者: __mctp_key_remove\n- 被调用者: []\n\n4. 函数名: spin_unlock_irqrestore\n- 参数: [&key->lock, flags]\n- 调用者: __mctp_key_remove\n- 被调用者: []\n\n5. 函数名: hlist_del\n- 参数: [&key->hlist]\n- 调用者: __mctp_key_remove\n- 被调用者: []\n\n6. 函数名: hlist_del\n- 参数: [&key->sklist]\n- 调用者: __mctp_key_remove\n- 被调用者: []\n\n7. 函数名: mctp_key_unref\n- 参数: [key]\n- 调用者: __mctp_key_remove\n- 被调用者: []\n\n8. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: __mctp_key_remove\n- 被调用者: []"
    },
    {
        "id": 3701,
        "cwe": "CWE-416",
        "cve": "CVE-2022-3977",
        "purpose": "Code purpose:\"\"\"管理MCTP协议中密钥的释放和资源清理，包括从链表中删除密钥引用、释放相关内存等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在同时调用DROPTAG ioctl和socket关闭时，由于释放后使用(key对象在释放后仍被访问)导致UAF漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: __mctp_key_done_in\n- 参数: [key, net, flags, reason]\n- 调用者: 未明确（由系统调用或内核其他部分调用）\n- 被调用者: [trace_mctp_key_release, spin_unlock_irqrestore, mctp_dev_release_key, spin_lock_irqsave, hlist_del, spin_unlock_irqrestore, mctp_key_unref, kfree_skb]\n\n2. 函数名: trace_mctp_key_release\n- 参数: [key, reason]\n- 调用者: __mctp_key_done_in\n- 被调用者: []\n\n3. 函数名: spin_unlock_irqrestore\n- 参数: [&key->lock, flags]\n- 调用者: __mctp_key_done_in\n- 被调用者: []\n\n4. 函数名: mctp_dev_release_key\n- 参数: [key->dev, key]\n- 调用者: __mctp_key_done_in\n- 被调用者: []\n\n5. 函数名: spin_lock_irqsave\n- 参数: [&net->mctp.keys_lock, flags]\n- 调用者: __mctp_key_done_in\n- 被调用者: []\n\n6. 函数名: hlist_del\n- 参数: [&key->hlist]\n- 调用者: __mctp_key_done_in\n- 被调用者: []\n\n7. 函数名: hlist_del\n- 参数: [&key->sklist]\n- 调用者: __mctp_key_done_in\n- 被调用者: []\n\n8. 函数名: spin_unlock_irqrestore\n- 参数: [&net->mctp.keys_lock, flags]\n- 调用者: __mctp_key_done_in\n- 被调用者: []\n\n9. 函数名: mctp_key_unref\n- 参数: [key]\n- 调用者: __mctp_key_done_in\n- 被调用者: []\n\n10. 函数名: mctp_key_unref\n- 参数: [key]\n- 调用者: __mctp_key_done_in\n- 被调用者: []\n\n11. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: __mctp_key_done_in\n- 被调用者: []"
    },
    {
        "id": 3706,
        "cwe": "CWE-416",
        "cve": "CVE-2022-4095",
        "purpose": "Code purpose:\"\"\"该代码用于处理不同类型的硬件操作命令，并根据命令类型调用相应的处理函数，同时管理命令对象的内存生命周期。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在cmd_hdl_filter函数中，某些case分支处理后会释放pcmd对象，但其他分支可能继续使用已释放的对象，导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: cmd_hdl_filter\n- 参数: [struct _adapter *padapter, struct cmd_obj *pcmd]\n- 调用者: 未显示\n- 被调用者: [read_macreg_hdl, write_macreg_hdl, read_bbreg_hdl, write_bbreg_hdl, read_rfreg_hdl, write_rfreg_hdl, sys_suspend_hdl, r8712_joinbss_reset, r8712_set_rpwm, r871x_internal_cmd_hdl, r8712_free_cmd_obj]\n\n2. 函数名: read_macreg_hdl\n- 参数: [struct _adapter *padapter, u8 *pcmd]\n- 调用者: cmd_hdl_filter\n- 被调用者: 未显示\n\n3. 函数名: write_macreg_hdl\n- 参数: [struct _adapter *padapter, u8 *pcmd]\n- 调用者: cmd_hdl_filter\n- 被调用者: 未显示\n\n4. 函数名: read_bbreg_hdl\n- 参数: [struct _adapter *padapter, u8 *pcmd]\n- 调用者: cmd_hdl_filter\n- 被调用者: 未显示\n\n5. 函数名: write_bbreg_hdl\n- 参数: [struct _adapter *padapter, u8 *pcmd]\n- 调用者: cmd_hdl_filter\n- 被调用者: 未显示\n\n6. 函数名: read_rfreg_hdl\n- 参数: [struct _adapter *padapter, u8 *pcmd]\n- 调用者: cmd_hdl_filter\n- 被调用者: 未显示\n\n7. 函数名: write_rfreg_hdl\n- 参数: [struct _adapter *padapter, u8 *pcmd]\n- 调用者: cmd_hdl_filter\n- 被调用者: 未显示\n\n8. 函数名: sys_suspend_hdl\n- 参数: [struct _adapter *padapter, u8 *pcmd]\n- 调用者: cmd_hdl_filter\n- 被调用者: 未显示\n\n9. 函数名: r8712_joinbss_reset\n- 参数: [struct _adapter *padapter]\n- 调用者: cmd_hdl_filter\n- 被调用者: 未显示\n\n10. 函数名: r8712_set_rpwm\n- 参数: [struct _adapter *padapter, PS_STATE_S4]\n- 调用者: cmd_hdl_filter\n- 被调用者: 未显示\n\n11. 函数名: r871x_internal_cmd_hdl\n- 参数: [struct _adapter *padapter, pcmd->parmbuf]\n- 调用者: cmd_hdl_filter\n- 被调用者: 未显示\n\n12. 函数名: r8712_free_cmd_obj\n- 参数: [struct cmd_obj *pcmd]\n- 调用者: cmd_hdl_filter\n- 被调用者: 未显示"
    },
    {
        "id": 3711,
        "cwe": "CWE-416",
        "cve": "CVE-2022-41218",
        "purpose": "Code purpose:\"\"\"释放数字视频广播(DVB)解复用设备资源并处理用户计数，确保在最后一个用户退出时安全卸载设备\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于引用计数竞争条件导致在dvb_dmxdev_release函数中存在释放后使用(UAF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: dvb_dmxdev_release\n- 参数: [struct dmxdev *dmxdev]\n- 调用者: 未指定（通常由内核其他模块调用）\n- 被调用者: [wait_event, dvb_unregister_device, vfree]\n\n2. 函数名: wait_event\n- 参数: [dmxdev->dvbdev->wait_queue, dmxdev->dvbdev->users == 1] 和 [dmxdev->dvr_dvbdev->wait_queue, dmxdev->dvr_dvbdev->users == 1]\n- 调用者: dvb_dmxdev_release\n- 被调用者: 未指定（内核等待队列相关函数）\n\n3. 函数名: dvb_unregister_device\n- 参数: [dmxdev->dvbdev] 和 [dmxdev->dvr_dvbdev]\n- 调用者: dvb_dmxdev_release\n- 被调用者: 未指定（内核设备注销相关函数）\n\n4. 函数名: vfree\n- 参数: [dmxdev->filter]\n- 调用者: dvb_dmxdev_release\n- 被调用者: 未指定（内核内存释放函数）\n\n5. 函数名: close\n- 参数: [dmxdev->demux]\n- 调用者: dvb_dmxdev_release\n- 被调用者: 未指定（通过函数指针调用，具体实现取决于dmxdev->demux->close指向的函数）"
    },
    {
        "id": 3712,
        "cwe": "CWE-416",
        "cve": "CVE-2022-41218",
        "purpose": "Code purpose:\"\"\"该代码实现了DVB设备解复用器的打开功能，包括过滤器分配、缓冲区初始化和状态设置等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于dvb_demux_open和dvb_dmxdev_release之间存在引用计数竞争条件，导致在释放资源后仍可能被访问，从而引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: dvb_demux_open\n- 参数: [struct inode *inode, struct file *file]\n- 调用者: 未明确显示（通常由文件系统操作调用）\n- 被调用者: [mutex_lock_interruptible, mutex_unlock, mutex_init, dvb_ringbuffer_init, dvb_vb2_init, dvb_dmxdev_filter_state_set, timer_setup]\n\n2. 函数名: mutex_lock_interruptible\n- 参数: [&dmxdev->mutex]\n- 调用者: dvb_demux_open\n- 被调用者: []\n\n3. 函数名: mutex_unlock\n- 参数: [&dmxdev->mutex]\n- 调用者: dvb_demux_open\n- 被调用者: []\n\n4. 函数名: mutex_init\n- 参数: [&dmxdevfilter->mutex]\n- 调用者: dvb_demux_open\n- 被调用者: []\n\n5. 函数名: dvb_ringbuffer_init\n- 参数: [&dmxdevfilter->buffer, NULL, 8192]\n- 调用者: dvb_demux_open\n- 被调用者: []\n\n6. 函数名: dvb_vb2_init\n- 参数: [&dmxdevfilter->vb2_ctx, \"demux_filter\", file->f_flags & O_NONBLOCK]\n- 调用者: dvb_demux_open\n- 被调用者: []\n\n7. 函数名: dvb_dmxdev_filter_state_set\n- 参数: [dmxdevfilter, DMXDEV_STATE_ALLOCATED]\n- 调用者: dvb_demux_open\n- 被调用者: []\n\n8. 函数名: timer_setup\n- 参数: [&dmxdevfilter->timer, dvb_dmxdev_filter_timeout, 0]\n- 调用者: dvb_demux_open\n- 被调用者: []"
    },
    {
        "id": 3713,
        "cwe": "CWE-416",
        "cve": "CVE-2022-41222",
        "purpose": "Code purpose:\"\"\"该代码用于在内存重新映射(mremap)操作中移动页表项，包括PUD和PMD级别的页表，以支持虚拟内存区域的扩展或移动。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在PUD移动操作期间未持有rmap锁，导致可能访问已释放的内存，造成use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: move_page_tables\n- 参数: [vma, old_addr, new_vma, new_addr, len, need_rmap_locks]\n- 调用者: N/A (top-level function)\n- 被调用者: [flush_cache_range, mmu_notifier_range_init, mmu_notifier_invalidate_range_start, cond_resched, get_extent, get_old_pud, alloc_new_pud, pud_trans_huge, pud_devmap, move_pgt_entry, get_old_pmd, alloc_new_pmd, is_swap_pmd, pmd_trans_huge, pmd_devmap, split_huge_pmd, pmd_trans_unstable, pte_alloc, move_ptes, mmu_notifier_invalidate_range_end]\n\n2. 函数名: flush_cache_range\n- 参数: [vma, old_addr, old_end]\n- 调用者: move_page_tables\n- 被调用者: []\n\n3. 函数名: mmu_notifier_range_init\n- 参数: [&range, MMU_NOTIFY_UNMAP, 0, vma, vma->vm_mm, old_addr, old_end]\n- 调用者: move_page_tables\n- 被调用者: []\n\n4. 函数名: mmu_notifier_invalidate_range_start\n- 参数: [&range]\n- 调用者: move_page_tables\n- 被调用者: []\n\n5. 函数名: cond_resched\n- 参数: []\n- 调用者: move_page_tables\n- 被调用者: []\n\n6. 函数名: get_extent\n- 参数: [NORMAL_PUD, old_addr, old_end, new_addr]\n- 调用者: move_page_tables\n- 被调用者: []\n\n7. 函数名: get_old_pud\n- 参数: [vma->vm_mm, old_addr]\n- 调用者: move_page_tables\n- 被调用者: []\n\n8. 函数名: alloc_new_pud\n- 参数: [vma->vm_mm, vma, new_addr]\n- 调用者: move_page_tables\n- 被调用者: []\n\n9. 函数名: pud_trans_huge\n- 参数: [*old_pud]\n- 调用者: move_page_tables\n- 被调用者: []\n\n10. 函数名: pud_devmap\n- 参数: [*old_pud]\n- 调用者: move_page_tables\n- 被调用者: []\n\n11. 函数名: move_pgt_entry\n- 参数: [HPAGE_PUD, vma, old_addr, new_addr, old_pud, new_pud, need_rmap_locks]\n- 调用者: move_page_tables\n- 被调用者: []\n\n12. 函数名: get_old_pmd\n- 参数: [vma->vm_mm, old_addr]\n- 调用者: move_page_tables\n- 被调用者: []\n\n13. 函数名: alloc_new_pmd\n- 参数: [vma->vm_mm, vma, new_addr]\n- 调用者: move_page_tables\n- 被调用者: []\n\n14. 函数名: is_swap_pmd\n- 参数: [*old_pmd]\n- 调用者: move_page_tables\n- 被调用者: []\n\n15. 函数名: pmd_trans_huge\n- 参数: [*old_pmd]\n- 调用者: move_page_tables\n- 被调用者: []\n\n16. 函数名: pmd_devmap\n- 参数: [*old_pmd]\n- 调用者: move_page_tables\n- 被调用者: []\n\n17. 函数名: split_huge_pmd\n- 参数: [vma, old_pmd, old_addr]\n- 调用者: move_page_tables\n- 被调用者: []\n\n18. 函数名: pmd_trans_unstable\n- 参数: [old_pmd]\n- 调用者: move_page_tables\n- 被调用者: []\n\n19. 函数名: pte_alloc\n- 参数: [new_vma->vm_mm, new_pmd]\n- 调用者: move_page_tables\n- 被调用者: []\n\n20. 函数名: move_ptes\n- 参数: [vma, old_pmd, old_addr, old_addr + extent, new_vma, new_pmd, new_addr, need_rmap_locks]\n- 调用者: move_page_tables\n- 被调用者: []\n\n21. 函数名: mmu_notifier_invalidate_range_end\n- 参数: [&range]\n- 调用者: move_page_tables\n- 被调用者: []"
    },
    {
        "id": 3720,
        "cwe": "CWE-416",
        "cve": "CVE-2022-41849",
        "purpose": "Code purpose:\"\"\"处理USB设备断开连接时的资源释放和状态清理工作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在USB设备断开连接时，由于缺乏适当的同步机制，导致在ufx_ops_open和ufx_usb_disconnect之间存在竞态条件，可能引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ufx_usb_disconnect\n- 参数: [struct usb_interface *interface]\n- 调用者: 未显示（由USB子系统调用）\n- 被调用者: [usb_get_intfdata, pr_debug, atomic_set, usb_set_intfdata, schedule_delayed_work, kref_put]\n\n2. 函数名: usb_get_intfdata\n- 参数: [struct usb_interface *interface]\n- 调用者: ufx_usb_disconnect\n- 被调用者: 未显示（内核API）\n\n3. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: ufx_usb_disconnect\n- 被调用者: 未显示（内核打印函数）\n\n4. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: ufx_usb_disconnect\n- 被调用者: 未显示（内核原子操作API）\n\n5. 函数名: usb_set_intfdata\n- 参数: [struct usb_interface *interface, void *data]\n- 调用者: ufx_usb_disconnect\n- 被调用者: 未显示（内核API）\n\n6. 函数名: schedule_delayed_work\n- 参数: [struct delayed_work *work, unsigned long delay]\n- 调用者: ufx_usb_disconnect\n- 被调用者: 未显示（内核工作队列API）\n\n7. 函数名: kref_put\n- 参数: [struct kref *kref, void (*release)(struct kref *kref)]\n- 调用者: ufx_usb_disconnect\n- 被调用者: [ufx_free]\n\n8. 函数名: ufx_free\n- 参数: [struct kref *kref]\n- 调用者: kref_put\n- 被调用者: 未显示（代码中未完全展示）"
    },
    {
        "id": 3721,
        "cwe": "CWE-416",
        "cve": "CVE-2022-41849",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中USB帧缓冲设备(ufx)的打开操作，包括设备状态检查、引用计数管理以及延迟I/O初始化等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ufx_ops_open函数中，当USB设备被物理移除时，dev指针可能变为悬垂指针，导致在后续操作中对已释放内存的访问，形成竞争条件下的释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ufx_ops_open\n- 参数: [struct fb_info *info, int user]\n- 调用者: 未明确显示（通常由framebuffer子系统调用）\n- 被调用者: [kref_get, kzalloc, fb_deferred_io_init, pr_debug]\n\n2. 函数名: kref_get\n- 参数: [&dev->kref]\n- 调用者: ufx_ops_open\n- 被调用者: []\n\n3. 函数名: kzalloc\n- 参数: [sizeof(*fbdefio), GFP_KERNEL]\n- 调用者: ufx_ops_open\n- 被调用者: []\n\n4. 函数名: fb_deferred_io_init\n- 参数: [info]\n- 调用者: ufx_ops_open\n- 被调用者: []\n\n5. 函数名: pr_debug\n- 参数: [\"open /dev/fb%d user=%d fb_info=%p count=%d\", info->node, user, info, dev->fb_count]\n- 调用者: ufx_ops_open\n- 被调用者: []\n\n6. 函数名: ufx_dpy_deferred_io\n- 参数: 未直接显示（通过fbdefio->deferred_io指针引用）\n- 调用者: 未直接调用（由fb_deferred_io系统后续调用）\n- 被调用者: []"
    },
    {
        "id": 3722,
        "cwe": "CWE-416",
        "cve": "CVE-2022-41850",
        "purpose": "Code purpose:\"\"\"该代码用于处理ROCCAT设备的报告事件，包括分配内存存储报告数据、管理循环缓冲区以及通知等待的读取进程。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在复制report->value的过程中接收到新报告时存在竞态条件，导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: roccat_report_event\n- 参数: [minor, data]\n- 调用者: 未指定（由外部调用）\n- 被调用者: [kmemdup, kfree, wake_up_interruptible]\n\n2. 函数名: kmemdup\n- 参数: [data, device->report_size, GFP_ATOMIC]\n- 调用者: roccat_report_event\n- 被调用者: 未指定（内核函数）\n\n3. 函数名: kfree\n- 参数: [report->value]\n- 调用者: roccat_report_event\n- 被调用者: 未指定（内核函数）\n\n4. 函数名: wake_up_interruptible\n- 参数: [&device->wait]\n- 调用者: roccat_report_event\n- 被调用者: 未指定（内核函数）"
    },
    {
        "id": 3727,
        "cwe": "CWE-416",
        "cve": "CVE-2022-42703",
        "purpose": "Code purpose:\"\"\"分配并初始化一个匿名虚拟内存区域(anon_vma)结构体，用于管理进程的匿名页映射关系\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"anon_vma结构体在释放后被重复使用，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: anon_vma_alloc\n- 参数: []\n- 调用者: 未明确显示（通常由内核内存管理相关函数调用）\n- 被调用者: [kmem_cache_alloc, atomic_set]"
    },
    {
        "id": 3728,
        "cwe": "CWE-416",
        "cve": "CVE-2022-42703",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理匿名虚拟内存区域(anon_vma)的复制和分配，实现父子进程间虚拟内存管理的继承和共享\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在匿名虚拟内存区域(anon_vma)的双重重用过程中，由于引用计数管理不当导致释放后重用(use-after-free)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: anon_vma_fork\n- 参数: [vma, pvma]\n- 调用者: N/A (top-level function)\n- 被调用者: [anon_vma_clone, anon_vma_alloc, anon_vma_chain_alloc, get_anon_vma, anon_vma_lock_write, anon_vma_chain_link, anon_vma_unlock_write, put_anon_vma, unlink_anon_vmas]\n\n2. 函数名: anon_vma_clone\n- 参数: [vma, pvma]\n- 调用者: anon_vma_fork\n- 被调用者: []\n\n3. 函数名: anon_vma_alloc\n- 参数: []\n- 调用者: anon_vma_fork\n- 被调用者: []\n\n4. 函数名: anon_vma_chain_alloc\n- 参数: [GFP_KERNEL]\n- 调用者: anon_vma_fork\n- 被调用者: []\n\n5. 函数名: get_anon_vma\n- 参数: [anon_vma->root]\n- 调用者: anon_vma_fork\n- 被调用者: []\n\n6. 函数名: anon_vma_lock_write\n- 参数: [anon_vma]\n- 调用者: anon_vma_fork\n- 被调用者: []\n\n7. 函数名: anon_vma_chain_link\n- 参数: [vma, avc, anon_vma]\n- 调用者: anon_vma_fork\n- 被调用者: []\n\n8. 函数名: anon_vma_unlock_write\n- 参数: [anon_vma]\n- 调用者: anon_vma_fork\n- 被调用者: []\n\n9. 函数名: put_anon_vma\n- 参数: [anon_vma]\n- 调用者: anon_vma_fork\n- 被调用者: []\n\n10. 函数名: unlink_anon_vmas\n- 参数: [vma]\n- 调用者: anon_vma_fork\n- 被调用者: []"
    },
    {
        "id": 3729,
        "cwe": "CWE-416",
        "cve": "CVE-2022-42703",
        "purpose": "Code purpose:\"\"\"该代码用于准备匿名虚拟内存区域(anon_vma)结构，处理内存映射的合并与链接操作，并管理相关资源的分配与释放。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在匿名虚拟内存区域(anon_vma)的双重重用场景中，由于缺乏适当的引用计数管理，导致释放后重用(use-after-free)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: __anon_vma_prepare\n- 参数: [struct vm_area_struct *vma]\n- 调用者: N/A\n- 被调用者: [might_sleep, anon_vma_chain_alloc, find_mergeable_anon_vma, anon_vma_alloc, anon_vma_lock_write, spin_lock, anon_vma_chain_link, spin_unlock, anon_vma_unlock_write, put_anon_vma, anon_vma_chain_free]\n\n2. 函数名: might_sleep\n- 参数: []\n- 调用者: __anon_vma_prepare\n- 被调用者: []\n\n3. 函数名: anon_vma_chain_alloc\n- 参数: [GFP_KERNEL]\n- 调用者: __anon_vma_prepare\n- 被调用者: []\n\n4. 函数名: find_mergeable_anon_vma\n- 参数: [struct vm_area_struct *vma]\n- 调用者: __anon_vma_prepare\n- 被调用者: []\n\n5. 函数名: anon_vma_alloc\n- 参数: []\n- 调用者: __anon_vma_prepare\n- 被调用者: []\n\n6. 函数名: anon_vma_lock_write\n- 参数: [struct anon_vma *anon_vma]\n- 调用者: __anon_vma_prepare\n- 被调用者: []\n\n7. 函数名: spin_lock\n- 参数: [&mm->page_table_lock]\n- 调用者: __anon_vma_prepare\n- 被调用者: []\n\n8. 函数名: anon_vma_chain_link\n- 参数: [struct vm_area_struct *vma, struct anon_vma_chain *avc, struct anon_vma *anon_vma]\n- 调用者: __anon_vma_prepare\n- 被调用者: []\n\n9. 函数名: spin_unlock\n- 参数: [&mm->page_table_lock]\n- 调用者: __anon_vma_prepare\n- 被调用者: []\n\n10. 函数名: anon_vma_unlock_write\n- 参数: [struct anon_vma *anon_vma]\n- 调用者: __anon_vma_prepare\n- 被调用者: []\n\n11. 函数名: put_anon_vma\n- 参数: [struct anon_vma *allocated]\n- 调用者: __anon_vma_prepare\n- 被调用者: []\n\n12. 函数名: anon_vma_chain_free\n- 参数: [struct anon_vma_chain *avc]\n- 调用者: __anon_vma_prepare\n- 被调用者: []"
    },
    {
        "id": 3730,
        "cwe": "CWE-416",
        "cve": "CVE-2022-42703",
        "purpose": "Code purpose:\"\"\"该代码用于解除虚拟内存区域(VMA)与匿名虚拟内存区域(anon_vma)之间的关联，并释放不再使用的匿名虚拟内存区域资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放匿名虚拟内存区域(anon_vma)时，由于双重重用导致释放后使用(use-after-free)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: unlink_anon_vmas\n- 参数: [struct vm_area_struct *vma]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [lock_anon_vma_root, anon_vma_interval_tree_remove, anon_vma_chain_free, unlock_anon_vma_root, put_anon_vma]\n\n2. 函数名: lock_anon_vma_root\n- 参数: [struct anon_vma *root, struct anon_vma *anon_vma]\n- 调用者: unlink_anon_vmas\n- 被调用者: 未明确（可能涉及内核同步原语）\n\n3. 函数名: anon_vma_interval_tree_remove\n- 参数: [struct anon_vma_chain *avc, &anon_vma->rb_root]\n- 调用者: unlink_anon_vmas\n- 被调用者: 未明确（内核红黑树操作）\n\n4. 函数名: anon_vma_chain_free\n- 参数: [struct anon_vma_chain *avc]\n- 调用者: unlink_anon_vmas\n- 被调用者: 未明确（内存释放函数）\n\n5. 函数名: unlock_anon_vma_root\n- 参数: [struct anon_vma *root]\n- 调用者: unlink_anon_vmas\n- 被调用者: 未明确（可能涉及内核同步原语）\n\n6. 函数名: put_anon_vma\n- 参数: [struct anon_vma *anon_vma]\n- 调用者: unlink_anon_vmas\n- 被调用者: 未明确（引用计数操作）"
    },
    {
        "id": 3731,
        "cwe": "CWE-416",
        "cve": "CVE-2022-42703",
        "purpose": "Code purpose:\"\"\"该代码用于克隆源虚拟内存区域的匿名虚拟内存区域(anon_vma)结构到目标区域，处理内存分配失败情况并维护引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在匿名虚拟内存区域(anon_vma)的重用过程中，由于未能正确处理引用计数和锁机制，导致存在双重释放和后续使用后释放的问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: anon_vma_clone\n- 参数: [struct vm_area_struct *dst, struct vm_area_struct *src]\n- 调用者: (未在代码片段中显示)\n- 被调用者: [anon_vma_chain_alloc, unlock_anon_vma_root, lock_anon_vma_root, anon_vma_chain_link, unlink_anon_vmas]\n\n2. 函数名: anon_vma_chain_alloc\n- 参数: [GFP_NOWAIT | __GFP_NOWARN 或 GFP_KERNEL]\n- 调用者: anon_vma_clone\n- 被调用者: (未在代码片段中显示)\n\n3. 函数名: unlock_anon_vma_root\n- 参数: [struct anon_vma *root]\n- 调用者: anon_vma_clone\n- 被调用者: (未在代码片段中显示)\n\n4. 函数名: lock_anon_vma_root\n- 参数: [struct anon_vma *root, struct anon_vma *anon_vma]\n- 调用者: anon_vma_clone\n- 被调用者: (未在代码片段中显示)\n\n5. 函数名: anon_vma_chain_link\n- 参数: [struct vm_area_struct *dst, struct anon_vma_chain *avc, struct anon_vma *anon_vma]\n- 调用者: anon_vma_clone\n- 被调用者: (未在代码片段中显示)\n\n6. 函数名: unlink_anon_vmas\n- 参数: [struct vm_area_struct *dst]\n- 调用者: anon_vma_clone\n- 被调用者: (未在代码片段中显示)"
    },
    {
        "id": 3732,
        "cwe": "CWE-416",
        "cve": "CVE-2022-42719",
        "purpose": "Code purpose:\"\"\"解析802.11无线网络帧中的多BSSID元素，构建对应的数据结构\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在解析多BSSID元素时，由于未正确处理非传输配置文件的释放时机，导致在后续操作中可能访问已释放的内存区域，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ieee802_11_parse_elems_full\n- 参数: [struct ieee80211_elems_parse_params *params]\n- 调用者: 未显示\n- 被调用者: [kzalloc, kmalloc, ieee802_11_find_bssid_profile, cfg80211_find_ext_elem, _ieee802_11_parse_elems_full, kfree]\n\n2. 函数名: ieee802_11_find_bssid_profile\n- 参数: [params->start, params->len, elems, params->bss, nontransmitted_profile]\n- 调用者: ieee802_11_parse_elems_full\n- 被调用者: 未显示\n\n3. 函数名: cfg80211_find_ext_elem\n- 参数: [WLAN_EID_EXT_NON_INHERITANCE, nontransmitted_profile, nontransmitted_profile_len]\n- 调用者: ieee802_11_parse_elems_full\n- 被调用者: 未显示\n\n4. 函数名: _ieee802_11_parse_elems_full\n- 参数: [params, elems, non_inherit] 和 [&sub, elems, NULL]\n- 调用者: ieee802_11_parse_elems_full\n- 被调用者: 未显示\n\n5. 函数名: kzalloc\n- 参数: [sizeof(*elems), GFP_ATOMIC]\n- 调用者: ieee802_11_parse_elems_full\n- 被调用者: 未显示\n\n6. 函数名: kmalloc\n- 参数: [params->len, GFP_ATOMIC]\n- 调用者: ieee802_11_parse_elems_full\n- 被调用者: 未显示\n\n7. 函数名: kfree\n- 参数: [nontransmitted_profile]\n- 调用者: ieee802_11_parse_elems_full\n- 被调用者: 未显示"
    },
    {
        "id": 3733,
        "cwe": "CWE-416",
        "cve": "CVE-2022-42720",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的mac80211栈中更新和管理无线网络BSS(基本服务集)信息，包括查找、创建和更新BSS条目，并处理相关的引用计数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在多BSS处理中存在引用计数错误，导致本地攻击者能够通过注入WLAN帧触发释放后使用条件\"\"\"",
        "functions": "Functions:\n1. 函数名: cfg80211_bss_update\n- 参数: [rdev, tmp, signal_valid, ts]\n- 调用者: 未显示\n- 被调用者: [WARN_ON, rb_find_bss, cfg80211_update_known_bss, kzalloc, kfree_rcu, memcpy, INIT_LIST_HEAD, rcu_access_pointer, rb_find_bss, list_add, rcu_assign_pointer, cfg80211_combine_bsses, bss_ref_put, cfg80211_bss_expire_oldest, container_of, bss_ref_get, list_add_tail, rb_insert_bss]\n\n2. 函数名: rb_find_bss\n- 参数: [rdev, tmp, BSS_CMP_REGULAR/BSS_CMP_HIDE_ZLEN/BSS_CMP_HIDE_NUL]\n- 调用者: cfg80211_bss_update\n- 被调用者: 未显示\n\n3. 函数名: cfg80211_update_known_bss\n- 参数: [rdev, found, tmp, signal_valid]\n- 调用者: cfg80211_bss_update\n- 被调用者: 未显示\n\n4. 函数名: kzalloc\n- 参数: [sizeof(*new) + rdev->wiphy.bss_priv_size, GFP_ATOMIC]\n- 调用者: cfg80211_bss_update\n- 被调用者: 未显示\n\n5. 函数名: kfree_rcu\n- 参数: [ies, rcu_head]\n- 调用者: cfg80211_bss_update\n- 被调用者: 未显示\n\n6. 函数名: memcpy\n- 参数: [new, tmp, sizeof(*new)]\n- 调用者: cfg80211_bss_update\n- 被调用者: 未显示\n\n7. 函数名: INIT_LIST_HEAD\n- 参数: [&new->hidden_list, &new->pub.nontrans_list]\n- 调用者: cfg80211_bss_update\n- 被调用者: 未显示\n\n8. 函数名: rcu_access_pointer\n- 参数: [tmp->pub.ies, tmp->pub.proberesp_ies]\n- 调用者: cfg80211_bss_update\n- 被调用者: 未显示\n\n9. 函数名: list_add\n- 参数: [&new->hidden_list, &hidden->hidden_list]\n- 调用者: cfg80211_bss_update\n- 被调用者: 未显示\n\n10. 函数名: rcu_assign_pointer\n- 参数: [new->pub.beacon_ies, hidden->pub.beacon_ies]\n- 调用者: cfg80211_bss_update\n- 被调用者: 未显示\n\n11. 函数名: cfg80211_combine_bsses\n- 参数: [rdev, new]\n- 调用者: cfg80211_bss_update\n- 被调用者: 未显示\n\n12. 函数名: bss_ref_put\n- 参数: [rdev, new]\n- 调用者: cfg80211_bss_update\n- 被调用者: 未显示\n\n13. 函数名: cfg80211_bss_expire_oldest\n- 参数: [rdev]\n- 调用者: cfg80211_bss_update\n- 被调用者: 未显示\n\n14. 函数名: container_of\n- 参数: [tmp->pub.transmitted_bss, struct cfg80211_internal_bss, pub]\n- 调用者: cfg80211_bss_update\n- 被调用者: 未显示\n\n15. 函数名: bss_ref_get\n- 参数: [rdev, pbss]\n- 调用者: cfg80211_bss_update\n- 被调用者: 未显示\n\n16. 函数名: list_add_tail\n- 参数: [&new->list, &rdev->bss_list]\n- 调用者: cfg80211_bss_update\n- 被调用者: 未显示\n\n17. 函数名: rb_insert_bss\n- 参数: [rdev, new]\n- 调用者: cfg80211_bss_update\n- 被调用者: 未显示"
    },
    {
        "id": 3734,
        "cwe": "CWE-416",
        "cve": "CVE-2022-42720",
        "purpose": "Code purpose:\"\"\"该代码用于处理无线网络中的单个BSS（基本服务集）信息，包括解析和存储BSS的相关数据，更新BSS列表，并处理非传输BSS与传输BSS之间的关系。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在多BSS处理中存在引用计数错误，导致本地攻击者能够通过注入WLAN帧触发释放后使用条件\"\"\"",
        "functions": "Functions:\n1. 函数名: cfg80211_inform_single_bss_data\n- 参数: [wiphy, data, ftype, bssid, tsf, capability, beacon_interval, ie, ielen, non_tx_data, gfp]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [wiphy_to_rdev, cfg80211_get_bss_channel, memcpy, ether_addr_copy, bss_from_pub, kzalloc, rcu_assign_pointer, cfg80211_bss_update, regulatory_hint_found_beacon, cfg80211_add_nontrans_list, __cfg80211_unlink_bss, trace_cfg80211_return_bss]\n\n2. 函数名: wiphy_to_rdev\n- 参数: [wiphy]\n- 调用者: cfg80211_inform_single_bss_data\n- 被调用者: []\n\n3. 函数名: cfg80211_get_bss_channel\n- 参数: [wiphy, ie, ielen, chan, scan_width, ftype]\n- 调用者: cfg80211_inform_single_bss_data\n- 被调用者: []\n\n4. 函数名: memcpy\n- 参数: [dest, src, n]\n- 调用者: cfg80211_inform_single_bss_data\n- 被调用者: []\n\n5. 函数名: ether_addr_copy\n- 参数: [dest, src]\n- 调用者: cfg80211_inform_single_bss_data\n- 被调用者: []\n\n6. 函数名: bss_from_pub\n- 参数: [pub]\n- 调用者: cfg80211_inform_single_bss_data\n- 被调用者: []\n\n7. 函数名: kzalloc\n- 参数: [size, flags]\n- 调用者: cfg80211_inform_single_bss_data\n- 被调用者: []\n\n8. 函数名: rcu_assign_pointer\n- 参数: [p, v]\n- 调用者: cfg80211_inform_single_bss_data\n- 被调用者: []\n\n9. 函数名: cfg80211_bss_update\n- 参数: [rdev, tmp, signal_valid, ts]\n- 调用者: cfg80211_inform_single_bss_data\n- 被调用者: []\n\n10. 函数名: regulatory_hint_found_beacon\n- 参数: [wiphy, channel, gfp]\n- 调用者: cfg80211_inform_single_bss_data\n- 被调用者: []\n\n11. 函数名: cfg80211_add_nontrans_list\n- 参数: [tx_bss, res_pub]\n- 调用者: cfg80211_inform_single_bss_data\n- 被调用者: []\n\n12. 函数名: __cfg80211_unlink_bss\n- 参数: [rdev, res]\n- 调用者: cfg80211_inform_single_bss_data\n- 被调用者: []\n\n13. 函数名: trace_cfg80211_return_bss\n- 参数: [pub]\n- 调用者: cfg80211_inform_single_bss_data\n- 被调用者: []"
    },
    {
        "id": 3735,
        "cwe": "CWE-416",
        "cve": "CVE-2022-42720",
        "purpose": "Code purpose:\"\"\"增加无线网络BSS(基本服务集)的引用计数，包括隐藏信标BSS和传输BSS的引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在mac80211栈的多BSS处理中存在引用计数错误，当处理隐藏信标BSS和传输BSS时可能导致引用计数不正确，从而引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: bss_ref_get\n- 参数: [struct cfg80211_registered_device *rdev, struct cfg80211_internal_bss *bss]\n- 调用者: 未明确显示（上下文缺失）\n- 被调用者: [lockdep_assert_held, container_of]\n\n2. 函数名: lockdep_assert_held\n- 参数: [&rdev->bss_lock]\n- 调用者: bss_ref_get\n- 被调用者: []\n\n3. 函数名: container_of\n- 参数: [bss->pub.hidden_beacon_bss, struct cfg80211_internal_bss, pub]\n- 调用者: bss_ref_get\n- 被调用者: []\n\n4. 函数名: container_of\n- 参数: [bss->pub.transmitted_bss, struct cfg80211_internal_bss, pub]\n- 调用者: bss_ref_get\n- 被调用者: []"
    },
    {
        "id": 3739,
        "cwe": "CWE-416",
        "cve": "CVE-2022-42896",
        "purpose": "Code purpose:\"\"\"处理蓝牙L2CAP层的低能耗连接请求，包括验证参数、创建通道和管理连接响应\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放pchan后仍可能通过chan引用已释放的内存，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_le_connect_req\n- 参数: [conn, cmd, cmd_len, data]\n- 调用者: 未明确（由L2CAP协议栈调用）\n- 被调用者: [__le16_to_cpu, l2cap_global_chan_by_psm, smp_sufficient_security, __l2cap_get_chan_by_dcid, bacpy, bdaddr_src_type, bdaddr_dst_type, __l2cap_chan_add, l2cap_le_flowctl_init, __set_chan_timer, l2cap_state_change, l2cap_chan_ready, l2cap_chan_unlock, mutex_unlock, l2cap_chan_put, cpu_to_le16, l2cap_send_cmd]\n\n2. 函数名: __le16_to_cpu\n- 参数: [req->scid, req->mtu, req->mps, psm, req->credits]\n- 调用者: l2cap_le_connect_req\n- 被调用者: []\n\n3. 函数名: l2cap_global_chan_by_psm\n- 参数: [BT_LISTEN, psm, &conn->hcon->src, &conn->hcon->dst, LE_LINK]\n- 调用者: l2cap_le_connect_req\n- 被调用者: []\n\n4. 函数名: smp_sufficient_security\n- 参数: [conn->hcon, pchan->sec_level, SMP_ALLOW_STK]\n- 调用者: l2cap_le_connect_req\n- 被调用者: []\n\n5. 函数名: __l2cap_get_chan_by_dcid\n- 参数: [conn, scid]\n- 调用者: l2cap_le_connect_req\n- 被调用者: []\n\n6. 函数名: bacpy\n- 参数: [&chan->src, &conn->hcon->src], [&chan->dst, &conn->hcon->dst]\n- 调用者: l2cap_le_connect_req\n- 被调用者: []\n\n7. 函数名: bdaddr_src_type\n- 参数: [conn->hcon]\n- 调用者: l2cap_le_connect_req\n- 被调用者: []\n\n8. 函数名: bdaddr_dst_type\n- 参数: [conn->hcon]\n- 调用者: l2cap_le_connect_req\n- 被调用者: []\n\n9. 函数名: __l2cap_chan_add\n- 参数: [conn, chan]\n- 调用者: l2cap_le_connect_req\n- 被调用者: []\n\n10. 函数名: l2cap_le_flowctl_init\n- 参数: [chan, __le16_to_cpu(req->credits)]\n- 调用者: l2cap_le_connect_req\n- 被调用者: []\n\n11. 函数名: __set_chan_timer\n- 参数: [chan, chan->ops->get_sndtimeo(chan)]\n- 调用者: l2cap_le_connect_req\n- 被调用者: []\n\n12. 函数名: l2cap_state_change\n- 参数: [chan, BT_CONNECT2]\n- 调用者: l2cap_le_connect_req\n- 被调用者: []\n\n13. 函数名: l2cap_chan_ready\n- 参数: [chan]\n- 调用者: l2cap_le_connect_req\n- 被调用者: []\n\n14. 函数名: l2cap_chan_unlock\n- 参数: [pchan]\n- 调用者: l2cap_le_connect_req\n- 被调用者: []\n\n15. 函数名: mutex_unlock\n- 参数: [&conn->chan_lock]\n- 调用者: l2cap_le_connect_req\n- 被调用者: []\n\n16. 函数名: l2cap_chan_put\n- 参数: [pchan]\n- 调用者: l2cap_le_connect_req\n- 被调用者: []\n\n17. 函数名: cpu_to_le16\n- 参数: [chan->imtu], [chan->mps], [dcid], [credits], [result]\n- 调用者: l2cap_le_connect_req\n- 被调用者: []\n\n18. 函数名: l2cap_send_cmd\n- 参数: [conn, cmd->ident, L2CAP_LE_CONN_RSP, sizeof(rsp), &rsp]\n- 调用者: l2cap_le_connect_req\n- 被调用者: []"
    },
    {
        "id": 3740,
        "cwe": "CWE-416",
        "cve": "CVE-2022-42896",
        "purpose": "Code purpose:\"\"\"处理蓝牙L2CAP协议中的增强型信用基础连接请求，包括参数验证、通道创建和安全检查等功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在l2cap_ecred_conn_req函数中，由于对通道(pchan)的引用计数管理不当，可能导致在释放后仍被使用(use-after-free)。\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_ecred_conn_req\n- 参数: [conn, cmd, cmd_len, data]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [l2cap_global_chan_by_psm, smp_sufficient_security, __l2cap_get_chan_by_dcid, pchan->ops->new_connection, bacpy, bdaddr_src_type, bdaddr_dst_type, __l2cap_chan_add, l2cap_ecred_init, cpu_to_le16, __set_chan_timer, chan->ops->get_sndtimeo, test_bit, l2cap_state_change, chan->ops->defer, l2cap_chan_ready, l2cap_chan_unlock, mutex_unlock, l2cap_chan_put, l2cap_send_cmd]\n\n2. 函数名: l2cap_global_chan_by_psm\n- 参数: [BT_LISTEN, psm, &conn->hcon->src, &conn->hcon->dst, LE_LINK]\n- 调用者: l2cap_ecred_conn_req\n- 被调用者: []\n\n3. 函数名: smp_sufficient_security\n- 参数: [conn->hcon, pchan->sec_level, SMP_ALLOW_STK]\n- 调用者: l2cap_ecred_conn_req\n- 被调用者: []\n\n4. 函数名: __l2cap_get_chan_by_dcid\n- 参数: [conn, scid]\n- 调用者: l2cap_ecred_conn_req\n- 被调用者: []\n\n5. 函数名: new_connection\n- 参数: [pchan]\n- 调用者: l2cap_ecred_conn_req\n- 被调用者: []\n\n6. 函数名: bacpy\n- 参数: [&chan->src, &conn->hcon->src], [&chan->dst, &conn->hcon->dst]\n- 调用者: l2cap_ecred_conn_req\n- 被调用者: []\n\n7. 函数名: bdaddr_src_type\n- 参数: [conn->hcon]\n- 调用者: l2cap_ecred_conn_req\n- 被调用者: []\n\n8. 函数名: bdaddr_dst_type\n- 参数: [conn->hcon]\n- 调用者: l2cap_ecred_conn_req\n- 被调用者: []\n\n9. 函数名: __l2cap_chan_add\n- 参数: [conn, chan]\n- 调用者: l2cap_ecred_conn_req\n- 被调用者: []\n\n10. 函数名: l2cap_ecred_init\n- 参数: [chan, __le16_to_cpu(req->credits)]\n- 调用者: l2cap_ecred_conn_req\n- 被调用者: []\n\n11. 函数名: cpu_to_le16\n- 参数: [chan->imtu], [chan->mps], [chan->rx_credits], [chan->scid], [result]\n- 调用者: l2cap_ecred_conn_req\n- 被调用者: []\n\n12. 函数名: __set_chan_timer\n- 参数: [chan, chan->ops->get_sndtimeo(chan)]\n- 调用者: l2cap_ecred_conn_req\n- 被调用者: []\n\n13. 函数名: get_sndtimeo\n- 参数: [chan]\n- 调用者: l2cap_ecred_conn_req\n- 被调用者: []\n\n14. 函数名: test_bit\n- 参数: [FLAG_DEFER_SETUP, &chan->flags]\n- 调用者: l2cap_ecred_conn_req\n- 被调用者: []\n\n15. 函数名: l2cap_state_change\n- 参数: [chan, BT_CONNECT2]\n- 调用者: l2cap_ecred_conn_req\n- 被调用者: []\n\n16. 函数名: defer\n- 参数: [chan]\n- 调用者: l2cap_ecred_conn_req\n- 被调用者: []\n\n17. 函数名: l2cap_chan_ready\n- 参数: [chan]\n- 调用者: l2cap_ecred_conn_req\n- 被调用者: []\n\n18. 函数名: l2cap_chan_unlock\n- 参数: [pchan]\n- 调用者: l2cap_ecred_conn_req\n- 被调用者: []\n\n19. 函数名: mutex_unlock\n- 参数: [&conn->chan_lock]\n- 调用者: l2cap_ecred_conn_req\n- 被调用者: []\n\n20. 函数名: l2cap_chan_put\n- 参数: [pchan]\n- 调用者: l2cap_ecred_conn_req\n- 被调用者: []\n\n21. 函数名: l2cap_send_cmd\n- 参数: [conn, cmd->ident, L2CAP_ECRED_CONN_RSP, sizeof(pdu.rsp) + len, &pdu]\n- 调用者: l2cap_ecred_conn_req\n- 被调用者: []"
    },
    {
        "id": 3745,
        "cwe": "CWE-416",
        "cve": "CVE-2022-4379",
        "purpose": "Code purpose:\"\"\"该代码实现了NFS服务器中异步文件拷贝功能，处理跨服务器和同服务器两种拷贝场景，并在完成后进行回调通知和资源清理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在__nfs42_ssc_open()函数中存在释放后重用问题，当处理异步拷贝操作时可能导致对已释放内存的访问\"\"\"",
        "functions": "Functions:\n1. 函数名: nfsd4_do_async_copy\n- 参数: [data]\n- 调用者: 无\n- 被调用者: [nfsd4_ssc_is_inter, nfs42_ssc_open, IS_ERR, PTR_ERR, nfsd4_interssc_disconnect, nfsd4_do_copy, nfsd4_cleanup_inter_ssc, nfsd4_cleanup_intra_ssc, nfsd4_send_cb_offload, cleanup_async_copy]\n\n2. 函数名: nfsd4_ssc_is_inter\n- 参数: [copy]\n- 调用者: nfsd4_do_async_copy\n- 被调用者: 无\n\n3. 函数名: nfs42_ssc_open\n- 参数: [copy->ss_mnt, &copy->c_fh, &copy->stateid]\n- 调用者: nfsd4_do_async_copy\n- 被调用者: 无\n\n4. 函数名: IS_ERR\n- 参数: [filp]\n- 调用者: nfsd4_do_async_copy\n- 被调用者: 无\n\n5. 函数名: PTR_ERR\n- 参数: [filp]\n- 调用者: nfsd4_do_async_copy\n- 被调用者: 无\n\n6. 函数名: nfsd4_interssc_disconnect\n- 参数: [copy->ss_mnt]\n- 调用者: nfsd4_do_async_copy\n- 被调用者: 无\n\n7. 函数名: nfsd4_do_copy\n- 参数: [copy, filp, copy->nf_dst->nf_file, false] 或 [copy, copy->nf_src->nf_file, copy->nf_dst->nf_file, false]\n- 调用者: nfsd4_do_async_copy\n- 被调用者: 无\n\n8. 函数名: nfsd4_cleanup_inter_ssc\n- 参数: [copy->ss_mnt, filp, copy->nf_dst]\n- 调用者: nfsd4_do_async_copy\n- 被调用者: 无\n\n9. 函数名: nfsd4_cleanup_intra_ssc\n- 参数: [copy->nf_src, copy->nf_dst]\n- 调用者: nfsd4_do_async_copy\n- 被调用者: 无\n\n10. 函数名: nfsd4_send_cb_offload\n- 参数: [copy, nfserr]\n- 调用者: nfsd4_do_async_copy\n- 被调用者: 无\n\n11. 函数名: cleanup_async_copy\n- 参数: [copy]\n- 调用者: nfsd4_do_async_copy\n- 被调用者: 无"
    },
    {
        "id": 3746,
        "cwe": "CWE-416",
        "cve": "CVE-2022-4379",
        "purpose": "Code purpose:\"\"\"该代码实现了NFS服务器中的文件复制功能，支持同步和异步两种复制方式，并处理了服务器间和服务器内的复制操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在异步拷贝操作中，由于内存释放后仍可能被访问，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nfsd4_copy\n- 参数: [rqstp, cstate, u]\n- 调用者: 未显示\n- 被调用者: [nfsd4_ssc_is_inter, nfsd4_copy_is_sync, nfsd4_setup_inter_ssc, nfsd4_setup_intra_ssc, nfsd4_copy_is_async, net_generic, kzalloc, kmalloc, nfs4_init_copy_state, refcount_set, memcpy, dup_copy_fields, kthread_create, IS_ERR, spin_lock, list_add, spin_unlock, wake_up_process, nfsd4_do_copy, nfsd4_cleanup_intra_ssc, cleanup_async_copy, nfsd4_interssc_disconnect]\n\n2. 函数名: nfsd4_ssc_is_inter\n- 参数: [copy]\n- 调用者: nfsd4_copy\n- 被调用者: 未显示\n\n3. 函数名: nfsd4_copy_is_sync\n- 参数: [copy]\n- 调用者: nfsd4_copy\n- 被调用者: 未显示\n\n4. 函数名: nfsd4_setup_inter_ssc\n- 参数: [rqstp, cstate, copy, &copy->ss_mnt]\n- 调用者: nfsd4_copy\n- 被调用者: 未显示\n\n5. 函数名: nfsd4_setup_intra_ssc\n- 参数: [rqstp, cstate, copy]\n- 调用者: nfsd4_copy\n- 被调用者: 未显示\n\n6. 函数名: nfsd4_copy_is_async\n- 参数: [copy]\n- 调用者: nfsd4_copy\n- 被调用者: 未显示\n\n7. 函数名: net_generic\n- 参数: [SVC_NET(rqstp), nfsd_net_id]\n- 调用者: nfsd4_copy\n- 被调用者: 未显示\n\n8. 函数名: kzalloc\n- 参数: [sizeof(struct nfsd4_copy), GFP_KERNEL]\n- 调用者: nfsd4_copy\n- 被调用者: 未显示\n\n9. 函数名: kmalloc\n- 参数: [sizeof(*async_copy->cp_src), GFP_KERNEL]\n- 调用者: nfsd4_copy\n- 被调用者: 未显示\n\n10. 函数名: nfs4_init_copy_state\n- 参数: [nn, copy]\n- 调用者: nfsd4_copy\n- 被调用者: 未显示\n\n11. 函数名: refcount_set\n- 参数: [&async_copy->refcount, 1]\n- 调用者: nfsd4_copy\n- 被调用者: 未显示\n\n12. 函数名: memcpy\n- 参数: [&copy->fh, &cstate->current_fh.fh_handle, sizeof(struct knfsd_fh)]\n- 调用者: nfsd4_copy\n- 被调用者: 未显示\n\n13. 函数名: dup_copy_fields\n- 参数: [copy, async_copy]\n- 调用者: nfsd4_copy\n- 被调用者: 未显示\n\n14. 函数名: kthread_create\n- 参数: [nfsd4_do_async_copy, async_copy, \"%s\", \"copy thread\"]\n- 调用者: nfsd4_copy\n- 被调用者: 未显示\n\n15. 函数名: IS_ERR\n- 参数: [async_copy->copy_task]\n- 调用者: nfsd4_copy\n- 被调用者: 未显示\n\n16. 函数名: spin_lock\n- 参数: [&async_copy->cp_clp->async_lock]\n- 调用者: nfsd4_copy\n- 被调用者: 未显示\n\n17. 函数名: list_add\n- 参数: [&async_copy->copies, &async_copy->cp_clp->async_copies]\n- 调用者: nfsd4_copy\n- 被调用者: 未显示\n\n18. 函数名: spin_unlock\n- 参数: [&async_copy->cp_clp->async_lock]\n- 调用者: nfsd4_copy\n- 被调用者: 未显示\n\n19. 函数名: wake_up_process\n- 参数: [async_copy->copy_task]\n- 调用者: nfsd4_copy\n- 被调用者: 未显示\n\n20. 函数名: nfsd4_do_copy\n- 参数: [copy, copy->nf_src->nf_file, copy->nf_dst->nf_file, true]\n- 调用者: nfsd4_copy\n- 被调用者: 未显示\n\n21. 函数名: nfsd4_cleanup_intra_ssc\n- 参数: [copy->nf_src, copy->nf_dst]\n- 调用者: nfsd4_copy\n- 被调用者: 未显示\n\n22. 函数名: cleanup_async_copy\n- 参数: [async_copy]\n- 调用者: nfsd4_copy\n- 被调用者: 未显示\n\n23. 函数名: nfsd4_interssc_disconnect\n- 参数: [copy->ss_mnt]\n- 调用者: nfsd4_copy\n- 被调用者: 未显示"
    },
    {
        "id": 3747,
        "cwe": "CWE-416",
        "cve": "CVE-2022-4382",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux gadgetfs驱动中超级块的填充和初始化，包括创建根inode和设备文件，用于USB gadget功能模拟。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在gadgetfs驱动中，当设备被拔出时，由于超级块操作之间的竞争条件导致了对已释放内存的使用\"\"\"",
        "functions": "Functions:\n1. 函数名: gadgetfs_fill_super\n- 参数: [struct super_block *sb, struct fs_context *fc]\n- 调用者: 未显示（通常由文件系统挂载流程调用）\n- 被调用者: [usb_get_gadget_udc_name, gadgetfs_make_inode, d_make_root, dev_new, gadgetfs_create_file, put_dev, kfree]\n\n2. 函数名: usb_get_gadget_udc_name\n- 参数: []\n- 调用者: gadgetfs_fill_super\n- 被调用者: []\n\n3. 函数名: gadgetfs_make_inode\n- 参数: [struct super_block *sb, NULL, &simple_dir_operations, S_IFDIR | S_IRUGO | S_IXUGO]\n- 调用者: gadgetfs_fill_super\n- 被调用者: []\n\n4. 函数名: d_make_root\n- 参数: [struct inode *inode]\n- 调用者: gadgetfs_fill_super\n- 被调用者: []\n\n5. 函数名: dev_new\n- 参数: []\n- 调用者: gadgetfs_fill_super\n- 被调用者: []\n\n6. 函数名: gadgetfs_create_file\n- 参数: [struct super_block *sb, CHIP, dev, &ep0_operations]\n- 调用者: gadgetfs_fill_super\n- 被调用者: []\n\n7. 函数名: put_dev\n- 参数: [struct dev_data *dev]\n- 调用者: gadgetfs_fill_super\n- 被调用者: []\n\n8. 函数名: kfree\n- 参数: [CHIP]\n- 调用者: gadgetfs_fill_super\n- 被调用者: []"
    },
    {
        "id": 3748,
        "cwe": "CWE-416",
        "cve": "CVE-2022-4382",
        "purpose": "Code purpose:\"\"\"该代码片段用于在gadgetfs驱动中清理超级块和相关设备资源，包括释放设备结构体和芯片数据结构。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在gadgetfs驱动中，由于超级块操作之间存在竞争条件，当设备被拔出时可能导致释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: gadgetfs_kill_sb\n- 参数: [struct super_block *sb]\n- 调用者: 未显示（由内核调用）\n- 被调用者: [kill_litter_super, put_dev, kfree]\n\n2. 函数名: kill_litter_super\n- 参数: [struct super_block *sb]\n- 调用者: gadgetfs_kill_sb\n- 被调用者: 未显示\n\n3. 函数名: put_dev\n- 参数: [未显示（应为the_device）]\n- 调用者: gadgetfs_kill_sb\n- 被调用者: 未显示\n\n4. 函数名: kfree\n- 参数: [CHIP]\n- 调用者: gadgetfs_kill_sb\n- 被调用者: 未显示"
    },
    {
        "id": 3753,
        "cwe": "CWE-416",
        "cve": "CVE-2022-45888",
        "purpose": "Code purpose:\"\"\"该代码实现了xillyusb设备的打开功能，包括设备通道的初始化、读写权限检查、端点分配和同步设置等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在USB设备物理移除时，xillyusb_open函数中存在竞态条件导致对已释放资源的后续访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: xillyusb_open\n- 参数: [struct inode *inode, struct file *filp]\n- 调用者: 无（内核驱动接口函数）\n- 被调用者: [xillybus_find_inode, mutex_lock, dev_err, kref_get, endpoint_alloc, fifo_init, flush_downstream, report_io_error, kzalloc, kfree, xillyusb_send_opcode, request_read_anything, safely_assign_in_fifo, fifo_mem_release, endpoint_dealloc, kref_put, mutex_unlock]\n\n2. 函数名: xillybus_find_inode\n- 参数: [struct inode *inode, void **xdev, int *index]\n- 调用者: xillyusb_open\n- 被调用者: 无\n\n3. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: xillyusb_open\n- 被调用者: 无\n\n4. 函数名: dev_err\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: xillyusb_open\n- 被调用者: 无\n\n5. 函数名: kref_get\n- 参数: [struct kref *kref]\n- 调用者: xillyusb_open\n- 被调用者: 无\n\n6. 函数名: endpoint_alloc\n- 参数: [struct xillyusb_dev *xdev, int endpoint_num, work_func_t work_func, int buf_size_order, int bufs_num]\n- 调用者: xillyusb_open\n- 被调用者: 无\n\n7. 函数名: fifo_init\n- 参数: [struct xillyfifo *fifo, int log2_fifo_size]\n- 调用者: xillyusb_open\n- 被调用者: 无\n\n8. 函数名: flush_downstream\n- 参数: [struct xillyusb_channel *chan, int timeout, bool force]\n- 调用者: xillyusb_open\n- 被调用者: 无\n\n9. 函数名: report_io_error\n- 参数: [struct xillyusb_dev *xdev, int rc]\n- 调用者: xillyusb_open\n- 被调用者: 无\n\n10. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: xillyusb_open\n- 被调用者: 无\n\n11. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: xillyusb_open\n- 被调用者: 无\n\n12. 函数名: xillyusb_send_opcode\n- 参数: [struct xillyusb_dev *xdev, int endpoint_num, int opcode, u32 data]\n- 调用者: xillyusb_open\n- 被调用者: 无\n\n13. 函数名: request_read_anything\n- 参数: [struct xillyusb_channel *chan, int opcode]\n- 调用者: xillyusb_open\n- 被调用者: 无\n\n14. 函数名: safely_assign_in_fifo\n- 参数: [struct xillyusb_channel *chan, struct xillyfifo *in_fifo]\n- 调用者: xillyusb_open\n- 被调用者: 无\n\n15. 函数名: fifo_mem_release\n- 参数: [struct xillyfifo *fifo]\n- 调用者: xillyusb_open\n- 被调用者: 无\n\n16. 函数名: endpoint_dealloc\n- 参数: [struct xillyusb_endpoint *ep]\n- 调用者: xillyusb_open\n- 被调用者: 无\n\n17. 函数名: kref_put\n- 参数: [struct kref *kref, void (*release)(struct kref *kref)]\n- 调用者: xillyusb_open\n- 被调用者: [cleanup_dev]\n\n18. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: xillyusb_open\n- 被调用者: 无\n\n19. 函数名: cleanup_dev\n- 参数: [struct kref *kref]\n- 调用者: kref_put\n- 被调用者: 无"
    },
    {
        "id": 3754,
        "cwe": "CWE-416",
        "cve": "CVE-2022-45888",
        "purpose": "Code purpose:\"\"\"在USB设备物理移除时，清理相关资源并处理设备断开连接的操作，包括发送停止命令、终止未完成的URB以及释放设备数据结构。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在USB设备物理移除时，xillyusb_disconnect函数存在竞态条件导致在释放xdev后仍可能被访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: xillyusb_disconnect\n- 参数: [struct usb_interface *interface]\n- 调用者: 无（由USB子系统调用）\n- 被调用者: [usb_get_intfdata, xillybus_cleanup_chrdev, xillyusb_send_opcode, wait_event_interruptible_timeout, dev_err, report_io_error, mutex_lock, endpoint_quiesce, mutex_unlock, usb_set_intfdata, kref_put]\n\n2. 函数名: usb_get_intfdata\n- 参数: [struct usb_interface *interface]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n3. 函数名: xillybus_cleanup_chrdev\n- 参数: [struct xillyusb_dev *xdev, struct device *dev]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n4. 函数名: xillyusb_send_opcode\n- 参数: [struct xillyusb_dev *xdev, ~0, OPCODE_QUIESCE, 0]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n5. 函数名: wait_event_interruptible_timeout\n- 参数: [fifo->waitq, msg_ep->drained || xdev->error, XILLY_RESPONSE_TIMEOUT]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n6. 函数名: dev_err\n- 参数: [&interface->dev, \"Weird timeout condition on sending quiesce request.\\n\"]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n7. 函数名: report_io_error\n- 参数: [xdev, -ENODEV]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n8. 函数名: mutex_lock\n- 参数: [&chan->lock]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n9. 函数名: endpoint_quiesce\n- 参数: [chan->out_ep]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n10. 函数名: mutex_unlock\n- 参数: [&chan->lock]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n11. 函数名: usb_set_intfdata\n- 参数: [interface, NULL]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无\n\n12. 函数名: kref_put\n- 参数: [&xdev->kref, cleanup_dev]\n- 调用者: xillyusb_disconnect\n- 被调用者: 无"
    },
    {
        "id": 3755,
        "cwe": "CWE-416",
        "cve": "CVE-2022-45919",
        "purpose": "Code purpose:\"\"\"初始化并管理DVB-CA (Common Interface)设备的硬件接口和状态，包括内存分配、设备注册、插槽初始化和监控线程创建。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在驱动程序断开连接后，由于缺少wait_event等待机制，导致在open操作后可能发生use-after-free问题\"\"\"",
        "functions": "Functions:\n1. 函数名: dvb_ca_en50221_init\n- 参数: [struct dvb_adapter *dvb_adapter, struct dvb_ca_en50221 *pubca, int flags, int slot_count]\n- 调用者: 未显示（外部调用）\n- 被调用者: [kzalloc, kref_init, kcalloc, init_waitqueue_head, dvb_register_device, memset, atomic_set, mutex_init, signal_pending, mb, kthread_run, dvb_unregister_device, kfree]\n\n2. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: dvb_ca_en50221_init\n- 被调用者: 未显示（内核函数）\n\n3. 函数名: kref_init\n- 参数: [struct kref *kref]\n- 调用者: dvb_ca_en50221_init\n- 被调用者: 未显示（内核函数）\n\n4. 函数名: kcalloc\n- 参数: [size_t n, size_t size, gfp_t flags]\n- 调用者: dvb_ca_en50221_init\n- 被调用者: 未显示（内核函数）\n\n5. 函数名: init_waitqueue_head\n- 参数: [wait_queue_head_t *q]\n- 调用者: dvb_ca_en50221_init\n- 被调用者: 未显示（内核函数）\n\n6. 函数名: dvb_register_device\n- 参数: [struct dvb_adapter *adap, struct dvb_device **pdvbdev, const struct dvb_device *template, void *priv, int type, int demux_sink_pads]\n- 调用者: dvb_ca_en50221_init\n- 被调用者: 未显示（外部函数）\n\n7. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: dvb_ca_en50221_init\n- 被调用者: 未显示（标准库函数）\n\n8. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: dvb_ca_en50221_init\n- 被调用者: 未显示（内核函数）\n\n9. 函数名: mutex_init\n- 参数: [struct mutex *lock]\n- 调用者: dvb_ca_en50221_init\n- 被调用者: 未显示（内核函数）\n\n10. 函数名: signal_pending\n- 参数: [struct task_struct *p]\n- 调用者: dvb_ca_en50221_init\n- 被调用者: 未显示（内核函数）\n\n11. 函数名: mb\n- 参数: []\n- 调用者: dvb_ca_en50221_init\n- 被调用者: 未显示（内核函数）\n\n12. 函数名: kthread_run\n- 参数: [int (*threadfn)(void *data), void *data, const char namefmt[], ...]\n- 调用者: dvb_ca_en50221_init\n- 被调用者: 未显示（内核函数）\n\n13. 函数名: dvb_unregister_device\n- 参数: [struct dvb_device *dvbdev]\n- 调用者: dvb_ca_en50221_init\n- 被调用者: 未显示（外部函数）\n\n14. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: dvb_ca_en50221_init\n- 被调用者: 未显示（内核函数）"
    },
    {
        "id": 3756,
        "cwe": "CWE-416",
        "cve": "CVE-2022-45919",
        "purpose": "Code purpose:\"\"\"释放DVB CA设备的资源并在设备关闭时进行清理操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在驱动程序释放资源后未等待相关操作完成，导致断开连接后可能发生释放后使用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: dvb_ca_en50221_io_release\n- 参数: [struct inode *inode, struct file *file]\n- 调用者: 未指定（通常是文件操作结构体中的release函数指针）\n- 被调用者: [dprintk, dvb_ca_en50221_thread_update_delay, dvb_generic_release, module_put, dvb_ca_private_put]\n\n2. 函数名: dprintk\n- 参数: [const char *fmt, ...]\n- 调用者: dvb_ca_en50221_io_release\n- 被调用者: []\n\n3. 函数名: dvb_ca_en50221_thread_update_delay\n- 参数: [struct dvb_ca_private *ca]\n- 调用者: dvb_ca_en50221_io_release\n- 被调用者: []\n\n4. 函数名: dvb_generic_release\n- 参数: [struct inode *inode, struct file *file]\n- 调用者: dvb_ca_en50221_io_release\n- 被调用者: []\n\n5. 函数名: module_put\n- 参数: [struct module *module]\n- 调用者: dvb_ca_en50221_io_release\n- 被调用者: []\n\n6. 函数名: dvb_ca_private_put\n- 参数: [struct dvb_ca_private *ca]\n- 调用者: dvb_ca_en50221_io_release\n- 被调用者: []"
    },
    {
        "id": 3757,
        "cwe": "CWE-416",
        "cve": "CVE-2022-45919",
        "purpose": "Code purpose:\"\"\"释放DVB-CA EN50221接口相关的资源，包括停止线程、关闭所有插槽并移除设备\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在驱动程序断开连接后未正确等待线程结束，导致对已释放内存的引用，引发use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: dvb_ca_en50221_release\n- 参数: [struct dvb_ca_en50221 *pubca]\n- 调用者: 未明确（通常是外部调用）\n- 被调用者: [kthread_stop, dvb_ca_en50221_slot_shutdown, dvb_remove_device, dvb_ca_private_put]\n\n2. 函数名: kthread_stop\n- 参数: [ca->thread]\n- 调用者: dvb_ca_en50221_release\n- 被调用者: []\n\n3. 函数名: dvb_ca_en50221_slot_shutdown\n- 参数: [ca, i]\n- 调用者: dvb_ca_en50221_release\n- 被调用者: []\n\n4. 函数名: dvb_remove_device\n- 参数: [ca->dvbdev]\n- 调用者: dvb_ca_en50221_release\n- 被调用者: []\n\n5. 函数名: dvb_ca_private_put\n- 参数: [ca]\n- 调用者: dvb_ca_en50221_release\n- 被调用者: []"
    },
    {
        "id": 3758,
        "cwe": "CWE-416",
        "cve": "CVE-2022-45919",
        "purpose": "Code purpose:\"\"\"该代码实现了DVB CA设备的打开功能，包括模块引用计数管理、设备状态检查和缓冲区处理等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在设备断开连接后未正确等待事件处理完成，导致在open操作后可能发生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: dvb_ca_en50221_io_open\n- 参数: [struct inode *inode, struct file *file]\n- 调用者: 未明确（通常是文件操作结构体中的open函数指针）\n- 被调用者: [try_module_get, dvb_generic_open, module_put, dvb_ringbuffer_flush, dvb_ca_en50221_thread_update_delay, dvb_ca_en50221_thread_wakeup, dvb_ca_private_get]\n\n2. 函数名: try_module_get\n- 参数: [ca->pub->owner]\n- 调用者: dvb_ca_en50221_io_open\n- 被调用者: []\n\n3. 函数名: dvb_generic_open\n- 参数: [struct inode *inode, struct file *file]\n- 调用者: dvb_ca_en50221_io_open\n- 被调用者: []\n\n4. 函数名: module_put\n- 参数: [ca->pub->owner]\n- 调用者: dvb_ca_en50221_io_open\n- 被调用者: []\n\n5. 函数名: dvb_ringbuffer_flush\n- 参数: [&sl->rx_buffer]\n- 调用者: dvb_ca_en50221_io_open\n- 被调用者: []\n\n6. 函数名: dvb_ca_en50221_thread_update_delay\n- 参数: [ca]\n- 调用者: dvb_ca_en50221_io_open\n- 被调用者: []\n\n7. 函数名: dvb_ca_en50221_thread_wakeup\n- 参数: [ca]\n- 调用者: dvb_ca_en50221_io_open\n- 被调用者: []\n\n8. 函数名: dvb_ca_private_get\n- 参数: [ca]\n- 调用者: dvb_ca_en50221_io_open\n- 被调用者: []"
    },
    {
        "id": 3761,
        "cwe": "CWE-416",
        "cve": "CVE-2022-4696",
        "purpose": "Code purpose:\"\"\"该代码片段用于在io_uring操作中根据操作类型获取内存映射(mm)和文件(files)资源，确保后续操作能正确访问这些资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当IORING_OP_SPLICE操作缺少IO_WQ_WORK_FILES标志时，未正确增加current->nsproxy的引用计数，导致后续错误减少引用计数引发释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: __io_sq_thread_acquire_mm_files\n- 参数: [ctx, req]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [__io_sq_thread_acquire_mm, __io_sq_thread_acquire_files]\n\n2. 函数名: __io_sq_thread_acquire_mm\n- 参数: [ctx]\n- 调用者: __io_sq_thread_acquire_mm_files\n- 被调用者: 未明确（上下文未提供）\n\n3. 函数名: __io_sq_thread_acquire_files\n- 参数: [ctx]\n- 调用者: __io_sq_thread_acquire_mm_files\n- 被调用者: 未明确（上下文未提供）"
    },
    {
        "id": 3778,
        "cwe": "CWE-416",
        "cve": "CVE-2022-47946",
        "purpose": "Code purpose:\"\"\"该代码用于在IO环形缓冲区满时等待空间可用，处理可能的中断和所有者死亡情况，并在条件满足时恢复执行。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_sqpoll_wait_sq函数中，当ctx->sqo_dead为真时直接跳转到out标签，跳过了finish_wait调用，导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_sqpoll_wait_sq\n- 参数: [ctx]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [io_sqring_full, prepare_to_wait, signal_pending, schedule, finish_wait]\n\n2. 函数名: io_sqring_full\n- 参数: [ctx]\n- 调用者: io_sqpoll_wait_sq\n- 被调用者: []\n\n3. 函数名: prepare_to_wait\n- 参数: [&ctx->sqo_sq_wait, &wait, TASK_INTERRUPTIBLE]\n- 调用者: io_sqpoll_wait_sq\n- 被调用者: []\n\n4. 函数名: signal_pending\n- 参数: [current]\n- 调用者: io_sqpoll_wait_sq\n- 被调用者: []\n\n5. 函数名: schedule\n- 参数: []\n- 调用者: io_sqpoll_wait_sq\n- 被调用者: []\n\n6. 函数名: finish_wait\n- 参数: [&ctx->sqo_sq_wait, &wait]\n- 调用者: io_sqpoll_wait_sq\n- 被调用者: []"
    },
    {
        "id": 3779,
        "cwe": "CWE-416",
        "cve": "CVE-2022-47946",
        "purpose": "Code purpose:\"\"\"该代码用于在io_uring上下文关闭时，安全地终止所有相关操作并清理资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_ring_ctx_wait_and_kill函数中，由于未能正确处理IORING_SETUP_SQPOLL标志下的等待队列，导致在进程快速fork并终止时可能跳过finish_wait操作，引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_ring_ctx_wait_and_kill\n- 参数: [struct io_ring_ctx *ctx]\n- 调用者: 未显示\n- 被调用者: [mutex_lock, percpu_ref_kill, WARN_ON_ONCE, __io_cqring_overflow_flush, idr_for_each, mutex_unlock, io_kill_timeouts, io_poll_remove_all, io_iopoll_try_reap_events, INIT_WORK, queue_work]\n\n2. 函数名: mutex_lock\n- 参数: [&ctx->uring_lock]\n- 调用者: io_ring_ctx_wait_and_kill\n- 被调用者: 未显示\n\n3. 函数名: percpu_ref_kill\n- 参数: [&ctx->refs]\n- 调用者: io_ring_ctx_wait_and_kill\n- 被调用者: 未显示\n\n4. 函数名: WARN_ON_ONCE\n- 参数: [(ctx->flags & IORING_SETUP_SQPOLL) && !ctx->sqo_dead]\n- 调用者: io_ring_ctx_wait_and_kill\n- 被调用者: 未显示\n\n5. 函数名: __io_cqring_overflow_flush\n- 参数: [ctx, true, NULL, NULL]\n- 调用者: io_ring_ctx_wait_and_kill\n- 被调用者: 未显示\n\n6. 函数名: idr_for_each\n- 参数: [&ctx->personality_idr, io_remove_personalities, ctx]\n- 调用者: io_ring_ctx_wait_and_kill\n- 被调用者: [io_remove_personalities]\n\n7. 函数名: mutex_unlock\n- 参数: [&ctx->uring_lock]\n- 调用者: io_ring_ctx_wait_and_kill\n- 被调用者: 未显示\n\n8. 函数名: io_kill_timeouts\n- 参数: [ctx, NULL, NULL]\n- 调用者: io_ring_ctx_wait_and_kill\n- 被调用者: 未显示\n\n9. 函数名: io_poll_remove_all\n- 参数: [ctx, NULL, NULL]\n- 调用者: io_ring_ctx_wait_and_kill\n- 被调用者: 未显示\n\n10. 函数名: io_iopoll_try_reap_events\n- 参数: [ctx]\n- 调用者: io_ring_ctx_wait_and_kill\n- 被调用者: 未显示\n\n11. 函数名: INIT_WORK\n- 参数: [&ctx->exit_work, io_ring_exit_work]\n- 调用者: io_ring_ctx_wait_and_kill\n- 被调用者: 未显示\n\n12. 函数名: queue_work\n- 参数: [system_unbound_wq, &ctx->exit_work]\n- 调用者: io_ring_ctx_wait_and_kill\n- 被调用者: 未显示"
    },
    {
        "id": 3780,
        "cwe": "CWE-416",
        "cve": "CVE-2022-47946",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中io_uring子系统的系统调用接口，用于处理异步I/O操作的提交和完成事件，支持轮询和等待机制。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_sqpoll_wait_sq函数中，由于可以跳过finish_wait操作，导致在进程快速fork并终止的情况下可能发生use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_uring_enter\n- 参数: [fd, to_submit, min_complete, flags, argp, argsz]\n- 调用者: SYSCALL_DEFINE6\n- 被调用者: [io_run_task_work, fdget, fdput, percpu_ref_tryget, percpu_ref_put, io_cqring_overflow_flush, io_sq_thread_fork, wake_up, io_sqpoll_wait_sq, io_uring_add_task_file, io_submit_sqes, io_get_ext_arg, io_iopoll_check, io_cqring_wait]\n\n2. 函数名: io_run_task_work\n- 参数: []\n- 调用者: io_uring_enter\n- 被调用者: []\n\n3. 函数名: fdget\n- 参数: [fd]\n- 调用者: io_uring_enter\n- 被调用者: []\n\n4. 函数名: fdput\n- 参数: [f]\n- 调用者: io_uring_enter\n- 被调用者: []\n\n5. 函数名: percpu_ref_tryget\n- 参数: [&ctx->refs]\n- 调用者: io_uring_enter\n- 被调用者: []\n\n6. 函数名: percpu_ref_put\n- 参数: [&ctx->refs]\n- 调用者: io_uring_enter\n- 被调用者: []\n\n7. 函数名: io_cqring_overflow_flush\n- 参数: [ctx, false, NULL, NULL]\n- 调用者: io_uring_enter\n- 被调用者: []\n\n8. 函数名: io_sq_thread_fork\n- 参数: [ctx->sq_data, ctx]\n- 调用者: io_uring_enter\n- 被调用者: []\n\n9. 函数名: wake_up\n- 参数: [&ctx->sq_data->wait]\n- 调用者: io_uring_enter\n- 被调用者: []\n\n10. 函数名: io_sqpoll_wait_sq\n- 参数: [ctx]\n- 调用者: io_uring_enter\n- 被调用者: []\n\n11. 函数名: io_uring_add_task_file\n- 参数: [ctx, f.file]\n- 调用者: io_uring_enter\n- 被调用者: []\n\n12. 函数名: io_submit_sqes\n- 参数: [ctx, to_submit]\n- 调用者: io_uring_enter\n- 被调用者: []\n\n13. 函数名: io_get_ext_arg\n- 参数: [flags, argp, &argsz, &ts, &sig]\n- 调用者: io_uring_enter\n- 被调用者: []\n\n14. 函数名: io_iopoll_check\n- 参数: [ctx, min_complete]\n- 调用者: io_uring_enter\n- 被调用者: []\n\n15. 函数名: io_cqring_wait\n- 参数: [ctx, min_complete, sig, argsz, ts]\n- 调用者: io_uring_enter\n- 被调用者: []"
    },
    {
        "id": 3781,
        "cwe": "CWE-416",
        "cve": "CVE-2022-47946",
        "purpose": "Code purpose:\"\"\"在io_uring子系统中创建并管理一个用于处理I/O操作的线程\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_sq_thread_fork函数中，由于线程创建失败时未正确处理等待队列状态，导致后续可能发生use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_sq_thread_fork\n- 参数: [sqd, ctx]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [clear_bit, reinit_completion, io_wq_fork_thread, wait_for_completion, io_uring_alloc_task_context]\n\n2. 函数名: clear_bit\n- 参数: [IO_SQ_THREAD_SHOULD_STOP, &sqd->state]\n- 调用者: io_sq_thread_fork\n- 被调用者: []\n\n3. 函数名: reinit_completion\n- 参数: [&sqd->completion]\n- 调用者: io_sq_thread_fork\n- 被调用者: []\n\n4. 函数名: io_wq_fork_thread\n- 参数: [io_sq_thread, sqd]\n- 调用者: io_sq_thread_fork\n- 被调用者: []\n\n5. 函数名: wait_for_completion\n- 参数: [&sqd->completion]\n- 调用者: io_sq_thread_fork\n- 被调用者: []\n\n6. 函数名: io_uring_alloc_task_context\n- 参数: [sqd->thread, ctx]\n- 调用者: io_sq_thread_fork\n- 被调用者: []"
    },
    {
        "id": 3782,
        "cwe": "CWE-416",
        "cve": "CVE-2022-47946",
        "purpose": "Code purpose:\"\"\"该代码用于创建和管理io_uring实例，包括初始化环形队列、设置参数、分配资源以及处理用户空间与内核空间的交互\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring_create函数中，当进程快速fork并终止时，由于finish_wait可能被跳过，导致io_sqpoll_wait_sq中出现use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_uring_create\n- 参数: [entries, p, params]\n- 调用者: 未显示（系统调用或其他内核函数）\n- 被调用者: [io_ring_ctx_alloc, get_uid, mmgrab, io_allocate_scq_urings, io_sq_offload_create, io_sq_offload_start, copy_to_user, io_uring_get_file, io_uring_install_fd, io_disable_sqo_submit, fput, trace_io_uring_create, io_ring_ctx_wait_and_kill]\n\n2. 函数名: io_ring_ctx_alloc\n- 参数: [p]\n- 调用者: io_uring_create\n- 被调用者: 未显示\n\n3. 函数名: get_uid\n- 参数: [current_user()]\n- 调用者: io_uring_create\n- 被调用者: 未显示\n\n4. 函数名: mmgrab\n- 参数: [current->mm]\n- 调用者: io_uring_create\n- 被调用者: 未显示\n\n5. 函数名: io_allocate_scq_urings\n- 参数: [ctx, p]\n- 调用者: io_uring_create\n- 被调用者: 未显示\n\n6. 函数名: io_sq_offload_create\n- 参数: [ctx, p]\n- 调用者: io_uring_create\n- 被调用者: 未显示\n\n7. 函数名: io_sq_offload_start\n- 参数: [ctx]\n- 调用者: io_uring_create\n- 被调用者: 未显示\n\n8. 函数名: copy_to_user\n- 参数: [params, p, sizeof(*p)]\n- 调用者: io_uring_create\n- 被调用者: 未显示\n\n9. 函数名: io_uring_get_file\n- 参数: [ctx]\n- 调用者: io_uring_create\n- 被调用者: 未显示\n\n10. 函数名: io_uring_install_fd\n- 参数: [ctx, file]\n- 调用者: io_uring_create\n- 被调用者: 未显示\n\n11. 函数名: io_disable_sqo_submit\n- 参数: [ctx]\n- 调用者: io_uring_create\n- 被调用者: 未显示\n\n12. 函数名: fput\n- 参数: [file]\n- 调用者: io_uring_create\n- 被调用者: 未显示\n\n13. 函数名: trace_io_uring_create\n- 参数: [ret, ctx, p->sq_entries, p->cq_entries, p->flags]\n- 调用者: io_uring_create\n- 被调用者: 未显示\n\n14. 函数名: io_ring_ctx_wait_and_kill\n- 参数: [ctx]\n- 调用者: io_uring_create\n- 被调用者: 未显示"
    },
    {
        "id": 3783,
        "cwe": "CWE-416",
        "cve": "CVE-2022-47946",
        "purpose": "Code purpose:\"\"\"该代码用于在io_uring子系统中取消SQPOLL模式下的I/O请求，并等待相关任务完成以避免竞争条件。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring_cancel_sqpoll函数中，由于prepare_to_wait和finish_wait之间的代码路径可能跳过finish_wait调用，导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_uring_cancel_sqpoll\n- 参数: [ctx]\n- 调用者: N/A\n- 被调用者: [io_disable_sqo_submit, io_sq_thread_park, io_sq_thread_unpark, tctx_inflight, io_uring_cancel_task_requests, prepare_to_wait, schedule, finish_wait, atomic_inc, atomic_dec]\n\n2. 函数名: io_disable_sqo_submit\n- 参数: [ctx]\n- 调用者: io_uring_cancel_sqpoll\n- 被调用者: N/A\n\n3. 函数名: io_sq_thread_park\n- 参数: [sqd]\n- 调用者: io_uring_cancel_sqpoll\n- 被调用者: N/A\n\n4. 函数名: io_sq_thread_unpark\n- 参数: [sqd]\n- 调用者: io_uring_cancel_sqpoll\n- 被调用者: N/A\n\n5. 函数名: tctx_inflight\n- 参数: [tctx]\n- 调用者: io_uring_cancel_sqpoll\n- 被调用者: N/A\n\n6. 函数名: io_uring_cancel_task_requests\n- 参数: [ctx, NULL]\n- 调用者: io_uring_cancel_sqpoll\n- 被调用者: N/A\n\n7. 函数名: prepare_to_wait\n- 参数: [&tctx->wait, &wait, TASK_UNINTERRUPTIBLE]\n- 调用者: io_uring_cancel_sqpoll\n- 被调用者: N/A\n\n8. 函数名: schedule\n- 参数: []\n- 调用者: io_uring_cancel_sqpoll\n- 被调用者: N/A\n\n9. 函数名: finish_wait\n- 参数: [&tctx->wait, &wait]\n- 调用者: io_uring_cancel_sqpoll\n- 被调用者: N/A\n\n10. 函数名: atomic_inc\n- 参数: [&tctx->in_idle]\n- 调用者: io_uring_cancel_sqpoll\n- 被调用者: N/A\n\n11. 函数名: atomic_dec\n- 参数: [&tctx->in_idle]\n- 调用者: io_uring_cancel_sqpoll\n- 被调用者: N/A"
    },
    {
        "id": 3784,
        "cwe": "CWE-416",
        "cve": "CVE-2022-47946",
        "purpose": "Code purpose:\"\"\"该代码用于处理Linux内核中io_uring子系统的提交队列任务，包括轮询已完成IO事件和提交新IO请求，同时管理相关锁和等待队列。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_sqpoll_wait_sq函数中，由于可以跳过finish_wait操作，导致在进程快速fork并终止的情况下可能发生use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: __io_sq_thread\n- 参数: [ctx, cap_entries]\n- 调用者: 未明确（可能是内核调度或其他IO_uring相关函数）\n- 被调用者: [io_sqring_entries, list_empty, mutex_lock, io_do_iopoll, percpu_ref_is_dying, io_submit_sqes, mutex_unlock, io_sqring_full, wq_has_sleeper, wake_up]\n\n2. 函数名: io_sqring_entries\n- 参数: [ctx]\n- 调用者: __io_sq_thread\n- 被调用者: []\n\n3. 函数名: list_empty\n- 参数: [&ctx->iopoll_list]\n- 调用者: __io_sq_thread\n- 被调用者: []\n\n4. 函数名: mutex_lock\n- 参数: [&ctx->uring_lock]\n- 调用者: __io_sq_thread\n- 被调用者: []\n\n5. 函数名: io_do_iopoll\n- 参数: [ctx, &nr_events, 0]\n- 调用者: __io_sq_thread\n- 被调用者: []\n\n6. 函数名: percpu_ref_is_dying\n- 参数: [&ctx->refs]\n- 调用者: __io_sq_thread\n- 被调用者: []\n\n7. 函数名: io_submit_sqes\n- 参数: [ctx, to_submit]\n- 调用者: __io_sq_thread\n- 被调用者: []\n\n8. 函数名: mutex_unlock\n- 参数: [&ctx->uring_lock]\n- 调用者: __io_sq_thread\n- 被调用者: []\n\n9. 函数名: io_sqring_full\n- 参数: [ctx]\n- 调用者: __io_sq_thread\n- 被调用者: []\n\n10. 函数名: wq_has_sleeper\n- 参数: [&ctx->sqo_sq_wait]\n- 调用者: __io_sq_thread\n- 被调用者: []\n\n11. 函数名: wake_up\n- 参数: [&ctx->sqo_sq_wait]\n- 调用者: __io_sq_thread\n- 被调用者: []"
    },
    {
        "id": 3785,
        "cwe": "CWE-416",
        "cve": "CVE-2022-47946",
        "purpose": "Code purpose:\"\"\"该代码用于取消当前任务的io_uring操作，包括停止sqpoll模式下的提交、等待未完成请求取消，并清理相关资源。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring_task_cancel函数中，当进程被快速终止时，可能导致finish_wait被跳过，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: __io_uring_task_cancel\n- 参数: []\n- 调用者: N/A\n- 被调用者: [atomic_inc, io_uring_cancel_sqpoll, tctx_inflight, __io_uring_files_cancel, prepare_to_wait, schedule, finish_wait, atomic_dec, io_uring_clean_tctx, __io_uring_free]\n\n2. 函数名: atomic_inc\n- 参数: [&tctx->in_idle]\n- 调用者: __io_uring_task_cancel\n- 被调用者: []\n\n3. 函数名: io_uring_cancel_sqpoll\n- 参数: [file->private_data]\n- 调用者: __io_uring_task_cancel\n- 被调用者: []\n\n4. 函数名: tctx_inflight\n- 参数: [tctx]\n- 调用者: __io_uring_task_cancel\n- 被调用者: []\n\n5. 函数名: __io_uring_files_cancel\n- 参数: [NULL]\n- 调用者: __io_uring_task_cancel\n- 被调用者: []\n\n6. 函数名: prepare_to_wait\n- 参数: [&tctx->wait, &wait, TASK_UNINTERRUPTIBLE]\n- 调用者: __io_uring_task_cancel\n- 被调用者: []\n\n7. 函数名: schedule\n- 参数: []\n- 调用者: __io_uring_task_cancel\n- 被调用者: []\n\n8. 函数名: finish_wait\n- 参数: [&tctx->wait, &wait]\n- 调用者: __io_uring_task_cancel\n- 被调用者: []\n\n9. 函数名: atomic_dec\n- 参数: [&tctx->in_idle]\n- 调用者: __io_uring_task_cancel\n- 被调用者: []\n\n10. 函数名: io_uring_clean_tctx\n- 参数: [tctx]\n- 调用者: __io_uring_task_cancel\n- 被调用者: []\n\n11. 函数名: __io_uring_free\n- 参数: [current]\n- 调用者: __io_uring_task_cancel\n- 被调用者: []"
    },
    {
        "id": 3786,
        "cwe": "CWE-416",
        "cve": "CVE-2022-47946",
        "purpose": "Code purpose:\"\"\"该代码片段用于在io_uring子系统中处理请求提交，根据上下文状态决定是排队请求还是取消请求\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_sqpoll_wait_sq中，由于finish_wait可能被跳过，导致在进程fork后快速终止的情况下出现use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: __io_req_task_submit\n- 参数: [struct io_kiocb *req]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [mutex_lock, mutex_unlock, __io_queue_sqe, __io_req_task_cancel]\n\n2. 函数名: mutex_lock\n- 参数: [&ctx->uring_lock]\n- 调用者: __io_req_task_submit\n- 被调用者: []\n\n3. 函数名: mutex_unlock\n- 参数: [&ctx->uring_lock]\n- 调用者: __io_req_task_submit\n- 被调用者: []\n\n4. 函数名: __io_queue_sqe\n- 参数: [req]\n- 调用者: __io_req_task_submit\n- 被调用者: []\n\n5. 函数名: __io_req_task_cancel\n- 参数: [req, -EFAULT]\n- 调用者: __io_req_task_submit\n- 被调用者: []"
    },
    {
        "id": 3787,
        "cwe": "CWE-416",
        "cve": "CVE-2022-47946",
        "purpose": "Code purpose:\"\"\"该代码用于在io_uring操作中取消与特定任务或文件描述符相关的请求，并处理SQPOLL线程的暂停与恢复操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring_cancel_task_requests函数中，当did_park为true时，可能由于进程快速终止导致task指针变为悬垂指针，从而在后续的atomic_dec操作中引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_uring_cancel_task_requests\n- 参数: [struct io_ring_ctx *ctx, struct files_struct *files]\n- 调用者: N/A\n- 被调用者: [io_disable_sqo_submit, io_sq_thread_park, io_cancel_defer_files, io_uring_cancel_files, io_uring_try_cancel_requests, atomic_inc, atomic_dec, io_sq_thread_unpark]\n\n2. 函数名: io_disable_sqo_submit\n- 参数: [struct io_ring_ctx *ctx]\n- 调用者: io_uring_cancel_task_requests\n- 被调用者: N/A\n\n3. 函数名: io_sq_thread_park\n- 参数: [struct io_sq_data *sq_data]\n- 调用者: io_uring_cancel_task_requests\n- 被调用者: N/A\n\n4. 函数名: io_cancel_defer_files\n- 参数: [struct io_ring_ctx *ctx, struct task_struct *task, struct files_struct *files]\n- 调用者: io_uring_cancel_task_requests\n- 被调用者: N/A\n\n5. 函数名: io_uring_cancel_files\n- 参数: [struct io_ring_ctx *ctx, struct task_struct *task, struct files_struct *files]\n- 调用者: io_uring_cancel_task_requests\n- 被调用者: N/A\n\n6. 函数名: io_uring_try_cancel_requests\n- 参数: [struct io_ring_ctx *ctx, struct task_struct *task, NULL]\n- 调用者: io_uring_cancel_task_requests\n- 被调用者: N/A\n\n7. 函数名: atomic_inc\n- 参数: [&task->io_uring->in_idle]\n- 调用者: io_uring_cancel_task_requests\n- 被调用者: N/A\n\n8. 函数名: atomic_dec\n- 参数: [&task->io_uring->in_idle]\n- 调用者: io_uring_cancel_task_requests\n- 被调用者: N/A\n\n9. 函数名: io_sq_thread_unpark\n- 参数: [struct io_sq_data *sq_data]\n- 调用者: io_uring_cancel_task_requests\n- 被调用者: N/A"
    },
    {
        "id": 3803,
        "cwe": "CWE-416",
        "cve": "CVE-2023-0030",
        "purpose": "Code purpose:\"\"\"该代码用于处理Nouveau驱动中虚拟内存管理器的映射请求，包括内存区域的查找、分割和映射操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在nvkm_uvmm_mthd_map函数中，当nvkm_vma_tail函数失败时未正确处理vma对象的释放，导致后续可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: nvkm_uvmm_mthd_map\n- 参数: [uvmm, argv, argc]\n- 调用者: 无（顶级函数）\n- 被调用者: [nvif_unpack, nvkm_umem_search, nvkm_vmm_node_search, nvkm_vma_tail, nvkm_vmm_node_insert, nvkm_vmm_unmap_region, nvkm_memory_map, nvkm_memory_unref]\n\n2. 函数名: nvif_unpack\n- 参数: [ret, &argv, &argc, args->v0, 0, 0, true]\n- 调用者: nvkm_uvmm_mthd_map\n- 被调用者: 无\n\n3. 函数名: nvkm_umem_search\n- 参数: [client, handle]\n- 调用者: nvkm_uvmm_mthd_map\n- 被调用者: 无\n\n4. 函数名: nvkm_vmm_node_search\n- 参数: [vmm, addr]\n- 调用者: nvkm_uvmm_mthd_map\n- 被调用者: 无\n\n5. 函数名: nvkm_vma_tail\n- 参数: [vma, tail]\n- 调用者: nvkm_uvmm_mthd_map\n- 被调用者: 无\n\n6. 函数名: nvkm_vmm_node_insert\n- 参数: [vmm, vma]\n- 调用者: nvkm_uvmm_mthd_map\n- 被调用者: 无\n\n7. 函数名: nvkm_vmm_unmap_region\n- 参数: [vmm, vma]\n- 调用者: nvkm_uvmm_mthd_map\n- 被调用者: 无\n\n8. 函数名: nvkm_memory_map\n- 参数: [memory, offset, vmm, vma, argv, argc]\n- 调用者: nvkm_uvmm_mthd_map\n- 被调用者: 无\n\n9. 函数名: nvkm_memory_unref\n- 参数: [&memory]\n- 调用者: nvkm_uvmm_mthd_map\n- 被调用者: 无"
    },
    {
        "id": 3804,
        "cwe": "CWE-416",
        "cve": "CVE-2023-0030",
        "purpose": "Code purpose:\"\"\"该代码用于在Nouveau驱动中管理虚拟内存分配，包括查找、分割和标记虚拟内存区域，并处理页面表分配和稀疏映射\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在nvkm_vmm_get_locked函数中，当nvkm_vma_tail函数调用失败时，未能正确处理已分配的vma资源，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nvkm_vmm_get_locked\n- 参数: [struct nvkm_vmm *vmm, bool getref, bool mapref, bool sparse, u8 shift, u8 align, u64 size, struct nvkm_vma **pvma]\n- 调用者: N/A (顶层函数)\n- 被调用者: [VMM_TRACE, VMM_DEBUG, rb_entry, rb_next, rb_erase, nvkm_vma_tail, nvkm_vmm_put_region, nvkm_vmm_free_insert, nvkm_vmm_ptes_sparse_get, nvkm_vmm_ptes_sparse, nvkm_vmm_ptes_get, nvkm_vmm_node_insert]\n\n2. 函数名: VMM_TRACE\n- 参数: [struct nvkm_vmm *vmm, const char *fmt, ...]\n- 调用者: nvkm_vmm_get_locked\n- 被调用者: N/A\n\n3. 函数名: VMM_DEBUG\n- 参数: [struct nvkm_vmm *vmm, const char *fmt, ...]\n- 调用者: nvkm_vmm_get_locked\n- 被调用者: N/A\n\n4. 函数名: rb_entry\n- 参数: [struct rb_node *node, type, member]\n- 调用者: nvkm_vmm_get_locked\n- 被调用者: N/A\n\n5. 函数名: rb_next\n- 参数: [struct rb_node *node]\n- 调用者: nvkm_vmm_get_locked\n- 被调用者: N/A\n\n6. 函数名: rb_erase\n- 参数: [struct rb_node *node, struct rb_root *root]\n- 调用者: nvkm_vmm_get_locked\n- 被调用者: N/A\n\n7. 函数名: nvkm_vma_tail\n- 参数: [struct nvkm_vma *vma, u64 size]\n- 调用者: nvkm_vmm_get_locked\n- 被调用者: N/A\n\n8. 函数名: nvkm_vmm_put_region\n- 参数: [struct nvkm_vmm *vmm, struct nvkm_vma *vma]\n- 调用者: nvkm_vmm_get_locked\n- 被调用者: N/A\n\n9. 函数名: nvkm_vmm_free_insert\n- 参数: [struct nvkm_vmm *vmm, struct nvkm_vma *vma]\n- 调用者: nvkm_vmm_get_locked\n- 被调用者: N/A\n\n10. 函数名: nvkm_vmm_ptes_sparse_get\n- 参数: [struct nvkm_vmm *vmm, const struct nvkm_vmm_page *page, u64 addr, u64 size]\n- 调用者: nvkm_vmm_get_locked\n- 被调用者: N/A\n\n11. 函数名: nvkm_vmm_ptes_sparse\n- 参数: [struct nvkm_vmm *vmm, u64 addr, u64 size, bool map]\n- 调用者: nvkm_vmm_get_locked\n- 被调用者: N/A\n\n12. 函数名: nvkm_vmm_ptes_get\n- 参数: [struct nvkm_vmm *vmm, const struct nvkm_vmm_page *page, u64 addr, u64 size]\n- 调用者: nvkm_vmm_get_locked\n- 被调用者: N/A\n\n13. 函数名: nvkm_vmm_node_insert\n- 参数: [struct nvkm_vmm *vmm, struct nvkm_vma *vma]\n- 调用者: nvkm_vmm_get_locked\n- 被调用者: N/A"
    },
    {
        "id": 3805,
        "cwe": "CWE-416",
        "cve": "CVE-2023-0030",
        "purpose": "Code purpose:\"\"\"该代码用于释放和管理NVIDIA显卡驱动中的虚拟内存区域(VMA)资源，包括合并相邻的空闲内存区域和清理相关数据结构。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放vma内存后未正确更新指针引用，导致后续操作可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: nvkm_vmm_unmap_region\n- 参数: [vmm, vma]\n- 调用者: 未显示\n- 被调用者: [nvkm_memory_tags_put, nvkm_memory_unref, node, rb_erase, list_del, kfree]\n\n2. 函数名: nvkm_memory_tags_put\n- 参数: [vma->memory, vmm->mmu->subdev.device, &vma->tags]\n- 调用者: nvkm_vmm_unmap_region\n- 被调用者: 未显示\n\n3. 函数名: nvkm_memory_unref\n- 参数: [&vma->memory]\n- 调用者: nvkm_vmm_unmap_region\n- 被调用者: 未显示\n\n4. 函数名: node\n- 参数: [vma, prev/next]\n- 调用者: nvkm_vmm_unmap_region\n- 被调用者: 未显示\n\n5. 函数名: rb_erase\n- 参数: [&vma->tree/&next->tree, &vmm->root]\n- 调用者: nvkm_vmm_unmap_region\n- 被调用者: 未显示\n\n6. 函数名: list_del\n- 参数: [&vma->head/&next->head]\n- 调用者: nvkm_vmm_unmap_region\n- 被调用者: 未显示\n\n7. 函数名: kfree\n- 参数: [vma/next]\n- 调用者: nvkm_vmm_unmap_region\n- 被调用者: 未显示"
    },
    {
        "id": 3806,
        "cwe": "CWE-416",
        "cve": "CVE-2023-0030",
        "purpose": "Code purpose:\"\"\"管理虚拟内存区域的释放和合并操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放prev或next指针后未正确置空，导致后续可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: nvkm_vmm_put_region\n- 参数: [struct nvkm_vmm *vmm, struct nvkm_vma *vma]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [node, rb_erase, list_del, kfree, nvkm_vmm_free_insert]\n\n2. 函数名: node\n- 参数: [struct nvkm_vma *vma, struct nvkm_vma *prev/next]\n- 调用者: nvkm_vmm_put_region\n- 被调用者: 未明确\n\n3. 函数名: rb_erase\n- 参数: [struct rb_node *node, struct rb_root *root]\n- 调用者: nvkm_vmm_put_region\n- 被调用者: 未明确\n\n4. 函数名: list_del\n- 参数: [struct list_head *entry]\n- 调用者: nvkm_vmm_put_region\n- 被调用者: 未明确\n\n5. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: nvkm_vmm_put_region\n- 被调用者: 未明确\n\n6. 函数名: nvkm_vmm_free_insert\n- 参数: [struct nvkm_vmm *vmm, struct nvkm_vma *vma]\n- 调用者: nvkm_vmm_put_region\n- 被调用者: 未明确"
    },
    {
        "id": 3807,
        "cwe": "CWE-416",
        "cve": "CVE-2023-0030",
        "purpose": "Code purpose:\"\"\"管理Nouveau显卡驱动中的虚拟内存区域(VMA)的释放和合并操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放内存后未正确清理指针导致后续可能被错误引用\"\"\"",
        "functions": "Functions:\n1. 函数名: nvkm_vmm_put_locked\n- 参数: [vmm, vma]\n- 调用者: 未显示\n- 被调用者: [node, nvkm_vmm_ptes_unmap_put, nvkm_vmm_ptes_put, nvkm_vmm_unmap_region, nvkm_vmm_ptes_sparse_put, nvkm_vmm_ptes_sparse, rb_erase, nvkm_vmm_put_region]\n\n2. 函数名: node\n- 参数: [next, next] (或 [vma, next] 根据上下文)\n- 调用者: nvkm_vmm_put_locked\n- 被调用者: 未显示\n\n3. 函数名: nvkm_vmm_ptes_unmap_put\n- 参数: [vmm, &page[refd], addr, size, vma->sparse]\n- 调用者: nvkm_vmm_put_locked\n- 被调用者: 未显示\n\n4. 函数名: nvkm_vmm_ptes_put\n- 参数: [vmm, &page[refd], addr, size]\n- 调用者: nvkm_vmm_put_locked\n- 被调用者: 未显示\n\n5. 函数名: nvkm_vmm_unmap_region\n- 参数: [vmm, next]\n- 调用者: nvkm_vmm_put_locked\n- 被调用者: 未显示\n\n6. 函数名: nvkm_vmm_ptes_sparse_put\n- 参数: [vmm, &page[vma->refd], vma->addr, vma->size]\n- 调用者: nvkm_vmm_put_locked\n- 被调用者: 未显示\n\n7. 函数名: nvkm_vmm_ptes_sparse\n- 参数: [vmm, vma->addr, vma->size, false]\n- 调用者: nvkm_vmm_put_locked\n- 被调用者: 未显示\n\n8. 函数名: rb_erase\n- 参数: [&vma->tree, &vmm->root]\n- 调用者: nvkm_vmm_put_locked\n- 被调用者: 未显示\n\n9. 函数名: nvkm_vmm_put_region\n- 参数: [vmm, vma]\n- 调用者: nvkm_vmm_put_locked\n- 被调用者: 未显示"
    },
    {
        "id": 3815,
        "cwe": "CWE-416",
        "cve": "CVE-2023-0240",
        "purpose": "Code purpose:\"\"\"从io_ring_ctx结构中移除指定ID的凭证引用并释放相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring实现中存在逻辑错误，当io_grab_identity调用返回false时错误地使用了init_cred或之前请求的身份，导致引用计数问题引发释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_remove_personalities\n- 参数: [id, p, data]\n- 调用者: 未明确（上下文不足）\n- 被调用者: [idr_remove, put_cred]\n\n2. 函数名: idr_remove\n- 参数: [&ctx->personality_idr, id]\n- 调用者: io_remove_personalities\n- 被调用者: 未明确（假设为内核函数）\n\n3. 函数名: put_cred\n- 参数: [cred]\n- 调用者: io_remove_personalities\n- 被调用者: 未明确（假设为内核函数）"
    },
    {
        "id": 3816,
        "cwe": "CWE-416",
        "cve": "CVE-2023-0240",
        "purpose": "Code purpose:\"\"\"为异步I/O请求准备相关工作环境，包括设置文件、内存、凭证等资源，并管理相关引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_prep_async_work函数中错误假设io_grab_identity调用总会成功，当失败时会错误使用init_cred或之前请求的身份而非当前身份，导致引用计数问题引发释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_prep_async_work\n- 参数: [struct io_kiocb *req]\n- 调用者: N/A\n- 被调用者: [io_req_init_async, io_wq_hash_work, get_files_struct, get_nsproxy, mmgrab, blkcg_css, css_tryget_online, get_current_cred, rlimit]\n\n2. 函数名: io_req_init_async\n- 参数: [struct io_kiocb *req]\n- 调用者: io_prep_async_work\n- 被调用者: N/A\n\n3. 函数名: io_wq_hash_work\n- 参数: [&req->work, file_inode(req->file)]\n- 调用者: io_prep_async_work\n- 被调用者: N/A\n\n4. 函数名: get_files_struct\n- 参数: [current]\n- 调用者: io_prep_async_work\n- 被调用者: N/A\n\n5. 函数名: get_nsproxy\n- 参数: [current->nsproxy]\n- 调用者: io_prep_async_work\n- 被调用者: N/A\n\n6. 函数名: mmgrab\n- 参数: [current->mm]\n- 调用者: io_prep_async_work\n- 被调用者: N/A\n\n7. 函数名: blkcg_css\n- 参数: []\n- 调用者: io_prep_async_work\n- 被调用者: N/A\n\n8. 函数名: css_tryget_online\n- 参数: [req->work.identity->blkcg_css]\n- 调用者: io_prep_async_work\n- 被调用者: N/A\n\n9. 函数名: get_current_cred\n- 参数: []\n- 调用者: io_prep_async_work\n- 被调用者: N/A\n\n10. 函数名: rlimit\n- 参数: [RLIMIT_FSIZE]\n- 调用者: io_prep_async_work\n- 被调用者: N/A"
    },
    {
        "id": 3817,
        "cwe": "CWE-416",
        "cve": "CVE-2023-0240",
        "purpose": "Code purpose:\"\"\"初始化异步IO请求的工作结构并设置身份标识\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring实现中存在逻辑错误，当io_grab_identity调用返回false时错误地使用了init_cred或之前链接请求的身份而非当前身份，导致引用计数问题引发释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_req_init_async\n- 参数: [struct io_kiocb *req]\n- 调用者: 未明确（可能是io_prep_async_work或其他调用者）\n- 被调用者: [memset]\n\n2. 函数名: memset\n- 参数: [&req->work, 0, sizeof(req->work)]\n- 调用者: io_req_init_async\n- 被调用者: []"
    },
    {
        "id": 3818,
        "cwe": "CWE-416",
        "cve": "CVE-2023-0240",
        "purpose": "Code purpose:\"\"\"释放io_uring请求资源并处理相关引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_prep_async_work函数中错误假设io_grab_identity调用总会返回true，导致可能使用错误的身份凭证进行操作，引发引用计数问题和使用后释放漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: __io_free_req\n- 参数: [struct io_kiocb *req]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [io_dismantle_req, atomic_long_inc, wake_up, put_task_struct, kmem_cache_free, clear_bit_unlock, percpu_ref_put]\n\n2. 函数名: io_dismantle_req\n- 参数: [struct io_kiocb *req]\n- 调用者: __io_free_req\n- 被调用者: 未明确\n\n3. 函数名: atomic_long_inc\n- 参数: [&tctx->req_complete]\n- 调用者: __io_free_req\n- 被调用者: 未明确\n\n4. 函数名: wake_up\n- 参数: [&tctx->wait]\n- 调用者: __io_free_req\n- 被调用者: 未明确\n\n5. 函数名: put_task_struct\n- 参数: [req->task]\n- 调用者: __io_free_req\n- 被调用者: 未明确\n\n6. 函数名: kmem_cache_free\n- 参数: [req_cachep, req]\n- 调用者: __io_free_req\n- 被调用者: 未明确\n\n7. 函数名: clear_bit_unlock\n- 参数: [0, (unsigned long *) &ctx->fallback_req]\n- 调用者: __io_free_req\n- 被调用者: 未明确\n\n8. 函数名: percpu_ref_put\n- 参数: [&ctx->refs]\n- 调用者: __io_free_req\n- 被调用者: 未明确"
    },
    {
        "id": 3819,
        "cwe": "CWE-416",
        "cve": "CVE-2023-0240",
        "purpose": "Code purpose:\"\"\"初始化io_uring请求并设置相关属性，包括操作码、用户数据、文件描述符等，同时处理身份验证和权限检查\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_prep_async_work函数中错误假设io_grab_identity调用总会成功，导致可能使用init_cred或之前请求的身份而非当前身份，引发引用计数问题和使用后释放漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_init_req\n- 参数: [ctx, req, sqe, state]\n- 调用者: N/A (top-level function)\n- 被调用者: [READ_ONCE, refcount_set, io_sq_thread_acquire_mm, io_check_restriction, io_req_init_async, idr_find, get_cred, io_req_set_file]\n\n2. 函数名: READ_ONCE\n- 参数: [variable]\n- 调用者: io_init_req\n- 被调用者: []\n\n3. 函数名: refcount_set\n- 参数: [ref, value]\n- 调用者: io_init_req\n- 被调用者: []\n\n4. 函数名: io_sq_thread_acquire_mm\n- 参数: [ctx, req]\n- 调用者: io_init_req\n- 被调用者: []\n\n5. 函数名: io_check_restriction\n- 参数: [ctx, req, sqe_flags]\n- 调用者: io_init_req\n- 被调用者: []\n\n6. 函数名: io_req_init_async\n- 参数: [req]\n- 调用者: io_init_req\n- 被调用者: []\n\n7. 函数名: idr_find\n- 参数: [idr, id]\n- 调用者: io_init_req\n- 被调用者: []\n\n8. 函数名: get_cred\n- 参数: [cred]\n- 调用者: io_init_req\n- 被调用者: []\n\n9. 函数名: io_req_set_file\n- 参数: [state, req, fd]\n- 调用者: io_init_req\n- 被调用者: []"
    },
    {
        "id": 3820,
        "cwe": "CWE-416",
        "cve": "CVE-2023-0240",
        "purpose": "Code purpose:\"\"\"清理io_uring请求中的工作项资源，包括内存管理、块控制组、凭证和文件系统等相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_prep_async_work函数中错误假设io_grab_identity调用总会成功，导致可能使用错误的身份信息进行操作，引发引用计数问题和使用后释放漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_req_clean_work\n- 参数: [struct io_kiocb *req]\n- 调用者: 未明确（可能是io_uring相关调用链）\n- 被调用者: [mmdrop, css_put, put_cred, spin_lock, spin_unlock, free_fs_struct]\n\n2. 函数名: mmdrop\n- 参数: [req->work.identity->mm]\n- 调用者: io_req_clean_work\n- 被调用者: []\n\n3. 函数名: css_put\n- 参数: [req->work.identity->blkcg_css]\n- 调用者: io_req_clean_work\n- 被调用者: []\n\n4. 函数名: put_cred\n- 参数: [req->work.identity->creds]\n- 调用者: io_req_clean_work\n- 被调用者: []\n\n5. 函数名: spin_lock\n- 参数: [&req->work.identity->fs->lock]\n- 调用者: io_req_clean_work\n- 被调用者: []\n\n6. 函数名: spin_unlock\n- 参数: [&req->work.identity->fs->lock]\n- 调用者: io_req_clean_work\n- 被调用者: []\n\n7. 函数名: free_fs_struct\n- 参数: [fs]\n- 调用者: io_req_clean_work\n- 被调用者: []"
    },
    {
        "id": 3821,
        "cwe": "CWE-416",
        "cve": "CVE-2023-0266",
        "purpose": "Code purpose:\"\"\"该代码实现了ALSA控制元素读取功能，用于从声卡设备读取控制元素的值并进行验证处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ALSA PCM包中，SNDRV_CTL_IOCTL_ELEM_{READ|WRITE}32操作缺少必要的锁保护，导致存在释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_ctl_elem_read\n- 参数: [struct snd_card *card, struct snd_ctl_elem_value *control]\n- 调用者: 未明确（由系统调用触发）\n- 被调用者: [snd_ctl_find_id, snd_ctl_get_ioff, snd_ctl_build_ioff, __snd_ctl_elem_info, snd_ctl_skip_validation, fill_remaining_elem_value, snd_power_ref_and_wait, snd_power_unref, sanity_check_elem_value]\n\n2. 函数名: snd_ctl_find_id\n- 参数: [struct snd_card *card, &control->id]\n- 调用者: snd_ctl_elem_read\n- 被调用者: 未明确\n\n3. 函数名: snd_ctl_get_ioff\n- 参数: [kctl, &control->id]\n- 调用者: snd_ctl_elem_read\n- 被调用者: 未明确\n\n4. 函数名: snd_ctl_build_ioff\n- 参数: [&control->id, kctl, index_offset]\n- 调用者: snd_ctl_elem_read\n- 被调用者: 未明确\n\n5. 函数名: __snd_ctl_elem_info\n- 参数: [card, kctl, &info, NULL]\n- 调用者: snd_ctl_elem_read\n- 被调用者: 未明确\n\n6. 函数名: snd_ctl_skip_validation\n- 参数: [&info]\n- 调用者: snd_ctl_elem_read\n- 被调用者: 未明确\n\n7. 函数名: fill_remaining_elem_value\n- 参数: [control, &info, pattern]\n- 调用者: snd_ctl_elem_read\n- 被调用者: 未明确\n\n8. 函数名: snd_power_ref_and_wait\n- 参数: [card]\n- 调用者: snd_ctl_elem_read\n- 被调用者: 未明确\n\n9. 函数名: snd_power_unref\n- 参数: [card]\n- 调用者: snd_ctl_elem_read\n- 被调用者: 未明确\n\n10. 函数名: sanity_check_elem_value\n- 参数: [card, control, &info, pattern]\n- 调用者: snd_ctl_elem_read\n- 被调用者: 未明确"
    },
    {
        "id": 3822,
        "cwe": "CWE-416",
        "cve": "CVE-2023-0266",
        "purpose": "Code purpose:\"\"\"该代码实现了从用户空间读取ALSA控制元素值的功能，并将结果拷贝回用户空间。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺少适当的锁保护，在SNDRV_CTL_IOCTL_ELEM_READ32操作中可能导致控制元素在释放后被继续使用，造成释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_ctl_elem_read_user\n- 参数: [struct snd_card *card, struct snd_ctl_elem_value __user *_control]\n- 调用者: 未指定（系统调用或驱动接口）\n- 被调用者: [memdup_user, IS_ERR, PTR_ERR, down_read, snd_ctl_elem_read, up_read, copy_to_user, kfree]\n\n2. 函数名: memdup_user\n- 参数: [struct snd_ctl_elem_value __user *_control, size_t sizeof(*control)]\n- 调用者: snd_ctl_elem_read_user\n- 被调用者: 未指定（内核内存分配函数）\n\n3. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: snd_ctl_elem_read_user\n- 被调用者: 未指定（内核错误检查宏）\n\n4. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: snd_ctl_elem_read_user\n- 被调用者: 未指定（内核错误转换宏）\n\n5. 函数名: down_read\n- 参数: [struct rw_semaphore *card->controls_rwsem]\n- 调用者: snd_ctl_elem_read_user\n- 被调用者: 未指定（内核读锁函数）\n\n6. 函数名: snd_ctl_elem_read\n- 参数: [struct snd_card *card, struct snd_ctl_elem_value *control]\n- 调用者: snd_ctl_elem_read_user\n- 被调用者: 未指定（ALSA控制元素读取函数）\n\n7. 函数名: up_read\n- 参数: [struct rw_semaphore *card->controls_rwsem]\n- 调用者: snd_ctl_elem_read_user\n- 被调用者: 未指定（内核读锁释放函数）\n\n8. 函数名: copy_to_user\n- 参数: [struct snd_ctl_elem_value __user *_control, struct snd_ctl_elem_value *control, size_t sizeof(*control)]\n- 调用者: snd_ctl_elem_read_user\n- 被调用者: 未指定（内核到用户空间拷贝函数）\n\n9. 函数名: kfree\n- 参数: [const void *control]\n- 调用者: snd_ctl_elem_read_user\n- 被调用者: 未指定（内核内存释放函数）"
    },
    {
        "id": 3828,
        "cwe": "CWE-416",
        "cve": "CVE-2023-0461",
        "purpose": "Code purpose:\"\"\"该代码片段实现了Linux内核中inet_csk_listen_start函数，用于初始化TCP监听套接字并处理端口绑定等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_TLS时，TCP socket断开连接后重用作监听器时未清除tls上下文，导致新创建的socket继承该上下文从而引发use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: inet_csk_listen_start\n- 参数: [struct sock *sk]\n- 调用者: 不适用（顶级函数）\n- 被调用者: [inet_csk, inet_sk, reqsk_queue_alloc, inet_csk_delack_init, READ_ONCE, sock_net, inet_sk_state_store, htons, sk_dst_reset, inet_sk_set_state]\n\n2. 函数名: inet_csk\n- 参数: [struct sock *sk]\n- 调用者: inet_csk_listen_start\n- 被调用者: []\n\n3. 函数名: inet_sk\n- 参数: [struct sock *sk]\n- 调用者: inet_csk_listen_start\n- 被调用者: []\n\n4. 函数名: reqsk_queue_alloc\n- 参数: [&icsk->icsk_accept_queue]\n- 调用者: inet_csk_listen_start\n- 被调用者: []\n\n5. 函数名: inet_csk_delack_init\n- 参数: [struct sock *sk]\n- 调用者: inet_csk_listen_start\n- 被调用者: []\n\n6. 函数名: READ_ONCE\n- 参数: [sock_net(sk)->core.sysctl_txrehash]\n- 调用者: inet_csk_listen_start\n- 被调用者: []\n\n7. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: inet_csk_listen_start\n- 被调用者: []\n\n8. 函数名: inet_sk_state_store\n- 参数: [struct sock *sk, TCP_LISTEN]\n- 调用者: inet_csk_listen_start\n- 被调用者: []\n\n9. 函数名: htons\n- 参数: [inet->inet_num]\n- 调用者: inet_csk_listen_start\n- 被调用者: []\n\n10. 函数名: sk_dst_reset\n- 参数: [struct sock *sk]\n- 调用者: inet_csk_listen_start\n- 被调用者: []\n\n11. 函数名: inet_sk_set_state\n- 参数: [struct sock *sk, TCP_CLOSE]\n- 调用者: inet_csk_listen_start\n- 被调用者: []"
    },
    {
        "id": 3829,
        "cwe": "CWE-416",
        "cve": "CVE-2023-0461",
        "purpose": "Code purpose:\"\"\"该代码用于设置TCP上层协议处理函数，但在清理和重用套接字时存在未正确清除上下文的问题，可能导致use-after-free漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当CONFIG_TLS启用时，TCP socket断开连接后未清除tls上下文，导致重用为监听器时新创建的socket会继承该上下文，从而引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: __tcp_set_ulp\n- 参数: [struct sock *sk, const struct tcp_ulp_ops *ulp_ops]\n- 调用者: 未明确显示（应为TCP_ULP操作相关调用）\n- 被调用者: [inet_csk, module_put, ulp_ops->init]\n\n2. 函数名: inet_csk\n- 参数: [struct sock *sk]\n- 调用者: __tcp_set_ulp\n- 被调用者: []\n\n3. 函数名: module_put\n- 参数: [ulp_ops->owner]\n- 调用者: __tcp_set_ulp\n- 被调用者: []\n\n4. 函数名: ulp_ops->init\n- 参数: [struct sock *sk]\n- 调用者: __tcp_set_ulp\n- 被调用者: []"
    },
    {
        "id": 3830,
        "cwe": "CWE-416",
        "cve": "CVE-2023-0468",
        "purpose": "Code purpose:\"\"\"该代码用于检查和处理io_uring中的poll事件，包括事件状态检查、多事件处理和取消操作等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于io_poll_check_events函数中对poll_refs的原子操作存在竞态条件，可能导致引用计数错误从而引发释放后重用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_poll_check_events\n- 参数: [struct io_kiocb *req, bool *locked]\n- 调用者: 未明确（由io_uring子系统调用）\n- 被调用者: [atomic_read, WARN_ON_ONCE, vfs_poll, io_is_uring_fops, io_post_aux_cqe, io_req_set_res, io_poll_issue, atomic_sub_return]\n\n2. 函数名: atomic_read\n- 参数: [&req->poll_refs]\n- 调用者: io_poll_check_events\n- 被调用者: []\n\n3. 函数名: WARN_ON_ONCE\n- 参数: [!(v & IO_POLL_REF_MASK)]\n- 调用者: io_poll_check_events\n- 被调用者: []\n\n4. 函数名: vfs_poll\n- 参数: [req->file, &pt]\n- 调用者: io_poll_check_events\n- 被调用者: []\n\n5. 函数名: io_is_uring_fops\n- 参数: [req->file]\n- 调用者: io_poll_check_events\n- 被调用者: []\n\n6. 函数名: io_post_aux_cqe\n- 参数: [ctx, req->cqe.user_data, mask, IORING_CQE_F_MORE, false]\n- 调用者: io_poll_check_events\n- 被调用者: []\n\n7. 函数名: io_req_set_res\n- 参数: [req, mask, 0]\n- 调用者: io_poll_check_events\n- 被调用者: []\n\n8. 函数名: io_poll_issue\n- 参数: [req, locked]\n- 调用者: io_poll_check_events\n- 被调用者: []\n\n9. 函数名: atomic_sub_return\n- 参数: [v & IO_POLL_REF_MASK, &req->poll_refs]\n- 调用者: io_poll_check_events\n- 被调用者: []"
    },
    {
        "id": 3831,
        "cwe": "CWE-416",
        "cve": "CVE-2023-0468",
        "purpose": "Code purpose:\"\"\"该代码用于通过原子操作增加poll_refs引用计数并检查是否获得IO轮询所有权\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于io_poll_get_ownership函数中对poll_refs的原子递增操作存在竞态条件，可能导致引用计数错误从而引发释放后重用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_poll_get_ownership\n- 参数: [struct io_kiocb *req]\n- 调用者: 未明确（需上下文确定）\n- 被调用者: [atomic_fetch_inc]"
    },
    {
        "id": 3832,
        "cwe": "CWE-416",
        "cve": "CVE-2023-0469",
        "purpose": "Code purpose:\"\"\"在io_uring中安装固定文件描述符到指定槽位，并处理可能的资源切换和清理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在清理调用过程中，由于未正确处理文件指针的释放顺序，导致在io_install_fixed_file函数中可能发生释放后重用(use-after-free)的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: io_install_fixed_file\n- 参数: [ctx, file, slot_index]\n- 调用者: N/A (顶级函数)\n- 被调用者: [io_is_uring_fops, array_index_nospec, io_fixed_file_slot, io_rsrc_node_switch_start, io_queue_rsrc_removal, io_file_bitmap_clear, io_scm_file_account, io_get_tag_slot, io_fixed_file_set, io_file_bitmap_set, io_rsrc_node_switch, fput]\n\n2. 函数名: io_is_uring_fops\n- 参数: [file]\n- 调用者: io_install_fixed_file\n- 被调用者: []\n\n3. 函数名: array_index_nospec\n- 参数: [slot_index, ctx->nr_user_files]\n- 调用者: io_install_fixed_file\n- 被调用者: []\n\n4. 函数名: io_fixed_file_slot\n- 参数: [&ctx->file_table, slot_index]\n- 调用者: io_install_fixed_file\n- 被调用者: []\n\n5. 函数名: io_rsrc_node_switch_start\n- 参数: [ctx]\n- 调用者: io_install_fixed_file\n- 被调用者: []\n\n6. 函数名: io_queue_rsrc_removal\n- 参数: [ctx->file_data, slot_index, ctx->rsrc_node, old_file]\n- 调用者: io_install_fixed_file\n- 被调用者: []\n\n7. 函数名: io_file_bitmap_clear\n- 参数: [&ctx->file_table, slot_index]\n- 调用者: io_install_fixed_file\n- 被调用者: []\n\n8. 函数名: io_scm_file_account\n- 参数: [ctx, file]\n- 调用者: io_install_fixed_file\n- 被调用者: []\n\n9. 函数名: io_get_tag_slot\n- 参数: [ctx->file_data, slot_index]\n- 调用者: io_install_fixed_file\n- 被调用者: []\n\n10. 函数名: io_fixed_file_set\n- 参数: [file_slot, file]\n- 调用者: io_install_fixed_file\n- 被调用者: []\n\n11. 函数名: io_file_bitmap_set\n- 参数: [&ctx->file_table, slot_index]\n- 调用者: io_install_fixed_file\n- 被调用者: []\n\n12. 函数名: io_rsrc_node_switch\n- 参数: [ctx, ctx->file_data]\n- 调用者: io_install_fixed_file\n- 被调用者: []\n\n13. 函数名: fput\n- 参数: [file]\n- 调用者: io_install_fixed_file\n- 被调用者: []"
    },
    {
        "id": 3846,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1079",
        "purpose": "Code purpose:\"\"\"通过LED控制器设置华硕键盘背光亮度，并在亮度改变时调度工作队列\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在设备断开连接时，LED控制器仍可能调度work_struct，导致对已释放的asus_kbd_leds结构体产生释放后使用(UAF)问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: asus_kbd_backlight_set\n- 参数: [led_cdev, brightness]\n- 调用者: 未明确（由LED子系统调用）\n- 被调用者: [container_of, spin_lock_irqsave, spin_unlock_irqrestore, schedule_work]\n\n2. 函数名: container_of\n- 参数: [未明确（宏参数）]\n- 调用者: asus_kbd_backlight_set\n- 被调用者: []\n\n3. 函数名: spin_lock_irqsave\n- 参数: [&led->lock, flags]\n- 调用者: asus_kbd_backlight_set\n- 被调用者: []\n\n4. 函数名: spin_unlock_irqrestore\n- 参数: [&led->lock, flags]\n- 调用者: asus_kbd_backlight_set\n- 被调用者: []\n\n5. 函数名: schedule_work\n- 参数: [&led->work]\n- 调用者: asus_kbd_backlight_set\n- 被调用者: []"
    },
    {
        "id": 3847,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1079",
        "purpose": "Code purpose:\"\"\"该代码用于控制华硕键盘背光灯的亮度设置，通过USB设备通信实现亮度调节功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在设备断开连接时，LED控制器可能仍会调度work_struct，导致对已释放的asus_kbd_leds结构体产生use-after-free问题\"\"\"",
        "functions": "Functions:\n1. 函数名: asus_kbd_backlight_work\n- 参数: [struct work_struct *work]\n- 调用者: 内核工作队列机制\n- 被调用者: [container_of, spin_lock_irqsave, spin_unlock_irqrestore, asus_kbd_set_report, hid_err]\n\n2. 函数名: container_of\n- 参数: [work, struct asus_kbd_leds, work]\n- 调用者: asus_kbd_backlight_work\n- 被调用者: []\n\n3. 函数名: spin_lock_irqsave\n- 参数: [&led->lock, flags]\n- 调用者: asus_kbd_backlight_work\n- 被调用者: []\n\n4. 函数名: spin_unlock_irqrestore\n- 参数: [&led->lock, flags]\n- 调用者: asus_kbd_backlight_work\n- 被调用者: []\n\n5. 函数名: asus_kbd_set_report\n- 参数: [led->hdev, buf, sizeof(buf)]\n- 调用者: asus_kbd_backlight_work\n- 被调用者: []\n\n6. 函数名: hid_err\n- 参数: [led->hdev, \"Asus failed to set keyboard backlight: %d\\n\", ret]\n- 调用者: asus_kbd_backlight_work\n- 被调用者: []"
    },
    {
        "id": 3849,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1118",
        "purpose": "Code purpose:\"\"\"该代码用于在移除PNP设备时清理相关资源，包括禁用接收、释放硬件缓冲区、注销设备及内存。\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放设备内存(kfree(dev))后，仍可能通过中断处理程序访问已释放的dev结构体，导致释放后使用(UAF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ene_remove\n- 参数: [struct pnp_dev *pnp_dev]\n- 调用者: 无（由系统调用）\n- 被调用者: [pnp_get_drvdata, spin_lock_irqsave, ene_rx_disable, ene_rx_restore_hw_buffer, spin_unlock_irqrestore, free_irq, release_region, rc_unregister_device, kfree]\n\n2. 函数名: pnp_get_drvdata\n- 参数: [struct pnp_dev *pnp_dev]\n- 调用者: ene_remove\n- 被调用者: 无\n\n3. 函数名: spin_lock_irqsave\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: ene_remove\n- 被调用者: 无\n\n4. 函数名: ene_rx_disable\n- 参数: [struct ene_device *dev]\n- 调用者: ene_remove\n- 被调用者: 无\n\n5. 函数名: ene_rx_restore_hw_buffer\n- 参数: [struct ene_device *dev]\n- 调用者: ene_remove\n- 被调用者: 无\n\n6. 函数名: spin_unlock_irqrestore\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: ene_remove\n- 被调用者: 无\n\n7. 函数名: free_irq\n- 参数: [unsigned int irq, void *dev_id]\n- 调用者: ene_remove\n- 被调用者: 无\n\n8. 函数名: release_region\n- 参数: [resource_size_t start, resource_size_t n]\n- 调用者: ene_remove\n- 被调用者: 无\n\n9. 函数名: rc_unregister_device\n- 参数: [struct rc_dev *dev]\n- 调用者: ene_remove\n- 被调用者: 无\n\n10. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: ene_remove\n- 被调用者: 无"
    },
    {
        "id": 3850,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1192",
        "purpose": "Code purpose:\"\"\"该代码片段实现了NTFS文件系统中读取MFT（主文件表）记录并初始化对应inode结构的功能，包括处理各种文件属性、设置文件权限和模式等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在CIFS传输响应数据到系统调用后，仍有局部变量指向该内存区域，当系统调用释放内存速度快于CIFS使用时，导致访问已释放内存区域引发拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: ntfs_read_mft\n- 参数: [struct inode *inode, const struct cpu_str *name, const struct MFT_REF *ref]\n- 调用者: N/A (顶层函数)\n- 被调用者: [ntfs_i, mi_init, run_add_entry, mi_read, is_rec_inuse, is_rec_base, ni_enum_attr_ex, ntfs_load_attr_list, ntfs_cmp_names_cpu, is_attr_sparsed, is_attr_compressed, is_attr_encrypted, indx_init, ni_parse_reparse, run_close, ntfs_get_wsl_perm, run_unpack_ex, set_nlink, init_rwsem, init_special_inode, iget_failed]\n\n2. 函数名: ntfs_i\n- 参数: [struct inode *inode]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n3. 函数名: mi_init\n- 参数: [struct mft_inode *mi, struct ntfs_sb_info *sbi, unsigned long ino]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n4. 函数名: run_add_entry\n- 参数: [struct runs_tree *run, u64 vcn, u64 lcn, u64 len, bool is_mft]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n5. 函数名: mi_read\n- 参数: [struct mft_inode *mi, bool is_mft]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n6. 函数名: is_rec_inuse\n- 参数: [struct MFT_REC *rec]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n7. 函数名: is_rec_base\n- 参数: [struct MFT_REC *rec]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n8. 函数名: ni_enum_attr_ex\n- 参数: [struct ntfs_inode *ni, struct ATTRIB *attr, struct ATTR_LIST_ENTRY **le, struct ATTR_LIST_ENTRY *le_next]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n9. 函数名: ntfs_load_attr_list\n- 参数: [struct ntfs_inode *ni, struct ATTRIB *attr]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n10. 函数名: ntfs_cmp_names_cpu\n- 参数: [const struct cpu_str *uni1, struct le_str *uni2, const struct ntfs_sb_info *sbi, bool case_sensitive]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n11. 函数名: is_attr_sparsed\n- 参数: [struct ATTRIB *attr]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n12. 函数名: is_attr_compressed\n- 参数: [struct ATTRIB *attr]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n13. 函数名: is_attr_encrypted\n- 参数: [struct ATTRIB *attr]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n14. 函数名: indx_init\n- 参数: [struct ntfs_index *indx, struct ntfs_sb_info *sbi, struct ATTRIB *attr, struct mutex *mutex]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n15. 函数名: ni_parse_reparse\n- 参数: [struct ntfs_inode *ni, struct ATTRIB *attr, struct REPARSE_DATA_BUFFER *rp]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n16. 函数名: run_close\n- 参数: [struct runs_tree *run]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n17. 函数名: ntfs_get_wsl_perm\n- 参数: [struct inode *inode]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n18. 函数名: run_unpack_ex\n- 参数: [struct runs_tree *run, struct ntfs_sb_info *sbi, u64 ino, u64 vcn, u64 evcn, u64 svcn, u8 *run_buf, u32 run_size]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n19. 函数名: set_nlink\n- 参数: [struct inode *inode, unsigned int nlink]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n20. 函数名: init_rwsem\n- 参数: [struct rw_semaphore *sem]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n21. 函数名: init_special_inode\n- 参数: [struct inode *inode, umode_t mode, dev_t rdev]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n22. 函数名: iget_failed\n- 参数: [struct inode *inode]\n- 调用者: ntfs_read_mft\n- 被调用者: []"
    },
    {
        "id": 3851,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1193",
        "purpose": "Code purpose:\"\"\"该代码用于尝试从连接队列中出列ksmbd工作请求，并管理请求的运行状态和同步/异步队列\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放work结构体后仍可能被访问，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ksmbd_conn_try_dequeue_request\n- 参数: [struct ksmbd_work *work]\n- 调用者: 未明确（需查看完整代码上下文）\n- 被调用者: [list_empty, atomic_dec, spin_lock, list_del_init, spin_unlock, wake_up_all]"
    },
    {
        "id": 3852,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1193",
        "purpose": "Code purpose:\"\"\"将工作请求添加到连接队列中，处理SMB2非取消命令的同步请求\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ksmbd_conn_enqueue_request函数中，当work对象被释放后仍可能被访问，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ksmbd_conn_enqueue_request\n- 参数: [struct ksmbd_work *work]\n- 调用者: 未显示\n- 被调用者: [atomic_inc, spin_lock, list_add_tail, spin_unlock]\n\n2. 函数名: get_cmd_val\n- 参数: [struct ksmbd_work *work]\n- 调用者: ksmbd_conn_enqueue_request\n- 被调用者: 未显示\n\n3. 函数名: atomic_inc\n- 参数: [&conn->req_running]\n- 调用者: ksmbd_conn_enqueue_request\n- 被调用者: 未显示\n\n4. 函数名: spin_lock\n- 参数: [&conn->request_lock]\n- 调用者: ksmbd_conn_enqueue_request\n- 被调用者: 未显示\n\n5. 函数名: list_add_tail\n- 参数: [&work->request_entry, requests_queue]\n- 调用者: ksmbd_conn_enqueue_request\n- 被调用者: 未显示\n\n6. 函数名: spin_unlock\n- 参数: [&conn->request_lock]\n- 调用者: ksmbd_conn_enqueue_request\n- 被调用者: 未显示"
    },
    {
        "id": 3853,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1193",
        "purpose": "Code purpose:\"\"\"设置异步工作请求并将工作项添加到连接器的异步请求列表中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在setup_async_work函数中，当异步请求处理完成后，work结构体可能被释放但仍保留在async_requests链表中，导致后续访问时出现use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: setup_async_work\n- 参数: [struct ksmbd_work *work, void (*fn)(void **), void **arg]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [smb2_get_msg, ksmbd_acquire_async_msg_id, cpu_to_le64, ksmbd_debug, list_empty, spin_lock, list_add_tail, spin_unlock]\n\n2. 函数名: smb2_get_msg\n- 参数: [work->response_buf]\n- 调用者: setup_async_work\n- 被调用者: 未明确\n\n3. 函数名: ksmbd_acquire_async_msg_id\n- 参数: [&conn->async_ida]\n- 调用者: setup_async_work\n- 被调用者: 未明确\n\n4. 函数名: cpu_to_le64\n- 参数: [id]\n- 调用者: setup_async_work\n- 被调用者: 未明确\n\n5. 函数名: ksmbd_debug\n- 参数: [SMB, \"Send interim Response to inform async request id : %d\\n\", work->async_id]\n- 调用者: setup_async_work\n- 被调用者: 未明确\n\n6. 函数名: list_empty\n- 参数: [&work->async_request_entry]\n- 调用者: setup_async_work\n- 被调用者: 未明确\n\n7. 函数名: spin_lock\n- 参数: [&conn->request_lock]\n- 调用者: setup_async_work\n- 被调用者: 未明确\n\n8. 函数名: list_add_tail\n- 参数: [&work->async_request_entry, &conn->async_requests]\n- 调用者: setup_async_work\n- 被调用者: 未明确\n\n9. 函数名: spin_unlock\n- 参数: [&conn->request_lock]\n- 调用者: setup_async_work\n- 被调用者: 未明确"
    },
    {
        "id": 3854,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1193",
        "purpose": "Code purpose:\"\"\"初始化SMB2响应头并将请求头中的相关字段复制到响应头中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在setup_async_work函数中存在释放后重用(use-after-free)问题，当访问已释放的work结构体时导致系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: init_smb2_rsp_hdr\n- 参数: [struct ksmbd_work *work]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [smb2_get_msg, memset, cpu_to_be32, memcpy, ksmbd_release_id]\n\n2. 函数名: smb2_get_msg\n- 参数: [work->response_buf, work->request_buf]\n- 调用者: init_smb2_rsp_hdr\n- 被调用者: []\n\n3. 函数名: memset\n- 参数: [rsp_hdr, 0, sizeof(struct smb2_hdr) + 2]\n- 调用者: init_smb2_rsp_hdr\n- 被调用者: []\n\n4. 函数名: cpu_to_be32\n- 参数: [conn->vals->header_size]\n- 调用者: init_smb2_rsp_hdr\n- 被调用者: []\n\n5. 函数名: memcpy\n- 参数: [rsp_hdr->Signature, rcv_hdr->Signature, 16]\n- 调用者: init_smb2_rsp_hdr\n- 被调用者: []\n\n6. 函数名: ksmbd_release_id\n- 参数: [&conn->async_ida, work->async_id]\n- 调用者: init_smb2_rsp_hdr\n- 被调用者: []"
    },
    {
        "id": 3856,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1195",
        "purpose": "Code purpose:\"\"\"该代码用于释放CIFS TCP会话相关的资源，包括减少引用计数、取消延迟工作、释放加密机制、清理会话密钥和主机名等，并处理可能的重新连接情况。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放server->hostname指针后未将其置为NULL，导致后续可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: cifs_put_tcp_session\n- 参数: [struct TCP_Server_Info *server, int from_reconnect]\n- 调用者: 未明确显示（可能是外部调用）\n- 被调用者: [cifs_net_ns, put_net, list_del_init, CIFS_SERVER_IS_CHAN, cifs_put_tcp_session, cancel_delayed_work_sync, cancel_delayed_work, cifs_crypto_secmech_release, kfree_sensitive, kfree, xchg, send_sig]\n\n2. 函数名: cifs_net_ns\n- 参数: [struct TCP_Server_Info *server]\n- 调用者: cifs_put_tcp_session\n- 被调用者: []\n\n3. 函数名: put_net\n- 参数: [未明确显示]\n- 调用者: cifs_put_tcp_session\n- 被调用者: []\n\n4. 函数名: list_del_init\n- 参数: [struct list_head *entry]\n- 调用者: cifs_put_tcp_session\n- 被调用者: []\n\n5. 函数名: CIFS_SERVER_IS_CHAN\n- 参数: [struct TCP_Server_Info *server]\n- 调用者: cifs_put_tcp_session\n- 被调用者: []\n\n6. 函数名: cancel_delayed_work_sync\n- 参数: [struct delayed_work *work]\n- 调用者: cifs_put_tcp_session\n- 被调用者: []\n\n7. 函数名: cancel_delayed_work\n- 参数: [struct delayed_work *work]\n- 调用者: cifs_put_tcp_session\n- 被调用者: []\n\n8. 函数名: cifs_crypto_secmech_release\n- 参数: [struct TCP_Server_Info *server]\n- 调用者: cifs_put_tcp_session\n- 被调用者: []\n\n9. 函数名: kfree_sensitive\n- 参数: [void *ptr]\n- 调用者: cifs_put_tcp_session\n- 被调用者: []\n\n10. 函数名: kfree\n- 参数: [void *ptr]\n- 调用者: cifs_put_tcp_session\n- 被调用者: []\n\n11. 函数名: xchg\n- 参数: [void *ptr, void *new]\n- 调用者: cifs_put_tcp_session\n- 被调用者: []\n\n12. 函数名: send_sig\n- 参数: [int sig, struct task_struct *p, int priv]\n- 调用者: cifs_put_tcp_session\n- 被调用者: []"
    },
    {
        "id": 3858,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1249",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中生成核心转储文件，收集并填充进程状态、寄存器值、信号信息等数据到ELF格式的笔记中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核的核心转储子系统中，由于未正确应用补丁390031c94211，导致在处理文件描述符时存在释放后使用(UAF)漏洞，允许本地用户使系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: fill_note_info\n- 参数: [struct elfhdr *elf, int phdrs, struct elf_note_info *info, struct coredump_params *cprm]\n- 调用者: N/A\n- 被调用者: [elf_note_info_init, kzalloc, list_add, elf_dump_thread_status, memset, fill_prstatus, elf_core_copy_regs, fill_elf_header, fill_note, fill_psinfo, fill_siginfo_note, fill_auxv_note, fill_files_note, elf_core_copy_task_fpregs]\n\n2. 函数名: elf_note_info_init\n- 参数: [struct elf_note_info *info]\n- 调用者: fill_note_info\n- 被调用者: N/A\n\n3. 函数名: kzalloc\n- 参数: [sizeof(*ets), GFP_KERNEL]\n- 调用者: fill_note_info\n- 被调用者: N/A\n\n4. 函数名: list_add\n- 参数: [&ets->list, &info->thread_list]\n- 调用者: fill_note_info\n- 被调用者: N/A\n\n5. 函数名: elf_dump_thread_status\n- 参数: [cprm->siginfo->si_signo, ets]\n- 调用者: fill_note_info\n- 被调用者: N/A\n\n6. 函数名: memset\n- 参数: [info->prstatus, 0, sizeof(*info->prstatus)]\n- 调用者: fill_note_info\n- 被调用者: N/A\n\n7. 函数名: fill_prstatus\n- 参数: [&info->prstatus->common, current, cprm->siginfo->si_signo]\n- 调用者: fill_note_info\n- 被调用者: N/A\n\n8. 函数名: elf_core_copy_regs\n- 参数: [&info->prstatus->pr_reg, cprm->regs]\n- 调用者: fill_note_info\n- 被调用者: N/A\n\n9. 函数名: fill_elf_header\n- 参数: [elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS]\n- 调用者: fill_note_info\n- 被调用者: N/A\n\n10. 函数名: fill_note\n- 参数: [info->notes + 0, \"CORE\", NT_PRSTATUS, sizeof(*info->prstatus), info->prstatus]\n- 调用者: fill_note_info\n- 被调用者: N/A\n\n11. 函数名: fill_psinfo\n- 参数: [info->psinfo, current->group_leader, current->mm]\n- 调用者: fill_note_info\n- 被调用者: N/A\n\n12. 函数名: fill_siginfo_note\n- 参数: [info->notes + 2, &info->csigdata, cprm->siginfo]\n- 调用者: fill_note_info\n- 被调用者: N/A\n\n13. 函数名: fill_auxv_note\n- 参数: [info->notes + 3, current->mm]\n- 调用者: fill_note_info\n- 被调用者: N/A\n\n14. 函数名: fill_files_note\n- 参数: [info->notes + info->numnote]\n- 调用者: fill_note_info\n- 被调用者: N/A\n\n15. 函数名: elf_core_copy_task_fpregs\n- 参数: [current, cprm->regs, info->fpu]\n- 调用者: fill_note_info\n- 被调用者: N/A"
    },
    {
        "id": 3859,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1249",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核的核心转储功能，用于在进程崩溃时生成核心转储文件以便调试，同时处理了权限、路径安全性和资源限制等相关问题。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在核心转储子系统中存在释放后使用漏洞，当未应用补丁390031c94211时，本地用户可利用此漏洞导致系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: do_coredump\n- 参数: [const kernel_siginfo_t *siginfo]\n- 调用者: N/A (kernel core dump handler)\n- 被调用者: [__get_dumpable, prepare_creds, coredump_wait, override_creds, format_corename, kmalloc_array, call_usermodehelper_setup, call_usermodehelper_exec, kfree, do_unlinkat, getname_kernel, file_open_root, filp_open, file_inode, unshare_files, dump_interrupted, dump_vma_snapshot, file_start_write, file_end_write, kvfree, wait_for_dump_helpers, filp_close, atomic_dec, kfree, coredump_finish, revert_creds, put_cred]\n\n2. 函数名: __get_dumpable\n- 参数: [int mm_flags]\n- 调用者: do_coredump\n- 被调用者: []\n\n3. 函数名: prepare_creds\n- 参数: []\n- 调用者: do_coredump\n- 被调用者: []\n\n4. 函数名: coredump_wait\n- 参数: [int si_signo, struct core_state *core_state]\n- 调用者: do_coredump\n- 被调用者: []\n\n5. 函数名: override_creds\n- 参数: [const struct cred *cred]\n- 调用者: do_coredump\n- 被调用者: []\n\n6. 函数名: format_corename\n- 参数: [struct core_name *cn, struct coredump_params *cprm, size_t **argv, int *argc]\n- 调用者: do_coredump\n- 被调用者: []\n\n7. 函数名: kmalloc_array\n- 参数: [size_t n, size_t size, gfp_t flags]\n- 调用者: do_coredump\n- 被调用者: []\n\n8. 函数名: call_usermodehelper_setup\n- 参数: [char *path, char **argv, char **envp, gfp_t gfp_mask, int (*init)(struct subprocess_info *info, struct cred *new), void *data, struct coredump_params *cprm]\n- 调用者: do_coredump\n- 被调用者: []\n\n9. 函数名: call_usermodehelper_exec\n- 参数: [struct subprocess_info *sub_info, int wait]\n- 调用者: do_coredump\n- 被调用者: []\n\n10. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: do_coredump\n- 被调用者: []\n\n11. 函数名: do_unlinkat\n- 参数: [int dfd, struct filename *name]\n- 调用者: do_coredump\n- 被调用者: []\n\n12. 函数名: getname_kernel\n- 参数: [const char *filename]\n- 调用者: do_coredump\n- 被调用者: []\n\n13. 函数名: file_open_root\n- 参数: [struct path *root, const char *name, int flags, umode_t mode]\n- 调用者: do_coredump\n- 被调用者: []\n\n14. 函数名: filp_open\n- 参数: [const char *filename, int flags, umode_t mode]\n- 调用者: do_coredump\n- 被调用者: []\n\n15. 函数名: file_inode\n- 参数: [struct file *file]\n- 调用者: do_coredump\n- 被调用者: []\n\n16. 函数名: unshare_files\n- 参数: []\n- 调用者: do_coredump\n- 被调用者: []\n\n17. 函数名: dump_interrupted\n- 参数: []\n- 调用者: do_coredump\n- 被调用者: []\n\n18. 函数名: dump_vma_snapshot\n- 参数: [struct coredump_params *cprm]\n- 调用者: do_coredump\n- 被调用者: []\n\n19. 函数名: file_start_write\n- 参数: [struct file *file]\n- 调用者: do_coredump\n- 被调用者: []\n\n20. 函数名: file_end_write\n- 参数: [struct file *file]\n- 调用者: do_coredump\n- 被调用者: []\n\n21. 函数名: kvfree\n- 参数: [const void *addr]\n- 调用者: do_coredump\n- 被调用者: []\n\n22. 函数名: wait_for_dump_helpers\n- 参数: [struct file *file]\n- 调用者: do_coredump\n- 被调用者: []\n\n23. 函数名: filp_close\n- 参数: [struct file *filp, fl_owner_t id]\n- 调用者: do_coredump\n- 被调用者: []\n\n24. 函数名: atomic_dec\n- 参数: [atomic_t *v]\n- 调用者: do_coredump\n- 被调用者: []\n\n25. 函数名: coredump_finish\n- 参数: [bool core_dumped]\n- 调用者: do_coredump\n- 被调用者: []\n\n26. 函数名: revert_creds\n- 参数: [const struct cred *old_cred]\n- 调用者: do_coredump\n- 被调用者: []\n\n27. 函数名: put_cred\n- 参数: [const struct cred *cred]\n- 调用者: do_coredump\n- 被调用者: []"
    },
    {
        "id": 3860,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1249",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中生成核心转储时，对进程的内存区域(VMA)进行快照并计算需要转储的数据大小\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在核心转储子系统中，由于在释放内存映射锁后继续访问可能已被释放的VMA结构，导致了use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: dump_vma_snapshot\n- 参数: [struct coredump_params *cprm]\n- 调用者: 未明确（可能是核心转储相关函数）\n- 被调用者: [mmap_write_lock_killable, get_gate_vma, kvmalloc_array, mmap_write_unlock, first_vma, next_vma, vma_dump_size, copy_from_user, memcmp]\n\n2. 函数名: mmap_write_lock_killable\n- 参数: [struct mm_struct *mm]\n- 调用者: dump_vma_snapshot\n- 被调用者: []\n\n3. 函数名: get_gate_vma\n- 参数: [struct mm_struct *mm]\n- 调用者: dump_vma_snapshot\n- 被调用者: []\n\n4. 函数名: kvmalloc_array\n- 参数: [size_t n, size_t size, gfp_t flags]\n- 调用者: dump_vma_snapshot\n- 被调用者: []\n\n5. 函数名: mmap_write_unlock\n- 参数: [struct mm_struct *mm]\n- 调用者: dump_vma_snapshot\n- 被调用者: []\n\n6. 函数名: first_vma\n- 参数: [struct task_struct *task, struct vm_area_struct *gate_vma]\n- 调用者: dump_vma_snapshot\n- 被调用者: []\n\n7. 函数名: next_vma\n- 参数: [struct vm_area_struct *vma, struct vm_area_struct *gate_vma]\n- 调用者: dump_vma_snapshot\n- 被调用者: []\n\n8. 函数名: vma_dump_size\n- 参数: [struct vm_area_struct *vma, unsigned long mm_flags]\n- 调用者: dump_vma_snapshot\n- 被调用者: []\n\n9. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: dump_vma_snapshot\n- 被调用者: []\n\n10. 函数名: memcmp\n- 参数: [const void *s1, const void *s2, size_t n]\n- 调用者: dump_vma_snapshot\n- 被调用者: []"
    },
    {
        "id": 3861,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1281",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核流量控制索引过滤器(tcindex)的参数设置功能，包括处理网络包的分类和过滤规则，并管理相关的内存分配和释放操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在tcindex过滤器的非完美哈希区域更新时，未正确处理正在遍历的数据包，导致在调用tcf_exts_exec()时可能使用已被释放的tcf_ext，从而引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: tcindex_set_parms\n- 参数: [struct net *net, struct tcf_proto *tp, unsigned long base, u32 handle, struct tcindex_data *p, struct tcindex_filter_result *r, struct nlattr **tb, struct nlattr *est, u32 flags, struct netlink_ext_ack *extack]\n- 调用者: N/A (top-level function)\n- 被调用者: [tcf_exts_init, tcf_exts_validate, kzalloc, refcount_set, nla_get_u32, nla_get_u16, tcindex_alloc_perfect_hash, min, tcindex_filter_result_init, valid_perfect_hash, tcf_bind_filter, tcf_exts_change, rcu_assign_pointer, rtnl_dereference, tcf_queue_work, tcindex_free_perfect_hash, kfree, tcf_exts_destroy, tcindex_lookup]\n\n2. 函数名: tcf_exts_init\n- 参数: [struct tcf_exts *e, struct net *net, int act, int police]\n- 调用者: tcindex_set_parms\n- 被调用者: []\n\n3. 函数名: tcf_exts_validate\n- 参数: [struct net *net, struct tcf_proto *tp, struct nlattr **tb, struct nlattr *est, struct tcf_exts *e, u32 flags, struct netlink_ext_ack *extack]\n- 调用者: tcindex_set_parms\n- 被调用者: []\n\n4. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: tcindex_set_parms\n- 被调用者: []\n\n5. 函数名: refcount_set\n- 参数: [refcount_t *r, int n]\n- 调用者: tcindex_set_parms\n- 被调用者: []\n\n6. 函数名: nla_get_u32\n- 参数: [struct nlattr *nla]\n- 调用者: tcindex_set_parms\n- 被调用者: []\n\n7. 函数名: nla_get_u16\n- 参数: [struct nlattr *nla]\n- 调用者: tcindex_set_parms\n- 被调用者: []\n\n8. 函数名: tcindex_alloc_perfect_hash\n- 参数: [struct net *net, struct tcindex_data *cp]\n- 调用者: tcindex_set_parms\n- 被调用者: []\n\n9. 函数名: min\n- 参数: [int a, int b]\n- 调用者: tcindex_set_parms\n- 被调用者: []\n\n10. 函数名: tcindex_filter_result_init\n- 参数: [struct tcindex_filter_result *r, struct tcindex_data *cp, struct net *net]\n- 调用者: tcindex_set_parms\n- 被调用者: []\n\n11. 函数名: valid_perfect_hash\n- 参数: [struct tcindex_data *cp]\n- 调用者: tcindex_set_parms\n- 被调用者: []\n\n12. 函数名: tcf_bind_filter\n- 参数: [struct tcf_proto *tp, struct tcf_result *r, unsigned long base]\n- 调用者: tcindex_set_parms\n- 被调用者: []\n\n13. 函数名: tcf_exts_change\n- 参数: [struct tcf_exts *dst, struct tcf_exts *src]\n- 调用者: tcindex_set_parms\n- 被调用者: []\n\n14. 函数名: rcu_assign_pointer\n- 参数: [type *p, type v]\n- 调用者: tcindex_set_parms\n- 被调用者: []\n\n15. 函数名: rtnl_dereference\n- 参数: [type *p]\n- 调用者: tcindex_set_parms\n- 被调用者: []\n\n16. 函数名: tcf_queue_work\n- 参数: [struct work_struct *work, work_func_t func]\n- 调用者: tcindex_set_parms\n- 被调用者: []\n\n17. 函数名: tcindex_free_perfect_hash\n- 参数: [struct tcindex_data *cp]\n- 调用者: tcindex_set_parms\n- 被调用者: []\n\n18. 函数名: kfree\n- 参数: [const void *x]\n- 调用者: tcindex_set_parms\n- 被调用者: []\n\n19. 函数名: tcf_exts_destroy\n- 参数: [struct tcf_exts *exts]\n- 调用者: tcindex_set_parms\n- 被调用者: []\n\n20. 函数名: tcindex_lookup\n- 参数: [struct tcindex_data *cp, u32 handle]\n- 调用者: tcindex_set_parms\n- 被调用者: []"
    },
    {
        "id": 3874,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1611",
        "purpose": "Code purpose:\"\"\"该代码实现了Btrfs文件系统中通过ioctl接口进行qgroup(配额组)关系分配或删除的功能，需要管理员权限并处理相关事务操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在btrfs_ioctl_qgroup_assign函数中，由于未能正确处理事务结束后的内存释放，导致存在释放后使用(use-after-free)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: btrfs_ioctl_qgroup_assign\n- 参数: [struct file *file, void __user *arg]\n- 调用者: 未显示（系统调用或内核其他部分）\n- 被调用者: [file_inode, btrfs_sb, BTRFS_I, capable, mnt_want_write_file, memdup_user, btrfs_join_transaction, btrfs_add_qgroup_relation, btrfs_del_qgroup_relation, btrfs_run_qgroups, btrfs_handle_fs_error, btrfs_end_transaction, kfree, mnt_drop_write_file]\n\n2. 函数名: file_inode\n- 参数: [struct file *file]\n- 调用者: btrfs_ioctl_qgroup_assign\n- 被调用者: []\n\n3. 函数名: btrfs_sb\n- 参数: [struct super_block *sb]\n- 调用者: btrfs_ioctl_qgroup_assign\n- 被调用者: []\n\n4. 函数名: capable\n- 参数: [CAP_SYS_ADMIN]\n- 调用者: btrfs_ioctl_qgroup_assign\n- 被调用者: []\n\n5. 函数名: mnt_want_write_file\n- 参数: [struct file *file]\n- 调用者: btrfs_ioctl_qgroup_assign\n- 被调用者: []\n\n6. 函数名: memdup_user\n- 参数: [void __user *arg, size_t size]\n- 调用者: btrfs_ioctl_qgroup_assign\n- 被调用者: []\n\n7. 函数名: btrfs_join_transaction\n- 参数: [struct btrfs_root *root]\n- 调用者: btrfs_ioctl_qgroup_assign\n- 被调用者: []\n\n8. 函数名: btrfs_add_qgroup_relation\n- 参数: [struct btrfs_trans_handle *trans, u64 src, u64 dst]\n- 调用者: btrfs_ioctl_qgroup_assign\n- 被调用者: []\n\n9. 函数名: btrfs_del_qgroup_relation\n- 参数: [struct btrfs_trans_handle *trans, u64 src, u64 dst]\n- 调用者: btrfs_ioctl_qgroup_assign\n- 被调用者: []\n\n10. 函数名: btrfs_run_qgroups\n- 参数: [struct btrfs_trans_handle *trans]\n- 调用者: btrfs_ioctl_qgroup_assign\n- 被调用者: []\n\n11. 函数名: btrfs_handle_fs_error\n- 参数: [struct btrfs_fs_info *fs_info, int err, const char *fmt]\n- 调用者: btrfs_ioctl_qgroup_assign\n- 被调用者: []\n\n12. 函数名: btrfs_end_transaction\n- 参数: [struct btrfs_trans_handle *trans]\n- 调用者: btrfs_ioctl_qgroup_assign\n- 被调用者: []\n\n13. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: btrfs_ioctl_qgroup_assign\n- 被调用者: []\n\n14. 函数名: mnt_drop_write_file\n- 参数: [struct file *file]\n- 调用者: btrfs_ioctl_qgroup_assign\n- 被调用者: []"
    },
    {
        "id": 3875,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1611",
        "purpose": "Code purpose:\"\"\"该代码用于处理Btrfs文件系统中的配额组(qgroup)更新操作，包括更新配额组信息项、限制项和状态项，并在出现错误时标记配额组为不一致状态。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放qgroup锁后，对qgroup对象的后续操作可能导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: btrfs_run_qgroups\n- 参数: [struct btrfs_trans_handle *trans]\n- 调用者: N/A (top-level function)\n- 被调用者: [update_qgroup_info_item, qgroup_mark_inconsistent, update_qgroup_limit_item, update_qgroup_status_item]\n\n2. 函数名: update_qgroup_info_item\n- 参数: [struct btrfs_trans_handle *trans, struct btrfs_qgroup *qgroup]\n- 调用者: btrfs_run_qgroups\n- 被调用者: []\n\n3. 函数名: qgroup_mark_inconsistent\n- 参数: [struct btrfs_fs_info *fs_info]\n- 调用者: btrfs_run_qgroups\n- 被调用者: []\n\n4. 函数名: update_qgroup_limit_item\n- 参数: [struct btrfs_trans_handle *trans, struct btrfs_qgroup *qgroup]\n- 调用者: btrfs_run_qgroups\n- 被调用者: []\n\n5. 函数名: update_qgroup_status_item\n- 参数: [struct btrfs_trans_handle *trans]\n- 调用者: btrfs_run_qgroups\n- 被调用者: []"
    },
    {
        "id": 3877,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1652",
        "purpose": "Code purpose:\"\"\"该代码用于在NFS文件系统中处理客户端共享挂载请求，匹配或创建挂载项并管理其引用计数和忙状态。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放work内存后，代码可能通过goto try_again重新进入循环使用已释放的内存，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nfsd4_ssc_setup_dul\n- 参数: [nn, ipaddr, retwork, ss_mnt]\n- 调用者: 未显示\n- 被调用者: [kzalloc, strncmp, prepare_to_wait, spin_unlock, signal_pending, schedule_timeout, finish_wait, refcount_inc, kfree, strscpy, refcount_set, list_add_tail, spin_lock]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*work), GFP_KERNEL]\n- 调用者: nfsd4_ssc_setup_dul\n- 被调用者: 未显示\n\n3. 函数名: strncmp\n- 参数: [ni->nsui_ipaddr, ipaddr, sizeof(ni->nsui_ipaddr)]\n- 调用者: nfsd4_ssc_setup_dul\n- 被调用者: 未显示\n\n4. 函数名: prepare_to_wait\n- 参数: [&nn->nfsd_ssc_waitq, &wait, TASK_INTERRUPTIBLE]\n- 调用者: nfsd4_ssc_setup_dul\n- 被调用者: 未显示\n\n5. 函数名: spin_unlock\n- 参数: [&nn->nfsd_ssc_lock]\n- 调用者: nfsd4_ssc_setup_dul\n- 被调用者: 未显示\n\n6. 函数名: signal_pending\n- 参数: [current]\n- 调用者: nfsd4_ssc_setup_dul\n- 被调用者: 未显示\n\n7. 函数名: schedule_timeout\n- 参数: [20*HZ]\n- 调用者: nfsd4_ssc_setup_dul\n- 被调用者: 未显示\n\n8. 函数名: finish_wait\n- 参数: [&nn->nfsd_ssc_waitq, &wait]\n- 调用者: nfsd4_ssc_setup_dul\n- 被调用者: 未显示\n\n9. 函数名: refcount_inc\n- 参数: [&ni->nsui_refcnt]\n- 调用者: nfsd4_ssc_setup_dul\n- 被调用者: 未显示\n\n10. 函数名: kfree\n- 参数: [work]\n- 调用者: nfsd4_ssc_setup_dul\n- 被调用者: 未显示\n\n11. 函数名: strscpy\n- 参数: [work->nsui_ipaddr, ipaddr, sizeof(work->nsui_ipaddr) - 1]\n- 调用者: nfsd4_ssc_setup_dul\n- 被调用者: 未显示\n\n12. 函数名: refcount_set\n- 参数: [&work->nsui_refcnt, 2]\n- 调用者: nfsd4_ssc_setup_dul\n- 被调用者: 未显示\n\n13. 函数名: list_add_tail\n- 参数: [&work->nsui_list, &nn->nfsd_ssc_mount_list]\n- 调用者: nfsd4_ssc_setup_dul\n- 被调用者: 未显示\n\n14. 函数名: spin_lock\n- 参数: [&nn->nfsd_ssc_lock]\n- 调用者: nfsd4_ssc_setup_dul\n- 被调用者: 未显示"
    },
    {
        "id": 3878,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1670",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的Xircom 16位PCMCIA网卡驱动中实现设备分离时的资源释放和清理操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在xirc2ps_detach函数中，先释放了net_device结构体(通过free_netdev)，但后续可能仍被访问，导致释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: xirc2ps_detach\n- 参数: [struct pcmcia_device *link]\n- 调用者: 未显示（由PCMCIA子系统调用）\n- 被调用者: [dev_dbg, unregister_netdev, xirc2ps_release, free_netdev]\n\n2. 函数名: dev_dbg\n- 参数: [&link->dev, \"detach\\n\"]\n- 调用者: xirc2ps_detach\n- 被调用者: []\n\n3. 函数名: unregister_netdev\n- 参数: [dev]\n- 调用者: xirc2ps_detach\n- 被调用者: []\n\n4. 函数名: xirc2ps_release\n- 参数: [link]\n- 调用者: xirc2ps_detach\n- 被调用者: []\n\n5. 函数名: free_netdev\n- 参数: [dev]\n- 调用者: xirc2ps_detach\n- 被调用者: []"
    },
    {
        "id": 3879,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1838",
        "purpose": "Code purpose:\"\"\"该代码用于设置vhost网络设备的后端socket连接，包括验证权限、检查队列状态、分配资源以及处理新旧socket的切换。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在vhost_net_set_backend函数中存在对文件描述符的双重fget操作，导致引用计数管理不当，可能引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: vhost_net_set_backend\n- 参数: [struct vhost_net *n, unsigned index, int fd]\n- 调用者: N/A\n- 被调用者: [mutex_lock, vhost_dev_check_owner, vhost_vq_access_ok, get_socket, vhost_vq_get_backend, vhost_net_ubuf_alloc, vhost_sock_zcopy, vhost_net_disable_vq, vhost_vq_set_backend, vhost_net_buf_unproduce, vhost_vq_init_access, vhost_net_enable_vq, get_tap_ptr_ring, vhost_net_ubuf_put_wait_and_free, vhost_zerocopy_signal_used, vhost_net_flush_vq, sockfd_put, mutex_unlock]\n\n2. 函数名: mutex_lock\n- 参数: [struct mutex *]\n- 调用者: vhost_net_set_backend\n- 被调用者: N/A\n\n3. 函数名: vhost_dev_check_owner\n- 参数: [struct vhost_dev *]\n- 调用者: vhost_net_set_backend\n- 被调用者: N/A\n\n4. 函数名: vhost_vq_access_ok\n- 参数: [struct vhost_virtqueue *]\n- 调用者: vhost_net_set_backend\n- 被调用者: N/A\n\n5. 函数名: get_socket\n- 参数: [int fd]\n- 调用者: vhost_net_set_backend\n- 被调用者: N/A\n\n6. 函数名: vhost_vq_get_backend\n- 参数: [struct vhost_virtqueue *]\n- 调用者: vhost_net_set_backend\n- 被调用者: N/A\n\n7. 函数名: vhost_net_ubuf_alloc\n- 参数: [struct vhost_virtqueue *, bool]\n- 调用者: vhost_net_set_backend\n- 被调用者: N/A\n\n8. 函数名: vhost_sock_zcopy\n- 参数: [struct socket *]\n- 调用者: vhost_net_set_backend\n- 被调用者: N/A\n\n9. 函数名: vhost_net_disable_vq\n- 参数: [struct vhost_net *, struct vhost_virtqueue *]\n- 调用者: vhost_net_set_backend\n- 被调用者: N/A\n\n10. 函数名: vhost_vq_set_backend\n- 参数: [struct vhost_virtqueue *, struct socket *]\n- 调用者: vhost_net_set_backend\n- 被调用者: N/A\n\n11. 函数名: vhost_net_buf_unproduce\n- 参数: [struct vhost_net_virtqueue *]\n- 调用者: vhost_net_set_backend\n- 被调用者: N/A\n\n12. 函数名: vhost_vq_init_access\n- 参数: [struct vhost_virtqueue *]\n- 调用者: vhost_net_set_backend\n- 被调用者: N/A\n\n13. 函数名: vhost_net_enable_vq\n- 参数: [struct vhost_net *, struct vhost_virtqueue *]\n- 调用者: vhost_net_set_backend\n- 被调用者: N/A\n\n14. 函数名: get_tap_ptr_ring\n- 参数: [int fd]\n- 调用者: vhost_net_set_backend\n- 被调用者: N/A\n\n15. 函数名: vhost_net_ubuf_put_wait_and_free\n- 参数: [struct vhost_net_ubuf_ref *]\n- 调用者: vhost_net_set_backend\n- 被调用者: N/A\n\n16. 函数名: vhost_zerocopy_signal_used\n- 参数: [struct vhost_net *, struct vhost_virtqueue *]\n- 调用者: vhost_net_set_backend\n- 被调用者: N/A\n\n17. 函数名: vhost_net_flush_vq\n- 参数: [struct vhost_net *, unsigned index]\n- 调用者: vhost_net_set_backend\n- 被调用者: N/A\n\n18. 函数名: sockfd_put\n- 参数: [struct socket *]\n- 调用者: vhost_net_set_backend\n- 被调用者: N/A\n\n19. 函数名: mutex_unlock\n- 参数: [struct mutex *]\n- 调用者: vhost_net_set_backend\n- 被调用者: N/A"
    },
    {
        "id": 3880,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1855",
        "purpose": "Code purpose:\"\"\"该代码用于在硬件监控驱动移除时释放相关资源，包括注销硬件监控设备、释放异步消息FIFO以及根据ACPI状态释放邮箱通道。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在xgene_hwmon_remove函数中存在竞态条件，导致在释放资源后可能仍被访问，造成释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: xgene_hwmon_remove\n- 参数: [struct platform_device *pdev]\n- 调用者: platform driver core (implicit)\n- 被调用者: [platform_get_drvdata, hwmon_device_unregister, kfifo_free, mbox_free_channel, pcc_mbox_free_channel]\n\n2. 函数名: platform_get_drvdata\n- 参数: [struct platform_device *pdev]\n- 调用者: xgene_hwmon_remove\n- 被调用者: []\n\n3. 函数名: hwmon_device_unregister\n- 参数: [struct device *dev]\n- 调用者: xgene_hwmon_remove\n- 被调用者: []\n\n4. 函数名: kfifo_free\n- 参数: [struct kfifo *fifo]\n- 调用者: xgene_hwmon_remove\n- 被调用者: []\n\n5. 函数名: mbox_free_channel\n- 参数: [struct mbox_chan *chan]\n- 调用者: xgene_hwmon_remove\n- 被调用者: []\n\n6. 函数名: pcc_mbox_free_channel\n- 参数: [struct mbox_chan *chan]\n- 调用者: xgene_hwmon_remove\n- 被调用者: []"
    },
    {
        "id": 3881,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1859",
        "purpose": "Code purpose:\"\"\"释放Xen 9pfs前端驱动中分配的资源，包括中断处理、内存页和权限引用等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放xen_9pfs_front_priv结构体资源时存在竞态条件，导致在释放后仍可能被访问，造成释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: xen_9pfs_front_free\n- 参数: [struct xen_9pfs_front_priv *priv]\n- 调用者: 未显示\n- 被调用者: [write_lock, list_del, write_unlock, unbind_from_irqhandler, gnttab_end_foreign_access, free_pages_exact, free_page, kfree]\n\n2. 函数名: write_lock\n- 参数: [&xen_9pfs_lock]\n- 调用者: xen_9pfs_front_free\n- 被调用者: 未显示\n\n3. 函数名: list_del\n- 参数: [&priv->list]\n- 调用者: xen_9pfs_front_free\n- 被调用者: 未显示\n\n4. 函数名: write_unlock\n- 参数: [&xen_9pfs_lock]\n- 调用者: xen_9pfs_front_free\n- 被调用者: 未显示\n\n5. 函数名: unbind_from_irqhandler\n- 参数: [priv->rings[i].irq, priv->dev]\n- 调用者: xen_9pfs_front_free\n- 被调用者: 未显示\n\n6. 函数名: gnttab_end_foreign_access\n- 参数: [ref, NULL] 和 [priv->rings[i].ref, NULL]\n- 调用者: xen_9pfs_front_free\n- 被调用者: 未显示\n\n7. 函数名: free_pages_exact\n- 参数: [priv->rings[i].data.in, 1UL << (priv->rings[i].intf->ring_order + XEN_PAGE_SHIFT)]\n- 调用者: xen_9pfs_front_free\n- 被调用者: 未显示\n\n8. 函数名: free_page\n- 参数: [(unsigned long)priv->rings[i].intf]\n- 调用者: xen_9pfs_front_free\n- 被调用者: 未显示\n\n9. 函数名: kfree\n- 参数: [priv->rings], [priv->tag], [priv]\n- 调用者: xen_9pfs_front_free\n- 被调用者: 未显示"
    },
    {
        "id": 3882,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1872",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核io_uring子系统中文件数据拼接(splice)的功能，用于在两个文件描述符之间高效传输数据。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于io_file_get_fixed函数未使用ctx->uring_lock锁保护，导致在固定文件注销时存在竞态条件，可能引发释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_splice\n- 参数: [struct io_kiocb *req, unsigned int issue_flags]\n- 调用者: 未明确（应为io_uring系统调用相关代码）\n- 被调用者: [io_file_get, do_splice, io_put_file, req_set_fail, io_req_complete]\n\n2. 函数名: io_file_get\n- 参数: [struct io_ring_ctx *ctx, struct io_kiocb *req, int fd, unsigned int flags]\n- 调用者: io_splice\n- 被调用者: 未明确（可能涉及文件描述符获取相关操作）\n\n3. 函数名: do_splice\n- 参数: [struct file *in, loff_t *poff_in, struct file *out, loff_t *poff_out, size_t len, unsigned int flags]\n- 调用者: io_splice\n- 被调用者: 未明确（内核splice系统调用实现）\n\n4. 函数名: io_put_file\n- 参数: [struct file *file]\n- 调用者: io_splice\n- 被调用者: 未明确（可能涉及文件引用计数操作）\n\n5. 函数名: req_set_fail\n- 参数: [struct io_kiocb *req]\n- 调用者: io_splice\n- 被调用者: 未明确（可能设置请求失败状态）\n\n6. 函数名: io_req_complete\n- 参数: [struct io_kiocb *req, long res]\n- 调用者: io_splice\n- 被调用者: 未明确（可能完成请求处理）"
    },
    {
        "id": 3883,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1872",
        "purpose": "Code purpose:\"\"\"处理io_uring中的异步I/O请求，检查事件状态并根据结果提交或完成请求\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于io_file_get_fixed函数缺少ctx->uring_lock保护，导致在固定文件注销时出现竞态条件，从而引发释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: io_apoll_task_func\n- 参数: [req, locked]\n- 调用者: 未明确（由系统调用或内核其他部分调用）\n- 被调用者: [io_poll_check_events, io_poll_remove_entries, io_req_task_submit, io_req_complete_failed]\n\n2. 函数名: io_poll_check_events\n- 参数: [req]\n- 调用者: io_apoll_task_func\n- 被调用者: []\n\n3. 函数名: io_poll_remove_entries\n- 参数: [req]\n- 调用者: io_apoll_task_func\n- 被调用者: []\n\n4. 函数名: io_req_task_submit\n- 参数: [req, locked]\n- 调用者: io_apoll_task_func\n- 被调用者: []\n\n5. 函数名: io_req_complete_failed\n- 参数: [req, ret]\n- 调用者: io_apoll_task_func\n- 被调用者: []\n\n6. 函数名: hash_del\n- 参数: [&req->hash_node]\n- 调用者: io_apoll_task_func\n- 被调用者: []\n\n7. 函数名: spin_lock\n- 参数: [&ctx->completion_lock]\n- 调用者: io_apoll_task_func\n- 被调用者: []\n\n8. 函数名: spin_unlock\n- 参数: [&ctx->completion_lock]\n- 调用者: io_apoll_task_func\n- 被调用者: []"
    },
    {
        "id": 3884,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1872",
        "purpose": "Code purpose:\"\"\"处理io_uring中的轮询任务，检查事件并完成请求处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于io_file_get_fixed函数中缺少ctx->uring_lock的保护，导致在固定文件注销时存在竞态条件，从而引发释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_poll_task_func\n- 参数: [struct io_kiocb *req, bool *locked]\n- 调用者: 未明确（由系统调用或内核其他部分调用）\n- 被调用者: [io_poll_check_events, mangle_poll, req_set_fail, io_poll_remove_entries, hash_del, __io_req_complete_post, io_commit_cqring, io_cqring_ev_posted]\n\n2. 函数名: io_poll_check_events\n- 参数: [struct io_kiocb *req]\n- 调用者: io_poll_task_func\n- 被调用者: 未明确\n\n3. 函数名: mangle_poll\n- 参数: [req->result & req->poll.events]\n- 调用者: io_poll_task_func\n- 被调用者: 未明确\n\n4. 函数名: req_set_fail\n- 参数: [struct io_kiocb *req]\n- 调用者: io_poll_task_func\n- 被调用者: 未明确\n\n5. 函数名: io_poll_remove_entries\n- 参数: [struct io_kiocb *req]\n- 调用者: io_poll_task_func\n- 被调用者: 未明确\n\n6. 函数名: hash_del\n- 参数: [&req->hash_node]\n- 调用者: io_poll_task_func\n- 被调用者: 未明确\n\n7. 函数名: __io_req_complete_post\n- 参数: [struct io_kiocb *req, req->result, 0]\n- 调用者: io_poll_task_func\n- 被调用者: 未明确\n\n8. 函数名: io_commit_cqring\n- 参数: [struct io_ring_ctx *ctx]\n- 调用者: io_poll_task_func\n- 被调用者: 未明确\n\n9. 函数名: io_cqring_ev_posted\n- 参数: [struct io_ring_ctx *ctx]\n- 调用者: io_poll_task_func\n- 被调用者: 未明确"
    },
    {
        "id": 3885,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1872",
        "purpose": "Code purpose:\"\"\"该代码片段实现了Linux内核中io_uring子系统对I/O向量(iovec)的导入功能，用于处理不同类型的I/O操作请求，包括固定缓冲区读写和缓冲区选择等场景。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核io_uring系统中io_file_get_fixed函数缺少ctx->uring_lock保护，导致固定文件注销时出现竞态条件引发释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: __io_import_iovec\n- 参数: [rw, req, s, issue_flags]\n- 调用者: N/A (顶级函数)\n- 被调用者: [io_import_fixed, ERR_PTR, io_rw_buffer_select, IS_ERR, ERR_CAST, import_single_range, io_iov_buffer_select, iov_iter_init, __import_iovec]\n\n2. 函数名: io_import_fixed\n- 参数: [req, rw, iter]\n- 调用者: __io_import_iovec\n- 被调用者: N/A\n\n3. 函数名: io_rw_buffer_select\n- 参数: [req, sqe_len, issue_flags]\n- 调用者: __io_import_iovec\n- 被调用者: N/A\n\n4. 函数名: import_single_range\n- 参数: [rw, buf, sqe_len, s->fast_iov, iter]\n- 调用者: __io_import_iovec\n- 被调用者: N/A\n\n5. 函数名: io_iov_buffer_select\n- 参数: [req, iovec, issue_flags]\n- 调用者: __io_import_iovec\n- 被调用者: N/A\n\n6. 函数名: iov_iter_init\n- 参数: [iter, rw, iovec, 1, iovec->iov_len]\n- 调用者: __io_import_iovec\n- 被调用者: N/A\n\n7. 函数名: __import_iovec\n- 参数: [rw, buf, sqe_len, UIO_FASTIOV, &iovec, iter, req->ctx->compat]\n- 调用者: __io_import_iovec\n- 被调用者: N/A\n\n8. 函数名: ERR_PTR\n- 参数: [ret/-EINVAL]\n- 调用者: __io_import_iovec\n- 被调用者: N/A\n\n9. 函数名: IS_ERR\n- 参数: [buf]\n- 调用者: __io_import_iovec\n- 被调用者: N/A\n\n10. 函数名: ERR_CAST\n- 参数: [buf]\n- 调用者: __io_import_iovec\n- 被调用者: N/A"
    },
    {
        "id": 3886,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1872",
        "purpose": "Code purpose:\"\"\"该代码实现了io_uring系统中io_tee操作，用于在两个文件描述符之间进行数据零拷贝传输\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于io_file_get_fixed函数未使用ctx->uring_lock锁保护，导致在固定文件注销时存在竞态条件，从而引发释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_tee\n- 参数: [req, issue_flags]\n- 调用者: 未明确（由io_uring系统调用）\n- 被调用者: [io_file_get, do_tee, io_put_file, req_set_fail, io_req_complete]\n\n2. 函数名: io_file_get\n- 参数: [ctx, req, splice_fd_in, flags]\n- 调用者: io_tee\n- 被调用者: 未明确\n\n3. 函数名: do_tee\n- 参数: [in, out, len, flags]\n- 调用者: io_tee\n- 被调用者: 未明确\n\n4. 函数名: io_put_file\n- 参数: [in]\n- 调用者: io_tee\n- 被调用者: 未明确\n\n5. 函数名: req_set_fail\n- 参数: [req]\n- 调用者: io_tee\n- 被调用者: 未明确\n\n6. 函数名: io_req_complete\n- 参数: [req, ret]\n- 调用者: io_tee\n- 被调用者: 未明确"
    },
    {
        "id": 3887,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1872",
        "purpose": "Code purpose:\"\"\"初始化io_uring请求并处理相关标志和文件描述符，为后续IO操作做准备\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"io_file_get_fixed函数中缺少ctx->uring_lock的保护，导致在固定文件注销时可能发生竞态条件，从而引发释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_init_req\n- 参数: [ctx, req, sqe]\n- 调用者: N/A (顶级函数)\n- 被调用者: [READ_ONCE, io_preinit_req, io_op_defs, io_check_restriction, io_init_req_drain, io_file_get, xa_load, get_cred, security_uring_override_creds, put_cred, io_req_prep, blk_start_plug_nr_ios]\n\n2. 函数名: READ_ONCE\n- 参数: [variable]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n3. 函数名: io_preinit_req\n- 参数: N/A (在注释中提到)\n- 调用者: N/A (在注释中提到)\n- 被调用者: N/A\n\n4. 函数名: io_check_restriction\n- 参数: [ctx, req, sqe_flags]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n5. 函数名: io_init_req_drain\n- 参数: [req]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n6. 函数名: io_file_get\n- 参数: [ctx, req, fd, IOSQE_FIXED_FILE]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n7. 函数名: xa_load\n- 参数: [&ctx->personalities, personality]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n8. 函数名: get_cred\n- 参数: [req->creds]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n9. 函数名: security_uring_override_creds\n- 参数: [req->creds]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n10. 函数名: put_cred\n- 参数: [req->creds]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n11. 函数名: io_req_prep\n- 参数: [req, sqe]\n- 调用者: io_init_req\n- 被调用者: N/A\n\n12. 函数名: blk_start_plug_nr_ios\n- 参数: [&state->plug, state->submit_nr]\n- 调用者: io_init_req\n- 被调用者: N/A"
    },
    {
        "id": 3888,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1989",
        "purpose": "Code purpose:\"\"\"在蓝牙SDIO驱动移除时，释放相关资源并注销HCI设备\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在btsdio_remove函数中，由于未正确处理异步操作导致的竞态条件，使得在hdev设备被释放后仍可能被访问，造成释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: btsdio_remove\n- 参数: [struct sdio_func *func]\n- 调用者: 未指定（由内核调用）\n- 被调用者: [sdio_get_drvdata, BT_DBG, sdio_set_drvdata, hci_unregister_dev, hci_free_dev]\n\n2. 函数名: sdio_get_drvdata\n- 参数: [struct sdio_func *func]\n- 调用者: btsdio_remove\n- 被调用者: 未指定\n\n3. 函数名: BT_DBG\n- 参数: [\"func %p\", func]\n- 调用者: btsdio_remove\n- 被调用者: 未指定\n\n4. 函数名: sdio_set_drvdata\n- 参数: [struct sdio_func *func, NULL]\n- 调用者: btsdio_remove\n- 被调用者: 未指定\n\n5. 函数名: hci_unregister_dev\n- 参数: [struct hci_dev *hdev]\n- 调用者: btsdio_remove\n- 被调用者: 未指定\n\n6. 函数名: hci_free_dev\n- 参数: [struct hci_dev *hdev]\n- 调用者: btsdio_remove\n- 被调用者: 未指定"
    },
    {
        "id": 3889,
        "cwe": "CWE-416",
        "cve": "CVE-2023-1990",
        "purpose": "Code purpose:\"\"\"该代码用于移除NDLC（NFC数据链路控制）结构体，包括取消定时器、清空接收和发送队列等清理操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ndlc_remove函数中，由于缺乏对ndlc对象访问的同步保护，导致在多线程环境下可能出现释放后使用(UAF)的竞态条件问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: ndlc_remove\n- 参数: [struct llt_ndlc *ndlc]\n- 调用者: 未明确（通常是外部调用）\n- 被调用者: [st_nci_remove, del_timer_sync, skb_queue_purge]\n\n2. 函数名: st_nci_remove\n- 参数: [ndlc->ndev]\n- 调用者: ndlc_remove\n- 被调用者: 未明确\n\n3. 函数名: del_timer_sync\n- 参数: [&ndlc->t1_timer], [&ndlc->t2_timer]\n- 调用者: ndlc_remove\n- 被调用者: 未明确\n\n4. 函数名: skb_queue_purge\n- 参数: [&ndlc->rcv_q], [&ndlc->send_q]\n- 调用者: ndlc_remove\n- 被调用者: 未明确"
    },
    {
        "id": 3907,
        "cwe": "CWE-416",
        "cve": "CVE-2023-20928",
        "purpose": "Code purpose:\"\"\"该代码用于在Android Binder驱动中释放已分配的内存资源，包括缓冲区、页面和相关的内存管理结构，确保在进程退出时清理所有分配的资源。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在binder_alloc_deferred_release函数中，由于对alloc->vma_vm_mm的访问没有适当的锁保护，可能导致在释放后仍被使用的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_alloc_deferred_release\n- 参数: [alloc]\n- 调用者: 未明确（根据上下文可能是binder_vma_close）\n- 被调用者: [mutex_lock, BUG_ON, rb_first, rb_entry, binder_alloc_clear_buf, binder_free_buf_locked, list_empty, list_first_entry, list_del, WARN_ON, WARN_ON_ONCE, kfree, list_lru_del, binder_alloc_debug, __free_page, mutex_unlock, mmdrop]\n\n2. 函数名: binder_alloc_clear_buf\n- 参数: [alloc, buffer]\n- 调用者: binder_alloc_deferred_release\n- 被调用者: []\n\n3. 函数名: binder_free_buf_locked\n- 参数: [alloc, buffer]\n- 调用者: binder_alloc_deferred_release\n- 被调用者: []\n\n4. 函数名: mutex_lock\n- 参数: [&alloc->mutex]\n- 调用者: binder_alloc_deferred_release\n- 被调用者: []\n\n5. 函数名: BUG_ON\n- 参数: [alloc->vma], [buffer->transaction]\n- 调用者: binder_alloc_deferred_release\n- 被调用者: []\n\n6. 函数名: rb_first\n- 参数: [&alloc->allocated_buffers]\n- 调用者: binder_alloc_deferred_release\n- 被调用者: []\n\n7. 函数名: rb_entry\n- 参数: [n, struct binder_buffer, rb_node]\n- 调用者: binder_alloc_deferred_release\n- 被调用者: []\n\n8. 函数名: list_empty\n- 参数: [&alloc->buffers]\n- 调用者: binder_alloc_deferred_release\n- 被调用者: []\n\n9. 函数名: list_first_entry\n- 参数: [&alloc->buffers, struct binder_buffer, entry]\n- 调用者: binder_alloc_deferred_release\n- 被调用者: []\n\n10. 函数名: list_del\n- 参数: [&buffer->entry]\n- 调用者: binder_alloc_deferred_release\n- 被调用者: []\n\n11. 函数名: WARN_ON\n- 参数: [!buffer->free]\n- 调用者: binder_alloc_deferred_release\n- 被调用者: []\n\n12. 函数名: WARN_ON_ONCE\n- 参数: [!list_empty(&alloc->buffers)]\n- 调用者: binder_alloc_deferred_release\n- 被调用者: []\n\n13. 函数名: kfree\n- 参数: [buffer]\n- 调用者: binder_alloc_deferred_release\n- 被调用者: []\n\n14. 函数名: list_lru_del\n- 参数: [&binder_alloc_lru, &alloc->pages[i].lru]\n- 调用者: binder_alloc_deferred_release\n- 被调用者: []\n\n15. 函数名: binder_alloc_debug\n- 参数: [BINDER_DEBUG_BUFFER_ALLOC, \"%s: %d: page %d at %pK %s\\n\", __func__, alloc->pid, i, page_addr, on_lru ? \"on lru\" : \"active\"], [BINDER_DEBUG_OPEN_CLOSE, \"%s: %d buffers %d, pages %d\\n\", __func__, alloc->pid, buffers, page_count]\n- 调用者: binder_alloc_deferred_release\n- 被调用者: []\n\n16. 函数名: __free_page\n- 参数: [alloc->pages[i].page_ptr]\n- 调用者: binder_alloc_deferred_release\n- 被调用者: []\n\n17. 函数名: mutex_unlock\n- 参数: [&alloc->mutex]\n- 调用者: binder_alloc_deferred_release\n- 被调用者: []\n\n18. 函数名: mmdrop\n- 参数: [alloc->vma_vm_mm]\n- 调用者: binder_alloc_deferred_release\n- 被调用者: []"
    },
    {
        "id": 3908,
        "cwe": "CWE-416",
        "cve": "CVE-2023-20928",
        "purpose": "Code purpose:\"\"\"设置binder分配器的虚拟内存区域(vma)并确保内存可见性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在binder_alloc_set_vma函数中，由于缺乏适当的锁保护，导致vma结构体可能在释放后被继续访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_alloc_set_vma\n- 参数: [alloc, vma]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [smp_wmb]\n\n2. 函数名: smp_wmb\n- 参数: []\n- 调用者: [binder_alloc_set_vma]\n- 被调用者: 未明确（系统/架构特定内存屏障实现）"
    },
    {
        "id": 3909,
        "cwe": "CWE-416",
        "cve": "CVE-2023-20928",
        "purpose": "Code purpose:\"\"\"该代码用于管理Android Binder驱动中的内存页面分配和释放，处理用户空间和内核空间之间的内存映射操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在binder_update_page_range函数中，由于对vma_vm_mm内存管理结构的锁定不当，导致在vma关闭时可能出现释放后使用(UAF)的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_update_page_range\n- 参数: [struct binder_alloc *alloc, int allocate, void __user *start, void __user *end]\n- 调用者: N/A\n- 被调用者: [binder_alloc_debug, trace_binder_update_page_range, mmget_not_zero, mmap_read_lock, list_lru_del, alloc_page, vm_insert_page, __free_page, mmap_read_unlock, mmput, list_lru_add, trace_binder_alloc_lru_start, trace_binder_alloc_lru_end, trace_binder_alloc_page_start, trace_binder_alloc_page_end, trace_binder_free_lru_start, trace_binder_free_lru_end]\n\n2. 函数名: binder_alloc_debug\n- 参数: [int level, const char *format, ...]\n- 调用者: binder_update_page_range\n- 被调用者: N/A\n\n3. 函数名: trace_binder_update_page_range\n- 参数: [struct binder_alloc *alloc, int allocate, void __user *start, void __user *end]\n- 调用者: binder_update_page_range\n- 被调用者: N/A\n\n4. 函数名: mmget_not_zero\n- 参数: [struct mm_struct *mm]\n- 调用者: binder_update_page_range\n- 被调用者: N/A\n\n5. 函数名: mmap_read_lock\n- 参数: [struct mm_struct *mm]\n- 调用者: binder_update_page_range\n- 被调用者: N/A\n\n6. 函数名: list_lru_del\n- 参数: [struct list_lru *lru, struct list_head *item]\n- 调用者: binder_update_page_range\n- 被调用者: N/A\n\n7. 函数名: alloc_page\n- 参数: [gfp_t gfp_mask]\n- 调用者: binder_update_page_range\n- 被调用者: N/A\n\n8. 函数名: vm_insert_page\n- 参数: [struct vm_area_struct *vma, unsigned long addr, struct page *page]\n- 调用者: binder_update_page_range\n- 被调用者: N/A\n\n9. 函数名: __free_page\n- 参数: [struct page *page]\n- 调用者: binder_update_page_range\n- 被调用者: N/A\n\n10. 函数名: mmap_read_unlock\n- 参数: [struct mm_struct *mm]\n- 调用者: binder_update_page_range\n- 被调用者: N/A\n\n11. 函数名: mmput\n- 参数: [struct mm_struct *mm]\n- 调用者: binder_update_page_range\n- 被调用者: N/A\n\n12. 函数名: list_lru_add\n- 参数: [struct list_lru *lru, struct list_head *item]\n- 调用者: binder_update_page_range\n- 被调用者: N/A\n\n13. 函数名: trace_binder_alloc_lru_start\n- 参数: [struct binder_alloc *alloc, size_t index]\n- 调用者: binder_update_page_range\n- 被调用者: N/A\n\n14. 函数名: trace_binder_alloc_lru_end\n- 参数: [struct binder_alloc *alloc, size_t index]\n- 调用者: binder_update_page_range\n- 被调用者: N/A\n\n15. 函数名: trace_binder_alloc_page_start\n- 参数: [struct binder_alloc *alloc, size_t index]\n- 调用者: binder_update_page_range\n- 被调用者: N/A\n\n16. 函数名: trace_binder_alloc_page_end\n- 参数: [struct binder_alloc *alloc, size_t index]\n- 调用者: binder_update_page_range\n- 被调用者: N/A\n\n17. 函数名: trace_binder_free_lru_start\n- 参数: [struct binder_alloc *alloc, size_t index]\n- 调用者: binder_update_page_range\n- 被调用者: N/A\n\n18. 函数名: trace_binder_free_lru_end\n- 参数: [struct binder_alloc *alloc, size_t index]\n- 调用者: binder_update_page_range\n- 被调用者: N/A"
    },
    {
        "id": 3910,
        "cwe": "CWE-416",
        "cve": "CVE-2023-20928",
        "purpose": "Code purpose:\"\"\"获取binder分配器中的虚拟内存区域(vma)结构体指针\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在binder_alloc_get_vma函数中，由于缺乏适当的锁保护，导致在访问alloc->vma时可能发生释放后重用(UAF)的情况。\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_alloc_get_vma\n- 参数: [struct binder_alloc *alloc]\n- 调用者: 未明确（根据上下文可能由binder驱动相关代码调用）\n- 被调用者: [smp_rmb]"
    },
    {
        "id": 3911,
        "cwe": "CWE-416",
        "cve": "CVE-2023-20928",
        "purpose": "Code purpose:\"\"\"该代码用于执行binder分配器的自测试，包括分配偏移量测试并在完成后输出测试结果\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在binder_vma_close函数中由于不正确的锁机制导致释放后使用(use-after-free)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_selftest_alloc\n- 参数: [struct binder_alloc *alloc]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [mutex_lock, mutex_unlock, binder_selftest_alloc_offset, pr_info]\n\n2. 函数名: mutex_lock\n- 参数: [&binder_selftest_lock]\n- 调用者: binder_selftest_alloc\n- 被调用者: []\n\n3. 函数名: mutex_unlock\n- 参数: [&binder_selftest_lock]\n- 调用者: binder_selftest_alloc\n- 被调用者: []\n\n4. 函数名: binder_selftest_alloc_offset\n- 参数: [alloc, end_offset, 0]\n- 调用者: binder_selftest_alloc\n- 被调用者: []\n\n5. 函数名: pr_info\n- 参数: [\"STARTED\"], [\"%d tests FAILED\\n\", binder_selftest_failures], [\"PASSED\\n\"]\n- 调用者: binder_selftest_alloc\n- 被调用者: []"
    },
    {
        "id": 3912,
        "cwe": "CWE-416",
        "cve": "CVE-2023-20938",
        "purpose": "Code purpose:\"\"\"处理Binder进程间通信中的文件描述符数组传输，包括验证输入参数、计算偏移量并逐个传输文件描述符\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在释放binder事务缓冲区时未正确验证输入，导致存在释放后使用(UAF)的可能性\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_translate_fd_array\n- 参数: [struct list_head *pf_head, struct binder_fd_array_object *fda, const void __user *sender_ubuffer, struct binder_buffer_object *parent, struct binder_buffer_object *sender_uparent, struct binder_transaction *t, struct binder_thread *thread, struct binder_transaction *in_reply_to]\n- 调用者: 未明确显示（应为binder_transaction相关函数）\n- 被调用者: [binder_user_error, IS_ALIGNED, binder_add_fixup, copy_from_user, binder_translate_fd]\n\n2. 函数名: binder_user_error\n- 参数: [const char *fmt, ...] (变参函数)\n- 调用者: binder_translate_fd_array\n- 被调用者: []\n\n3. 函数名: IS_ALIGNED\n- 参数: [unsigned long addr, size_t alignment]\n- 调用者: binder_translate_fd_array\n- 被调用者: []\n\n4. 函数名: binder_add_fixup\n- 参数: [struct list_head *pf_head, binder_size_t offset, binder_uintptr_t fixup_data, size_t data_size]\n- 调用者: binder_translate_fd_array\n- 被调用者: []\n\n5. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: binder_translate_fd_array\n- 被调用者: []\n\n6. 函数名: binder_translate_fd\n- 参数: [u32 fd, binder_size_t offset, struct binder_transaction *t, struct binder_thread *thread, struct binder_transaction *in_reply_to]\n- 调用者: binder_translate_fd_array\n- 被调用者: []"
    },
    {
        "id": 3916,
        "cwe": "CWE-416",
        "cve": "CVE-2023-21255",
        "purpose": "Code purpose:\"\"\"释放binder缓冲区并处理相关事务，包括清理事务缓冲区和异步事务队列\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放内存后仍可能访问已被释放的buffer结构体，导致use-after-free内存破坏漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_free_buf\n- 参数: [proc, thread, buffer, is_failure]\n- 调用者: N/A (顶级函数)\n- 被调用者: [binder_inner_proc_lock, binder_inner_proc_unlock, binder_node_inner_lock, binder_dequeue_work_head_ilocked, binder_enqueue_work_ilocked, binder_wakeup_proc_ilocked, binder_node_inner_unlock, trace_binder_transaction_buffer_release, binder_transaction_buffer_release, binder_alloc_free_buf]\n\n2. 函数名: binder_inner_proc_lock\n- 参数: [proc]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n3. 函数名: binder_inner_proc_unlock\n- 参数: [proc]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n4. 函数名: binder_node_inner_lock\n- 参数: [buf_node]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n5. 函数名: binder_dequeue_work_head_ilocked\n- 参数: [&buf_node->async_todo]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n6. 函数名: binder_enqueue_work_ilocked\n- 参数: [w, &proc->todo]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n7. 函数名: binder_wakeup_proc_ilocked\n- 参数: [proc]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n8. 函数名: binder_node_inner_unlock\n- 参数: [buf_node]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n9. 函数名: trace_binder_transaction_buffer_release\n- 参数: [buffer]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n10. 函数名: binder_transaction_buffer_release\n- 参数: [proc, thread, buffer, 0, is_failure]\n- 调用者: binder_free_buf\n- 被调用者: []\n\n11. 函数名: binder_alloc_free_buf\n- 参数: [&proc->alloc, buffer]\n- 调用者: binder_free_buf\n- 被调用者: []"
    },
    {
        "id": 3917,
        "cwe": "CWE-416",
        "cve": "CVE-2023-21255",
        "purpose": "Code purpose:\"\"\"处理Binder进程间通信事务，包括事务的排队、唤醒线程以及处理异步事务的内存管理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在释放过时的交易对象t_outdated后，可能仍存在对该对象的内存引用，导致释放后使用(UAF)的内存损坏漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_proc_transaction\n- 参数: [struct binder_transaction *t, struct binder_proc *proc, struct binder_thread *thread]\n- 调用者: N/A\n- 被调用者: [binder_node_lock, binder_inner_proc_lock, binder_inner_proc_unlock, binder_node_unlock, binder_select_thread_ilocked, binder_enqueue_thread_work_ilocked, binder_enqueue_work_ilocked, binder_find_outdated_transaction_ilocked, binder_wakeup_thread_ilocked, binder_transaction_buffer_release, binder_alloc_free_buf, kfree, binder_stats_deleted]\n\n2. 函数名: binder_node_lock\n- 参数: [struct binder_node *node]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n3. 函数名: binder_inner_proc_lock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n4. 函数名: binder_inner_proc_unlock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n5. 函数名: binder_node_unlock\n- 参数: [struct binder_node *node]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n6. 函数名: binder_select_thread_ilocked\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n7. 函数名: binder_enqueue_thread_work_ilocked\n- 参数: [struct binder_thread *thread, struct binder_work *work]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n8. 函数名: binder_enqueue_work_ilocked\n- 参数: [struct binder_work *work, struct list_head *target_list]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n9. 函数名: binder_find_outdated_transaction_ilocked\n- 参数: [struct binder_transaction *t, struct list_head *list]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n10. 函数名: binder_wakeup_thread_ilocked\n- 参数: [struct binder_proc *proc, struct binder_thread *thread, bool sync]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n11. 函数名: binder_transaction_buffer_release\n- 参数: [struct binder_proc *proc, struct binder_thread *thread, struct binder_buffer *buffer, int debug_id, int last]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n12. 函数名: binder_alloc_free_buf\n- 参数: [struct binder_alloc *alloc, struct binder_buffer *buffer]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n13. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n14. 函数名: binder_stats_deleted\n- 参数: [enum binder_stat_types type]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A"
    },
    {
        "id": 3923,
        "cwe": "CWE-416",
        "cve": "CVE-2023-2162",
        "purpose": "Code purpose:\"\"\"该代码用于获取iSCSI TCP主机参数，特别是处理IP地址参数的查询，涉及会话和连接状态的检查以及套接字信息的获取。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放连接资源后仍可能访问该连接的数据结构，导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: iscsi_sw_tcp_host_get_param\n- 参数: [struct Scsi_Host *shost, enum iscsi_host_param param, char *buf]\n- 调用者: 未显示\n- 被调用者: [iscsi_host_priv, iscsi_get_conn, spin_lock_bh, spin_unlock_bh, mutex_lock, mutex_unlock, kernel_getsockname, iscsi_put_conn, iscsi_conn_get_addr_param, iscsi_host_get_param]\n\n2. 函数名: iscsi_host_priv\n- 参数: [struct Scsi_Host *shost]\n- 调用者: iscsi_sw_tcp_host_get_param\n- 被调用者: 未显示\n\n3. 函数名: iscsi_get_conn\n- 参数: [struct iscsi_cls_conn *cls_conn]\n- 调用者: iscsi_sw_tcp_host_get_param\n- 被调用者: 未显示\n\n4. 函数名: spin_lock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: iscsi_sw_tcp_host_get_param\n- 被调用者: 未显示\n\n5. 函数名: spin_unlock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: iscsi_sw_tcp_host_get_param\n- 被调用者: 未显示\n\n6. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: iscsi_sw_tcp_host_get_param\n- 被调用者: 未显示\n\n7. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: iscsi_sw_tcp_host_get_param\n- 被调用者: 未显示\n\n8. 函数名: kernel_getsockname\n- 参数: [struct socket *sock, struct sockaddr *addr]\n- 调用者: iscsi_sw_tcp_host_get_param\n- 被调用者: 未显示\n\n9. 函数名: iscsi_put_conn\n- 参数: [struct iscsi_cls_conn *cls_conn]\n- 调用者: iscsi_sw_tcp_host_get_param\n- 被调用者: 未显示\n\n10. 函数名: iscsi_conn_get_addr_param\n- 参数: [struct sockaddr_storage *addr, enum iscsi_param param, char *buf]\n- 调用者: iscsi_sw_tcp_host_get_param\n- 被调用者: 未显示\n\n11. 函数名: iscsi_host_get_param\n- 参数: [struct Scsi_Host *shost, enum iscsi_host_param param, char *buf]\n- 调用者: iscsi_sw_tcp_host_get_param\n- 被调用者: 未显示"
    },
    {
        "id": 3924,
        "cwe": "CWE-416",
        "cve": "CVE-2023-2162",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的SCSI子系统中创建一个iSCSI over TCP的会话，包括主机分配、会话设置和资源初始化等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在iscsi_sw_tcp_session_create函数中，当ep参数非空时错误地返回NULL而未释放已分配的资源，可能导致后续操作中访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: iscsi_sw_tcp_session_create\n- 参数: [ep, cmds_max, qdepth, initial_cmdsn]\n- 调用者: N/A\n- 被调用者: [iscsi_host_alloc, iscsi_host_get_max_scsi_cmds, iscsi_host_add, iscsi_session_setup, iscsi_tcp_r2tpool_alloc, iscsi_session_teardown, iscsi_host_remove, iscsi_host_free]\n\n2. 函数名: iscsi_host_alloc\n- 参数: [&iscsi_sw_tcp_sht, sizeof(struct iscsi_sw_tcp_host), 1]\n- 调用者: iscsi_sw_tcp_session_create\n- 被调用者: N/A\n\n3. 函数名: iscsi_host_get_max_scsi_cmds\n- 参数: [shost, cmds_max]\n- 调用者: iscsi_sw_tcp_session_create\n- 被调用者: N/A\n\n4. 函数名: iscsi_host_add\n- 参数: [shost, NULL]\n- 调用者: iscsi_sw_tcp_session_create\n- 被调用者: N/A\n\n5. 函数名: iscsi_session_setup\n- 参数: [&iscsi_sw_tcp_transport, shost, cmds_max, 0, sizeof(struct iscsi_tcp_task) + sizeof(struct iscsi_sw_tcp_hdrbuf), initial_cmdsn, 0]\n- 调用者: iscsi_sw_tcp_session_create\n- 被调用者: N/A\n\n6. 函数名: iscsi_tcp_r2tpool_alloc\n- 参数: [session]\n- 调用者: iscsi_sw_tcp_session_create\n- 被调用者: N/A\n\n7. 函数名: iscsi_session_teardown\n- 参数: [cls_session]\n- 调用者: iscsi_sw_tcp_session_create\n- 被调用者: N/A\n\n8. 函数名: iscsi_host_remove\n- 参数: [shost, false]\n- 调用者: iscsi_sw_tcp_session_create\n- 被调用者: N/A\n\n9. 函数名: iscsi_host_free\n- 参数: [shost]\n- 调用者: iscsi_sw_tcp_session_create\n- 被调用者: N/A"
    },
    {
        "id": 3956,
        "cwe": "CWE-416",
        "cve": "CVE-2023-25012",
        "purpose": "Code purpose:\"\"\"该代码实现了一个HID设备(BigBen游戏控制器)的LED和力反馈(rumble)功能的工作线程，处理来自设备的输入报告并发送控制指令。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在bigben_remove操作后，LED控制器注册状态保持时间过长，导致后续可能访问已释放的内存区域。\"\"\"",
        "functions": "Functions:\n1. 函数名: bigben_worker\n- 参数: [struct work_struct *work]\n- 调用者: 未显示（由工作队列机制调用）\n- 被调用者: [container_of, hid_alloc_report_buf, hid_report_len, spin_lock_irqsave, spin_unlock_irqrestore, hid_output_report, hid_hw_raw_request, kfree]\n\n2. 函数名: container_of\n- 参数: [work, struct bigben_device, worker]\n- 调用者: bigben_worker\n- 被调用者: 无（宏函数）\n\n3. 函数名: hid_alloc_report_buf\n- 参数: [bigben->report, GFP_KERNEL]\n- 调用者: bigben_worker\n- 被调用者: 无\n\n4. 函数名: hid_report_len\n- 参数: [bigben->report]\n- 调用者: bigben_worker\n- 被调用者: 无\n\n5. 函数名: spin_lock_irqsave\n- 参数: [&bigben->lock, flags]\n- 调用者: bigben_worker\n- 被调用者: 无\n\n6. 函数名: spin_unlock_irqrestore\n- 参数: [&bigben->lock, flags]\n- 调用者: bigben_worker\n- 被调用者: 无\n\n7. 函数名: hid_output_report\n- 参数: [bigben->report, buf]\n- 调用者: bigben_worker\n- 被调用者: 无\n\n8. 函数名: hid_hw_raw_request\n- 参数: [bigben->hid, bigben->report->id, buf, len, bigben->report->type, HID_REQ_SET_REPORT]\n- 调用者: bigben_worker\n- 被调用者: 无\n\n9. 函数名: kfree\n- 参数: [buf]\n- 调用者: bigben_worker\n- 被调用者: 无"
    },
    {
        "id": 3957,
        "cwe": "CWE-416",
        "cve": "CVE-2023-25012",
        "purpose": "Code purpose:\"\"\"该代码用于控制BigBen设备的LED灯状态，根据亮度值设置LED的开关状态，并通过工作队列调度更新操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"LED控制器在设备被移除后仍保持注册状态过久，导致后续可能发生对已释放内存的使用（Use-After-Free）。\"\"\"",
        "functions": "Functions:\n1. 函数名: bigben_set_led\n- 参数: [struct led_classdev *led, enum led_brightness value]\n- 调用者: 未显示（应为LED子系统调用）\n- 被调用者: [to_hid_device, hid_get_drvdata, hid_err, spin_lock_irqsave, spin_unlock_irqrestore, schedule_work]\n\n2. 函数名: to_hid_device\n- 参数: [struct device *dev]\n- 调用者: bigben_set_led\n- 被调用者: []\n\n3. 函数名: hid_get_drvdata\n- 参数: [struct hid_device *hid]\n- 调用者: bigben_set_led\n- 被调用者: []\n\n4. 函数名: hid_err\n- 参数: [struct hid_device *hid, const char *fmt]\n- 调用者: bigben_set_led\n- 被调用者: []\n\n5. 函数名: spin_lock_irqsave\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: bigben_set_led\n- 被调用者: []\n\n6. 函数名: spin_unlock_irqrestore\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: bigben_set_led\n- 被调用者: []\n\n7. 函数名: schedule_work\n- 参数: [struct work_struct *work]\n- 调用者: bigben_set_led\n- 被调用者: []"
    },
    {
        "id": 3958,
        "cwe": "CWE-416",
        "cve": "CVE-2023-25012",
        "purpose": "Code purpose:\"\"\"处理HID设备BigBen的力反馈效果，根据输入效果控制左右马达的状态和力度\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在设备移除时LED控制器注册时间过长，导致后续可能发生对已释放内存的使用\"\"\"",
        "functions": "Functions:\n1. 函数名: hid_bigben_play_effect\n- 参数: [struct input_dev *dev, void *data, struct ff_effect *effect]\n- 调用者: 未明确显示（通常由输入子系统调用）\n- 被调用者: [input_get_drvdata, hid_get_drvdata, hid_err, spin_lock_irqsave, spin_unlock_irqrestore, schedule_work]\n\n2. 函数名: input_get_drvdata\n- 参数: [struct input_dev *dev]\n- 调用者: hid_bigben_play_effect\n- 被调用者: []\n\n3. 函数名: hid_get_drvdata\n- 参数: [struct hid_device *hid]\n- 调用者: hid_bigben_play_effect\n- 被调用者: []\n\n4. 函数名: hid_err\n- 参数: [struct hid_device *hid, const char *fmt, ...]\n- 调用者: hid_bigben_play_effect\n- 被调用者: []\n\n5. 函数名: spin_lock_irqsave\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: hid_bigben_play_effect\n- 被调用者: []\n\n6. 函数名: spin_unlock_irqrestore\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: hid_bigben_play_effect\n- 被调用者: []\n\n7. 函数名: schedule_work\n- 参数: [struct work_struct *work]\n- 调用者: hid_bigben_play_effect\n- 被调用者: []"
    },
    {
        "id": 3959,
        "cwe": "CWE-416",
        "cve": "CVE-2023-25012",
        "purpose": "Code purpose:\"\"\"该代码实现了对BigBen游戏手柄的LED灯和力反馈功能的支持，包括设备探测、初始化、LED控制器注册和力反馈设置等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"LED控制器在设备移除后仍保持注册状态导致使用后释放漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: bigben_probe\n- 参数: [struct hid_device *hid, const struct hid_device_id *id]\n- 调用者: 外部调用（HID子系统）\n- 被调用者: [devm_kzalloc, hid_set_drvdata, hid_parse, hid_err, hid_hw_start, list_empty, list_entry, list_first_entry, set_bit, INIT_WORK, spin_lock_init, input_ff_create_memless, strlen, dev_name, snprintf, devm_led_classdev_register, schedule_work, hid_info, hid_hw_stop]\n\n2. 函数名: devm_kzalloc\n- 参数: [&hid->dev, sizeof(*bigben), GFP_KERNEL]\n- 调用者: bigben_probe\n- 被调用者: []\n\n3. 函数名: hid_set_drvdata\n- 参数: [hid, bigben]\n- 调用者: bigben_probe\n- 被调用者: []\n\n4. 函数名: hid_parse\n- 参数: [hid]\n- 调用者: bigben_probe\n- 被调用者: []\n\n5. 函数名: hid_err\n- 参数: [hid, \"parse failed\\n\"]\n- 调用者: bigben_probe\n- 被调用者: []\n\n6. 函数名: hid_hw_start\n- 参数: [hid, HID_CONNECT_DEFAULT & ~HID_CONNECT_FF]\n- 调用者: bigben_probe\n- 被调用者: []\n\n7. 函数名: list_empty\n- 参数: [report_list], [&hid->inputs]\n- 调用者: bigben_probe\n- 被调用者: []\n\n8. 函数名: list_entry\n- 参数: [report_list->next, struct hid_report, list]\n- 调用者: bigben_probe\n- 被调用者: []\n\n9. 函数名: list_first_entry\n- 参数: [&hid->inputs, struct hid_input, list]\n- 调用者: bigben_probe\n- 被调用者: []\n\n10. 函数名: set_bit\n- 参数: [FF_RUMBLE, hidinput->input->ffbit]\n- 调用者: bigben_probe\n- 被调用者: []\n\n11. 函数名: INIT_WORK\n- 参数: [&bigben->worker, bigben_worker]\n- 调用者: bigben_probe\n- 被调用者: []\n\n12. 函数名: spin_lock_init\n- 参数: [&bigben->lock]\n- 调用者: bigben_probe\n- 被调用者: []\n\n13. 函数名: input_ff_create_memless\n- 参数: [hidinput->input, NULL, hid_bigben_play_effect]\n- 调用者: bigben_probe\n- 被调用者: []\n\n14. 函数名: strlen\n- 参数: [dev_name(&hid->dev)]\n- 调用者: bigben_probe\n- 被调用者: []\n\n15. 函数名: dev_name\n- 参数: [&hid->dev]\n- 调用者: bigben_probe\n- 被调用者: []\n\n16. 函数名: snprintf\n- 参数: [name, name_sz, \"%s:red:bigben%d\", dev_name(&hid->dev), n + 1]\n- 调用者: bigben_probe\n- 被调用者: []\n\n17. 函数名: devm_led_classdev_register\n- 参数: [&hid->dev, led]\n- 调用者: bigben_probe\n- 被调用者: []\n\n18. 函数名: schedule_work\n- 参数: [&bigben->worker]\n- 调用者: bigben_probe\n- 被调用者: []\n\n19. 函数名: hid_info\n- 参数: [hid, \"LED and force feedback support for BigBen gamepad\\n\"]\n- 调用者: bigben_probe\n- 被调用者: []\n\n20. 函数名: hid_hw_stop\n- 参数: [hid]\n- 调用者: bigben_probe\n- 被调用者: []"
    },
    {
        "id": 3960,
        "cwe": "CWE-416",
        "cve": "CVE-2023-2513",
        "purpose": "Code purpose:\"\"\"该代码用于在ext4文件系统中查找inode内部存储的扩展属性，并验证其有效性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4文件系统中处理扩展属性的额外inode大小时，存在释放后使用(UAF)漏洞，可能导致系统崩溃或其他未定义行为。\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_xattr_ibody_find\n- 参数: [struct inode *inode, struct ext4_xattr_info *i, struct ext4_xattr_ibody_find *is]\n- 调用者: N/A\n- 被调用者: [ext4_raw_inode, IHDR, IFIRST, ext4_test_inode_state, xattr_check_inode, xattr_find_entry]\n\n2. 函数名: ext4_raw_inode\n- 参数: [&is->iloc]\n- 调用者: ext4_xattr_ibody_find\n- 被调用者: N/A\n\n3. 函数名: IHDR\n- 参数: [inode, raw_inode]\n- 调用者: ext4_xattr_ibody_find\n- 被调用者: N/A\n\n4. 函数名: IFIRST\n- 参数: [header]\n- 调用者: ext4_xattr_ibody_find\n- 被调用者: N/A\n\n5. 函数名: ext4_test_inode_state\n- 参数: [inode, EXT4_STATE_XATTR]\n- 调用者: ext4_xattr_ibody_find\n- 被调用者: N/A\n\n6. 函数名: xattr_check_inode\n- 参数: [inode, header, is->s.end]\n- 调用者: ext4_xattr_ibody_find\n- 被调用者: N/A\n\n7. 函数名: xattr_find_entry\n- 参数: [inode, &is->s.here, is->s.end, i->name_index, i->name, 0]\n- 调用者: ext4_xattr_ibody_find\n- 被调用者: N/A"
    },
    {
        "id": 3961,
        "cwe": "CWE-416",
        "cve": "CVE-2023-2513",
        "purpose": "Code purpose:\"\"\"处理ext4文件系统中扩展属性在inode内部存储的设置操作，包括属性条目的设置和magic值的更新\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4文件系统中处理扩展属性的额外inode大小时，存在释放后使用(use-after-free)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_xattr_ibody_set\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_xattr_info *i, struct ext4_xattr_ibody_find *is]\n- 调用者: N/A\n- 被调用者: [ext4_xattr_set_entry, cpu_to_le32, ext4_set_inode_state, ext4_clear_inode_state, IHDR, ext4_raw_inode, IS_LAST_ENTRY]\n\n2. 函数名: ext4_xattr_set_entry\n- 参数: [struct ext4_xattr_info *i, struct ext4_xattr_search *s, handle_t *handle, struct inode *inode, bool is_block]\n- 调用者: ext4_xattr_ibody_set\n- 被调用者: N/A\n\n3. 函数名: cpu_to_le32\n- 参数: [u32]\n- 调用者: ext4_xattr_ibody_set\n- 被调用者: N/A\n\n4. 函数名: ext4_set_inode_state\n- 参数: [struct inode *inode, unsigned int state]\n- 调用者: ext4_xattr_ibody_set\n- 被调用者: N/A\n\n5. 函数名: ext4_clear_inode_state\n- 参数: [struct inode *inode, unsigned int state]\n- 调用者: ext4_xattr_ibody_set\n- 被调用者: N/A\n\n6. 函数名: IHDR\n- 参数: [struct inode *inode, void *raw_inode]\n- 调用者: ext4_xattr_ibody_set\n- 被调用者: N/A\n\n7. 函数名: ext4_raw_inode\n- 参数: [struct ext4_iloc *iloc]\n- 调用者: ext4_xattr_ibody_set\n- 被调用者: N/A\n\n8. 函数名: IS_LAST_ENTRY\n- 参数: [struct ext4_xattr_entry *entry]\n- 调用者: ext4_xattr_ibody_set\n- 被调用者: N/A"
    },
    {
        "id": 3968,
        "cwe": "CWE-416",
        "cve": "CVE-2023-26544",
        "purpose": "Code purpose:\"\"\"该代码片段实现了NTFS文件系统中读取主文件表(MFT)记录的功能，包括解析文件属性、设置inode信息以及处理不同类型的文件记录。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在NTFS文件系统中处理run_unpack时，由于NTFS扇区大小与媒体扇区大小不一致导致的释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ntfs_read_mft\n- 参数: [struct inode *inode, const struct cpu_str *name, const struct MFT_REF *ref]\n- 调用者: N/A (likely called by filesystem operations)\n- 被调用者: [ntfs_i, mi_init, run_add_entry, mi_read, is_rec_inuse, is_rec_base, ni_enum_attr_ex, ntfs_load_attr_list, ntfs_cmp_names_cpu, is_attr_sparsed, is_attr_compressed, is_attr_encrypted, indx_init, ni_parse_reparse, run_close, resident_data_ex, ntfs_get_wsl_perm, run_unpack_ex, set_nlink, init_rwsem, unlock_new_inode, iget_failed]\n\n2. 函数名: ntfs_i\n- 参数: [struct inode *inode]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n3. 函数名: mi_init\n- 参数: [struct mft_inode *mi, struct ntfs_sb_info *sbi, unsigned long ino]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n4. 函数名: run_add_entry\n- 参数: [struct runs_tree *run, u64 vcn, u64 lcn, u64 len, bool is_mft]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n5. 函数名: mi_read\n- 参数: [struct mft_inode *mi, bool is_mft]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n6. 函数名: is_rec_inuse\n- 参数: [struct MFT_REC *rec]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n7. 函数名: is_rec_base\n- 参数: [struct MFT_REC *rec]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n8. 函数名: ni_enum_attr_ex\n- 参数: [struct ntfs_inode *ni, struct ATTRIB *attr, struct ATTR_LIST_ENTRY **le, struct ATTR_LIST_ENTRY *le_next]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n9. 函数名: ntfs_load_attr_list\n- 参数: [struct ntfs_inode *ni, struct ATTRIB *attr]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n10. 函数名: ntfs_cmp_names_cpu\n- 参数: [struct cpu_str *uni1, struct le_str *uni2, struct ntfs_sb_info *sbi, bool case_insensitive]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n11. 函数名: is_attr_sparsed\n- 参数: [struct ATTRIB *attr]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n12. 函数名: is_attr_compressed\n- 参数: [struct ATTRIB *attr]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n13. 函数名: is_attr_encrypted\n- 参数: [struct ATTRIB *attr]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n14. 函数名: indx_init\n- 参数: [struct ntfs_index *indx, struct ntfs_sb_info *sbi, struct ATTRIB *attr, struct mutex *mutex]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n15. 函数名: ni_parse_reparse\n- 参数: [struct ntfs_inode *ni, struct ATTRIB *attr, struct REPARSE_DATA_BUFFER *rp]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n16. 函数名: run_close\n- 参数: [struct runs_tree *run]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n17. 函数名: resident_data_ex\n- 参数: [struct ATTRIB *attr, u32 data_size]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n18. 函数名: ntfs_get_wsl_perm\n- 参数: [struct inode *inode]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n19. 函数名: run_unpack_ex\n- 参数: [struct runs_tree *run, struct ntfs_sb_info *sbi, u64 ino, u64 vcn, u64 evcn, u64 svcn, u8 *run_buf, u32 run_size]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n20. 函数名: set_nlink\n- 参数: [struct inode *inode, unsigned int nlink]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n21. 函数名: init_rwsem\n- 参数: [struct rw_semaphore *sem]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n22. 函数名: unlock_new_inode\n- 参数: [struct inode *inode]\n- 调用者: ntfs_read_mft\n- 被调用者: []\n\n23. 函数名: iget_failed\n- 参数: [struct inode *inode]\n- 调用者: ntfs_read_mft\n- 被调用者: []"
    },
    {
        "id": 3971,
        "cwe": "CWE-416",
        "cve": "CVE-2023-26605",
        "purpose": "Code purpose:\"\"\"该代码用于处理单个inode的写回操作，包括同步状态管理、脏数据检查以及写回列表维护等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核6.0.8中，fs/fs-writeback.c文件的inode_cgwb_move_to_attached函数存在释放后重用漏洞，与__list_del_entry_valid相关。\"\"\"",
        "functions": "Functions:\n1. 函数名: writeback_single_inode\n- 参数: [struct inode *inode, struct writeback_control *wbc]\n- 调用者: N/A (顶级函数)\n- 被调用者: [WARN_ON, __inode_wait_for_writeback, mapping_tagged, wbc_attach_and_unlock_inode, __writeback_single_inode, wbc_detach_inode, inode_to_wb_and_lock_list, inode_cgwb_move_to_attached, redirty_tail_locked, inode_io_list_move_locked, inode_sync_complete]\n\n2. 函数名: __inode_wait_for_writeback\n- 参数: [struct inode *inode]\n- 调用者: writeback_single_inode\n- 被调用者: []\n\n3. 函数名: wbc_attach_and_unlock_inode\n- 参数: [struct writeback_control *wbc, struct inode *inode]\n- 调用者: writeback_single_inode\n- 被调用者: []\n\n4. 函数名: __writeback_single_inode\n- 参数: [struct inode *inode, struct writeback_control *wbc]\n- 调用者: writeback_single_inode\n- 被调用者: []\n\n5. 函数名: wbc_detach_inode\n- 参数: [struct writeback_control *wbc]\n- 调用者: writeback_single_inode\n- 被调用者: []\n\n6. 函数名: inode_to_wb_and_lock_list\n- 参数: [struct inode *inode]\n- 调用者: writeback_single_inode\n- 被调用者: []\n\n7. 函数名: inode_cgwb_move_to_attached\n- 参数: [struct inode *inode, struct bdi_writeback *wb]\n- 调用者: writeback_single_inode\n- 被调用者: []\n\n8. 函数名: redirty_tail_locked\n- 参数: [struct inode *inode, struct bdi_writeback *wb]\n- 调用者: writeback_single_inode\n- 被调用者: []\n\n9. 函数名: inode_io_list_move_locked\n- 参数: [struct inode *inode, struct bdi_writeback *wb, struct list_head *list]\n- 调用者: writeback_single_inode\n- 被调用者: []\n\n10. 函数名: inode_sync_complete\n- 参数: [struct inode *inode]\n- 调用者: writeback_single_inode\n- 被调用者: []"
    },
    {
        "id": 3972,
        "cwe": "CWE-416",
        "cve": "CVE-2023-26606",
        "purpose": "Code purpose:\"\"\"该代码用于在NTFS文件系统中实现trim功能，通过释放未使用的簇来优化存储空间使用。\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ntfs_trim_fs函数中，由于对位图缓冲区的引用计数管理不当，可能导致在缓冲区已被释放后仍被访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ntfs_trim_fs\n- 参数: [struct ntfs_sb_info *sbi, struct fstrim_range *range]\n- 调用者: (未显示)\n- 被调用者: [bytes_to_cluster, down_read_nested, wnd_map, test_bit, ntfs_discard, put_bh, up_read]\n\n2. 函数名: bytes_to_cluster\n- 参数: [struct ntfs_sb_info *sbi, u64 bytes]\n- 调用者: ntfs_trim_fs\n- 被调用者: (未显示)\n\n3. 函数名: down_read_nested\n- 参数: [struct rw_semaphore *sem, int subclass]\n- 调用者: ntfs_trim_fs\n- 被调用者: (未显示)\n\n4. 函数名: wnd_map\n- 参数: [struct wnd_bitmap *wnd, size_t iw]\n- 调用者: ntfs_trim_fs\n- 被调用者: (未显示)\n\n5. 函数名: test_bit\n- 参数: [unsigned int nr, const volatile unsigned long *addr]\n- 调用者: ntfs_trim_fs\n- 被调用者: (未显示)\n\n6. 函数名: ntfs_discard\n- 参数: [struct ntfs_sb_info *sbi, CLST lcn, CLST len]\n- 调用者: ntfs_trim_fs\n- 被调用者: (未显示)\n\n7. 函数名: put_bh\n- 参数: [struct buffer_head *bh]\n- 调用者: ntfs_trim_fs\n- 被调用者: (未显示)\n\n8. 函数名: up_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: ntfs_trim_fs\n- 被调用者: (未显示)"
    },
    {
        "id": 3984,
        "cwe": "CWE-416",
        "cve": "CVE-2023-2985",
        "purpose": "Code purpose:\"\"\"该代码用于在卸载HFS+文件系统时执行清理操作，包括同步文件系统、关闭B树结构、释放分配的资源等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在hfsplus_put_super函数中，释放sbi->s_vhdr_buf后可能存在对已释放内存的后续访问，导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: hfsplus_put_super\n- 参数: [struct super_block *sb]\n- 调用者: 未显示（通常由内核VFS层调用）\n- 被调用者: [hfs_dbg, cancel_delayed_work_sync, sb_rdonly, hfsp_now2mt, cpu_to_be32, hfsplus_sync_fs, hfs_btree_close, iput, unload_nls, kfree]\n\n2. 函数名: hfs_dbg\n- 参数: [SUPER, \"hfsplus_put_super\\n\"]\n- 调用者: hfsplus_put_super\n- 被调用者: []\n\n3. 函数名: cancel_delayed_work_sync\n- 参数: [&sbi->sync_work]\n- 调用者: hfsplus_put_super\n- 被调用者: []\n\n4. 函数名: sb_rdonly\n- 参数: [sb]\n- 调用者: hfsplus_put_super\n- 被调用者: []\n\n5. 函数名: hfsp_now2mt\n- 参数: []\n- 调用者: hfsplus_put_super\n- 被调用者: []\n\n6. 函数名: cpu_to_be32\n- 参数: [HFSPLUS_VOL_UNMNT]\n- 调用者: hfsplus_put_super\n- 被调用者: []\n\n7. 函数名: cpu_to_be32\n- 参数: [~HFSPLUS_VOL_INCNSTNT]\n- 调用者: hfsplus_put_super\n- 被调用者: []\n\n8. 函数名: hfsplus_sync_fs\n- 参数: [sb, 1]\n- 调用者: hfsplus_put_super\n- 被调用者: []\n\n9. 函数名: hfs_btree_close\n- 参数: [sbi->attr_tree]\n- 调用者: hfsplus_put_super\n- 被调用者: []\n\n10. 函数名: hfs_btree_close\n- 参数: [sbi->cat_tree]\n- 调用者: hfsplus_put_super\n- 被调用者: []\n\n11. 函数名: hfs_btree_close\n- 参数: [sbi->ext_tree]\n- 调用者: hfsplus_put_super\n- 被调用者: []\n\n12. 函数名: iput\n- 参数: [sbi->alloc_file]\n- 调用者: hfsplus_put_super\n- 被调用者: []\n\n13. 函数名: iput\n- 参数: [sbi->hidden_dir]\n- 调用者: hfsplus_put_super\n- 被调用者: []\n\n14. 函数名: kfree\n- 参数: [sbi->s_vhdr_buf]\n- 调用者: hfsplus_put_super\n- 被调用者: []\n\n15. 函数名: kfree\n- 参数: [sbi->s_backup_vhdr_buf]\n- 调用者: hfsplus_put_super\n- 被调用者: []\n\n16. 函数名: unload_nls\n- 参数: [sbi->nls]\n- 调用者: hfsplus_put_super\n- 被调用者: []\n\n17. 函数名: kfree\n- 参数: [sb->s_fs_info]\n- 调用者: hfsplus_put_super\n- 被调用者: []"
    },
    {
        "id": 3989,
        "cwe": "CWE-416",
        "cve": "CVE-2023-30772",
        "purpose": "Code purpose:\"\"\"该代码用于在设备移除时释放充电器相关的IRQ资源、取消电源供应注册并释放ADC通道资源。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在设备移除过程中存在竞态条件，导致在释放中断请求和取消注册电源供应之间可能发生use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: da9150_charger_remove\n- 参数: [struct platform_device *pdev]\n- 调用者: platform driver unregister process\n- 被调用者: [platform_get_drvdata, platform_get_irq_byname, free_irq, IS_ERR_OR_NULL, usb_unregister_notifier, power_supply_unregister, iio_channel_release]\n\n2. 函数名: platform_get_drvdata\n- 参数: [struct platform_device *pdev]\n- 调用者: da9150_charger_remove\n- 被调用者: []\n\n3. 函数名: platform_get_irq_byname\n- 参数: [struct platform_device *pdev, const char *name]\n- 调用者: da9150_charger_remove\n- 被调用者: []\n\n4. 函数名: free_irq\n- 参数: [unsigned int irq, void *dev_id]\n- 调用者: da9150_charger_remove\n- 被调用者: []\n\n5. 函数名: IS_ERR_OR_NULL\n- 参数: [const void *ptr]\n- 调用者: da9150_charger_remove\n- 被调用者: []\n\n6. 函数名: usb_unregister_notifier\n- 参数: [struct usb_phy *phy, struct notifier_block *nb]\n- 调用者: da9150_charger_remove\n- 被调用者: []\n\n7. 函数名: power_supply_unregister\n- 参数: [struct power_supply *psy]\n- 调用者: da9150_charger_remove\n- 被调用者: []\n\n8. 函数名: iio_channel_release\n- 参数: [struct iio_channel *chan]\n- 调用者: da9150_charger_remove\n- 被调用者: []"
    },
    {
        "id": 3998,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3111",
        "purpose": "Code purpose:\"\"\"为Btrfs文件系统的重定位操作准备资源并启动事务处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在prepare_to_relocate函数中，当btrfs_join_transaction失败时，未正确释放rc->block_rsv资源，导致后续可能发生释放后使用(UAF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: prepare_to_relocate\n- 参数: [struct reloc_control *rc]\n- 调用者: 未明确（可能是外部调用）\n- 被调用者: [btrfs_alloc_block_rsv, memset, btrfs_block_rsv_refill, set_reloc_control, btrfs_join_transaction, unset_reloc_control, PTR_ERR, btrfs_commit_transaction]\n\n2. 函数名: btrfs_alloc_block_rsv\n- 参数: [rc->extent_root->fs_info, BTRFS_BLOCK_RSV_TEMP]\n- 调用者: prepare_to_relocate\n- 被调用者: 未明确\n\n3. 函数名: memset\n- 参数: [&rc->cluster, 0, sizeof(rc->cluster)]\n- 调用者: prepare_to_relocate\n- 被调用者: 无\n\n4. 函数名: btrfs_block_rsv_refill\n- 参数: [rc->extent_root->fs_info, rc->block_rsv, rc->block_rsv->size, BTRFS_RESERVE_FLUSH_ALL]\n- 调用者: prepare_to_relocate\n- 被调用者: 未明确\n\n5. 函数名: set_reloc_control\n- 参数: [rc]\n- 调用者: prepare_to_relocate\n- 被调用者: 未明确\n\n6. 函数名: btrfs_join_transaction\n- 参数: [rc->extent_root]\n- 调用者: prepare_to_relocate\n- 被调用者: 未明确\n\n7. 函数名: unset_reloc_control\n- 参数: [rc]\n- 调用者: prepare_to_relocate\n- 被调用者: 未明确\n\n8. 函数名: PTR_ERR\n- 参数: [trans]\n- 调用者: prepare_to_relocate\n- 被调用者: 无\n\n9. 函数名: btrfs_commit_transaction\n- 参数: [trans]\n- 调用者: prepare_to_relocate\n- 被调用者: 未明确"
    },
    {
        "id": 4000,
        "cwe": "CWE-416",
        "cve": "CVE-2023-31248",
        "purpose": "Code purpose:\"\"\"该代码用于初始化nftables的判决(verdict)数据，包括验证判决类型和处理跳转/转向到指定链的逻辑\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"nft_chain_lookup_byid()函数未能验证查找的chain是否处于活动状态，且未检查CAP_NET_ADMIN权限，导致存在use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_verdict_init\n- 参数: [const struct nft_ctx *ctx, struct nft_data *data, struct nft_data_desc *desc, const struct nlattr *nla]\n- 调用者: (未显示)\n- 被调用者: [nla_parse_nested_deprecated, ntohl, nla_get_be32, nft_chain_lookup, nft_chain_lookup_byid, nft_is_base_chain, nft_chain_is_bound, nft_use_inc]\n\n2. 函数名: nla_parse_nested_deprecated\n- 参数: (未完全显示，至少包括[tb, NFTA_VERDICT_MAX, nla, nft_verdict_policy, NULL])\n- 调用者: nft_verdict_init\n- 被调用者: (未显示)\n\n3. 函数名: ntohl\n- 参数: (未显示)\n- 调用者: nft_verdict_init\n- 被调用者: (未显示)\n\n4. 函数名: nla_get_be32\n- 参数: (未显示)\n- 调用者: nft_verdict_init\n- 被调用者: (未显示)\n\n5. 函数名: nft_chain_lookup\n- 参数: [ctx->net, ctx->table, tb[NFTA_VERDICT_CHAIN], genmask]\n- 调用者: nft_verdict_init\n- 被调用者: (未显示)\n\n6. 函数名: nft_chain_lookup_byid\n- 参数: [ctx->net, ctx->table, tb[NFTA_VERDICT_CHAIN_ID]]\n- 调用者: nft_verdict_init\n- 被调用者: (未显示)\n\n7. 函数名: nft_is_base_chain\n- 参数: [chain]\n- 调用者: nft_verdict_init\n- 被调用者: (未显示)\n\n8. 函数名: nft_chain_is_bound\n- 参数: [chain]\n- 调用者: nft_verdict_init\n- 被调用者: (未显示)\n\n9. 函数名: nft_use_inc\n- 参数: [&chain->use]\n- 调用者: nft_verdict_init\n- 被调用者: (未显示)"
    },
    {
        "id": 4001,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3141",
        "purpose": "Code purpose:\"\"\"该代码用于在设备断开连接时清理和释放相关资源，包括停止处理线程、释放DMA内存、中断和PCI资源等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在r592_remove函数中，存在对已释放资源dev的后续使用，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: r592_remove\n- 参数: [struct pci_dev *pdev]\n- 调用者: 未显示（通常由PCI子系统调用）\n- 被调用者: [pci_get_drvdata, kthread_stop, r592_enable_device, memstick_next_req, memstick_remove_host, dma_free_coherent, free_irq, iounmap, pci_release_regions, pci_disable_device, memstick_free_host]\n\n2. 函数名: pci_get_drvdata\n- 参数: [struct pci_dev *pdev]\n- 调用者: r592_remove\n- 被调用者: []\n\n3. 函数名: kthread_stop\n- 参数: [dev->io_thread]\n- 调用者: r592_remove\n- 被调用者: []\n\n4. 函数名: r592_enable_device\n- 参数: [struct r592_device *dev, bool false]\n- 调用者: r592_remove\n- 被调用者: []\n\n5. 函数名: memstick_next_req\n- 参数: [dev->host, &dev->req]\n- 调用者: r592_remove\n- 被调用者: []\n\n6. 函数名: memstick_remove_host\n- 参数: [dev->host]\n- 调用者: r592_remove\n- 被调用者: []\n\n7. 函数名: dma_free_coherent\n- 参数: [&pdev->dev, PAGE_SIZE, dev->dummy_dma_page, dev->dummy_dma_page_physical_address]\n- 调用者: r592_remove\n- 被调用者: []\n\n8. 函数名: free_irq\n- 参数: [dev->irq, dev]\n- 调用者: r592_remove\n- 被调用者: []\n\n9. 函数名: iounmap\n- 参数: [dev->mmio]\n- 调用者: r592_remove\n- 被调用者: []\n\n10. 函数名: pci_release_regions\n- 参数: [struct pci_dev *pdev]\n- 调用者: r592_remove\n- 被调用者: []\n\n11. 函数名: pci_disable_device\n- 参数: [struct pci_dev *pdev]\n- 调用者: r592_remove\n- 被调用者: []\n\n12. 函数名: memstick_free_host\n- 参数: [dev->host]\n- 调用者: r592_remove\n- 被调用者: []"
    },
    {
        "id": 4003,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3159",
        "purpose": "Code purpose:\"\"\"处理火线(FireWire)外发物理层数据包的回调函数，根据状态设置响应码并通过队列事件通知客户端\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当queue_event()调用失败时，会导致在释放e->client后仍被client_put()使用，造成释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: outbound_phy_packet_callback\n- 参数: [struct fw_packet *packet, struct fw_card *card, int status]\n- 调用者: (未明确显示，应为firewire驱动相关代码)\n- 被调用者: [container_of, queue_event, client_put]\n\n2. 函数名: container_of\n- 参数: (未显示完整，通常为[ptr, type, member])\n- 调用者: outbound_phy_packet_callback\n- 被调用者: []\n\n3. 函数名: queue_event\n- 参数: (根据调用推断为[e->client, &e->event, &e->phy_packet, sizeof(e->phy_packet) + e->phy_packet.length, NULL, 0])\n- 调用者: outbound_phy_packet_callback\n- 被调用者: []\n\n4. 函数名: client_put\n- 参数: [e->client]\n- 调用者: outbound_phy_packet_callback\n- 被调用者: []"
    },
    {
        "id": 4006,
        "cwe": "CWE-416",
        "cve": "CVE-2023-32233",
        "purpose": "Code purpose:\"\"\"该代码用于处理Netfilter nf_tables中集合的停用操作，根据不同的传输阶段调整集合的使用计数并执行解绑操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于匿名集合处理不当，在Netfilter nf_tables处理批量请求时出现释放后使用漏洞，导致内核内存的任意读写。\"\"\"",
        "functions": "Functions:\n1. 函数名: nf_tables_deactivate_set\n- 参数: [const struct nft_ctx *ctx, struct nft_set *set, struct nft_set_binding *binding, enum nft_trans_phase phase]\n- 调用者: 未明确（由Netfilter框架调用）\n- 被调用者: [nf_tables_unbind_set]\n\n2. 函数名: nf_tables_unbind_set\n- 参数: [const struct nft_ctx *ctx, struct nft_set *set, struct nft_set_binding *binding, bool commit]\n- 调用者: nf_tables_deactivate_set\n- 被调用者: 未明确"
    },
    {
        "id": 4007,
        "cwe": "CWE-416",
        "cve": "CVE-2023-32233",
        "purpose": "Code purpose:\"\"\"增加动态集合的使用计数以实现激活操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于匿名集合处理不当导致Netfilter nf_tables在处理批量请求时出现释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_dynset_activate\n- 参数: [const struct nft_ctx *ctx, const struct nft_expr *expr]\n- 调用者: 未明确显示（由Netfilter nf_tables模块调用）\n- 被调用者: [nft_expr_priv]\n\n2. 函数名: nft_expr_priv\n- 参数: [const struct nft_expr *expr]\n- 调用者: nft_dynset_activate\n- 被调用者: []"
    },
    {
        "id": 4008,
        "cwe": "CWE-416",
        "cve": "CVE-2023-32233",
        "purpose": "Code purpose:\"\"\"增加Netfilter nf_tables中匿名集合的使用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于匿名集合处理不当导致Netfilter nf_tables在处理批量请求时出现释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_lookup_activate\n- 参数: [const struct nft_ctx *ctx, const struct nft_expr *expr]\n- 调用者: 未明确（由Netfilter nf_tables模块调用）\n- 被调用者: [nft_expr_priv]\n\n2. 函数名: nft_expr_priv\n- 参数: [const struct nft_expr *expr]\n- 调用者: nft_lookup_activate\n- 被调用者: 未明确（通常为内核内部函数）"
    },
    {
        "id": 4009,
        "cwe": "CWE-416",
        "cve": "CVE-2023-32233",
        "purpose": "Code purpose:\"\"\"增加匿名集合的使用计数以跟踪其引用情况\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于匿名集合处理不当导致Netfilter nf_tables在处理批量请求时出现释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_objref_map_activate\n- 参数: [const struct nft_ctx *ctx, const struct nft_expr *expr]\n- 调用者: 未明确（由Netfilter nf_tables模块调用）\n- 被调用者: [nft_expr_priv]\n\n2. 函数名: nft_expr_priv\n- 参数: [const struct nft_expr *expr]\n- 调用者: nft_objref_map_activate\n- 被调用者: []"
    },
    {
        "id": 4051,
        "cwe": "CWE-416",
        "cve": "CVE-2023-32269",
        "purpose": "Code purpose:\"\"\"该代码用于处理NET/ROM协议套接字的监听状态设置，包括初始化用户地址、设置最大连接队列长度和状态转换\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核的netrom实现中，对已成功连接的AF_NETROM套接字允许accept操作，导致释放后重用(use-after-free)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: nr_listen\n- 参数: [struct socket *sock, int backlog]\n- 调用者: 未明确（应为内核中调用socket listen操作的相关代码）\n- 被调用者: [lock_sock, memset, release_sock]\n\n2. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: nr_listen\n- 被调用者: 未明确（内核内部实现）\n\n3. 函数名: memset\n- 参数: [&nr_sk(sk)->user_addr, 0, AX25_ADDR_LEN]\n- 调用者: nr_listen\n- 被调用者: 未明确（标准库函数）\n\n4. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: nr_listen\n- 被调用者: 未明确（内核内部实现）"
    },
    {
        "id": 4053,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3269",
        "purpose": "Code purpose:\"\"\"处理用户空间内存访问引发的页错误，包括地址验证、内存区域查找、权限检查以及错误处理等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核内存管理子系统中，虚拟内存区域(VMA)的锁处理不正确，导致在访问和更新VMA时可能出现释放后使用(use-after-free)问题\"\"\"",
        "functions": "Functions:\n1. 函数名: do_user_addr_fault\n- 参数: [struct pt_regs *regs, unsigned long error_code, unsigned long address]\n- 调用者: N/A (kernel page fault handler)\n- 被调用者: [is_errata93, page_fault_oops, kprobe_page_fault, pgtable_bad, cpu_feature_enabled, bad_area_nosemaphore, user_mode, local_irq_enable, perf_sw_event, is_vsyscall_vaddr, emulate_vsyscall, lock_vma_under_rcu, handle_mm_fault, vma_end_read, fault_signal_pending, kernelmode_fixup_or_oops, search_exception_tables, mmap_read_trylock, mmap_read_lock, might_sleep, find_vma, expand_stack, bad_area, bad_area_access_error, mmap_read_unlock, fatal_signal_pending, pagefault_out_of_memory, do_sigbus, BUG]\n\n2. 函数名: is_errata93\n- 参数: [struct pt_regs *regs, unsigned long address]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n3. 函数名: page_fault_oops\n- 参数: [struct pt_regs *regs, unsigned long error_code, unsigned long address]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n4. 函数名: kprobe_page_fault\n- 参数: [struct pt_regs *regs, X86_TRAP_PF]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n5. 函数名: pgtable_bad\n- 参数: [struct pt_regs *regs, unsigned long error_code, unsigned long address]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n6. 函数名: cpu_feature_enabled\n- 参数: [X86_FEATURE_SMAP]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n7. 函数名: bad_area_nosemaphore\n- 参数: [struct pt_regs *regs, unsigned long error_code, unsigned long address]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n8. 函数名: user_mode\n- 参数: [struct pt_regs *regs]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n9. 函数名: local_irq_enable\n- 参数: []\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n10. 函数名: perf_sw_event\n- 参数: [PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n11. 函数名: is_vsyscall_vaddr\n- 参数: [address]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n12. 函数名: emulate_vsyscall\n- 参数: [error_code, regs, address]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n13. 函数名: lock_vma_under_rcu\n- 参数: [struct mm_struct *mm, unsigned long address]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n14. 函数名: handle_mm_fault\n- 参数: [struct vm_area_struct *vma, unsigned long address, flags | FAULT_FLAG_VMA_LOCK, regs]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n15. 函数名: vma_end_read\n- 参数: [struct vm_area_struct *vma]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n16. 函数名: fault_signal_pending\n- 参数: [vm_fault_t fault, struct pt_regs *regs]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n17. 函数名: kernelmode_fixup_or_oops\n- 参数: [struct pt_regs *regs, unsigned long error_code, unsigned long address, SIGBUS, BUS_ADRERR, ARCH_DEFAULT_PKEY]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n18. 函数名: search_exception_tables\n- 参数: [regs->ip]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n19. 函数名: mmap_read_trylock\n- 参数: [struct mm_struct *mm]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n20. 函数名: mmap_read_lock\n- 参数: [struct mm_struct *mm]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n21. 函数名: might_sleep\n- 参数: []\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n22. 函数名: find_vma\n- 参数: [struct mm_struct *mm, unsigned long address]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n23. 函数名: expand_stack\n- 参数: [struct vm_area_struct *vma, unsigned long address]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n24. 函数名: bad_area\n- 参数: [struct pt_regs *regs, unsigned long error_code, unsigned long address]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n25. 函数名: bad_area_access_error\n- 参数: [struct pt_regs *regs, unsigned long error_code, unsigned long address, struct vm_area_struct *vma]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n26. 函数名: mmap_read_unlock\n- 参数: [struct mm_struct *mm]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n27. 函数名: fatal_signal_pending\n- 参数: [current]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n28. 函数名: pagefault_out_of_memory\n- 参数: []\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n29. 函数名: do_sigbus\n- 参数: [struct pt_regs *regs, unsigned long error_code, unsigned long address, vm_fault_t fault]\n- 调用者: do_user_addr_fault\n- 被调用者: []\n\n30. 函数名: BUG\n- 参数: []\n- 调用者: do_user_addr_fault\n- 被调用者: []"
    },
    {
        "id": 4056,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3317",
        "purpose": "Code purpose:\"\"\"该代码用于检查MT7921 WiFi设备的固件卸载能力，解析固件特征信息并返回相关数据。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放'features'内存后仍可能被访问，导致释放后使用(UAF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: mt7921_check_offload_capability\n- 参数: [dev, fw_wm]\n- 调用者: 未显示\n- 被调用者: [request_firmware, dev_err, le32_to_cpu, le16_to_cpu, release_firmware]\n\n2. 函数名: request_firmware\n- 参数: [&fw, fw_wm, dev]\n- 调用者: mt7921_check_offload_capability\n- 被调用者: 未显示\n\n3. 函数名: dev_err\n- 参数: [dev, \"Invalid firmware\"]\n- 调用者: mt7921_check_offload_capability\n- 被调用者: 未显示\n\n4. 函数名: le32_to_cpu\n- 参数: [region->len]\n- 调用者: mt7921_check_offload_capability\n- 被调用者: 未显示\n\n5. 函数名: le16_to_cpu\n- 参数: [rel_info->len]\n- 调用者: mt7921_check_offload_capability\n- 被调用者: 未显示\n\n6. 函数名: release_firmware\n- 参数: [fw]\n- 调用者: mt7921_check_offload_capability\n- 被调用者: 未显示"
    },
    {
        "id": 4058,
        "cwe": "CWE-416",
        "cve": "CVE-2023-33250",
        "purpose": "Code purpose:\"\"\"该代码用于解除IOMMU页表中指定IOVA地址范围的页面访问权限映射\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在iommufd_access_unpin_pages函数中，由于未正确管理内存释放后的访问，导致在iopt_unmap_iova_range操作中可能发生释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: iommufd_access_unpin_pages\n- 参数: [access, iova, length]\n- 调用者: 未显示\n- 被调用者: [WARN_ON, check_add_overflow, down_read, iopt_for_each_contig_area, iopt_area_remove_access, iopt_area_iova_to_index, min, iopt_area_last_iova, up_read, iopt_area_contig_done]\n\n2. 函数名: WARN_ON\n- 参数: [condition]\n- 调用者: iommufd_access_unpin_pages\n- 被调用者: 未显示\n\n3. 函数名: check_add_overflow\n- 参数: [a, b, res]\n- 调用者: iommufd_access_unpin_pages\n- 被调用者: 未显示\n\n4. 函数名: down_read\n- 参数: [sem]\n- 调用者: iommufd_access_unpin_pages\n- 被调用者: 未显示\n\n5. 函数名: iopt_for_each_contig_area\n- 参数: [iter, area, iopt, iova, last_iova]\n- 调用者: iommufd_access_unpin_pages\n- 被调用者: 未显示\n\n6. 函数名: iopt_area_remove_access\n- 参数: [area, start_index, last_index]\n- 调用者: iommufd_access_unpin_pages\n- 被调用者: 未显示\n\n7. 函数名: iopt_area_iova_to_index\n- 参数: [area, iova]\n- 调用者: iommufd_access_unpin_pages\n- 被调用者: 未显示\n\n8. 函数名: min\n- 参数: [a, b]\n- 调用者: iommufd_access_unpin_pages\n- 被调用者: 未显示\n\n9. 函数名: iopt_area_last_iova\n- 参数: [area]\n- 调用者: iommufd_access_unpin_pages\n- 被调用者: 未显示\n\n10. 函数名: up_read\n- 参数: [sem]\n- 调用者: iommufd_access_unpin_pages\n- 被调用者: 未显示\n\n11. 函数名: iopt_area_contig_done\n- 参数: [iter]\n- 调用者: iommufd_access_unpin_pages\n- 被调用者: 未显示"
    },
    {
        "id": 4059,
        "cwe": "CWE-416",
        "cve": "CVE-2023-33288",
        "purpose": "Code purpose:\"\"\"该代码用于在移除i2c客户端时，清理bq24190充电器设备的相关资源，包括电源供应注册和运行时电源管理设置。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在bq24190_remove函数中存在竞态条件，导致在电源管理运行时状态操作期间可能发生释放后使用(UAF)问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: bq24190_remove\n- 参数: [struct i2c_client *client]\n- 调用者: 内核驱动框架\n- 被调用者: [i2c_get_clientdata, pm_runtime_resume_and_get, dev_warn, bq24190_register_reset, power_supply_unregister, pm_runtime_put_sync, pm_runtime_dont_use_autosuspend, pm_runtime_disable]\n\n2. 函数名: i2c_get_clientdata\n- 参数: [struct i2c_client *client]\n- 调用者: bq24190_remove\n- 被调用者: []\n\n3. 函数名: pm_runtime_resume_and_get\n- 参数: [struct device *dev]\n- 调用者: bq24190_remove\n- 被调用者: []\n\n4. 函数名: dev_warn\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: bq24190_remove\n- 被调用者: []\n\n5. 函数名: bq24190_register_reset\n- 参数: [struct bq24190_dev_info *bdi]\n- 调用者: bq24190_remove\n- 被调用者: []\n\n6. 函数名: power_supply_unregister\n- 参数: [struct power_supply *psy]\n- 调用者: bq24190_remove\n- 被调用者: []\n\n7. 函数名: pm_runtime_put_sync\n- 参数: [struct device *dev]\n- 调用者: bq24190_remove\n- 被调用者: []\n\n8. 函数名: pm_runtime_dont_use_autosuspend\n- 参数: [struct device *dev]\n- 调用者: bq24190_remove\n- 被调用者: []\n\n9. 函数名: pm_runtime_disable\n- 参数: [struct device *dev]\n- 调用者: bq24190_remove\n- 被调用者: []"
    },
    {
        "id": 4065,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3389",
        "purpose": "Code purpose:\"\"\"该代码用于在io_uring上下文关闭时，安全地清理资源、取消挂起的操作并安排退出工作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring子系统中，取消轮询请求与链接超时竞争导致hrtimer的释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_ring_ctx_wait_and_kill\n- 参数: [struct io_ring_ctx *ctx]\n- 调用者: 未显示\n- 被调用者: [mutex_lock, percpu_ref_kill, __io_cqring_overflow_flush, xa_for_each, io_unregister_personality, mutex_unlock, io_kill_timeouts, io_poll_remove_all, io_iopoll_try_reap_events, INIT_WORK, queue_work]\n\n2. 函数名: mutex_lock\n- 参数: [&ctx->uring_lock]\n- 调用者: io_ring_ctx_wait_and_kill\n- 被调用者: 未显示\n\n3. 函数名: percpu_ref_kill\n- 参数: [&ctx->refs]\n- 调用者: io_ring_ctx_wait_and_kill\n- 被调用者: 未显示\n\n4. 函数名: __io_cqring_overflow_flush\n- 参数: [ctx, true]\n- 调用者: io_ring_ctx_wait_and_kill\n- 被调用者: 未显示\n\n5. 函数名: xa_for_each\n- 参数: [&ctx->personalities, index, creds]\n- 调用者: io_ring_ctx_wait_and_kill\n- 被调用者: 未显示\n\n6. 函数名: io_unregister_personality\n- 参数: [ctx, index]\n- 调用者: io_ring_ctx_wait_and_kill\n- 被调用者: 未显示\n\n7. 函数名: mutex_unlock\n- 参数: [&ctx->uring_lock]\n- 调用者: io_ring_ctx_wait_and_kill\n- 被调用者: 未显示\n\n8. 函数名: io_kill_timeouts\n- 参数: [ctx, NULL, true]\n- 调用者: io_ring_ctx_wait_and_kill\n- 被调用者: 未显示\n\n9. 函数名: io_poll_remove_all\n- 参数: [ctx, NULL, true]\n- 调用者: io_ring_ctx_wait_and_kill\n- 被调用者: 未显示\n\n10. 函数名: io_iopoll_try_reap_events\n- 参数: [ctx]\n- 调用者: io_ring_ctx_wait_and_kill\n- 被调用者: 未显示\n\n11. 函数名: INIT_WORK\n- 参数: [&ctx->exit_work, io_ring_exit_work]\n- 调用者: io_ring_ctx_wait_and_kill\n- 被调用者: 未显示\n\n12. 函数名: queue_work\n- 参数: [system_unbound_wq, &ctx->exit_work]\n- 调用者: io_ring_ctx_wait_and_kill\n- 被调用者: 未显示"
    },
    {
        "id": 4066,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3389",
        "purpose": "Code purpose:\"\"\"该代码用于在io_uring子系统中尝试取消请求，包括轮询请求、延迟文件、超时等操作，并处理相关资源清理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring子系统中，取消轮询请求与链接超时之间存在竞争条件，导致hrtimer的使用后释放(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_uring_try_cancel_requests\n- 参数: [struct io_ring_ctx *ctx, struct task_struct *task, bool cancel_all]\n- 调用者: N/A\n- 被调用者: [io_uring_try_cancel_iowq, io_wq_cancel_cb, io_cancel_task_cb, io_iopoll_try_reap_events, io_cancel_defer_files, io_poll_remove_all, io_kill_timeouts, io_run_task_work, cond_resched]\n\n2. 函数名: io_uring_try_cancel_iowq\n- 参数: [struct io_ring_ctx *ctx]\n- 调用者: io_uring_try_cancel_requests\n- 被调用者: N/A\n\n3. 函数名: io_wq_cancel_cb\n- 参数: [struct io_wq *wq, io_cancel_cb_t cb, void *data, bool cancel_all]\n- 调用者: io_uring_try_cancel_requests\n- 被调用者: N/A\n\n4. 函数名: io_cancel_task_cb\n- 参数: [struct io_wq_work *work, void *data]\n- 调用者: io_wq_cancel_cb\n- 被调用者: N/A\n\n5. 函数名: io_iopoll_try_reap_events\n- 参数: [struct io_ring_ctx *ctx]\n- 调用者: io_uring_try_cancel_requests\n- 被调用者: N/A\n\n6. 函数名: io_cancel_defer_files\n- 参数: [struct io_ring_ctx *ctx, struct task_struct *task, bool cancel_all]\n- 调用者: io_uring_try_cancel_requests\n- 被调用者: N/A\n\n7. 函数名: io_poll_remove_all\n- 参数: [struct io_ring_ctx *ctx, struct task_struct *task, bool cancel_all]\n- 调用者: io_uring_try_cancel_requests\n- 被调用者: N/A\n\n8. 函数名: io_kill_timeouts\n- 参数: [struct io_ring_ctx *ctx, struct task_struct *task, bool cancel_all]\n- 调用者: io_uring_try_cancel_requests\n- 被调用者: N/A\n\n9. 函数名: io_run_task_work\n- 参数: []\n- 调用者: io_uring_try_cancel_requests\n- 被调用者: N/A\n\n10. 函数名: cond_resched\n- 参数: []\n- 调用者: io_uring_try_cancel_requests\n- 被调用者: N/A"
    },
    {
        "id": 4067,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3389",
        "purpose": "Code purpose:\"\"\"分配并初始化io_uring子系统的上下文结构体，包括各种锁、列表和资源的初始化\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring子系统中，取消轮询请求与链接超时竞争导致hrtimer的使用后释放(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_ring_ctx_alloc\n- 参数: [struct io_uring_params *p]\n- 调用者: 未显示\n- 被调用者: [kzalloc, xa_init, ilog2, clamp, io_alloc_hash_table, kfree, percpu_ref_init, init_waitqueue_head, INIT_LIST_HEAD, init_completion, xa_init_flags, mutex_init, spin_lock_init, INIT_WQ_LIST, INIT_DELAYED_WORK, init_llist_head, xa_destroy]\n\n2. 函数名: io_alloc_hash_table\n- 参数: [未显示]\n- 调用者: io_ring_ctx_alloc\n- 被调用者: []\n\n3. 函数名: io_ring_ctx_ref_free\n- 参数: [未显示]\n- 调用者: percpu_ref_init\n- 被调用者: []\n\n4. 函数名: io_import_fixed\n- 参数: [未显示]\n- 调用者: 未显示(代码中仅被引用)\n- 被调用者: []\n\n5. 函数名: io_rsrc_put_work\n- 参数: [未显示]\n- 调用者: INIT_DELAYED_WORK\n- 被调用者: []\n\n6. 函数名: io_fallback_req_func\n- 参数: [未显示]\n- 调用者: INIT_DELAYED_WORK\n- 被调用者: []"
    },
    {
        "id": 4068,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3389",
        "purpose": "Code purpose:\"\"\"释放io_ring_ctx结构体及其相关资源，清理io_uring子系统的上下文环境\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring子系统中，取消轮询请求与链接超时竞争导致hrtimer的释放后使用(UAF)。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_ring_ctx_free\n- 参数: [ctx]\n- 调用者: 未显示\n- 被调用者: [io_sq_thread_finish, mmdrop, io_rsrc_refs_drop, io_wait_rsrc_data, mutex_lock, __io_sqe_buffers_unregister, __io_sqe_files_unregister, __io_cqring_overflow_flush, io_eventfd_unregister, io_flush_apoll_cache, mutex_unlock, io_destroy_buffers, put_cred, put_task_struct, io_rsrc_node_destroy, flush_delayed_work, sock_release, io_mem_free, percpu_ref_exit, free_uid, io_req_caches_free, io_wq_put_hash, kfree, xa_destroy]\n\n2. 函数名: io_sq_thread_finish\n- 参数: [ctx]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示\n\n3. 函数名: mmdrop\n- 参数: [ctx->mm_account]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示\n\n4. 函数名: io_rsrc_refs_drop\n- 参数: [ctx]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示\n\n5. 函数名: io_wait_rsrc_data\n- 参数: [ctx->buf_data], [ctx->file_data]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示\n\n6. 函数名: mutex_lock\n- 参数: [&ctx->uring_lock]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示\n\n7. 函数名: __io_sqe_buffers_unregister\n- 参数: [ctx]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示\n\n8. 函数名: __io_sqe_files_unregister\n- 参数: [ctx]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示\n\n9. 函数名: __io_cqring_overflow_flush\n- 参数: [ctx, true]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示\n\n10. 函数名: io_eventfd_unregister\n- 参数: [ctx]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示\n\n11. 函数名: io_flush_apoll_cache\n- 参数: [ctx]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示\n\n12. 函数名: mutex_unlock\n- 参数: [&ctx->uring_lock]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示\n\n13. 函数名: io_destroy_buffers\n- 参数: [ctx]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示\n\n14. 函数名: put_cred\n- 参数: [ctx->sq_creds]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示\n\n15. 函数名: put_task_struct\n- 参数: [ctx->submitter_task]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示\n\n16. 函数名: io_rsrc_node_destroy\n- 参数: [ctx->rsrc_node], [ctx->rsrc_backup_node]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示\n\n17. 函数名: flush_delayed_work\n- 参数: [&ctx->rsrc_put_work], [&ctx->fallback_work]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示\n\n18. 函数名: sock_release\n- 参数: [ctx->ring_sock]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示\n\n19. 函数名: io_mem_free\n- 参数: [ctx->rings], [ctx->sq_sqes]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示\n\n20. 函数名: percpu_ref_exit\n- 参数: [&ctx->refs]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示\n\n21. 函数名: free_uid\n- 参数: [ctx->user]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示\n\n22. 函数名: io_req_caches_free\n- 参数: [ctx]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示\n\n23. 函数名: io_wq_put_hash\n- 参数: [ctx->hash_map]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示\n\n24. 函数名: kfree\n- 参数: [ctx->cancel_table.hbs], [ctx->dummy_ubuf], [ctx->io_bl], [ctx]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示\n\n25. 函数名: xa_destroy\n- 参数: [&ctx->io_bl_xa]\n- 调用者: io_ring_ctx_free\n- 被调用者: 未显示"
    },
    {
        "id": 4069,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3389",
        "purpose": "Code purpose:\"\"\"该代码用于处理io_uring子系统中轮询请求的移除和更新操作，包括查找、解除绑定和更新轮询事件或用户数据等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring子系统中，取消轮询请求与链接超时竞争时，由于未正确处理hrtimer的使用后释放问题，导致UAF漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_poll_remove\n- 参数: [struct io_kiocb *req, unsigned int issue_flags]\n- 调用者: 未明确（由内核调用）\n- 被调用者: [io_kiocb_to_cmd, io_poll_find, io_poll_disarm, spin_unlock, io_poll_add, req_set_fail, io_req_set_res, io_req_task_complete]\n\n2. 函数名: io_kiocb_to_cmd\n- 参数: [struct io_kiocb *req]\n- 调用者: io_poll_remove\n- 被调用者: 未明确\n\n3. 函数名: io_poll_find\n- 参数: [struct io_ring_ctx *ctx, bool, struct io_cancel_data *cd, struct io_hash_table *table, struct io_hash_bucket **bucket]\n- 调用者: io_poll_remove\n- 被调用者: 未明确\n\n4. 函数名: io_poll_disarm\n- 参数: [struct io_kiocb *preq]\n- 调用者: io_poll_remove\n- 被调用者: 未明确\n\n5. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: io_poll_remove\n- 被调用者: 未明确\n\n6. 函数名: io_poll_add\n- 参数: [struct io_kiocb *preq, unsigned int issue_flags]\n- 调用者: io_poll_remove\n- 被调用者: 未明确\n\n7. 函数名: req_set_fail\n- 参数: [struct io_kiocb *req]\n- 调用者: io_poll_remove\n- 被调用者: 未明确\n\n8. 函数名: io_req_set_res\n- 参数: [struct io_kiocb *req, int res, unsigned int cflags]\n- 调用者: io_poll_remove\n- 被调用者: 未明确\n\n9. 函数名: io_req_task_complete\n- 参数: [struct io_kiocb *req, bool *locked]\n- 调用者: io_poll_remove\n- 被调用者: 未明确"
    },
    {
        "id": 4070,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3389",
        "purpose": "Code purpose:\"\"\"该代码用于处理Linux内核io_uring子系统的异步轮询请求，包括设置轮询掩码、管理异步轮询结构体以及处理相关事件\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring子系统中，取消轮询请求与链接超时竞争时，会导致hrtimer的使用后释放(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_arm_poll_handler\n- 参数: [struct io_kiocb *req, unsigned issue_flags]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [file_can_poll, kfree, kmalloc, __io_arm_poll_handler, trace_io_uring_poll_arm, io_kbuf_recycle]\n\n2. 函数名: file_can_poll\n- 参数: [struct file *file]\n- 调用者: io_arm_poll_handler\n- 被调用者: 未显示\n\n3. 函数名: kfree\n- 参数: [void *ptr]\n- 调用者: io_arm_poll_handler\n- 被调用者: 未显示\n\n4. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: io_arm_poll_handler\n- 被调用者: 未显示\n\n5. 函数名: __io_arm_poll_handler\n- 参数: [struct io_kiocb *req, struct io_poll *poll, struct io_poll_table *pt, __poll_t mask]\n- 调用者: io_arm_poll_handler\n- 被调用者: 未显示\n\n6. 函数名: trace_io_uring_poll_arm\n- 参数: [struct io_ring_ctx *ctx, struct io_kiocb *req, u64 user_data, int opcode, __poll_t mask, __poll_t events]\n- 调用者: io_arm_poll_handler\n- 被调用者: 未显示\n\n7. 函数名: io_kbuf_recycle\n- 参数: [struct io_kiocb *req, unsigned issue_flags]\n- 调用者: io_arm_poll_handler\n- 被调用者: 未显示"
    },
    {
        "id": 4071,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3389",
        "purpose": "Code purpose:\"\"\"该代码用于处理Linux内核io_uring子系统的poll请求，包括添加poll处理程序和错误处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring子系统中，取消轮询请求与链接超时竞争导致hrtimer出现释放后使用(UAF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: io_poll_add\n- 参数: [struct io_kiocb *req, unsigned int issue_flags]\n- 调用者: 未明确（由io_uring子系统调用）\n- 被调用者: [io_kiocb_to_cmd, __io_arm_poll_handler, io_req_set_res, req_set_fail]\n\n2. 函数名: io_kiocb_to_cmd\n- 参数: [struct io_kiocb *req]\n- 调用者: io_poll_add\n- 被调用者: []\n\n3. 函数名: __io_arm_poll_handler\n- 参数: [struct io_kiocb *req, struct io_poll *poll, struct io_poll_table *ipt, unsigned int events]\n- 调用者: io_poll_add\n- 被调用者: []\n\n4. 函数名: io_req_set_res\n- 参数: [struct io_kiocb *req, int ret, int value]\n- 调用者: io_poll_add\n- 被调用者: []\n\n5. 函数名: req_set_fail\n- 参数: [struct io_kiocb *req]\n- 调用者: io_poll_add\n- 被调用者: []"
    },
    {
        "id": 4072,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3389",
        "purpose": "Code purpose:\"\"\"处理io_uring子系统的轮询任务，检查事件并完成或删除请求\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring子系统中，取消轮询请求与链接超时竞争导致hrtimer释放后使用(UAF)。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_apoll_task_func\n- 参数: [req, locked]\n- 调用者: 未明确（由io_uring子系统调用）\n- 被调用者: [io_poll_check_events, io_poll_remove_entries, io_poll_req_delete, io_req_task_submit, io_req_complete_failed]\n\n2. 函数名: io_poll_check_events\n- 参数: [req, locked]\n- 调用者: io_apoll_task_func\n- 被调用者: []\n\n3. 函数名: io_poll_remove_entries\n- 参数: [req]\n- 调用者: io_apoll_task_func\n- 被调用者: []\n\n4. 函数名: io_poll_req_delete\n- 参数: [req, req->ctx]\n- 调用者: io_apoll_task_func\n- 被调用者: []\n\n5. 函数名: io_req_task_submit\n- 参数: [req, locked]\n- 调用者: io_apoll_task_func\n- 被调用者: []\n\n6. 函数名: io_req_complete_failed\n- 参数: [req, ret]\n- 调用者: io_apoll_task_func\n- 被调用者: []"
    },
    {
        "id": 4073,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3389",
        "purpose": "Code purpose:\"\"\"处理io_uring子系统的轮询任务，检查事件并完成请求处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring子系统中，取消轮询请求与链接超时竞争导致hrtimer的释放后使用(UAF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: io_poll_task_func\n- 参数: [struct io_kiocb *req, bool *locked]\n- 调用者: 未明确（由系统调用或内核其他部分调用）\n- 被调用者: [io_poll_check_events, mangle_poll, io_poll_remove_entries, io_poll_req_delete, io_req_set_res, io_req_task_complete]\n\n2. 函数名: io_poll_check_events\n- 参数: [struct io_kiocb *req, bool *locked]\n- 调用者: io_poll_task_func\n- 被调用者: 未明确\n\n3. 函数名: mangle_poll\n- 参数: [req->cqe.res & poll->events]\n- 调用者: io_poll_task_func\n- 被调用者: 未明确\n\n4. 函数名: io_poll_remove_entries\n- 参数: [struct io_kiocb *req]\n- 调用者: io_poll_task_func\n- 被调用者: 未明确\n\n5. 函数名: io_poll_req_delete\n- 参数: [struct io_kiocb *req, struct io_ring_ctx *ctx]\n- 调用者: io_poll_task_func\n- 被调用者: 未明确\n\n6. 函数名: io_req_set_res\n- 参数: [struct io_kiocb *req, req->cqe.res, 0]\n- 调用者: io_poll_task_func\n- 被调用者: 未明确\n\n7. 函数名: io_req_task_complete\n- 参数: [struct io_kiocb *req, bool *locked]\n- 调用者: io_poll_task_func\n- 被调用者: 未明确"
    },
    {
        "id": 4074,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3389",
        "purpose": "Code purpose:\"\"\"该代码片段用于解除IO轮询请求的武装状态，包括移除哈希表中的条目并释放相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring子系统中，取消轮询请求与链接超时竞争导致hrtimer释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: io_poll_disarm\n- 参数: [struct io_kiocb *req]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [io_poll_get_ownership, io_poll_remove_entries, hash_del]\n\n2. 函数名: io_poll_get_ownership\n- 参数: [struct io_kiocb *req]\n- 调用者: io_poll_disarm\n- 被调用者: 未明确\n\n3. 函数名: io_poll_remove_entries\n- 参数: [struct io_kiocb *req]\n- 调用者: io_poll_disarm\n- 被调用者: 未明确\n\n4. 函数名: hash_del\n- 参数: [&req->hash_node]\n- 调用者: io_poll_disarm\n- 被调用者: 未明确"
    },
    {
        "id": 4075,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3389",
        "purpose": "Code purpose:\"\"\"该代码片段实现了io_uring子系统中取消轮询请求的功能，通过调用__io_poll_cancel函数处理取消操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring子系统中，取消轮询请求与链接超时竞争导致hrtimer出现释放后使用(UAF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: io_poll_cancel\n- 参数: [ctx, cd, issue_flags]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [__io_poll_cancel]\n\n2. 函数名: __io_poll_cancel\n- 参数: [ctx, cd, &ctx->cancel_table]\n- 调用者: [io_poll_cancel]\n- 被调用者: 未明确（可能涉及内核内部函数）"
    },
    {
        "id": 4076,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3389",
        "purpose": "Code purpose:\"\"\"处理io_uring子系统的poll请求，包括事件注册、执行和取消操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在io_uring子系统中，取消轮询请求与链接超时竞争时，由于不当的引用计数管理导致hrtimer的释放后重用(UAF)。\"\"\"",
        "functions": "Functions:\n1. 函数名: __io_arm_poll_handler\n- 参数: [struct io_kiocb *req, struct io_poll *poll, struct io_poll_table *ipt, __poll_t mask]\n- 调用者: N/A (作为内核函数被其他内核代码调用)\n- 被调用者: [atomic_read, io_init_poll_iocb, vfs_poll, io_poll_remove_entries, io_poll_req_insert, atomic_set, atomic_dec_return, __io_poll_execute]\n\n2. 函数名: io_init_poll_iocb\n- 参数: [struct io_poll *poll, __poll_t mask, function pointer]\n- 调用者: __io_arm_poll_handler\n- 被调用者: N/A\n\n3. 函数名: vfs_poll\n- 参数: [struct file *file, struct poll_table_struct *pt]\n- 调用者: __io_arm_poll_handler\n- 被调用者: N/A\n\n4. 函数名: io_poll_remove_entries\n- 参数: [struct io_kiocb *req]\n- 调用者: __io_arm_poll_handler\n- 被调用者: N/A\n\n5. 函数名: io_poll_req_insert\n- 参数: [struct io_kiocb *req]\n- 调用者: __io_arm_poll_handler\n- 被调用者: N/A\n\n6. 函数名: __io_poll_execute\n- 参数: [struct io_kiocb *req, __poll_t mask, __poll_t events]\n- 调用者: __io_arm_poll_handler\n- 被调用者: N/A\n\n7. 函数名: atomic_read\n- 参数: [atomic_t *v]\n- 调用者: __io_arm_poll_handler\n- 被调用者: N/A\n\n8. 函数名: atomic_set\n- 参数: [atomic_t *v, int i]\n- 调用者: __io_arm_poll_handler\n- 被调用者: N/A\n\n9. 函数名: atomic_dec_return\n- 参数: [atomic_t *v]\n- 调用者: __io_arm_poll_handler\n- 被调用者: N/A"
    },
    {
        "id": 4077,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3390",
        "purpose": "Code purpose:\"\"\"处理netfilter子系统中NFT_MSG_NEWRULE消息，用于创建或替换nftables规则\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在NFT_MSG_NEWRULE消息处理中，错误处理不当导致同一事务中可能使用悬垂指针，造成释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: nf_tables_newrule\n- 参数: [struct sk_buff *skb, const struct nfnl_info *info, const struct nlattr * const nla[]]\n- 调用者: 未显示\n- 被调用者: [nft_pernet, nft_table_lookup, nft_chain_lookup, nft_chain_lookup_byid, __nft_rule_lookup, nft_ctx_init, kvmalloc_array, nf_tables_expr_parse, kzalloc, nft_activate_next, nft_userdata, nla_memcpy, nft_expr_first, nf_tables_newexpr, nft_validate_state_update, nft_expr_next, nft_flow_rule_create, nft_delrule, nft_trans_rule_add, list_add_tail_rcu, list_add_rcu, kvfree, nft_trans_flow_rule, nft_table_validate, nft_flow_rule_destroy, nf_tables_rule_release, module_put]\n\n2. 函数名: nft_pernet\n- 参数: [struct net *net]\n- 调用者: nf_tables_newrule\n- 被调用者: 未显示\n\n3. 函数名: nft_table_lookup\n- 参数: [struct net *net, const struct nlattr *attr, u8 family, u8 genmask, u32 portid]\n- 调用者: nf_tables_newrule\n- 被调用者: 未显示\n\n4. 函数名: nft_chain_lookup\n- 参数: [struct net *net, struct nft_table *table, const struct nlattr *attr, u8 genmask]\n- 调用者: nf_tables_newrule\n- 被调用者: 未显示\n\n5. 函数名: nft_chain_lookup_byid\n- 参数: [struct net *net, struct nft_table *table, const struct nlattr *attr]\n- 调用者: nf_tables_newrule\n- 被调用者: 未显示\n\n6. 函数名: __nft_rule_lookup\n- 参数: [struct nft_chain *chain, u64 handle]\n- 调用者: nf_tables_newrule\n- 被调用者: 未显示\n\n7. 函数名: nft_ctx_init\n- 参数: [struct nft_ctx *ctx, struct net *net, struct sk_buff *skb, const struct nlmsghdr *nlh, u8 family, struct nft_table *table, struct nft_chain *chain, const struct nlattr * const nla[]]\n- 调用者: nf_tables_newrule\n- 被调用者: 未显示\n\n8. 函数名: nf_tables_expr_parse\n- 参数: [struct nft_ctx *ctx, const struct nlattr *attr, struct nft_expr_info *info]\n- 调用者: nf_tables_newrule\n- 被调用者: 未显示\n\n9. 函数名: nf_tables_newexpr\n- 参数: [struct nft_ctx *ctx, struct nft_expr_info *info, struct nft_expr *expr]\n- 调用者: nf_tables_newrule\n- 被调用者: 未显示\n\n10. 函数名: nft_validate_state_update\n- 参数: [struct nft_table *table, enum nft_validate_state state]\n- 调用者: nf_tables_newrule\n- 被调用者: 未显示\n\n11. 函数名: nft_flow_rule_create\n- 参数: [struct net *net, struct nft_rule *rule]\n- 调用者: nf_tables_newrule\n- 被调用者: 未显示\n\n12. 函数名: nft_delrule\n- 参数: [struct nft_ctx *ctx, struct nft_rule *rule]\n- 调用者: nf_tables_newrule\n- 被调用者: 未显示\n\n13. 函数名: nft_trans_rule_add\n- 参数: [struct nft_ctx *ctx, int msg_type, struct nft_rule *rule]\n- 调用者: nf_tables_newrule\n- 被调用者: 未显示\n\n14. 函数名: nft_table_validate\n- 参数: [struct net *net, struct nft_table *table]\n- 调用者: nf_tables_newrule\n- 被调用者: 未显示\n\n15. 函数名: nft_flow_rule_destroy\n- 参数: [struct nft_flow_rule *flow]\n- 调用者: nf_tables_newrule\n- 被调用者: 未显示\n\n16. 函数名: nf_tables_rule_release\n- 参数: [struct nft_ctx *ctx, struct nft_rule *rule]\n- 调用者: nf_tables_newrule\n- 被调用者: 未显示"
    },
    {
        "id": 4104,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3439",
        "purpose": "Code purpose:\"\"\"在MCTP协议中注销网络设备时释放相关资源，包括路由、邻居信息和地址内存\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在mctp_unregister()函数中释放mdev->addrs资源后，可能存在其他运行中的例程未感知该释放操作而继续使用该资源，导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: mctp_unregister\n- 参数: [struct net_device *dev]\n- 调用者: 未明确（应为网络设备注销时的调用）\n- 被调用者: [mctp_dev_get_rtnl, mctp_known, netdev_warn, RCU_INIT_POINTER, mctp_route_remove_dev, mctp_neigh_remove_dev, kfree, mctp_dev_put]\n\n2. 函数名: mctp_dev_get_rtnl\n- 参数: [struct net_device *dev]\n- 调用者: mctp_unregister\n- 被调用者: []\n\n3. 函数名: mctp_known\n- 参数: [struct net_device *dev]\n- 调用者: mctp_unregister\n- 被调用者: []\n\n4. 函数名: netdev_warn\n- 参数: [struct net_device *dev, const char *format, __func__, dev->type]\n- 调用者: mctp_unregister\n- 被调用者: []\n\n5. 函数名: RCU_INIT_POINTER\n- 参数: [mdev->dev->mctp_ptr, NULL]\n- 调用者: mctp_unregister\n- 被调用者: []\n\n6. 函数名: mctp_route_remove_dev\n- 参数: [struct mctp_dev *mdev]\n- 调用者: mctp_unregister\n- 被调用者: []\n\n7. 函数名: mctp_neigh_remove_dev\n- 参数: [struct mctp_dev *mdev]\n- 调用者: mctp_unregister\n- 被调用者: []\n\n8. 函数名: kfree\n- 参数: [mdev->addrs]\n- 调用者: mctp_unregister\n- 被调用者: []\n\n9. 函数名: mctp_dev_put\n- 参数: [struct mctp_dev *mdev]\n- 调用者: mctp_unregister\n- 被调用者: []"
    },
    {
        "id": 4105,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3439",
        "purpose": "Code purpose:\"\"\"该代码用于在引用计数减至零时释放MCTP设备资源，包括关联的设备引用和内存空间。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在MCTP协议中，当网卡分离时mctp_unregister()回收设备资源，但运行中的例程可能未察觉此情况，导致对已释放的mdev->addrs对象进行使用后释放(UAF)。\"\"\"",
        "functions": "Functions:\n1. 函数名: mctp_dev_put\n- 参数: [mdev]\n- 调用者: 未提供（上下文不足）\n- 被调用者: [refcount_dec_and_test, dev_put, kfree_rcu]\n\n2. 函数名: refcount_dec_and_test\n- 参数: [&mdev->refs]\n- 调用者: mctp_dev_put\n- 被调用者: 未提供（假设为内核内部函数）\n\n3. 函数名: dev_put\n- 参数: [mdev->dev]\n- 调用者: mctp_dev_put\n- 被调用者: 未提供（假设为内核内部函数）\n\n4. 函数名: kfree_rcu\n- 参数: [mdev, rcu]\n- 调用者: mctp_dev_put\n- 被调用者: 未提供（假设为内核内部函数）"
    },
    {
        "id": 4107,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3567",
        "purpose": "Code purpose:\"\"\"该代码实现了从虚拟控制台(vc)读取数据到用户空间缓冲区的功能，包括处理unicode和属性模式下的控制台数据读取。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在vcs_read函数中，由于在释放控制台锁后执行copy_to_user操作时可能发生页面错误，导致在重新获取锁之前控制台状态可能已被修改，从而引发释放后使用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: vcs_read\n- 参数: [struct file *file, char __user *buf, size_t count, loff_t *ppos]\n- 调用者: 无（内核接口函数）\n- 被调用者: [file_inode, __get_free_page, console_lock, use_unicode, use_attributes, vcs_vc, vcs_size, vcs_read_buf_uni, vcs_read_buf_noattr, vcs_read_buf, console_unlock, copy_to_user, free_page]\n\n2. 函数名: file_inode\n- 参数: [struct file *file]\n- 调用者: vcs_read\n- 被调用者: 无\n\n3. 函数名: __get_free_page\n- 参数: [GFP_KERNEL]\n- 调用者: vcs_read\n- 被调用者: 无\n\n4. 函数名: console_lock\n- 参数: []\n- 调用者: vcs_read\n- 被调用者: 无\n\n5. 函数名: use_unicode\n- 参数: [struct inode *inode]\n- 调用者: vcs_read\n- 被调用者: 无\n\n6. 函数名: use_attributes\n- 参数: [struct inode *inode]\n- 调用者: vcs_read\n- 被调用者: 无\n\n7. 函数名: vcs_vc\n- 参数: [struct inode *inode, bool *viewed]\n- 调用者: vcs_read\n- 被调用者: 无\n\n8. 函数名: vcs_size\n- 参数: [struct vc_data *vc, bool attr, bool uni_mode]\n- 调用者: vcs_read\n- 被调用者: 无\n\n9. 函数名: vcs_read_buf_uni\n- 参数: [struct vc_data *vc, char *con_buf, loff_t pos, unsigned int this_round, bool viewed]\n- 调用者: vcs_read\n- 被调用者: 无\n\n10. 函数名: vcs_read_buf_noattr\n- 参数: [struct vc_data *vc, char *con_buf, loff_t pos, unsigned int this_round, bool viewed]\n- 调用者: vcs_read\n- 被调用者: 无\n\n11. 函数名: vcs_read_buf\n- 参数: [struct vc_data *vc, char *con_buf, loff_t pos, unsigned int this_round, bool viewed, unsigned int *skip]\n- 调用者: vcs_read\n- 被调用者: 无\n\n12. 函数名: console_unlock\n- 参数: []\n- 调用者: vcs_read\n- 被调用者: 无\n\n13. 函数名: copy_to_user\n- 参数: [char __user *buf, char *con_buf + skip, unsigned int this_round]\n- 调用者: vcs_read\n- 被调用者: 无\n\n14. 函数名: free_page\n- 参数: [unsigned long con_buf]\n- 调用者: vcs_read\n- 被调用者: 无"
    },
    {
        "id": 4109,
        "cwe": "CWE-416",
        "cve": "CVE-2023-35823",
        "purpose": "Code purpose:\"\"\"释放SAA7134视频设备中与传输流队列相关的页表资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放dev->ts_q.pt资源后未将指针置空，导致后续可能发生对已释放内存的访问\"\"\"",
        "functions": "Functions:\n1. 函数名: saa7134_ts_fini\n- 参数: [struct saa7134_dev *dev]\n- 调用者: 未明确（应为外部调用）\n- 被调用者: [saa7134_pgtable_free]\n\n2. 函数名: saa7134_pgtable_free\n- 参数: [dev->pci, &dev->ts_q.pt]\n- 调用者: saa7134_ts_fini\n- 被调用者: 未明确"
    },
    {
        "id": 4110,
        "cwe": "CWE-416",
        "cve": "CVE-2023-35823",
        "purpose": "Code purpose:\"\"\"该函数用于释放SAA7134视频捕获设备的VBI相关资源，但当前实现为空操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"saa7134_vbi_fini函数未正确释放资源导致后续使用时出现释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: saa7134_vbi_fini\n- 参数: [struct saa7134_dev *dev]\n- 调用者: 未提供\n- 被调用者: []"
    },
    {
        "id": 4111,
        "cwe": "CWE-416",
        "cve": "CVE-2023-35823",
        "purpose": "Code purpose:\"\"\"释放saa7134视频设备相关的资源，包括页表、视频队列、VBI队列和控制处理器\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在saa7134_video_fini函数中释放资源后，未将相关指针置空，导致后续可能发生对已释放内存的使用（use-after-free）。\"\"\"",
        "functions": "Functions:\n1. 函数名: saa7134_video_fini\n- 参数: [struct saa7134_dev *dev]\n- 调用者: (未在代码片段中显示)\n- 被调用者: [saa7134_pgtable_free, v4l2_ctrl_handler_free, card_has_radio]\n\n2. 函数名: saa7134_pgtable_free\n- 参数: [dev->pci, &dev->video_q.pt], [dev->pci, &dev->vbi_q.pt]\n- 调用者: saa7134_video_fini\n- 被调用者: (未在代码片段中显示)\n\n3. 函数名: v4l2_ctrl_handler_free\n- 参数: [&dev->ctrl_handler], [&dev->radio_ctrl_handler]\n- 调用者: saa7134_video_fini\n- 被调用者: (未在代码片段中显示)\n\n4. 函数名: card_has_radio\n- 参数: [dev]\n- 调用者: saa7134_video_fini\n- 被调用者: (未在代码片段中显示)"
    },
    {
        "id": 4112,
        "cwe": "CWE-416",
        "cve": "CVE-2023-35824",
        "purpose": "Code purpose:\"\"\"该代码用于在移除dm1105 PCI设备时清理相关资源，包括中断、内存映射、DVB适配器等。\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在dm1105_remove函数中，存在对已释放的dmx结构体的后续操作，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: dm1105_remove\n- 参数: [struct pci_dev *pdev]\n- 调用者: 无（驱动卸载函数）\n- 被调用者: [pci_get_drvdata, dm1105_ir_exit, dvb_net_release, dvb_unregister_frontend, dmx->close, dmx->disconnect_frontend, dmx->remove_frontend, dvb_dmxdev_release, dvb_dmx_release, dvb_unregister_adapter, i2c_del_adapter, dm1105_hw_exit, free_irq, pci_iounmap, pci_release_regions, pci_disable_device, kfree]\n\n2. 函数名: pci_get_drvdata\n- 参数: [struct pci_dev *pdev]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n3. 函数名: dm1105_ir_exit\n- 参数: [struct dm1105_dev *dev]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n4. 函数名: dvb_net_release\n- 参数: [struct dvb_net *dvbnet]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n5. 函数名: dvb_unregister_frontend\n- 参数: [struct dvb_frontend *fe]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n6. 函数名: dmx->close\n- 参数: [struct dmx_demux *dmx]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n7. 函数名: dmx->disconnect_frontend\n- 参数: [struct dmx_demux *dmx]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n8. 函数名: dmx->remove_frontend\n- 参数: [struct dmx_demux *dmx, struct dmx_frontend *frontend]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n9. 函数名: dvb_dmxdev_release\n- 参数: [struct dvb_demux *demux]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n10. 函数名: dvb_dmx_release\n- 参数: [struct dvb_demux *demux]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n11. 函数名: dvb_unregister_adapter\n- 参数: [struct dvb_adapter *adapter]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n12. 函数名: i2c_del_adapter\n- 参数: [struct i2c_adapter *adap]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n13. 函数名: dm1105_hw_exit\n- 参数: [struct dm1105_dev *dev]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n14. 函数名: free_irq\n- 参数: [unsigned int irq, void *dev_id]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n15. 函数名: pci_iounmap\n- 参数: [struct pci_dev *dev, void __iomem *addr]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n16. 函数名: pci_release_regions\n- 参数: [struct pci_dev *pdev]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n17. 函数名: pci_disable_device\n- 参数: [struct pci_dev *dev]\n- 调用者: dm1105_remove\n- 被调用者: 无\n\n18. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: dm1105_remove\n- 被调用者: 无"
    },
    {
        "id": 4113,
        "cwe": "CWE-416",
        "cve": "CVE-2023-35826",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理Cedrus视频解码器设备的移除操作，包括注销媒体设备、释放资源和清理相关数据结构。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在cedrus_remove函数中，对dev结构体的成员进行操作后未正确释放dev指针，导致后续可能发生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: cedrus_remove\n- 参数: [struct platform_device *pdev]\n- 调用者: 无（驱动移除函数，由内核调用）\n- 被调用者: [platform_get_drvdata, media_devnode_is_registered, media_device_unregister, v4l2_m2m_unregister_media_controller, media_device_cleanup, v4l2_m2m_release, video_unregister_device, v4l2_device_unregister, cedrus_hw_remove]\n\n2. 函数名: platform_get_drvdata\n- 参数: [struct platform_device *pdev]\n- 调用者: cedrus_remove\n- 被调用者: 无\n\n3. 函数名: media_devnode_is_registered\n- 参数: [dev->mdev.devnode]\n- 调用者: cedrus_remove\n- 被调用者: 无\n\n4. 函数名: media_device_unregister\n- 参数: [&dev->mdev]\n- 调用者: cedrus_remove\n- 被调用者: 无\n\n5. 函数名: v4l2_m2m_unregister_media_controller\n- 参数: [dev->m2m_dev]\n- 调用者: cedrus_remove\n- 被调用者: 无\n\n6. 函数名: media_device_cleanup\n- 参数: [&dev->mdev]\n- 调用者: cedrus_remove\n- 被调用者: 无\n\n7. 函数名: v4l2_m2m_release\n- 参数: [dev->m2m_dev]\n- 调用者: cedrus_remove\n- 被调用者: 无\n\n8. 函数名: video_unregister_device\n- 参数: [&dev->vfd]\n- 调用者: cedrus_remove\n- 被调用者: 无\n\n9. 函数名: v4l2_device_unregister\n- 参数: [&dev->v4l2_dev]\n- 调用者: cedrus_remove\n- 被调用者: 无\n\n10. 函数名: cedrus_hw_remove\n- 参数: [dev]\n- 调用者: cedrus_remove\n- 被调用者: 无"
    },
    {
        "id": 4114,
        "cwe": "CWE-416",
        "cve": "CVE-2023-35827",
        "purpose": "Code purpose:\"\"\"该代码实现了网络设备关闭时的资源释放和清理操作，包括中断禁用、DMA停止、时间戳列表清除、PHY断开连接、中断释放和内存回收等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ravb_close函数中，释放了网络设备资源后，可能存在对已释放资源的后续访问，导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ravb_close\n- 参数: [struct net_device *ndev]\n- 调用者: 未显示\n- 被调用者: [netdev_priv, netif_tx_stop_all_queues, ravb_write, ravb_ptp_stop, ravb_stop_dma, netdev_err, list_for_each_entry_safe, list_del, kfree_skb, kfree, phy_stop, phy_disconnect, of_phy_is_fixed_link, of_phy_deregister_fixed_link, free_irq, napi_disable, ravb_ring_free]\n\n2. 函数名: netdev_priv\n- 参数: [struct net_device *ndev]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n3. 函数名: netif_tx_stop_all_queues\n- 参数: [struct net_device *ndev]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n4. 函数名: ravb_write\n- 参数: [struct net_device *ndev, int value, int reg]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n5. 函数名: ravb_ptp_stop\n- 参数: [struct net_device *ndev]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n6. 函数名: ravb_stop_dma\n- 参数: [struct net_device *ndev]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n7. 函数名: netdev_err\n- 参数: [struct net_device *ndev, const char *fmt, ...]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n8. 函数名: list_for_each_entry_safe\n- 参数: [type *pos, type *n, struct list_head *head, member]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n9. 函数名: list_del\n- 参数: [struct list_head *entry]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n10. 函数名: kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n11. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n12. 函数名: phy_stop\n- 参数: [struct phy_device *phydev]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n13. 函数名: phy_disconnect\n- 参数: [struct phy_device *phydev]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n14. 函数名: of_phy_is_fixed_link\n- 参数: [struct device_node *np]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n15. 函数名: of_phy_deregister_fixed_link\n- 参数: [struct device_node *np]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n16. 函数名: free_irq\n- 参数: [unsigned int irq, void *dev_id]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n17. 函数名: napi_disable\n- 参数: [struct napi_struct *n]\n- 调用者: ravb_close\n- 被调用者: 未显示\n\n18. 函数名: ravb_ring_free\n- 参数: [struct net_device *ndev, int queue]\n- 调用者: ravb_close\n- 被调用者: 未显示"
    },
    {
        "id": 4115,
        "cwe": "CWE-416",
        "cve": "CVE-2023-35828",
        "purpose": "Code purpose:\"\"\"该代码实现了Renesas USB3设备驱动在移除时的资源清理功能，包括删除调试文件系统、移除设备属性、注销USB角色切换、删除USB gadget UDC、重置控制、释放DMA资源等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在renesas_usb3_remove函数中，存在对已释放的usb3结构体的后续操作，导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: renesas_usb3_remove\n- 参数: [struct platform_device *pdev]\n- 调用者: platform_driver_unregister (implied)\n- 被调用者: [platform_get_drvdata, debugfs_remove_recursive, device_remove_file, usb_role_switch_unregister, usb_del_gadget_udc, reset_control_assert, renesas_usb3_dma_free_prd, __renesas_usb3_ep_free_request, pm_runtime_disable]\n\n2. 函数名: platform_get_drvdata\n- 参数: [struct platform_device *pdev]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n3. 函数名: debugfs_remove_recursive\n- 参数: [struct dentry *dentry]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n4. 函数名: device_remove_file\n- 参数: [struct device *dev, const struct device_attribute *attr]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n5. 函数名: usb_role_switch_unregister\n- 参数: [struct usb_role_switch *sw]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n6. 函数名: usb_del_gadget_udc\n- 参数: [struct usb_gadget *gadget]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n7. 函数名: reset_control_assert\n- 参数: [struct reset_control *rstc]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n8. 函数名: renesas_usb3_dma_free_prd\n- 参数: [struct renesas_usb3 *usb3, struct device *dev]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n9. 函数名: __renesas_usb3_ep_free_request\n- 参数: [struct usb_request *req]\n- 调用者: renesas_usb3_remove\n- 被调用者: []\n\n10. 函数名: pm_runtime_disable\n- 参数: [struct device *dev]\n- 调用者: renesas_usb3_remove\n- 被调用者: []"
    },
    {
        "id": 4116,
        "cwe": "CWE-416",
        "cve": "CVE-2023-35829",
        "purpose": "Code purpose:\"\"\"该代码片段实现了Linux内核中rkvdec设备的移除功能，包括清理V4L2相关资源、禁用电源管理和自动挂起功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在rkvdec_remove函数中，platform_get_drvdata获取的设备数据可能在后续操作中被释放，导致use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: rkvdec_remove\n- 参数: [struct platform_device *pdev]\n- 调用者: platform device removal mechanism\n- 被调用者: [platform_get_drvdata, rkvdec_v4l2_cleanup, pm_runtime_disable, pm_runtime_dont_use_autosuspend]\n\n2. 函数名: platform_get_drvdata\n- 参数: [struct platform_device *pdev]\n- 调用者: rkvdec_remove\n- 被调用者: []\n\n3. 函数名: rkvdec_v4l2_cleanup\n- 参数: [struct rkvdec_dev *rkvdec]\n- 调用者: rkvdec_remove\n- 被调用者: []\n\n4. 函数名: pm_runtime_disable\n- 参数: [struct device *dev]\n- 调用者: rkvdec_remove\n- 被调用者: []\n\n5. 函数名: pm_runtime_dont_use_autosuspend\n- 参数: [struct device *dev]\n- 调用者: rkvdec_remove\n- 被调用者: []"
    },
    {
        "id": 4117,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3609",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的net/sched: cls_u32组件中设置和更新流量控制过滤器的参数，包括链接哈希表、类ID和输入设备等配置。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当tcf_change_indev()失败时，函数直接返回错误而未正确处理之前已修改的引用计数器，导致引用计数可能被减至零引发释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: u32_set_parms\n- 参数: [struct net *net, struct tcf_proto *tp, unsigned long base, struct tc_u_knode *n, struct nlattr **tb, struct nlattr *est, u32 flags, u32 fl_flags, struct netlink_ext_ack *extack]\n- 调用者: (未在代码片段中显示)\n- 被调用者: [tcf_exts_validate_ex, nla_get_u32, u32_lookup_ht, rtnl_dereference, rcu_assign_pointer, tcf_bind_filter, tcf_change_indev]\n\n2. 函数名: tcf_exts_validate_ex\n- 参数: [struct net *net, struct tcf_proto *tp, struct nlattr **tb, struct nlattr *est, struct tcf_exts *exts, u32 flags, u32 fl_flags, struct netlink_ext_ack *extack]\n- 调用者: u32_set_parms\n- 被调用者: (未在代码片段中显示)\n\n3. 函数名: nla_get_u32\n- 参数: [struct nlattr *nla]\n- 调用者: u32_set_parms\n- 被调用者: (未在代码片段中显示)\n\n4. 函数名: u32_lookup_ht\n- 参数: [void *data, u32 handle]\n- 调用者: u32_set_parms\n- 被调用者: (未在代码片段中显示)\n\n5. 函数名: rtnl_dereference\n- 参数: [struct tc_u_hnode *ptr]\n- 调用者: u32_set_parms\n- 被调用者: (未在代码片段中显示)\n\n6. 函数名: rcu_assign_pointer\n- 参数: [struct tc_u_hnode *ptr, struct tc_u_hnode *new]\n- 调用者: u32_set_parms\n- 被调用者: (未在代码片段中显示)\n\n7. 函数名: tcf_bind_filter\n- 参数: [struct tcf_proto *tp, struct tcf_result *r, unsigned long base]\n- 调用者: u32_set_parms\n- 被调用者: (未在代码片段中显示)\n\n8. 函数名: tcf_change_indev\n- 参数: [struct net *net, struct nlattr *indev_attr, struct netlink_ext_ack *extack]\n- 调用者: u32_set_parms\n- 被调用者: (未在代码片段中显示)"
    },
    {
        "id": 4118,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3610",
        "purpose": "Code purpose:\"\"\"释放和处理网络过滤规则表中的规则，包括停用规则表达式并销毁规则\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在NFT_MSG_NEWRULE的abort路径中，对绑定链的错误处理不当导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nf_tables_rule_release\n- 参数: [const struct nft_ctx *ctx, struct nft_rule *rule]\n- 调用者: 未显示\n- 被调用者: [nft_rule_expr_deactivate, nf_tables_rule_destroy]\n\n2. 函数名: nft_rule_expr_deactivate\n- 参数: [const struct nft_ctx *ctx, struct nft_rule *rule, NFT_TRANS_RELEASE]\n- 调用者: nf_tables_rule_release\n- 被调用者: 未显示\n\n3. 函数名: nf_tables_rule_destroy\n- 参数: [const struct nft_ctx *ctx, struct nft_rule *rule]\n- 调用者: nf_tables_rule_release\n- 被调用者: 未显示"
    },
    {
        "id": 4119,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3610",
        "purpose": "Code purpose:\"\"\"激活网络过滤规则中的所有表达式\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在NFT_MSG_NEWRULE的abort路径中，对绑定链的错误处理不当导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_rule_expr_activate\n- 参数: [const struct nft_ctx *ctx, struct nft_rule *rule]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [nft_expr_first, nft_expr_more, nft_expr_next, expr->ops->activate]\n\n2. 函数名: nft_expr_first\n- 参数: [struct nft_rule *rule]\n- 调用者: nft_rule_expr_activate\n- 被调用者: 未显示\n\n3. 函数名: nft_expr_more\n- 参数: [struct nft_rule *rule, struct nft_expr *expr]\n- 调用者: nft_rule_expr_activate\n- 被调用者: 未显示\n\n4. 函数名: nft_expr_next\n- 参数: [struct nft_expr *expr]\n- 调用者: nft_rule_expr_activate\n- 被调用者: 未显示\n\n5. 函数名: expr->ops->activate\n- 参数: [const struct nft_ctx *ctx, struct nft_expr *expr]\n- 调用者: nft_rule_expr_activate\n- 被调用者: 未显示"
    },
    {
        "id": 4120,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3610",
        "purpose": "Code purpose:\"\"\"该代码用于在netfilter的nf_tables组件中添加新的链或处理链相关操作，包括分配传输对象、激活链和处理链ID等\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在错误处理过程中对绑定链的处理不当，导致在NFT_MSG_NEWRULE的abort路径中出现释放后使用(UAF)问题\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_trans_chain_add\n- 参数: [struct nft_ctx *ctx, int msg_type]\n- 调用者: 未提供\n- 被调用者: [nft_trans_alloc, ERR_PTR, nft_activate_next, nft_trans_chain_id, ntohl, nla_get_be32, nft_trans_commit_list_add_tail]\n\n2. 函数名: nft_trans_alloc\n- 参数: [struct nft_ctx *ctx, int msg_type, size_t size]\n- 调用者: nft_trans_chain_add\n- 被调用者: 未提供\n\n3. 函数名: ERR_PTR\n- 参数: [long error]\n- 调用者: nft_trans_chain_add\n- 被调用者: 未提供\n\n4. 函数名: nft_activate_next\n- 参数: [struct net *net, struct nft_chain *chain]\n- 调用者: nft_trans_chain_add\n- 被调用者: 未提供\n\n5. 函数名: nft_trans_chain_id\n- 参数: [struct nft_trans *trans]\n- 调用者: nft_trans_chain_add\n- 被调用者: 未提供\n\n6. 函数名: ntohl\n- 参数: [uint32_t netlong]\n- 调用者: nft_trans_chain_add\n- 被调用者: 未提供\n\n7. 函数名: nla_get_be32\n- 参数: [const struct nlattr *nla]\n- 调用者: nft_trans_chain_add\n- 被调用者: 未提供\n\n8. 函数名: nft_trans_commit_list_add_tail\n- 参数: [struct net *net, struct nft_trans *trans]\n- 调用者: nft_trans_chain_add\n- 被调用者: 未提供"
    },
    {
        "id": 4121,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3610",
        "purpose": "Code purpose:\"\"\"该代码用于处理NFT数据持有操作，特别是针对NFT_JUMP和NFT_GOTO类型的裁决，增加相关链和表的使用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在错误处理过程中未正确释放已绑定的链，导致在NFT_MSG_NEWRULE的中止路径中出现释放后使用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_data_hold\n- 参数: [const struct nft_data *data, enum nft_data_types type]\n- 调用者: 未显示\n- 被调用者: [nft_chain_is_bound, nft_chain_add]\n\n2. 函数名: nft_chain_is_bound\n- 参数: [struct nft_chain *chain]\n- 调用者: nft_data_hold\n- 被调用者: 未显示\n\n3. 函数名: nft_chain_add\n- 参数: [struct nft_table *table, struct nft_chain *chain]\n- 调用者: nft_data_hold\n- 被调用者: 未显示\n\n4. 函数名: list_for_each_entry\n- 参数: [rule, &chain->rules, list]\n- 调用者: nft_data_hold\n- 被调用者: 未显示"
    },
    {
        "id": 4122,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3610",
        "purpose": "Code purpose:\"\"\"该代码用于在netfilter的nf_tables组件中停用规则表达式，遍历规则中的所有表达式并调用其停用函数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在NFT_MSG_NEWRULE的abort路径中，对绑定链的错误处理不当导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_rule_expr_deactivate\n- 参数: [const struct nft_ctx *ctx, struct nft_rule *rule, enum nft_trans_phase phase]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [nft_expr_first, nft_expr_more, expr->ops->deactivate, nft_expr_next]\n\n2. 函数名: nft_expr_first\n- 参数: [struct nft_rule *rule]\n- 调用者: nft_rule_expr_deactivate\n- 被调用者: 未明确\n\n3. 函数名: nft_expr_more\n- 参数: [struct nft_rule *rule, struct nft_expr *expr]\n- 调用者: nft_rule_expr_deactivate\n- 被调用者: 未明确\n\n4. 函数名: expr->ops->deactivate\n- 参数: [const struct nft_ctx *ctx, struct nft_expr *expr, enum nft_trans_phase phase]\n- 调用者: nft_rule_expr_deactivate\n- 被调用者: 未明确\n\n5. 函数名: nft_expr_next\n- 参数: [struct nft_expr *expr]\n- 调用者: nft_rule_expr_deactivate\n- 被调用者: 未明确"
    },
    {
        "id": 4123,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3610",
        "purpose": "Code purpose:\"\"\"该代码片段用于销毁nf_tables规则，包括释放规则中的表达式和规则本身的内存\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在NFT_MSG_NEWRULE的abort路径中，错误处理绑定链时导致释放后使用(use-after-free)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nf_tables_rule_destroy\n- 参数: [const struct nft_ctx *ctx, struct nft_rule *rule]\n- 调用者: 未明确显示（可能是外部调用或错误处理路径）\n- 被调用者: [nft_expr_first, nft_expr_more, nft_expr_next, nf_tables_expr_destroy, kfree]\n\n2. 函数名: nft_expr_first\n- 参数: [struct nft_rule *rule]\n- 调用者: nf_tables_rule_destroy\n- 被调用者: 未显示\n\n3. 函数名: nft_expr_more\n- 参数: [struct nft_rule *rule, struct nft_expr *expr]\n- 调用者: nf_tables_rule_destroy\n- 被调用者: 未显示\n\n4. 函数名: nft_expr_next\n- 参数: [struct nft_expr *expr]\n- 调用者: nf_tables_rule_destroy\n- 被调用者: 未显示\n\n5. 函数名: nf_tables_expr_destroy\n- 参数: [const struct nft_ctx *ctx, struct nft_expr *expr]\n- 调用者: nf_tables_rule_destroy\n- 被调用者: 未显示\n\n6. 函数名: kfree\n- 参数: [void *ptr] (此处为 struct nft_rule *rule)\n- 调用者: nf_tables_rule_destroy\n- 被调用者: 未显示"
    },
    {
        "id": 4124,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3610",
        "purpose": "Code purpose:\"\"\"处理netfilter中nf_tables组件的abort操作，包括回滚事务、释放资源和清理状态，以应对错误情况下的系统恢复。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在NFT_MSG_NEWRULE的错误处理路径中，对已绑定链的处理不当导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: __nf_tables_abort\n- 参数: [net, action]\n- 调用者: N/A\n- 被调用者: [nft_pernet, nf_tables_validate, nft_trans_table_update, nft_trans_destroy, list_del_rcu, nf_tables_table_disable, nft_clear, nft_trans_chain_update, nft_netdev_unregister_hooks, free_percpu, kfree, nft_chain_is_bound, nft_chain_del, nf_tables_unregister_hook, list_splice, nft_rule_expr_deactivate, nft_flow_rule_destroy, nft_rule_expr_activate, nft_trans_set_update, nft_trans_set_bound, nft_setelem_remove, nft_setelem_is_catchall, atomic_dec, list_add_tail, nft_setelem_data_activate, nft_setelem_activate, nft_trans_obj_update, nft_obj_destroy, nft_obj_del, nft_trans_flowtable_update, nft_unregister_flowtable_net_hooks, nft_set_abort_update, synchronize_rcu, nf_tables_abort_release, nf_tables_module_autoload, nf_tables_module_autoload_cleanup]\n\n2. 函数名: nft_pernet\n- 参数: [net]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n3. 函数名: nf_tables_validate\n- 参数: [net]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n4. 函数名: nft_trans_table_update\n- 参数: [trans]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n5. 函数名: nft_trans_destroy\n- 参数: [trans]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n6. 函数名: list_del_rcu\n- 参数: [list]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n7. 函数名: nf_tables_table_disable\n- 参数: [net, table]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n8. 函数名: nft_clear\n- 参数: [net, table/chain/rule/set/obj/flowtable]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n9. 函数名: nft_trans_chain_update\n- 参数: [trans]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n10. 函数名: nft_netdev_unregister_hooks\n- 参数: [net, hooks, bool]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n11. 函数名: free_percpu\n- 参数: [stats]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n12. 函数名: kfree\n- 参数: [name]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n13. 函数名: nft_chain_is_bound\n- 参数: [chain]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n14. 函数名: nft_chain_del\n- 参数: [chain]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n15. 函数名: nf_tables_unregister_hook\n- 参数: [net, table, chain]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n16. 函数名: list_splice\n- 参数: [hooks, hook_list]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n17. 函数名: nft_rule_expr_deactivate\n- 参数: [ctx, rule, NFT_TRANS_ABORT]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n18. 函数名: nft_flow_rule_destroy\n- 参数: [flow_rule]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n19. 函数名: nft_rule_expr_activate\n- 参数: [ctx, rule]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n20. 函数名: nft_trans_set_update\n- 参数: [trans]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n21. 函数名: nft_trans_set_bound\n- 参数: [trans]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n22. 函数名: nft_setelem_remove\n- 参数: [net, set, elem]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n23. 函数名: nft_setelem_is_catchall\n- 参数: [set, elem]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n24. 函数名: atomic_dec\n- 参数: [nelems]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n25. 函数名: list_add_tail\n- 参数: [pending_update, set_update_list]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n26. 函数名: nft_setelem_data_activate\n- 参数: [net, set, elem]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n27. 函数名: nft_setelem_activate\n- 参数: [net, set, elem]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n28. 函数名: nft_trans_obj_update\n- 参数: [trans]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n29. 函数名: nft_obj_destroy\n- 参数: [ctx, newobj]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n30. 函数名: nft_obj_del\n- 参数: [obj]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n31. 函数名: nft_trans_flowtable_update\n- 参数: [trans]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n32. 函数名: nft_unregister_flowtable_net_hooks\n- 参数: [net, hooks/hook_list]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n33. 函数名: nft_set_abort_update\n- 参数: [set_update_list]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n34. 函数名: synchronize_rcu\n- 参数: []\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n35. 函数名: nf_tables_abort_release\n- 参数: [trans]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n36. 函数名: nf_tables_module_autoload\n- 参数: [net]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A\n\n37. 函数名: nf_tables_module_autoload_cleanup\n- 参数: [net]\n- 调用者: __nf_tables_abort\n- 被调用者: N/A"
    },
    {
        "id": 4125,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3610",
        "purpose": "Code purpose:\"\"\"处理网络过滤规则中链的引用计数和删除操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在错误处理绑定链时未正确管理引用计数，导致NFT_MSG_NEWRULE中止路径中出现释放后使用(UAF)问题\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_verdict_uninit\n- 参数: [const struct nft_data *data]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [nft_chain_is_bound, nft_chain_del]\n\n2. 函数名: nft_chain_is_bound\n- 参数: [struct nft_chain *chain]\n- 调用者: nft_verdict_uninit\n- 被调用者: []\n\n3. 函数名: nft_chain_del\n- 参数: [struct nft_chain *chain]\n- 调用者: nft_verdict_uninit\n- 被调用者: []\n\n4. 函数名: list_for_each_entry\n- 参数: [rule, &chain->rules, list]\n- 调用者: nft_verdict_uninit\n- 被调用者: []"
    },
    {
        "id": 4126,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3610",
        "purpose": "Code purpose:\"\"\"将新的nftables链添加到指定表的哈希表和链表中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"错误处理中对绑定链的处理不当导致在NFT_MSG_NEWRULE的abort路径中出现释放后重用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_chain_add\n- 参数: [struct nft_table *table, struct nft_chain *chain]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [rhltable_insert_key, list_add_tail_rcu]\n\n2. 函数名: rhltable_insert_key\n- 参数: [&table->chains_ht, chain->name, &chain->rhlhead, nft_chain_ht_params]\n- 调用者: nft_chain_add\n- 被调用者: 未明确（可能是内核内部函数）\n\n3. 函数名: list_add_tail_rcu\n- 参数: [&chain->list, &table->chains]\n- 调用者: nft_chain_add\n- 被调用者: 未明确（可能是内核RCU相关函数）"
    },
    {
        "id": 4127,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3610",
        "purpose": "Code purpose:\"\"\"该代码用于处理Linux内核netfilter中nftables模块的立即表达式销毁操作，特别是处理绑定链的规则释放和链销毁\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在错误处理绑定链时，NFT_MSG_NEWRULE的中止路径中未正确释放资源导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_immediate_destroy\n- 参数: [const struct nft_ctx *ctx, const struct nft_expr *expr]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [nft_expr_priv, nft_chain_is_bound, list_for_each_entry_safe, nf_tables_rule_release, nf_tables_chain_destroy]\n\n2. 函数名: nft_expr_priv\n- 参数: [const struct nft_expr *expr]\n- 调用者: nft_immediate_destroy\n- 被调用者: 未明确\n\n3. 函数名: nft_chain_is_bound\n- 参数: [struct nft_chain *chain]\n- 调用者: nft_immediate_destroy\n- 被调用者: 未明确\n\n4. 函数名: list_for_each_entry_safe\n- 参数: [rule, n, &chain->rules, list]\n- 调用者: nft_immediate_destroy\n- 被调用者: 未明确\n\n5. 函数名: nf_tables_rule_release\n- 参数: [&chain_ctx, rule]\n- 调用者: nft_immediate_destroy\n- 被调用者: 未明确\n\n6. 函数名: nf_tables_chain_destroy\n- 参数: [&chain_ctx]\n- 调用者: nft_immediate_destroy\n- 被调用者: 未明确"
    },
    {
        "id": 4128,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3610",
        "purpose": "Code purpose:\"\"\"该代码片段实现了在特定阶段释放nft_immediate_expr结构体中数据的功能，属于Linux内核netfilter:nf_tables组件中规则处理的一部分\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在NFT_TRANS_COMMIT阶段未正确处理nft_immediate_expr结构体的释放，导致在错误处理路径中出现释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_immediate_deactivate\n- 参数: [const struct nft_ctx *ctx, const struct nft_expr *expr, enum nft_trans_phase phase]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [nft_expr_priv, nft_data_release, nft_dreg_to_type]\n\n2. 函数名: nft_expr_priv\n- 参数: [const struct nft_expr *expr]\n- 调用者: nft_immediate_deactivate\n- 被调用者: 未明确\n\n3. 函数名: nft_data_release\n- 参数: [&priv->data, nft_dreg_to_type(priv->dreg)]\n- 调用者: nft_immediate_deactivate\n- 被调用者: 未明确\n\n4. 函数名: nft_dreg_to_type\n- 参数: [priv->dreg]\n- 调用者: nft_immediate_deactivate\n- 被调用者: 未明确"
    },
    {
        "id": 4129,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3610",
        "purpose": "Code purpose:\"\"\"该代码用于初始化nftables中的立即表达式(immediate expression)，处理网络过滤规则中的数据注册和存储操作，并管理相关链的绑定状态。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在错误处理过程中未正确释放已绑定的链，导致在NFT_MSG_NEWRULE的abort路径中出现use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_immediate_init\n- 参数: [const struct nft_ctx *ctx, const struct nft_expr *expr, const struct nlattr * const tb[]]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [nft_expr_priv, nft_reg_to_type, nft_data_init, nft_parse_register_store, nft_chain_is_bound, nft_data_release]\n\n2. 函数名: nft_expr_priv\n- 参数: [const struct nft_expr *expr]\n- 调用者: nft_immediate_init\n- 被调用者: 未显示\n\n3. 函数名: nft_reg_to_type\n- 参数: [const struct nlattr *]\n- 调用者: nft_immediate_init\n- 被调用者: 未显示\n\n4. 函数名: nft_data_init\n- 参数: [const struct nft_ctx *ctx, struct nft_data *data, struct nft_data_desc *desc, const struct nlattr *tb]\n- 调用者: nft_immediate_init\n- 被调用者: 未显示\n\n5. 函数名: nft_parse_register_store\n- 参数: [const struct nft_ctx *ctx, const struct nlattr *attr, u32 *dreg, const struct nft_data *data, enum nft_data_types type, unsigned int len]\n- 调用者: nft_immediate_init\n- 被调用者: 未显示\n\n6. 函数名: nft_chain_is_bound\n- 参数: [const struct nft_chain *chain]\n- 调用者: nft_immediate_init\n- 被调用者: 未显示\n\n7. 函数名: nft_data_release\n- 参数: [struct nft_data *data, enum nft_data_types type]\n- 调用者: nft_immediate_init\n- 被调用者: 未显示"
    },
    {
        "id": 4130,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3610",
        "purpose": "Code purpose:\"\"\"该代码片段实现了在Linux内核netfilter的nf_tables组件中激活立即表达式时对数据的持有操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在错误处理绑定链时，NFT_MSG_NEWRULE的中止路径中出现了释放后使用的问题\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_immediate_activate\n- 参数: [const struct nft_ctx *ctx, const struct nft_expr *expr]\n- 调用者: 未提供\n- 被调用者: [nft_expr_priv, nft_data_hold, nft_dreg_to_type]\n\n2. 函数名: nft_expr_priv\n- 参数: [const struct nft_expr *expr]\n- 调用者: nft_immediate_activate\n- 被调用者: 未提供\n\n3. 函数名: nft_data_hold\n- 参数: [&priv->data, nft_dreg_to_type(priv->dreg)]\n- 调用者: nft_immediate_activate\n- 被调用者: 未提供\n\n4. 函数名: nft_dreg_to_type\n- 参数: [priv->dreg]\n- 调用者: nft_immediate_activate\n- 被调用者: 未提供"
    },
    {
        "id": 4135,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3776",
        "purpose": "Code purpose:\"\"\"该代码用于设置防火墙过滤器的参数，包括验证扩展属性、处理分类ID、网络设备索引和掩码匹配等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当tcf_change_indev()失败时，fw_set_parms()在tcf_bind_filter()调整引用计数器后立即返回错误，可能导致引用计数被置零从而引发释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: fw_set_parms\n- 参数: [struct net *net, struct tcf_proto *tp, struct fw_filter *f, struct nlattr **tb, struct nlattr **tca, unsigned long base, u32 flags, struct netlink_ext_ack *extack]\n- 调用者: (未在代码片段中显示)\n- 被调用者: [rtnl_dereference, tcf_exts_validate, nla_get_u32, tcf_bind_filter, tcf_change_indev]\n\n2. 函数名: rtnl_dereference\n- 参数: [tp->root]\n- 调用者: fw_set_parms\n- 被调用者: (未在代码片段中显示)\n\n3. 函数名: tcf_exts_validate\n- 参数: [net, tp, tb, tca[TCA_RATE], &f->exts, flags, extack]\n- 调用者: fw_set_parms\n- 被调用者: (未在代码片段中显示)\n\n4. 函数名: nla_get_u32\n- 参数: [tb[TCA_FW_CLASSID], tb[TCA_FW_MASK]]\n- 调用者: fw_set_parms\n- 被调用者: (未在代码片段中显示)\n\n5. 函数名: tcf_bind_filter\n- 参数: [tp, &f->res, base]\n- 调用者: fw_set_parms\n- 被调用者: (未在代码片段中显示)\n\n6. 函数名: tcf_change_indev\n- 参数: [net, tb[TCA_FW_INDEV], extack]\n- 调用者: fw_set_parms\n- 被调用者: (未在代码片段中显示)"
    },
    {
        "id": 4136,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3812",
        "purpose": "Code purpose:\"\"\"该代码用于在TUN/TAP设备驱动中通过NAPI机制分配和组装网络数据包的片段，处理用户提供的分片数据并构建完整的sk_buff结构。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当启用napi frags时，恶意用户可生成过大的网络数据包，导致超出边界的内存访问，从而引发系统崩溃或权限提升。\"\"\"",
        "functions": "Functions:\n1. 函数名: tun_napi_alloc_frags\n- 参数: [tfile, len, it]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [ERR_PTR, local_bh_disable, napi_get_frags, local_bh_enable, iov_iter_single_seg_count, __skb_grow, netdev_alloc_frag, virt_to_head_page, page_address, skb_fill_page_desc, napi_free_frags]\n\n2. 函数名: ERR_PTR\n- 参数: [error_code]\n- 调用者: [tun_napi_alloc_frags]\n- 被调用者: []\n\n3. 函数名: local_bh_disable\n- 参数: []\n- 调用者: [tun_napi_alloc_frags]\n- 被调用者: []\n\n4. 函数名: napi_get_frags\n- 参数: [&tfile->napi]\n- 调用者: [tun_napi_alloc_frags]\n- 被调用者: []\n\n5. 函数名: local_bh_enable\n- 参数: []\n- 调用者: [tun_napi_alloc_frags]\n- 被调用者: []\n\n6. 函数名: iov_iter_single_seg_count\n- 参数: [it]\n- 调用者: [tun_napi_alloc_frags]\n- 被调用者: []\n\n7. 函数名: __skb_grow\n- 参数: [skb, linear]\n- 调用者: [tun_napi_alloc_frags]\n- 被调用者: []\n\n8. 函数名: netdev_alloc_frag\n- 参数: [fragsz]\n- 调用者: [tun_napi_alloc_frags]\n- 被调用者: []\n\n9. 函数名: virt_to_head_page\n- 参数: [frag]\n- 调用者: [tun_napi_alloc_frags]\n- 被调用者: []\n\n10. 函数名: page_address\n- 参数: [page]\n- 调用者: [tun_napi_alloc_frags]\n- 被调用者: []\n\n11. 函数名: skb_fill_page_desc\n- 参数: [skb, i - 1, page, frag - page_address(page), fragsz]\n- 调用者: [tun_napi_alloc_frags]\n- 被调用者: []\n\n12. 函数名: napi_free_frags\n- 参数: [&tfile->napi]\n- 调用者: [tun_napi_alloc_frags]\n- 被调用者: []"
    },
    {
        "id": 4143,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3863",
        "purpose": "Code purpose:\"\"\"该代码片段实现了NFC LLCP协议中发送SYMM（对称）PDU的功能，包括分配缓冲区、添加协议头并通过NFC进行数据交换\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在nfc_llcp_send_symm函数中，对nfc_llcp_find_local返回的local指针使用后未正确管理其生命周期，导致可能发生释放后重用(UAF)的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: nfc_llcp_send_symm\n- 参数: [struct nfc_dev *dev]\n- 调用者: 未显示\n- 被调用者: [nfc_llcp_find_local, alloc_skb, skb_reserve, llcp_add_header, __net_timestamp, nfc_llcp_send_to_raw_sock, nfc_data_exchange]\n\n2. 函数名: nfc_llcp_find_local\n- 参数: [struct nfc_dev *dev]\n- 调用者: nfc_llcp_send_symm\n- 被调用者: 未显示\n\n3. 函数名: alloc_skb\n- 参数: [size, GFP_KERNEL]\n- 调用者: nfc_llcp_send_symm\n- 被调用者: 未显示\n\n4. 函数名: skb_reserve\n- 参数: [struct sk_buff *skb, dev->tx_headroom + NFC_HEADER_SIZE]\n- 调用者: nfc_llcp_send_symm\n- 被调用者: 未显示\n\n5. 函数名: llcp_add_header\n- 参数: [struct sk_buff *skb, 0, 0, LLCP_PDU_SYMM]\n- 调用者: nfc_llcp_send_symm\n- 被调用者: 未显示\n\n6. 函数名: __net_timestamp\n- 参数: [struct sk_buff *skb]\n- 调用者: nfc_llcp_send_symm\n- 被调用者: 未显示\n\n7. 函数名: nfc_llcp_send_to_raw_sock\n- 参数: [struct nfc_llcp_local *local, struct sk_buff *skb, NFC_DIRECTION_TX]\n- 调用者: nfc_llcp_send_symm\n- 被调用者: 未显示\n\n8. 函数名: nfc_data_exchange\n- 参数: [struct nfc_dev *dev, local->target_idx, skb, nfc_llcp_recv, local]\n- 调用者: nfc_llcp_send_symm\n- 被调用者: 未显示"
    },
    {
        "id": 4144,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3863",
        "purpose": "Code purpose:\"\"\"该代码用于处理NFC LLCP协议中MAC层启动时的操作，包括设置本地设备参数并根据射频模式决定是调度传输工作还是修改链路定时器。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在nfc_llcp_mac_is_up函数中，未对nfc_llcp_find_local返回的local指针进行有效保护，导致可能在使用已被释放的内存区域时发生use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: nfc_llcp_mac_is_up\n- 参数: [struct nfc_dev *dev, u32 target_idx, u8 comm_mode, u8 rf_mode]\n- 调用者: 未显示\n- 被调用者: [nfc_llcp_find_local, pr_debug, schedule_work, mod_timer, msecs_to_jiffies]\n\n2. 函数名: nfc_llcp_find_local\n- 参数: [struct nfc_dev *dev]\n- 调用者: nfc_llcp_mac_is_up\n- 被调用者: 未显示\n\n3. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: nfc_llcp_mac_is_up\n- 被调用者: 未显示\n\n4. 函数名: schedule_work\n- 参数: [struct work_struct *work]\n- 调用者: nfc_llcp_mac_is_up\n- 被调用者: 未显示\n\n5. 函数名: mod_timer\n- 参数: [struct timer_list *timer, unsigned long expires]\n- 调用者: nfc_llcp_mac_is_up\n- 被调用者: 未显示\n\n6. 函数名: msecs_to_jiffies\n- 参数: [const unsigned int m]\n- 调用者: nfc_llcp_mac_is_up\n- 被调用者: 未显示"
    },
    {
        "id": 4145,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3863",
        "purpose": "Code purpose:\"\"\"在NFC设备链表中查找与指定设备匹配的本地LLCP连接对象\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在nfc_llcp_find_local函数中，返回的local指针可能指向已被释放的内存，导致后续使用时出现use-after-free问题\"\"\"",
        "functions": "Functions:\n1. 函数名: nfc_llcp_find_local\n- 参数: [struct nfc_dev *dev]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [list_for_each_entry, pr_debug]\n\n2. 函数名: list_for_each_entry\n- 参数: [local, &llcp_devices, list]\n- 调用者: nfc_llcp_find_local\n- 被调用者: 未明确（宏定义）\n\n3. 函数名: pr_debug\n- 参数: [\"No device found\\n\"]\n- 调用者: nfc_llcp_find_local\n- 被调用者: 未明确（内核打印函数）"
    },
    {
        "id": 4146,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3863",
        "purpose": "Code purpose:\"\"\"该代码用于在NFC协议栈中注销设备时清理相关本地资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在nfc_llcp_unregister_device函数中，调用nfc_llcp_local_put(local)后可能导致local指针被释放后仍被使用，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: nfc_llcp_unregister_device\n- 参数: [struct nfc_dev *dev]\n- 调用者: 未指定\n- 被调用者: [nfc_llcp_find_local, pr_debug, local_cleanup, nfc_llcp_local_put]\n\n2. 函数名: nfc_llcp_find_local\n- 参数: [struct nfc_dev *dev]\n- 调用者: nfc_llcp_unregister_device\n- 被调用者: 未指定\n\n3. 函数名: pr_debug\n- 参数: [\"No such device\\n\"]\n- 调用者: nfc_llcp_unregister_device\n- 被调用者: 未指定\n\n4. 函数名: local_cleanup\n- 参数: [struct nfc_llcp_local *local]\n- 调用者: nfc_llcp_unregister_device\n- 被调用者: 未指定\n\n5. 函数名: nfc_llcp_local_put\n- 参数: [struct nfc_llcp_local *local]\n- 调用者: nfc_llcp_unregister_device\n- 被调用者: 未指定"
    },
    {
        "id": 4147,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3863",
        "purpose": "Code purpose:\"\"\"增加NFC LLCP本地对象的引用计数并返回该对象\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在nfc_llcp_local_get函数中，未对local指针进行有效性检查就直接增加引用计数，可能导致在对象已被释放后仍被访问的use-after-free问题\"\"\"",
        "functions": "Functions:\n1. 函数名: nfc_llcp_local_get\n- 参数: [local]\n- 调用者: 未提供（需查看完整代码上下文）\n- 被调用者: [kref_get]"
    },
    {
        "id": 4148,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3863",
        "purpose": "Code purpose:\"\"\"该代码用于获取NFC设备的LLCP层通用字节数据及其长度\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在nfc_llcp_general_bytes函数中，返回了可能已被释放的local->gb指针，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nfc_llcp_general_bytes\n- 参数: [dev, general_bytes_len]\n- 调用者: 未显示\n- 被调用者: [nfc_llcp_find_local, nfc_llcp_build_gb]\n\n2. 函数名: nfc_llcp_find_local\n- 参数: [dev]\n- 调用者: nfc_llcp_general_bytes\n- 被调用者: 未显示\n\n3. 函数名: nfc_llcp_build_gb\n- 参数: [local]\n- 调用者: nfc_llcp_general_bytes\n- 被调用者: 未显示"
    },
    {
        "id": 4149,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3863",
        "purpose": "Code purpose:\"\"\"释放NFC LLCP本地连接资源并清理相关数据结构\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放local结构体后未清空引用，导致后续可能访问已释放内存区域，造成use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: local_release\n- 参数: [struct kref *ref]\n- 调用者: 未明确（通常由kref_put等引用计数函数调用）\n- 被调用者: [container_of, list_del, local_cleanup, kfree]\n\n2. 函数名: container_of\n- 参数: [ref, struct nfc_llcp_local, ref]\n- 调用者: local_release\n- 被调用者: []\n\n3. 函数名: list_del\n- 参数: [&local->list]\n- 调用者: local_release\n- 被调用者: []\n\n4. 函数名: local_cleanup\n- 参数: [local]\n- 调用者: local_release\n- 被调用者: []\n\n5. 函数名: kfree\n- 参数: [local]\n- 调用者: local_release\n- 被调用者: []"
    },
    {
        "id": 4150,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3863",
        "purpose": "Code purpose:\"\"\"该代码片段用于处理NFC LLCP层接收到的数据包，包括查找本地NFC设备并接收处理数据包\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在nfc_llcp_data_received函数中，调用nfc_llcp_find_local获取的local指针可能在使用后被释放，导致后续__nfc_llcp_recv函数使用时出现use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: nfc_llcp_data_received\n- 参数: [struct nfc_dev *dev, struct sk_buff *skb]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [nfc_llcp_find_local, kfree_skb, __nfc_llcp_recv]\n\n2. 函数名: nfc_llcp_find_local\n- 参数: [struct nfc_dev *dev]\n- 调用者: nfc_llcp_data_received\n- 被调用者: 未显示\n\n3. 函数名: kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: nfc_llcp_data_received\n- 被调用者: 未显示\n\n4. 函数名: __nfc_llcp_recv\n- 参数: [struct nfc_llcp_local *local, struct sk_buff *skb]\n- 调用者: nfc_llcp_data_received\n- 被调用者: 未显示"
    },
    {
        "id": 4151,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3863",
        "purpose": "Code purpose:\"\"\"该代码用于设置NFC LLCP协议中的远程设备全局字节(remote_gb)，包括验证输入长度、查找本地设备、复制数据并验证魔术字，最后解析TLV数据。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在nfc_llcp_find_local函数中返回的local指针可能指向已释放的内存，后续操作导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nfc_llcp_set_remote_gb\n- 参数: [struct nfc_dev *dev, const u8 *gb, u8 gb_len]\n- 调用者: 未显示\n- 被调用者: [nfc_llcp_find_local, memset, memcpy, memcmp, nfc_llcp_parse_gb_tlv]\n\n2. 函数名: nfc_llcp_find_local\n- 参数: [struct nfc_dev *dev]\n- 调用者: nfc_llcp_set_remote_gb\n- 被调用者: 未显示\n\n3. 函数名: memset\n- 参数: [local->remote_gb, 0, NFC_MAX_GT_LEN]\n- 调用者: nfc_llcp_set_remote_gb\n- 被调用者: 未显示\n\n4. 函数名: memcpy\n- 参数: [local->remote_gb, gb, gb_len]\n- 调用者: nfc_llcp_set_remote_gb\n- 被调用者: 未显示\n\n5. 函数名: memcmp\n- 参数: [local->remote_gb, llcp_magic, 3]\n- 调用者: nfc_llcp_set_remote_gb\n- 被调用者: 未显示\n\n6. 函数名: nfc_llcp_parse_gb_tlv\n- 参数: [local, &local->remote_gb[3], local->remote_gb_len - 3]\n- 调用者: nfc_llcp_set_remote_gb\n- 被调用者: 未显示"
    },
    {
        "id": 4152,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3863",
        "purpose": "Code purpose:\"\"\"该代码用于在NFC设备MAC层断开时，重置远程设备参数并释放所有相关套接字资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在nfc_llcp_mac_is_down函数中，调用nfc_llcp_find_local获取的local指针可能已被释放，后续操作导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nfc_llcp_mac_is_down\n- 参数: [struct nfc_dev *dev]\n- 调用者: 未显示\n- 被调用者: [nfc_llcp_find_local, nfc_llcp_socket_release]\n\n2. 函数名: nfc_llcp_find_local\n- 参数: [struct nfc_dev *dev]\n- 调用者: nfc_llcp_mac_is_down\n- 被调用者: 未显示\n\n3. 函数名: nfc_llcp_socket_release\n- 参数: [struct nfc_llcp_local *local, bool, int]\n- 调用者: nfc_llcp_mac_is_down\n- 被调用者: 未显示"
    },
    {
        "id": 4153,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3863",
        "purpose": "Code purpose:\"\"\"该代码实现了NFC LLCP协议中socket连接的功能，包括设备查找、连接状态管理和资源分配等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在nfc_llcp_find_local函数中，当查找本地NFC设备时未正确管理引用计数，导致后续操作可能访问已释放的内存区域，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: llcp_sock_connect\n- 参数: [sock, _addr, len, flags]\n- 调用者: 无（顶层函数）\n- 被调用者: [nfc_llcp_sock, lock_sock, nfc_get_device, nfc_llcp_find_local, device_lock, device_unlock, nfc_llcp_local_get, nfc_llcp_get_local_ssap, kmemdup, nfc_llcp_sock_link, nfc_llcp_send_connect, sock_wait_state, release_sock, nfc_llcp_sock_unlink, kfree, nfc_llcp_put_ssap, nfc_llcp_local_put, nfc_put_device]\n\n2. 函数名: nfc_llcp_sock\n- 参数: [sk]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n3. 函数名: lock_sock\n- 参数: [sk]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n4. 函数名: nfc_get_device\n- 参数: [addr->dev_idx]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n5. 函数名: nfc_llcp_find_local\n- 参数: [dev]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n6. 函数名: device_lock\n- 参数: [&dev->dev]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n7. 函数名: device_unlock\n- 参数: [&dev->dev]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n8. 函数名: nfc_llcp_local_get\n- 参数: [local]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n9. 函数名: nfc_llcp_get_local_ssap\n- 参数: [local]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n10. 函数名: kmemdup\n- 参数: [addr->service_name, llcp_sock->service_name_len, GFP_KERNEL]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n11. 函数名: nfc_llcp_sock_link\n- 参数: [&local->connecting_sockets, sk]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n12. 函数名: nfc_llcp_send_connect\n- 参数: [llcp_sock]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n13. 函数名: sock_wait_state\n- 参数: [sk, LLCP_CONNECTED, sock_sndtimeo(sk, flags & O_NONBLOCK)]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n14. 函数名: release_sock\n- 参数: [sk]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n15. 函数名: nfc_llcp_sock_unlink\n- 参数: [&local->connecting_sockets, sk]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n16. 函数名: kfree\n- 参数: [llcp_sock->service_name]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n17. 函数名: nfc_llcp_put_ssap\n- 参数: [local, llcp_sock->ssap]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n18. 函数名: nfc_llcp_local_put\n- 参数: [llcp_sock->local]\n- 调用者: llcp_sock_connect\n- 被调用者: 无\n\n19. 函数名: nfc_put_device\n- 参数: [dev]\n- 调用者: llcp_sock_connect\n- 被调用者: 无"
    },
    {
        "id": 4154,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3863",
        "purpose": "Code purpose:\"\"\"该代码实现了NFC LLCP协议中原始套接字的绑定功能，包括验证地址信息、查找本地设备、关联套接字与设备等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在llcp_raw_sock_bind函数中，当nfc_llcp_find_local返回NULL时，直接跳转到put_dev标签释放dev设备，但未正确处理local指针可能导致后续使用已释放的内存\"\"\"",
        "functions": "Functions:\n1. 函数名: llcp_raw_sock_bind\n- 参数: [sock, addr, alen]\n- 调用者: 未显示（通常由socket绑定操作调用）\n- 被调用者: [nfc_llcp_sock, offsetofend, pr_debug, memset, min_t, memcpy, lock_sock, nfc_get_device, nfc_llcp_find_local, nfc_llcp_local_get, nfc_llcp_sock_link, nfc_put_device, release_sock]\n\n2. 函数名: nfc_llcp_sock\n- 参数: [sk]\n- 调用者: llcp_raw_sock_bind\n- 被调用者: []\n\n3. 函数名: offsetofend\n- 参数: [struct sockaddr, sa_family]\n- 调用者: llcp_raw_sock_bind\n- 被调用者: []\n\n4. 函数名: pr_debug\n- 参数: [format string, sk, addr, addr->sa_family]\n- 调用者: llcp_raw_sock_bind\n- 被调用者: []\n\n5. 函数名: memset\n- 参数: [&llcp_addr, 0, sizeof(llcp_addr)]\n- 调用者: llcp_raw_sock_bind\n- 被调用者: []\n\n6. 函数名: min_t\n- 参数: [unsigned int, sizeof(llcp_addr), alen]\n- 调用者: llcp_raw_sock_bind\n- 被调用者: []\n\n7. 函数名: memcpy\n- 参数: [&llcp_addr, addr, len]\n- 调用者: llcp_raw_sock_bind\n- 被调用者: []\n\n8. 函数名: lock_sock\n- 参数: [sk]\n- 调用者: llcp_raw_sock_bind\n- 被调用者: []\n\n9. 函数名: nfc_get_device\n- 参数: [llcp_addr.dev_idx]\n- 调用者: llcp_raw_sock_bind\n- 被调用者: []\n\n10. 函数名: nfc_llcp_find_local\n- 参数: [dev]\n- 调用者: llcp_raw_sock_bind\n- 被调用者: []\n\n11. 函数名: nfc_llcp_local_get\n- 参数: [local]\n- 调用者: llcp_raw_sock_bind\n- 被调用者: []\n\n12. 函数名: nfc_llcp_sock_link\n- 参数: [&local->raw_sockets, sk]\n- 调用者: llcp_raw_sock_bind\n- 被调用者: []\n\n13. 函数名: nfc_put_device\n- 参数: [dev]\n- 调用者: llcp_raw_sock_bind\n- 被调用者: []\n\n14. 函数名: release_sock\n- 参数: [sk]\n- 调用者: llcp_raw_sock_bind\n- 被调用者: []"
    },
    {
        "id": 4155,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3863",
        "purpose": "Code purpose:\"\"\"该代码实现了NFC LLCP协议中套接字绑定功能，包括验证地址信息、设备查找、服务名分配和状态管理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在nfc_llcp_find_local函数中，由于未正确处理本地对象的引用计数，导致在后续操作中可能发生释放后重用(UAF)的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: llcp_sock_bind\n- 参数: [struct socket *sock, struct sockaddr *addr, int alen]\n- 调用者: 未显示\n- 被调用者: [nfc_llcp_sock, min_t, memcpy, lock_sock, nfc_get_device, nfc_llcp_find_local, nfc_llcp_local_get, kmemdup, nfc_llcp_get_sdp_ssap, nfc_llcp_sock_link, nfc_put_device, release_sock, kfree, nfc_llcp_local_put]\n\n2. 函数名: nfc_llcp_sock\n- 参数: [struct sock *sk]\n- 调用者: llcp_sock_bind\n- 被调用者: 未显示\n\n3. 函数名: min_t\n- 参数: [unsigned int, sizeof(llcp_addr), alen]\n- 调用者: llcp_sock_bind\n- 被调用者: 未显示\n\n4. 函数名: memcpy\n- 参数: [&llcp_addr, addr, len]\n- 调用者: llcp_sock_bind\n- 被调用者: 未显示\n\n5. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: llcp_sock_bind\n- 被调用者: 未显示\n\n6. 函数名: nfc_get_device\n- 参数: [llcp_addr.dev_idx]\n- 调用者: llcp_sock_bind\n- 被调用者: 未显示\n\n7. 函数名: nfc_llcp_find_local\n- 参数: [dev]\n- 调用者: llcp_sock_bind\n- 被调用者: 未显示\n\n8. 函数名: nfc_llcp_local_get\n- 参数: [local]\n- 调用者: llcp_sock_bind\n- 被调用者: 未显示\n\n9. 函数名: kmemdup\n- 参数: [llcp_addr.service_name, llcp_sock->service_name_len, GFP_KERNEL]\n- 调用者: llcp_sock_bind\n- 被调用者: 未显示\n\n10. 函数名: nfc_llcp_get_sdp_ssap\n- 参数: [local, llcp_sock]\n- 调用者: llcp_sock_bind\n- 被调用者: 未显示\n\n11. 函数名: nfc_llcp_sock_link\n- 参数: [&local->sockets, sk]\n- 调用者: llcp_sock_bind\n- 被调用者: 未显示\n\n12. 函数名: nfc_put_device\n- 参数: [dev]\n- 调用者: llcp_sock_bind\n- 被调用者: 未显示\n\n13. 函数名: release_sock\n- 参数: [sk]\n- 调用者: llcp_sock_bind\n- 被调用者: 未显示\n\n14. 函数名: kfree\n- 参数: [llcp_sock->service_name]\n- 调用者: llcp_sock_bind\n- 被调用者: 未显示\n\n15. 函数名: nfc_llcp_local_put\n- 参数: [llcp_sock->local]\n- 调用者: llcp_sock_bind\n- 被调用者: 未显示"
    },
    {
        "id": 4156,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3863",
        "purpose": "Code purpose:\"\"\"该代码用于设置NFC设备的LLC层参数，包括超时时间(LTO)、接收窗口大小(RW)和最大信息单元扩展(MIUX)。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放设备锁后继续访问已释放的local指针，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nfc_genl_llc_set_params\n- 参数: [struct sk_buff *skb, struct genl_info *info]\n- 调用者: 未显示（由GENL框架调用）\n- 被调用者: [nla_get_u8, nla_get_u16, nla_get_u32, nfc_get_device, device_lock, nfc_llcp_find_local, device_unlock, nfc_put_device]\n\n2. 函数名: nla_get_u8\n- 参数: [struct nlattr *nla]\n- 调用者: nfc_genl_llc_set_params\n- 被调用者: []\n\n3. 函数名: nla_get_u16\n- 参数: [struct nlattr *nla]\n- 调用者: nfc_genl_llc_set_params\n- 被调用者: []\n\n4. 函数名: nla_get_u32\n- 参数: [struct nlattr *nla]\n- 调用者: nfc_genl_llc_set_params\n- 被调用者: []\n\n5. 函数名: nfc_get_device\n- 参数: [u32 idx]\n- 调用者: nfc_genl_llc_set_params\n- 被调用者: []\n\n6. 函数名: device_lock\n- 参数: [struct device *dev]\n- 调用者: nfc_genl_llc_set_params\n- 被调用者: []\n\n7. 函数名: nfc_llcp_find_local\n- 参数: [struct nfc_dev *dev]\n- 调用者: nfc_genl_llc_set_params\n- 被调用者: []\n\n8. 函数名: device_unlock\n- 参数: [struct device *dev]\n- 调用者: nfc_genl_llc_set_params\n- 被调用者: []\n\n9. 函数名: nfc_put_device\n- 参数: [struct nfc_dev *dev]\n- 调用者: nfc_genl_llc_set_params\n- 被调用者: []"
    },
    {
        "id": 4157,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3863",
        "purpose": "Code purpose:\"\"\"处理NFC设备的LLCP协议服务发现请求，包括解析请求参数、构建服务描述符并发送响应。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在nfc_llcp_find_local函数中，当查找本地NFC设备时未正确管理引用计数，导致释放后使用(UAF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nfc_genl_llc_sdreq\n- 参数: [struct sk_buff *skb, struct genl_info *info]\n- 调用者: 未显示（由GENL框架调用）\n- 被调用者: [nla_get_u32, nfc_get_device, device_lock, nfc_llcp_find_local, INIT_HLIST_HEAD, nla_for_each_nested, nla_parse_nested_deprecated, nla_len, nla_data, nfc_llcp_build_sdreq_tlv, hlist_add_head, hlist_empty, nfc_llcp_send_snl_sdreq, device_unlock, nfc_put_device]\n\n2. 函数名: nla_get_u32\n- 参数: [struct nlattr *nla]\n- 调用者: nfc_genl_llc_sdreq\n- 被调用者: []\n\n3. 函数名: nfc_get_device\n- 参数: [u32 idx]\n- 调用者: nfc_genl_llc_sdreq\n- 被调用者: []\n\n4. 函数名: device_lock\n- 参数: [struct device *dev]\n- 调用者: nfc_genl_llc_sdreq\n- 被调用者: []\n\n5. 函数名: nfc_llcp_find_local\n- 参数: [struct nfc_dev *dev]\n- 调用者: nfc_genl_llc_sdreq\n- 被调用者: []\n\n6. 函数名: INIT_HLIST_HEAD\n- 参数: [struct hlist_head *h]\n- 调用者: nfc_genl_llc_sdreq\n- 被调用者: []\n\n7. 函数名: nla_for_each_nested\n- 参数: [struct nlattr *nla, struct nlattr *rem, int rem]\n- 调用者: nfc_genl_llc_sdreq\n- 被调用者: []\n\n8. 函数名: nla_parse_nested_deprecated\n- 参数: [struct nlattr **tb, int maxtype, struct nlattr *nla, const struct nla_policy *policy, struct netlink_ext_ack *extack]\n- 调用者: nfc_genl_llc_sdreq\n- 被调用者: []\n\n9. 函数名: nla_len\n- 参数: [struct nlattr *nla]\n- 调用者: nfc_genl_llc_sdreq\n- 被调用者: []\n\n10. 函数名: nla_data\n- 参数: [struct nlattr *nla]\n- 调用者: nfc_genl_llc_sdreq\n- 被调用者: []\n\n11. 函数名: nfc_llcp_build_sdreq_tlv\n- 参数: [u8 tid, char *uri, size_t uri_len]\n- 调用者: nfc_genl_llc_sdreq\n- 被调用者: []\n\n12. 函数名: hlist_add_head\n- 参数: [struct hlist_node *n, struct hlist_head *h]\n- 调用者: nfc_genl_llc_sdreq\n- 被调用者: []\n\n13. 函数名: hlist_empty\n- 参数: [struct hlist_head *h]\n- 调用者: nfc_genl_llc_sdreq\n- 被调用者: []\n\n14. 函数名: nfc_llcp_send_snl_sdreq\n- 参数: [struct nfc_llcp_local *local, struct hlist_head *sdreq_list, size_t tlvs_len]\n- 调用者: nfc_genl_llc_sdreq\n- 被调用者: []\n\n15. 函数名: device_unlock\n- 参数: [struct device *dev]\n- 调用者: nfc_genl_llc_sdreq\n- 被调用者: []\n\n16. 函数名: nfc_put_device\n- 参数: [struct nfc_dev *dev]\n- 调用者: nfc_genl_llc_sdreq\n- 被调用者: []"
    },
    {
        "id": 4158,
        "cwe": "CWE-416",
        "cve": "CVE-2023-3863",
        "purpose": "Code purpose:\"\"\"该代码用于通过NFC通用netlink接口获取NFC设备的LLCP层参数，并将参数信息通过netlink消息返回给请求者。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放local对象后仍可能通过msg继续访问该对象，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nfc_genl_llc_get_params\n- 参数: [skb, info]\n- 调用者: 未显示（由GENL框架调用）\n- 被调用者: [nla_get_u32, nfc_get_device, device_lock, nfc_llcp_find_local, nlmsg_new, nfc_genl_send_params, device_unlock, nfc_put_device, nlmsg_free, genlmsg_reply]\n\n2. 函数名: nla_get_u32\n- 参数: [info->attrs[NFC_ATTR_DEVICE_INDEX]]\n- 调用者: nfc_genl_llc_get_params\n- 被调用者: []\n\n3. 函数名: nfc_get_device\n- 参数: [idx]\n- 调用者: nfc_genl_llc_get_params\n- 被调用者: []\n\n4. 函数名: device_lock\n- 参数: [&dev->dev]\n- 调用者: nfc_genl_llc_get_params\n- 被调用者: []\n\n5. 函数名: nfc_llcp_find_local\n- 参数: [dev]\n- 调用者: nfc_genl_llc_get_params\n- 被调用者: []\n\n6. 函数名: nlmsg_new\n- 参数: [NLMSG_DEFAULT_SIZE, GFP_KERNEL]\n- 调用者: nfc_genl_llc_get_params\n- 被调用者: []\n\n7. 函数名: nfc_genl_send_params\n- 参数: [msg, local, info->snd_portid, info->snd_seq]\n- 调用者: nfc_genl_llc_get_params\n- 被调用者: []\n\n8. 函数名: device_unlock\n- 参数: [&dev->dev]\n- 调用者: nfc_genl_llc_get_params\n- 被调用者: []\n\n9. 函数名: nfc_put_device\n- 参数: [dev]\n- 调用者: nfc_genl_llc_get_params\n- 被调用者: []\n\n10. 函数名: nlmsg_free\n- 参数: [msg]\n- 调用者: nfc_genl_llc_get_params\n- 被调用者: []\n\n11. 函数名: genlmsg_reply\n- 参数: [msg, info]\n- 调用者: nfc_genl_llc_get_params\n- 被调用者: []"
    },
    {
        "id": 4185,
        "cwe": "CWE-416",
        "cve": "CVE-2023-39198",
        "purpose": "Code purpose:\"\"\"该代码用于在QXL驱动中创建一个简单的显示缓冲区对象，处理显示模式参数并生成对应的表面格式和句柄\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于qxl_mode_dumb_create()函数在仅通过handle持有qobj引用的情况下直接解引用qobj，攻击者可通过猜测handle值触发竞态条件导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: qxl_mode_dumb_create\n- 参数: [struct drm_file *file_priv, struct drm_device *dev, struct drm_mode_create_dumb *args]\n- 调用者: 未指定\n- 被调用者: [to_qxl, qxl_gem_object_create_with_handle]\n\n2. 函数名: to_qxl\n- 参数: [struct drm_device *dev]\n- 调用者: qxl_mode_dumb_create\n- 被调用者: []\n\n3. 函数名: qxl_gem_object_create_with_handle\n- 参数: [struct qxl_device *qdev, struct drm_file *file_priv, QXL_GEM_DOMAIN_CPU, args->size, &surf, &qobj, &handle]\n- 调用者: qxl_mode_dumb_create\n- 被调用者: []"
    },
    {
        "id": 4186,
        "cwe": "CWE-416",
        "cve": "CVE-2023-39198",
        "purpose": "Code purpose:\"\"\"该代码实现了QXL驱动中分配表面缓冲区的功能，通过创建带有句柄的GEM对象来管理图形表面内存。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于qxl_gem_object_create_with_handle()返回的qobj仅由handle持有引用，攻击者可通过猜测handle值触发竞态条件导致释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: qxl_alloc_surf_ioctl\n- 参数: [struct drm_device *dev, void *data, struct drm_file *file]\n- 调用者: 未显示（由DRM框架调用）\n- 被调用者: [to_qxl, qxl_gem_object_create_with_handle]\n\n2. 函数名: to_qxl\n- 参数: [struct drm_device *dev]\n- 调用者: qxl_alloc_surf_ioctl\n- 被调用者: []\n\n3. 函数名: qxl_gem_object_create_with_handle\n- 参数: [struct qxl_device *qdev, struct drm_file *file, QXL_GEM_DOMAIN_SURFACE, int size, struct qxl_surface *surf, struct qxl_bo **qobj, int *handle]\n- 调用者: qxl_alloc_surf_ioctl\n- 被调用者: []"
    },
    {
        "id": 4187,
        "cwe": "CWE-416",
        "cve": "CVE-2023-39198",
        "purpose": "Code purpose:\"\"\"该代码用于在QXL驱动中通过ioctl调用分配图形内存对象并返回对应的句柄\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于qxl_alloc_ioctl()函数中创建的qobj对象仅由handle持有引用，攻击者可通过猜测handle值触发竞态条件导致释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: qxl_alloc_ioctl\n- 参数: [struct drm_device *dev, void *data, struct drm_file *file_priv]\n- 调用者: 未显示（应为DRM子系统ioctl调用）\n- 被调用者: [to_qxl, qxl_gem_object_create_with_handle]\n\n2. 函数名: to_qxl\n- 参数: [struct drm_device *dev]\n- 调用者: qxl_alloc_ioctl\n- 被调用者: []\n\n3. 函数名: qxl_gem_object_create_with_handle\n- 参数: [struct qxl_device *qdev, struct drm_file *file_priv, u32 domain, size_t size, NULL, struct qxl_bo **qobj, uint32_t *handle]\n- 调用者: qxl_alloc_ioctl\n- 被调用者: []"
    },
    {
        "id": 4188,
        "cwe": "CWE-416",
        "cve": "CVE-2023-4015",
        "purpose": "Code purpose:\"\"\"处理nftables规则中立即表达式的停用操作，包括解绑链和释放相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在构建nftables规则出错时，nft_immediate_deactivate()函数解除绑定链后仍可能使用已被释放的链对象，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_immediate_deactivate\n- 参数: [const struct nft_ctx *ctx, const struct nft_expr *expr, enum nft_trans_phase phase]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [nft_expr_priv, nft_chain_binding, list_for_each_entry, nft_rule_expr_deactivate, nf_tables_unbind_chain, nft_deactivate_next, nft_chain_del, nft_use_dec, nft_data_release, nft_dreg_to_type]\n\n2. 函数名: nft_expr_priv\n- 参数: [const struct nft_expr *expr]\n- 调用者: nft_immediate_deactivate\n- 被调用者: 未明确\n\n3. 函数名: nft_chain_binding\n- 参数: [struct nft_chain *chain]\n- 调用者: nft_immediate_deactivate\n- 被调用者: 未明确\n\n4. 函数名: list_for_each_entry\n- 参数: [rule, &chain->rules, list]\n- 调用者: nft_immediate_deactivate\n- 被调用者: 未明确\n\n5. 函数名: nft_rule_expr_deactivate\n- 参数: [&chain_ctx, rule, phase]\n- 调用者: nft_immediate_deactivate\n- 被调用者: 未明确\n\n6. 函数名: nf_tables_unbind_chain\n- 参数: [ctx, chain]\n- 调用者: nft_immediate_deactivate\n- 被调用者: 未明确\n\n7. 函数名: nft_deactivate_next\n- 参数: [ctx->net, chain]\n- 调用者: nft_immediate_deactivate\n- 被调用者: 未明确\n\n8. 函数名: nft_chain_del\n- 参数: [chain]\n- 调用者: nft_immediate_deactivate\n- 被调用者: 未明确\n\n9. 函数名: nft_use_dec\n- 参数: [&chain->table->use]\n- 调用者: nft_immediate_deactivate\n- 被调用者: 未明确\n\n10. 函数名: nft_data_release\n- 参数: [&priv->data, nft_dreg_to_type(priv->dreg)]\n- 调用者: nft_immediate_deactivate\n- 被调用者: 未明确\n\n11. 函数名: nft_dreg_to_type\n- 参数: [priv->dreg]\n- 调用者: nft_data_release\n- 被调用者: 未明确"
    },
    {
        "id": 4189,
        "cwe": "CWE-416",
        "cve": "CVE-2023-40283",
        "purpose": "Code purpose:\"\"\"释放L2CAP套接字资源并处理相关通道的关闭操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放套接字资源时未正确处理子套接字，导致对已释放内存的后续引用\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_sock_release\n- 参数: [struct socket *sock]\n- 调用者: N/A\n- 被调用者: [bt_sock_unlink, l2cap_sock_shutdown, l2cap_pi, l2cap_chan_hold, l2cap_chan_lock, sock_orphan, l2cap_sock_kill, l2cap_chan_unlock, l2cap_chan_put]\n\n2. 函数名: bt_sock_unlink\n- 参数: [&l2cap_sk_list, sk]\n- 调用者: l2cap_sock_release\n- 被调用者: N/A\n\n3. 函数名: l2cap_sock_shutdown\n- 参数: [sock, SHUT_RDWR]\n- 调用者: l2cap_sock_release\n- 被调用者: N/A\n\n4. 函数名: l2cap_pi\n- 参数: [sk]\n- 调用者: l2cap_sock_release\n- 被调用者: N/A\n\n5. 函数名: l2cap_chan_hold\n- 参数: [chan]\n- 调用者: l2cap_sock_release\n- 被调用者: N/A\n\n6. 函数名: l2cap_chan_lock\n- 参数: [chan]\n- 调用者: l2cap_sock_release\n- 被调用者: N/A\n\n7. 函数名: sock_orphan\n- 参数: [sk]\n- 调用者: l2cap_sock_release\n- 被调用者: N/A\n\n8. 函数名: l2cap_sock_kill\n- 参数: [sk]\n- 调用者: l2cap_sock_release\n- 被调用者: N/A\n\n9. 函数名: l2cap_chan_unlock\n- 参数: [chan]\n- 调用者: l2cap_sock_release\n- 被调用者: N/A\n\n10. 函数名: l2cap_chan_put\n- 参数: [chan]\n- 调用者: l2cap_sock_release\n- 被调用者: N/A"
    },
    {
        "id": 4192,
        "cwe": "CWE-416",
        "cve": "CVE-2023-4132",
        "purpose": "Code purpose:\"\"\"停止smsusb设备的所有URB传输并释放相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在停止流传输时未正确处理urb和回调缓冲区的释放顺序，导致可能在使用已被释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: smsusb_stop_streaming\n- 参数: [dev]\n- 调用者: 未显示在代码片段中\n- 被调用者: [usb_kill_urb, cancel_work_sync, smscore_putbuffer]\n\n2. 函数名: usb_kill_urb\n- 参数: [&dev->surbs[i].urb]\n- 调用者: smsusb_stop_streaming\n- 被调用者: 未显示在代码片段中\n\n3. 函数名: cancel_work_sync\n- 参数: [&dev->surbs[i].wq]\n- 调用者: smsusb_stop_streaming\n- 被调用者: 未显示在代码片段中\n\n4. 函数名: smscore_putbuffer\n- 参数: [dev->coredev, dev->surbs[i].cb]\n- 调用者: smsusb_stop_streaming\n- 被调用者: 未显示在代码片段中"
    },
    {
        "id": 4193,
        "cwe": "CWE-416",
        "cve": "CVE-2023-4133",
        "purpose": "Code purpose:\"\"\"清理cxgb4驱动中与TC flower相关的资源，包括定时器、工作队列和哈希表，并标记初始化状态为false\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在设备分离时，flower_stats_timer可能从工作队列中重新启动，导致定时器被释放后仍可能被访问，引发释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: cxgb4_cleanup_tc_flower\n- 参数: [adap]\n- 调用者: N/A\n- 被调用者: [del_timer_sync, cancel_work_sync, rhashtable_destroy]\n\n2. 函数名: del_timer_sync\n- 参数: [&adap->flower_stats_timer]\n- 调用者: cxgb4_cleanup_tc_flower\n- 被调用者: N/A\n\n3. 函数名: cancel_work_sync\n- 参数: [&adap->flower_stats_work]\n- 调用者: cxgb4_cleanup_tc_flower\n- 被调用者: N/A\n\n4. 函数名: rhashtable_destroy\n- 参数: [&adap->flower_tbl]\n- 调用者: cxgb4_cleanup_tc_flower\n- 被调用者: N/A"
    },
    {
        "id": 4198,
        "cwe": "CWE-416",
        "cve": "CVE-2023-4206",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的网络流量控制子系统中处理路由过滤器的创建、修改和删除操作，主要功能是管理路由过滤器的生命周期和属性更新。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在更新绑定到类的过滤器时，route4_change()函数总是将整个tcf_result结构复制到新过滤器实例中，并在成功路径中对旧实例调用tcf_unbind_filter()，导致仍被引用的类的filter_cnt减少并可能被删除，从而引发释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: route4_change\n- 参数: [net, in_skb, tp, base, handle, tca, arg, flags, extack]\n- 调用者: 未明确（由内核网络调度模块调用）\n- 被调用者: [nla_parse_nested_deprecated, kzalloc, tcf_exts_init, route4_set_parms, rtnl_dereference, tcf_block_netif_keep_dst, rcu_assign_pointer, route4_reset_fastmap, tcf_unbind_filter, tcf_exts_get_net, tcf_queue_work, tcf_exts_destroy, kfree]\n\n2. 函数名: nla_parse_nested_deprecated\n- 参数: [tb, TCA_ROUTE4_MAX, opt, route4_policy, NULL]\n- 调用者: route4_change\n- 被调用者: 未明确（内核网络属性解析函数）\n\n3. 函数名: kzalloc\n- 参数: [sizeof(struct route4_filter), GFP_KERNEL]\n- 调用者: route4_change\n- 被调用者: 未明确（内核内存分配函数）\n\n4. 函数名: tcf_exts_init\n- 参数: [&f->exts, net, TCA_ROUTE4_ACT, TCA_ROUTE4_POLICE]\n- 调用者: route4_change\n- 被调用者: 未明确（流量控制扩展初始化函数）\n\n5. 函数名: route4_set_parms\n- 参数: [net, tp, base, f, handle, head, tb, tca[TCA_RATE], new, flags, extack]\n- 调用者: route4_change\n- 被调用者: 未明确（路由过滤器参数设置函数）\n\n6. 函数名: rtnl_dereference\n- 参数: [*fp], [head->table[th]], [*fp]\n- 调用者: route4_change\n- 被调用者: 未明确（RCU解引用函数）\n\n7. 函数名: tcf_block_netif_keep_dst\n- 参数: [tp->chain->block]\n- 调用者: route4_change\n- 被调用者: 未明确（流量控制块网络接口函数）\n\n8. 函数名: rcu_assign_pointer\n- 参数: [f->next, f1], [*fp, f], [*fp, fold->next]\n- 调用者: route4_change\n- 被调用者: 未明确（RCU指针赋值函数）\n\n9. 函数名: route4_reset_fastmap\n- 参数: [head]\n- 调用者: route4_change\n- 被调用者: 未明确（路由快速映射重置函数）\n\n10. 函数名: tcf_unbind_filter\n- 参数: [tp, &fold->res]\n- 调用者: route4_change\n- 被调用者: 未明确（流量控制过滤器解绑函数）\n\n11. 函数名: tcf_exts_get_net\n- 参数: [&fold->exts]\n- 调用者: route4_change\n- 被调用者: 未明确（获取扩展的网络命名空间函数）\n\n12. 函数名: tcf_queue_work\n- 参数: [&fold->rwork, route4_delete_filter_work]\n- 调用者: route4_change\n- 被调用者: 未明确（排队工作函数）\n\n13. 函数名: tcf_exts_destroy\n- 参数: [&f->exts]\n- 调用者: route4_change\n- 被调用者: 未明确（销毁流量控制扩展函数）\n\n14. 函数名: kfree\n- 参数: [f]\n- 调用者: route4_change\n- 被调用者: 未明确（内核内存释放函数）"
    },
    {
        "id": 4199,
        "cwe": "CWE-416",
        "cve": "CVE-2023-4207",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核网络分类器cls_fw中过滤器的创建、修改和更新功能，处理网络流量分类规则的相关操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在更新绑定到类的过滤器时，fw_change()函数总是将整个tcf_result结构复制到新实例并调用tcf_unbind_filter()释放旧实例，导致仍被引用的类的filter_cnt被错误减少从而可能被删除，引发释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: fw_change\n- 参数: [net, in_skb, tp, base, handle, tca, arg, flags, extack]\n- 调用者: 未知（由内核调度）\n- 被调用者: [rtnl_dereference, nla_parse_nested_deprecated, kzalloc, tcf_exts_init, fw_set_parms, tcf_exts_destroy, kfree, fw_hash, RCU_INIT_POINTER, rcu_assign_pointer, tcf_unbind_filter, tcf_exts_get_net, tcf_queue_work, nla_get_u32]\n\n2. 函数名: fw_set_parms\n- 参数: [net, tp, fnew, tb, tca, base, flags, extack]\n- 调用者: fw_change\n- 被调用者: 未知（代码片段中未显示）\n\n3. 函数名: fw_delete_filter_work\n- 参数: 未知（仅通过指针引用）\n- 调用者: tcf_queue_work\n- 被调用者: 未知（代码片段中未显示）\n\n4. 函数名: fw_hash\n- 参数: [handle或fnew->id]\n- 调用者: fw_change\n- 被调用者: 未知（代码片段中未显示）\n\n5. 函数名: rtnl_dereference\n- 参数: [tp->root或*fp或pfp->next]\n- 调用者: fw_change\n- 被调用者: 未知（内核函数）\n\n6. 函数名: nla_parse_nested_deprecated\n- 参数: [tb, TCA_FW_MAX, opt, fw_policy, NULL]\n- 调用者: fw_change\n- 被调用者: 未知（内核函数）\n\n7. 函数名: kzalloc\n- 参数: [sizeof(struct fw_filter), GFP_KERNEL]或[sizeof(*head), GFP_KERNEL]\n- 调用者: fw_change\n- 被调用者: 未知（内核函数）\n\n8. 函数名: tcf_exts_init\n- 参数: [&fnew->exts, net, TCA_FW_ACT, TCA_FW_POLICE]或[&f->exts, net, TCA_FW_ACT, TCA_FW_POLICE]\n- 调用者: fw_change\n- 被调用者: 未知（内核函数）\n\n9. 函数名: tcf_exts_destroy\n- 参数: [&fnew->exts]或[&f->exts]\n- 调用者: fw_change\n- 被调用者: 未知（内核函数）\n\n10. 函数名: kfree\n- 参数: [fnew]或[f]\n- 调用者: fw_change\n- 被调用者: 未知（内核函数）\n\n11. 函数名: RCU_INIT_POINTER\n- 参数: [fnew->next, rtnl_dereference(pfp->next)]或[f->next, head->ht[fw_hash(handle)]]\n- 调用者: fw_change\n- 被调用者: 未知（内核函数）\n\n12. 函数名: rcu_assign_pointer\n- 参数: [*fp, fnew]或[tp->root, head]或[head->ht[fw_hash(handle)], f]\n- 调用者: fw_change\n- 被调用者: 未知（内核函数）\n\n13. 函数名: tcf_unbind_filter\n- 参数: [tp, &f->res]\n- 调用者: fw_change\n- 被调用者: 未知（内核函数）\n\n14. 函数名: tcf_exts_get_net\n- 参数: [&f->exts]\n- 调用者: fw_change\n- 被调用者: 未知（内核函数）\n\n15. 函数名: tcf_queue_work\n- 参数: [&f->rwork, fw_delete_filter_work]\n- 调用者: fw_change\n- 被调用者: 未知（内核函数）\n\n16. 函数名: nla_get_u32\n- 参数: [tb[TCA_FW_MASK]]\n- 调用者: fw_change\n- 被调用者: 未知（内核函数）"
    },
    {
        "id": 4200,
        "cwe": "CWE-416",
        "cve": "CVE-2023-4208",
        "purpose": "Code purpose:\"\"\"初始化一个新的tc_u_knode结构体，用于Linux内核网络流量控制中的u32分类器，并复制相关参数和统计信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在更新绑定到类的过滤器时，旧实例的tcf_unbind_filter()操作会减少仍被引用的类的filter_cnt，导致类可能被提前删除从而引发释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: u32_init_knode\n- 参数: [net, tp, n]\n- 调用者: 未明确显示（应为调用u32_change的相关函数）\n- 被调用者: [kzalloc, RCU_INIT_POINTER, memcpy, tcf_exts_init, kfree]\n\n2. 函数名: kzalloc\n- 参数: [struct_size(new, sel.keys, s->nkeys), GFP_KERNEL]\n- 调用者: u32_init_knode\n- 被调用者: []\n\n3. 函数名: RCU_INIT_POINTER\n- 参数: [new->next, n->next], [new->ht_up, n->ht_up], [new->ht_down, ht]\n- 调用者: u32_init_knode\n- 被调用者: []\n\n4. 函数名: memcpy\n- 参数: [&new->sel, s, struct_size(s, keys, s->nkeys)]\n- 调用者: u32_init_knode\n- 被调用者: []\n\n5. 函数名: tcf_exts_init\n- 参数: [&new->exts, net, TCA_U32_ACT, TCA_U32_POLICE]\n- 调用者: u32_init_knode\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [new]\n- 调用者: u32_init_knode\n- 被调用者: []"
    },
    {
        "id": 4201,
        "cwe": "CWE-416",
        "cve": "CVE-2023-4244",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中netfilter的nf_tables组件的提交功能，处理网络过滤规则集的生成、更新和删除操作，并管理相关资源的生命周期。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于nf_tables网络链接控制平面事务与nft_set元素垃圾回收之间存在竞争条件，可能导致引用计数器下溢，从而引发释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: nf_tables_commit\n- 参数: [net, skb]\n- 调用者: 无\n- 被调用者: [nft_pernet, mutex_unlock, nft_trans_set_update, nft_set_is_anonymous, nft_trans_set_bound, nft_trans_chain_update, nft_chain_binding, nft_trans_chain_bound, nf_tables_validate, nft_flow_rule_offload_commit, nf_tables_commit_audit_alloc, nf_tables_commit_chain_prepare_cancel, nf_tables_commit_audit_free, nf_tables_commit_chain_prepare, nf_tables_commit_chain, READ_ONCE, WRITE_ONCE, nft_gencursor_next, nf_tables_commit_audit_collect, nft_trans_table_update, nft_trans_destroy, nf_tables_table_disable, nft_clear, nf_tables_table_notify, nft_chain_commit_update, nf_tables_chain_notify, nft_chain_commit_drop_policy, nft_chain_del, nft_netdev_unregister_hooks, nf_tables_unregister_hook, nf_tables_rule_notify, nft_flow_rule_destroy, nft_rule_expr_deactivate, nft_set_is_anonymous, nft_use_dec, nf_tables_set_notify, nft_setelem_activate, nf_tables_setelem_notify, nft_setelem_remove, nft_setelem_is_catchall, nft_obj_commit_update, nf_tables_obj_notify, nft_obj_del, nf_tables_flowtable_notify, nft_unregister_flowtable_net_hooks, nft_set_commit_update, nft_commit_notify, nf_tables_gen_notify, nf_tables_commit_audit_log, nf_tables_commit_release]\n\n2. 函数名: nft_pernet\n- 参数: [net]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n3. 函数名: mutex_unlock\n- 参数: [&nft_net->commit_mutex]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n4. 函数名: nft_trans_set_update\n- 参数: [trans]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n5. 函数名: nft_set_is_anonymous\n- 参数: [nft_trans_set(trans)]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n6. 函数名: nft_trans_set_bound\n- 参数: [trans]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n7. 函数名: nft_trans_chain_update\n- 参数: [trans]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n8. 函数名: nft_chain_binding\n- 参数: [nft_trans_chain(trans)]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n9. 函数名: nft_trans_chain_bound\n- 参数: [trans]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n10. 函数名: nf_tables_validate\n- 参数: [net]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n11. 函数名: nft_flow_rule_offload_commit\n- 参数: [net]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n12. 函数名: nf_tables_commit_audit_alloc\n- 参数: [&adl, trans->ctx.table]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n13. 函数名: nf_tables_commit_chain_prepare_cancel\n- 参数: [net]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n14. 函数名: nf_tables_commit_audit_free\n- 参数: [&adl]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n15. 函数名: nf_tables_commit_chain_prepare\n- 参数: [net, chain]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n16. 函数名: nf_tables_commit_chain\n- 参数: [net, chain]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n17. 函数名: READ_ONCE\n- 参数: [nft_net->base_seq]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n18. 函数名: WRITE_ONCE\n- 参数: [nft_net->base_seq, base_seq]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n19. 函数名: nft_gencursor_next\n- 参数: [net]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n20. 函数名: nf_tables_commit_audit_collect\n- 参数: [&adl, trans->ctx.table, trans->msg_type]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n21. 函数名: nft_trans_table_update\n- 参数: [trans]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n22. 函数名: nft_trans_destroy\n- 参数: [trans]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n23. 函数名: nf_tables_table_disable\n- 参数: [net, trans->ctx.table]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n24. 函数名: nft_clear\n- 参数: [net, trans->ctx.table]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n25. 函数名: nf_tables_table_notify\n- 参数: [&trans->ctx, NFT_MSG_NEWTABLE]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n26. 函数名: nft_chain_commit_update\n- 参数: [trans]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n27. 函数名: nf_tables_chain_notify\n- 参数: [&trans->ctx, NFT_MSG_NEWCHAIN, &nft_trans_chain_hooks(trans)]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n28. 函数名: nft_chain_commit_drop_policy\n- 参数: [trans]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n29. 函数名: nft_chain_del\n- 参数: [trans->ctx.chain]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n30. 函数名: nft_netdev_unregister_hooks\n- 参数: [net, &nft_trans_chain_hooks(trans), true]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n31. 函数名: nf_tables_unregister_hook\n- 参数: [trans->ctx.net, trans->ctx.table, trans->ctx.chain]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n32. 函数名: nf_tables_rule_notify\n- 参数: [&trans->ctx, nft_trans_rule(trans), NFT_MSG_NEWRULE]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n33. 函数名: nft_flow_rule_destroy\n- 参数: [nft_trans_flow_rule(trans)]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n34. 函数名: nft_rule_expr_deactivate\n- 参数: [&trans->ctx, nft_trans_rule(trans), NFT_TRANS_COMMIT]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n35. 函数名: nft_use_dec\n- 参数: [&trans->ctx.table->use]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n36. 函数名: nf_tables_set_notify\n- 参数: [&trans->ctx, nft_trans_set(trans), NFT_MSG_NEWSET, GFP_KERNEL]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n37. 函数名: nft_setelem_activate\n- 参数: [net, te->set, &te->elem]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n38. 函数名: nf_tables_setelem_notify\n- 参数: [&trans->ctx, te->set, &te->elem, NFT_MSG_NEWSETELEM]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n39. 函数名: nft_setelem_remove\n- 参数: [net, te->set, &te->elem]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n40. 函数名: nft_setelem_is_catchall\n- 参数: [te->set, &te->elem]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n41. 函数名: nft_obj_commit_update\n- 参数: [trans]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n42. 函数名: nf_tables_obj_notify\n- 参数: [&trans->ctx, nft_trans_obj(trans), NFT_MSG_NEWOBJ]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n43. 函数名: nft_obj_del\n- 参数: [nft_trans_obj(trans)]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n44. 函数名: nf_tables_flowtable_notify\n- 参数: [&trans->ctx, nft_trans_flowtable(trans), &nft_trans_flowtable_hooks(trans), NFT_MSG_NEWFLOWTABLE]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n45. 函数名: nft_unregister_flowtable_net_hooks\n- 参数: [net, &nft_trans_flowtable_hooks(trans)]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n46. 函数名: nft_set_commit_update\n- 参数: [&set_update_list]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n47. 函数名: nft_commit_notify\n- 参数: [net, NETLINK_CB(skb).portid]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n48. 函数名: nf_tables_gen_notify\n- 参数: [net, skb, NFT_MSG_NEWGEN]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n49. 函数名: nf_tables_commit_audit_log\n- 参数: [&adl, nft_net->base_seq]\n- 调用者: nf_tables_commit\n- 被调用者: 无\n\n50. 函数名: nf_tables_commit_release\n- 参数: [net]\n- 调用者: nf_tables_commit\n- 被调用者: 无"
    },
    {
        "id": 4202,
        "cwe": "CWE-416",
        "cve": "CVE-2023-4244",
        "purpose": "Code purpose:\"\"\"处理netfilter中nftables表的网络链接释放事件，包括表的释放和资源清理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于nf_tables网络链接控制平面事务与nft_set元素垃圾回收之间存在竞争条件，导致引用计数器下溢，从而引发释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_rcv_nl_event\n- 参数: [this, event, ptr]\n- 调用者: 未显示（由内核通知链机制调用）\n- 被调用者: [nft_pernet, list_empty, rcu_barrier, list_for_each_entry, nft_table_has_owner, __nft_release_hook, list_del_rcu, synchronize_rcu, __nft_release_table, mutex_unlock]\n\n2. 函数名: nft_pernet\n- 参数: [net]\n- 调用者: nft_rcv_nl_event\n- 被调用者: 未显示\n\n3. 函数名: list_empty\n- 参数: [&nf_tables_destroy_list]\n- 调用者: nft_rcv_nl_event\n- 被调用者: 未显示\n\n4. 函数名: rcu_barrier\n- 参数: []\n- 调用者: nft_rcv_nl_event\n- 被调用者: 未显示\n\n5. 函数名: list_for_each_entry\n- 参数: [table, &nft_net->tables, list]\n- 调用者: nft_rcv_nl_event\n- 被调用者: 未显示\n\n6. 函数名: nft_table_has_owner\n- 参数: [table]\n- 调用者: nft_rcv_nl_event\n- 被调用者: 未显示\n\n7. 函数名: __nft_release_hook\n- 参数: [net, table]\n- 调用者: nft_rcv_nl_event\n- 被调用者: 未显示\n\n8. 函数名: list_del_rcu\n- 参数: [&table->list]\n- 调用者: nft_rcv_nl_event\n- 被调用者: 未显示\n\n9. 函数名: synchronize_rcu\n- 参数: []\n- 调用者: nft_rcv_nl_event\n- 被调用者: 未显示\n\n10. 函数名: __nft_release_table\n- 参数: [net, to_delete[--deleted]]\n- 调用者: nft_rcv_nl_event\n- 被调用者: 未显示\n\n11. 函数名: mutex_unlock\n- 参数: [&nft_net->commit_mutex]\n- 调用者: nft_rcv_nl_event\n- 被调用者: 未显示"
    },
    {
        "id": 4203,
        "cwe": "CWE-416",
        "cve": "CVE-2023-4244",
        "purpose": "Code purpose:\"\"\"在Linux内核的netfilter:nf_tables组件中，清理网络命名空间时释放相关资源并处理未完成的提交列表和模块列表\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于nf_tables网络链接控制平面事务与nft_set元素垃圾回收之间存在竞争条件，导致引用计数器下溢，引发释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nf_tables_exit_net\n- 参数: [struct net *net]\n- 调用者: 未明确显示（通常由网络子系统调用）\n- 被调用者: [nft_pernet, mutex_lock, list_empty, __nf_tables_abort, __nft_release_tables, mutex_unlock, WARN_ON_ONCE]\n\n2. 函数名: nft_pernet\n- 参数: [struct net *net]\n- 调用者: nf_tables_exit_net\n- 被调用者: []\n\n3. 函数名: mutex_lock\n- 参数: [&nft_net->commit_mutex]\n- 调用者: nf_tables_exit_net\n- 被调用者: []\n\n4. 函数名: list_empty\n- 参数: [&nft_net->commit_list], [&nft_net->module_list]\n- 调用者: nf_tables_exit_net\n- 被调用者: []\n\n5. 函数名: __nf_tables_abort\n- 参数: [net, NFNL_ABORT_NONE]\n- 调用者: nf_tables_exit_net\n- 被调用者: []\n\n6. 函数名: __nft_release_tables\n- 参数: [net]\n- 调用者: nf_tables_exit_net\n- 被调用者: []\n\n7. 函数名: mutex_unlock\n- 参数: [&nft_net->commit_mutex]\n- 调用者: nf_tables_exit_net\n- 被调用者: []\n\n8. 函数名: WARN_ON_ONCE\n- 参数: [!list_empty(&nft_net->tables)], [!list_empty(&nft_net->module_list)], [!list_empty(&nft_net->notify_list)]\n- 调用者: nf_tables_exit_net\n- 被调用者: []"
    },
    {
        "id": 4210,
        "cwe": "CWE-416",
        "cve": "CVE-2023-4387",
        "purpose": "Code purpose:\"\"\"该代码用于在VMware的vmxnet3以太网NIC驱动中分配和管理接收队列的缓冲区，包括SKB和页缓冲区的分配、DMA映射以及相关状态更新。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在清理vmxnet3_rq_cleanup_all时存在双重释放问题，导致释放后使用(use-after-free)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: vmxnet3_rq_alloc_rx_buf\n- 参数: [struct vmxnet3_rx_queue *rq, u32 ring_idx, int num_to_alloc, struct vmxnet3_adapter *adapter]\n- 调用者: N/A\n- 被调用者: [__netdev_alloc_skb_ip_align, dma_map_single, dma_mapping_error, dev_kfree_skb_any, alloc_page, dma_map_page, put_page, cpu_to_le64, cpu_to_le32, vmxnet3_cmd_ring_adv_next2fill, netdev_dbg, BUG_ON]\n\n2. 函数名: __netdev_alloc_skb_ip_align\n- 参数: [struct net_device *dev, unsigned int length, gfp_t gfp]\n- 调用者: vmxnet3_rq_alloc_rx_buf\n- 被调用者: N/A\n\n3. 函数名: dma_map_single\n- 参数: [struct device *dev, void *ptr, size_t size, enum dma_data_direction dir]\n- 调用者: vmxnet3_rq_alloc_rx_buf\n- 被调用者: N/A\n\n4. 函数名: dma_mapping_error\n- 参数: [struct device *dev, dma_addr_t dma_addr]\n- 调用者: vmxnet3_rq_alloc_rx_buf\n- 被调用者: N/A\n\n5. 函数名: dev_kfree_skb_any\n- 参数: [struct sk_buff *skb]\n- 调用者: vmxnet3_rq_alloc_rx_buf\n- 被调用者: N/A\n\n6. 函数名: alloc_page\n- 参数: [gfp_t gfp_mask]\n- 调用者: vmxnet3_rq_alloc_rx_buf\n- 被调用者: N/A\n\n7. 函数名: dma_map_page\n- 参数: [struct device *dev, struct page *page, size_t offset, size_t size, enum dma_data_direction dir]\n- 调用者: vmxnet3_rq_alloc_rx_buf\n- 被调用者: N/A\n\n8. 函数名: put_page\n- 参数: [struct page *page]\n- 调用者: vmxnet3_rq_alloc_rx_buf\n- 被调用者: N/A\n\n9. 函数名: cpu_to_le64\n- 参数: [__u64 x]\n- 调用者: vmxnet3_rq_alloc_rx_buf\n- 被调用者: N/A\n\n10. 函数名: cpu_to_le32\n- 参数: [__u32 x]\n- 调用者: vmxnet3_rq_alloc_rx_buf\n- 被调用者: N/A\n\n11. 函数名: vmxnet3_cmd_ring_adv_next2fill\n- 参数: [struct vmxnet3_cmd_ring *ring]\n- 调用者: vmxnet3_rq_alloc_rx_buf\n- 被调用者: N/A\n\n12. 函数名: netdev_dbg\n- 参数: [const struct net_device *dev, const char *fmt, ...]\n- 调用者: vmxnet3_rq_alloc_rx_buf\n- 被调用者: N/A\n\n13. 函数名: BUG_ON\n- 参数: [condition]\n- 调用者: vmxnet3_rq_alloc_rx_buf\n- 被调用者: N/A"
    },
    {
        "id": 4212,
        "cwe": "CWE-416",
        "cve": "CVE-2023-4394",
        "purpose": "Code purpose:\"\"\"该代码用于根据设备路径获取Btrfs文件系统的设备参数，包括设备ID、UUID和FSID等信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在btrfs_get_dev_args_from_path函数中，由于在释放disk_super和bdev后没有清空相关指针，可能导致后续对这些已释放内存的访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: btrfs_get_dev_args_from_path\n- 参数: [struct btrfs_fs_info *fs_info, struct btrfs_dev_lookup_args *args, const char *path]\n- 调用者: N/A\n- 被调用者: [strcmp, kzalloc, btrfs_put_dev_args_from_path, btrfs_get_bdev_and_sb, btrfs_stack_device_id, memcpy, btrfs_fs_incompat, btrfs_release_disk_super, blkdev_put]\n\n2. 函数名: strcmp\n- 参数: [const char *path, const char *\"missing\"]\n- 调用者: btrfs_get_dev_args_from_path\n- 被调用者: N/A\n\n3. 函数名: kzalloc\n- 参数: [BTRFS_UUID_SIZE, GFP_KERNEL], [BTRFS_FSID_SIZE, GFP_KERNEL]\n- 调用者: btrfs_get_dev_args_from_path\n- 被调用者: N/A\n\n4. 函数名: btrfs_put_dev_args_from_path\n- 参数: [struct btrfs_dev_lookup_args *args]\n- 调用者: btrfs_get_dev_args_from_path\n- 被调用者: N/A\n\n5. 函数名: btrfs_get_bdev_and_sb\n- 参数: [const char *path, FMODE_READ, fs_info->bdev_holder, 0, &bdev, &disk_super]\n- 调用者: btrfs_get_dev_args_from_path\n- 被调用者: N/A\n\n6. 函数名: btrfs_stack_device_id\n- 参数: [&disk_super->dev_item]\n- 调用者: btrfs_get_dev_args_from_path\n- 被调用者: N/A\n\n7. 函数名: memcpy\n- 参数: [args->uuid, disk_super->dev_item.uuid, BTRFS_UUID_SIZE], [args->fsid, disk_super->metadata_uuid, BTRFS_FSID_SIZE], [args->fsid, disk_super->fsid, BTRFS_FSID_SIZE]\n- 调用者: btrfs_get_dev_args_from_path\n- 被调用者: N/A\n\n8. 函数名: btrfs_fs_incompat\n- 参数: [struct btrfs_fs_info *fs_info, METADATA_UUID]\n- 调用者: btrfs_get_dev_args_from_path\n- 被调用者: N/A\n\n9. 函数名: btrfs_release_disk_super\n- 参数: [struct btrfs_super_block *disk_super]\n- 调用者: btrfs_get_dev_args_from_path\n- 被调用者: N/A\n\n10. 函数名: blkdev_put\n- 参数: [struct block_device *bdev, FMODE_READ]\n- 调用者: btrfs_get_dev_args_from_path\n- 被调用者: N/A"
    },
    {
        "id": 4227,
        "cwe": "CWE-416",
        "cve": "CVE-2023-45898",
        "purpose": "Code purpose:\"\"\"在ext4文件系统中插入延迟分配的块到extent状态树中，并处理相关的错误情况\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在错误处理路径中，es1和es2可能被释放后又被重新使用，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_es_insert_delayed_block\n- 参数: [struct inode *inode, ext4_lblk_t lblk, bool allocated]\n- 调用者: N/A\n- 被调用者: [ext4_es_store_pblock_status, trace_ext4_es_insert_delayed_block, ext4_es_insert_extent_check, __es_alloc_extent, __es_remove_extent, __es_insert_extent, __insert_pending, __es_free_extent, ext4_es_print_tree, ext4_print_pending_tree]\n\n2. 函数名: ext4_es_store_pblock_status\n- 参数: [struct extent_status *es, ext4_fsblk_t pb, unsigned int status]\n- 调用者: ext4_es_insert_delayed_block\n- 被调用者: N/A\n\n3. 函数名: trace_ext4_es_insert_delayed_block\n- 参数: [struct inode *inode, struct extent_status *newes, bool allocated]\n- 调用者: ext4_es_insert_delayed_block\n- 被调用者: N/A\n\n4. 函数名: ext4_es_insert_extent_check\n- 参数: [struct inode *inode, struct extent_status *es]\n- 调用者: ext4_es_insert_delayed_block\n- 被调用者: N/A\n\n5. 函数名: __es_alloc_extent\n- 参数: [bool nofail]\n- 调用者: ext4_es_insert_delayed_block\n- 被调用者: N/A\n\n6. 函数名: __es_remove_extent\n- 参数: [struct inode *inode, ext4_lblk_t lblk, ext4_lblk_t end, struct extent_status *res, struct extent_status *prealloc]\n- 调用者: ext4_es_insert_delayed_block\n- 被调用者: N/A\n\n7. 函数名: __es_insert_extent\n- 参数: [struct inode *inode, struct extent_status *newes, struct extent_status *prealloc]\n- 调用者: ext4_es_insert_delayed_block\n- 被调用者: N/A\n\n8. 函数名: __insert_pending\n- 参数: [struct inode *inode, ext4_lblk_t lblk]\n- 调用者: ext4_es_insert_delayed_block\n- 被调用者: N/A\n\n9. 函数名: __es_free_extent\n- 参数: [struct extent_status *es]\n- 调用者: ext4_es_insert_delayed_block\n- 被调用者: N/A\n\n10. 函数名: ext4_es_print_tree\n- 参数: [struct inode *inode]\n- 调用者: ext4_es_insert_delayed_block\n- 被调用者: N/A\n\n11. 函数名: ext4_print_pending_tree\n- 参数: [struct inode *inode]\n- 调用者: ext4_es_insert_delayed_block\n- 被调用者: N/A"
    },
    {
        "id": 4228,
        "cwe": "CWE-416",
        "cve": "CVE-2023-45898",
        "purpose": "Code purpose:\"\"\"从ext4文件系统的inode中移除指定范围的extent状态信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4_es_remove_extent函数中，由于错误处理和重试逻辑可能导致es指针在释放后又被使用，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_es_remove_extent\n- 参数: [struct inode *inode, ext4_lblk_t lblk, ext4_lblk_t len]\n- 调用者: N/A (顶层函数)\n- 被调用者: [trace_ext4_es_remove_extent, __es_alloc_extent, __es_remove_extent, __es_free_extent, ext4_es_print_tree, ext4_da_release_space]\n\n2. 函数名: __es_alloc_extent\n- 参数: [bool]\n- 调用者: ext4_es_remove_extent\n- 被调用者: []\n\n3. 函数名: __es_remove_extent\n- 参数: [struct inode *inode, ext4_lblk_t lblk, ext4_lblk_t end, int *reserved, struct extent_status *es]\n- 调用者: ext4_es_remove_extent\n- 被调用者: []\n\n4. 函数名: __es_free_extent\n- 参数: [struct extent_status *es]\n- 调用者: ext4_es_remove_extent\n- 被调用者: []\n\n5. 函数名: ext4_es_print_tree\n- 参数: [struct inode *inode]\n- 调用者: ext4_es_remove_extent\n- 被调用者: []\n\n6. 函数名: ext4_da_release_space\n- 参数: [struct inode *inode, int reserved]\n- 调用者: ext4_es_remove_extent\n- 被调用者: []\n\n7. 函数名: trace_ext4_es_remove_extent\n- 参数: [struct inode *inode, ext4_lblk_t lblk, ext4_lblk_t len]\n- 调用者: ext4_es_remove_extent\n- 被调用者: []"
    },
    {
        "id": 4229,
        "cwe": "CWE-416",
        "cve": "CVE-2023-45898",
        "purpose": "Code purpose:\"\"\"该代码用于在ext4文件系统中插入新的extent状态到extent状态树中，并处理相关的错误情况\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4_es_insert_extent函数中，es1在错误处理路径中可能被释放后又被使用，导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_es_insert_extent\n- 参数: [struct inode *inode, ext4_lblk_t lblk, ext4_lblk_t len, ext4_fsblk_t pblk, unsigned int status]\n- 调用者: N/A (top-level function)\n- 被调用者: [ext4_warning, WARN_ON, ext4_es_store_pblock_status, trace_ext4_es_insert_extent, ext4_es_insert_extent_check, __es_alloc_extent, __es_remove_extent, __es_insert_extent, ext4_es_must_keep, __revise_pending, __es_free_extent, write_lock, write_unlock, ext4_es_print_tree]\n\n2. 函数名: ext4_es_store_pblock_status\n- 参数: [struct extent_status *es, ext4_fsblk_t pblk, unsigned int status]\n- 调用者: ext4_es_insert_extent\n- 被调用者: N/A\n\n3. 函数名: ext4_es_insert_extent_check\n- 参数: [struct inode *inode, struct extent_status *es]\n- 调用者: ext4_es_insert_extent\n- 被调用者: N/A\n\n4. 函数名: __es_alloc_extent\n- 参数: [bool]\n- 调用者: ext4_es_insert_extent\n- 被调用者: N/A\n\n5. 函数名: __es_remove_extent\n- 参数: [struct inode *inode, ext4_lblk_t lblk, ext4_lblk_t end, NULL, struct extent_status *es1]\n- 调用者: ext4_es_insert_extent\n- 被调用者: N/A\n\n6. 函数名: __es_insert_extent\n- 参数: [struct inode *inode, struct extent_status *newes, struct extent_status *es2]\n- 调用者: ext4_es_insert_extent\n- 被调用者: N/A\n\n7. 函数名: ext4_es_must_keep\n- 参数: [struct extent_status *es]\n- 调用者: ext4_es_insert_extent\n- 被调用者: N/A\n\n8. 函数名: __revise_pending\n- 参数: [struct inode *inode, ext4_lblk_t lblk, ext4_lblk_t len]\n- 调用者: ext4_es_insert_extent\n- 被调用者: N/A\n\n9. 函数名: __es_free_extent\n- 参数: [struct extent_status *es]\n- 调用者: ext4_es_insert_extent\n- 被调用者: N/A\n\n10. 函数名: ext4_es_print_tree\n- 参数: [struct inode *inode]\n- 调用者: ext4_es_insert_extent\n- 被调用者: N/A"
    },
    {
        "id": 4234,
        "cwe": "CWE-416",
        "cve": "CVE-2023-4611",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中内存策略绑定(mbind)的功能，用于将指定内存范围绑定到特定的NUMA节点策略上，并处理相关的内存迁移操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在mbind()操作与VMA锁定页面错误处理之间存在竞争条件，导致释放后使用(UAF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: do_mbind\n- 参数: [start, len, mode, mode_flags, nmask, flags]\n- 调用者: 未显示\n- 被调用者: [mpol_new, mpol_set_nodemask, queue_pages_range, vma_iter_init, vma_prev, for_each_vma_range, mbind_range, migrate_pages, putback_movable_pages, mmap_write_unlock, mpol_put, lru_cache_disable, lru_cache_enable]\n\n2. 函数名: mpol_new\n- 参数: [mode, mode_flags, nmask]\n- 调用者: do_mbind\n- 被调用者: 未显示\n\n3. 函数名: mpol_set_nodemask\n- 参数: [new, nmask, scratch]\n- 调用者: do_mbind\n- 被调用者: 未显示\n\n4. 函数名: queue_pages_range\n- 参数: [mm, start, end, nmask, flags | MPOL_MF_INVERT, &pagelist]\n- 调用者: do_mbind\n- 被调用者: 未显示\n\n5. 函数名: vma_iter_init\n- 参数: [&vmi, mm, start]\n- 调用者: do_mbind\n- 被调用者: 未显示\n\n6. 函数名: vma_prev\n- 参数: [&vmi]\n- 调用者: do_mbind\n- 被调用者: 未显示\n\n7. 函数名: for_each_vma_range\n- 参数: [vmi, vma, end]\n- 调用者: do_mbind\n- 被调用者: mbind_range\n\n8. 函数名: mbind_range\n- 参数: [&vmi, vma, &prev, start, end, new]\n- 调用者: for_each_vma_range\n- 被调用者: 未显示\n\n9. 函数名: migrate_pages\n- 参数: [&pagelist, new_folio, NULL, start, MIGRATE_SYNC, MR_MEMPOLICY_MBIND, NULL]\n- 调用者: do_mbind\n- 被调用者: 未显示\n\n10. 函数名: putback_movable_pages\n- 参数: [&pagelist]\n- 调用者: do_mbind\n- 被调用者: 未显示\n\n11. 函数名: mmap_write_unlock\n- 参数: [mm]\n- 调用者: do_mbind\n- 被调用者: 未显示\n\n12. 函数名: mpol_put\n- 参数: [new]\n- 调用者: do_mbind\n- 被调用者: 未显示\n\n13. 函数名: lru_cache_disable\n- 参数: []\n- 调用者: do_mbind\n- 被调用者: 未显示\n\n14. 函数名: lru_cache_enable\n- 参数: []\n- 调用者: do_mbind\n- 被调用者: 未显示"
    },
    {
        "id": 4235,
        "cwe": "CWE-416",
        "cve": "CVE-2023-4611",
        "purpose": "Code purpose:\"\"\"该代码实现了设置内存策略的home_node功能，用于指定内存区域的首选NUMA节点，并处理相关的内存绑定操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在内存管理子系统中，mbind()与VMA锁定的页面错误之间存在竞争条件，导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: SYSCALL_DEFINE4(set_mempolicy_home_node)\n- 参数: [unsigned long start, unsigned long len, unsigned long home_node, unsigned long flags]\n- 调用者: 系统调用\n- 被调用者: [untagged_addr, PAGE_MASK, node_online, PAGE_ALIGN, mmap_write_lock, vma_prev, for_each_vma_range, vma_policy, mpol_dup, IS_ERR, PTR_ERR, mbind_range, mpol_put, mmap_write_unlock]\n\n2. 函数名: untagged_addr\n- 参数: [unsigned long start]\n- 调用者: SYSCALL_DEFINE4(set_mempolicy_home_node)\n- 被调用者: []\n\n3. 函数名: node_online\n- 参数: [unsigned long home_node]\n- 调用者: SYSCALL_DEFINE4(set_mempolicy_home_node)\n- 被调用者: []\n\n4. 函数名: PAGE_ALIGN\n- 参数: [unsigned long len]\n- 调用者: SYSCALL_DEFINE4(set_mempolicy_home_node)\n- 被调用者: []\n\n5. 函数名: mmap_write_lock\n- 参数: [struct mm_struct *mm]\n- 调用者: SYSCALL_DEFINE4(set_mempolicy_home_node)\n- 被调用者: []\n\n6. 函数名: vma_prev\n- 参数: [struct vma_iterator *vmi]\n- 调用者: SYSCALL_DEFINE4(set_mempolicy_home_node)\n- 被调用者: []\n\n7. 函数名: for_each_vma_range\n- 参数: [struct vma_iterator vmi, struct vm_area_struct vma, unsigned long end]\n- 调用者: SYSCALL_DEFINE4(set_mempolicy_home_node)\n- 被调用者: []\n\n8. 函数名: vma_policy\n- 参数: [struct vm_area_struct *vma]\n- 调用者: SYSCALL_DEFINE4(set_mempolicy_home_node)\n- 被调用者: []\n\n9. 函数名: mpol_dup\n- 参数: [struct mempolicy *old]\n- 调用者: SYSCALL_DEFINE4(set_mempolicy_home_node)\n- 被调用者: []\n\n10. 函数名: IS_ERR\n- 参数: [void *ptr]\n- 调用者: SYSCALL_DEFINE4(set_mempolicy_home_node)\n- 被调用者: []\n\n11. 函数名: PTR_ERR\n- 参数: [void *ptr]\n- 调用者: SYSCALL_DEFINE4(set_mempolicy_home_node)\n- 被调用者: []\n\n12. 函数名: mbind_range\n- 参数: [struct vma_iterator *vmi, struct vm_area_struct *vma, struct vm_area_struct **prev, unsigned long start, unsigned long end, struct mempolicy *new]\n- 调用者: SYSCALL_DEFINE4(set_mempolicy_home_node)\n- 被调用者: []\n\n13. 函数名: mpol_put\n- 参数: [struct mempolicy *new]\n- 调用者: SYSCALL_DEFINE4(set_mempolicy_home_node)\n- 被调用者: []\n\n14. 函数名: mmap_write_unlock\n- 参数: [struct mm_struct *mm]\n- 调用者: SYSCALL_DEFINE4(set_mempolicy_home_node)\n- 被调用者: []"
    },
    {
        "id": 4236,
        "cwe": "CWE-416",
        "cve": "CVE-2023-4611",
        "purpose": "Code purpose:\"\"\"替换虚拟内存区域(VMA)的内存策略并处理旧策略的释放\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在vma_replace_policy函数中，由于mbind()和VMA锁定页面错误之间的竞争条件，导致内存策略对象在被释放后仍可能被访问，从而引发use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: vma_replace_policy\n- 参数: [vma, pol]\n- 调用者: 未明确（可能是内核中调用内存策略的相关函数）\n- 被调用者: [mpol_dup, mpol_put]\n\n2. 函数名: mpol_dup\n- 参数: [pol]\n- 调用者: vma_replace_policy\n- 被调用者: 未明确\n\n3. 函数名: mpol_put\n- 参数: [old/new]\n- 调用者: vma_replace_policy\n- 被调用者: 未明确\n\n4. 函数名: set_policy\n- 参数: [vma, new]\n- 调用者: vma_replace_policy（通过vma->vm_ops->set_policy调用）\n- 被调用者: 未明确"
    },
    {
        "id": 4237,
        "cwe": "CWE-416",
        "cve": "CVE-2023-4611",
        "purpose": "Code purpose:\"\"\"该代码用于重新绑定内存管理结构中所有虚拟内存区域的NUMA内存策略到新的节点掩码\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在内存管理子系统中的mpol_rebind_mm函数存在竞态条件，当mbind()操作与VMA锁定的页面错误同时发生时，可能导致释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: mpol_rebind_mm\n- 参数: [struct mm_struct *mm, nodemask_t *new]\n- 调用者: 未明确（可能是内核中调用内存策略重新绑定的代码）\n- 被调用者: [mmap_write_lock, for_each_vma, mpol_rebind_policy, mmap_write_unlock]\n\n2. 函数名: mmap_write_lock\n- 参数: [struct mm_struct *mm]\n- 调用者: mpol_rebind_mm\n- 被调用者: []\n\n3. 函数名: for_each_vma\n- 参数: [VMA_ITERATOR(vmi, mm, 0), struct vm_area_struct *vma]\n- 调用者: mpol_rebind_mm\n- 被调用者: []\n\n4. 函数名: mpol_rebind_policy\n- 参数: [vma->vm_policy, new]\n- 调用者: mpol_rebind_mm\n- 被调用者: []\n\n5. 函数名: mmap_write_unlock\n- 参数: [struct mm_struct *mm]\n- 调用者: mpol_rebind_mm\n- 被调用者: []"
    },
    {
        "id": 4238,
        "cwe": "CWE-416",
        "cve": "CVE-2023-4622",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中AF_UNIX套接字的流式数据传输功能，通过sendpage机制将数据页内容发送到已连接的UNIX域套接字对端\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"unix_stream_sendpage()函数在未锁定接收队列的情况下尝试访问skb，导致垃圾回收时可能释放该skb，从而产生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: unix_stream_sendpage\n- 参数: [socket, page, offset, size, flags]\n- 调用者: N/A (kernel-level function)\n- 被调用者: [unix_peer, mutex_lock_interruptible, mutex_unlock, unix_state_lock, unix_state_unlock, maybe_init_creds, skb_peek_tail, unix_skb_scm_eq, sock_alloc_send_pskb, consume_skb, skb_append_pagefrags, unix_scm_to_skb, __skb_queue_tail, scm_destroy, kfree_skb, send_sig]\n\n2. 函数名: unix_peer\n- 参数: [sk]\n- 调用者: unix_stream_sendpage\n- 被调用者: N/A\n\n3. 函数名: mutex_lock_interruptible\n- 参数: [&unix_sk(other)->iolock]\n- 调用者: unix_stream_sendpage\n- 被调用者: N/A\n\n4. 函数名: mutex_unlock\n- 参数: [&unix_sk(other)->iolock]\n- 调用者: unix_stream_sendpage\n- 被调用者: N/A\n\n5. 函数名: unix_state_lock\n- 参数: [other]\n- 调用者: unix_stream_sendpage\n- 被调用者: N/A\n\n6. 函数名: unix_state_unlock\n- 参数: [other]\n- 调用者: unix_stream_sendpage\n- 被调用者: N/A\n\n7. 函数名: maybe_init_creds\n- 参数: [&scm, socket, other]\n- 调用者: unix_stream_sendpage\n- 被调用者: N/A\n\n8. 函数名: skb_peek_tail\n- 参数: [&other->sk_receive_queue]\n- 调用者: unix_stream_sendpage\n- 被调用者: N/A\n\n9. 函数名: unix_skb_scm_eq\n- 参数: [skb, &scm]\n- 调用者: unix_stream_sendpage\n- 被调用者: N/A\n\n10. 函数名: sock_alloc_send_pskb\n- 参数: [sk, 0, 0, flags & MSG_DONTWAIT, &err, 0]\n- 调用者: unix_stream_sendpage\n- 被调用者: N/A\n\n11. 函数名: consume_skb\n- 参数: [newskb]\n- 调用者: unix_stream_sendpage\n- 被调用者: N/A\n\n12. 函数名: skb_append_pagefrags\n- 参数: [skb, page, offset, size, MAX_SKB_FRAGS]\n- 调用者: unix_stream_sendpage\n- 被调用者: N/A\n\n13. 函数名: unix_scm_to_skb\n- 参数: [&scm, skb, false]\n- 调用者: unix_stream_sendpage\n- 被调用者: N/A\n\n14. 函数名: __skb_queue_tail\n- 参数: [&other->sk_receive_queue, newskb]\n- 调用者: unix_stream_sendpage\n- 被调用者: N/A\n\n15. 函数名: scm_destroy\n- 参数: [&scm]\n- 调用者: unix_stream_sendpage\n- 被调用者: N/A\n\n16. 函数名: kfree_skb\n- 参数: [newskb]\n- 调用者: unix_stream_sendpage\n- 被调用者: N/A\n\n17. 函数名: send_sig\n- 参数: [SIGPIPE, current, 0]\n- 调用者: unix_stream_sendpage\n- 被调用者: N/A"
    },
    {
        "id": 4239,
        "cwe": "CWE-416",
        "cve": "CVE-2023-4623",
        "purpose": "Code purpose:\"\"\"该代码实现了HFSC（Hierarchical Fair Service Curve）队列调度算法中类的修改和创建功能，用于网络流量控制管理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当具有链路共享曲线的类(HFSC_FSC标志)的父类没有链路共享曲线时，init_vf()会调用vttree_insert()插入父类，但update_vf()中未调用vttree_remove()移除，导致悬垂指针引发释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: hfsc_change_class\n- 参数: [sch, classid, parentid, tca, arg, extack]\n- 调用者: 未显示（由内核调度器调用）\n- 被调用者: [nla_parse_nested_deprecated, nla_data, psched_get_time, gen_replace_estimator, sch_tree_lock, hfsc_change_rsc, hfsc_change_fsc, hfsc_change_usc, qdisc_peek_len, update_ed, init_ed, update_vf, init_vf, sch_tree_unlock, hfsc_find_class, kzalloc, tcf_block_get, gen_new_estimator, tcf_block_put, kfree, qdisc_create_dflt, qdisc_hash_add, qdisc_class_hash_insert, list_add_tail, qdisc_purge_queue, hfsc_adjust_levels, qdisc_class_hash_grow]\n\n2. 函数名: nla_parse_nested_deprecated\n- 参数: [tb, TCA_HFSC_MAX, opt, hfsc_policy, NULL]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n3. 函数名: nla_data\n- 参数: [tb[TCA_HFSC_RSC], tb[TCA_HFSC_FSC], tb[TCA_HFSC_USC]]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n4. 函数名: psched_get_time\n- 参数: []\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n5. 函数名: gen_replace_estimator\n- 参数: [&cl->bstats, NULL, &cl->rate_est, NULL, true, tca[TCA_RATE]]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n6. 函数名: sch_tree_lock\n- 参数: [sch]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n7. 函数名: hfsc_change_rsc\n- 参数: [cl, rsc, cur_time]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n8. 函数名: hfsc_change_fsc\n- 参数: [cl, fsc]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n9. 函数名: hfsc_change_usc\n- 参数: [cl, usc, cur_time]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n10. 函数名: qdisc_peek_len\n- 参数: [cl->qdisc]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n11. 函数名: update_ed\n- 参数: [cl, len]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n12. 函数名: init_ed\n- 参数: [cl, len]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n13. 函数名: update_vf\n- 参数: [cl, 0, cur_time]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n14. 函数名: init_vf\n- 参数: [cl, len]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n15. 函数名: sch_tree_unlock\n- 参数: [sch]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n16. 函数名: hfsc_find_class\n- 参数: [parentid, sch]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n17. 函数名: kzalloc\n- 参数: [sizeof(struct hfsc_class), GFP_KERNEL]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n18. 函数名: tcf_block_get\n- 参数: [&cl->block, &cl->filter_list, sch, extack]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n19. 函数名: gen_new_estimator\n- 参数: [&cl->bstats, NULL, &cl->rate_est, NULL, true, tca[TCA_RATE]]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n20. 函数名: tcf_block_put\n- 参数: [cl->block]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n21. 函数名: kfree\n- 参数: [cl]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n22. 函数名: qdisc_create_dflt\n- 参数: [sch->dev_queue, &pfifo_qdisc_ops, classid, NULL]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n23. 函数名: qdisc_hash_add\n- 参数: [cl->qdisc, true]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n24. 函数名: qdisc_class_hash_insert\n- 参数: [&q->clhash, &cl->cl_common]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n25. 函数名: list_add_tail\n- 参数: [&cl->siblings, &parent->children]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n26. 函数名: qdisc_purge_queue\n- 参数: [parent->qdisc]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n27. 函数名: hfsc_adjust_levels\n- 参数: [parent]\n- 调用者: hfsc_change_class\n- 被调用者: []\n\n28. 函数名: qdisc_class_hash_grow\n- 参数: [sch, &q->clhash]\n- 调用者: hfsc_change_class\n- 被调用者: []"
    },
    {
        "id": 4253,
        "cwe": "CWE-416",
        "cve": "CVE-2023-4921",
        "purpose": "Code purpose:\"\"\"该代码片段实现了QFQ调度算法中从聚合队列中出队数据包并更新类别的信用值(deficit)的功能，当队列为空时从列表中移除相应类别。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于sch_plug的.peek处理程序不正确且agg_dequeue()中缺乏错误检查，当plug qdisc作为qfq qdisc的类使用时，发送网络数据包会触发qfq_dequeue()中的释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: agg_dequeue\n- 参数: [agg, cl, len]\n- 调用者: 未明确（可能是qfq_dequeue或其他调度相关函数）\n- 被调用者: [qdisc_dequeue_peeked, list_del, qdisc_pkt_len, peek, list_move_tail]\n\n2. 函数名: qdisc_dequeue_peeked\n- 参数: [cl->qdisc]\n- 调用者: agg_dequeue\n- 被调用者: []\n\n3. 函数名: list_del\n- 参数: [&cl->alist]\n- 调用者: agg_dequeue\n- 被调用者: []\n\n4. 函数名: qdisc_pkt_len\n- 参数: [cl->qdisc->ops->peek(cl->qdisc)]\n- 调用者: agg_dequeue\n- 被调用者: []\n\n5. 函数名: peek\n- 参数: [cl->qdisc]\n- 调用者: agg_dequeue（通过cl->qdisc->ops->peek调用）\n- 被调用者: []\n\n6. 函数名: list_move_tail\n- 参数: [&cl->alist, &agg->active]\n- 调用者: agg_dequeue\n- 被调用者: []"
    },
    {
        "id": 4254,
        "cwe": "CWE-416",
        "cve": "CVE-2023-4921",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中QFQ(Quick Fair Queueing)调度算法的出队操作，用于网络数据包的调度和传输管理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当plug qdisc作为qfq qdisc的一个类使用时，由于sch_plug的.peek处理程序不正确且agg_dequeue()缺乏错误检查，导致qfq_dequeue()中存在释放后使用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: qfq_dequeue\n- 参数: [struct Qdisc *sch]\n- 调用者: 无（顶级函数）\n- 被调用者: [qfq_peek_skb, charge_actual_service, qfq_update_agg_ts, qfq_schedule_agg, qfq_choose_next_agg, qdisc_qstats_backlog_dec, qdisc_bstats_update, agg_dequeue]\n\n2. 函数名: qfq_peek_skb\n- 参数: [struct qfq_aggregate *in_serv_agg, struct qfq_class **cl, unsigned int *len]\n- 调用者: qfq_dequeue\n- 被调用者: 无\n\n3. 函数名: charge_actual_service\n- 参数: [struct qfq_aggregate *in_serv_agg]\n- 调用者: qfq_dequeue\n- 被调用者: 无\n\n4. 函数名: qfq_update_agg_ts\n- 参数: [struct qfq_sched *q, struct qfq_aggregate *in_serv_agg, enum update_reason requeue]\n- 调用者: qfq_dequeue\n- 被调用者: 无\n\n5. 函数名: qfq_schedule_agg\n- 参数: [struct qfq_sched *q, struct qfq_aggregate *in_serv_agg]\n- 调用者: qfq_dequeue\n- 被调用者: 无\n\n6. 函数名: qfq_choose_next_agg\n- 参数: [struct qfq_sched *q]\n- 调用者: qfq_dequeue\n- 被调用者: 无\n\n7. 函数名: qdisc_qstats_backlog_dec\n- 参数: [struct Qdisc *sch, struct sk_buff *skb]\n- 调用者: qfq_dequeue\n- 被调用者: 无\n\n8. 函数名: qdisc_bstats_update\n- 参数: [struct Qdisc *sch, struct sk_buff *skb]\n- 调用者: qfq_dequeue\n- 被调用者: 无\n\n9. 函数名: agg_dequeue\n- 参数: [struct qfq_aggregate *in_serv_agg, struct qfq_class *cl, unsigned int len]\n- 调用者: qfq_dequeue\n- 被调用者: 无"
    },
    {
        "id": 4258,
        "cwe": "CWE-416",
        "cve": "CVE-2023-51780",
        "purpose": "Code purpose:\"\"\"处理ATM(异步传输模式)虚拟电路(VCC)的输入输出控制命令(ioctl)，包括连接状态查询、信号处理、后端模块加载等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"do_vcc_ioctl函数在处理vcc_recvmsg时存在竞态条件，导致在释放vcc后仍可能被访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: do_vcc_ioctl\n- 参数: [struct socket *sock, unsigned int cmd, unsigned long arg, int compat]\n- 调用者: N/A (内核IOCTL调用)\n- 被调用者: [put_user, sk_wmem_alloc_get, skb_peek, capable, task_pid_nr, sigd_attach, request_module, mutex_lock, list_for_each, try_module_get, module_put, mutex_unlock, get_user, atm_getnames, atm_dev_ioctl, compat_ptr]\n\n2. 函数名: put_user\n- 参数: [value, pointer]\n- 调用者: do_vcc_ioctl\n- 被调用者: []\n\n3. 函数名: sk_wmem_alloc_get\n- 参数: [struct sock *sk]\n- 调用者: do_vcc_ioctl\n- 被调用者: []\n\n4. 函数名: skb_peek\n- 参数: [struct sk_buff_head *list]\n- 调用者: do_vcc_ioctl\n- 被调用者: []\n\n5. 函数名: capable\n- 参数: [capability]\n- 调用者: do_vcc_ioctl\n- 被调用者: []\n\n6. 函数名: task_pid_nr\n- 参数: [struct task_struct *task]\n- 调用者: do_vcc_ioctl\n- 被调用者: []\n\n7. 函数名: sigd_attach\n- 参数: [struct atm_vcc *vcc]\n- 调用者: do_vcc_ioctl\n- 被调用者: []\n\n8. 函数名: request_module\n- 参数: [const char *name]\n- 调用者: do_vcc_ioctl\n- 被调用者: []\n\n9. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: do_vcc_ioctl\n- 被调用者: []\n\n10. 函数名: list_for_each\n- 参数: [pos, head]\n- 调用者: do_vcc_ioctl\n- 被调用者: []\n\n11. 函数名: try_module_get\n- 参数: [struct module *module]\n- 调用者: do_vcc_ioctl\n- 被调用者: []\n\n12. 函数名: module_put\n- 参数: [struct module *module]\n- 调用者: do_vcc_ioctl\n- 被调用者: []\n\n13. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: do_vcc_ioctl\n- 被调用者: []\n\n14. 函数名: get_user\n- 参数: [x, ptr]\n- 调用者: do_vcc_ioctl\n- 被调用者: []\n\n15. 函数名: atm_getnames\n- 参数: [buf, len]\n- 调用者: do_vcc_ioctl\n- 被调用者: []\n\n16. 函数名: atm_dev_ioctl\n- 参数: [cmd, buf, len, number, compat]\n- 调用者: do_vcc_ioctl\n- 被调用者: []\n\n17. 函数名: compat_ptr\n- 参数: [compat_uptr_t uptr]\n- 调用者: do_vcc_ioctl\n- 被调用者: []"
    },
    {
        "id": 4259,
        "cwe": "CWE-416",
        "cve": "CVE-2023-51781",
        "purpose": "Code purpose:\"\"\"处理AppleTalk协议套接字的IO控制命令，包括查询发送/接收队列状态、路由管理和接口配置等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"atalk_ioctl函数在处理IOCTL命令时存在竞态条件，导致在atalk_recvmsg中可能发生释放后使用(UAF)的情况。\"\"\"",
        "functions": "Functions:\n1. 函数名: atalk_ioctl\n- 参数: [struct socket *sock, unsigned int cmd, unsigned long arg]\n- 调用者: 未显示（内核IOCTL调用）\n- 被调用者: [sk_wmem_alloc_get, put_user, skb_peek, capable, atrtr_ioctl, rtnl_lock, atif_ioctl, rtnl_unlock]\n\n2. 函数名: sk_wmem_alloc_get\n- 参数: [struct sock *sk]\n- 调用者: atalk_ioctl\n- 被调用者: []\n\n3. 函数名: put_user\n- 参数: [long amount, int __user *argp]\n- 调用者: atalk_ioctl\n- 被调用者: []\n\n4. 函数名: skb_peek\n- 参数: [struct sk_buff_head *list]\n- 调用者: atalk_ioctl\n- 被调用者: []\n\n5. 函数名: capable\n- 参数: [CAP_NET_ADMIN]\n- 调用者: atalk_ioctl\n- 被调用者: []\n\n6. 函数名: atrtr_ioctl\n- 参数: [unsigned int cmd, void __user *argp]\n- 调用者: atalk_ioctl\n- 被调用者: []\n\n7. 函数名: rtnl_lock\n- 参数: []\n- 调用者: atalk_ioctl\n- 被调用者: []\n\n8. 函数名: atif_ioctl\n- 参数: [unsigned int cmd, void __user *argp]\n- 调用者: atalk_ioctl\n- 被调用者: []\n\n9. 函数名: rtnl_unlock\n- 参数: []\n- 调用者: atalk_ioctl\n- 被调用者: []"
    },
    {
        "id": 4260,
        "cwe": "CWE-416",
        "cve": "CVE-2023-51782",
        "purpose": "Code purpose:\"\"\"处理ROSE协议套接字的ioctl命令，包括队列状态查询、路由管理、呼叫控制和状态设置等功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"rose_ioctl函数在处理SIOCRSACCEPT命令时存在竞态条件，导致在rose_accept过程中可能发生use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: rose_ioctl\n- 参数: [struct socket *sock, unsigned int cmd, unsigned long arg]\n- 调用者: 未显示（由内核IOCTL机制调用）\n- 被调用者: [rose_sk, sk_wmem_alloc_get, put_user, skb_peek, capable, rose_rt_ioctl, copy_to_user, copy_from_user, ax25cmp, ax25_listen_release, ax25_listen_register, rose_write_internal, rose_start_idletimer]\n\n2. 函数名: rose_sk\n- 参数: [struct sock *sk]\n- 调用者: rose_ioctl\n- 被调用者: 未显示\n\n3. 函数名: sk_wmem_alloc_get\n- 参数: [struct sock *sk]\n- 调用者: rose_ioctl\n- 被调用者: 未显示\n\n4. 函数名: put_user\n- 参数: [long amount, unsigned int __user *argp]\n- 调用者: rose_ioctl\n- 被调用者: 未显示\n\n5. 函数名: skb_peek\n- 参数: [struct sk_buff_head *list]\n- 调用者: rose_ioctl\n- 被调用者: 未显示\n\n6. 函数名: capable\n- 参数: [int cap]\n- 调用者: rose_ioctl\n- 被调用者: 未显示\n\n7. 函数名: rose_rt_ioctl\n- 参数: [unsigned int cmd, void __user *argp]\n- 调用者: rose_ioctl\n- 被调用者: 未显示\n\n8. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: rose_ioctl\n- 被调用者: 未显示\n\n9. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: rose_ioctl\n- 被调用者: 未显示\n\n10. 函数名: ax25cmp\n- 参数: [ax25_address *a, ax25_address *b]\n- 调用者: rose_ioctl\n- 被调用者: 未显示\n\n11. 函数名: ax25_listen_release\n- 参数: [ax25_address *callsign, struct net_device *dev]\n- 调用者: rose_ioctl\n- 被调用者: 未显示\n\n12. 函数名: ax25_listen_register\n- 参数: [ax25_address *callsign, struct net_device *dev]\n- 调用者: rose_ioctl\n- 被调用者: 未显示\n\n13. 函数名: rose_write_internal\n- 参数: [struct sock *sk, int frametype]\n- 调用者: rose_ioctl\n- 被调用者: 未显示\n\n14. 函数名: rose_start_idletimer\n- 参数: [struct sock *sk]\n- 调用者: rose_ioctl\n- 被调用者: 未显示"
    },
    {
        "id": 4261,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5197",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核netfilter子系统中nf_tables模块的规则创建功能，包括规则的查找、验证、内存分配和链表管理，用于处理用户空间传递的网络过滤规则操作请求。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在同一个事务中同时添加和删除链绑定的规则时，由于未正确处理引用计数导致释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nf_tables_newrule\n- 参数: [struct sk_buff *skb, const struct nfnl_info *info, const struct nlattr * const nla[]]\n- 调用者: 未显示（由netfilter框架调用）\n- 被调用者: [nft_pernet, nft_table_lookup, nft_chain_lookup, nft_chain_lookup_byid, nft_chain_is_bound, __nft_rule_lookup, nf_tables_alloc_handle, nft_rule_lookup_byid, nft_ctx_init, kvmalloc_array, nf_tables_expr_parse, kzalloc, nft_activate_next, nft_userdata, nla_memcpy, nft_expr_first, nf_tables_newexpr, nft_validate_state_update, nft_expr_next, nft_flow_rule_create, nft_use_inc, nft_delrule, nft_trans_rule_add, list_add_tail_rcu, list_add_rcu, kvfree, nft_trans_flow_rule, nft_table_validate, nft_use_dec_restore, nft_flow_rule_destroy, nft_rule_expr_deactivate, nf_tables_rule_destroy, module_put]\n\n2. 函数名: nft_pernet\n- 参数: [info->net]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n3. 函数名: nft_table_lookup\n- 参数: [net, nla[NFTA_RULE_TABLE], family, genmask, NETLINK_CB(skb).portid]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n4. 函数名: nft_chain_lookup\n- 参数: [net, table, nla[NFTA_RULE_CHAIN], genmask]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n5. 函数名: nft_chain_lookup_byid\n- 参数: [net, table, nla[NFTA_RULE_CHAIN_ID], genmask]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n6. 函数名: nft_chain_is_bound\n- 参数: [chain]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n7. 函数名: __nft_rule_lookup\n- 参数: [chain, handle]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n8. 函数名: nf_tables_alloc_handle\n- 参数: [table]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n9. 函数名: nft_rule_lookup_byid\n- 参数: [net, chain, nla[NFTA_RULE_POSITION_ID]]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n10. 函数名: nft_ctx_init\n- 参数: [&ctx, net, skb, info->nlh, family, table, chain, nla]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n11. 函数名: nf_tables_expr_parse\n- 参数: [&ctx, tmp, &expr_info[n]]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n12. 函数名: nft_activate_next\n- 参数: [net, rule]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n13. 函数名: nft_userdata\n- 参数: [rule]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n14. 函数名: nft_expr_first\n- 参数: [rule]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n15. 函数名: nf_tables_newexpr\n- 参数: [&ctx, &expr_info[i], expr]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n16. 函数名: nft_validate_state_update\n- 参数: [table, NFT_VALIDATE_NEED]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n17. 函数名: nft_expr_next\n- 参数: [expr]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n18. 函数名: nft_flow_rule_create\n- 参数: [net, rule]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n19. 函数名: nft_use_inc\n- 参数: [&chain->use]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n20. 函数名: nft_delrule\n- 参数: [&ctx, old_rule]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n21. 函数名: nft_trans_rule_add\n- 参数: [&ctx, NFT_MSG_NEWRULE, rule]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n22. 函数名: nft_trans_flow_rule\n- 参数: [trans]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n23. 函数名: nft_table_validate\n- 参数: [net, table]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n24. 函数名: nft_use_dec_restore\n- 参数: [&chain->use]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n25. 函数名: nft_flow_rule_destroy\n- 参数: [flow]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n26. 函数名: nft_rule_expr_deactivate\n- 参数: [&ctx, rule, NFT_TRANS_PREPARE_ERROR]\n- 调用者: nf_tables_newrule\n- 被调用者: []\n\n27. 函数名: nf_tables_rule_destroy\n- 参数: [&ctx, rule]\n- 调用者: nf_tables_newrule\n- 被调用者: []"
    },
    {
        "id": 4262,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5197",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的netfilter:nf_tables组件中删除表及其关联的链、集合、流表和对象，但存在释放后使用漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在同一个事务中对链绑定进行规则添加和删除操作时，未能正确处理内存引用导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_flush_table\n- 参数: [struct nft_ctx *ctx]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [nft_is_active_next, nft_chain_is_bound, nft_delrule_by_chain, nft_set_is_anonymous, nft_delset, nft_delflowtable, nft_delobj, nft_delchain, nft_deltable]\n\n2. 函数名: nft_is_active_next\n- 参数: [ctx->net, chain/set/flowtable/obj]\n- 调用者: nft_flush_table\n- 被调用者: 未明确（上下文未提供）\n\n3. 函数名: nft_chain_is_bound\n- 参数: [chain]\n- 调用者: nft_flush_table\n- 被调用者: 未明确（上下文未提供）\n\n4. 函数名: nft_delrule_by_chain\n- 参数: [ctx]\n- 调用者: nft_flush_table\n- 被调用者: 未明确（上下文未提供）\n\n5. 函数名: nft_set_is_anonymous\n- 参数: [set]\n- 调用者: nft_flush_table\n- 被调用者: 未明确（上下文未提供）\n\n6. 函数名: nft_delset\n- 参数: [ctx, set]\n- 调用者: nft_flush_table\n- 被调用者: 未明确（上下文未提供）\n\n7. 函数名: nft_delflowtable\n- 参数: [ctx, flowtable]\n- 调用者: nft_flush_table\n- 被调用者: 未明确（上下文未提供）\n\n8. 函数名: nft_delobj\n- 参数: [ctx, obj]\n- 调用者: nft_flush_table\n- 被调用者: 未明确（上下文未提供）\n\n9. 函数名: nft_delchain\n- 参数: [ctx]\n- 调用者: nft_flush_table\n- 被调用者: 未明确（上下文未提供）\n\n10. 函数名: nft_deltable\n- 参数: [ctx]\n- 调用者: nft_flush_table\n- 被调用者: 未明确（上下文未提供）"
    },
    {
        "id": 4263,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5197",
        "purpose": "Code purpose:\"\"\"该代码用于处理Linux内核netfilter子系统中nf_tables模块的规则删除操作，包括根据指定条件查找并删除表中的规则或链。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在同一个事务中对链绑定进行规则添加和删除操作时，会导致释放后使用(use-after-free)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: nf_tables_delrule\n- 参数: [struct sk_buff *skb, const struct nfnl_info *info, const struct nlattr * const nla[]]\n- 调用者: (未显示)\n- 被调用者: [nft_table_lookup, nft_chain_lookup, nft_chain_is_bound, nft_ctx_init, nft_rule_lookup, nft_delrule, nft_rule_lookup_byid, nft_delrule_by_chain, nft_is_active_next]\n\n2. 函数名: nft_table_lookup\n- 参数: [struct net *net, const struct nlattr *nla, u8 family, u8 genmask, u32 portid]\n- 调用者: nf_tables_delrule\n- 被调用者: (未显示)\n\n3. 函数名: nft_chain_lookup\n- 参数: [struct net *net, struct nft_table *table, const struct nlattr *nla, u8 genmask]\n- 调用者: nf_tables_delrule\n- 被调用者: (未显示)\n\n4. 函数名: nft_chain_is_bound\n- 参数: [struct nft_chain *chain]\n- 调用者: nf_tables_delrule\n- 被调用者: (未显示)\n\n5. 函数名: nft_ctx_init\n- 参数: [struct nft_ctx *ctx, struct net *net, struct sk_buff *skb, const struct nlmsghdr *nlh, u8 family, struct nft_table *table, struct nft_chain *chain, const struct nlattr * const nla[]]\n- 调用者: nf_tables_delrule\n- 被调用者: (未显示)\n\n6. 函数名: nft_rule_lookup\n- 参数: [struct nft_chain *chain, const struct nlattr *nla]\n- 调用者: nf_tables_delrule\n- 被调用者: (未显示)\n\n7. 函数名: nft_delrule\n- 参数: [struct nft_ctx *ctx, struct nft_rule *rule]\n- 调用者: nf_tables_delrule\n- 被调用者: (未显示)\n\n8. 函数名: nft_rule_lookup_byid\n- 参数: [struct net *net, struct nft_chain *chain, const struct nlattr *nla]\n- 调用者: nf_tables_delrule\n- 被调用者: (未显示)\n\n9. 函数名: nft_delrule_by_chain\n- 参数: [struct nft_ctx *ctx]\n- 调用者: nf_tables_delrule\n- 被调用者: (未显示)\n\n10. 函数名: nft_is_active_next\n- 参数: [struct net *net, struct nft_chain *chain]\n- 调用者: nf_tables_delrule\n- 被调用者: (未显示)"
    },
    {
        "id": 4264,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5197",
        "purpose": "Code purpose:\"\"\"释放和销毁网络过滤表(nft_table)及其关联的链(chain)、规则(rule)、流表(flowtable)、集合(set)和对象(object)等资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在同一个事务中对链绑定进行规则添加和删除操作时，会导致释放后重用(use-after-free)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: __nft_release_table\n- 参数: [net, table]\n- 调用者: 未显示\n- 被调用者: [nft_chain_is_bound, list_del, nft_use_dec, nf_tables_rule_release, nf_tables_flowtable_destroy, nft_map_deactivate, nft_set_destroy, nft_obj_del, nft_obj_destroy, nft_chain_del, nf_tables_chain_destroy, nf_tables_table_destroy]\n\n2. 函数名: nft_chain_is_bound\n- 参数: [chain]\n- 调用者: __nft_release_table\n- 被调用者: 未显示\n\n3. 函数名: list_del\n- 参数: [&rule->list, &flowtable->list, &set->list]\n- 调用者: __nft_release_table\n- 被调用者: 未显示\n\n4. 函数名: nft_use_dec\n- 参数: [&chain->use, &table->use]\n- 调用者: __nft_release_table\n- 被调用者: 未显示\n\n5. 函数名: nf_tables_rule_release\n- 参数: [&ctx, rule]\n- 调用者: __nft_release_table\n- 被调用者: 未显示\n\n6. 函数名: nf_tables_flowtable_destroy\n- 参数: [flowtable]\n- 调用者: __nft_release_table\n- 被调用者: 未显示\n\n7. 函数名: nft_map_deactivate\n- 参数: [&ctx, set]\n- 调用者: __nft_release_table\n- 被调用者: 未显示\n\n8. 函数名: nft_set_destroy\n- 参数: [&ctx, set]\n- 调用者: __nft_release_table\n- 被调用者: 未显示\n\n9. 函数名: nft_obj_del\n- 参数: [obj]\n- 调用者: __nft_release_table\n- 被调用者: 未显示\n\n10. 函数名: nft_obj_destroy\n- 参数: [&ctx, obj]\n- 调用者: __nft_release_table\n- 被调用者: 未显示\n\n11. 函数名: nft_chain_del\n- 参数: [chain]\n- 调用者: __nft_release_table\n- 被调用者: 未显示\n\n12. 函数名: nf_tables_chain_destroy\n- 参数: [&ctx]\n- 调用者: __nft_release_table\n- 被调用者: 未显示\n\n13. 函数名: nf_tables_table_destroy\n- 参数: [&ctx]\n- 调用者: __nft_release_table\n- 被调用者: 未显示"
    },
    {
        "id": 4265,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5197",
        "purpose": "Code purpose:\"\"\"该代码用于处理Linux内核netfilter子系统中nf_tables模块的删除链操作，包括查找指定链、验证条件并执行删除操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在同一个事务中同时添加和删除链绑定规则时，由于引用计数管理不当导致释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nf_tables_delchain\n- 参数: [struct sk_buff *skb, const struct nfnl_info *info, const struct nlattr * const nla[]]\n- 调用者: (未明确显示)\n- 被调用者: [nft_table_lookup, nft_chain_lookup_byhandle, nft_chain_lookup, nft_ctx_init, nft_is_base_chain, nft_base_chain, nft_base_chain_netdev, nft_delchain_hook, nft_delrule, nft_delchain]\n\n2. 函数名: nft_table_lookup\n- 参数: [struct net *net, const struct nlattr *nla, u8 family, u8 genmask, u32 portid]\n- 调用者: nf_tables_delchain\n- 被调用者: (未明确显示)\n\n3. 函数名: nft_chain_lookup_byhandle\n- 参数: [struct nft_table *table, u64 handle, u8 genmask]\n- 调用者: nf_tables_delchain\n- 被调用者: (未明确显示)\n\n4. 函数名: nft_chain_lookup\n- 参数: [struct net *net, struct nft_table *table, const struct nlattr *attr, u8 genmask]\n- 调用者: nf_tables_delchain\n- 被调用者: (未明确显示)\n\n5. 函数名: nft_ctx_init\n- 参数: [struct nft_ctx *ctx, struct net *net, struct sk_buff *skb, const struct nlmsghdr *nlh, u8 family, struct nft_table *table, struct nft_chain *chain, const struct nlattr * const nla[]]\n- 调用者: nf_tables_delchain\n- 被调用者: (未明确显示)\n\n6. 函数名: nft_is_base_chain\n- 参数: [struct nft_chain *chain]\n- 调用者: nf_tables_delchain\n- 被调用者: (未明确显示)\n\n7. 函数名: nft_base_chain\n- 参数: [struct nft_chain *chain]\n- 调用者: nf_tables_delchain\n- 被调用者: (未明确显示)\n\n8. 函数名: nft_base_chain_netdev\n- 参数: [u32 family, int hooknum]\n- 调用者: nf_tables_delchain\n- 被调用者: (未明确显示)\n\n9. 函数名: nft_delchain_hook\n- 参数: [struct nft_ctx *ctx, struct nft_base_chain *basechain, struct netlink_ext_ack *extack]\n- 调用者: nf_tables_delchain\n- 被调用者: (未明确显示)\n\n10. 函数名: nft_delrule\n- 参数: [struct nft_ctx *ctx, struct nft_rule *rule]\n- 调用者: nf_tables_delchain\n- 被调用者: (未明确显示)\n\n11. 函数名: nft_delchain\n- 参数: [struct nft_ctx *ctx]\n- 调用者: nf_tables_delchain\n- 被调用者: (未明确显示)"
    },
    {
        "id": 4266,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5345",
        "purpose": "Code purpose:\"\"\"解析SMB3文件系统挂载参数并设置相关配置，处理用户认证、网络连接、文件系统特性等选项\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在smb3_fs_context_parse_param函数出错时，ctx->password被释放但未置空，可能导致双重释放漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: smb3_fs_context_parse_param\n- 参数: [struct fs_context *fc, struct fs_parameter *param]\n- 调用者: 未显示\n- 被调用者: [smb3_fc2context, strcmp, fs_parse, cifs_dbg, cifs_errorf, kfree, kfree_sensitive, kstrdup, make_kuid, uid_valid, make_kgid, gid_valid, cifs_convert_address, strnlen, strncasecmp, memset, cifs_parse_smb_version, cifs_parse_security_flavors, cifs_parse_cache_flavor, smb3_parse_devname, smb3_fs_context_fullpath, IS_ERR, PTR_ERR, pr_warn, pr_warn_once, pr_err]\n\n2. 函数名: smb3_fc2context\n- 参数: [struct fs_context *fc]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n3. 函数名: fs_parse\n- 参数: [struct fs_context *fc, smb3_fs_parameters, struct fs_parameter *param, struct fs_parse_result *result]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n4. 函数名: cifs_dbg\n- 参数: [FYI/VFS, format string, ...]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n5. 函数名: cifs_errorf\n- 参数: [struct fs_context *fc, format string, ...]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n6. 函数名: kfree\n- 参数: [void *ptr]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n7. 函数名: kfree_sensitive\n- 参数: [void *ptr]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n8. 函数名: kstrdup\n- 参数: [const char *s, gfp_t gfp]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n9. 函数名: make_kuid\n- 参数: [struct user_namespace *ns, uid_t uid]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n10. 函数名: uid_valid\n- 参数: [kuid_t uid]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n11. 函数名: make_kgid\n- 参数: [struct user_namespace *ns, gid_t gid]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n12. 函数名: gid_valid\n- 参数: [kgid_t gid]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n13. 函数名: cifs_convert_address\n- 参数: [struct sockaddr *addr, const char *src, int len]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n14. 函数名: strnlen\n- 参数: [const char *s, size_t maxlen]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n15. 函数名: strncasecmp\n- 参数: [const char *s1, const char *s2, size_t n]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n16. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n17. 函数名: cifs_parse_smb_version\n- 参数: [struct fs_context *fc, const char *value, struct smb3_fs_context *ctx, bool is_smb3]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n18. 函数名: cifs_parse_security_flavors\n- 参数: [struct fs_context *fc, const char *value, struct smb3_fs_context *ctx]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n19. 函数名: cifs_parse_cache_flavor\n- 参数: [struct fs_context *fc, const char *value, struct smb3_fs_context *ctx]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n20. 函数名: smb3_parse_devname\n- 参数: [const char *devname, struct smb3_fs_context *ctx]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n21. 函数名: smb3_fs_context_fullpath\n- 参数: [struct smb3_fs_context *ctx, char sep]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n22. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n23. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n24. 函数名: pr_warn\n- 参数: [format string, ...]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n25. 函数名: pr_warn_once\n- 参数: [format string, ...]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示\n\n26. 函数名: pr_err\n- 参数: [format string, ...]\n- 调用者: smb3_fs_context_parse_param\n- 被调用者: 未显示"
    },
    {
        "id": 4267,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5633",
        "purpose": "Code purpose:\"\"\"释放虚拟机内存对象(vmw_bo)的资源，包括解除映射和释放gem对象\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放内存对象时未正确处理引用计数，导致释放后仍可能被使用的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_bo_release\n- 参数: [struct vmw_bo *vbo]\n- 调用者: 未显示在代码片段中\n- 被调用者: [vmw_bo_unmap, drm_gem_object_release]\n\n2. 函数名: vmw_bo_unmap\n- 参数: [struct vmw_bo *vbo]\n- 调用者: vmw_bo_release\n- 被调用者: 未显示在代码片段中\n\n3. 函数名: drm_gem_object_release\n- 参数: [&vbo->tbo.base]\n- 调用者: vmw_bo_release\n- 被调用者: 未显示在代码片段中"
    },
    {
        "id": 4268,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5633",
        "purpose": "Code purpose:\"\"\"该代码实现了虚拟机中3D加速环境下对内存对象的同步CPU操作（抓取和释放）的IOCTL接口处理功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在引用计数修改过程中未正确处理内存对象的生命周期，导致释放后重用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_user_bo_synccpu_ioctl\n- 参数: [struct drm_device *dev, void *data, struct drm_file *file_priv]\n- 调用者: 未显示（通常由DRM子系统调用）\n- 被调用者: [vmw_user_bo_lookup, vmw_user_bo_synccpu_grab, vmw_user_bo_unref, vmw_user_bo_synccpu_release]\n\n2. 函数名: vmw_user_bo_lookup\n- 参数: [struct drm_file *file_priv, unsigned int handle, struct vmw_bo **vbo]\n- 调用者: vmw_user_bo_synccpu_ioctl\n- 被调用者: 未显示\n\n3. 函数名: vmw_user_bo_synccpu_grab\n- 参数: [struct vmw_bo *vbo, unsigned int flags]\n- 调用者: vmw_user_bo_synccpu_ioctl\n- 被调用者: 未显示\n\n4. 函数名: vmw_user_bo_unref\n- 参数: [struct vmw_bo *vbo]\n- 调用者: vmw_user_bo_synccpu_ioctl\n- 被调用者: 未显示\n\n5. 函数名: vmw_user_bo_synccpu_release\n- 参数: [struct drm_file *file_priv, unsigned int handle, unsigned int flags]\n- 调用者: vmw_user_bo_synccpu_ioctl\n- 被调用者: 未显示"
    },
    {
        "id": 4269,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5633",
        "purpose": "Code purpose:\"\"\"该代码用于通过句柄查找并获取虚拟内存缓冲区对象，同时增加其引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在引用计数修改过程中未正确处理内存对象，导致释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_user_bo_lookup\n- 参数: [struct drm_file *filp, u32 handle, struct vmw_bo **out]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [drm_gem_object_lookup, to_vmw_bo, ttm_bo_get]\n\n2. 函数名: drm_gem_object_lookup\n- 参数: [struct drm_file *filp, u32 handle]\n- 调用者: vmw_user_bo_lookup\n- 被调用者: 未明确\n\n3. 函数名: to_vmw_bo\n- 参数: [struct drm_gem_object *gobj]\n- 调用者: vmw_user_bo_lookup\n- 被调用者: 未明确\n\n4. 函数名: ttm_bo_get\n- 参数: [struct ttm_buffer_object *tbo]\n- 调用者: vmw_user_bo_lookup\n- 被调用者: 未明确"
    },
    {
        "id": 4270,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5633",
        "purpose": "Code purpose:\"\"\"该代码用于释放VMware图形驱动中用户空间缓冲区对象的CPU同步引用计数，并在特定条件下减少写者计数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放内存对象时未正确处理引用计数，导致在同步CPU操作期间可能发生引用计数错误，从而引发释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_user_bo_synccpu_release\n- 参数: [struct drm_file *filp, uint32_t handle, uint32_t flags]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [vmw_user_bo_lookup, atomic_dec, vmw_user_bo_unref]\n\n2. 函数名: vmw_user_bo_lookup\n- 参数: [struct drm_file *filp, uint32_t handle, struct vmw_bo **vmw_bo]\n- 调用者: vmw_user_bo_synccpu_release\n- 被调用者: 未显示（可能为内部实现）\n\n3. 函数名: atomic_dec\n- 参数: [atomic_t *v] (这里传递的是&vmw_bo->cpu_writers)\n- 调用者: vmw_user_bo_synccpu_release\n- 被调用者: 未显示（原子操作实现）\n\n4. 函数名: vmw_user_bo_unref\n- 参数: [struct vmw_bo *vmw_bo]\n- 调用者: vmw_user_bo_synccpu_release\n- 被调用者: 未显示（可能为内部实现）"
    },
    {
        "id": 4271,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5633",
        "purpose": "Code purpose:\"\"\"该代码用于调整VMware图形设备中COTable（命令表）的大小，包括分配新缓冲区、复制旧数据、切换缓冲区引用以及处理可能的错误情况。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在内存对象处理过程中，由于引用计数管理不当导致释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_cotable_resize\n- 参数: [struct vmw_resource *res, size_t new_size]\n- 调用者: N/A (顶级函数)\n- 被调用者: [vmw_cotable, MKS_STAT_TIME_DECL, MKS_STAT_TIME_PUSH, vmw_cotable_readback, vmw_bo_create, ttm_bo_reserve, ttm_bo_wait, ttm_bo_kmap, ttm_kmap_obj_virtual, ttm_bo_kunmap, vmw_bo_placement_set, ttm_bo_validate, vmw_resource_mob_detach, vmw_cotable_unscrub, vmw_resource_mob_attach, vmw_bo_unreference, dma_resv_reserve_fences, ttm_bo_unpin, MKS_STAT_TIME_POP]\n\n2. 函数名: vmw_cotable\n- 参数: [struct vmw_resource *res]\n- 调用者: vmw_cotable_resize\n- 被调用者: []\n\n3. 函数名: MKS_STAT_TIME_DECL\n- 参数: [MKSSTAT_KERN_COTABLE_RESIZE]\n- 调用者: vmw_cotable_resize\n- 被调用者: []\n\n4. 函数名: MKS_STAT_TIME_PUSH\n- 参数: [MKSSTAT_KERN_COTABLE_RESIZE]\n- 调用者: vmw_cotable_resize\n- 被调用者: []\n\n5. 函数名: vmw_cotable_readback\n- 参数: [struct vmw_resource *res]\n- 调用者: vmw_cotable_resize\n- 被调用者: []\n\n6. 函数名: vmw_bo_create\n- 参数: [struct vmw_private *dev_priv, struct vmw_bo_params *bo_params, struct vmw_bo **buf]\n- 调用者: vmw_cotable_resize\n- 被调用者: []\n\n7. 函数名: ttm_bo_reserve\n- 参数: [struct ttm_buffer_object *bo, bool interruptible, bool no_wait, NULL]\n- 调用者: vmw_cotable_resize\n- 被调用者: []\n\n8. 函数名: ttm_bo_wait\n- 参数: [struct ttm_buffer_object *old_bo, false, false]\n- 调用者: vmw_cotable_resize\n- 被调用者: []\n\n9. 函数名: ttm_bo_kmap\n- 参数: [struct ttm_buffer_object *bo, size_t i, 1, struct ttm_bo_kmap_obj *map]\n- 调用者: vmw_cotable_resize\n- 被调用者: []\n\n10. 函数名: ttm_kmap_obj_virtual\n- 参数: [struct ttm_bo_kmap_obj *map, bool *dummy]\n- 调用者: vmw_cotable_resize\n- 被调用者: []\n\n11. 函数名: ttm_bo_kunmap\n- 参数: [struct ttm_bo_kmap_obj *map]\n- 调用者: vmw_cotable_resize\n- 被调用者: []\n\n12. 函数名: vmw_bo_placement_set\n- 参数: [struct vmw_bo *buf, VMW_BO_DOMAIN_MOB, VMW_BO_DOMAIN_MOB]\n- 调用者: vmw_cotable_resize\n- 被调用者: []\n\n13. 函数名: ttm_bo_validate\n- 参数: [struct ttm_buffer_object *bo, struct ttm_placement *placement, struct ttm_operation_ctx *ctx]\n- 调用者: vmw_cotable_resize\n- 被调用者: []\n\n14. 函数名: vmw_resource_mob_detach\n- 参数: [struct vmw_resource *res]\n- 调用者: vmw_cotable_resize\n- 被调用者: []\n\n15. 函数名: vmw_cotable_unscrub\n- 参数: [struct vmw_resource *res]\n- 调用者: vmw_cotable_resize\n- 被调用者: []\n\n16. 函数名: vmw_resource_mob_attach\n- 参数: [struct vmw_resource *res]\n- 调用者: vmw_cotable_resize\n- 被调用者: []\n\n17. 函数名: vmw_bo_unreference\n- 参数: [struct vmw_bo **old_buf]\n- 调用者: vmw_cotable_resize\n- 被调用者: []\n\n18. 函数名: dma_resv_reserve_fences\n- 参数: [struct dma_resv *resv, 1]\n- 调用者: vmw_cotable_resize\n- 被调用者: []\n\n19. 函数名: ttm_bo_unpin\n- 参数: [struct ttm_buffer_object *bo]\n- 调用者: vmw_cotable_resize\n- 被调用者: []\n\n20. 函数名: MKS_STAT_TIME_POP\n- 参数: [MKSSTAT_KERN_COTABLE_RESIZE]\n- 调用者: vmw_cotable_resize\n- 被调用者: []"
    },
    {
        "id": 4272,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5633",
        "purpose": "Code purpose:\"\"\"将SVGAGuestPtr转换为vmw_bo对象并管理其引用计数和重定位信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放内存对象后仍保留了对该对象的引用，导致引用计数管理不当引发use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_translate_guest_ptr\n- 参数: [dev_priv, sw_context, ptr, vmw_bo_p]\n- 调用者: N/A\n- 被调用者: [vmw_validation_preload_bo, vmw_user_bo_lookup, vmw_bo_placement_set, vmw_validation_add_bo, vmw_user_bo_unref, vmw_validation_mem_alloc, list_add_tail]\n\n2. 函数名: vmw_validation_preload_bo\n- 参数: [sw_context->ctx]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: []\n\n3. 函数名: vmw_user_bo_lookup\n- 参数: [sw_context->filp, handle, &vmw_bo]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: []\n\n4. 函数名: vmw_bo_placement_set\n- 参数: [vmw_bo, VMW_BO_DOMAIN_GMR | VMW_BO_DOMAIN_VRAM, VMW_BO_DOMAIN_GMR | VMW_BO_DOMAIN_VRAM]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: []\n\n5. 函数名: vmw_validation_add_bo\n- 参数: [sw_context->ctx, vmw_bo]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: []\n\n6. 函数名: vmw_user_bo_unref\n- 参数: [vmw_bo]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: []\n\n7. 函数名: vmw_validation_mem_alloc\n- 参数: [sw_context->ctx, sizeof(*reloc)]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: []\n\n8. 函数名: list_add_tail\n- 参数: [&reloc->head, &sw_context->bo_relocations]\n- 调用者: vmw_translate_guest_ptr\n- 被调用者: []"
    },
    {
        "id": 4273,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5633",
        "purpose": "Code purpose:\"\"\"将用户空间的MOB缓冲区ID转换为内核空间的vmw_bo对象，并建立重定位关系用于后续操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放内存对象后仍继续使用其引用，导致释放后重用漏洞(CWE-416)。\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_translate_mob_ptr\n- 参数: [dev_priv, sw_context, id, vmw_bo_p]\n- 调用者: 未显示\n- 被调用者: [vmw_validation_preload_bo, vmw_user_bo_lookup, vmw_bo_placement_set, vmw_validation_add_bo, vmw_user_bo_unref, vmw_validation_mem_alloc, list_add_tail]\n\n2. 函数名: vmw_validation_preload_bo\n- 参数: [sw_context->ctx]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: 未显示\n\n3. 函数名: vmw_user_bo_lookup\n- 参数: [sw_context->filp, handle, &vmw_bo]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: 未显示\n\n4. 函数名: vmw_bo_placement_set\n- 参数: [vmw_bo, VMW_BO_DOMAIN_MOB, VMW_BO_DOMAIN_MOB]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: 未显示\n\n5. 函数名: vmw_validation_add_bo\n- 参数: [sw_context->ctx, vmw_bo]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: 未显示\n\n6. 函数名: vmw_user_bo_unref\n- 参数: [vmw_bo]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: 未显示\n\n7. 函数名: vmw_validation_mem_alloc\n- 参数: [sw_context->ctx, sizeof(*reloc)]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: 未显示\n\n8. 函数名: list_add_tail\n- 参数: [&reloc->head, &sw_context->bo_relocations]\n- 调用者: vmw_translate_mob_ptr\n- 被调用者: 未显示"
    },
    {
        "id": 4274,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5633",
        "purpose": "Code purpose:\"\"\"创建带有句柄的VMware图形内存对象并管理其引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在内存对象被用于存储表面时，引用计数变更导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_gem_object_create_with_handle\n- 参数: [struct vmw_private *dev_priv, struct drm_file *filp, uint32_t size, uint32_t *handle, struct vmw_bo **p_vbo]\n- 调用者: 未显示\n- 被调用者: [vmw_bo_create, drm_gem_handle_create]\n\n2. 函数名: vmw_bo_create\n- 参数: [struct vmw_private *dev_priv, struct vmw_bo_params *params, struct vmw_bo **p_vbo]\n- 调用者: vmw_gem_object_create_with_handle\n- 被调用者: 未显示\n\n3. 函数名: drm_gem_handle_create\n- 参数: [struct drm_file *filp, struct drm_gem_object *obj, uint32_t *handle]\n- 调用者: vmw_gem_object_create_with_handle\n- 被调用者: 未显示"
    },
    {
        "id": 4275,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5633",
        "purpose": "Code purpose:\"\"\"该代码用于在VMware虚拟环境中创建和管理图形缓冲区的代理表面，处理不同像素格式的帧缓冲区并管理相关资源引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在资源引用计数管理过程中存在缺陷，导致在释放内存对象后仍可能被访问，造成use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_create_bo_proxy\n- 参数: [dev, mode_cmd, bo_mob, srf_out]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [vmw_gb_surface_define, vmw_priv, vmw_resource_reserve, vmw_bo_unreference, vmw_bo_reference, vmw_resource_unreserve]\n\n2. 函数名: vmw_gb_surface_define\n- 参数: [vmw_priv(dev), &metadata, srf_out]\n- 调用者: vmw_create_bo_proxy\n- 被调用者: 未明确（假设为外部函数）\n\n3. 函数名: vmw_priv\n- 参数: [dev]\n- 调用者: vmw_create_bo_proxy\n- 被调用者: 未明确（假设为外部函数）\n\n4. 函数名: vmw_resource_reserve\n- 参数: [res, false, true]\n- 调用者: vmw_create_bo_proxy\n- 被调用者: 未明确（假设为外部函数）\n\n5. 函数名: vmw_bo_unreference\n- 参数: [&res->guest_memory_bo]\n- 调用者: vmw_create_bo_proxy\n- 被调用者: 未明确（假设为外部函数）\n\n6. 函数名: vmw_bo_reference\n- 参数: [bo_mob]\n- 调用者: vmw_create_bo_proxy\n- 被调用者: 未明确（假设为外部函数）\n\n7. 函数名: vmw_resource_unreserve\n- 参数: [res, false, false, false, NULL, 0]\n- 调用者: vmw_create_bo_proxy\n- 被调用者: 未明确（假设为外部函数）"
    },
    {
        "id": 4276,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5633",
        "purpose": "Code purpose:\"\"\"该代码用于在VMware虚拟机的3D加速环境下创建和管理帧缓冲对象，处理来自用户空间的图形缓冲区请求。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在3D加速环境下，由于对内存对象的引用计数处理不当，导致在释放表面(surface)时可能发生引用计数错误，从而引发释放后重用(use-after-free)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_kms_fb_create\n- 参数: [struct drm_device *dev, struct drm_file *file_priv, const struct drm_mode_fb_cmd2 *mode_cmd]\n- 调用者: N/A\n- 被调用者: [vmw_priv, vmw_user_lookup_handle, vmw_kms_srf_ok, vmw_kms_new_framebuffer, vmw_user_bo_unref, vmw_surface_unreference]\n\n2. 函数名: vmw_priv\n- 参数: [struct drm_device *dev]\n- 调用者: vmw_kms_fb_create\n- 被调用者: N/A\n\n3. 函数名: vmw_user_lookup_handle\n- 参数: [struct vmw_private *dev_priv, struct drm_file *file_priv, unsigned int handles, struct vmw_surface **surface, struct vmw_bo **bo]\n- 调用者: vmw_kms_fb_create\n- 被调用者: N/A\n\n4. 函数名: vmw_kms_srf_ok\n- 参数: [struct vmw_private *dev_priv, unsigned int width, unsigned int height]\n- 调用者: vmw_kms_fb_create\n- 被调用者: N/A\n\n5. 函数名: vmw_kms_new_framebuffer\n- 参数: [struct vmw_private *dev_priv, struct vmw_bo *bo, struct vmw_surface *surface, bool is_dmabuf_proxy, const struct drm_mode_fb_cmd2 *mode_cmd]\n- 调用者: vmw_kms_fb_create\n- 被调用者: N/A\n\n6. 函数名: vmw_user_bo_unref\n- 参数: [struct vmw_bo *bo]\n- 调用者: vmw_kms_fb_create\n- 被调用者: N/A\n\n7. 函数名: vmw_surface_unreference\n- 参数: [struct vmw_surface **surface]\n- 调用者: vmw_kms_fb_create\n- 被调用者: N/A"
    },
    {
        "id": 4277,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5633",
        "purpose": "Code purpose:\"\"\"该代码片段实现了VMware图形驱动中覆盖层(overlay)的IOCTL控制功能，包括流媒体的启用/禁用和更新操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放内存对象时未正确处理引用计数，导致引用计数管理不当引发释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_overlay_ioctl\n- 参数: [struct drm_device *dev, void *data, struct drm_file *file_priv]\n- 调用者: N/A (系统调用接口)\n- 被调用者: [vmw_fpriv, vmw_priv, vmw_overlay_available, vmw_user_stream_lookup, mutex_lock, vmw_overlay_stop, vmw_user_bo_lookup, vmw_overlay_update_stream, vmw_user_bo_unref, mutex_unlock, vmw_resource_unreference]\n\n2. 函数名: vmw_fpriv\n- 参数: [struct drm_file *file_priv]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: []\n\n3. 函数名: vmw_priv\n- 参数: [struct drm_device *dev]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: []\n\n4. 函数名: vmw_overlay_available\n- 参数: [struct vmw_private *dev_priv]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: []\n\n5. 函数名: vmw_user_stream_lookup\n- 参数: [struct vmw_private *dev_priv, struct ttm_object_file *tfile, &arg->stream_id, &res]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: []\n\n6. 函数名: mutex_lock\n- 参数: [&overlay->mutex]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: []\n\n7. 函数名: vmw_overlay_stop\n- 参数: [struct vmw_private *dev_priv, arg->stream_id, false, true]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: []\n\n8. 函数名: vmw_user_bo_lookup\n- 参数: [file_priv, arg->handle, &buf]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: []\n\n9. 函数名: vmw_overlay_update_stream\n- 参数: [struct vmw_private *dev_priv, buf, arg, true]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: []\n\n10. 函数名: vmw_user_bo_unref\n- 参数: [buf]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: []\n\n11. 函数名: mutex_unlock\n- 参数: [&overlay->mutex]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: []\n\n12. 函数名: vmw_resource_unreference\n- 参数: [&res]\n- 调用者: vmw_overlay_ioctl\n- 被调用者: []"
    },
    {
        "id": 4278,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5633",
        "purpose": "Code purpose:\"\"\"释放VMware图形资源并管理相关内存对象的引用计数和绑定关系\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放资源时未正确处理内存对象的引用计数，导致释放后仍可能被使用的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_resource_release\n- 参数: [struct kref *kref]\n- 调用者: 未明确（通常由kref引用计数机制调用）\n- 被调用者: [container_of, list_del_init, spin_lock, spin_unlock, ttm_bo_reserve, vmw_resource_mob_attached, res->func->unbind, vmw_resource_mob_detach, res->func->dirty_free, vmw_bo_dirty_release, ttm_bo_unreserve, vmw_bo_unreference, mutex_lock, vmw_binding_res_list_kill, mutex_unlock, res->hw_destroy, res->res_free, kfree, idr_remove]\n\n2. 函数名: container_of\n- 参数: [kref, struct vmw_resource, kref]\n- 调用者: vmw_resource_release\n- 被调用者: []\n\n3. 函数名: list_del_init\n- 参数: [&res->lru_head]\n- 调用者: vmw_resource_release\n- 被调用者: []\n\n4. 函数名: spin_lock\n- 参数: [&dev_priv->resource_lock]\n- 调用者: vmw_resource_release\n- 被调用者: []\n\n5. 函数名: spin_unlock\n- 参数: [&dev_priv->resource_lock]\n- 调用者: vmw_resource_release\n- 被调用者: []\n\n6. 函数名: ttm_bo_reserve\n- 参数: [bo, false, false, NULL]\n- 调用者: vmw_resource_release\n- 被调用者: []\n\n7. 函数名: vmw_resource_mob_attached\n- 参数: [res]\n- 调用者: vmw_resource_release\n- 被调用者: []\n\n8. 函数名: res->func->unbind\n- 参数: [res, false, &val_buf]\n- 调用者: vmw_resource_release\n- 被调用者: []\n\n9. 函数名: vmw_resource_mob_detach\n- 参数: [res]\n- 调用者: vmw_resource_release\n- 被调用者: []\n\n10. 函数名: res->func->dirty_free\n- 参数: [res]\n- 调用者: vmw_resource_release\n- 被调用者: []\n\n11. 函数名: vmw_bo_dirty_release\n- 参数: [res->guest_memory_bo]\n- 调用者: vmw_resource_release\n- 被调用者: []\n\n12. 函数名: ttm_bo_unreserve\n- 参数: [bo]\n- 调用者: vmw_resource_release\n- 被调用者: []\n\n13. 函数名: vmw_bo_unreference\n- 参数: [&res->guest_memory_bo]\n- 调用者: vmw_resource_release\n- 被调用者: []\n\n14. 函数名: mutex_lock\n- 参数: [&dev_priv->binding_mutex]\n- 调用者: vmw_resource_release\n- 被调用者: []\n\n15. 函数名: vmw_binding_res_list_kill\n- 参数: [&res->binding_head]\n- 调用者: vmw_resource_release\n- 被调用者: []\n\n16. 函数名: mutex_unlock\n- 参数: [&dev_priv->binding_mutex]\n- 调用者: vmw_resource_release\n- 被调用者: []\n\n17. 函数名: res->hw_destroy\n- 参数: [res]\n- 调用者: vmw_resource_release\n- 被调用者: []\n\n18. 函数名: res->res_free\n- 参数: [res]\n- 调用者: vmw_resource_release\n- 被调用者: []\n\n19. 函数名: kfree\n- 参数: [res]\n- 调用者: vmw_resource_release\n- 被调用者: []\n\n20. 函数名: idr_remove\n- 参数: [idr, id]\n- 调用者: vmw_resource_release\n- 被调用者: []"
    },
    {
        "id": 4279,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5633",
        "purpose": "Code purpose:\"\"\"该代码用于验证和管理VMware图形资源的内存对象，包括资源验证、LRU列表管理和内存回收操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在资源验证过程中对内存对象引用计数的处理不当，导致释放后使用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_resource_validate\n- 参数: [res, intr, dirtying]\n- 调用者: 未显示\n- 被调用者: [vmw_resource_do_validate, vmw_resource_reference, vmw_resource_do_evict, vmw_resource_unreference, vmw_bo_unreference]\n\n2. 函数名: vmw_resource_do_validate\n- 参数: [res, val_buf, dirtying]\n- 调用者: vmw_resource_validate\n- 被调用者: 未显示\n\n3. 函数名: vmw_resource_reference\n- 参数: [list_first_entry(lru_list, struct vmw_resource, lru_head)]\n- 调用者: vmw_resource_validate\n- 被调用者: 未显示\n\n4. 函数名: vmw_resource_do_evict\n- 参数: [NULL, evict_res, intr]\n- 调用者: vmw_resource_validate\n- 被调用者: 未显示\n\n5. 函数名: vmw_resource_unreference\n- 参数: [&evict_res]\n- 调用者: vmw_resource_validate\n- 被调用者: 未显示\n\n6. 函数名: vmw_bo_unreference\n- 参数: [&res->guest_memory_bo]\n- 调用者: vmw_resource_validate\n- 被调用者: 未显示"
    },
    {
        "id": 4280,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5633",
        "purpose": "Code purpose:\"\"\"该代码用于检查和管理虚拟机资源中的缓冲区，包括分配、验证和释放缓冲区内存的操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放内存对象时未正确处理引用计数，导致存在use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_resource_check_buffer\n- 参数: [ticket, res, interruptible, val_buf]\n- 调用者: 未提供\n- 被调用者: [vmw_resource_buf_alloc, ttm_bo_get, ttm_eu_reserve_buffers, vmw_resource_mob_attached, vmw_bo_placement_set, ttm_bo_validate, ttm_eu_backoff_reservation, ttm_bo_put, vmw_bo_unreference]\n\n2. 函数名: vmw_resource_buf_alloc\n- 参数: [res, interruptible]\n- 调用者: vmw_resource_check_buffer\n- 被调用者: 未提供\n\n3. 函数名: ttm_bo_get\n- 参数: [&res->guest_memory_bo->tbo]\n- 调用者: vmw_resource_check_buffer\n- 被调用者: 未提供\n\n4. 函数名: ttm_eu_reserve_buffers\n- 参数: [ticket, &val_list, interruptible, NULL]\n- 调用者: vmw_resource_check_buffer\n- 被调用者: 未提供\n\n5. 函数名: vmw_resource_mob_attached\n- 参数: [res]\n- 调用者: vmw_resource_check_buffer\n- 被调用者: 未提供\n\n6. 函数名: vmw_bo_placement_set\n- 参数: [res->guest_memory_bo, res->func->domain, res->func->busy_domain]\n- 调用者: vmw_resource_check_buffer\n- 被调用者: 未提供\n\n7. 函数名: ttm_bo_validate\n- 参数: [&res->guest_memory_bo->tbo, &res->guest_memory_bo->placement, &ctx]\n- 调用者: vmw_resource_check_buffer\n- 被调用者: 未提供\n\n8. 函数名: ttm_eu_backoff_reservation\n- 参数: [ticket, &val_list]\n- 调用者: vmw_resource_check_buffer\n- 被调用者: 未提供\n\n9. 函数名: ttm_bo_put\n- 参数: [val_buf->bo]\n- 调用者: vmw_resource_check_buffer\n- 被调用者: 未提供\n\n10. 函数名: vmw_bo_unreference\n- 参数: [&res->guest_memory_bo]\n- 调用者: vmw_resource_check_buffer\n- 被调用者: 未提供"
    },
    {
        "id": 4281,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5633",
        "purpose": "Code purpose:\"\"\"为虚拟机资源分配和管理图形内存缓冲区对象\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放内存对象时未正确处理引用计数，导致后续使用时可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_resource_buf_alloc\n- 参数: [struct vmw_resource *res, bool interruptible]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [vmw_bo_create]\n\n2. 函数名: vmw_bo_create\n- 参数: [struct vmw_private *dev_priv, struct vmw_bo_params *params, struct vmw_bo **p_bo]\n- 调用者: vmw_resource_buf_alloc\n- 被调用者: 未明确（由代码片段无法确定）\n\n3. 函数名: PFN_ALIGN\n- 参数: [unsigned long size]\n- 调用者: vmw_resource_buf_alloc\n- 被调用者: 未明确（可能是宏或内联函数）"
    },
    {
        "id": 4282,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5633",
        "purpose": "Code purpose:\"\"\"该代码用于管理VMware虚拟机的图形资源引用计数和内存对象切换，包括处理脏页状态和资源释放等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在切换guest memory时未正确处理内存对象的引用计数，导致释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_resource_unreserve\n- 参数: [res, dirty_set, dirty, switch_guest_memory, new_guest_memory_bo, new_guest_memory_offset]\n- 调用者: 不适用（顶级函数）\n- 被调用者: [vmw_resource_mob_detach, vmw_bo_dirty_release, vmw_bo_unreference, vmw_bo_reference, vmw_resource_mob_attach, list_add_tail]\n\n2. 函数名: vmw_resource_mob_detach\n- 参数: [res]\n- 调用者: vmw_resource_unreserve\n- 被调用者: []\n\n3. 函数名: vmw_bo_dirty_release\n- 参数: [res->guest_memory_bo]\n- 调用者: vmw_resource_unreserve\n- 被调用者: []\n\n4. 函数名: vmw_bo_unreference\n- 参数: [&res->guest_memory_bo]\n- 调用者: vmw_resource_unreserve\n- 被调用者: []\n\n5. 函数名: vmw_bo_reference\n- 参数: [new_guest_memory_bo]\n- 调用者: vmw_resource_unreserve\n- 被调用者: []\n\n6. 函数名: vmw_resource_mob_attach\n- 参数: [res]\n- 调用者: vmw_resource_unreserve\n- 被调用者: []\n\n7. 函数名: list_add_tail\n- 参数: [&res->lru_head, &res->dev_priv->res_lru[res->func->res_type]]\n- 调用者: vmw_resource_unreserve\n- 被调用者: []"
    },
    {
        "id": 4283,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5633",
        "purpose": "Code purpose:\"\"\"该代码用于在VMware虚拟环境中处理着色器定义操作，包括验证输入参数、查找缓冲区对象并根据着色器类型分配相应的着色器资源。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放内存对象时未正确处理引用计数，导致引用计数变化后出现use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_shader_define\n- 参数: [struct drm_device *dev, struct drm_file *file_priv, enum drm_vmw_shader_type shader_type_drm, u32 buffer_handle, size_t size, size_t offset, uint8_t num_input_sig, uint8_t num_output_sig, uint32_t *shader_handle]\n- 调用者: 未显示（外部调用）\n- 被调用者: [vmw_priv, vmw_fpriv, vmw_user_bo_lookup, vmw_user_shader_alloc, vmw_user_bo_unref]\n\n2. 函数名: vmw_priv\n- 参数: [struct drm_device *dev]\n- 调用者: vmw_shader_define\n- 被调用者: 未显示\n\n3. 函数名: vmw_fpriv\n- 参数: [struct drm_file *file_priv]\n- 调用者: vmw_shader_define\n- 被调用者: 未显示\n\n4. 函数名: vmw_user_bo_lookup\n- 参数: [struct drm_file *file_priv, u32 buffer_handle, struct vmw_bo **buffer]\n- 调用者: vmw_shader_define\n- 被调用者: 未显示\n\n5. 函数名: vmw_user_shader_alloc\n- 参数: [struct vmw_private *dev_priv, struct vmw_bo *buffer, size_t size, size_t offset, SVGA3dShaderType shader_type, uint8_t num_input_sig, uint8_t num_output_sig, struct ttm_object_file *tfile, uint32_t *shader_handle]\n- 调用者: vmw_shader_define\n- 被调用者: 未显示\n\n6. 函数名: vmw_user_bo_unref\n- 参数: [struct vmw_bo *buffer]\n- 调用者: vmw_shader_define\n- 被调用者: 未显示"
    },
    {
        "id": 4284,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5633",
        "purpose": "Code purpose:\"\"\"初始化VMware图形后端着色器资源，包括设置资源属性、引用计数管理和内存对象处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放资源时未正确处理引用计数导致内存对象被释放后仍被使用\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_gb_shader_init\n- 参数: [dev_priv, res, size, offset, type, num_input_sig, num_output_sig, byte_code, res_free]\n- 调用者: 未显示\n- 被调用者: [vmw_res_to_shader, vmw_resource_init, res_free, kfree, vmw_bo_reference, vmw_hw_shader_destroy]\n\n2. 函数名: vmw_res_to_shader\n- 参数: [res]\n- 调用者: vmw_gb_shader_init\n- 被调用者: 未显示\n\n3. 函数名: vmw_resource_init\n- 参数: [dev_priv, res, true, res_free, &vmw_gb_shader_func]\n- 调用者: vmw_gb_shader_init\n- 被调用者: 未显示\n\n4. 函数名: res_free\n- 参数: [res]\n- 调用者: vmw_gb_shader_init\n- 被调用者: 未显示\n\n5. 函数名: kfree\n- 参数: [res]\n- 调用者: vmw_gb_shader_init\n- 被调用者: 未显示\n\n6. 函数名: vmw_bo_reference\n- 参数: [byte_code]\n- 调用者: vmw_gb_shader_init\n- 被调用者: 未显示\n\n7. 函数名: vmw_hw_shader_destroy\n- 参数: 未显示\n- 调用者: vmw_gb_shader_init\n- 被调用者: 未显示"
    },
    {
        "id": 4285,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5633",
        "purpose": "Code purpose:\"\"\"该代码用于在VMware虚拟环境中创建和管理3D图形表面资源，包括验证输入参数、分配内存资源、设置表面元数据以及处理资源引用计数等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放内存对象时引用计数处理不当，导致存在释放后使用(UAF)漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_gb_surface_define_internal\n- 参数: [struct drm_device *dev, struct drm_vmw_gb_surface_create_ext_req *req, struct drm_vmw_gb_surface_create_rep *rep, struct drm_file *file_priv]\n- 调用者: N/A (顶层函数)\n- 被调用者: [vmw_fpriv, vmw_priv, has_sm4_context, has_sm4_1_context, has_sm5_context, vmw_gb_surface_define, container_of, drm_is_primary_client, drm_file_get_master, vmw_user_bo_lookup, vmw_bo_unreference, vmw_gem_object_create_with_handle, vmw_bo_reference, vmw_resource_unreference, ttm_bo_reserve, vmw_bo_dirty_add, ttm_bo_unreserve, vmw_resource_reference, ttm_prime_object_init, drm_vma_node_offset_addr]\n\n2. 函数名: vmw_fpriv\n- 参数: [struct drm_file *file_priv]\n- 调用者: vmw_gb_surface_define_internal\n- 被调用者: []\n\n3. 函数名: vmw_priv\n- 参数: [struct drm_device *dev]\n- 调用者: vmw_gb_surface_define_internal\n- 被调用者: []\n\n4. 函数名: has_sm4_context\n- 参数: [struct vmw_private *dev_priv]\n- 调用者: vmw_gb_surface_define_internal\n- 被调用者: []\n\n5. 函数名: has_sm4_1_context\n- 参数: [struct vmw_private *dev_priv]\n- 调用者: vmw_gb_surface_define_internal\n- 被调用者: []\n\n6. 函数名: has_sm5_context\n- 参数: [struct vmw_private *dev_priv]\n- 调用者: vmw_gb_surface_define_internal\n- 被调用者: []\n\n7. 函数名: vmw_gb_surface_define\n- 参数: [struct vmw_private *dev_priv, struct vmw_surface_metadata *metadata, struct vmw_surface **srf]\n- 调用者: vmw_gb_surface_define_internal\n- 被调用者: []\n\n8. 函数名: container_of\n- 参数: [struct vmw_surface *srf, struct vmw_user_surface, srf]\n- 调用者: vmw_gb_surface_define_internal\n- 被调用者: []\n\n9. 函数名: drm_is_primary_client\n- 参数: [struct drm_file *file_priv]\n- 调用者: vmw_gb_surface_define_internal\n- 被调用者: []\n\n10. 函数名: drm_file_get_master\n- 参数: [struct drm_file *file_priv]\n- 调用者: vmw_gb_surface_define_internal\n- 被调用者: []\n\n11. 函数名: vmw_user_bo_lookup\n- 参数: [struct drm_file *file_priv, uint32_t handle, struct vmw_bo **bo]\n- 调用者: vmw_gb_surface_define_internal\n- 被调用者: []\n\n12. 函数名: vmw_bo_unreference\n- 参数: [struct vmw_bo **bo]\n- 调用者: vmw_gb_surface_define_internal\n- 被调用者: []\n\n13. 函数名: vmw_gem_object_create_with_handle\n- 参数: [struct vmw_private *dev_priv, struct drm_file *file_priv, size_t size, uint32_t *handle, struct vmw_bo **bo]\n- 调用者: vmw_gb_surface_define_internal\n- 被调用者: []\n\n14. 函数名: vmw_bo_reference\n- 参数: [struct vmw_bo *bo]\n- 调用者: vmw_gb_surface_define_internal\n- 被调用者: []\n\n15. 函数名: vmw_resource_unreference\n- 参数: [struct vmw_resource **res]\n- 调用者: vmw_gb_surface_define_internal\n- 被调用者: []\n\n16. 函数名: ttm_bo_reserve\n- 参数: [struct ttm_buffer_object *bo, bool interruptible, bool no_wait, struct ww_acquire_ctx *ticket]\n- 调用者: vmw_gb_surface_define_internal\n- 被调用者: []\n\n17. 函数名: vmw_bo_dirty_add\n- 参数: [struct vmw_bo *bo]\n- 调用者: vmw_gb_surface_define_internal\n- 被调用者: []\n\n18. 函数名: ttm_bo_unreserve\n- 参数: [struct ttm_buffer_object *bo]\n- 调用者: vmw_gb_surface_define_internal\n- 被调用者: []\n\n19. 函数名: vmw_resource_reference\n- 参数: [struct vmw_resource *res]\n- 调用者: vmw_gb_surface_define_internal\n- 被调用者: []\n\n20. 函数名: ttm_prime_object_init\n- 参数: [struct ttm_object_file *tfile, size_t size, struct ttm_prime_object *prime, bool shareable, enum ttm_object_type type, void (*refcount_release)(struct ttm_base_object **)]\n- 调用者: vmw_gb_surface_define_internal\n- 被调用者: []\n\n21. 函数名: drm_vma_node_offset_addr\n- 参数: [struct drm_vma_offset_node *node]\n- 调用者: vmw_gb_surface_define_internal\n- 被调用者: []"
    },
    {
        "id": 4286,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5633",
        "purpose": "Code purpose:\"\"\"释放VMware用户表面资源并处理相关内存对象的引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放资源时未正确处理引用计数导致use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_user_surface_base_release\n- 参数: [p_base]\n- 调用者: 未指定\n- 被调用者: [container_of, drm_gem_object_put, vmw_resource_unreference]\n\n2. 函数名: container_of\n- 参数: [base, struct vmw_user_surface, prime.base]\n- 调用者: vmw_user_surface_base_release\n- 被调用者: 未指定\n\n3. 函数名: drm_gem_object_put\n- 参数: [&res->guest_memory_bo->tbo.base]\n- 调用者: vmw_user_surface_base_release\n- 被调用者: 未指定\n\n4. 函数名: vmw_resource_unreference\n- 参数: [&res]\n- 调用者: vmw_user_surface_base_release\n- 被调用者: 未指定"
    },
    {
        "id": 4287,
        "cwe": "CWE-416",
        "cve": "CVE-2023-5633",
        "purpose": "Code purpose:\"\"\"该代码实现了虚拟机中3D图形表面(surface)的创建和管理功能，包括内存分配、格式验证、资源引用计数管理等，用于支持虚拟机的3D加速功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放内存对象时引用计数处理不当，导致后续使用时可能访问已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_surface_define_ioctl\n- 参数: [struct drm_device *dev, void *data, struct drm_file *file_priv]\n- 调用者: N/A (ioctl入口函数)\n- 被调用者: [vmw_priv, vmw_fpriv, vmw_surface_get_desc, kzalloc, memcpy, memdup_user, kmalloc_array, vmw_surface_calculate_pitch, vmw_surface_get_image_buffer_size, kzalloc, drm_is_primary_client, drm_file_get_master, vmw_surface_init, vmw_user_surface_free, vmw_gem_object_create_with_handle, vmw_resource_unreference, vmw_bo_reference, drm_gem_handle_delete, vmw_resource_reference, ttm_prime_object_init, ttm_prime_object_kfree]\n\n2. 函数名: vmw_priv\n- 参数: [struct drm_device *dev]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n3. 函数名: vmw_fpriv\n- 参数: [struct drm_file *file_priv]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n4. 函数名: vmw_surface_get_desc\n- 参数: [req->format]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n5. 函数名: vmw_surface_calculate_pitch\n- 参数: [desc, cur_size]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n6. 函数名: vmw_surface_get_image_buffer_size\n- 参数: [desc, cur_size, stride]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n7. 函数名: vmw_surface_init\n- 参数: [dev_priv, srf, vmw_user_surface_free]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n8. 函数名: vmw_user_surface_free\n- 参数: N/A\n- 调用者: vmw_surface_init\n- 被调用者: []\n\n9. 函数名: vmw_gem_object_create_with_handle\n- 参数: [dev_priv, file_priv, res->guest_memory_size, &backup_handle, &res->guest_memory_bo]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n10. 函数名: vmw_resource_unreference\n- 参数: [&res], [&tmp]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n11. 函数名: vmw_bo_reference\n- 参数: [res->guest_memory_bo]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n12. 函数名: drm_gem_handle_delete\n- 参数: [file_priv, backup_handle]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n13. 函数名: vmw_resource_reference\n- 参数: [&srf->res]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n14. 函数名: ttm_prime_object_init\n- 参数: [tfile, res->guest_memory_size, &user_srf->prime, req->shareable, VMW_RES_SURFACE, &vmw_user_surface_base_release]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n15. 函数名: ttm_prime_object_kfree\n- 参数: [user_srf, prime]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n16. 函数名: drm_is_primary_client\n- 参数: [file_priv]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n17. 函数名: drm_file_get_master\n- 参数: [file_priv]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []"
    },
    {
        "id": 4294,
        "cwe": "CWE-416",
        "cve": "CVE-2023-6039",
        "purpose": "Code purpose:\"\"\"该代码实现了LAN78XX USB网络设备断开连接时的资源清理和释放功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在lan78xx_disconnect函数中，存在对已释放的net设备中的phydev成员的访问，导致释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: lan78xx_disconnect\n- 参数: [struct usb_interface *intf]\n- 调用者: 无（由USB子系统调用）\n- 被调用者: [usb_get_intfdata, usb_set_intfdata, set_bit, netif_napi_del, interface_to_usbdev, unregister_netdev, cancel_delayed_work_sync, phy_unregister_fixup_for_uid, phy_disconnect, phy_is_pseudo_fixed_link, fixed_phy_unregister, usb_scuttle_anchored_urbs, timer_pending, del_timer_sync, lan78xx_unbind, lan78xx_free_tx_resources, lan78xx_free_rx_resources, usb_kill_urb, usb_free_urb, free_netdev, usb_put_dev]\n\n2. 函数名: usb_get_intfdata\n- 参数: [struct usb_interface *intf]\n- 调用者: lan78xx_disconnect\n- 被调用者: 无\n\n3. 函数名: usb_set_intfdata\n- 参数: [struct usb_interface *intf, NULL]\n- 调用者: lan78xx_disconnect\n- 被调用者: 无\n\n4. 函数名: set_bit\n- 参数: [EVENT_DEV_DISCONNECT, &dev->flags]\n- 调用者: lan78xx_disconnect\n- 被调用者: 无\n\n5. 函数名: netif_napi_del\n- 参数: [&dev->napi]\n- 调用者: lan78xx_disconnect\n- 被调用者: 无\n\n6. 函数名: interface_to_usbdev\n- 参数: [intf]\n- 调用者: lan78xx_disconnect\n- 被调用者: 无\n\n7. 函数名: unregister_netdev\n- 参数: [net]\n- 调用者: lan78xx_disconnect\n- 被调用者: 无\n\n8. 函数名: cancel_delayed_work_sync\n- 参数: [&dev->wq]\n- 调用者: lan78xx_disconnect\n- 被调用者: 无\n\n9. 函数名: phy_unregister_fixup_for_uid\n- 参数: [PHY_KSZ9031RNX, 0xfffffff0]\n- 调用者: lan78xx_disconnect\n- 被调用者: 无\n\n10. 函数名: phy_unregister_fixup_for_uid\n- 参数: [PHY_LAN8835, 0xfffffff0]\n- 调用者: lan78xx_disconnect\n- 被调用者: 无\n\n11. 函数名: phy_disconnect\n- 参数: [net->phydev]\n- 调用者: lan78xx_disconnect\n- 被调用者: 无\n\n12. 函数名: phy_is_pseudo_fixed_link\n- 参数: [phydev]\n- 调用者: lan78xx_disconnect\n- 被调用者: 无\n\n13. 函数名: fixed_phy_unregister\n- 参数: [phydev]\n- 调用者: lan78xx_disconnect\n- 被调用者: 无\n\n14. 函数名: usb_scuttle_anchored_urbs\n- 参数: [&dev->deferred]\n- 调用者: lan78xx_disconnect\n- 被调用者: 无\n\n15. 函数名: timer_pending\n- 参数: [&dev->stat_monitor]\n- 调用者: lan78xx_disconnect\n- 被调用者: 无\n\n16. 函数名: del_timer_sync\n- 参数: [&dev->stat_monitor]\n- 调用者: lan78xx_disconnect\n- 被调用者: 无\n\n17. 函数名: lan78xx_unbind\n- 参数: [dev, intf]\n- 调用者: lan78xx_disconnect\n- 被调用者: 无\n\n18. 函数名: lan78xx_free_tx_resources\n- 参数: [dev]\n- 调用者: lan78xx_disconnect\n- 被调用者: 无\n\n19. 函数名: lan78xx_free_rx_resources\n- 参数: [dev]\n- 调用者: lan78xx_disconnect\n- 被调用者: 无\n\n20. 函数名: usb_kill_urb\n- 参数: [dev->urb_intr]\n- 调用者: lan78xx_disconnect\n- 被调用者: 无\n\n21. 函数名: usb_free_urb\n- 参数: [dev->urb_intr]\n- 调用者: lan78xx_disconnect\n- 被调用者: 无\n\n22. 函数名: free_netdev\n- 参数: [net]\n- 调用者: lan78xx_disconnect\n- 被调用者: 无\n\n23. 函数名: usb_put_dev\n- 参数: [udev]\n- 调用者: lan78xx_disconnect\n- 被调用者: 无"
    },
    {
        "id": 4296,
        "cwe": "CWE-416",
        "cve": "CVE-2023-6111",
        "purpose": "Code purpose:\"\"\"该代码用于处理netfilter中nftables组件的垃圾回收，遍历并清理过期的catchall集合元素\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当sync参数为true时，函数未将catchall集合元素从catchall_list中移除，导致该元素可能被多次释放\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_trans_gc_catchall\n- 参数: [gc, gc_seq, sync]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [nft_set_elem_ext, nft_set_elem_expired, nft_set_elem_is_dead, nft_set_elem_dead, nft_trans_gc_queue_sync, nft_trans_gc_queue_async, nft_trans_gc_elem_add]\n\n2. 函数名: nft_set_elem_ext\n- 参数: [set, catchall->elem]\n- 调用者: nft_trans_gc_catchall\n- 被调用者: []\n\n3. 函数名: nft_set_elem_expired\n- 参数: [ext]\n- 调用者: nft_trans_gc_catchall\n- 被调用者: []\n\n4. 函数名: nft_set_elem_is_dead\n- 参数: [ext]\n- 调用者: nft_trans_gc_catchall\n- 被调用者: []\n\n5. 函数名: nft_set_elem_dead\n- 参数: [ext]\n- 调用者: nft_trans_gc_catchall\n- 被调用者: []\n\n6. 函数名: nft_trans_gc_queue_sync\n- 参数: [gc, GFP_ATOMIC]\n- 调用者: nft_trans_gc_catchall\n- 被调用者: []\n\n7. 函数名: nft_trans_gc_queue_async\n- 参数: [gc, gc_seq, GFP_ATOMIC]\n- 调用者: nft_trans_gc_catchall\n- 被调用者: []\n\n8. 函数名: nft_trans_gc_elem_add\n- 参数: [gc, catchall->elem]\n- 调用者: nft_trans_gc_catchall\n- 被调用者: []"
    },
    {
        "id": 4297,
        "cwe": "CWE-416",
        "cve": "CVE-2023-6111",
        "purpose": "Code purpose:\"\"\"从nft_set的catchall_list中移除指定的elem_priv元素并释放其内存\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当sync参数为true时，nft_trans_gc_catchall函数未能从catchall_list中移除catchall集合元素，导致该元素可能被多次释放\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_setelem_catchall_remove\n- 参数: [net, set, elem_priv]\n- 调用者: 未明确指定（可能是内核中其他处理netfilter/nf_tables的代码）\n- 被调用者: [list_for_each_entry_safe, list_del_rcu, kfree_rcu]\n\n2. 函数名: list_for_each_entry_safe\n- 参数: [catchall, next, &set->catchall_list, list]\n- 调用者: nft_setelem_catchall_remove\n- 被调用者: []\n\n3. 函数名: list_del_rcu\n- 参数: [&catchall->list]\n- 调用者: nft_setelem_catchall_remove\n- 被调用者: []\n\n4. 函数名: kfree_rcu\n- 参数: [catchall, rcu]\n- 调用者: nft_setelem_catchall_remove\n- 被调用者: []"
    },
    {
        "id": 4311,
        "cwe": "CWE-416",
        "cve": "CVE-2023-6932",
        "purpose": "Code purpose:\"\"\"该代码用于为IGMP协议启动一个随机延迟的定时器，并管理相关引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在RCU读锁定对象上错误注册定时器，导致另一个线程释放该对象后发生use-after-free漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: igmp_start_timer\n- 参数: [struct ip_mc_list *im, int max_delay]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [get_random_u32_below, mod_timer, refcount_inc]\n\n2. 函数名: get_random_u32_below\n- 参数: [int max_delay]\n- 调用者: igmp_start_timer\n- 被调用者: []\n\n3. 函数名: mod_timer\n- 参数: [&im->timer, jiffies+tv+2]\n- 调用者: igmp_start_timer\n- 被调用者: []\n\n4. 函数名: refcount_inc\n- 参数: [&im->refcnt]\n- 调用者: igmp_start_timer\n- 被调用者: []"
    },
    {
        "id": 4313,
        "cwe": "CWE-416",
        "cve": "CVE-2024-0193",
        "purpose": "Code purpose:\"\"\"该代码用于在netfilter子系统中提交和处理集合更新列表中的NFT集合更新操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当pipapo集合被移除时，如果catchall元素被垃圾回收，会导致该元素被两次释放，从而引发NFT_CHAIN或NFT_OBJECT对象的释放后使用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_set_commit_update\n- 参数: [struct list_head *set_update_list]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [list_for_each_entry_safe, list_del_init, set->ops->commit]\n\n2. 函数名: list_for_each_entry_safe\n- 参数: [set, next, set_update_list, pending_update]\n- 调用者: nft_set_commit_update\n- 被调用者: []\n\n3. 函数名: list_del_init\n- 参数: [&set->pending_update]\n- 调用者: nft_set_commit_update\n- 被调用者: []\n\n4. 函数名: set->ops->commit\n- 参数: [set]\n- 调用者: nft_set_commit_update\n- 被调用者: []"
    },
    {
        "id": 414,
        "cwe": "CWE-476",
        "cve": "CVE-2013-7339",
        "purpose": "Code purpose:\"\"\"检查给定的IP地址是否可用于RDS的IB传输，并验证设备类型是否为IB设备\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在缺乏RDS传输的系统上，当执行RDS套接字的bind系统调用时，cm_id->device可能为NULL，导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: rds_ib_laddr_check\n- 参数: [__be32 addr]\n- 调用者: 未明确显示（应为RDS socket绑定操作的调用者）\n- 被调用者: [rdma_create_id, memset, rdma_bind_addr, rdsdebug, rdma_destroy_id]\n\n2. 函数名: rdma_create_id\n- 参数: [NULL, NULL, RDMA_PS_TCP, IB_QPT_RC]\n- 调用者: rds_ib_laddr_check\n- 被调用者: []\n\n3. 函数名: memset\n- 参数: [&sin, 0, sizeof(sin)]\n- 调用者: rds_ib_laddr_check\n- 被调用者: []\n\n4. 函数名: rdma_bind_addr\n- 参数: [cm_id, (struct sockaddr *)&sin]\n- 调用者: rds_ib_laddr_check\n- 被调用者: []\n\n5. 函数名: rdsdebug\n- 参数: [\"addr %pI4 ret %d node type %d\\n\", &addr, ret, cm_id->device ? cm_id->device->node_type : -1]\n- 调用者: rds_ib_laddr_check\n- 被调用者: []\n\n6. 函数名: rdma_destroy_id\n- 参数: [cm_id]\n- 调用者: rds_ib_laddr_check\n- 被调用者: []"
    },
    {
        "id": 429,
        "cwe": "CWE-476",
        "cve": "CVE-2014-0101",
        "purpose": "Code purpose:\"\"\"处理SCTP协议中的COOKIE_ECHO块，验证并建立新的关联，包括认证处理和状态转换\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在调用sctp_sf_authenticate之前未验证auth_enable和auth_capable字段，导致攻击者可通过特制的AUTH块引发空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: sctp_sf_do_5_1D_ce\n- 参数: [net, ep, asoc, type, arg, commands]\n- 调用者: 未显示\n- 被调用者: [sctp_sk, SCTP_INC_STATS, sctp_sf_tabort_8_4_8, sctp_chunk_length_valid, sctp_sf_pdiscard, sctp_sstate, sk_acceptq_is_full, pskb_pull, sctp_unpack_cookie, sctp_send_stale_cookie_err, sctp_process_init, sctp_auth_asoc_init_active_key, sctp_sf_authenticate, kfree_skb, sctp_association_free, sctp_make_cookie_ack, sctp_ulpevent_make_assoc_change, sctp_ulpevent_make_adaptation_indication, sctp_add_cmd_sf, SCTP_INC_STATS, sctp_ulpevent_free, sctp_chunk_free, sctp_association_free]\n\n2. 函数名: sctp_sk\n- 参数: [net->sctp.ctl_sock]\n- 调用者: sctp_sf_do_5_1D_ce\n- 被调用者: 未显示\n\n3. 函数名: SCTP_INC_STATS\n- 参数: [net, SCTP_MIB_OUTOFBLUES], [net, SCTP_MIB_CURRESTAB], [net, SCTP_MIB_PASSIVEESTABS]\n- 调用者: sctp_sf_do_5_1D_ce\n- 被调用者: 未显示\n\n4. 函数名: sctp_sf_tabort_8_4_8\n- 参数: [net, ep, asoc, type, arg, commands]\n- 调用者: sctp_sf_do_5_1D_ce\n- 被调用者: 未显示\n\n5. 函数名: sctp_chunk_length_valid\n- 参数: [chunk, sizeof(sctp_chunkhdr_t)]\n- 调用者: sctp_sf_do_5_1D_ce\n- 被调用者: 未显示\n\n6. 函数名: sctp_sf_pdiscard\n- 参数: [net, ep, asoc, type, arg, commands]\n- 调用者: sctp_sf_do_5_1D_ce\n- 被调用者: 未显示\n\n7. 函数名: sctp_sstate\n- 参数: [sk, LISTENING]\n- 调用者: sctp_sf_do_5_1D_ce\n- 被调用者: 未显示\n\n8. 函数名: sk_acceptq_is_full\n- 参数: [sk]\n- 调用者: sctp_sf_do_5_1D_ce\n- 被调用者: 未显示\n\n9. 函数名: pskb_pull\n- 参数: [chunk->skb, ntohs(chunk->chunk_hdr->length) - sizeof(sctp_chunkhdr_t)]\n- 调用者: sctp_sf_do_5_1D_ce\n- 被调用者: 未显示\n\n10. 函数名: sctp_unpack_cookie\n- 参数: [ep, asoc, chunk, GFP_ATOMIC, &error, &err_chk_p]\n- 调用者: sctp_sf_do_5_1D_ce\n- 被调用者: 未显示\n\n11. 函数名: sctp_send_stale_cookie_err\n- 参数: [net, ep, asoc, chunk, commands, err_chk_p]\n- 调用者: sctp_sf_do_5_1D_ce\n- 被调用者: 未显示\n\n12. 函数名: sctp_process_init\n- 参数: [new_asoc, chunk, &chunk->subh.cookie_hdr->c.peer_addr, peer_init, GFP_ATOMIC]\n- 调用者: sctp_sf_do_5_1D_ce\n- 被调用者: 未显示\n\n13. 函数名: sctp_auth_asoc_init_active_key\n- 参数: [new_asoc, GFP_ATOMIC]\n- 调用者: sctp_sf_do_5_1D_ce\n- 被调用者: 未显示\n\n14. 函数名: sctp_sf_authenticate\n- 参数: [net, ep, new_asoc, type, &auth]\n- 调用者: sctp_sf_do_5_1D_ce\n- 被调用者: 未显示\n\n15. 函数名: kfree_skb\n- 参数: [chunk->auth_chunk]\n- 调用者: sctp_sf_do_5_1D_ce\n- 被调用者: 未显示\n\n16. 函数名: sctp_association_free\n- 参数: [new_asoc]\n- 调用者: sctp_sf_do_5_1D_ce\n- 被调用者: 未显示\n\n17. 函数名: sctp_make_cookie_ack\n- 参数: [new_asoc, chunk]\n- 调用者: sctp_sf_do_5_1D_ce\n- 被调用者: 未显示\n\n18. 函数名: sctp_ulpevent_make_assoc_change\n- 参数: [new_asoc, 0, SCTP_COMM_UP, 0, new_asoc->c.sinit_num_ostreams, new_asoc->c.sinit_max_instreams, NULL, GFP_ATOMIC]\n- 调用者: sctp_sf_do_5_1D_ce\n- 被调用者: 未显示\n\n19. 函数名: sctp_ulpevent_make_adaptation_indication\n- 参数: [new_asoc, GFP_ATOMIC]\n- 调用者: sctp_sf_do_5_1D_ce\n- 被调用者: 未显示\n\n20. 函数名: sctp_add_cmd_sf\n- 参数: [commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc)], [commands, SCTP_CMD_NEW_STATE, SCTP_STATE(SCTP_STATE_ESTABLISHED)], [commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL()], [commands, SCTP_CMD_TIMER_START, SCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE)], [commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl)], [commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev)], [commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ai_ev)]\n- 调用者: sctp_sf_do_5_1D_ce\n- 被调用者: 未显示\n\n21. 函数名: sctp_ulpevent_free\n- 参数: [ev]\n- 调用者: sctp_sf_do_5_1D_ce\n- 被调用者: 未显示\n\n22. 函数名: sctp_chunk_free\n- 参数: [repl]\n- 调用者: sctp_sf_do_5_1D_ce\n- 被调用者: 未显示"
    },
    {
        "id": 493,
        "cwe": "CWE-476",
        "cve": "CVE-2014-2678",
        "purpose": "Code purpose:\"\"\"该代码用于检查给定的IP地址是否可用于RDS(Reliable Datagram Sockets)通信，主要验证IB(InfiniBand)和iWARP设备的绑定能力。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在缺乏RDS传输的系统上，当执行RDS套接字的bind系统调用时，代码未检查cm_id->device是否为NULL就直接访问其node_type成员，导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: rds_iw_laddr_check\n- 参数: [__be32 addr]\n- 调用者: 未指定（由系统调用触发）\n- 被调用者: [rdma_create_id, memset, rdma_bind_addr, rdsdebug, rdma_destroy_id]\n\n2. 函数名: rdma_create_id\n- 参数: [NULL, NULL, RDMA_PS_TCP, IB_QPT_RC]\n- 调用者: rds_iw_laddr_check\n- 被调用者: []\n\n3. 函数名: memset\n- 参数: [&sin, 0, sizeof(sin)]\n- 调用者: rds_iw_laddr_check\n- 被调用者: []\n\n4. 函数名: rdma_bind_addr\n- 参数: [cm_id, (struct sockaddr *)&sin]\n- 调用者: rds_iw_laddr_check\n- 被调用者: []\n\n5. 函数名: rdsdebug\n- 参数: [\"addr %pI4 ret %d node type %d\\n\", &addr, ret, cm_id->device ? cm_id->device->node_type : -1]\n- 调用者: rds_iw_laddr_check\n- 被调用者: []\n\n6. 函数名: rdma_destroy_id\n- 参数: [cm_id]\n- 调用者: rds_iw_laddr_check\n- 被调用者: []"
    },
    {
        "id": 593,
        "cwe": "CWE-476",
        "cve": "CVE-2014-7826",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中跟踪系统调用退出事件，记录系统调用编号和返回值到跟踪缓冲区中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核未正确处理私有系统调用号，导致通过特制应用程序可能造成空指针解引用或权限提升\"\"\"",
        "functions": "Functions:\n1. 函数名: ftrace_syscall_exit\n- 参数: [data, regs, ret]\n- 调用者: 未显示\n- 被调用者: [trace_get_syscall_nr, rcu_dereference_sched, ftrace_trigger_soft_disabled, syscall_nr_to_meta, local_save_flags, preempt_count, trace_buffer_lock_reserve, ring_buffer_event_data, syscall_get_return_value, event_trigger_unlock_commit]\n\n2. 函数名: trace_get_syscall_nr\n- 参数: [current, regs]\n- 调用者: ftrace_syscall_exit\n- 被调用者: 未显示\n\n3. 函数名: rcu_dereference_sched\n- 参数: [tr->exit_syscall_files[syscall_nr]]\n- 调用者: ftrace_syscall_exit\n- 被调用者: 未显示\n\n4. 函数名: ftrace_trigger_soft_disabled\n- 参数: [ftrace_file]\n- 调用者: ftrace_syscall_exit\n- 被调用者: 未显示\n\n5. 函数名: syscall_nr_to_meta\n- 参数: [syscall_nr]\n- 调用者: ftrace_syscall_exit\n- 被调用者: 未显示\n\n6. 函数名: local_save_flags\n- 参数: [irq_flags]\n- 调用者: ftrace_syscall_exit\n- 被调用者: 未显示\n\n7. 函数名: preempt_count\n- 参数: []\n- 调用者: ftrace_syscall_exit\n- 被调用者: 未显示\n\n8. 函数名: trace_buffer_lock_reserve\n- 参数: [buffer, sys_data->exit_event->event.type, sizeof(*entry), irq_flags, pc]\n- 调用者: ftrace_syscall_exit\n- 被调用者: 未显示\n\n9. 函数名: ring_buffer_event_data\n- 参数: [event]\n- 调用者: ftrace_syscall_exit\n- 被调用者: 未显示\n\n10. 函数名: syscall_get_return_value\n- 参数: [current, regs]\n- 调用者: ftrace_syscall_exit\n- 被调用者: 未显示\n\n11. 函数名: event_trigger_unlock_commit\n- 参数: [ftrace_file, buffer, event, entry, irq_flags, pc]\n- 调用者: ftrace_syscall_exit\n- 被调用者: 未显示"
    },
    {
        "id": 594,
        "cwe": "CWE-476",
        "cve": "CVE-2014-7826",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中跟踪系统调用退出事件，并将相关信息提交给性能分析子系统。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核未正确处理私有系统调用号，导致在ftrace子系统中可能引发无效指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: perf_syscall_exit\n- 参数: [ignore, regs, ret]\n- 调用者: N/A\n- 被调用者: [trace_get_syscall_nr, test_bit, syscall_nr_to_meta, this_cpu_ptr, hlist_empty, ALIGN, perf_trace_buf_prepare, syscall_get_return_value, perf_trace_buf_submit]\n\n2. 函数名: trace_get_syscall_nr\n- 参数: [current, regs]\n- 调用者: perf_syscall_exit\n- 被调用者: N/A\n\n3. 函数名: test_bit\n- 参数: [syscall_nr, enabled_perf_exit_syscalls]\n- 调用者: perf_syscall_exit\n- 被调用者: N/A\n\n4. 函数名: syscall_nr_to_meta\n- 参数: [syscall_nr]\n- 调用者: perf_syscall_exit\n- 被调用者: N/A\n\n5. 函数名: this_cpu_ptr\n- 参数: [sys_data->exit_event->perf_events]\n- 调用者: perf_syscall_exit\n- 被调用者: N/A\n\n6. 函数名: hlist_empty\n- 参数: [head]\n- 调用者: perf_syscall_exit\n- 被调用者: N/A\n\n7. 函数名: ALIGN\n- 参数: [sizeof(*rec) + sizeof(u32), sizeof(u64)]\n- 调用者: perf_syscall_exit\n- 被调用者: N/A\n\n8. 函数名: perf_trace_buf_prepare\n- 参数: [size, sys_data->exit_event->event.type, regs, &rctx]\n- 调用者: perf_syscall_exit\n- 被调用者: N/A\n\n9. 函数名: syscall_get_return_value\n- 参数: [current, regs]\n- 调用者: perf_syscall_exit\n- 被调用者: N/A\n\n10. 函数名: perf_trace_buf_submit\n- 参数: [rec, size, rctx, 0, 1, regs, head, NULL]\n- 调用者: perf_syscall_exit\n- 被调用者: N/A"
    },
    {
        "id": 595,
        "cwe": "CWE-476",
        "cve": "CVE-2014-7826",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中跟踪系统调用进入事件，记录系统调用编号和参数到跟踪缓冲区中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核未正确处理私有系统调用号，导致通过特制应用程序可能造成空指针解引用或权限提升\"\"\"",
        "functions": "Functions:\n1. 函数名: ftrace_syscall_enter\n- 参数: [data, regs, id]\n- 调用者: 未显示\n- 被调用者: [trace_get_syscall_nr, rcu_dereference_sched, ftrace_trigger_soft_disabled, syscall_nr_to_meta, local_save_flags, preempt_count, trace_buffer_lock_reserve, ring_buffer_event_data, syscall_get_arguments, event_trigger_unlock_commit]\n\n2. 函数名: trace_get_syscall_nr\n- 参数: [current, regs]\n- 调用者: ftrace_syscall_enter\n- 被调用者: 未显示\n\n3. 函数名: rcu_dereference_sched\n- 参数: [tr->enter_syscall_files[syscall_nr]]\n- 调用者: ftrace_syscall_enter\n- 被调用者: 未显示\n\n4. 函数名: ftrace_trigger_soft_disabled\n- 参数: [ftrace_file]\n- 调用者: ftrace_syscall_enter\n- 被调用者: 未显示\n\n5. 函数名: syscall_nr_to_meta\n- 参数: [syscall_nr]\n- 调用者: ftrace_syscall_enter\n- 被调用者: 未显示\n\n6. 函数名: local_save_flags\n- 参数: [irq_flags]\n- 调用者: ftrace_syscall_enter\n- 被调用者: 未显示\n\n7. 函数名: preempt_count\n- 参数: []\n- 调用者: ftrace_syscall_enter\n- 被调用者: 未显示\n\n8. 函数名: trace_buffer_lock_reserve\n- 参数: [buffer, sys_data->enter_event->event.type, size, irq_flags, pc]\n- 调用者: ftrace_syscall_enter\n- 被调用者: 未显示\n\n9. 函数名: ring_buffer_event_data\n- 参数: [event]\n- 调用者: ftrace_syscall_enter\n- 被调用者: 未显示\n\n10. 函数名: syscall_get_arguments\n- 参数: [current, regs, 0, sys_data->nb_args, entry->args]\n- 调用者: ftrace_syscall_enter\n- 被调用者: 未显示\n\n11. 函数名: event_trigger_unlock_commit\n- 参数: [ftrace_file, buffer, event, entry, irq_flags, pc]\n- 调用者: ftrace_syscall_enter\n- 被调用者: 未显示"
    },
    {
        "id": 596,
        "cwe": "CWE-476",
        "cve": "CVE-2014-7826",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中跟踪系统调用进入事件，收集系统调用参数并通过perf子系统提交跟踪数据\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核未正确处理私有系统调用号，导致在ftrace子系统中可能发生无效指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: perf_syscall_enter\n- 参数: [ignore, regs, id]\n- 调用者: 未显示（由系统调用触发）\n- 被调用者: [trace_get_syscall_nr, test_bit, syscall_nr_to_meta, this_cpu_ptr, hlist_empty, ALIGN, perf_trace_buf_prepare, syscall_get_arguments, perf_trace_buf_submit]\n\n2. 函数名: trace_get_syscall_nr\n- 参数: [current, regs]\n- 调用者: perf_syscall_enter\n- 被调用者: []\n\n3. 函数名: test_bit\n- 参数: [syscall_nr, enabled_perf_enter_syscalls]\n- 调用者: perf_syscall_enter\n- 被调用者: []\n\n4. 函数名: syscall_nr_to_meta\n- 参数: [syscall_nr]\n- 调用者: perf_syscall_enter\n- 被调用者: []\n\n5. 函数名: this_cpu_ptr\n- 参数: [sys_data->enter_event->perf_events]\n- 调用者: perf_syscall_enter\n- 被调用者: []\n\n6. 函数名: hlist_empty\n- 参数: [head]\n- 调用者: perf_syscall_enter\n- 被调用者: []\n\n7. 函数名: ALIGN\n- 参数: [size + sizeof(u32), sizeof(u64)]\n- 调用者: perf_syscall_enter\n- 被调用者: []\n\n8. 函数名: perf_trace_buf_prepare\n- 参数: [size, sys_data->enter_event->event.type, regs, &rctx]\n- 调用者: perf_syscall_enter\n- 被调用者: []\n\n9. 函数名: syscall_get_arguments\n- 参数: [current, regs, 0, sys_data->nb_args, (unsigned long *)&rec->args]\n- 调用者: perf_syscall_enter\n- 被调用者: []\n\n10. 函数名: perf_trace_buf_submit\n- 参数: [rec, size, rctx, 0, 1, regs, head, NULL]\n- 调用者: perf_syscall_enter\n- 被调用者: []"
    },
    {
        "id": 785,
        "cwe": "CWE-476",
        "cve": "CVE-2015-7515",
        "purpose": "Code purpose:\"\"\"该代码用于探测并初始化Aiptek USB绘图板设备，设置输入设备参数并注册到系统中，处理USB通信和数据传输。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当USB设备缺少端点描述符时，代码未进行空指针检查直接访问endpoint->bEndpointAddress，导致空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: aiptek_probe\n- 参数: [struct usb_interface *intf, const struct usb_device_id *id]\n- 调用者: USB core subsystem\n- 被调用者: [interface_to_usbdev, kzalloc, input_allocate_device, usb_alloc_coherent, usb_alloc_urb, usb_make_path, strlcat, usb_to_input_id, input_set_drvdata, __set_bit, input_set_abs_params, usb_fill_int_urb, aiptek_program_tablet, input_abs_get_max, usb_set_intfdata, sysfs_create_group, input_register_device, sysfs_remove_group, usb_free_urb, usb_free_coherent, input_free_device, kfree]\n\n2. 函数名: interface_to_usbdev\n- 参数: [struct usb_interface *intf]\n- 调用者: aiptek_probe\n- 被调用者: []\n\n3. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: aiptek_probe\n- 被调用者: []\n\n4. 函数名: input_allocate_device\n- 参数: []\n- 调用者: aiptek_probe\n- 被调用者: []\n\n5. 函数名: usb_alloc_coherent\n- 参数: [struct usb_device *dev, size_t size, gfp_t mem_flags, dma_addr_t *dma]\n- 调用者: aiptek_probe\n- 被调用者: []\n\n6. 函数名: usb_alloc_urb\n- 参数: [int iso_packets, gfp_t mem_flags]\n- 调用者: aiptek_probe\n- 被调用者: []\n\n7. 函数名: usb_make_path\n- 参数: [struct usb_device *dev, char *buf, size_t size]\n- 调用者: aiptek_probe\n- 被调用者: []\n\n8. 函数名: strlcat\n- 参数: [char *dest, const char *src, size_t count]\n- 调用者: aiptek_probe\n- 被调用者: []\n\n9. 函数名: usb_to_input_id\n- 参数: [struct usb_device *dev, struct input_id *id]\n- 调用者: aiptek_probe\n- 被调用者: []\n\n10. 函数名: input_set_drvdata\n- 参数: [struct input_dev *dev, void *data]\n- 调用者: aiptek_probe\n- 被调用者: []\n\n11. 函数名: __set_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: aiptek_probe\n- 被调用者: []\n\n12. 函数名: input_set_abs_params\n- 参数: [struct input_dev *dev, unsigned int axis, int min, int max, int fuzz, int flat]\n- 调用者: aiptek_probe\n- 被调用者: []\n\n13. 函数名: usb_fill_int_urb\n- 参数: [struct urb *urb, struct usb_device *dev, unsigned int pipe, void *transfer_buffer, int buffer_length, usb_complete_t complete_fn, void *context, int interval]\n- 调用者: aiptek_probe\n- 被调用者: []\n\n14. 函数名: aiptek_program_tablet\n- 参数: [struct aiptek *aiptek]\n- 调用者: aiptek_probe\n- 被调用者: []\n\n15. 函数名: input_abs_get_max\n- 参数: [struct input_dev *dev, unsigned int axis]\n- 调用者: aiptek_probe\n- 被调用者: []\n\n16. 函数名: usb_set_intfdata\n- 参数: [struct usb_interface *intf, void *data]\n- 调用者: aiptek_probe\n- 被调用者: []\n\n17. 函数名: sysfs_create_group\n- 参数: [struct kobject *kobj, const struct attribute_group *grp]\n- 调用者: aiptek_probe\n- 被调用者: []\n\n18. 函数名: input_register_device\n- 参数: [struct input_dev *dev]\n- 调用者: aiptek_probe\n- 被调用者: []\n\n19. 函数名: sysfs_remove_group\n- 参数: [struct kobject *kobj, const struct attribute_group *grp]\n- 调用者: aiptek_probe\n- 被调用者: []\n\n20. 函数名: usb_free_urb\n- 参数: [struct urb *urb]\n- 调用者: aiptek_probe\n- 被调用者: []\n\n21. 函数名: usb_free_coherent\n- 参数: [struct usb_device *dev, size_t size, void *addr, dma_addr_t dma]\n- 调用者: aiptek_probe\n- 被调用者: []\n\n22. 函数名: input_free_device\n- 参数: [struct input_dev *dev]\n- 调用者: aiptek_probe\n- 被调用者: []\n\n23. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: aiptek_probe\n- 被调用者: []"
    },
    {
        "id": 829,
        "cwe": "CWE-476",
        "cve": "CVE-2015-8551",
        "purpose": "Code purpose:\"\"\"该代码用于在Xen PCI后端驱动中启用MSI中断，并将中断向量信息返回给客户机，但缺少对空指针的健全性检查\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未对dev->irq进行空指针检查就直接调用xen_pirq_from_irq函数，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: xen_pcibk_enable_msi\n- 参数: [struct xen_pcibk_device *pdev, struct pci_dev *dev, struct xen_pci_op *op]\n- 调用者: 未明确（由Xen PCI backend驱动调用）\n- 被调用者: [printk, pci_enable_msi, pr_warn_ratelimited, pci_name, xen_pirq_from_irq, pci_get_drvdata]\n\n2. 函数名: printk\n- 参数: [KERN_DEBUG DRV_NAME \": %s: enable MSI\\n\", pci_name(dev)]\n- 调用者: xen_pcibk_enable_msi\n- 被调用者: []\n\n3. 函数名: pci_enable_msi\n- 参数: [struct pci_dev *dev]\n- 调用者: xen_pcibk_enable_msi\n- 被调用者: []\n\n4. 函数名: pr_warn_ratelimited\n- 参数: [\"%s: error enabling MSI for guest %u: err %d\\n\", pci_name(dev), pdev->xdev->otherend_id, status]\n- 调用者: xen_pcibk_enable_msi\n- 被调用者: []\n\n5. 函数名: pci_name\n- 参数: [struct pci_dev *dev]\n- 调用者: xen_pcibk_enable_msi\n- 被调用者: []\n\n6. 函数名: xen_pirq_from_irq\n- 参数: [dev->irq]\n- 调用者: xen_pcibk_enable_msi\n- 被调用者: []\n\n7. 函数名: pci_get_drvdata\n- 参数: [struct pci_dev *dev]\n- 调用者: xen_pcibk_enable_msi\n- 被调用者: []"
    },
    {
        "id": 845,
        "cwe": "CWE-476",
        "cve": "CVE-2015-8787",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理IPv4数据包的重定向，将特定条件下的数据包目标地址修改为本地回环地址或接口本地地址。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当传入的数据包指向未完全配置的网络接口时，代码未正确检查ifa_list是否为空，导致NULL指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: nf_nat_redirect_ipv4\n- 参数: [struct sk_buff *skb, const struct nf_nat_ipv4_multi_range_compat *mr, unsigned int hooknum]\n- 调用者: 未明确（由内核网络子系统调用）\n- 被调用者: [nf_ct_get, htonl, __in_dev_get_rcu, rcu_read_lock, rcu_read_unlock, memset, nf_nat_setup_info]\n\n2. 函数名: nf_ct_get\n- 参数: [struct sk_buff *skb, enum ip_conntrack_info *ctinfo]\n- 调用者: nf_nat_redirect_ipv4\n- 被调用者: []\n\n3. 函数名: htonl\n- 参数: [uint32_t hostlong]\n- 调用者: nf_nat_redirect_ipv4\n- 被调用者: []\n\n4. 函数名: __in_dev_get_rcu\n- 参数: [const struct net_device *dev]\n- 调用者: nf_nat_redirect_ipv4\n- 被调用者: []\n\n5. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: nf_nat_redirect_ipv4\n- 被调用者: []\n\n6. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: nf_nat_redirect_ipv4\n- 被调用者: []\n\n7. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: nf_nat_redirect_ipv4\n- 被调用者: []\n\n8. 函数名: nf_nat_setup_info\n- 参数: [struct nf_conn *ct, const struct nf_nat_range *range, enum nf_nat_manip_type maniptype]\n- 调用者: nf_nat_redirect_ipv4\n- 被调用者: []"
    },
    {
        "id": 868,
        "cwe": "CWE-476",
        "cve": "CVE-2015-8956",
        "purpose": "Code purpose:\"\"\"实现蓝牙RFCOMM套接字的绑定功能，包括地址验证、状态检查和通道分配\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在蓝牙RFCOMM套接字绑定操作中，未对sa指针进行空指针检查，可能导致空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: rfcomm_sock_bind\n- 参数: [sock, addr, addr_len]\n- 调用者: 系统调用bind\n- 被调用者: [lock_sock, write_lock, __rfcomm_get_listen_sock_by_addr, bacpy, write_unlock, release_sock]\n\n2. 函数名: lock_sock\n- 参数: [sk]\n- 调用者: rfcomm_sock_bind\n- 被调用者: []\n\n3. 函数名: write_lock\n- 参数: [&rfcomm_sk_list.lock]\n- 调用者: rfcomm_sock_bind\n- 被调用者: []\n\n4. 函数名: __rfcomm_get_listen_sock_by_addr\n- 参数: [chan, &sa->rc_bdaddr]\n- 调用者: rfcomm_sock_bind\n- 被调用者: []\n\n5. 函数名: bacpy\n- 参数: [&rfcomm_pi(sk)->src, &sa->rc_bdaddr]\n- 调用者: rfcomm_sock_bind\n- 被调用者: []\n\n6. 函数名: write_unlock\n- 参数: [&rfcomm_sk_list.lock]\n- 调用者: rfcomm_sock_bind\n- 被调用者: []\n\n7. 函数名: release_sock\n- 参数: [sk]\n- 调用者: rfcomm_sock_bind\n- 被调用者: []"
    },
    {
        "id": 876,
        "cwe": "CWE-476",
        "cve": "CVE-2015-8970",
        "purpose": "Code purpose:\"\"\"该代码用于在AF_ALG套接字上初始化并设置对称加密算法的上下文，但不验证是否已执行setkey操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在AF_ALG套接字处理accept系统调用前未验证是否已执行setkey操作，导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: skcipher_accept_parent\n- 参数: [private, sk]\n- 调用者: 不适用（顶层函数）\n- 被调用者: [alg_sk, sock_kmalloc, crypto_skcipher_reqsize, crypto_skcipher_ivsize, sock_kfree_s, memset, INIT_LIST_HEAD, atomic_set, af_alg_init_completion, skcipher_request_set_tfm, skcipher_request_set_callback]\n\n2. 函数名: alg_sk\n- 参数: [sk]\n- 调用者: skcipher_accept_parent\n- 被调用者: []\n\n3. 函数名: sock_kmalloc\n- 参数: [sk, len, GFP_KERNEL]\n- 调用者: skcipher_accept_parent\n- 被调用者: []\n\n4. 函数名: crypto_skcipher_reqsize\n- 参数: [private]\n- 调用者: skcipher_accept_parent\n- 被调用者: []\n\n5. 函数名: crypto_skcipher_ivsize\n- 参数: [private]\n- 调用者: skcipher_accept_parent\n- 被调用者: []\n\n6. 函数名: sock_kfree_s\n- 参数: [sk, ctx, len]\n- 调用者: skcipher_accept_parent\n- 被调用者: []\n\n7. 函数名: memset\n- 参数: [ctx->iv, 0, crypto_skcipher_ivsize(private)]\n- 调用者: skcipher_accept_parent\n- 被调用者: []\n\n8. 函数名: INIT_LIST_HEAD\n- 参数: [&ctx->tsgl]\n- 调用者: skcipher_accept_parent\n- 被调用者: []\n\n9. 函数名: atomic_set\n- 参数: [&ctx->inflight, 0]\n- 调用者: skcipher_accept_parent\n- 被调用者: []\n\n10. 函数名: af_alg_init_completion\n- 参数: [&ctx->completion]\n- 调用者: skcipher_accept_parent\n- 被调用者: []\n\n11. 函数名: skcipher_request_set_tfm\n- 参数: [&ctx->req, private]\n- 调用者: skcipher_accept_parent\n- 被调用者: []\n\n12. 函数名: skcipher_request_set_callback\n- 参数: [&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG, af_alg_complete, &ctx->completion]\n- 调用者: skcipher_accept_parent\n- 被调用者: []"
    },
    {
        "id": 877,
        "cwe": "CWE-476",
        "cve": "CVE-2015-8970",
        "purpose": "Code purpose:\"\"\"释放对称密钥加密算法的私有数据结构\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未在accept系统调用处理前验证AF_ALG套接字是否执行了setkey操作，导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: skcipher_release\n- 参数: [private]\n- 调用者: 未明确（通常由AF_ALG套接字相关代码调用）\n- 被调用者: [crypto_free_skcipher]\n\n2. 函数名: crypto_free_skcipher\n- 参数: [private]\n- 调用者: [skcipher_release]\n- 被调用者: 未明确（内核内部函数）"
    },
    {
        "id": 878,
        "cwe": "CWE-476",
        "cve": "CVE-2015-8970",
        "purpose": "Code purpose:\"\"\"该代码片段实现了设置对称密钥的功能，将密钥传递给底层加密算法\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未在accept系统调用处理前验证AF_ALG套接字是否执行了setkey操作，导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: skcipher_setkey\n- 参数: [private, key, keylen]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [crypto_skcipher_setkey]\n\n2. 函数名: crypto_skcipher_setkey\n- 参数: [private, key, keylen]（通过skcipher_setkey传递）\n- 调用者: [skcipher_setkey]\n- 被调用者: 未明确（可能是底层加密API）"
    },
    {
        "id": 879,
        "cwe": "CWE-476",
        "cve": "CVE-2015-8970",
        "purpose": "Code purpose:\"\"\"该代码片段实现了一个用于分配对称密钥加密算法实例的函数，通过给定的名称、类型和掩码参数来创建并返回一个skcipher加密算法实例。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在AF_ALG套接字上未验证setkey操作是否执行就处理accept系统调用，导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: skcipher_bind\n- 参数: [name, type, mask]\n- 调用者: 未提供（上下文不足）\n- 被调用者: [crypto_alloc_skcipher]\n\n2. 函数名: crypto_alloc_skcipher\n- 参数: [name, type, mask]\n- 调用者: [skcipher_bind]\n- 被调用者: 未提供（上下文不足）"
    },
    {
        "id": 895,
        "cwe": "CWE-476",
        "cve": "CVE-2016-10147",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中创建和管理mcryptd哈希算法实例，支持异步加密操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当使用AF_ALG套接字与不兼容的算法(如mcryptd(md5))时，会导致空指针解引用，因为代码未正确处理算法不兼容的情况。\"\"\"",
        "functions": "Functions:\n1. 函数名: mcryptd_create_hash\n- 参数: [struct crypto_template *tmpl, struct rtattr **tb, struct mcryptd_queue *queue]\n- 调用者: N/A\n- 被调用者: [mcryptd_check_internal, ahash_attr_alg, PTR_ERR, IS_ERR, mcryptd_alloc_instance, ahash_instance_ctx, crypto_init_ahash_spawn, ahash_crypto_instance, ahash_register_instance, crypto_drop_ahash, kfree, crypto_mod_put]\n\n2. 函数名: mcryptd_check_internal\n- 参数: [struct rtattr **tb, u32 *type, u32 *mask]\n- 调用者: mcryptd_create_hash\n- 被调用者: N/A\n\n3. 函数名: ahash_attr_alg\n- 参数: [struct rtattr *tb, u32 type, u32 mask]\n- 调用者: mcryptd_create_hash\n- 被调用者: N/A\n\n4. 函数名: mcryptd_alloc_instance\n- 参数: [struct crypto_alg *alg, unsigned int headroom, unsigned int inst_size]\n- 调用者: mcryptd_create_hash\n- 被调用者: N/A\n\n5. 函数名: ahash_instance_ctx\n- 参数: [struct ahash_instance *inst]\n- 调用者: mcryptd_create_hash\n- 被调用者: N/A\n\n6. 函数名: crypto_init_ahash_spawn\n- 参数: [struct crypto_ahash_spawn *spawn, struct hash_alg_common *alg, struct crypto_instance *inst]\n- 调用者: mcryptd_create_hash\n- 被调用者: N/A\n\n7. 函数名: ahash_crypto_instance\n- 参数: [struct ahash_instance *inst]\n- 调用者: mcryptd_create_hash\n- 被调用者: N/A\n\n8. 函数名: ahash_register_instance\n- 参数: [struct crypto_template *tmpl, struct ahash_instance *inst]\n- 调用者: mcryptd_create_hash\n- 被调用者: N/A\n\n9. 函数名: crypto_drop_ahash\n- 参数: [struct crypto_ahash_spawn *spawn]\n- 调用者: mcryptd_create_hash\n- 被调用者: N/A\n\n10. 函数名: crypto_mod_put\n- 参数: [struct crypto_alg *alg]\n- 调用者: mcryptd_create_hash\n- 被调用者: N/A"
    },
    {
        "id": 896,
        "cwe": "CWE-476",
        "cve": "CVE-2016-10147",
        "purpose": "Code purpose:\"\"\"检查并设置加密算法的内部类型和掩码标志\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在检查算法类型和掩码时未验证指针是否为空，导致当使用不兼容算法时可能引发空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: mcryptd_check_internal\n- 参数: [struct rtattr **tb, u32 *type, u32 *mask]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [crypto_get_attr_type, IS_ERR]\n\n2. 函数名: crypto_get_attr_type\n- 参数: [struct rtattr **tb]\n- 调用者: mcryptd_check_internal\n- 被调用者: 未明确（由内核提供）\n\n3. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: mcryptd_check_internal\n- 被调用者: 未明确（由内核提供）"
    },
    {
        "id": 955,
        "cwe": "CWE-476",
        "cve": "CVE-2016-2782",
        "purpose": "Code purpose:\"\"\"该代码用于处理特定USB设备（Handspring和Kyocera设备）的端点交换，以实现正确的通信配置。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在拷贝端口数据时未检查中断端点urb指针是否为空，导致插入缺少批量输入或中断输入端点的USB设备时可能引发空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: treo_attach\n- 参数: [struct usb_serial *serial]\n- 调用者: 未明确显示（通常由USB子系统调用）\n- 被调用者: [le16_to_cpu, kmalloc, kfree]\n\n2. 函数名: le16_to_cpu\n- 参数: [uint16_t]\n- 调用者: treo_attach\n- 被调用者: []\n\n3. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: treo_attach\n- 被调用者: []\n\n4. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: treo_attach\n- 被调用者: []"
    },
    {
        "id": 960,
        "cwe": "CWE-476",
        "cve": "CVE-2016-3070",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中实现页面迁移功能，包括处理页面映射的转移、引用计数管理和内存区域状态更新等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在页面迁移过程中，由于未正确处理映射为NULL的情况，导致可能发生空指针解引用，造成系统崩溃或其他未指定的影响。\"\"\"",
        "functions": "Functions:\n1. 函数名: migrate_page_move_mapping\n- 参数: [struct address_space *mapping, struct page *newpage, struct page *page, struct buffer_head *head, enum migrate_mode mode, int extra_count]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [page_count, set_page_memcg, PageSwapBacked, SetPageSwapBacked, spin_lock_irq, radix_tree_lookup_slot, page_index, page_has_private, radix_tree_deref_slot_protected, spin_unlock_irq, page_freeze_refs, buffer_migrate_lock_buffers, page_unfreeze_refs, get_page, PageSwapCache, SetPageSwapCache, set_page_private, page_private, radix_tree_replace_slot, __dec_zone_page_state, __inc_zone_page_state]\n\n2. 函数名: page_count\n- 参数: [struct page *page]\n- 调用者: migrate_page_move_mapping\n- 被调用者: []\n\n3. 函数名: set_page_memcg\n- 参数: [struct page *page, struct mem_cgroup *memcg]\n- 调用者: migrate_page_move_mapping\n- 被调用者: []\n\n4. 函数名: PageSwapBacked\n- 参数: [struct page *page]\n- 调用者: migrate_page_move_mapping\n- 被调用者: []\n\n5. 函数名: SetPageSwapBacked\n- 参数: [struct page *page]\n- 调用者: migrate_page_move_mapping\n- 被调用者: []\n\n6. 函数名: spin_lock_irq\n- 参数: [spinlock_t *lock]\n- 调用者: migrate_page_move_mapping\n- 被调用者: []\n\n7. 函数名: radix_tree_lookup_slot\n- 参数: [struct radix_tree_root *root, unsigned long index]\n- 调用者: migrate_page_move_mapping\n- 被调用者: []\n\n8. 函数名: page_index\n- 参数: [struct page *page]\n- 调用者: migrate_page_move_mapping\n- 被调用者: []\n\n9. 函数名: page_has_private\n- 参数: [struct page *page]\n- 调用者: migrate_page_move_mapping\n- 被调用者: []\n\n10. 函数名: radix_tree_deref_slot_protected\n- 参数: [void **slot, spinlock_t *lock]\n- 调用者: migrate_page_move_mapping\n- 被调用者: []\n\n11. 函数名: spin_unlock_irq\n- 参数: [spinlock_t *lock]\n- 调用者: migrate_page_move_mapping\n- 被调用者: []\n\n12. 函数名: page_freeze_refs\n- 参数: [struct page *page, int count]\n- 调用者: migrate_page_move_mapping\n- 被调用者: []\n\n13. 函数名: buffer_migrate_lock_buffers\n- 参数: [struct buffer_head *head, enum migrate_mode mode]\n- 调用者: migrate_page_move_mapping\n- 被调用者: []\n\n14. 函数名: page_unfreeze_refs\n- 参数: [struct page *page, int count]\n- 调用者: migrate_page_move_mapping\n- 被调用者: []\n\n15. 函数名: get_page\n- 参数: [struct page *page]\n- 调用者: migrate_page_move_mapping\n- 被调用者: []\n\n16. 函数名: PageSwapCache\n- 参数: [struct page *page]\n- 调用者: migrate_page_move_mapping\n- 被调用者: []\n\n17. 函数名: SetPageSwapCache\n- 参数: [struct page *page]\n- 调用者: migrate_page_move_mapping\n- 被调用者: []\n\n18. 函数名: set_page_private\n- 参数: [struct page *page, unsigned long private]\n- 调用者: migrate_page_move_mapping\n- 被调用者: []\n\n19. 函数名: page_private\n- 参数: [struct page *page]\n- 调用者: migrate_page_move_mapping\n- 被调用者: []\n\n20. 函数名: radix_tree_replace_slot\n- 参数: [void **slot, void *item]\n- 调用者: migrate_page_move_mapping\n- 被调用者: []\n\n21. 函数名: __dec_zone_page_state\n- 参数: [struct page *page, enum zone_stat_item item]\n- 调用者: migrate_page_move_mapping\n- 被调用者: []\n\n22. 函数名: __inc_zone_page_state\n- 参数: [struct page *page, enum zone_stat_item item]\n- 调用者: migrate_page_move_mapping\n- 被调用者: []"
    },
    {
        "id": 961,
        "cwe": "CWE-476",
        "cve": "CVE-2016-3070",
        "purpose": "Code purpose:\"\"\"将源页面的内容和状态完整地迁移复制到目标页面\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在页面迁移过程中未正确处理脏页的回写跟踪，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: migrate_page_copy\n- 参数: [struct page *newpage, struct page *page]\n- 调用者: 未指定\n- 被调用者: [copy_huge_page, copy_highpage, SetPageError, SetPageReferenced, SetPageUptodate, TestClearPageActive, TestClearPageUnevictable, SetPageActive, SetPageUnevictable, SetPageChecked, SetPageMappedToDisk, clear_page_dirty_for_io, SetPageDirty, __set_page_dirty_nobuffers, page_is_young, set_page_young, page_is_idle, set_page_idle, page_cpupid_xchg_last, ksm_migrate_page, ClearPageSwapCache, ClearPagePrivate, set_page_private, PageWriteback, end_page_writeback]\n\n2. 函数名: copy_huge_page\n- 参数: [struct page *newpage, struct page *page]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n3. 函数名: copy_highpage\n- 参数: [struct page *newpage, struct page *page]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n4. 函数名: SetPageError\n- 参数: [struct page *newpage]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n5. 函数名: SetPageReferenced\n- 参数: [struct page *newpage]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n6. 函数名: SetPageUptodate\n- 参数: [struct page *newpage]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n7. 函数名: TestClearPageActive\n- 参数: [struct page *page]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n8. 函数名: TestClearPageUnevictable\n- 参数: [struct page *page]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n9. 函数名: SetPageActive\n- 参数: [struct page *newpage]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n10. 函数名: SetPageUnevictable\n- 参数: [struct page *newpage]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n11. 函数名: SetPageChecked\n- 参数: [struct page *newpage]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n12. 函数名: SetPageMappedToDisk\n- 参数: [struct page *newpage]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n13. 函数名: clear_page_dirty_for_io\n- 参数: [struct page *page]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n14. 函数名: SetPageDirty\n- 参数: [struct page *newpage]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n15. 函数名: __set_page_dirty_nobuffers\n- 参数: [struct page *newpage]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n16. 函数名: page_is_young\n- 参数: [struct page *page]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n17. 函数名: set_page_young\n- 参数: [struct page *newpage]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n18. 函数名: page_is_idle\n- 参数: [struct page *page]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n19. 函数名: set_page_idle\n- 参数: [struct page *newpage]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n20. 函数名: page_cpupid_xchg_last\n- 参数: [struct page *page, int cpupid]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n21. 函数名: ksm_migrate_page\n- 参数: [struct page *newpage, struct page *page]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n22. 函数名: ClearPageSwapCache\n- 参数: [struct page *page]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n23. 函数名: ClearPagePrivate\n- 参数: [struct page *page]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n24. 函数名: set_page_private\n- 参数: [struct page *page, unsigned long private]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n25. 函数名: PageWriteback\n- 参数: [struct page *newpage]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定\n\n26. 函数名: end_page_writeback\n- 参数: [struct page *newpage]\n- 调用者: migrate_page_copy\n- 被调用者: 未指定"
    },
    {
        "id": 1075,
        "cwe": "CWE-476",
        "cve": "CVE-2016-6327",
        "purpose": "Code purpose:\"\"\"处理SRP（SCSI RDMA Protocol）任务管理请求，包括中止任务等操作，并与目标子系统交互完成相应功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理ABORT_TASK命令时，代码未充分验证srp_tsk->task_tag的有效性，可能导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: srpt_handle_tsk_mgmt\n- 参数: [struct srpt_rdma_ch *ch, struct srpt_recv_ioctx *recv_ioctx, struct srpt_send_ioctx *send_ioctx]\n- 调用者: 未显示\n- 被调用者: [pr_debug, srpt_set_cmd_state, srp_tmr_to_tcm, srpt_unpack_lun, srpt_rx_mgmt_fn_tag, target_submit_tmr, transport_send_check_condition_and_sense]\n\n2. 函数名: pr_debug\n- 参数: [格式化字符串, 多个参数]\n- 调用者: srpt_handle_tsk_mgmt\n- 被调用者: []\n\n3. 函数名: srpt_set_cmd_state\n- 参数: [struct srpt_send_ioctx *send_ioctx, SRPT_STATE_MGMT]\n- 调用者: srpt_handle_tsk_mgmt\n- 被调用者: []\n\n4. 函数名: srp_tmr_to_tcm\n- 参数: [srp_tsk->tsk_mgmt_func]\n- 调用者: srpt_handle_tsk_mgmt\n- 被调用者: []\n\n5. 函数名: srpt_unpack_lun\n- 参数: [(uint8_t *)&srp_tsk->lun, sizeof(srp_tsk->lun)]\n- 调用者: srpt_handle_tsk_mgmt\n- 被调用者: []\n\n6. 函数名: srpt_rx_mgmt_fn_tag\n- 参数: [struct srpt_send_ioctx *send_ioctx, srp_tsk->task_tag]\n- 调用者: srpt_handle_tsk_mgmt\n- 被调用者: []\n\n7. 函数名: target_submit_tmr\n- 参数: [&send_ioctx->cmd, sess, NULL, unpacked_lun, srp_tsk, tcm_tmr, GFP_KERNEL, tag, TARGET_SCF_ACK_KREF]\n- 调用者: srpt_handle_tsk_mgmt\n- 被调用者: []\n\n8. 函数名: transport_send_check_condition_and_sense\n- 参数: [cmd, 0, 0]\n- 调用者: srpt_handle_tsk_mgmt\n- 被调用者: []"
    },
    {
        "id": 1119,
        "cwe": "CWE-476",
        "cve": "CVE-2016-8630",
        "purpose": "Code purpose:\"\"\"该代码用于在KVM虚拟化环境中解码x86指令，处理指令前缀、操作码和操作数，并模拟指令执行。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理未定义指令时，由于未正确验证ModR/M字节的有效性，导致可能访问无效内存地址，引发主机操作系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: x86_decode_insn\n- 参数: [struct x86_emulate_ctxt *ctxt, void *insn, int insn_len]\n- 调用者: 未显示\n- 被调用者: [__do_insn_fetch_bytes, memcpy, insn_fetch, decode_modrm, decode_abs, decode_operand, address_mask]\n\n2. 函数名: __do_insn_fetch_bytes\n- 参数: [struct x86_emulate_ctxt *ctxt, int bytes]\n- 调用者: x86_decode_insn\n- 被调用者: 未显示\n\n3. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: x86_decode_insn\n- 被调用者: 未显示\n\n4. 函数名: insn_fetch\n- 参数: [u8, struct x86_emulate_ctxt *ctxt]\n- 调用者: x86_decode_insn\n- 被调用者: 未显示\n\n5. 函数名: decode_modrm\n- 参数: [struct x86_emulate_ctxt *ctxt, struct operand *memop]\n- 调用者: x86_decode_insn\n- 被调用者: 未显示\n\n6. 函数名: decode_abs\n- 参数: [struct x86_emulate_ctxt *ctxt, struct operand *memop]\n- 调用者: x86_decode_insn\n- 被调用者: 未显示\n\n7. 函数名: decode_operand\n- 参数: [struct x86_emulate_ctxt *ctxt, struct operand *op, int op_type]\n- 调用者: x86_decode_insn\n- 被调用者: 未显示\n\n8. 函数名: address_mask\n- 参数: [struct x86_emulate_ctxt *ctxt, unsigned long addr]\n- 调用者: x86_decode_insn\n- 被调用者: 未显示"
    },
    {
        "id": 1129,
        "cwe": "CWE-476",
        "cve": "CVE-2016-8646",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理哈希算法套接字的连接接受操作，包括状态导出和导入功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当尝试对未接收任何数据的socket使用内核哈希算法时，未正确处理空数据状态导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: hash_accept\n- 参数: [sock, newsock, flags]\n- 调用者: 未指定\n- 被调用者: [alg_sk, crypto_ahash_statesize, crypto_ahash_reqtfm, crypto_ahash_export, af_alg_accept, crypto_ahash_import, sock_orphan, sock_put]\n\n2. 函数名: alg_sk\n- 参数: [sk]\n- 调用者: hash_accept\n- 被调用者: 未指定\n\n3. 函数名: crypto_ahash_statesize\n- 参数: [crypto_ahash_reqtfm(req)]\n- 调用者: hash_accept\n- 被调用者: 未指定\n\n4. 函数名: crypto_ahash_reqtfm\n- 参数: [req]\n- 调用者: hash_accept\n- 被调用者: 未指定\n\n5. 函数名: crypto_ahash_export\n- 参数: [req, state]\n- 调用者: hash_accept\n- 被调用者: 未指定\n\n6. 函数名: af_alg_accept\n- 参数: [ask->parent, newsock]\n- 调用者: hash_accept\n- 被调用者: 未指定\n\n7. 函数名: crypto_ahash_import\n- 参数: [&ctx2->req, state]\n- 调用者: hash_accept\n- 被调用者: 未指定\n\n8. 函数名: sock_orphan\n- 参数: [sk2]\n- 调用者: hash_accept\n- 被调用者: 未指定\n\n9. 函数名: sock_put\n- 参数: [sk2]\n- 调用者: hash_accept\n- 被调用者: 未指定"
    },
    {
        "id": 1144,
        "cwe": "CWE-476",
        "cve": "CVE-2016-9313",
        "purpose": "Code purpose:\"\"\"注册大密钥类型(big_key)到Linux内核的密钥管理系统中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在big_key.c中未能正确处理加密注册失败而密钥类型注册成功的情况，导致空指针解引用和系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: big_key_init\n- 参数: [void]\n- 调用者: __init\n- 被调用者: [register_key_type]\n\n2. 函数名: register_key_type\n- 参数: [&key_type_big_key]\n- 调用者: big_key_init\n- 被调用者: []"
    },
    {
        "id": 1256,
        "cwe": "CWE-476",
        "cve": "CVE-2017-12153",
        "purpose": "Code purpose:\"\"\"该代码用于处理无线网络重新密钥数据的设置请求，通过Netlink接口接收并验证密钥相关参数，然后配置到当前无线连接中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"函数未检查Netlink请求中必需的属性是否存在就直接访问，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: nl80211_set_rekey_data\n- 参数: [skb, info]\n- 调用者: 未显示（由内核调用）\n- 被调用者: [nla_parse_nested, nla_len, nla_data, wdev_lock, rdev_set_rekey_data, wdev_unlock]\n\n2. 函数名: nla_parse_nested\n- 参数: [tb, MAX_NL80211_REKEY_DATA, info->attrs[NL80211_ATTR_REKEY_DATA], nl80211_rekey_policy, info->extack]\n- 调用者: nl80211_set_rekey_data\n- 被调用者: 未显示\n\n3. 函数名: nla_len\n- 参数: [tb[NL80211_REKEY_DATA_REPLAY_CTR]], [tb[NL80211_REKEY_DATA_KEK]], [tb[NL80211_REKEY_DATA_KCK]]\n- 调用者: nl80211_set_rekey_data\n- 被调用者: 未显示\n\n4. 函数名: nla_data\n- 参数: [tb[NL80211_REKEY_DATA_KEK]], [tb[NL80211_REKEY_DATA_KCK]], [tb[NL80211_REKEY_DATA_REPLAY_CTR]]\n- 调用者: nl80211_set_rekey_data\n- 被调用者: 未显示\n\n5. 函数名: wdev_lock\n- 参数: [wdev]\n- 调用者: nl80211_set_rekey_data\n- 被调用者: 未显示\n\n6. 函数名: rdev_set_rekey_data\n- 参数: [rdev, dev, &rekey_data]\n- 调用者: nl80211_set_rekey_data\n- 被调用者: 未显示\n\n7. 函数名: wdev_unlock\n- 参数: [wdev]\n- 调用者: nl80211_set_rekey_data\n- 被调用者: 未显示"
    },
    {
        "id": 1261,
        "cwe": "CWE-476",
        "cve": "CVE-2017-12192",
        "purpose": "Code purpose:\"\"\"该代码用于读取指定密钥的内容并返回给用户空间，同时检查调用者是否具有读取权限。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"keyctl_read_key函数未正确处理负实例化密钥的情况，导致本地用户可通过特制的KEYCTL_READ操作引发系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: keyctl_read_key\n- 参数: [key_serial_t keyid, char __user *buffer, size_t buflen]\n- 调用者: 未指定（系统调用）\n- 被调用者: [lookup_user_key, key_ref_to_ptr, key_permission, is_key_possessed, down_read, key_validate, key->type->read, up_read, key_put]\n\n2. 函数名: lookup_user_key\n- 参数: [key_serial_t keyid, int create, int possess]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定\n\n3. 函数名: key_ref_to_ptr\n- 参数: [key_ref_t key_ref]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定\n\n4. 函数名: key_permission\n- 参数: [key_ref_t key_ref, unsigned perm]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定\n\n5. 函数名: is_key_possessed\n- 参数: [key_ref_t key_ref]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定\n\n6. 函数名: down_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定\n\n7. 函数名: key_validate\n- 参数: [struct key *key]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定\n\n8. 函数名: up_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定\n\n9. 函数名: key_put\n- 参数: [struct key *key]\n- 调用者: keyctl_read_key\n- 被调用者: 未指定"
    },
    {
        "id": 1262,
        "cwe": "CWE-476",
        "cve": "CVE-2017-12193",
        "purpose": "Code purpose:\"\"\"该代码用于在关联数组的终端节点中插入新元素，处理节点分裂和键值比较等操作，以维护关联数组的结构完整性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在节点分裂处理过程中未正确验证指针是否为空，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: assoc_array_insert_into_terminal_node\n- 参数: [struct assoc_array_edit *edit, const struct assoc_array_ops *ops, const void *index_key, struct assoc_array_walk_result *result]\n- 调用者: 未显示（应为外部调用）\n- 被调用者: [assoc_array_ptr_is_leaf, ops->compare_object, assoc_array_ptr_to_leaf, kzalloc, assoc_array_node_to_ptr, ops->get_object_key_chunk, assoc_array_ptr_is_meta, assoc_array_ptr_is_node, assoc_array_ptr_to_node, assoc_array_ptr_to_shortcut, ops->diff_objects, round_up, ops->get_key_chunk]\n\n2. 函数名: assoc_array_ptr_is_leaf\n- 参数: [struct assoc_array_ptr *ptr]\n- 调用者: assoc_array_insert_into_terminal_node\n- 被调用者: []\n\n3. 函数名: compare_object\n- 参数: [未显示完整参数]\n- 调用者: assoc_array_insert_into_terminal_node\n- 被调用者: []\n\n4. 函数名: assoc_array_ptr_to_leaf\n- 参数: [struct assoc_array_ptr *ptr]\n- 调用者: assoc_array_insert_into_terminal_node\n- 被调用者: []\n\n5. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: assoc_array_insert_into_terminal_node\n- 被调用者: []\n\n6. 函数名: assoc_array_node_to_ptr\n- 参数: [struct assoc_array_node *node]\n- 调用者: assoc_array_insert_into_terminal_node\n- 被调用者: []\n\n7. 函数名: get_object_key_chunk\n- 参数: [未显示完整参数]\n- 调用者: assoc_array_insert_into_terminal_node\n- 被调用者: []\n\n8. 函数名: assoc_array_ptr_is_meta\n- 参数: [struct assoc_array_ptr *ptr]\n- 调用者: assoc_array_insert_into_terminal_node\n- 被调用者: []\n\n9. 函数名: assoc_array_ptr_is_node\n- 参数: [struct assoc_array_ptr *ptr]\n- 调用者: assoc_array_insert_into_terminal_node\n- 被调用者: []\n\n10. 函数名: assoc_array_ptr_to_node\n- 参数: [struct assoc_array_ptr *ptr]\n- 调用者: assoc_array_insert_into_terminal_node\n- 被调用者: []\n\n11. 函数名: assoc_array_ptr_to_shortcut\n- 参数: [struct assoc_array_ptr *ptr]\n- 调用者: assoc_array_insert_into_terminal_node\n- 被调用者: []\n\n12. 函数名: diff_objects\n- 参数: [未显示完整参数]\n- 调用者: assoc_array_insert_into_terminal_node\n- 被调用者: []\n\n13. 函数名: round_up\n- 参数: [unsigned long x, unsigned long y]\n- 调用者: assoc_array_insert_into_terminal_node\n- 被调用者: []\n\n14. 函数名: get_key_chunk\n- 参数: [未显示完整参数]\n- 调用者: assoc_array_insert_into_terminal_node\n- 被调用者: []"
    },
    {
        "id": 1277,
        "cwe": "CWE-476",
        "cve": "CVE-2017-13686",
        "purpose": "Code purpose:\"\"\"处理网络路由查询请求，构建并返回路由信息，包括源地址、目的地址和路由表等数据\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在设置RTM_F_FIB_MATCH标志时，内核未能及时检查fib_result结构中的fi字段是否为NULL，导致可能发生空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: inet_rtm_getroute\n- 参数: [struct sk_buff *in_skb, struct nlmsghdr *nlh, struct netlink_ext_ack *extack]\n- 调用者: 未显示（由内核网络子系统调用）\n- 被调用者: [nlmsg_parse, nlmsg_data, alloc_skb, skb_reset_mac_header, skb_reset_network_header, nla_get_in_addr, nla_get_u32, make_kuid, current_user_ns, current_uid, ip_hdr, skb_reserve, memset, dev_get_by_index_rcu, htons, ip_route_input_rcu, skb_rtable, ip_route_output_key_hash_rcu, skb_dst_set, fib_dump_info, rt_fill_info, rcu_read_unlock, rtnl_unicast, kfree_skb]\n\n2. 函数名: nlmsg_parse\n- 参数: [struct nlmsghdr *nlh, int sizeof_rtm, struct nlattr *tb[], int RTA_MAX, struct nla_policy *rtm_ipv4_policy, struct netlink_ext_ack *extack]\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示\n\n3. 函数名: nlmsg_data\n- 参数: [struct nlmsghdr *nlh]\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示\n\n4. 函数名: alloc_skb\n- 参数: [unsigned int NLMSG_GOODSIZE, gfp_t GFP_KERNEL]\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示\n\n5. 函数名: skb_reset_mac_header\n- 参数: [struct sk_buff *skb]\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示\n\n6. 函数名: skb_reset_network_header\n- 参数: [struct sk_buff *skb]\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示\n\n7. 函数名: nla_get_in_addr\n- 参数: [struct nlattr *tb[]]\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示\n\n8. 函数名: nla_get_u32\n- 参数: [struct nlattr *tb[]]\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示\n\n9. 函数名: make_kuid\n- 参数: [struct user_namespace *current_user_ns(), u32 nla_get_u32(tb[RTA_UID])]\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示\n\n10. 函数名: current_user_ns\n- 参数: []\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示\n\n11. 函数名: current_uid\n- 参数: []\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示\n\n12. 函数名: ip_hdr\n- 参数: [struct sk_buff *skb]\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示\n\n13. 函数名: skb_reserve\n- 参数: [struct sk_buff *skb, int MAX_HEADER + sizeof(struct iphdr)]\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示\n\n14. 函数名: memset\n- 参数: [struct flowi4 *fl4, int 0, sizeof(fl4)]\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示\n\n15. 函数名: dev_get_by_index_rcu\n- 参数: [struct net *net, u32 iif]\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示\n\n16. 函数名: htons\n- 参数: [ETH_P_IP]\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示\n\n17. 函数名: ip_route_input_rcu\n- 参数: [struct sk_buff *skb, __be32 dst, __be32 src, u8 rtm->rtm_tos, struct net_device *dev, struct fib_result *res]\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示\n\n18. 函数名: skb_rtable\n- 参数: [struct sk_buff *skb]\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示\n\n19. 函数名: ip_route_output_key_hash_rcu\n- 参数: [struct net *net, struct flowi4 *fl4, struct fib_result *res, struct sk_buff *skb]\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示\n\n20. 函数名: skb_dst_set\n- 参数: [struct sk_buff *skb, struct dst_entry *rt->dst]\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示\n\n21. 函数名: fib_dump_info\n- 参数: [struct sk_buff *skb, u32 NETLINK_CB(in_skb).portid, u32 nlh->nlmsg_seq, int RTM_NEWROUTE, u32 table_id, u8 rt->rt_type, u32 res.prefix, u32 res.prefixlen, u8 fl4.flowi4_tos, struct fib_info *res.fi, int 0]\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示\n\n22. 函数名: rt_fill_info\n- 参数: [struct net *net, __be32 dst, __be32 src, u32 table_id, struct flowi4 *fl4, struct sk_buff *skb, u32 NETLINK_CB(in_skb).portid, u32 nlh->nlmsg_seq]\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示\n\n23. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示\n\n24. 函数名: rtnl_unicast\n- 参数: [struct sk_buff *skb, struct net *net, u32 NETLINK_CB(in_skb).portid]\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示\n\n25. 函数名: kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: inet_rtm_getroute\n- 被调用者: 未显示"
    },
    {
        "id": 1288,
        "cwe": "CWE-476",
        "cve": "CVE-2017-15102",
        "purpose": "Code purpose:\"\"\"该代码用于探测并初始化LEGO USB Tower设备，包括分配内存、设置端点信息、注册设备以及获取固件版本等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于存在竞态条件和空指针解引用，导致攻击者可以通过精心构造的USB设备触发写任意地址的条件，从而提升权限。\"\"\"",
        "functions": "Functions:\n1. 函数名: tower_probe\n- 参数: [struct usb_interface *interface, const struct usb_device_id *id]\n- 调用者: 内核USB子系统\n- 被调用者: [kmalloc, mutex_init, spin_lock_init, msecs_to_jiffies, init_waitqueue_head, usb_endpoint_xfer_int, usb_endpoint_dir_in, dev_err, kfree, usb_alloc_urb, usb_set_intfdata, usb_register_dev, usb_control_msg, le16_to_cpu, tower_delete]\n\n2. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: tower_probe\n- 被调用者: []\n\n3. 函数名: mutex_init\n- 参数: [struct mutex *lock]\n- 调用者: tower_probe\n- 被调用者: []\n\n4. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: tower_probe\n- 被调用者: []\n\n5. 函数名: msecs_to_jiffies\n- 参数: [const unsigned int m]\n- 调用者: tower_probe\n- 被调用者: []\n\n6. 函数名: init_waitqueue_head\n- 参数: [wait_queue_head_t *q]\n- 调用者: tower_probe\n- 被调用者: []\n\n7. 函数名: usb_endpoint_xfer_int\n- 参数: [const struct usb_endpoint_descriptor *epd]\n- 调用者: tower_probe\n- 被调用者: []\n\n8. 函数名: usb_endpoint_dir_in\n- 参数: [const struct usb_endpoint_descriptor *epd]\n- 调用者: tower_probe\n- 被调用者: []\n\n9. 函数名: dev_err\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: tower_probe\n- 被调用者: []\n\n10. 函数名: usb_alloc_urb\n- 参数: [int iso_packets, gfp_t mem_flags]\n- 调用者: tower_probe\n- 被调用者: []\n\n11. 函数名: usb_set_intfdata\n- 参数: [struct usb_interface *intf, void *data]\n- 调用者: tower_probe\n- 被调用者: []\n\n12. 函数名: usb_register_dev\n- 参数: [struct usb_interface *intf, struct usb_class_driver *class_driver]\n- 调用者: tower_probe\n- 被调用者: []\n\n13. 函数名: usb_control_msg\n- 参数: [struct usb_device *dev, unsigned int pipe, __u8 request, __u8 requesttype, __u16 value, __u16 index, void *data, __u16 size, int timeout]\n- 调用者: tower_probe\n- 被调用者: []\n\n14. 函数名: le16_to_cpu\n- 参数: [__le16 val]\n- 调用者: tower_probe\n- 被调用者: []\n\n15. 函数名: tower_delete\n- 参数: [struct lego_usb_tower *dev]\n- 调用者: tower_probe\n- 被调用者: []"
    },
    {
        "id": 1290,
        "cwe": "CWE-476",
        "cve": "CVE-2017-15116",
        "purpose": "Code purpose:\"\"\"该代码用于重置加密随机数生成器的种子，处理种子为空时的情况并确保内存安全释放\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当seed参数为NULL且slen不为0时，代码可能因tfm->seed为NULL而导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: crypto_rng_reset\n- 参数: [struct crypto_rng *tfm, const u8 *seed, unsigned int slen]\n- 调用者: 未提供\n- 被调用者: [kmalloc, get_random_bytes, tfm->seed, kfree]\n\n2. 函数名: kmalloc\n- 参数: [slen, GFP_KERNEL]\n- 调用者: crypto_rng_reset\n- 被调用者: 未提供\n\n3. 函数名: get_random_bytes\n- 参数: [buf, slen]\n- 调用者: crypto_rng_reset\n- 被调用者: 未提供\n\n4. 函数名: tfm->seed\n- 参数: [tfm, seed, slen]\n- 调用者: crypto_rng_reset\n- 被调用者: 未提供\n\n5. 函数名: kfree\n- 参数: [buf]\n- 调用者: crypto_rng_reset\n- 被调用者: 未提供"
    },
    {
        "id": 1291,
        "cwe": "CWE-476",
        "cve": "CVE-2017-15116",
        "purpose": "Code purpose:\"\"\"初始化加密随机数生成器的转换函数，设置生成随机数、种子和种子大小的相关操作函数指针\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在旧版RNG算法(oalg)中，当rng_make_random存在但未正确初始化rngapi_reset函数时，会导致NULL指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: crypto_rng_init_tfm\n- 参数: [struct crypto_tfm *tfm]\n- 调用者: 未明确（通常是内核中crypto子系统初始化流程）\n- 被调用者: [__crypto_rng_cast, crypto_rng_alg, crypto_old_rng_alg, generate, rngapi_reset]\n\n2. 函数名: __crypto_rng_cast\n- 参数: [struct crypto_tfm *tfm]\n- 调用者: crypto_rng_init_tfm\n- 被调用者: []\n\n3. 函数名: crypto_rng_alg\n- 参数: [struct crypto_rng *rng]\n- 调用者: crypto_rng_init_tfm\n- 被调用者: []\n\n4. 函数名: crypto_old_rng_alg\n- 参数: [struct crypto_rng *rng]\n- 调用者: crypto_rng_init_tfm\n- 被调用者: []\n\n5. 函数名: generate\n- 参数: 未明确（通过函数指针调用）\n- 调用者: crypto_rng_init_tfm\n- 被调用者: []\n\n6. 函数名: rngapi_reset\n- 参数: 未明确（通过函数指针调用）\n- 调用者: crypto_rng_init_tfm\n- 被调用者: []"
    },
    {
        "id": 1292,
        "cwe": "CWE-476",
        "cve": "CVE-2017-15116",
        "purpose": "Code purpose:\"\"\"计算加密算法中随机数生成器的种子大小\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在检查alg->cra_rng.rng_make_random时未对alg指针进行空指针检查，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: seedsize\n- 参数: [struct crypto_alg *alg]\n- 调用者: 未明确（需查看完整代码上下文）\n- 被调用者: [container_of]\n\n2. 函数名: container_of\n- 参数: [alg, struct rng_alg, base]（根据宏定义推断）\n- 调用者: seedsize\n- 被调用者: []"
    },
    {
        "id": 1293,
        "cwe": "CWE-476",
        "cve": "CVE-2017-15116",
        "purpose": "Code purpose:\"\"\"获取加密随机数生成器的种子大小\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核4.2之前版本中，crypto_rng_seedsize函数未对tfm指针进行空指针检查，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: crypto_rng_seedsize\n- 参数: [struct crypto_rng *tfm]\n- 调用者: 未提供（代码片段中未显示）\n- 被调用者: []"
    },
    {
        "id": 1294,
        "cwe": "CWE-476",
        "cve": "CVE-2017-15116",
        "purpose": "Code purpose:\"\"\"该代码片段实现了一个内联函数，用于调用随机数生成器（RNG）的generate方法来生成随机数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对tfm指针及其generate方法进行空指针检查，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: crypto_rng_generate\n- 参数: [struct crypto_rng *tfm, const u8 *src, unsigned int slen, u8 *dst, unsigned int dlen]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [tfm->generate]"
    },
    {
        "id": 1302,
        "cwe": "CWE-476",
        "cve": "CVE-2017-15274",
        "purpose": "Code purpose:\"\"\"该代码用于更新Linux内核中的密钥数据，处理用户空间提供的密钥内容并更新到内核密钥环中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当_payload为NULL且plen非零时，代码未进行有效检查，导致后续操作中出现空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: keyctl_update_key\n- 参数: [key_serial_t id, const void __user *_payload, size_t plen]\n- 调用者: 系统调用\n- 被调用者: [kmalloc, copy_from_user, lookup_user_key, key_update, key_ref_put, kfree]\n\n2. 函数名: kmalloc\n- 参数: [size_t plen, gfp_t GFP_KERNEL]\n- 调用者: keyctl_update_key\n- 被调用者: []\n\n3. 函数名: copy_from_user\n- 参数: [void *payload, const void __user *_payload, size_t plen]\n- 调用者: keyctl_update_key\n- 被调用者: []\n\n4. 函数名: lookup_user_key\n- 参数: [key_serial_t id, int 0, KEY_NEED_WRITE]\n- 调用者: keyctl_update_key\n- 被调用者: []\n\n5. 函数名: key_update\n- 参数: [key_ref_t key_ref, void *payload, size_t plen]\n- 调用者: keyctl_update_key\n- 被调用者: []\n\n6. 函数名: key_ref_put\n- 参数: [key_ref_t key_ref]\n- 调用者: keyctl_update_key\n- 被调用者: []\n\n7. 函数名: kfree\n- 参数: [void *payload]\n- 调用者: keyctl_update_key\n- 被调用者: []"
    },
    {
        "id": 1303,
        "cwe": "CWE-476",
        "cve": "CVE-2017-15274",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中添加或更新密钥的系统调用功能，包括验证输入参数、分配内存、复制用户空间数据到内核空间，并将密钥添加到指定的密钥环中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当payload为NULL且plen不为零时，代码未进行有效检查导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: SYSCALL_DEFINE5(add_key)\n- 参数: [_type, _description, _payload, plen, ringid]\n- 调用者: 系统调用\n- 被调用者: [key_get_type_from_user, strndup_user, kfree, kvmalloc, copy_from_user, lookup_user_key, key_create_or_update, key_ref_to_ptr, key_ref_put, kvfree]\n\n2. 函数名: key_get_type_from_user\n- 参数: [type, _type, sizeof(type)]\n- 调用者: SYSCALL_DEFINE5(add_key)\n- 被调用者: []\n\n3. 函数名: strndup_user\n- 参数: [_description, KEY_MAX_DESC_SIZE]\n- 调用者: SYSCALL_DEFINE5(add_key)\n- 被调用者: []\n\n4. 函数名: kfree\n- 参数: [description]\n- 调用者: SYSCALL_DEFINE5(add_key)\n- 被调用者: []\n\n5. 函数名: kvmalloc\n- 参数: [plen, GFP_KERNEL]\n- 调用者: SYSCALL_DEFINE5(add_key)\n- 被调用者: []\n\n6. 函数名: copy_from_user\n- 参数: [payload, _payload, plen]\n- 调用者: SYSCALL_DEFINE5(add_key)\n- 被调用者: []\n\n7. 函数名: lookup_user_key\n- 参数: [ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE]\n- 调用者: SYSCALL_DEFINE5(add_key)\n- 被调用者: []\n\n8. 函数名: key_create_or_update\n- 参数: [keyring_ref, type, description, payload, plen, KEY_PERM_UNDEF, KEY_ALLOC_IN_QUOTA]\n- 调用者: SYSCALL_DEFINE5(add_key)\n- 被调用者: []\n\n9. 函数名: key_ref_to_ptr\n- 参数: [key_ref]\n- 调用者: SYSCALL_DEFINE5(add_key)\n- 被调用者: []\n\n10. 函数名: key_ref_put\n- 参数: [key_ref]\n- 调用者: SYSCALL_DEFINE5(add_key)\n- 被调用者: []\n\n11. 函数名: key_ref_put\n- 参数: [keyring_ref]\n- 调用者: SYSCALL_DEFINE5(add_key)\n- 被调用者: []\n\n12. 函数名: kvfree\n- 参数: [payload]\n- 调用者: SYSCALL_DEFINE5(add_key)\n- 被调用者: []"
    },
    {
        "id": 1304,
        "cwe": "CWE-476",
        "cve": "CVE-2017-15299",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的KEYS子系统中创建或更新密钥，包括密钥的实例化、权限检查和链接到密钥环等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当尝试使用add_key系统调用更新一个已存在但未实例化的密钥时，KEYS子系统未正确处理该情况，导致空指针解引用和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: key_create_or_update\n- 参数: [keyring_ref, type, description, payload, plen, perm, flags]\n- 调用者: 未指定（系统调用）\n- 被调用者: [key_type_lookup, IS_ERR, ERR_PTR, key_ref_to_ptr, key_check, memset, strlen, __key_link_begin, key_permission, find_key_to_update, key_alloc, __key_instantiate_and_link, make_key_ref, key_put, __key_link_end, key_type_put, __key_update]\n\n2. 函数名: key_type_lookup\n- 参数: [type]\n- 调用者: key_create_or_update\n- 被调用者: []\n\n3. 函数名: key_ref_to_ptr\n- 参数: [keyring_ref]\n- 调用者: key_create_or_update\n- 被调用者: []\n\n4. 函数名: key_check\n- 参数: [keyring]\n- 调用者: key_create_or_update\n- 被调用者: []\n\n5. 函数名: __key_link_begin\n- 参数: [keyring, &index_key, &edit]\n- 调用者: key_create_or_update\n- 被调用者: []\n\n6. 函数名: key_permission\n- 参数: [keyring_ref, KEY_NEED_WRITE]\n- 调用者: key_create_or_update\n- 被调用者: []\n\n7. 函数名: find_key_to_update\n- 参数: [keyring_ref, &index_key]\n- 调用者: key_create_or_update\n- 被调用者: []\n\n8. 函数名: key_alloc\n- 参数: [index_key.type, index_key.description, cred->fsuid, cred->fsgid, cred, perm, flags, NULL]\n- 调用者: key_create_or_update\n- 被调用者: []\n\n9. 函数名: __key_instantiate_and_link\n- 参数: [key, &prep, keyring, NULL, &edit]\n- 调用者: key_create_or_update\n- 被调用者: []\n\n10. 函数名: make_key_ref\n- 参数: [key, is_key_possessed(keyring_ref)]\n- 调用者: key_create_or_update\n- 被调用者: []\n\n11. 函数名: key_put\n- 参数: [key]\n- 调用者: key_create_or_update\n- 被调用者: []\n\n12. 函数名: __key_link_end\n- 参数: [keyring, &index_key, edit]\n- 调用者: key_create_or_update\n- 被调用者: []\n\n13. 函数名: key_type_put\n- 参数: [index_key.type]\n- 调用者: key_create_or_update\n- 被调用者: []\n\n14. 函数名: __key_update\n- 参数: [key_ref, &prep]\n- 调用者: key_create_or_update\n- 被调用者: []"
    },
    {
        "id": 1305,
        "cwe": "CWE-476",
        "cve": "CVE-2017-15306",
        "purpose": "Code purpose:\"\"\"该代码用于检查KVM虚拟机的扩展功能支持情况，并根据不同的扩展类型返回相应的支持状态或能力值。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当调用KVM_CAP_PPC_HTM扩展检查时，未对kvm指针进行空指针检查就直接传递给is_kvmppc_hv_enabled函数，导致空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: kvm_vm_ioctl_check_extension\n- 参数: [struct kvm *kvm, long ext]\n- 调用者: 未明确显示（由KVM ioctl调用）\n- 被调用者: [kvmppc_hv_ops, is_kvmppc_hv_enabled, cpu_has_feature, radix_enabled, kvmppc_hwrng_present, num_present_cpus, num_online_cpus]\n\n2. 函数名: is_kvmppc_hv_enabled\n- 参数: [struct kvm *kvm]\n- 调用者: kvm_vm_ioctl_check_extension\n- 被调用者: []\n\n3. 函数名: cpu_has_feature\n- 参数: [CPU_FTR_ARCH_300 或 CPU_FTR_TM_COMP]\n- 调用者: kvm_vm_ioctl_check_extension\n- 被调用者: []\n\n4. 函数名: radix_enabled\n- 参数: []\n- 调用者: kvm_vm_ioctl_check_extension\n- 被调用者: []\n\n5. 函数名: kvmppc_hwrng_present\n- 参数: []\n- 调用者: kvm_vm_ioctl_check_extension\n- 被调用者: []\n\n6. 函数名: num_present_cpus\n- 参数: []\n- 调用者: kvm_vm_ioctl_check_extension\n- 被调用者: []\n\n7. 函数名: num_online_cpus\n- 参数: []\n- 调用者: kvm_vm_ioctl_check_extension\n- 被调用者: []"
    },
    {
        "id": 1319,
        "cwe": "CWE-476",
        "cve": "CVE-2017-16532",
        "purpose": "Code purpose:\"\"\"该代码用于从USB接口中获取并配置不同类型的端点(如批量传输、中断传输和等时传输端点)，以便进行USB设备测试。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理USB设备端点时未充分验证指针是否为空，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: get_endpoints\n- 参数: [struct usbtest_dev *dev, struct usb_interface *intf]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [usb_endpoint_dir_in, usb_endpoint_type, endpoint_update, testdev_to_usbdev, usb_set_interface, usb_rcvbulkpipe, usb_sndbulkpipe, usb_rcvisocpipe, usb_sndisocpipe, usb_rcvintpipe, usb_sndintpipe]\n\n2. 函数名: endpoint_update\n- 参数: [int edi, struct usb_host_endpoint **in, struct usb_host_endpoint **out, struct usb_host_endpoint *e]\n- 调用者: get_endpoints\n- 被调用者: 未显示（假设是内部实现）\n\n3. 函数名: usb_endpoint_dir_in\n- 参数: [struct usb_endpoint_descriptor *desc]\n- 调用者: get_endpoints\n- 被调用者: 未显示（标准USB函数）\n\n4. 函数名: usb_endpoint_type\n- 参数: [struct usb_endpoint_descriptor *desc]\n- 调用者: get_endpoints\n- 被调用者: 未显示（标准USB函数）\n\n5. 函数名: testdev_to_usbdev\n- 参数: [struct usbtest_dev *dev]\n- 调用者: get_endpoints\n- 被调用者: 未显示（假设是内部实现）\n\n6. 函数名: usb_set_interface\n- 参数: [struct usb_device *udev, int bInterfaceNumber, int bAlternateSetting]\n- 调用者: get_endpoints\n- 被调用者: 未显示（标准USB函数）\n\n7. 函数名: usb_rcvbulkpipe\n- 参数: [struct usb_device *udev, int endpoint]\n- 调用者: get_endpoints\n- 被调用者: 未显示（标准USB函数）\n\n8. 函数名: usb_sndbulkpipe\n- 参数: [struct usb_device *udev, int endpoint]\n- 调用者: get_endpoints\n- 被调用者: 未显示（标准USB函数）\n\n9. 函数名: usb_rcvisocpipe\n- 参数: [struct usb_device *udev, int endpoint]\n- 调用者: get_endpoints\n- 被调用者: 未显示（标准USB函数）\n\n10. 函数名: usb_sndisocpipe\n- 参数: [struct usb_device *udev, int endpoint]\n- 调用者: get_endpoints\n- 被调用者: 未显示（标准USB函数）\n\n11. 函数名: usb_rcvintpipe\n- 参数: [struct usb_device *udev, int endpoint]\n- 调用者: get_endpoints\n- 被调用者: 未显示（标准USB函数）\n\n12. 函数名: usb_sndintpipe\n- 参数: [struct usb_device *udev, int endpoint]\n- 调用者: get_endpoints\n- 被调用者: 未显示（标准USB函数）"
    },
    {
        "id": 1323,
        "cwe": "CWE-476",
        "cve": "CVE-2017-16537",
        "purpose": "Code purpose:\"\"\"该代码用于探测和初始化iMON USB设备，包括处理设备的多接口情况并创建相应的sysfs条目和显示支持。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在imon_probe函数中，当处理USB设备的第二个接口时，未正确验证first_if指针是否为NULL，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: imon_probe\n- 参数: [struct usb_interface *interface, const struct usb_device_id *id]\n- 调用者: 无（USB驱动探测函数）\n- 被调用者: [usb_get_dev, interface_to_usbdev, le16_to_cpu, dev_dbg, mutex_lock, usb_ifnum_to_if, usb_get_intfdata, imon_init_intf0, imon_init_intf1, usb_set_intfdata, sysfs_create_group, imon_init_display, mutex_unlock, dev_info, usb_put_dev, dev_err]\n\n2. 函数名: usb_get_dev\n- 参数: [struct usb_device *dev]\n- 调用者: imon_probe\n- 被调用者: 无\n\n3. 函数名: interface_to_usbdev\n- 参数: [struct usb_interface *interface]\n- 调用者: imon_probe\n- 被调用者: 无\n\n4. 函数名: le16_to_cpu\n- 参数: [__le16]\n- 调用者: imon_probe\n- 被调用者: 无\n\n5. 函数名: dev_dbg\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: imon_probe\n- 被调用者: 无\n\n6. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: imon_probe\n- 被调用者: 无\n\n7. 函数名: usb_ifnum_to_if\n- 参数: [struct usb_device *dev, unsigned ifnum]\n- 调用者: imon_probe\n- 被调用者: 无\n\n8. 函数名: usb_get_intfdata\n- 参数: [struct usb_interface *intf]\n- 调用者: imon_probe\n- 被调用者: 无\n\n9. 函数名: imon_init_intf0\n- 参数: [struct usb_interface *interface, const struct usb_device_id *id]\n- 调用者: imon_probe\n- 被调用者: 无\n\n10. 函数名: imon_init_intf1\n- 参数: [struct usb_interface *interface, struct imon_context *ictx]\n- 调用者: imon_probe\n- 被调用者: 无\n\n11. 函数名: usb_set_intfdata\n- 参数: [struct usb_interface *intf, void *data]\n- 调用者: imon_probe\n- 被调用者: 无\n\n12. 函数名: sysfs_create_group\n- 参数: [struct kobject *kobj, const struct attribute_group *grp]\n- 调用者: imon_probe\n- 被调用者: 无\n\n13. 函数名: imon_init_display\n- 参数: [struct imon_context *ictx, struct usb_interface *intf]\n- 调用者: imon_probe\n- 被调用者: 无\n\n14. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: imon_probe\n- 被调用者: 无\n\n15. 函数名: dev_info\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: imon_probe\n- 被调用者: 无\n\n16. 函数名: usb_put_dev\n- 参数: [struct usb_device *dev]\n- 调用者: imon_probe\n- 被调用者: 无\n\n17. 函数名: dev_err\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: imon_probe\n- 被调用者: 无"
    },
    {
        "id": 1328,
        "cwe": "CWE-476",
        "cve": "CVE-2017-16646",
        "purpose": "Code purpose:\"\"\"该代码用于处理DVB USB设备的适配器前端连接，包括GPIO设置和I2C枚举，以初始化设备前端功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码在未正确验证USB设备输入的情况下直接操作GPIO和I2C设备，导致恶意USB设备可能引发空指针解引用或系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: stk7700d_frontend_attach\n- 参数: [struct dvb_usb_adapter *adap]\n- 调用者: 未显示（由DVB子系统调用）\n- 被调用者: [dvb_attach, dib0700_set_gpio, msleep, i2c_enumeration, dvb_detach, init]\n\n2. 函数名: dvb_attach\n- 参数: [dib7000p_attach, &state->dib7000p_ops]\n- 调用者: stk7700d_frontend_attach\n- 被调用者: 未显示（外部函数）\n\n3. 函数名: dib0700_set_gpio\n- 参数: [adap->dev, GPIO6/GPIO9/GPIO4/GPIO7/GPIO10/GPIO0, GPIO_OUT, 1/0]\n- 调用者: stk7700d_frontend_attach\n- 被调用者: 未显示（外部函数）\n\n4. 函数名: msleep\n- 参数: [10]\n- 调用者: stk7700d_frontend_attach\n- 被调用者: 未显示（内核函数）\n\n5. 函数名: i2c_enumeration\n- 参数: [&adap->dev->i2c_adap, 2, 18, stk7700d_dib7000p_mt2266_config]\n- 调用者: state->dib7000p_ops（通过函数指针）\n- 被调用者: stk7700d_frontend_attach\n\n6. 函数名: dvb_detach\n- 参数: [&state->dib7000p_ops]\n- 调用者: stk7700d_frontend_attach\n- 被调用者: 未显示（外部函数）\n\n7. 函数名: init\n- 参数: [&adap->dev->i2c_adap, 0x80 + (adap->id << 1), &stk7700d_dib7000p_mt2266_config[adap->id]]\n- 调用者: state->dib7000p_ops（通过函数指针）\n- 被调用者: stk7700d_frontend_attach"
    },
    {
        "id": 1329,
        "cwe": "CWE-476",
        "cve": "CVE-2017-16646",
        "purpose": "Code purpose:\"\"\"该代码用于处理DVB USB设备的适配器前端连接，包括GPIO控制、时钟设置和I2C枚举等操作，以实现对特定USB视频设备的支持。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未对USB设备描述符指针进行空指针检查，可能导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: stk7070p_frontend_attach\n- 参数: [struct dvb_usb_adapter *adap]\n- 调用者: 未显示\n- 被调用者: [dvb_attach, dib0700_set_gpio, msleep, dib0700_ctrl_clock, i2c_enumeration, dvb_detach, init]\n\n2. 函数名: dvb_attach\n- 参数: [dib7000p_attach, &state->dib7000p_ops]\n- 调用者: stk7070p_frontend_attach\n- 被调用者: 未显示\n\n3. 函数名: dib0700_set_gpio\n- 参数: [adap->dev, GPIO6/GPIO9/GPIO4/GPIO7/GPIO10/GPIO0, GPIO_OUT, 0/1]\n- 调用者: stk7070p_frontend_attach\n- 被调用者: 未显示\n\n4. 函数名: msleep\n- 参数: [10]\n- 调用者: stk7070p_frontend_attach\n- 被调用者: 未显示\n\n5. 函数名: dib0700_ctrl_clock\n- 参数: [adap->dev, 72, 1]\n- 调用者: stk7070p_frontend_attach\n- 被调用者: 未显示\n\n6. 函数名: i2c_enumeration\n- 参数: [&adap->dev->i2c_adap, 1, 18, &dib7070p_dib7000p_config]\n- 调用者: state->dib7000p_ops\n- 被调用者: stk7070p_frontend_attach\n\n7. 函数名: dvb_detach\n- 参数: [&state->dib7000p_ops]\n- 调用者: stk7070p_frontend_attach\n- 被调用者: 未显示\n\n8. 函数名: init\n- 参数: [&adap->dev->i2c_adap, 0x80, &dib7070p_dib7000p_config]\n- 调用者: state->dib7000p_ops\n- 被调用者: stk7070p_frontend_attach"
    },
    {
        "id": 1330,
        "cwe": "CWE-476",
        "cve": "CVE-2017-16646",
        "purpose": "Code purpose:\"\"\"该代码实现了DVB USB适配器的前端附件功能，包括电源管理、GPIO控制、时钟设置和调制解调器检测等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未对USB设备的输入进行充分验证，导致恶意USB设备可触发空指针解引用或其他未定义行为\"\"\"",
        "functions": "Functions:\n1. 函数名: pctv340e_frontend_attach\n- 参数: [struct dvb_usb_adapter *adap]\n- 调用者: 未显示\n- 被调用者: [dvb_attach, dib0700_set_gpio, msleep, dib0700_ctrl_clock, state->dib7000p_ops.dib7000pc_detection, dvb_detach, state->dib7000p_ops.init]\n\n2. 函数名: dvb_attach\n- 参数: [dib7000p_attach, &state->dib7000p_ops]\n- 调用者: pctv340e_frontend_attach\n- 被调用者: 未显示\n\n3. 函数名: dib0700_set_gpio\n- 参数: [adap->dev, GPIO6, GPIO_OUT, 0], [adap->dev, GPIO6, GPIO_OUT, 1], [adap->dev, GPIO10, GPIO_OUT, 0], [adap->dev, GPIO10, GPIO_OUT, 1], [adap->dev, GPIO8, GPIO_OUT, 1], [adap->dev, GPIO2, GPIO_OUT, 1]\n- 调用者: pctv340e_frontend_attach\n- 被调用者: 未显示\n\n4. 函数名: msleep\n- 参数: [50], [100], [1], [500]\n- 调用者: pctv340e_frontend_attach\n- 被调用者: 未显示\n\n5. 函数名: dib0700_ctrl_clock\n- 参数: [adap->dev, 72, 1]\n- 调用者: pctv340e_frontend_attach\n- 被调用者: 未显示\n\n6. 函数名: state->dib7000p_ops.dib7000pc_detection\n- 参数: [&adap->dev->i2c_adap]\n- 调用者: pctv340e_frontend_attach\n- 被调用者: 未显示\n\n7. 函数名: dvb_detach\n- 参数: [&state->dib7000p_ops]\n- 调用者: pctv340e_frontend_attach\n- 被调用者: 未显示\n\n8. 函数名: state->dib7000p_ops.init\n- 参数: [&adap->dev->i2c_adap, 0x12, &pctv_340e_config]\n- 调用者: pctv340e_frontend_attach\n- 被调用者: 未显示"
    },
    {
        "id": 1331,
        "cwe": "CWE-476",
        "cve": "CVE-2017-16646",
        "purpose": "Code purpose:\"\"\"该代码用于处理TFE7790P前端设备的连接和初始化，包括GPIO设置、时钟控制和I2C枚举等操作，以支持DVB USB适配器功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码在处理USB设备时未充分验证输入，导致空指针解引用或无效内存访问\"\"\"",
        "functions": "Functions:\n1. 函数名: tfe7790p_frontend_attach\n- 参数: [struct dvb_usb_adapter *adap]\n- 调用者: 未显示\n- 被调用者: [dvb_attach, dib0700_set_gpio, msleep, dib0700_ctrl_clock, err, dvb_detach]\n\n2. 函数名: dvb_attach\n- 参数: [dib7000p_attach, &state->dib7000p_ops]\n- 调用者: tfe7790p_frontend_attach\n- 被调用者: 未显示\n\n3. 函数名: dib0700_set_gpio\n- 参数: [adap->dev, GPIO6, GPIO_OUT, 1], [adap->dev, GPIO9, GPIO_OUT, 1], [adap->dev, GPIO4, GPIO_OUT, 1], [adap->dev, GPIO7, GPIO_OUT, 1], [adap->dev, GPIO10, GPIO_OUT, 0], [adap->dev, GPIO10, GPIO_OUT, 1], [adap->dev, GPIO0, GPIO_OUT, 1]\n- 调用者: tfe7790p_frontend_attach\n- 被调用者: 未显示\n\n4. 函数名: msleep\n- 参数: [20], [20], [20]\n- 调用者: tfe7790p_frontend_attach\n- 被调用者: 未显示\n\n5. 函数名: dib0700_ctrl_clock\n- 参数: [adap->dev, 72, 1]\n- 调用者: tfe7790p_frontend_attach\n- 被调用者: 未显示\n\n6. 函数名: err\n- 参数: [\"%s: state->dib7000p_ops.i2c_enumeration failed.  Cannot continue\\n\", __func__]\n- 调用者: tfe7790p_frontend_attach\n- 被调用者: 未显示\n\n7. 函数名: dvb_detach\n- 参数: [&state->dib7000p_ops]\n- 调用者: tfe7790p_frontend_attach\n- 被调用者: 未显示\n\n8. 函数名: i2c_enumeration\n- 参数: [&adap->dev->i2c_adap, 1, 0x10, &tfe7790p_dib7000p_config]\n- 调用者: tfe7790p_frontend_attach\n- 被调用者: 未显示\n\n9. 函数名: init\n- 参数: [&adap->dev->i2c_adap, 0x80, &tfe7790p_dib7000p_config]\n- 调用者: tfe7790p_frontend_attach\n- 被调用者: 未显示"
    },
    {
        "id": 1332,
        "cwe": "CWE-476",
        "cve": "CVE-2017-16646",
        "purpose": "Code purpose:\"\"\"该代码用于处理DVB USB设备的适配器前端连接，包括GPIO设置和I2C枚举，以初始化设备并配置相关参数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未对USB设备描述符进行充分验证，导致当插入恶意USB设备时可能引发空指针解引用或系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: stk7700ph_frontend_attach\n- 参数: [struct dvb_usb_adapter *adap]\n- 调用者: N/A (驱动初始化函数)\n- 被调用者: [dvb_attach, dib0700_set_gpio, msleep, i2c_enumeration, dvb_detach, init]\n\n2. 函数名: dvb_attach\n- 参数: [dib7000p_attach, &state->dib7000p_ops]\n- 调用者: stk7700ph_frontend_attach\n- 被调用者: N/A\n\n3. 函数名: dib0700_set_gpio\n- 参数: [adap->dev, GPIO6/GPIO9/GPIO4/GPIO7/GPIO10/GPIO0, GPIO_OUT, 0/1]\n- 调用者: stk7700ph_frontend_attach\n- 被调用者: N/A\n\n4. 函数名: msleep\n- 参数: [20/10]\n- 调用者: stk7700ph_frontend_attach\n- 被调用者: N/A\n\n5. 函数名: i2c_enumeration\n- 参数: [&adap->dev->i2c_adap, 1, 18, &stk7700ph_dib7700_xc3028_config]\n- 调用者: state->dib7000p_ops (通过函数指针调用)\n- 被调用者: N/A\n\n6. 函数名: dvb_detach\n- 参数: [&state->dib7000p_ops]\n- 调用者: stk7700ph_frontend_attach\n- 被调用者: N/A\n\n7. 函数名: init\n- 参数: [&adap->dev->i2c_adap, 0x80, &stk7700ph_dib7700_xc3028_config]\n- 调用者: state->dib7000p_ops (通过函数指针调用)\n- 被调用者: N/A"
    },
    {
        "id": 1333,
        "cwe": "CWE-476",
        "cve": "CVE-2017-16646",
        "purpose": "Code purpose:\"\"\"该代码用于初始化并附加DVB USB设备的frontend适配器，处理与dib7000p芯片相关的I2C通信和设备配置。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码在处理USB设备时未充分验证输入，导致空指针解引用或非法内存访问\"\"\"",
        "functions": "Functions:\n1. 函数名: tfe7090pvr_frontend1_attach\n- 参数: [struct dvb_usb_adapter *adap]\n- 调用者: 未显示（由DVB子系统调用）\n- 被调用者: [dvb_attach, state->dib7000p_ops.get_i2c_master, state->dib7000p_ops.i2c_enumeration, dvb_detach, state->dib7000p_ops.init, dib0700_set_i2c_speed]\n\n2. 函数名: dvb_attach\n- 参数: [dib7000p_attach, &state->dib7000p_ops]\n- 调用者: tfe7090pvr_frontend1_attach\n- 被调用者: 未显示（外部函数）\n\n3. 函数名: get_i2c_master\n- 参数: [adap->dev->adapter[0].fe_adap[0].fe, DIBX000_I2C_INTERFACE_GPIO_6_7, 1]\n- 调用者: tfe7090pvr_frontend1_attach\n- 被调用者: 未显示（通过state->dib7000p_ops结构体调用）\n\n4. 函数名: i2c_enumeration\n- 参数: [i2c, 1, 0x10, &tfe7090pvr_dib7000p_config[1]]\n- 调用者: tfe7090pvr_frontend1_attach\n- 被调用者: 未显示（通过state->dib7000p_ops结构体调用）\n\n5. 函数名: dvb_detach\n- 参数: [&state->dib7000p_ops]\n- 调用者: tfe7090pvr_frontend1_attach\n- 被调用者: 未显示（外部函数）\n\n6. 函数名: init\n- 参数: [i2c, 0x92, &tfe7090pvr_dib7000p_config[1]]\n- 调用者: tfe7090pvr_frontend1_attach\n- 被调用者: 未显示（通过state->dib7000p_ops结构体调用）\n\n7. 函数名: dib0700_set_i2c_speed\n- 参数: [adap->dev, 200]\n- 调用者: tfe7090pvr_frontend1_attach\n- 被调用者: 未显示（外部函数）"
    },
    {
        "id": 1334,
        "cwe": "CWE-476",
        "cve": "CVE-2017-16646",
        "purpose": "Code purpose:\"\"\"该代码用于初始化并附加DVB USB适配器的前端设备，处理与DIB7000P芯片的通信和配置。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未对USB设备输入进行充分验证，导致空指针解引用或非法内存访问\"\"\"",
        "functions": "Functions:\n1. 函数名: stk7070pd_frontend_attach0\n- 参数: [struct dvb_usb_adapter *adap]\n- 调用者: 未显示\n- 被调用者: [dvb_attach, stk7070pd_init, msleep, dib0700_set_gpio, i2c_enumeration, err, dvb_detach, init]\n\n2. 函数名: dvb_attach\n- 参数: [dib7000p_attach, &state->dib7000p_ops]\n- 调用者: stk7070pd_frontend_attach0\n- 被调用者: 未显示\n\n3. 函数名: stk7070pd_init\n- 参数: [adap->dev]\n- 调用者: stk7070pd_frontend_attach0\n- 被调用者: 未显示\n\n4. 函数名: msleep\n- 参数: [10]\n- 调用者: stk7070pd_frontend_attach0\n- 被调用者: 未显示\n\n5. 函数名: dib0700_set_gpio\n- 参数: [adap->dev, GPIO0, GPIO_OUT, 1]\n- 调用者: stk7070pd_frontend_attach0\n- 被调用者: 未显示\n\n6. 函数名: i2c_enumeration\n- 参数: [&adap->dev->i2c_adap, 2, 18, stk7070pd_dib7000p_config]\n- 调用者: state->dib7000p_ops (通过 stk7070pd_frontend_attach0)\n- 被调用者: 未显示\n\n7. 函数名: err\n- 参数: [\"%s: state->dib7000p_ops.i2c_enumeration failed.  Cannot continue\\n\", __func__]\n- 调用者: stk7070pd_frontend_attach0\n- 被调用者: 未显示\n\n8. 函数名: dvb_detach\n- 参数: [&state->dib7000p_ops]\n- 调用者: stk7070pd_frontend_attach0\n- 被调用者: 未显示\n\n9. 函数名: init\n- 参数: [&adap->dev->i2c_adap, 0x80, &stk7070pd_dib7000p_config[0]]\n- 调用者: state->dib7000p_ops (通过 stk7070pd_frontend_attach0)\n- 被调用者: 未显示"
    },
    {
        "id": 1335,
        "cwe": "CWE-476",
        "cve": "CVE-2017-16646",
        "purpose": "Code purpose:\"\"\"该代码实现了TFE7090P USB设备的DVB前端适配器初始化功能，包括GPIO设置、I2C枚举和设备初始化等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码在处理USB设备时未充分验证输入，导致空指针解引用或无效内存访问\"\"\"",
        "functions": "Functions:\n1. 函数名: tfe7090pvr_frontend0_attach\n- 参数: [struct dvb_usb_adapter *adap]\n- 调用者: (未明确显示)\n- 被调用者: [dvb_attach, dib0700_set_gpio, msleep, state->dib7000p_ops.i2c_enumeration, err, dvb_detach, dib0700_set_i2c_speed, state->dib7000p_ops.init, state->dib7000p_ops.slave_reset]\n\n2. 函数名: dvb_attach\n- 参数: [dib7000p_attach, &state->dib7000p_ops]\n- 调用者: tfe7090pvr_frontend0_attach\n- 被调用者: (未明确显示)\n\n3. 函数名: dib0700_set_gpio\n- 参数: [adap->dev, GPIO6, GPIO_OUT, 1], [adap->dev, GPIO9, GPIO_OUT, 1], [adap->dev, GPIO4, GPIO_OUT, 1], [adap->dev, GPIO7, GPIO_OUT, 1], [adap->dev, GPIO10, GPIO_OUT, 0], [adap->dev, GPIO10, GPIO_OUT, 1], [adap->dev, GPIO0, GPIO_OUT, 1]\n- 调用者: tfe7090pvr_frontend0_attach\n- 被调用者: (未明确显示)\n\n4. 函数名: msleep\n- 参数: [20]\n- 调用者: tfe7090pvr_frontend0_attach\n- 被调用者: (未明确显示)\n\n5. 函数名: state->dib7000p_ops.i2c_enumeration\n- 参数: [&adap->dev->i2c_adap, 1, 0x20, &tfe7090pvr_dib7000p_config[0]]\n- 调用者: tfe7090pvr_frontend0_attach\n- 被调用者: (未明确显示)\n\n6. 函数名: err\n- 参数: [\"%s: state->dib7000p_ops.i2c_enumeration failed.  Cannot continue\\n\", __func__]\n- 调用者: tfe7090pvr_frontend0_attach\n- 被调用者: (未明确显示)\n\n7. 函数名: dvb_detach\n- 参数: [&state->dib7000p_ops]\n- 调用者: tfe7090pvr_frontend0_attach\n- 被调用者: (未明确显示)\n\n8. 函数名: dib0700_set_i2c_speed\n- 参数: [adap->dev, 340]\n- 调用者: tfe7090pvr_frontend0_attach\n- 被调用者: (未明确显示)\n\n9. 函数名: state->dib7000p_ops.init\n- 参数: [&adap->dev->i2c_adap, 0x90, &tfe7090pvr_dib7000p_config[0]]\n- 调用者: tfe7090pvr_frontend0_attach\n- 被调用者: (未明确显示)\n\n10. 函数名: state->dib7000p_ops.slave_reset\n- 参数: [adap->fe_adap[0].fe]\n- 调用者: tfe7090pvr_frontend0_attach\n- 被调用者: (未明确显示)"
    },
    {
        "id": 1336,
        "cwe": "CWE-476",
        "cve": "CVE-2017-16646",
        "purpose": "Code purpose:\"\"\"该代码用于处理DVB USB设备的适配器前端连接，包括GPIO控制、时钟设置和I2C枚举等操作，以实现设备的初始化和配置。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未对USB设备描述符指针进行空指针检查，可能导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: stk7770p_frontend_attach\n- 参数: [struct dvb_usb_adapter *adap]\n- 调用者: 未显示\n- 被调用者: [dvb_attach, dib0700_set_gpio, msleep, dib0700_ctrl_clock, i2c_enumeration, dvb_detach, init]\n\n2. 函数名: dvb_attach\n- 参数: [dib7000p_attach, &state->dib7000p_ops]\n- 调用者: stk7770p_frontend_attach\n- 被调用者: 未显示\n\n3. 函数名: dib0700_set_gpio\n- 参数: [adap->dev, GPIO6, GPIO_OUT, 0/1], [adap->dev, GPIO9, GPIO_OUT, 1], [adap->dev, GPIO4, GPIO_OUT, 1], [adap->dev, GPIO7, GPIO_OUT, 1], [adap->dev, GPIO10, GPIO_OUT, 0/1], [adap->dev, GPIO0, GPIO_OUT, 1]\n- 调用者: stk7770p_frontend_attach\n- 被调用者: 未显示\n\n4. 函数名: msleep\n- 参数: [10]\n- 调用者: stk7770p_frontend_attach\n- 被调用者: 未显示\n\n5. 函数名: dib0700_ctrl_clock\n- 参数: [adap->dev, 72, 1]\n- 调用者: stk7770p_frontend_attach\n- 被调用者: 未显示\n\n6. 函数名: i2c_enumeration\n- 参数: [&adap->dev->i2c_adap, 1, 18, &dib7770p_dib7000p_config]\n- 调用者: state->dib7000p_ops (通过指针调用)\n- 被调用者: stk7770p_frontend_attach\n\n7. 函数名: dvb_detach\n- 参数: [&state->dib7000p_ops]\n- 调用者: stk7770p_frontend_attach\n- 被调用者: 未显示\n\n8. 函数名: init\n- 参数: [&adap->dev->i2c_adap, 0x80, &dib7770p_dib7000p_config]\n- 调用者: state->dib7000p_ops (通过指针调用)\n- 被调用者: stk7770p_frontend_attach"
    },
    {
        "id": 1337,
        "cwe": "CWE-476",
        "cve": "CVE-2017-16646",
        "purpose": "Code purpose:\"\"\"该代码用于实现DVB USB设备的适配器前端连接功能，包括GPIO控制和I2C枚举等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在dib7000p_attach操作失败时未正确检查state->dib7000p_ops指针的有效性，导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: nim7090_frontend_attach\n- 参数: [struct dvb_usb_adapter *adap]\n- 调用者: 未显示（由DVB USB子系统调用）\n- 被调用者: [dvb_attach, dib0700_set_gpio, msleep, state->dib7000p_ops.i2c_enumeration, err, dvb_detach, state->dib7000p_ops.init]\n\n2. 函数名: dvb_attach\n- 参数: [dib7000p_attach, &state->dib7000p_ops]\n- 调用者: nim7090_frontend_attach\n- 被调用者: 未显示（外部函数）\n\n3. 函数名: dib0700_set_gpio\n- 参数: [adap->dev, GPIO6/GPIO9/GPIO4/GPIO7/GPIO10/GPIO0, GPIO_OUT, 1/0]\n- 调用者: nim7090_frontend_attach\n- 被调用者: 未显示（外部函数）\n\n4. 函数名: msleep\n- 参数: [20]\n- 调用者: nim7090_frontend_attach\n- 被调用者: 未显示（内核延迟函数）\n\n5. 函数名: state->dib7000p_ops.i2c_enumeration\n- 参数: [&adap->dev->i2c_adap, 1, 0x10, &nim7090_dib7000p_config]\n- 调用者: nim7090_frontend_attach\n- 被调用者: 未显示（通过函数指针调用）\n\n6. 函数名: err\n- 参数: [格式化字符串, __func__]\n- 调用者: nim7090_frontend_attach\n- 被调用者: 未显示（内核打印函数）\n\n7. 函数名: dvb_detach\n- 参数: [&state->dib7000p_ops]\n- 调用者: nim7090_frontend_attach\n- 被调用者: 未显示（外部函数）\n\n8. 函数名: state->dib7000p_ops.init\n- 参数: [&adap->dev->i2c_adap, 0x80, &nim7090_dib7000p_config]\n- 调用者: nim7090_frontend_attach\n- 被调用者: 未显示（通过函数指针调用）"
    },
    {
        "id": 1338,
        "cwe": "CWE-476",
        "cve": "CVE-2017-16646",
        "purpose": "Code purpose:\"\"\"该代码用于初始化并配置USB DVB设备的适配器前端，包括GPIO设置、I2C枚举和前端操作的重载，以支持特定的数字视频广播功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在未正确验证USB设备输入的情况下，直接使用来自USB设备的指针进行操作，导致空指针解引用或内存访问错误\"\"\"",
        "functions": "Functions:\n1. 函数名: novatd_frontend_attach\n- 参数: [struct dvb_usb_adapter *adap]\n- 调用者: 未指定\n- 被调用者: [dvb_attach, stk7070pd_init, dib0700_set_gpio, i2c_enumeration, dvb_detach, init, read_status, sleep]\n\n2. 函数名: dvb_attach\n- 参数: [dib7000p_attach, &state->dib7000p_ops]\n- 调用者: novatd_frontend_attach\n- 被调用者: 未指定\n\n3. 函数名: stk7070pd_init\n- 参数: [dev]\n- 调用者: novatd_frontend_attach\n- 被调用者: 未指定\n\n4. 函数名: dib0700_set_gpio\n- 参数: [dev, GPIO0, GPIO_OUT, 0], [dev, GPIO1, GPIO_OUT, 0], [dev, GPIO2, GPIO_OUT, 1]\n- 调用者: novatd_frontend_attach\n- 被调用者: 未指定\n\n5. 函数名: i2c_enumeration\n- 参数: [&dev->i2c_adap, 2, 18, stk7070pd_dib7000p_config]\n- 调用者: novatd_frontend_attach\n- 被调用者: 未指定\n\n6. 函数名: dvb_detach\n- 参数: [&state->dib7000p_ops]\n- 调用者: novatd_frontend_attach\n- 被调用者: 未指定\n\n7. 函数名: init\n- 参数: [&dev->i2c_adap, adap->id == 0 ? 0x80 : 0x82, &stk7070pd_dib7000p_config[adap->id]]\n- 调用者: novatd_frontend_attach\n- 被调用者: 未指定\n\n8. 函数名: read_status\n- 参数: 未指定\n- 调用者: novatd_frontend_attach\n- 被调用者: 未指定\n\n9. 函数名: sleep\n- 参数: 未指定\n- 调用者: novatd_frontend_attach\n- 被调用者: 未指定\n\n10. 函数名: novatd_read_status_override\n- 参数: 未指定\n- 调用者: novatd_frontend_attach\n- 被调用者: 未指定\n\n11. 函数名: novatd_sleep_override\n- 参数: 未指定\n- 调用者: novatd_frontend_attach\n- 被调用者: 未指定"
    },
    {
        "id": 1339,
        "cwe": "CWE-476",
        "cve": "CVE-2017-16646",
        "purpose": "Code purpose:\"\"\"该代码用于处理DVB USB适配器的前端附件操作，包括GPIO控制和I2C设备枚举，以初始化并配置前端设备。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码在未正确验证USB设备输入的情况下直接操作设备状态，导致空指针解引用或非法内存访问\"\"\"",
        "functions": "Functions:\n1. 函数名: stk7700P2_frontend_attach\n- 参数: [struct dvb_usb_adapter *adap]\n- 调用者: N/A (驱动初始化函数调用)\n- 被调用者: [dvb_attach, dib0700_set_gpio, msleep, i2c_enumeration, dvb_detach, init]\n\n2. 函数名: dvb_attach\n- 参数: [dib7000p_attach, &state->dib7000p_ops]\n- 调用者: stk7700P2_frontend_attach\n- 被调用者: N/A\n\n3. 函数名: dib0700_set_gpio\n- 参数: [adap->dev, GPIO6/GPIO9/GPIO4/GPIO7/GPIO10, GPIO_OUT, 1/0]\n- 调用者: stk7700P2_frontend_attach\n- 被调用者: N/A\n\n4. 函数名: msleep\n- 参数: [10]\n- 调用者: stk7700P2_frontend_attach\n- 被调用者: N/A\n\n5. 函数名: i2c_enumeration\n- 参数: [&adap->dev->i2c_adap, 1, 18, stk7700d_dib7000p_mt2266_config]\n- 调用者: state->dib7000p_ops (通过函数指针调用)\n- 被调用者: N/A\n\n6. 函数名: dvb_detach\n- 参数: [&state->dib7000p_ops]\n- 调用者: stk7700P2_frontend_attach\n- 被调用者: N/A\n\n7. 函数名: init\n- 参数: [&adap->dev->i2c_adap, 0x80 + (adap->id << 1), &stk7700d_dib7000p_mt2266_config[adap->id]]\n- 调用者: state->dib7000p_ops (通过函数指针调用)\n- 被调用者: N/A"
    },
    {
        "id": 1340,
        "cwe": "CWE-476",
        "cve": "CVE-2017-16647",
        "purpose": "Code purpose:\"\"\"处理USB网络设备挂起时的操作，包括调用设备特定的挂起函数和通用USB网络挂起函数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未对usb_get_intfdata()返回的dev指针进行NULL检查，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: asix_suspend\n- 参数: [struct usb_interface *intf, pm_message_t message]\n- 调用者: 未显示（应为USB子系统调用）\n- 被调用者: [usb_get_intfdata, usbnet_suspend]\n\n2. 函数名: usb_get_intfdata\n- 参数: [struct usb_interface *intf]\n- 调用者: asix_suspend\n- 被调用者: 未显示（应为内核USB核心函数）\n\n3. 函数名: usbnet_suspend\n- 参数: [struct usb_interface *intf, pm_message_t message]\n- 调用者: asix_suspend\n- 被调用者: 未显示（应为USB网络驱动核心函数）"
    },
    {
        "id": 1341,
        "cwe": "CWE-476",
        "cve": "CVE-2017-16647",
        "purpose": "Code purpose:\"\"\"处理USB网络设备恢复时的回调函数，包括调用设备特定的恢复函数和通用的USB网络恢复函数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未对dev->driver_priv指针进行空指针检查，导致当该指针为空时可能引发空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: asix_resume\n- 参数: [struct usb_interface *intf]\n- 调用者: 未指定（由USB子系统调用）\n- 被调用者: [usb_get_intfdata, usbnet_resume]\n\n2. 函数名: usb_get_intfdata\n- 参数: [struct usb_interface *intf]\n- 调用者: asix_resume\n- 被调用者: []\n\n3. 函数名: usbnet_resume\n- 参数: [struct usb_interface *intf]\n- 调用者: asix_resume\n- 被调用者: []"
    },
    {
        "id": 1351,
        "cwe": "CWE-476",
        "cve": "CVE-2017-16914",
        "purpose": "Code purpose:\"\"\"该代码用于处理USB/IP协议中从主机到设备的返回提交请求，负责构建和发送包含USB请求块(URB)数据的TCP消息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理特制的USB over IP数据包时，由于未对urb->iso_frame_desc指针进行空指针检查，导致可能发生空指针解引用，造成拒绝服务。\"\"\"",
        "functions": "Functions:\n1. 函数名: stub_send_ret_submit\n- 参数: [struct stub_device *sdev]\n- 调用者: 未显示\n- 被调用者: [dequeue_from_priv_tx, usb_pipetype, kcalloc, setup_ret_submit_pdu, usbip_dbg_stub_tx, usbip_header_correct_endian, usb_pipein, dev_err, kfree, usbip_event_add, usbip_alloc_iso_desc_pdu, kernel_sendmsg, spin_lock_irqsave, list_for_each_entry_safe, stub_free_priv_and_urb, spin_unlock_irqrestore]\n\n2. 函数名: dequeue_from_priv_tx\n- 参数: [struct stub_device *sdev]\n- 调用者: stub_send_ret_submit\n- 被调用者: 未显示\n\n3. 函数名: usb_pipetype\n- 参数: [urb->pipe]\n- 调用者: stub_send_ret_submit\n- 被调用者: 未显示\n\n4. 函数名: kcalloc\n- 参数: [iovnum, sizeof(struct kvec), GFP_KERNEL]\n- 调用者: stub_send_ret_submit\n- 被调用者: 未显示\n\n5. 函数名: setup_ret_submit_pdu\n- 参数: [&pdu_header, urb]\n- 调用者: stub_send_ret_submit\n- 被调用者: 未显示\n\n6. 函数名: usbip_dbg_stub_tx\n- 参数: [\"setup txdata seqnum: %d urb: %p\\n\", pdu_header.base.seqnum, urb]\n- 调用者: stub_send_ret_submit\n- 被调用者: 未显示\n\n7. 函数名: usbip_header_correct_endian\n- 参数: [&pdu_header, 1]\n- 调用者: stub_send_ret_submit\n- 被调用者: 未显示\n\n8. 函数名: usb_pipein\n- 参数: [urb->pipe]\n- 调用者: stub_send_ret_submit\n- 被调用者: 未显示\n\n9. 函数名: dev_err\n- 参数: [&sdev->udev->dev, \"actual length of urb %d does not match iso packet sizes %zu\\n\", urb->actual_length, txsize-sizeof(pdu_header)]\n- 调用者: stub_send_ret_submit\n- 被调用者: 未显示\n\n10. 函数名: kfree\n- 参数: [iov], [iso_buffer]\n- 调用者: stub_send_ret_submit\n- 被调用者: 未显示\n\n11. 函数名: usbip_event_add\n- 参数: [&sdev->ud, SDEV_EVENT_ERROR_MALLOC], [&sdev->ud, SDEV_EVENT_ERROR_TCP]\n- 调用者: stub_send_ret_submit\n- 被调用者: 未显示\n\n12. 函数名: usbip_alloc_iso_desc_pdu\n- 参数: [urb, &len]\n- 调用者: stub_send_ret_submit\n- 被调用者: 未显示\n\n13. 函数名: kernel_sendmsg\n- 参数: [sdev->ud.tcp_socket, &msg, iov, iovnum, txsize]\n- 调用者: stub_send_ret_submit\n- 被调用者: 未显示\n\n14. 函数名: spin_lock_irqsave\n- 参数: [&sdev->priv_lock, flags]\n- 调用者: stub_send_ret_submit\n- 被调用者: 未显示\n\n15. 函数名: list_for_each_entry_safe\n- 参数: [priv, tmp, &sdev->priv_free, list]\n- 调用者: stub_send_ret_submit\n- 被调用者: 未显示\n\n16. 函数名: stub_free_priv_and_urb\n- 参数: [priv]\n- 调用者: stub_send_ret_submit\n- 被调用者: 未显示\n\n17. 函数名: spin_unlock_irqrestore\n- 参数: [&sdev->priv_lock, flags]\n- 调用者: stub_send_ret_submit\n- 被调用者: 未显示"
    },
    {
        "id": 1389,
        "cwe": "CWE-476",
        "cve": "CVE-2017-18079",
        "purpose": "Code purpose:\"\"\"处理i8042键盘控制器的中断请求，读取并转发键盘或鼠标的输入数据，同时处理可能出现的错误状态。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在验证port->exists值后，该值可能被改变，导致后续使用时出现空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: i8042_interrupt\n- 参数: [irq, dev_id]\n- 调用者: 中断处理程序\n- 被调用者: [i8042_read_status, i8042_read_data, spin_lock_irqsave, spin_unlock_irqrestore, dbg, time_before, filter_dbg, i8042_filter, serio_interrupt, IRQ_RETVAL]\n\n2. 函数名: i8042_read_status\n- 参数: []\n- 调用者: i8042_interrupt\n- 被调用者: []\n\n3. 函数名: i8042_read_data\n- 参数: []\n- 调用者: i8042_interrupt\n- 被调用者: []\n\n4. 函数名: spin_lock_irqsave\n- 参数: [&i8042_lock, flags]\n- 调用者: i8042_interrupt\n- 被调用者: []\n\n5. 函数名: spin_unlock_irqrestore\n- 参数: [&i8042_lock, flags]\n- 调用者: i8042_interrupt\n- 被调用者: []\n\n6. 函数名: dbg\n- 参数: [\"Interrupt %d, without any data\\n\", irq]\n- 调用者: i8042_interrupt\n- 被调用者: []\n\n7. 函数名: time_before\n- 参数: [jiffies, last_transmit + HZ/10]\n- 调用者: i8042_interrupt\n- 被调用者: []\n\n8. 函数名: filter_dbg\n- 参数: [port->driver_bound, data, \"<- i8042 (interrupt, %d, %d%s%s)\\n\", port_no, irq, dfl & SERIO_PARITY ? \", bad parity\" : \"\", dfl & SERIO_TIMEOUT ? \", timeout\" : \"\"]\n- 调用者: i8042_interrupt\n- 被调用者: []\n\n9. 函数名: i8042_filter\n- 参数: [data, str, serio]\n- 调用者: i8042_interrupt\n- 被调用者: []\n\n10. 函数名: serio_interrupt\n- 参数: [serio, data, dfl]\n- 调用者: i8042_interrupt\n- 被调用者: []\n\n11. 函数名: IRQ_RETVAL\n- 参数: [ret]\n- 调用者: i8042_interrupt\n- 被调用者: []"
    },
    {
        "id": 1390,
        "cwe": "CWE-476",
        "cve": "CVE-2017-18079",
        "purpose": "Code purpose:\"\"\"该代码片段用于停止i8042控制器的串行端口操作，包括标记端口不存在、同步中断请求以及清空端口指针。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于port->exists的值在验证后可能被改变，导致后续操作中出现空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: i8042_stop\n- 参数: [struct serio *serio]\n- 调用者: 未明确显示（通常由serio子系统调用）\n- 被调用者: [synchronize_irq]\n\n2. 函数名: synchronize_irq\n- 参数: [int irq]\n- 调用者: [i8042_stop]\n- 被调用者: 未明确显示（内核中断处理函数）"
    },
    {
        "id": 1391,
        "cwe": "CWE-476",
        "cve": "CVE-2017-18079",
        "purpose": "Code purpose:\"\"\"该代码片段用于启动i8042键盘控制器端口，设置端口存在标志并确保内存屏障后返回成功状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在验证port->exists值后，该值可能被改变，导致空指针解引用和系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: i8042_start\n- 参数: [serio]\n- 调用者: 未明确（由内核调用）\n- 被调用者: []"
    },
    {
        "id": 1400,
        "cwe": "CWE-476",
        "cve": "CVE-2017-18216",
        "purpose": "Code purpose:\"\"\"该代码用于管理集群节点本地属性的设置，包括验证输入参数、处理节点本地状态变更以及控制网络监听服务的启停。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于代码中缺少必要的互斥锁保护，导致本地用户可能通过竞争条件引发空指针解引用，造成系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: o2nm_node_local_store\n- 参数: [struct config_item *item, const char *page, size_t count]\n- 调用者: 未明确显示（通常由文件系统配置接口调用）\n- 被调用者: [to_o2nm_node, to_o2nm_cluster_from_node, simple_strtoul, test_bit, o2net_start_listening, o2net_stop_listening]\n\n2. 函数名: to_o2nm_node\n- 参数: [struct config_item *item]\n- 调用者: o2nm_node_local_store\n- 被调用者: []\n\n3. 函数名: to_o2nm_cluster_from_node\n- 参数: [struct o2nm_node *node]\n- 调用者: o2nm_node_local_store\n- 被调用者: []\n\n4. 函数名: simple_strtoul\n- 参数: [char *p, char **p, int base]\n- 调用者: o2nm_node_local_store\n- 被调用者: []\n\n5. 函数名: test_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: o2nm_node_local_store\n- 被调用者: []\n\n6. 函数名: o2net_start_listening\n- 参数: [struct o2nm_node *node]\n- 调用者: o2nm_node_local_store\n- 被调用者: []\n\n7. 函数名: o2net_stop_listening\n- 参数: [struct o2nm_node *node]\n- 调用者: o2nm_node_local_store\n- 被调用者: []"
    },
    {
        "id": 1401,
        "cwe": "CWE-476",
        "cve": "CVE-2017-18216",
        "purpose": "Code purpose:\"\"\"该代码用于管理集群节点编号的存储操作，包括验证输入、检查节点属性设置状态，并将节点编号写入集群节点数组。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺少必要的互斥锁保护，导致在多线程环境下可能发生空指针解引用，造成系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: o2nm_node_num_store\n- 参数: [struct config_item *item, const char *page, size_t count]\n- 调用者: 未显示（通常由文件系统操作调用）\n- 被调用者: [to_o2nm_node, to_o2nm_cluster_from_node, simple_strtoul, test_bit, write_lock, test_and_set_bit, write_unlock]\n\n2. 函数名: to_o2nm_node\n- 参数: [struct config_item *item]\n- 调用者: o2nm_node_num_store\n- 被调用者: []\n\n3. 函数名: to_o2nm_cluster_from_node\n- 参数: [struct o2nm_node *node]\n- 调用者: o2nm_node_num_store\n- 被调用者: []\n\n4. 函数名: simple_strtoul\n- 参数: [char *p, char **endp, int base]\n- 调用者: o2nm_node_num_store\n- 被调用者: []\n\n5. 函数名: test_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: o2nm_node_num_store\n- 被调用者: []\n\n6. 函数名: write_lock\n- 参数: [rwlock_t *lock]\n- 调用者: o2nm_node_num_store\n- 被调用者: []\n\n7. 函数名: test_and_set_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: o2nm_node_num_store\n- 被调用者: []\n\n8. 函数名: write_unlock\n- 参数: [rwlock_t *lock]\n- 调用者: o2nm_node_num_store\n- 被调用者: []"
    },
    {
        "id": 1402,
        "cwe": "CWE-476",
        "cve": "CVE-2017-18216",
        "purpose": "Code purpose:\"\"\"该代码用于处理节点IPv4地址的存储操作，包括验证输入格式、检查地址范围、管理集群节点树中的IP地址插入，并更新节点属性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未使用必要的互斥锁保护共享资源，导致在多线程环境下可能发生空指针解引用和系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: o2nm_node_ipv4_address_store\n- 参数: [struct config_item *item, const char *page, size_t count]\n- 调用者: 未明确显示（通常由文件系统操作调用）\n- 被调用者: [to_o2nm_node, to_o2nm_cluster_from_node, sscanf, be32_add_cpu, write_lock, o2nm_node_ip_tree_lookup, test_and_set_bit, rb_link_node, rb_insert_color, write_unlock, memcpy]\n\n2. 函数名: to_o2nm_node\n- 参数: [struct config_item *item]\n- 调用者: o2nm_node_ipv4_address_store\n- 被调用者: 未显示\n\n3. 函数名: to_o2nm_cluster_from_node\n- 参数: [struct o2nm_node *node]\n- 调用者: o2nm_node_ipv4_address_store\n- 被调用者: 未显示\n\n4. 函数名: sscanf\n- 参数: [const char *page, \"%3u.%3u.%3u.%3u\", &octets[3], &octets[2], &octets[1], &octets[0]]\n- 调用者: o2nm_node_ipv4_address_store\n- 被调用者: 未显示\n\n5. 函数名: be32_add_cpu\n- 参数: [__be32 *ipv4_addr, unsigned int octets[i] << (i * 8)]\n- 调用者: o2nm_node_ipv4_address_store\n- 被调用者: 未显示\n\n6. 函数名: write_lock\n- 参数: [&cluster->cl_nodes_lock]\n- 调用者: o2nm_node_ipv4_address_store\n- 被调用者: 未显示\n\n7. 函数名: o2nm_node_ip_tree_lookup\n- 参数: [struct o2nm_cluster *cluster, __be32 ipv4_addr, struct rb_node ***p, struct rb_node **parent]\n- 调用者: o2nm_node_ipv4_address_store\n- 被调用者: 未显示\n\n8. 函数名: test_and_set_bit\n- 参数: [O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes]\n- 调用者: o2nm_node_ipv4_address_store\n- 被调用者: 未显示\n\n9. 函数名: rb_link_node\n- 参数: [&node->nd_ip_node, parent, p]\n- 调用者: o2nm_node_ipv4_address_store\n- 被调用者: 未显示\n\n10. 函数名: rb_insert_color\n- 参数: [&node->nd_ip_node, &cluster->cl_node_ip_tree]\n- 调用者: o2nm_node_ipv4_address_store\n- 被调用者: 未显示\n\n11. 函数名: write_unlock\n- 参数: [&cluster->cl_nodes_lock]\n- 调用者: o2nm_node_ipv4_address_store\n- 被调用者: 未显示\n\n12. 函数名: memcpy\n- 参数: [&node->nd_ipv4_address, &ipv4_addr, sizeof(ipv4_addr)]\n- 调用者: o2nm_node_ipv4_address_store\n- 被调用者: 未显示"
    },
    {
        "id": 1403,
        "cwe": "CWE-476",
        "cve": "CVE-2017-18216",
        "purpose": "Code purpose:\"\"\"通过节点结构体中的父指针链获取所属集群结构体\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未使用必要的互斥锁保护，导致在多线程环境下可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: to_o2nm_cluster_from_node\n- 参数: [struct o2nm_node *node]\n- 调用者: 未提供（上下文不足）\n- 被调用者: [to_o2nm_cluster]\n\n2. 函数名: to_o2nm_cluster\n- 参数: [未明确显示参数类型，但接收node->nd_item.ci_parent->ci_parent]\n- 调用者: to_o2nm_cluster_from_node\n- 被调用者: 未提供（上下文不足）"
    },
    {
        "id": 1423,
        "cwe": "CWE-476",
        "cve": "CVE-2017-18241",
        "purpose": "Code purpose:\"\"\"该代码用于创建和管理F2FS文件系统的刷新命令控制结构，包括初始化线程和处理刷新操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当使用noflush_merge选项时，flush_cmd_control数据结构可能为NULL值，导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: create_flush_cmd_control\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: 未明确显示（应为f2fs文件系统相关代码）\n- 被调用者: [kzalloc, atomic_set, init_waitqueue_head, init_llist_head, kthread_run, IS_ERR, PTR_ERR, kfree, MAJOR, MINOR]\n\n2. 函数名: issue_flush_thread\n- 参数: 未明确显示（通过kthread_run间接调用）\n- 调用者: create_flush_cmd_control（通过kthread_run调用）\n- 被调用者: 未明确显示\n\n3. 函数名: kzalloc\n- 参数: [sizeof(struct flush_cmd_control), GFP_KERNEL]\n- 调用者: create_flush_cmd_control\n- 被调用者: 未明确显示（内核内存分配函数）\n\n4. 函数名: atomic_set\n- 参数: [&fcc->issued_flush, 0], [&fcc->issing_flush, 0]\n- 调用者: create_flush_cmd_control\n- 被调用者: 未明确显示（内核原子操作函数）\n\n5. 函数名: init_waitqueue_head\n- 参数: [&fcc->flush_wait_queue]\n- 调用者: create_flush_cmd_control\n- 被调用者: 未明确显示（内核等待队列初始化函数）\n\n6. 函数名: init_llist_head\n- 参数: [&fcc->issue_list]\n- 调用者: create_flush_cmd_control\n- 被调用者: 未明确显示（内核链表初始化函数）\n\n7. 函数名: kthread_run\n- 参数: [issue_flush_thread, sbi, \"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev)]\n- 调用者: create_flush_cmd_control\n- 被调用者: 未明确显示（内核线程创建函数）\n\n8. 函数名: IS_ERR\n- 参数: [fcc->f2fs_issue_flush]\n- 调用者: create_flush_cmd_control\n- 被调用者: 未明确显示（内核错误检查函数）\n\n9. 函数名: PTR_ERR\n- 参数: [fcc->f2fs_issue_flush]\n- 调用者: create_flush_cmd_control\n- 被调用者: 未明确显示（内核指针错误转换函数）\n\n10. 函数名: kfree\n- 参数: [fcc]\n- 调用者: create_flush_cmd_control\n- 被调用者: 未明确显示（内核内存释放函数）\n\n11. 函数名: MAJOR\n- 参数: [dev]\n- 调用者: create_flush_cmd_control\n- 被调用者: 未明确显示（设备号主设备号提取函数）\n\n12. 函数名: MINOR\n- 参数: [dev]\n- 调用者: create_flush_cmd_control\n- 被调用者: 未明确显示（设备号次设备号提取函数）"
    },
    {
        "id": 1424,
        "cwe": "CWE-476",
        "cve": "CVE-2017-18241",
        "purpose": "Code purpose:\"\"\"初始化F2FS文件系统的段管理器，包括分配内存、设置段信息、创建刷新和丢弃命令控制结构，以及构建段信息表等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当使用noflush_merge选项时，未正确初始化flush_cmd_control数据结构，导致后续操作中出现空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: build_segment_manager\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: 未显示\n- 被调用者: [kzalloc, le32_to_cpu, test_opt, f2fs_readonly, create_flush_cmd_control, create_discard_cmd_control, build_sit_info, build_free_segmap, build_curseg, build_sit_entries, init_free_segmap, build_dirty_segmap, init_min_max_mtime]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(struct f2fs_sm_info), GFP_KERNEL]\n- 调用者: build_segment_manager\n- 被调用者: 未显示\n\n3. 函数名: le32_to_cpu\n- 参数: [raw_super->segment0_blkaddr, raw_super->main_blkaddr, raw_super->segment_count, ckpt->rsvd_segment_count, ckpt->overprov_segment_count, raw_super->segment_count_main, raw_super->ssa_blkaddr]\n- 调用者: build_segment_manager\n- 被调用者: 未显示\n\n4. 函数名: test_opt\n- 参数: [sbi, LFS]\n- 调用者: build_segment_manager\n- 被调用者: 未显示\n\n5. 函数名: f2fs_readonly\n- 参数: [sbi->sb]\n- 调用者: build_segment_manager\n- 被调用者: 未显示\n\n6. 函数名: create_flush_cmd_control\n- 参数: [sbi]\n- 调用者: build_segment_manager\n- 被调用者: 未显示\n\n7. 函数名: create_discard_cmd_control\n- 参数: [sbi]\n- 调用者: build_segment_manager\n- 被调用者: 未显示\n\n8. 函数名: build_sit_info\n- 参数: [sbi]\n- 调用者: build_segment_manager\n- 被调用者: 未显示\n\n9. 函数名: build_free_segmap\n- 参数: [sbi]\n- 调用者: build_segment_manager\n- 被调用者: 未显示\n\n10. 函数名: build_curseg\n- 参数: [sbi]\n- 调用者: build_segment_manager\n- 被调用者: 未显示\n\n11. 函数名: build_sit_entries\n- 参数: [sbi]\n- 调用者: build_segment_manager\n- 被调用者: 未显示\n\n12. 函数名: init_free_segmap\n- 参数: [sbi]\n- 调用者: build_segment_manager\n- 被调用者: 未显示\n\n13. 函数名: build_dirty_segmap\n- 参数: [sbi]\n- 调用者: build_segment_manager\n- 被调用者: 未显示\n\n14. 函数名: init_min_max_mtime\n- 参数: [sbi]\n- 调用者: build_segment_manager\n- 被调用者: 未显示"
    },
    {
        "id": 1449,
        "cwe": "CWE-476",
        "cve": "CVE-2017-2634",
        "purpose": "Code purpose:\"\"\"该代码片段用于在DCCP协议中发送重置包，但错误地在IPv6连接上使用了仅支持IPv4的inet_sk_rebuild_header()函数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核的DCCP实现在处理IPv6连接时错误地使用了仅支持IPv4的inet_sk_rebuild_header()函数，导致内存损坏漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: dccp_send_reset\n- 参数: [struct sock *sk, enum dccp_reset_codes code]\n- 调用者: 未指定\n- 被调用者: [inet_sk_rebuild_header, sock_wmalloc, skb_reserve, dccp_transmit_skb]\n\n2. 函数名: inet_sk_rebuild_header\n- 参数: [struct sock *sk]\n- 调用者: dccp_send_reset\n- 被调用者: 未指定\n\n3. 函数名: sock_wmalloc\n- 参数: [struct sock *sk, sk->sk_prot->max_header, 1, GFP_ATOMIC]\n- 调用者: dccp_send_reset\n- 被调用者: 未指定\n\n4. 函数名: skb_reserve\n- 参数: [struct sk_buff *skb, sk->sk_prot->max_header]\n- 调用者: dccp_send_reset\n- 被调用者: 未指定\n\n5. 函数名: dccp_transmit_skb\n- 参数: [struct sock *sk, struct sk_buff *skb]\n- 调用者: dccp_send_reset\n- 被调用者: 未指定"
    },
    {
        "id": 1450,
        "cwe": "CWE-476",
        "cve": "CVE-2017-2647",
        "purpose": "Code purpose:\"\"\"该代码片段用于初始化密钥匹配数据中的查找类型为迭代查找\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对match_data参数进行NULL指针检查，导致可能发生空指针解引用，引发权限提升或系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: asymmetric_key_match_preparse\n- 参数: [struct key_match_data *match_data]\n- 调用者: 未明确（由KEYS子系统调用）\n- 被调用者: []"
    },
    {
        "id": 1451,
        "cwe": "CWE-476",
        "cve": "CVE-2017-2647",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的KEYS子系统中创建或更新密钥，并处理密钥环的相关操作，包括密钥的实例化、权限检查和链接等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当key_type结构体中的match字段为NULL时，未进行充分验证导致空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: key_create_or_update\n- 参数: [key_ref_t keyring_ref, const char *type, const char *description, const void *payload, size_t plen, key_perm_t perm, unsigned long flags]\n- 调用者: N/A (top-level function)\n- 被调用者: [key_type_lookup, key_ref_to_ptr, key_check, key_permission, find_key_to_update, key_alloc, __key_instantiate_and_link, make_key_ref, __key_link_begin, __key_link_end, key_type_put, key_put, ERR_PTR, IS_ERR, ERR_CAST, memset, strlen, test_bit]\n\n2. 函数名: key_type_lookup\n- 参数: [const char *type]\n- 调用者: key_create_or_update\n- 被调用者: N/A\n\n3. 函数名: key_ref_to_ptr\n- 参数: [key_ref_t keyring_ref]\n- 调用者: key_create_or_update\n- 被调用者: N/A\n\n4. 函数名: key_check\n- 参数: [struct key *keyring]\n- 调用者: key_create_or_update\n- 被调用者: N/A\n\n5. 函数名: key_permission\n- 参数: [key_ref_t keyring_ref, KEY_NEED_WRITE]\n- 调用者: key_create_or_update\n- 被调用者: N/A\n\n6. 函数名: find_key_to_update\n- 参数: [key_ref_t keyring_ref, struct keyring_index_key *index_key]\n- 调用者: key_create_or_update\n- 被调用者: N/A\n\n7. 函数名: key_alloc\n- 参数: [struct key_type *type, const char *description, uid_t cred->fsuid, gid_t cred->fsgid, const struct cred *cred, key_perm_t perm, unsigned long flags]\n- 调用者: key_create_or_update\n- 被调用者: N/A\n\n8. 函数名: __key_instantiate_and_link\n- 参数: [struct key *key, struct key_preparsed_payload *prep, struct key *keyring, NULL, struct assoc_array_edit **edit]\n- 调用者: key_create_or_update\n- 被调用者: N/A\n\n9. 函数名: make_key_ref\n- 参数: [struct key *key, is_key_possessed(keyring_ref)]\n- 调用者: key_create_or_update\n- 被调用者: N/A\n\n10. 函数名: __key_link_begin\n- 参数: [struct key *keyring, struct keyring_index_key *index_key, struct assoc_array_edit **edit]\n- 调用者: key_create_or_update\n- 被调用者: N/A\n\n11. 函数名: __key_link_end\n- 参数: [struct key *keyring, struct keyring_index_key *index_key, struct assoc_array_edit *edit]\n- 调用者: key_create_or_update\n- 被调用者: N/A\n\n12. 函数名: key_type_put\n- 参数: [struct key_type *type]\n- 调用者: key_create_or_update\n- 被调用者: N/A\n\n13. 函数名: key_put\n- 参数: [struct key *key]\n- 调用者: key_create_or_update\n- 被调用者: N/A\n\n14. 函数名: __key_update\n- 参数: [key_ref_t key_ref, struct key_preparsed_payload *prep]\n- 调用者: key_create_or_update\n- 被调用者: N/A"
    },
    {
        "id": 1452,
        "cwe": "CWE-476",
        "cve": "CVE-2017-2647",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的KEYS子系统中搜索匹配特定类型和描述符的密钥环(keyring)\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当key_type结构体中的match字段为NULL时，未进行充分检查导致空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: keyring_search\n- 参数: [key_ref_t keyring, struct key_type *type, const char *description]\n- 调用者: 未指定\n- 被调用者: [ERR_PTR, type->match_preparse, keyring_search_aux, type->match_free]\n\n2. 函数名: ERR_PTR\n- 参数: [long error]\n- 调用者: keyring_search\n- 被调用者: 未指定\n\n3. 函数名: type->match_preparse\n- 参数: [struct keyring_search_context *ctx.match_data]\n- 调用者: keyring_search\n- 被调用者: 未指定\n\n4. 函数名: keyring_search_aux\n- 参数: [key_ref_t keyring, struct keyring_search_context *ctx]\n- 调用者: keyring_search\n- 被调用者: 未指定\n\n5. 函数名: type->match_free\n- 参数: [struct keyring_search_context *ctx.match_data]\n- 调用者: keyring_search\n- 被调用者: 未指定"
    },
    {
        "id": 1453,
        "cwe": "CWE-476",
        "cve": "CVE-2017-2647",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中请求并链接密钥，包括搜索进程密钥环、构造密钥以及在找到密钥时将其链接到目标密钥环\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当key_type结构体中的match字段为NULL时，会导致空指针解引用，从而引发系统崩溃或权限提升\"\"\"",
        "functions": "Functions:\n1. 函数名: request_key_and_link\n- 参数: [struct key_type *type, const char *description, const void *callout_info, size_t callout_len, void *aux, struct key *dest_keyring, unsigned long flags]\n- 调用者: N/A (顶层函数)\n- 被调用者: [ERR_PTR, search_process_keyrings, key_ref_to_ptr, construct_get_dest_keyring, key_link, key_put, ERR_CAST, construct_key_and_link, type->match_free, kleave]\n\n2. 函数名: search_process_keyrings\n- 参数: [struct keyring_search_context *ctx]\n- 调用者: request_key_and_link\n- 被调用者: N/A (假设是外部函数)\n\n3. 函数名: key_ref_to_ptr\n- 参数: [key_ref_t key_ref]\n- 调用者: request_key_and_link\n- 被调用者: N/A (假设是外部函数)\n\n4. 函数名: construct_get_dest_keyring\n- 参数: [struct key **dest_keyring]\n- 调用者: request_key_and_link\n- 被调用者: N/A (假设是外部函数)\n\n5. 函数名: key_link\n- 参数: [struct key *dest_keyring, struct key *key]\n- 调用者: request_key_and_link\n- 被调用者: N/A (假设是外部函数)\n\n6. 函数名: key_put\n- 参数: [struct key *key]\n- 调用者: request_key_and_link\n- 被调用者: N/A (假设是外部函数)\n\n7. 函数名: ERR_CAST\n- 参数: [key_ref_t key_ref]\n- 调用者: request_key_and_link\n- 被调用者: N/A (宏或外部函数)\n\n8. 函数名: construct_key_and_link\n- 参数: [struct keyring_search_context *ctx, const void *callout_info, size_t callout_len, void *aux, struct key *dest_keyring, unsigned long flags]\n- 调用者: request_key_and_link\n- 被调用者: N/A (假设是外部函数)\n\n9. 函数名: kleave\n- 参数: [const char *fmt, ...]\n- 调用者: request_key_and_link\n- 被调用者: N/A (假设是宏或外部函数)\n\n10. 函数名: type->match_preparse\n- 参数: [struct keyring_search_context.match_data *match_data]\n- 调用者: request_key_and_link\n- 被调用者: N/A (函数指针)\n\n11. 函数名: type->match_free\n- 参数: [struct keyring_search_context.match_data *match_data]\n- 调用者: request_key_and_link\n- 被调用者: N/A (函数指针)"
    },
    {
        "id": 1454,
        "cwe": "CWE-476",
        "cve": "CVE-2017-2647",
        "purpose": "Code purpose:\"\"\"该代码用于通过目标ID获取密钥实例化的授权密钥，涉及密钥环搜索和权限验证\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对search_process_keyrings函数返回的authkey_ref进行有效NULL指针检查，导致可能发生空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: key_get_instantiation_authkey\n- 参数: [key_serial_t target_id]\n- 调用者: N/A (顶层函数)\n- 被调用者: [sprintf, search_process_keyrings, ERR_CAST, ERR_PTR, key_ref_to_ptr, test_bit, key_put]\n\n2. 函数名: sprintf\n- 参数: [description, \"%x\", target_id]\n- 调用者: key_get_instantiation_authkey\n- 被调用者: []\n\n3. 函数名: search_process_keyrings\n- 参数: [&ctx]\n- 调用者: key_get_instantiation_authkey\n- 被调用者: []\n\n4. 函数名: ERR_CAST\n- 参数: [authkey_ref]\n- 调用者: key_get_instantiation_authkey\n- 被调用者: []\n\n5. 函数名: ERR_PTR\n- 参数: [-EAGAIN], [-ENOKEY], [-EKEYREVOKED]\n- 调用者: key_get_instantiation_authkey\n- 被调用者: []\n\n6. 函数名: key_ref_to_ptr\n- 参数: [authkey_ref]\n- 调用者: key_get_instantiation_authkey\n- 被调用者: []\n\n7. 函数名: test_bit\n- 参数: [KEY_FLAG_REVOKED, &authkey->flags]\n- 调用者: key_get_instantiation_authkey\n- 被调用者: []\n\n8. 函数名: key_put\n- 参数: [authkey]\n- 调用者: key_get_instantiation_authkey\n- 被调用者: []"
    },
    {
        "id": 1474,
        "cwe": "CWE-476",
        "cve": "CVE-2017-5970",
        "purpose": "Code purpose:\"\"\"该代码用于准备IPv4数据包信息，包括处理接口索引和特定目的地址，并在特定条件下更新这些信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ipv4_pktinfo_prepare函数中，当处理带有无效IP选项的IPv4流量时，未充分验证skb_rtable(skb)返回的指针，可能导致空指针解引用引发系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: ipv4_pktinfo_prepare\n- 参数: [const struct sock *sk, struct sk_buff *skb]\n- 调用者: 未明确（由内核网络栈调用）\n- 被调用者: [inet_sk, ipv6_sk_rxinfo, skb_rtable, inet_iif, fib_compute_spec_dst, skb_dst_drop]\n\n2. 函数名: inet_sk\n- 参数: [const struct sock *sk]\n- 调用者: ipv4_pktinfo_prepare\n- 被调用者: []\n\n3. 函数名: ipv6_sk_rxinfo\n- 参数: [const struct sock *sk]\n- 调用者: ipv4_pktinfo_prepare\n- 被调用者: []\n\n4. 函数名: skb_rtable\n- 参数: [struct sk_buff *skb]\n- 调用者: ipv4_pktinfo_prepare\n- 被调用者: []\n\n5. 函数名: inet_iif\n- 参数: [struct sk_buff *skb]\n- 调用者: ipv4_pktinfo_prepare\n- 被调用者: []\n\n6. 函数名: fib_compute_spec_dst\n- 参数: [struct sk_buff *skb]\n- 调用者: ipv4_pktinfo_prepare\n- 被调用者: []\n\n7. 函数名: skb_dst_drop\n- 参数: [struct sk_buff *skb]\n- 调用者: ipv4_pktinfo_prepare\n- 被调用者: []"
    },
    {
        "id": 1497,
        "cwe": "CWE-476",
        "cve": "CVE-2017-7374",
        "purpose": "Code purpose:\"\"\"验证加密文件系统中目录项的有效性，检查密钥状态以确定是否允许访问\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在密钥被撤销后，代码未正确处理加密信息对象(ci)的释放，导致后续可能引用已释放的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: fscrypt_d_revalidate\n- 参数: [struct dentry *dentry, unsigned int flags]\n- 调用者: 未明确显示（通常由文件系统调用）\n- 被调用者: [dget_parent, d_inode, dput, spin_lock, spin_unlock, d_is_negative]\n\n2. 函数名: dget_parent\n- 参数: [struct dentry *dentry]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: 未显示\n\n3. 函数名: d_inode\n- 参数: [struct dentry *dentry]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: 未显示\n\n4. 函数名: dput\n- 参数: [struct dentry *dentry]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: 未显示\n\n5. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: 未显示\n\n6. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: 未显示\n\n7. 函数名: d_is_negative\n- 参数: [const struct dentry *dentry]\n- 调用者: fscrypt_d_revalidate\n- 被调用者: 未显示"
    },
    {
        "id": 1498,
        "cwe": "CWE-476",
        "cve": "CVE-2017-7374",
        "purpose": "Code purpose:\"\"\"该代码用于处理Linux内核中文件系统加密相关的文件名设置，包括加密文件名分配、加密操作以及解密处理等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当密钥环中的密钥被撤销时，加密转换对象被过早释放，导致后续使用时出现空指针解引用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: fscrypt_setup_filename\n- 参数: [struct inode *dir, const struct qstr *iname, int lookup, struct fscrypt_name *fname]\n- 调用者: 未显示\n- 被调用者: [memset, fscrypt_is_dot_dotdot, fscrypt_get_crypt_info, fscrypt_fname_alloc_buffer, fname_encrypt, kmalloc, digest_decode, memcpy, fscrypt_fname_free_buffer]\n\n2. 函数名: memset\n- 参数: [fname, 0, sizeof(struct fscrypt_name)]\n- 调用者: fscrypt_setup_filename\n- 被调用者: []\n\n3. 函数名: fscrypt_is_dot_dotdot\n- 参数: [iname]\n- 调用者: fscrypt_setup_filename\n- 被调用者: []\n\n4. 函数名: fscrypt_get_crypt_info\n- 参数: [dir]\n- 调用者: fscrypt_setup_filename\n- 被调用者: []\n\n5. 函数名: fscrypt_fname_alloc_buffer\n- 参数: [dir, iname->len, &fname->crypto_buf]\n- 调用者: fscrypt_setup_filename\n- 被调用者: []\n\n6. 函数名: fname_encrypt\n- 参数: [dir, iname, &fname->crypto_buf]\n- 调用者: fscrypt_setup_filename\n- 被调用者: []\n\n7. 函数名: kmalloc\n- 参数: [32, GFP_KERNEL]\n- 调用者: fscrypt_setup_filename\n- 被调用者: []\n\n8. 函数名: digest_decode\n- 参数: [iname->name + bigname, iname->len - bigname, fname->crypto_buf.name]\n- 调用者: fscrypt_setup_filename\n- 被调用者: []\n\n9. 函数名: memcpy\n- 参数: [&fname->hash, fname->crypto_buf.name, 4]\n- 调用者: fscrypt_setup_filename\n- 被调用者: []\n\n10. 函数名: memcpy\n- 参数: [&fname->minor_hash, fname->crypto_buf.name + 4, 4]\n- 调用者: fscrypt_setup_filename\n- 被调用者: []\n\n11. 函数名: fscrypt_fname_free_buffer\n- 参数: [&fname->crypto_buf]\n- 调用者: fscrypt_setup_filename\n- 被调用者: []"
    },
    {
        "id": 1499,
        "cwe": "CWE-476",
        "cve": "CVE-2017-7374",
        "purpose": "Code purpose:\"\"\"该代码用于检查inode的加密信息是否有效，若无效则重新获取加密信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在密钥被撤销后未正确检查密钥状态，导致可能使用已释放的加密转换对象，引发空指针解引用或权限提升问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: fscrypt_get_encryption_info\n- 参数: [struct inode *inode]\n- 调用者: 未显示（由内核其他部分调用）\n- 被调用者: [fscrypt_get_crypt_info]\n\n2. 函数名: fscrypt_get_crypt_info\n- 参数: [struct inode *inode]\n- 调用者: [fscrypt_get_encryption_info]\n- 被调用者: 未显示"
    },
    {
        "id": 1500,
        "cwe": "CWE-476",
        "cve": "CVE-2017-7374",
        "purpose": "Code purpose:\"\"\"验证用户提供的加密密钥并派生新的加密密钥用于文件系统加密\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当密钥环密钥被撤销时，内核未能正确处理仍在使用的加密转换对象，导致提前释放后仍被访问的use-after-free漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: validate_user_key\n- 参数: [struct fscrypt_info *crypt_info, struct fscrypt_context *ctx, u8 *raw_key, const char *prefix]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [kasprintf, request_key, kfree, IS_ERR, PTR_ERR, printk_once, down_read, user_key_payload, up_read, derive_key_aes, key_put]\n\n2. 函数名: kasprintf\n- 参数: [GFP_NOFS, \"%s%*phN\", prefix, FS_KEY_DESCRIPTOR_SIZE, ctx->master_key_descriptor]\n- 调用者: validate_user_key\n- 被调用者: 未显示（内核函数）\n\n3. 函数名: request_key\n- 参数: [&key_type_logon, description, NULL]\n- 调用者: validate_user_key\n- 被调用者: 未显示（内核函数）\n\n4. 函数名: kfree\n- 参数: [description]\n- 调用者: validate_user_key\n- 被调用者: 未显示（内核函数）\n\n5. 函数名: IS_ERR\n- 参数: [keyring_key]\n- 调用者: validate_user_key\n- 被调用者: 未显示（内核宏）\n\n6. 函数名: PTR_ERR\n- 参数: [keyring_key]\n- 调用者: validate_user_key\n- 被调用者: 未显示（内核宏）\n\n7. 函数名: printk_once\n- 参数: [KERN_WARNING, \"%s: key type must be logon\\n\", __func__]\n- 调用者: validate_user_key\n- 被调用者: 未显示（内核函数）\n\n8. 函数名: down_read\n- 参数: [&keyring_key->sem]\n- 调用者: validate_user_key\n- 被调用者: 未显示（内核函数）\n\n9. 函数名: user_key_payload\n- 参数: [keyring_key]\n- 调用者: validate_user_key\n- 被调用者: 未显示（内核函数）\n\n10. 函数名: up_read\n- 参数: [&keyring_key->sem]\n- 调用者: validate_user_key\n- 被调用者: 未显示（内核函数）\n\n11. 函数名: derive_key_aes\n- 参数: [ctx->nonce, master_key->raw, raw_key]\n- 调用者: validate_user_key\n- 被调用者: 未显示（内核函数）\n\n12. 函数名: key_put\n- 参数: [keyring_key]\n- 调用者: validate_user_key\n- 被调用者: 未显示（内核函数）"
    },
    {
        "id": 1501,
        "cwe": "CWE-476",
        "cve": "CVE-2017-7374",
        "purpose": "Code purpose:\"\"\"释放文件加密相关的密钥和加密转换对象的内存资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放加密信息结构体时未正确处理密钥环密钥和加密转换对象的引用计数，导致可能发生提前释放和后续使用已释放对象的情况。\"\"\"",
        "functions": "Functions:\n1. 函数名: put_crypt_info\n- 参数: [struct fscrypt_info *ci]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [key_put, crypto_free_skcipher, kmem_cache_free]\n\n2. 函数名: key_put\n- 参数: [ci->ci_keyring_key]\n- 调用者: put_crypt_info\n- 被调用者: 未明确\n\n3. 函数名: crypto_free_skcipher\n- 参数: [ci->ci_ctfm]\n- 调用者: put_crypt_info\n- 被调用者: 未明确\n\n4. 函数名: kmem_cache_free\n- 参数: [fscrypt_info_cachep, ci]\n- 调用者: put_crypt_info\n- 被调用者: 未明确"
    },
    {
        "id": 1550,
        "cwe": "CWE-476",
        "cve": "CVE-2017-8106",
        "purpose": "Code purpose:\"\"\"初始化嵌套虚拟化(VMX)的控制寄存器和MSR(模型特定寄存器)，设置虚拟机的各种控制位和功能支持。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"处理INVEPT指令时未对EPT指针进行空指针检查，导致当传入NULL指针时引发空指针解引用，造成系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: nested_vmx_setup_ctls_msrs\n- 参数: []\n- 调用者: __init\n- 被调用者: [rdmsr, vmx_mpx_supported]\n\n2. 函数名: rdmsr\n- 参数: [MSR_IA32_VMX_PINBASED_CTLS, nested_vmx_pinbased_ctls_low, nested_vmx_pinbased_ctls_high]\n- 调用者: nested_vmx_setup_ctls_msrs\n- 被调用者: []\n\n3. 函数名: rdmsr\n- 参数: [MSR_IA32_VMX_EXIT_CTLS, nested_vmx_exit_ctls_low, nested_vmx_exit_ctls_high]\n- 调用者: nested_vmx_setup_ctls_msrs\n- 被调用者: []\n\n4. 函数名: rdmsr\n- 参数: [MSR_IA32_VMX_ENTRY_CTLS, nested_vmx_entry_ctls_low, nested_vmx_entry_ctls_high]\n- 调用者: nested_vmx_setup_ctls_msrs\n- 被调用者: []\n\n5. 函数名: rdmsr\n- 参数: [MSR_IA32_VMX_PROCBASED_CTLS, nested_vmx_procbased_ctls_low, nested_vmx_procbased_ctls_high]\n- 调用者: nested_vmx_setup_ctls_msrs\n- 被调用者: []\n\n6. 函数名: rdmsr\n- 参数: [MSR_IA32_VMX_PROCBASED_CTLS2, nested_vmx_secondary_ctls_low, nested_vmx_secondary_ctls_high]\n- 调用者: nested_vmx_setup_ctls_msrs\n- 被调用者: []\n\n7. 函数名: rdmsr\n- 参数: [MSR_IA32_VMX_MISC, nested_vmx_misc_low, nested_vmx_misc_high]\n- 调用者: nested_vmx_setup_ctls_msrs\n- 被调用者: []\n\n8. 函数名: vmx_mpx_supported\n- 参数: []\n- 调用者: nested_vmx_setup_ctls_msrs\n- 被调用者: []"
    },
    {
        "id": 1551,
        "cwe": "CWE-476",
        "cve": "CVE-2017-8106",
        "purpose": "Code purpose:\"\"\"处理虚拟机监控程序中的INVEPT指令，用于刷新扩展页表(EPT)的转换缓存，但存在空指针解引用漏洞可能导致拒绝服务\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当处理单上下文INVEPT指令时，未对EPT指针进行NULL检查，导致空指针解引用引发系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: handle_invept\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: 未显示\n- 被调用者: [nested_vmx_secondary_ctls_high, nested_vmx_ept_caps, kvm_queue_exception, nested_vmx_check_permission, kvm_read_cr0_bits, vmcs_read32, kvm_register_read, nested_vmx_failValid, get_vmx_mem_address, vmcs_readl, kvm_read_guest_virt, kvm_inject_page_fault, nested_ept_get_cr3, kvm_mmu_sync_roots, kvm_mmu_flush_tlb, nested_vmx_succeed, skip_emulated_instruction]\n\n2. 函数名: kvm_queue_exception\n- 参数: [struct kvm_vcpu *vcpu, UD_VECTOR]\n- 调用者: handle_invept\n- 被调用者: 未显示\n\n3. 函数名: nested_vmx_check_permission\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: handle_invept\n- 被调用者: 未显示\n\n4. 函数名: kvm_read_cr0_bits\n- 参数: [struct kvm_vcpu *vcpu, X86_CR0_PE]\n- 调用者: handle_invept\n- 被调用者: 未显示\n\n5. 函数名: vmcs_read32\n- 参数: [VMX_INSTRUCTION_INFO]\n- 调用者: handle_invept\n- 被调用者: 未显示\n\n6. 函数名: kvm_register_read\n- 参数: [struct kvm_vcpu *vcpu, (vmx_instruction_info >> 28) & 0xf]\n- 调用者: handle_invept\n- 被调用者: 未显示\n\n7. 函数名: nested_vmx_failValid\n- 参数: [struct kvm_vcpu *vcpu, VMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID]\n- 调用者: handle_invept\n- 被调用者: 未显示\n\n8. 函数名: get_vmx_mem_address\n- 参数: [struct kvm_vcpu *vcpu, vmcs_readl(EXIT_QUALIFICATION), vmx_instruction_info, &gva]\n- 调用者: handle_invept\n- 被调用者: 未显示\n\n9. 函数名: vmcs_readl\n- 参数: [EXIT_QUALIFICATION]\n- 调用者: handle_invept\n- 被调用者: 未显示\n\n10. 函数名: kvm_read_guest_virt\n- 参数: [&vcpu->arch.emulate_ctxt, gva, &operand, sizeof(operand), &e]\n- 调用者: handle_invept\n- 被调用者: 未显示\n\n11. 函数名: kvm_inject_page_fault\n- 参数: [struct kvm_vcpu *vcpu, &e]\n- 调用者: handle_invept\n- 被调用者: 未显示\n\n12. 函数名: nested_ept_get_cr3\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: handle_invept\n- 被调用者: 未显示\n\n13. 函数名: kvm_mmu_sync_roots\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: handle_invept\n- 被调用者: 未显示\n\n14. 函数名: kvm_mmu_flush_tlb\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: handle_invept\n- 被调用者: 未显示\n\n15. 函数名: nested_vmx_succeed\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: handle_invept\n- 被调用者: 未显示\n\n16. 函数名: skip_emulated_instruction\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: handle_invept\n- 被调用者: 未显示"
    },
    {
        "id": 1568,
        "cwe": "CWE-476",
        "cve": "CVE-2017-9211",
        "purpose": "Code purpose:\"\"\"初始化对称密钥加密转换框架，设置加密/解密操作函数和密钥相关参数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于crypto_skcipher_init_tfm函数在初始化加密操作时未对setkey函数的密钥大小进行检查，导致本地用户可通过特制应用触发空指针解引用，造成拒绝服务。\"\"\"",
        "functions": "Functions:\n1. 函数名: crypto_skcipher_init_tfm\n- 参数: [struct crypto_tfm *tfm]\n- 调用者: 未明确显示（通常由内核加密子系统调用）\n- 被调用者: [__crypto_skcipher_cast, crypto_skcipher_alg, crypto_init_skcipher_ops_blkcipher, crypto_init_skcipher_ops_ablkcipher, crypto_skcipher_exit_tfm]\n\n2. 函数名: __crypto_skcipher_cast\n- 参数: [struct crypto_tfm *tfm]\n- 调用者: crypto_skcipher_init_tfm\n- 被调用者: []\n\n3. 函数名: crypto_skcipher_alg\n- 参数: [struct crypto_skcipher *skcipher]\n- 调用者: crypto_skcipher_init_tfm\n- 被调用者: []\n\n4. 函数名: crypto_init_skcipher_ops_blkcipher\n- 参数: [struct crypto_tfm *tfm]\n- 调用者: crypto_skcipher_init_tfm\n- 被调用者: []\n\n5. 函数名: crypto_init_skcipher_ops_ablkcipher\n- 参数: [struct crypto_tfm *tfm]\n- 调用者: crypto_skcipher_init_tfm\n- 被调用者: []\n\n6. 函数名: crypto_skcipher_exit_tfm\n- 参数: 未明确显示（通常接收struct crypto_tfm *参数）\n- 调用者: crypto_skcipher_init_tfm\n- 被调用者: []"
    },
    {
        "id": 1578,
        "cwe": "CWE-476",
        "cve": "CVE-2018-1000200",
        "purpose": "Code purpose:\"\"\"该代码用于在进程退出时释放其内存映射区域，包括解除内存锁定、刷新缓存、取消映射并释放页表等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在OOM killer终止进程时，exit_mmap()中munlock_vma_pages_all()与oom reaper的unmap_page_range()同步操作导致空指针解引用，因为vma的VM_LOCKED位在解锁前被清除。\"\"\"",
        "functions": "Functions:\n1. 函数名: exit_mmap\n- 参数: [struct mm_struct *mm]\n- 调用者: N/A\n- 被调用者: [mmu_notifier_release, munlock_vma_pages_all, arch_exit_mmap, lru_add_drain, flush_cache_mm, tlb_gather_mmu, unmap_vmas, down_write, up_write, free_pgtables, tlb_finish_mmu, remove_vma, vm_unacct_memory]\n\n2. 函数名: mmu_notifier_release\n- 参数: [struct mm_struct *mm]\n- 调用者: exit_mmap\n- 被调用者: N/A\n\n3. 函数名: munlock_vma_pages_all\n- 参数: [struct vm_area_struct *vma]\n- 调用者: exit_mmap\n- 被调用者: N/A\n\n4. 函数名: arch_exit_mmap\n- 参数: [struct mm_struct *mm]\n- 调用者: exit_mmap\n- 被调用者: N/A\n\n5. 函数名: lru_add_drain\n- 参数: []\n- 调用者: exit_mmap\n- 被调用者: N/A\n\n6. 函数名: flush_cache_mm\n- 参数: [struct mm_struct *mm]\n- 调用者: exit_mmap\n- 被调用者: N/A\n\n7. 函数名: tlb_gather_mmu\n- 参数: [struct mmu_gather *tlb, struct mm_struct *mm, unsigned long start, unsigned long end]\n- 调用者: exit_mmap\n- 被调用者: N/A\n\n8. 函数名: unmap_vmas\n- 参数: [struct mmu_gather *tlb, struct vm_area_struct *vma, unsigned long start_addr, unsigned long end_addr]\n- 调用者: exit_mmap\n- 被调用者: N/A\n\n9. 函数名: down_write\n- 参数: [struct rw_semaphore *sem]\n- 调用者: exit_mmap\n- 被调用者: N/A\n\n10. 函数名: up_write\n- 参数: [struct rw_semaphore *sem]\n- 调用者: exit_mmap\n- 被调用者: N/A\n\n11. 函数名: free_pgtables\n- 参数: [struct mmu_gather *tlb, struct vm_area_struct *vma, unsigned long floor, unsigned long ceiling]\n- 调用者: exit_mmap\n- 被调用者: N/A\n\n12. 函数名: tlb_finish_mmu\n- 参数: [struct mmu_gather *tlb, unsigned long start, unsigned long end]\n- 调用者: exit_mmap\n- 被调用者: N/A\n\n13. 函数名: remove_vma\n- 参数: [struct vm_area_struct *vma]\n- 调用者: exit_mmap\n- 被调用者: N/A\n\n14. 函数名: vm_unacct_memory\n- 参数: [long pages]\n- 调用者: exit_mmap\n- 被调用者: N/A"
    },
    {
        "id": 1579,
        "cwe": "CWE-476",
        "cve": "CVE-2018-1000200",
        "purpose": "Code purpose:\"\"\"该代码用于在内存不足时回收被OOM killer选中的进程的内存资源，并处理相关标记和引用计数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在oom_reap_task函数中，当处理oom_killed进程时，由于mm指针可能为NULL且未进行有效性检查，导致空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: oom_reap_task\n- 参数: [struct task_struct *tsk]\n- 调用者: 未明确显示（通常由OOM killer机制调用）\n- 被调用者: [__oom_reap_task_mm, schedule_timeout_idle, task_pid_nr, debug_show_all_locks, put_task_struct]\n\n2. 函数名: __oom_reap_task_mm\n- 参数: [struct task_struct *tsk, struct mm_struct *mm]\n- 调用者: oom_reap_task\n- 被调用者: 未显示\n\n3. 函数名: schedule_timeout_idle\n- 参数: [HZ/10]\n- 调用者: oom_reap_task\n- 被调用者: 未显示\n\n4. 函数名: task_pid_nr\n- 参数: [struct task_struct *tsk]\n- 调用者: oom_reap_task\n- 被调用者: 未显示\n\n5. 函数名: debug_show_all_locks\n- 参数: []\n- 调用者: oom_reap_task\n- 被调用者: 未显示\n\n6. 函数名: put_task_struct\n- 参数: [struct task_struct *tsk]\n- 调用者: oom_reap_task\n- 被调用者: 未显示"
    },
    {
        "id": 1584,
        "cwe": "CWE-476",
        "cve": "CVE-2018-10074",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中实现hi3660芯片的时钟桩模块初始化，包括邮箱通道申请、内存资源映射和时钟硬件注册等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在hi3660_stub_clk_probe函数中，未对platform_get_resource返回的资源指针进行NULL检查，导致当资源获取失败时可能引发空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: hi3660_stub_clk_probe\n- 参数: [struct platform_device *pdev]\n- 调用者: 内核平台驱动框架\n- 被调用者: [mbox_request_channel, platform_get_resource, devm_ioremap, resource_size, devm_clk_hw_register, devm_of_clk_add_hw_provider]\n\n2. 函数名: mbox_request_channel\n- 参数: [&stub_clk_chan.cl, 0]\n- 调用者: hi3660_stub_clk_probe\n- 被调用者: []\n\n3. 函数名: platform_get_resource\n- 参数: [pdev, IORESOURCE_MEM, 0]\n- 调用者: hi3660_stub_clk_probe\n- 被调用者: []\n\n4. 函数名: devm_ioremap\n- 参数: [dev, res->start, resource_size(res)]\n- 调用者: hi3660_stub_clk_probe\n- 被调用者: [resource_size]\n\n5. 函数名: resource_size\n- 参数: [res]\n- 调用者: devm_ioremap\n- 被调用者: []\n\n6. 函数名: devm_clk_hw_register\n- 参数: [&pdev->dev, &hi3660_stub_clks[i].hw]\n- 调用者: hi3660_stub_clk_probe\n- 被调用者: []\n\n7. 函数名: devm_of_clk_add_hw_provider\n- 参数: [&pdev->dev, hi3660_stub_clk_hw_get, hi3660_stub_clks]\n- 调用者: hi3660_stub_clk_probe\n- 被调用者: []"
    },
    {
        "id": 1587,
        "cwe": "CWE-476",
        "cve": "CVE-2018-10322",
        "purpose": "Code purpose:\"\"\"验证XFS文件系统中磁盘inode结构的有效性和完整性，防止无效或恶意构造的inode导致系统错误或安全漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"xfs_dinode_verify函数在验证xfs文件系统inode结构时，未能正确处理某些特定情况下的指针解引用，导致攻击者可通过特制的xfs镜像触发空指针解引用造成拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: xfs_dinode_verify\n- 参数: [mp, ino, dip]\n- 调用者: 未明确（可能是内核中调用文件系统验证的代码）\n- 被调用者: [cpu_to_be16, xfs_sb_version_hascrc, xfs_verify_cksum, be64_to_cpu, uuid_equal, be16_to_cpu, xfs_mode_to_ftype, be32_to_cpu, XFS_DFORK_BOFF, xfs_sb_version_hasreflink]\n\n2. 函数名: cpu_to_be16\n- 参数: [未明确]\n- 调用者: xfs_dinode_verify\n- 被调用者: []\n\n3. 函数名: xfs_sb_version_hascrc\n- 参数: [&mp->m_sb]\n- 调用者: xfs_dinode_verify\n- 被调用者: []\n\n4. 函数名: xfs_verify_cksum\n- 参数: [(char *)dip, mp->m_sb.sb_inodesize, XFS_DINODE_CRC_OFF]\n- 调用者: xfs_dinode_verify\n- 被调用者: []\n\n5. 函数名: be64_to_cpu\n- 参数: [dip->di_ino, dip->di_size, dip->di_nblocks]\n- 调用者: xfs_dinode_verify\n- 被调用者: []\n\n6. 函数名: uuid_equal\n- 参数: [&dip->di_uuid, &mp->m_sb.sb_meta_uuid]\n- 调用者: xfs_dinode_verify\n- 被调用者: []\n\n7. 函数名: be16_to_cpu\n- 参数: [dip->di_mode, dip->di_flags, dip->di_anextents]\n- 调用者: xfs_dinode_verify\n- 被调用者: []\n\n8. 函数名: xfs_mode_to_ftype\n- 参数: [mode]\n- 调用者: xfs_dinode_verify\n- 被调用者: []\n\n9. 函数名: be32_to_cpu\n- 参数: [dip->di_nextents]\n- 调用者: xfs_dinode_verify\n- 被调用者: []\n\n10. 函数名: XFS_DFORK_BOFF\n- 参数: [dip]\n- 调用者: xfs_dinode_verify\n- 被调用者: []\n\n11. 函数名: xfs_sb_version_hasreflink\n- 参数: [&mp->m_sb]\n- 调用者: xfs_dinode_verify\n- 被调用者: []"
    },
    {
        "id": 1588,
        "cwe": "CWE-476",
        "cve": "CVE-2018-10323",
        "purpose": "Code purpose:\"\"\"将XFS文件系统中inode的扩展属性从扩展格式转换为B树格式\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"xfs_bmap_extents_to_btree函数在处理特制的xfs镜像时，由于未充分验证输入导致NULL指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: xfs_bmap_extents_to_btree\n- 参数: [tp, ip, firstblock, dfops, curp, wasdel, logflagsp, whichfork]\n- 调用者: 未显示\n- 被调用者: [XFS_IFORK_PTR, XFS_IFORK_FORMAT, xfs_iroot_realloc, xfs_btree_init_block_int, xfs_bmbt_init_cursor, XFS_IFORK_FMT_SET, xfs_rmap_ino_bmbt_owner, xfs_alloc_vextent, xfs_btree_del_cursor, XFS_FSB_TO_AGNO, xfs_trans_mod_dquot_byino, xfs_btree_get_bufl, XFS_BUF_TO_BLOCK, for_each_xfs_iext, isnullstartblock, XFS_BMBT_REC_ADDR, xfs_bmbt_disk_set_all, XFS_IFORK_NEXTENTS, xfs_btree_set_numrecs, XFS_BMBT_KEY_ADDR, xfs_bmbt_disk_get_startoff, XFS_BMBT_PTR_ADDR, xfs_bmbt_get_maxrecs, xfs_btree_log_block, xfs_btree_log_recs, xfs_ilog_fbroot]\n\n2. 函数名: xfs_iroot_realloc\n- 参数: [ip, delta, whichfork]\n- 调用者: xfs_bmap_extents_to_btree\n- 被调用者: 未显示\n\n3. 函数名: xfs_btree_init_block_int\n- 参数: [mp, block, d, type, level, numrecs, owner, flags]\n- 调用者: xfs_bmap_extents_to_btree\n- 被调用者: 未显示\n\n4. 函数名: xfs_bmbt_init_cursor\n- 参数: [mp, tp, ip, whichfork]\n- 调用者: xfs_bmap_extents_to_btree\n- 被调用者: 未显示\n\n5. 函数名: xfs_rmap_ino_bmbt_owner\n- 参数: [oinfo, ino, whichfork]\n- 调用者: xfs_bmap_extents_to_btree\n- 被调用者: 未显示\n\n6. 函数名: xfs_alloc_vextent\n- 参数: [args]\n- 调用者: xfs_bmap_extents_to_btree\n- 被调用者: 未显示\n\n7. 函数名: xfs_btree_del_cursor\n- 参数: [cur, error]\n- 调用者: xfs_bmap_extents_to_btree\n- 被调用者: 未显示\n\n8. 函数名: xfs_trans_mod_dquot_byino\n- 参数: [tp, ip, field, delta]\n- 调用者: xfs_bmap_extents_to_btree\n- 被调用者: 未显示\n\n9. 函数名: xfs_btree_get_bufl\n- 参数: [mp, tp, fsbno, flags]\n- 调用者: xfs_bmap_extents_to_btree\n- 被调用者: 未显示\n\n10. 函数名: xfs_bmbt_disk_set_all\n- 参数: [arp, rec]\n- 调用者: xfs_bmap_extents_to_btree\n- 被调用者: 未显示\n\n11. 函数名: xfs_btree_set_numrecs\n- 参数: [block, numrecs]\n- 调用者: xfs_bmap_extents_to_btree\n- 被调用者: 未显示\n\n12. 函数名: xfs_bmbt_disk_get_startoff\n- 参数: [arp]\n- 调用者: xfs_bmap_extents_to_btree\n- 被调用者: 未显示\n\n13. 函数名: xfs_bmbt_get_maxrecs\n- 参数: [cur, level]\n- 调用者: xfs_bmap_extents_to_btree\n- 被调用者: 未显示\n\n14. 函数名: xfs_btree_log_block\n- 参数: [cur, bp, fields]\n- 调用者: xfs_bmap_extents_to_btree\n- 被调用者: 未显示\n\n15. 函数名: xfs_btree_log_recs\n- 参数: [cur, bp, first, last]\n- 调用者: xfs_bmap_extents_to_btree\n- 被调用者: 未显示\n\n16. 函数名: xfs_ilog_fbroot\n- 参数: [whichfork]\n- 调用者: xfs_bmap_extents_to_btree\n- 被调用者: 未显示"
    },
    {
        "id": 1589,
        "cwe": "CWE-476",
        "cve": "CVE-2018-1065",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核netfilter子系统中IP表规则的处理功能，包括数据包匹配、跳转规则执行和最终裁决处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统中处理规则跳转时，当规则blob包含跳转但缺少用户定义链时，会导致空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ipt_do_table\n- 参数: [struct sk_buff *skb, const struct nf_hook_state *state, struct xt_table *table]\n- 调用者: 未明确（由netfilter子系统调用）\n- 被调用者: [ip_hdr, ntohs, ip_hdrlen, local_bh_disable, xt_write_recseq_begin, READ_ONCE, smp_processor_id, static_key_false, __this_cpu_read, get_entry, ip_packet_match, ipt_next_entry, xt_ematch_foreach, xt_get_this_cpu_counter, ADD_COUNTER, ipt_get_target, trace_packet, xt_write_recseq_end, local_bh_enable]\n\n2. 函数名: ip_hdr\n- 参数: [struct sk_buff *skb]\n- 调用者: ipt_do_table\n- 被调用者: []\n\n3. 函数名: ntohs\n- 参数: [unsigned short]\n- 调用者: ipt_do_table\n- 被调用者: []\n\n4. 函数名: ip_hdrlen\n- 参数: [struct sk_buff *skb]\n- 调用者: ipt_do_table\n- 被调用者: []\n\n5. 函数名: local_bh_disable\n- 参数: []\n- 调用者: ipt_do_table\n- 被调用者: []\n\n6. 函数名: xt_write_recseq_begin\n- 参数: []\n- 调用者: ipt_do_table\n- 被调用者: []\n\n7. 函数名: READ_ONCE\n- 参数: [variable]\n- 调用者: ipt_do_table\n- 被调用者: []\n\n8. 函数名: smp_processor_id\n- 参数: []\n- 调用者: ipt_do_table\n- 被调用者: []\n\n9. 函数名: static_key_false\n- 参数: [struct static_key *key]\n- 调用者: ipt_do_table\n- 被调用者: []\n\n10. 函数名: __this_cpu_read\n- 参数: [variable]\n- 调用者: ipt_do_table\n- 被调用者: []\n\n11. 函数名: get_entry\n- 参数: [const void *table_base, unsigned int offset]\n- 调用者: ipt_do_table\n- 被调用者: []\n\n12. 函数名: ip_packet_match\n- 参数: [const struct iphdr *ip, const char *indev, const char *outdev, const struct ipt_ip *ipinfo, unsigned int fragoff]\n- 调用者: ipt_do_table\n- 被调用者: []\n\n13. 函数名: ipt_next_entry\n- 参数: [struct ipt_entry *entry]\n- 调用者: ipt_do_table\n- 被调用者: []\n\n14. 函数名: xt_ematch_foreach\n- 参数: [struct xt_entry_match *ematch, struct ipt_entry *e]\n- 调用者: ipt_do_table\n- 被调用者: []\n\n15. 函数名: xt_get_this_cpu_counter\n- 参数: [struct xt_counters *counter]\n- 调用者: ipt_do_table\n- 被调用者: []\n\n16. 函数名: ADD_COUNTER\n- 参数: [struct xt_counters counter, unsigned int bytes, unsigned int packets]\n- 调用者: ipt_do_table\n- 被调用者: []\n\n17. 函数名: ipt_get_target\n- 参数: [struct ipt_entry *e]\n- 调用者: ipt_do_table\n- 被调用者: []\n\n18. 函数名: trace_packet\n- 参数: [struct net *net, struct sk_buff *skb, unsigned int hook, struct net_device *in, struct net_device *out, const char *tablename, const struct xt_table_info *private, struct ipt_entry *e]\n- 调用者: ipt_do_table\n- 被调用者: []\n\n19. 函数名: xt_write_recseq_end\n- 参数: [unsigned int addend]\n- 调用者: ipt_do_table\n- 被调用者: []\n\n20. 函数名: local_bh_enable\n- 参数: []\n- 调用者: ipt_do_table\n- 被调用者: []"
    },
    {
        "id": 1590,
        "cwe": "CWE-476",
        "cve": "CVE-2018-1066",
        "purpose": "Code purpose:\"\"\"构建NTLMSSP认证消息块，用于CIFS客户端与服务器之间的身份验证和安全协商\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在NTLMSSP认证过程中，当服务器返回的TargetInfo字段为空时，客户端未能正确处理导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: build_ntlmssp_auth_blob\n- 参数: [pbuffer, buflen, ses, nls_cp]\n- 调用者: 未显示\n- 被调用者: [setup_ntlmv2_rsp, kmalloc, memcpy, cpu_to_le32, cpu_to_le16, cifs_strtoUTF16, calc_seckey]\n\n2. 函数名: setup_ntlmv2_rsp\n- 参数: [ses, nls_cp]\n- 调用者: build_ntlmssp_auth_blob\n- 被调用者: 未显示\n\n3. 函数名: kmalloc\n- 参数: [size_of_ntlmssp_blob(ses), GFP_KERNEL]\n- 调用者: build_ntlmssp_auth_blob\n- 被调用者: 未显示\n\n4. 函数名: memcpy\n- 参数: [sec_blob->Signature, NTLMSSP_SIGNATURE, 8], [tmp, ses->auth_key.response + CIFS_SESS_KEY_SIZE, ses->auth_key.len - CIFS_SESS_KEY_SIZE], [tmp, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE]\n- 调用者: build_ntlmssp_auth_blob\n- 被调用者: 未显示\n\n5. 函数名: cpu_to_le32\n- 参数: [flags], [sizeof(AUTHENTICATE_MESSAGE)], [tmp - *pbuffer] (多次调用)\n- 调用者: build_ntlmssp_auth_blob\n- 被调用者: 未显示\n\n6. 函数名: cpu_to_le16\n- 参数: [ses->auth_key.len - CIFS_SESS_KEY_SIZE] (多次调用), [len] (多次调用), [CIFS_CPHTXT_SIZE] (多次调用)\n- 调用者: build_ntlmssp_auth_blob\n- 被调用者: 未显示\n\n7. 函数名: cifs_strtoUTF16\n- 参数: [(__le16 *)tmp, ses->domainName, CIFS_MAX_DOMAINNAME_LEN, nls_cp], [(__le16 *)tmp, ses->user_name, CIFS_MAX_USERNAME_LEN, nls_cp]\n- 调用者: build_ntlmssp_auth_blob\n- 被调用者: 未显示\n\n8. 函数名: calc_seckey\n- 参数: [ses]\n- 调用者: build_ntlmssp_auth_blob\n- 被调用者: 未显示"
    },
    {
        "id": 1591,
        "cwe": "CWE-476",
        "cve": "CVE-2018-1066",
        "purpose": "Code purpose:\"\"\"构建NTLMSSP协商消息块，用于CIFS客户端与服务器之间的认证协商\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理NTLMSSP协商响应时，未能正确处理空的TargetInfo字段，导致在会话恢复期间出现空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: build_ntlmssp_negotiate_blob\n- 参数: [unsigned char *pbuffer, struct cifs_ses *ses]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [memset, memcpy, cpu_to_le32]\n\n2. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: build_ntlmssp_negotiate_blob\n- 被调用者: []\n\n3. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: build_ntlmssp_negotiate_blob\n- 被调用者: []\n\n4. 函数名: cpu_to_le32\n- 参数: [__u32 x]\n- 调用者: build_ntlmssp_negotiate_blob\n- 被调用者: []"
    },
    {
        "id": 1592,
        "cwe": "CWE-476",
        "cve": "CVE-2018-1066",
        "purpose": "Code purpose:\"\"\"建立SMB2/3会话并处理会话密钥生成及会话状态管理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在NTLMSSP设置协商响应中处理空的TargetInfo字段时，会话恢复过程中未正确验证空指针，导致内核空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: SMB2_sess_establish_session\n- 参数: [struct SMB2_sess_data *sess_data]\n- 调用者: 未明确显示（应为CIFS会话建立流程中的调用者）\n- 被调用者: [mutex_lock, mutex_unlock, kfree, cifs_dbg, spin_lock, spin_unlock]\n\n2. 函数名: mutex_lock\n- 参数: [&ses->server->srv_mutex]\n- 调用者: SMB2_sess_establish_session\n- 被调用者: []\n\n3. 函数名: mutex_unlock\n- 参数: [&ses->server->srv_mutex]\n- 调用者: SMB2_sess_establish_session\n- 被调用者: []\n\n4. 函数名: kfree\n- 参数: [ses->auth_key.response]\n- 调用者: SMB2_sess_establish_session\n- 被调用者: []\n\n5. 函数名: cifs_dbg\n- 参数: [FYI, \"SMB3 session key generation failed\\n\"] 或 [FYI, \"SMB2/3 session established successfully\\n\"]\n- 调用者: SMB2_sess_establish_session\n- 被调用者: []\n\n6. 函数名: spin_lock\n- 参数: [&GlobalMid_Lock]\n- 调用者: SMB2_sess_establish_session\n- 被调用者: []\n\n7. 函数名: spin_unlock\n- 参数: [&GlobalMid_Lock]\n- 调用者: SMB2_sess_establish_session\n- 被调用者: []\n\n8. 函数名: generate_signingkey\n- 参数: [ses]\n- 调用者: 通过函数指针 ses->server->ops->generate_signingkey 调用\n- 被调用者: SMB2_sess_establish_session"
    },
    {
        "id": 1623,
        "cwe": "CWE-476",
        "cve": "CVE-2018-1092",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中ext4文件系统的inode获取功能，包括从磁盘读取inode信息、验证其有效性并初始化内存中的inode结构体\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"ext4_iget函数在处理根目录i_links_count为零的情况时未正确验证，导致空指针解引用和系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_iget\n- 参数: [struct super_block *sb, unsigned long ino]\n- 调用者: N/A (顶层函数)\n- 被调用者: [iget_locked, ERR_PTR, EXT4_I, __ext4_get_inode_loc, ext4_raw_inode, le16_to_cpu, EXT4_ERROR_INODE, ext4_has_metadata_csum, ext4_chksum, ext4_inode_csum_verify, i_uid_write, i_gid_write, make_kprojid, set_nlink, ext4_clear_state_flags, ext4_inode_blocks, ext4_isize, i_size_read, INIT_LIST_HEAD, read_lock, read_unlock, BUILD_BUG_ON, ext4_iget_extra_inode, EXT4_INODE_GET_XTIME, EXT4_EINODE_GET_XTIME, test_opt2, le32_to_cpu, inode_set_iversion_queried, ext4_data_block_valid, ext4_has_inline_data, ext4_test_inode_flag, ext4_inode_is_fast_symlink, ext4_ext_check_inode, ext4_ind_check_inode, ext4_set_aops, ext4_encrypted_inode, nd_terminate_link, inode_nohighmem, old_decode_dev, new_decode_dev, make_bad_inode, brelse, ext4_set_inode_flags, unlock_new_inode, iget_failed]\n\n2. 函数名: __ext4_get_inode_loc\n- 参数: [struct inode *inode, struct ext4_iloc *iloc, int]\n- 调用者: ext4_iget\n- 被调用者: N/A\n\n3. 函数名: ext4_raw_inode\n- 参数: [struct ext4_iloc *iloc]\n- 调用者: ext4_iget\n- 被调用者: N/A\n\n4. 函数名: ext4_chksum\n- 参数: [struct ext4_sb_info *sbi, __u32 csum_seed, __u8 *data, size_t len]\n- 调用者: ext4_iget\n- 被调用者: N/A\n\n5. 函数名: ext4_inode_csum_verify\n- 参数: [struct inode *inode, struct ext4_inode *raw_inode, struct ext4_inode_info *ei]\n- 调用者: ext4_iget\n- 被调用者: N/A\n\n6. 函数名: ext4_iget_extra_inode\n- 参数: [struct inode *inode, struct ext4_inode *raw_inode, struct ext4_inode_info *ei]\n- 调用者: ext4_iget\n- 被调用者: N/A\n\n7. 函数名: ext4_data_block_valid\n- 参数: [struct ext4_sb_info *sbi, __u64 blk, unsigned int len]\n- 调用者: ext4_iget\n- 被调用者: N/A\n\n8. 函数名: ext4_ext_check_inode\n- 参数: [struct inode *inode]\n- 调用者: ext4_iget\n- 被调用者: N/A\n\n9. 函数名: ext4_ind_check_inode\n- 参数: [struct inode *inode]\n- 调用者: ext4_iget\n- 被调用者: N/A\n\n10. 函数名: ext4_set_aops\n- 参数: [struct inode *inode]\n- 调用者: ext4_iget\n- 被调用者: N/A\n\n11. 函数名: ext4_encrypted_inode\n- 参数: [struct inode *inode]\n- 调用者: ext4_iget\n- 被调用者: N/A\n\n12. 函数名: ext4_inode_is_fast_symlink\n- 参数: [struct inode *inode]\n- 调用者: ext4_iget\n- 被调用者: N/A\n\n13. 函数名: ext4_test_inode_flag\n- 参数: [struct inode *inode, int flag]\n- 调用者: ext4_iget\n- 被调用者: N/A\n\n14. 函数名: ext4_has_inline_data\n- 参数: [struct inode *inode]\n- 调用者: ext4_iget\n- 被调用者: N/A\n\n15. 函数名: ext4_has_metadata_csum\n- 参数: [struct super_block *sb]\n- 调用者: ext4_iget\n- 被调用者: N/A\n\n16. 函数名: ext4_has_feature_project\n- 参数: [struct super_block *sb]\n- 调用者: ext4_iget\n- 被调用者: N/A\n\n17. 函数名: ext4_has_feature_64bit\n- 参数: [struct super_block *sb]\n- 调用者: ext4_iget\n- 被调用者: N/A"
    },
    {
        "id": 1628,
        "cwe": "CWE-476",
        "cve": "CVE-2018-1094",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中ext4文件系统的超级块填充和初始化功能，包括文件系统参数解析、元数据校验、日志系统设置等，用于挂载ext4文件系统。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"ext4_fill_super函数未正确初始化crc32c校验和驱动，导致在处理特制的ext4镜像时可能引发空指针解引用和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_fill_super\n- 参数: [struct super_block *sb, void *data, int silent]\n- 调用者: N/A (kernel mount operation)\n- 被调用者: [fs_dax_get_by_bdev, kstrdup, kzalloc, get_sb_block, sb_min_blocksize, sb_bread_unmovable, ext4_has_feature_metadata_csum, ext4_has_feature_gdt_csum, ext4_verify_csum_type, crypto_alloc_shash, ext4_superblock_csum_verify, ext4_chksum, ext4_has_feature_csum_seed, ext4_has_metadata_csum, ext4_has_feature_ea_inode, ext4_has_feature_dir_index, ext4_has_feature_bigalloc, ext4_has_feature_64bit, ext4_has_feature_meta_bg, ext4_has_feature_quota, ext4_has_feature_encrypt, ext4_has_feature_journal, ext4_has_feature_journal_needs_recovery, ext4_has_feature_mmp, ext4_has_feature_extra_isize, ext4_has_feature_flex_bg, ext4_load_journal, ext4_multi_mount_protect, ext4_iget, ext4_setup_super, ext4_setup_system_zone, ext4_ext_init, ext4_mb_init, ext4_count_free_clusters, ext4_count_free_inodes, ext4_count_dirs, ext4_fill_flex_info, ext4_register_li_request, ext4_register_sysfs, ext4_enable_quotas, ext4_orphan_cleanup, ext4_mark_recovery_complete, ext4_unregister_sysfs, ext4_unregister_li_request, ext4_mb_release, ext4_ext_release, ext4_release_system_zone, ext4_es_unregister_shrinker, ext4_blkdev_remove, ext4_xattr_destroy_cache, jbd2_journal_destroy, kthread_stop, brelse, kvfree, crypto_free_shash, kfree, fs_put_dax]\n\n2. 函数名: fs_dax_get_by_bdev\n- 参数: [struct block_device *bdev]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n3. 函数名: kstrdup\n- 参数: [const char *s, gfp_t gfp]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n4. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n5. 函数名: get_sb_block\n- 参数: [void **data]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n6. 函数名: sb_min_blocksize\n- 参数: [struct super_block *sb, int size]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n7. 函数名: sb_bread_unmovable\n- 参数: [struct super_block *sb, sector_t block]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n8. 函数名: ext4_has_feature_metadata_csum\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n9. 函数名: ext4_has_feature_gdt_csum\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n10. 函数名: ext4_verify_csum_type\n- 参数: [struct super_block *sb, struct ext4_super_block *es]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n11. 函数名: crypto_alloc_shash\n- 参数: [const char *alg_name, u32 type, u32 mask]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n12. 函数名: ext4_superblock_csum_verify\n- 参数: [struct super_block *sb, struct ext4_super_block *es]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n13. 函数名: ext4_chksum\n- 参数: [struct ext4_sb_info *sbi, __u32 crc, void *address, unsigned int length]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n14. 函数名: ext4_has_feature_csum_seed\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n15. 函数名: ext4_has_metadata_csum\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n16. 函数名: ext4_has_feature_ea_inode\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n17. 函数名: ext4_has_feature_dir_index\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n18. 函数名: ext4_has_feature_bigalloc\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n19. 函数名: ext4_has_feature_64bit\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n20. 函数名: ext4_has_feature_meta_bg\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n21. 函数名: ext4_has_feature_quota\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n22. 函数名: ext4_has_feature_encrypt\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n23. 函数名: ext4_has_feature_journal\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n24. 函数名: ext4_has_feature_journal_needs_recovery\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n25. 函数名: ext4_has_feature_mmp\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n26. 函数名: ext4_has_feature_extra_isize\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n27. 函数名: ext4_has_feature_flex_bg\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n28. 函数名: ext4_load_journal\n- 参数: [struct super_block *sb, struct ext4_super_block *es, unsigned int journal_devnum]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n29. 函数名: ext4_multi_mount_protect\n- 参数: [struct super_block *sb, ext4_fsblk_t mmp_block]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n30. 函数名: ext4_iget\n- 参数: [struct super_block *sb, unsigned long ino]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n31. 函数名: ext4_setup_super\n- 参数: [struct super_block *sb, struct ext4_super_block *es, int read_only]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n32. 函数名: ext4_setup_system_zone\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n33. 函数名: ext4_ext_init\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n34. 函数名: ext4_mb_init\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n35. 函数名: ext4_count_free_clusters\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n36. 函数名: ext4_count_free_inodes\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n37. 函数名: ext4_count_dirs\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n38. 函数名: ext4_fill_flex_info\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n39. 函数名: ext4_register_li_request\n- 参数: [struct super_block *sb, ext4_group_t first_not_zeroed]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n40. 函数名: ext4_register_sysfs\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n41. 函数名: ext4_enable_quotas\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n42. 函数名: ext4_orphan_cleanup\n- 参数: [struct super_block *sb, struct ext4_super_block *es]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n43. 函数名: ext4_mark_recovery_complete\n- 参数: [struct super_block *sb, struct ext4_super_block *es]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n44. 函数名: ext4_unregister_sysfs\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n45. 函数名: ext4_unregister_li_request\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n46. 函数名: ext4_mb_release\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n47. 函数名: ext4_ext_release\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n48. 函数名: ext4_release_system_zone\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n49. 函数名: ext4_es_unregister_shrinker\n- 参数: [struct ext4_sb_info *sbi]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n50. 函数名: ext4_blkdev_remove\n- 参数: [struct ext4_sb_info *sbi]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n51. 函数名: ext4_xattr_destroy_cache\n- 参数: [struct mb_cache *cache]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n52. 函数名: jbd2_journal_destroy\n- 参数: [journal_t *journal]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n53. 函数名: kthread_stop\n- 参数: [struct task_struct *k]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n54. 函数名: brelse\n- 参数: [struct buffer_head *bh]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n55. 函数名: kvfree\n- 参数: [const void *addr]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n56. 函数名: crypto_free_shash\n- 参数: [struct crypto_shash *tfm]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n57. 函数名: kfree\n- 参数: [const void *x]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n58. 函数名: fs_put_dax\n- 参数: [struct dax_device *dax_dev]\n- 调用者: ext4_fill_super\n- 被调用者: N/A"
    },
    {
        "id": 1630,
        "cwe": "CWE-476",
        "cve": "CVE-2018-1095",
        "purpose": "Code purpose:\"\"\"验证ext4文件系统中扩展属性(xattr)条目的有效性和边界，防止因属性大小或偏移量错误导致的越界访问或系统崩溃\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未正确验证xattr属性的大小，导致将大小值误解为错误代码，从而可能引发空指针解引用和系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_xattr_check_entries\n- 参数: [struct ext4_xattr_entry *entry, void *end, void *value_start]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [EXT4_XATTR_NEXT, IS_LAST_ENTRY, le16_to_cpu, le32_to_cpu]\n\n2. 函数名: EXT4_XATTR_NEXT\n- 参数: [struct ext4_xattr_entry *e]\n- 调用者: ext4_xattr_check_entries\n- 被调用者: 无（宏或内联函数）\n\n3. 函数名: IS_LAST_ENTRY\n- 参数: [struct ext4_xattr_entry *e]\n- 调用者: ext4_xattr_check_entries\n- 被调用者: 无（宏或内联函数）\n\n4. 函数名: le16_to_cpu\n- 参数: [u16 value]\n- 调用者: ext4_xattr_check_entries\n- 被调用者: 无（宏或内联函数）\n\n5. 函数名: le32_to_cpu\n- 参数: [u32 value]\n- 调用者: ext4_xattr_check_entries\n- 被调用者: 无（宏或内联函数）"
    },
    {
        "id": 1642,
        "cwe": "CWE-476",
        "cve": "CVE-2018-1130",
        "purpose": "Code purpose:\"\"\"该代码实现了DCCP协议中发送消息的功能，包括消息长度检查、连接状态等待、内存分配、数据拷贝和传输等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在dccp_sendmsg函数中，当调用dccp_write_xmit()时未正确检查dp指针是否为NULL，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: dccp_sendmsg\n- 参数: [struct sock *sk, struct msghdr *msg, size_t len]\n- 调用者: 无（顶层函数）\n- 被调用者: [dccp_sk, trace_dccp_probe, lock_sock, dccp_qpolicy_full, sock_sndtimeo, sk_stream_wait_connect, release_sock, sock_alloc_send_skb, skb_reserve, memcpy_from_msg, skb_put, dccp_msghdr_parse, dccp_qpolicy_push, timer_pending, dccp_write_xmit, kfree_skb]\n\n2. 函数名: dccp_sk\n- 参数: [struct sock *sk]\n- 调用者: dccp_sendmsg\n- 被调用者: 无\n\n3. 函数名: trace_dccp_probe\n- 参数: [struct sock *sk, size_t len]\n- 调用者: dccp_sendmsg\n- 被调用者: 无\n\n4. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: dccp_sendmsg\n- 被调用者: 无\n\n5. 函数名: dccp_qpolicy_full\n- 参数: [struct sock *sk]\n- 调用者: dccp_sendmsg\n- 被调用者: 无\n\n6. 函数名: sock_sndtimeo\n- 参数: [struct sock *sk, int noblock]\n- 调用者: dccp_sendmsg\n- 被调用者: 无\n\n7. 函数名: sk_stream_wait_connect\n- 参数: [struct sock *sk, long *timeo]\n- 调用者: dccp_sendmsg\n- 被调用者: 无\n\n8. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: dccp_sendmsg\n- 被调用者: 无\n\n9. 函数名: sock_alloc_send_skb\n- 参数: [struct sock *sk, int size, int noblock, int *rc]\n- 调用者: dccp_sendmsg\n- 被调用者: 无\n\n10. 函数名: skb_reserve\n- 参数: [struct sk_buff *skb, int len]\n- 调用者: dccp_sendmsg\n- 被调用者: 无\n\n11. 函数名: memcpy_from_msg\n- 参数: [void *data, struct msghdr *msg, size_t len]\n- 调用者: dccp_sendmsg\n- 被调用者: 无\n\n12. 函数名: skb_put\n- 参数: [struct sk_buff *skb, unsigned int len]\n- 调用者: dccp_sendmsg\n- 被调用者: 无\n\n13. 函数名: dccp_msghdr_parse\n- 参数: [struct msghdr *msg, struct sk_buff *skb]\n- 调用者: dccp_sendmsg\n- 被调用者: 无\n\n14. 函数名: dccp_qpolicy_push\n- 参数: [struct sock *sk, struct sk_buff *skb]\n- 调用者: dccp_sendmsg\n- 被调用者: 无\n\n15. 函数名: timer_pending\n- 参数: [const struct timer_list *timer]\n- 调用者: dccp_sendmsg\n- 被调用者: 无\n\n16. 函数名: dccp_write_xmit\n- 参数: [struct sock *sk]\n- 调用者: dccp_sendmsg\n- 被调用者: 无\n\n17. 函数名: kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: dccp_sendmsg\n- 被调用者: 无"
    },
    {
        "id": 1667,
        "cwe": "CWE-476",
        "cve": "CVE-2018-13093",
        "purpose": "Code purpose:\"\"\"该代码用于处理XFS文件系统中未在缓存中找到inode时的处理流程，包括分配新inode、验证其状态、并将其插入到radix树缓存中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在分配缓存inode时未正确验证其是否空闲，导致当处理损坏的xfs镜像时，lookup_slow()函数会解引用NULL的inode->i_ops指针，引发空指针解引用和系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: xfs_iget_cache_miss\n- 参数: [mp, pag, tp, ino, ipp, flags, lock_flags]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [xfs_inode_alloc, xfs_iread, xfs_inode_verify_forks, trace_xfs_iget_miss, VFS_I, xfs_warn, radix_tree_preload, xfs_ilock_nowait, xfs_iflags_set, spin_lock, radix_tree_insert, XFS_STATS_INC, spin_unlock, radix_tree_preload_end, xfs_iunlock, __destroy_inode, xfs_inode_free]\n\n2. 函数名: xfs_inode_alloc\n- 参数: [mp, ino]\n- 调用者: xfs_iget_cache_miss\n- 被调用者: 未显示\n\n3. 函数名: xfs_iread\n- 参数: [mp, tp, ip, flags]\n- 调用者: xfs_iget_cache_miss\n- 被调用者: 未显示\n\n4. 函数名: xfs_inode_verify_forks\n- 参数: [ip]\n- 调用者: xfs_iget_cache_miss\n- 被调用者: 未显示\n\n5. 函数名: trace_xfs_iget_miss\n- 参数: [ip]\n- 调用者: xfs_iget_cache_miss\n- 被调用者: 未显示\n\n6. 函数名: VFS_I\n- 参数: [ip]\n- 调用者: xfs_iget_cache_miss\n- 被调用者: 未显示\n\n7. 函数名: xfs_warn\n- 参数: [mp, format_string, ino]\n- 调用者: xfs_iget_cache_miss\n- 被调用者: 未显示\n\n8. 函数名: radix_tree_preload\n- 参数: [GFP_NOFS]\n- 调用者: xfs_iget_cache_miss\n- 被调用者: 未显示\n\n9. 函数名: xfs_ilock_nowait\n- 参数: [ip, lock_flags]\n- 调用者: xfs_iget_cache_miss\n- 被调用者: 未显示\n\n10. 函数名: xfs_iflags_set\n- 参数: [ip, iflags]\n- 调用者: xfs_iget_cache_miss\n- 被调用者: 未显示\n\n11. 函数名: spin_lock\n- 参数: [&pag->pag_ici_lock]\n- 调用者: xfs_iget_cache_miss\n- 被调用者: 未显示\n\n12. 函数名: radix_tree_insert\n- 参数: [&pag->pag_ici_root, agino, ip]\n- 调用者: xfs_iget_cache_miss\n- 被调用者: 未显示\n\n13. 函数名: XFS_STATS_INC\n- 参数: [mp, xs_ig_dup]\n- 调用者: xfs_iget_cache_miss\n- 被调用者: 未显示\n\n14. 函数名: spin_unlock\n- 参数: [&pag->pag_ici_lock]\n- 调用者: xfs_iget_cache_miss\n- 被调用者: 未显示\n\n15. 函数名: radix_tree_preload_end\n- 参数: []\n- 调用者: xfs_iget_cache_miss\n- 被调用者: 未显示\n\n16. 函数名: xfs_iunlock\n- 参数: [ip, lock_flags]\n- 调用者: xfs_iget_cache_miss\n- 被调用者: 未显示\n\n17. 函数名: __destroy_inode\n- 参数: [VFS_I(ip)]\n- 调用者: xfs_iget_cache_miss\n- 被调用者: 未显示\n\n18. 函数名: xfs_inode_free\n- 参数: [ip]\n- 调用者: xfs_iget_cache_miss\n- 被调用者: 未显示"
    },
    {
        "id": 1668,
        "cwe": "CWE-476",
        "cve": "CVE-2018-13093",
        "purpose": "Code purpose:\"\"\"该代码用于处理XFS文件系统中inode缓存命中的情况，包括检查inode重用、处理回收状态以及重新初始化inode等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在xfs文件系统中，当处理损坏的xfs镜像时，由于未正确验证缓存inode是否空闲，导致在分配时出现空指针解引用，引发panic。\"\"\"",
        "functions": "Functions:\n1. 函数名: xfs_iget_cache_hit\n- 参数: [pag, ip, ino, flags, lock_flags]\n- 调用者: 未显示（应为xfs_iget相关函数）\n- 被调用者: [VFS_I, trace_xfs_iget_skip, XFS_STATS_INC, __xfs_iflags_test, wake_up_bit, xfs_reinit_inode, xfs_inode_clear_reclaim_tag, rwsem_is_locked, init_rwsem, igrab, xfs_ilock, xfs_iflags_clear]\n\n2. 函数名: VFS_I\n- 参数: [ip]\n- 调用者: xfs_iget_cache_hit\n- 被调用者: 无\n\n3. 函数名: trace_xfs_iget_skip\n- 参数: [ip]\n- 调用者: xfs_iget_cache_hit\n- 被调用者: 无\n\n4. 函数名: XFS_STATS_INC\n- 参数: [mp, xs_ig_frecycle/xs_ig_found]\n- 调用者: xfs_iget_cache_hit\n- 被调用者: 无\n\n5. 函数名: __xfs_iflags_test\n- 参数: [ip, XFS_INEW]\n- 调用者: xfs_iget_cache_hit\n- 被调用者: 无\n\n6. 函数名: wake_up_bit\n- 参数: [&ip->i_flags, __XFS_INEW_BIT]\n- 调用者: xfs_iget_cache_hit\n- 被调用者: 无\n\n7. 函数名: xfs_reinit_inode\n- 参数: [mp, inode]\n- 调用者: xfs_iget_cache_hit\n- 被调用者: 无\n\n8. 函数名: xfs_inode_clear_reclaim_tag\n- 参数: [pag, ip->i_ino]\n- 调用者: xfs_iget_cache_hit\n- 被调用者: 无\n\n9. 函数名: rwsem_is_locked\n- 参数: [&inode->i_rwsem]\n- 调用者: xfs_iget_cache_hit\n- 被调用者: 无\n\n10. 函数名: init_rwsem\n- 参数: [&inode->i_rwsem]\n- 调用者: xfs_iget_cache_hit\n- 被调用者: 无\n\n11. 函数名: igrab\n- 参数: [inode]\n- 调用者: xfs_iget_cache_hit\n- 被调用者: 无\n\n12. 函数名: xfs_ilock\n- 参数: [ip, lock_flags]\n- 调用者: xfs_iget_cache_hit\n- 被调用者: 无\n\n13. 函数名: xfs_iflags_clear\n- 参数: [ip, XFS_ISTALE | XFS_IDONTCACHE]\n- 调用者: xfs_iget_cache_hit\n- 被调用者: 无"
    },
    {
        "id": 1669,
        "cwe": "CWE-476",
        "cve": "CVE-2018-13094",
        "purpose": "Code purpose:\"\"\"将XFS文件系统中属性的短格式转换为叶格式\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当xfs_da_shrink_inode()被调用时传入NULL的bp指针，导致内核在访问空指针时触发OOPS\"\"\"",
        "functions": "Functions:\n1. 函数名: xfs_attr_shortform_to_leaf\n- 参数: [struct xfs_da_args *args, struct xfs_buf **leaf_bp]\n- 调用者: 未显示\n- 被调用者: [be16_to_cpu, kmem_alloc, memcpy, xfs_idata_realloc, xfs_bmap_local_to_extents_empty, xfs_da_grow_inode, xfs_attr3_leaf_create, xfs_da_shrink_inode, memset, xfs_da_hashname, xfs_attr3_leaf_lookup_int, xfs_attr3_leaf_add, kmem_free]\n\n2. 函数名: be16_to_cpu\n- 参数: [sf->hdr.totsize]\n- 调用者: xfs_attr_shortform_to_leaf\n- 被调用者: 未显示\n\n3. 函数名: kmem_alloc\n- 参数: [size, KM_SLEEP]\n- 调用者: xfs_attr_shortform_to_leaf\n- 被调用者: 未显示\n\n4. 函数名: memcpy\n- 参数: [tmpbuffer, ifp->if_u1.if_data, size]\n- 调用者: xfs_attr_shortform_to_leaf\n- 被调用者: 未显示\n\n5. 函数名: xfs_idata_realloc\n- 参数: [dp, -size, XFS_ATTR_FORK]\n- 调用者: xfs_attr_shortform_to_leaf\n- 被调用者: 未显示\n\n6. 函数名: xfs_bmap_local_to_extents_empty\n- 参数: [dp, XFS_ATTR_FORK]\n- 调用者: xfs_attr_shortform_to_leaf\n- 被调用者: 未显示\n\n7. 函数名: xfs_da_grow_inode\n- 参数: [args, &blkno]\n- 调用者: xfs_attr_shortform_to_leaf\n- 被调用者: 未显示\n\n8. 函数名: xfs_attr3_leaf_create\n- 参数: [args, blkno, &bp]\n- 调用者: xfs_attr_shortform_to_leaf\n- 被调用者: 未显示\n\n9. 函数名: xfs_da_shrink_inode\n- 参数: [args, 0, bp]\n- 调用者: xfs_attr_shortform_to_leaf\n- 被调用者: 未显示\n\n10. 函数名: memset\n- 参数: [(char *)&nargs, 0, sizeof(nargs)]\n- 调用者: xfs_attr_shortform_to_leaf\n- 被调用者: 未显示\n\n11. 函数名: xfs_da_hashname\n- 参数: [sfe->nameval, sfe->namelen]\n- 调用者: xfs_attr_shortform_to_leaf\n- 被调用者: 未显示\n\n12. 函数名: xfs_attr3_leaf_lookup_int\n- 参数: [bp, &nargs]\n- 调用者: xfs_attr_shortform_to_leaf\n- 被调用者: 未显示\n\n13. 函数名: xfs_attr3_leaf_add\n- 参数: [bp, &nargs]\n- 调用者: xfs_attr_shortform_to_leaf\n- 被调用者: 未显示\n\n14. 函数名: kmem_free\n- 参数: [tmpbuffer]\n- 调用者: xfs_attr_shortform_to_leaf\n- 被调用者: 未显示"
    },
    {
        "id": 1678,
        "cwe": "CWE-476",
        "cve": "CVE-2018-14609",
        "purpose": "Code purpose:\"\"\"该代码用于在btrfs文件系统中删除重定位根节点时，处理相关的重定位控制结构和树节点清理工作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在未初始化reloc_ctl的情况下尝试访问其成员reloc_root_tree，导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: __del_reloc_root\n- 参数: [struct btrfs_root *root]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [tree_search, rb_entry, rb_erase, list_del_init, kfree]\n\n2. 函数名: tree_search\n- 参数: [&rc->reloc_root_tree.rb_root, root->node->start]\n- 调用者: __del_reloc_root\n- 被调用者: 未明确（可能为内核内部函数）\n\n3. 函数名: rb_entry\n- 参数: [rb_node, struct mapping_node, rb_node]\n- 调用者: __del_reloc_root\n- 被调用者: 未明确（内核宏）\n\n4. 函数名: rb_erase\n- 参数: [&node->rb_node, &rc->reloc_root_tree.rb_root]\n- 调用者: __del_reloc_root\n- 被调用者: 未明确（内核红黑树操作函数）\n\n5. 函数名: list_del_init\n- 参数: [&root->root_list]\n- 调用者: __del_reloc_root\n- 被调用者: 未明确（内核链表操作函数）\n\n6. 函数名: kfree\n- 参数: [node]\n- 调用者: __del_reloc_root\n- 被调用者: 未明确（内核内存释放函数）"
    },
    {
        "id": 1681,
        "cwe": "CWE-476",
        "cve": "CVE-2018-14612",
        "purpose": "Code purpose:\"\"\"检查Btrfs文件系统中的叶子节点是否有效，包括验证键顺序、项偏移和大小以及项内容等，以确保数据结构的完整性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在检查叶子节点时未充分验证空树情况，导致当挂载特制的btrfs镜像时可能引发无效指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: check_leaf\n- 参数: [struct btrfs_fs_info *fs_info, struct extent_buffer *leaf, bool check_item_data]\n- 调用者: 未显示在代码片段中\n- 被调用者: [btrfs_header_nritems, btrfs_header_flag, btrfs_header_owner, btrfs_get_fs_root, IS_ERR_OR_NULL, btrfs_root_node, free_extent_buffer, generic_err, btrfs_item_key_to_cpu, btrfs_comp_cpu_keys, btrfs_item_offset_nr, btrfs_item_end_nr, btrfs_item_nr_offset, btrfs_item_ptr_offset, check_leaf_item]\n\n2. 函数名: btrfs_header_nritems\n- 参数: [struct extent_buffer *leaf]\n- 调用者: check_leaf\n- 被调用者: 未显示在代码片段中\n\n3. 函数名: btrfs_header_flag\n- 参数: [struct extent_buffer *leaf, int flag]\n- 调用者: check_leaf\n- 被调用者: 未显示在代码片段中\n\n4. 函数名: btrfs_header_owner\n- 参数: [struct extent_buffer *leaf]\n- 调用者: check_leaf\n- 被调用者: 未显示在代码片段中\n\n5. 函数名: btrfs_get_fs_root\n- 参数: [struct btrfs_fs_info *fs_info, struct btrfs_key *key, bool check_ref]\n- 调用者: check_leaf\n- 被调用者: 未显示在代码片段中\n\n6. 函数名: IS_ERR_OR_NULL\n- 参数: [void *ptr]\n- 调用者: check_leaf\n- 被调用者: 未显示在代码片段中\n\n7. 函数名: btrfs_root_node\n- 参数: [struct btrfs_root *root]\n- 调用者: check_leaf\n- 被调用者: 未显示在代码片段中\n\n8. 函数名: free_extent_buffer\n- 参数: [struct extent_buffer *eb]\n- 调用者: check_leaf\n- 被调用者: 未显示在代码片段中\n\n9. 函数名: generic_err\n- 参数: [struct btrfs_fs_info *fs_info, struct extent_buffer *eb, int slot, const char *fmt, ...]\n- 调用者: check_leaf\n- 被调用者: 未显示在代码片段中\n\n10. 函数名: btrfs_item_key_to_cpu\n- 参数: [struct extent_buffer *leaf, struct btrfs_key *key, int slot]\n- 调用者: check_leaf\n- 被调用者: 未显示在代码片段中\n\n11. 函数名: btrfs_comp_cpu_keys\n- 参数: [struct btrfs_key *k1, struct btrfs_key *k2]\n- 调用者: check_leaf\n- 被调用者: 未显示在代码片段中\n\n12. 函数名: btrfs_item_offset_nr\n- 参数: [struct extent_buffer *leaf, int slot]\n- 调用者: check_leaf\n- 被调用者: 未显示在代码片段中\n\n13. 函数名: btrfs_item_end_nr\n- 参数: [struct extent_buffer *leaf, int slot]\n- 调用者: check_leaf\n- 被调用者: 未显示在代码片段中\n\n14. 函数名: btrfs_item_nr_offset\n- 参数: [int slot]\n- 调用者: check_leaf\n- 被调用者: 未显示在代码片段中\n\n15. 函数名: btrfs_item_ptr_offset\n- 参数: [struct extent_buffer *leaf, int slot]\n- 调用者: check_leaf\n- 被调用者: 未显示在代码片段中\n\n16. 函数名: check_leaf_item\n- 参数: [struct btrfs_fs_info *fs_info, struct extent_buffer *leaf, struct btrfs_key *key, int slot]\n- 调用者: check_leaf\n- 被调用者: 未显示在代码片段中"
    },
    {
        "id": 1682,
        "cwe": "CWE-476",
        "cve": "CVE-2018-14613",
        "purpose": "Code purpose:\"\"\"检查Btrfs文件系统中叶子节点的各项数据项的有效性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在check_leaf_item函数中缺少对BTRFS_BLOCK_GROUP_ITEM_KEY类型的块组项验证，导致可以操作恶意构造的btrfs镜像时触发无效指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: check_leaf_item\n- 参数: [struct btrfs_fs_info *fs_info, struct extent_buffer *leaf, struct btrfs_key *key, int slot]\n- 调用者: 未明确（应为调用树检查器的上层函数）\n- 被调用者: [check_extent_data_item, check_csum_item, check_dir_item]\n\n2. 函数名: check_extent_data_item\n- 参数: [struct btrfs_fs_info *fs_info, struct extent_buffer *leaf, struct btrfs_key *key, int slot]\n- 调用者: check_leaf_item\n- 被调用者: []\n\n3. 函数名: check_csum_item\n- 参数: [struct btrfs_fs_info *fs_info, struct extent_buffer *leaf, struct btrfs_key *key, int slot]\n- 调用者: check_leaf_item\n- 被调用者: []\n\n4. 函数名: check_dir_item\n- 参数: [struct btrfs_fs_info *fs_info, struct extent_buffer *leaf, struct btrfs_key *key, int slot]\n- 调用者: check_leaf_item\n- 被调用者: []"
    },
    {
        "id": 1683,
        "cwe": "CWE-476",
        "cve": "CVE-2018-14613",
        "purpose": "Code purpose:\"\"\"该代码用于在Btrfs文件系统中分配和管理数据块组(chunk)，包括计算条带大小、设备选择、空间分配以及元数据更新等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在check_leaf_item函数中缺乏对块组项的验证，导致在处理恶意构造的btrfs镜像时可能引发无效指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: __btrfs_alloc_chunk\n- 参数: [trans, start, type]\n- 调用者: N/A (顶层函数)\n- 被调用者: [btrfs_bg_flags_to_raid_index, btrfs_test_opt, btrfs_debug, btrfs_err, div_factor, kcalloc, find_free_dev_extent, sort, btrfs_cmp_device_info, round_down, min, div_u64, round_up, kmalloc, alloc_extent_map, add_extent_mapping, free_extent_map, btrfs_make_block_group, btrfs_device_set_bytes_used, atomic64_sub, check_raid56_incompat_flag, remove_extent_mapping]\n\n2. 函数名: btrfs_bg_flags_to_raid_index\n- 参数: [type]\n- 调用者: __btrfs_alloc_chunk\n- 被调用者: []\n\n3. 函数名: btrfs_test_opt\n- 参数: [info, ENOSPC_DEBUG]\n- 调用者: __btrfs_alloc_chunk\n- 被调用者: []\n\n4. 函数名: btrfs_debug\n- 参数: [info, format_string, ...]\n- 调用者: __btrfs_alloc_chunk\n- 被调用者: []\n\n5. 函数名: btrfs_err\n- 参数: [info, format_string, ...]\n- 调用者: __btrfs_alloc_chunk\n- 被调用者: []\n\n6. 函数名: div_factor\n- 参数: [fs_devices->total_rw_bytes, 1]\n- 调用者: __btrfs_alloc_chunk\n- 被调用者: []\n\n7. 函数名: kcalloc\n- 参数: [fs_devices->rw_devices, sizeof(*devices_info), GFP_NOFS]\n- 调用者: __btrfs_alloc_chunk\n- 被调用者: []\n\n8. 函数名: find_free_dev_extent\n- 参数: [trans, device, max_stripe_size * dev_stripes, &dev_offset, &max_avail]\n- 调用者: __btrfs_alloc_chunk\n- 被调用者: []\n\n9. 函数名: sort\n- 参数: [devices_info, ndevs, sizeof(struct btrfs_device_info), btrfs_cmp_device_info, NULL]\n- 调用者: __btrfs_alloc_chunk\n- 被调用者: []\n\n10. 函数名: btrfs_cmp_device_info\n- 参数: [未显示]\n- 调用者: sort\n- 被调用者: []\n\n11. 函数名: round_down\n- 参数: [ndevs, devs_increment]\n- 调用者: __btrfs_alloc_chunk\n- 被调用者: []\n\n12. 函数名: min\n- 参数: [ndevs, devs_max]\n- 调用者: __btrfs_alloc_chunk\n- 被调用者: []\n\n13. 函数名: div_u64\n- 参数: [devices_info[ndevs - 1].max_avail, dev_stripes]\n- 调用者: __btrfs_alloc_chunk\n- 被调用者: []\n\n14. 函数名: round_up\n- 参数: [stripe_size, SZ_16M]\n- 调用者: __btrfs_alloc_chunk\n- 被调用者: []\n\n15. 函数名: kmalloc\n- 参数: [map_lookup_size(num_stripes), GFP_NOFS]\n- 调用者: __btrfs_alloc_chunk\n- 被调用者: []\n\n16. 函数名: alloc_extent_map\n- 参数: []\n- 调用者: __btrfs_alloc_chunk\n- 被调用者: []\n\n17. 函数名: add_extent_mapping\n- 参数: [em_tree, em, 0]\n- 调用者: __btrfs_alloc_chunk\n- 被调用者: []\n\n18. 函数名: free_extent_map\n- 参数: [em]\n- 调用者: __btrfs_alloc_chunk\n- 被调用者: []\n\n19. 函数名: btrfs_make_block_group\n- 参数: [trans, 0, type, start, num_bytes]\n- 调用者: __btrfs_alloc_chunk\n- 被调用者: []\n\n20. 函数名: btrfs_device_set_bytes_used\n- 参数: [map->stripes[i].dev, num_bytes]\n- 调用者: __btrfs_alloc_chunk\n- 被调用者: []\n\n21. 函数名: atomic64_sub\n- 参数: [stripe_size * map->num_stripes, &info->free_chunk_space]\n- 调用者: __btrfs_alloc_chunk\n- 被调用者: []\n\n22. 函数名: check_raid56_incompat_flag\n- 参数: [info, type]\n- 调用者: __btrfs_alloc_chunk\n- 被调用者: []\n\n23. 函数名: remove_extent_mapping\n- 参数: [em_tree, em]\n- 调用者: __btrfs_alloc_chunk\n- 被调用者: []"
    },
    {
        "id": 1684,
        "cwe": "CWE-476",
        "cve": "CVE-2018-14614",
        "purpose": "Code purpose:\"\"\"该代码用于在F2FS文件系统中获取并验证检查点(checkpoint)数据，确保文件系统一致性，并处理检查点数据的版本比较和复制。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在验证检查点时未充分验证输入数据，导致访问超出边界的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: f2fs_get_valid_checkpoint\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: 未显示\n- 被调用者: [f2fs_kzalloc, validate_checkpoint, ver_after, page_address, memcpy, f2fs_sanity_check_ckpt, f2fs_get_meta_page, f2fs_put_page, kfree]\n\n2. 函数名: validate_checkpoint\n- 参数: [struct f2fs_sb_info *sbi, unsigned long long cp_start_blk_no, unsigned long long *cp_version]\n- 调用者: f2fs_get_valid_checkpoint\n- 被调用者: 未显示\n\n3. 函数名: f2fs_kzalloc\n- 参数: [struct f2fs_sb_info *sbi, size_t size, gfp_t flags]\n- 调用者: f2fs_get_valid_checkpoint\n- 被调用者: 未显示\n\n4. 函数名: ver_after\n- 参数: [unsigned long long cp2_version, unsigned long long cp1_version]\n- 调用者: f2fs_get_valid_checkpoint\n- 被调用者: 未显示\n\n5. 函数名: page_address\n- 参数: [struct page *page]\n- 调用者: f2fs_get_valid_checkpoint\n- 被调用者: 未显示\n\n6. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: f2fs_get_valid_checkpoint\n- 被调用者: 未显示\n\n7. 函数名: f2fs_sanity_check_ckpt\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_get_valid_checkpoint\n- 被调用者: 未显示\n\n8. 函数名: f2fs_get_meta_page\n- 参数: [struct f2fs_sb_info *sbi, block_t blk_addr]\n- 调用者: f2fs_get_valid_checkpoint\n- 被调用者: 未显示\n\n9. 函数名: f2fs_put_page\n- 参数: [struct page *page, int unlock]\n- 调用者: f2fs_get_valid_checkpoint\n- 被调用者: 未显示\n\n10. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: f2fs_get_valid_checkpoint\n- 被调用者: 未显示"
    },
    {
        "id": 1685,
        "cwe": "CWE-476",
        "cve": "CVE-2018-14614",
        "purpose": "Code purpose:\"\"\"该代码用于检查F2FS文件系统检查点的完整性，验证各种段和块计数是否在合理范围内，防止文件系统损坏或异常情况发生。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在__remove_dirty_segment()函数中存在对脏段(dirty segment)的越界访问，当挂载f2fs镜像时未正确验证段号的有效性\"\"\"",
        "functions": "Functions:\n1. 函数名: f2fs_sanity_check_ckpt\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: (未在代码片段中显示)\n- 被调用者: [le32_to_cpu, le64_to_cpu, le16_to_cpu, f2fs_msg, f2fs_cp_error]\n\n2. 函数名: le32_to_cpu\n- 参数: [unsigned int value]\n- 调用者: f2fs_sanity_check_ckpt\n- 被调用者: []\n\n3. 函数名: le64_to_cpu\n- 参数: [unsigned long long value]\n- 调用者: f2fs_sanity_check_ckpt\n- 被调用者: []\n\n4. 函数名: le16_to_cpu\n- 参数: [unsigned short value]\n- 调用者: f2fs_sanity_check_ckpt\n- 被调用者: []\n\n5. 函数名: f2fs_msg\n- 参数: [struct super_block *sb, int level, const char *fmt, ...]\n- 调用者: f2fs_sanity_check_ckpt\n- 被调用者: []\n\n6. 函数名: f2fs_cp_error\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_sanity_check_ckpt\n- 被调用者: []"
    },
    {
        "id": 1687,
        "cwe": "CWE-476",
        "cve": "CVE-2018-14616",
        "purpose": "Code purpose:\"\"\"分配并初始化一个用于读取加密f2fs文件系统数据的bio结构体，处理可能的解密操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当操作损坏的f2fs镜像文件时，fscrypt_do_page_crypto()函数中出现了空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: f2fs_grab_read_bio\n- 参数: [struct inode *inode, block_t blkaddr, unsigned nr_pages, unsigned op_flag]\n- 调用者: 未指定\n- 被调用者: [F2FS_I_SB, f2fs_bio_alloc, f2fs_target_device, bio_set_op_attrs, f2fs_encrypted_file, mempool_alloc, bio_put, f2fs_wait_on_block_writeback]\n\n2. 函数名: F2FS_I_SB\n- 参数: [struct inode *inode]\n- 调用者: f2fs_grab_read_bio\n- 被调用者: 未指定\n\n3. 函数名: f2fs_bio_alloc\n- 参数: [struct f2fs_sb_info *sbi, int nr_pages, bool is_sync]\n- 调用者: f2fs_grab_read_bio\n- 被调用者: 未指定\n\n4. 函数名: f2fs_target_device\n- 参数: [struct f2fs_sb_info *sbi, block_t blkaddr, struct bio *bio]\n- 调用者: f2fs_grab_read_bio\n- 被调用者: 未指定\n\n5. 函数名: bio_set_op_attrs\n- 参数: [struct bio *bio, unsigned op, unsigned op_flags]\n- 调用者: f2fs_grab_read_bio\n- 被调用者: 未指定\n\n6. 函数名: f2fs_encrypted_file\n- 参数: [struct inode *inode]\n- 调用者: f2fs_grab_read_bio\n- 被调用者: 未指定\n\n7. 函数名: mempool_alloc\n- 参数: [mempool_t *pool, gfp_t gfp_mask]\n- 调用者: f2fs_grab_read_bio\n- 被调用者: 未指定\n\n8. 函数名: bio_put\n- 参数: [struct bio *bio]\n- 调用者: f2fs_grab_read_bio\n- 被调用者: 未指定\n\n9. 函数名: f2fs_wait_on_block_writeback\n- 参数: [struct f2fs_sb_info *sbi, block_t blkaddr]\n- 调用者: f2fs_grab_read_bio\n- 被调用者: 未指定"
    },
    {
        "id": 1688,
        "cwe": "CWE-476",
        "cve": "CVE-2018-14616",
        "purpose": "Code purpose:\"\"\"读取并解析f2fs文件系统中的inode信息，包括权限、时间戳、扩展属性等元数据，并进行有效性检查\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在操作损坏的f2fs镜像文件时，由于未对空指针进行有效检查，导致fscrypt_do_page_crypto()函数中出现空指针解引用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: do_read_inode\n- 参数: [struct inode *inode]\n- 调用者: N/A\n- 被调用者: [f2fs_check_nid_range, f2fs_get_node_page, IS_ERR, PTR_ERR, F2FS_INODE, le16_to_cpu, le32_to_cpu, i_uid_write, i_gid_write, set_nlink, le64_to_cpu, SECTOR_FROM_BLOCK, S_ISDIR, S_ISREG, f2fs_init_extent_tree, set_page_dirty, get_inline_info, f2fs_has_extra_attr, f2fs_sb_has_flexible_inline_xattr, f2fs_has_inline_xattr, f2fs_has_inline_dentry, sanity_check_inode, f2fs_put_page, f2fs_has_inline_data, f2fs_exist_data, __recover_inline_status, __get_inode_rdev, __written_first_block, set_inode_flag, f2fs_need_inode_block_update, f2fs_sb_has_project_quota, F2FS_FITS_IN_INODE, make_kprojid, f2fs_sb_has_inode_crtime, stat_inc_inline_xattr, stat_inc_inline_inode, stat_inc_inline_dir]\n\n2. 函数名: f2fs_check_nid_range\n- 参数: [struct f2fs_sb_info *sbi, unsigned int nid]\n- 调用者: do_read_inode\n- 被调用者: N/A\n\n3. 函数名: f2fs_get_node_page\n- 参数: [struct f2fs_sb_info *sbi, unsigned int nid]\n- 调用者: do_read_inode\n- 被调用者: N/A\n\n4. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: do_read_inode\n- 被调用者: N/A\n\n5. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: do_read_inode\n- 被调用者: N/A\n\n6. 函数名: F2FS_INODE\n- 参数: [struct page *node_page]\n- 调用者: do_read_inode\n- 被调用者: N/A\n\n7. 函数名: f2fs_init_extent_tree\n- 参数: [struct inode *inode, struct f2fs_extent *i_ext]\n- 调用者: do_read_inode\n- 被调用者: N/A\n\n8. 函数名: set_page_dirty\n- 参数: [struct page *page]\n- 调用者: do_read_inode\n- 被调用者: N/A\n\n9. 函数名: get_inline_info\n- 参数: [struct inode *inode, struct f2fs_inode *ri]\n- 调用者: do_read_inode\n- 被调用者: N/A\n\n10. 函数名: sanity_check_inode\n- 参数: [struct inode *inode, struct page *node_page]\n- 调用者: do_read_inode\n- 被调用者: N/A\n\n11. 函数名: f2fs_put_page\n- 参数: [struct page *page, int unlock]\n- 调用者: do_read_inode\n- 被调用者: N/A\n\n12. 函数名: __recover_inline_status\n- 参数: [struct inode *inode, struct page *node_page]\n- 调用者: do_read_inode\n- 被调用者: N/A\n\n13. 函数名: __get_inode_rdev\n- 参数: [struct inode *inode, struct f2fs_inode *ri]\n- 调用者: do_read_inode\n- 被调用者: N/A\n\n14. 函数名: __written_first_block\n- 参数: [struct f2fs_sb_info *sbi, struct f2fs_inode *ri]\n- 调用者: do_read_inode\n- 被调用者: N/A\n\n15. 函数名: set_inode_flag\n- 参数: [struct inode *inode, unsigned int flag]\n- 调用者: do_read_inode\n- 被调用者: N/A\n\n16. 函数名: f2fs_need_inode_block_update\n- 参数: [struct f2fs_sb_info *sbi, unsigned int ino]\n- 调用者: do_read_inode\n- 被调用者: N/A\n\n17. 函数名: make_kprojid\n- 参数: [struct user_namespace *ns, projid_t projid]\n- 调用者: do_read_inode\n- 被调用者: N/A\n\n18. 函数名: stat_inc_inline_xattr\n- 参数: [struct inode *inode]\n- 调用者: do_read_inode\n- 被调用者: N/A\n\n19. 函数名: stat_inc_inline_inode\n- 参数: [struct inode *inode]\n- 调用者: do_read_inode\n- 被调用者: N/A\n\n20. 函数名: stat_inc_inline_dir\n- 参数: [struct inode *inode]\n- 调用者: do_read_inode\n- 被调用者: N/A"
    },
    {
        "id": 1689,
        "cwe": "CWE-476",
        "cve": "CVE-2018-14616",
        "purpose": "Code purpose:\"\"\"检查f2fs文件系统中第一个数据块地址是否有效\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理损坏的f2fs镜像文件时，未对指针进行有效检查导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: __written_first_block\n- 参数: [sbi, ri]\n- 调用者: 未提供\n- 被调用者: [le32_to_cpu, offset_in_addr, is_valid_data_blkaddr]\n\n2. 函数名: le32_to_cpu\n- 参数: [ri->i_addr[offset_in_addr(ri)]]\n- 调用者: __written_first_block\n- 被调用者: 未提供\n\n3. 函数名: offset_in_addr\n- 参数: [ri]\n- 调用者: __written_first_block\n- 被调用者: 未提供\n\n4. 函数名: is_valid_data_blkaddr\n- 参数: [sbi, addr]\n- 调用者: __written_first_block\n- 被调用者: 未提供"
    },
    {
        "id": 1690,
        "cwe": "CWE-476",
        "cve": "CVE-2018-14617",
        "purpose": "Code purpose:\"\"\"该代码用于在HFS+文件系统中查找目录项并处理硬链接，返回对应的inode结构以便进行文件操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在读取损坏的HFS+文件系统目录项时，由于未充分验证硬链接相关数据的有效性，导致可能对空指针进行解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: hfsplus_lookup\n- 参数: [struct inode *dir, struct dentry *dentry, unsigned int flags]\n- 调用者: 文件系统调用\n- 被调用者: [hfs_find_init, hfsplus_cat_build_key, hfs_brec_read, hfs_find_exit, hfsplus_iget, d_splice_alias, ERR_PTR, ERR_CAST, be16_to_cpu, be32_to_cpu, cpu_to_be32, HFSPLUS_I, HFSPLUS_SB, d_inode, pr_err, sprintf]\n\n2. 函数名: hfs_find_init\n- 参数: [HFSPLUS_SB(sb)->cat_tree, &fd]\n- 调用者: hfsplus_lookup\n- 被调用者: []\n\n3. 函数名: hfsplus_cat_build_key\n- 参数: [sb, fd.search_key, dir->i_ino, &dentry->d_name]\n- 调用者: hfsplus_lookup\n- 被调用者: []\n\n4. 函数名: hfs_brec_read\n- 参数: [&fd, &entry, sizeof(entry)]\n- 调用者: hfsplus_lookup\n- 被调用者: []\n\n5. 函数名: hfs_find_exit\n- 参数: [&fd]\n- 调用者: hfsplus_lookup\n- 被调用者: []\n\n6. 函数名: hfsplus_iget\n- 参数: [dir->i_sb, cnid]\n- 调用者: hfsplus_lookup\n- 被调用者: []\n\n7. 函数名: d_splice_alias\n- 参数: [inode, dentry]\n- 调用者: hfsplus_lookup\n- 被调用者: []\n\n8. 函数名: ERR_PTR\n- 参数: [err]\n- 调用者: hfsplus_lookup\n- 被调用者: []\n\n9. 函数名: ERR_CAST\n- 参数: [inode]\n- 调用者: hfsplus_lookup\n- 被调用者: []\n\n10. 函数名: be16_to_cpu\n- 参数: [entry.type]\n- 调用者: hfsplus_lookup\n- 被调用者: []\n\n11. 函数名: be32_to_cpu\n- 参数: [entry.folder.id], [entry.file.id], [entry.file.permissions.dev]\n- 调用者: hfsplus_lookup\n- 被调用者: []\n\n12. 函数名: cpu_to_be32\n- 参数: [HFSP_HARDLINK_TYPE], [HFSP_HFSPLUS_CREATOR]\n- 调用者: hfsplus_lookup\n- 被调用者: []\n\n13. 函数名: HFSPLUS_I\n- 参数: [HFSPLUS_SB(sb)->hidden_dir], [inode]\n- 调用者: hfsplus_lookup\n- 被调用者: []\n\n14. 函数名: HFSPLUS_SB\n- 参数: [sb]\n- 调用者: hfsplus_lookup\n- 被调用者: []\n\n15. 函数名: d_inode\n- 参数: [sb->s_root]\n- 调用者: hfsplus_lookup\n- 被调用者: []\n\n16. 函数名: pr_err\n- 参数: [\"invalid catalog entry type in lookup\"]\n- 调用者: hfsplus_lookup\n- 被调用者: []\n\n17. 函数名: sprintf\n- 参数: [name, \"iNode%d\", linkid]\n- 调用者: hfsplus_lookup\n- 被调用者: []"
    },
    {
        "id": 1701,
        "cwe": "CWE-476",
        "cve": "CVE-2018-14646",
        "purpose": "Code purpose:\"\"\"该代码用于处理网络链接信息的获取请求，包括解析网络命名空间ID、查找网络设备并返回相关信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当分配了带有netnsid的网络命名空间时，__netlink_ns_capable()函数中的空指针解引用导致内核崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: rtnl_getlink\n- 参数: [skb, nlh, extack]\n- 调用者: 无（顶层函数）\n- 被调用者: [sock_net, nlmsg_parse, nla_get_s32, get_target_net, PTR_ERR, nla_strlcpy, nla_get_u32, nlmsg_data, __dev_get_by_index, __dev_get_by_name, nlmsg_new, if_nlmsg_size, rtnl_fill_ifinfo, WARN_ON, kfree_skb, rtnl_unicast, put_net]\n\n2. 函数名: sock_net\n- 参数: [sk]\n- 调用者: rtnl_getlink\n- 被调用者: 无\n\n3. 函数名: nlmsg_parse\n- 参数: [nlh, sizeof(*ifm), tb, IFLA_MAX, ifla_policy, extack]\n- 调用者: rtnl_getlink\n- 被调用者: 无\n\n4. 函数名: nla_get_s32\n- 参数: [tb[IFLA_IF_NETNSID]]\n- 调用者: rtnl_getlink\n- 被调用者: 无\n\n5. 函数名: get_target_net\n- 参数: [skb, netnsid]\n- 调用者: rtnl_getlink\n- 被调用者: 无\n\n6. 函数名: PTR_ERR\n- 参数: [tgt_net]\n- 调用者: rtnl_getlink\n- 被调用者: 无\n\n7. 函数名: nla_strlcpy\n- 参数: [ifname, tb[IFLA_IFNAME], IFNAMSIZ]\n- 调用者: rtnl_getlink\n- 被调用者: 无\n\n8. 函数名: nla_get_u32\n- 参数: [tb[IFLA_EXT_MASK]]\n- 调用者: rtnl_getlink\n- 被调用者: 无\n\n9. 函数名: nlmsg_data\n- 参数: [nlh]\n- 调用者: rtnl_getlink\n- 被调用者: 无\n\n10. 函数名: __dev_get_by_index\n- 参数: [tgt_net, ifm->ifi_index]\n- 调用者: rtnl_getlink\n- 被调用者: 无\n\n11. 函数名: __dev_get_by_name\n- 参数: [tgt_net, ifname]\n- 调用者: rtnl_getlink\n- 被调用者: 无\n\n12. 函数名: nlmsg_new\n- 参数: [if_nlmsg_size(dev, ext_filter_mask), GFP_KERNEL]\n- 调用者: rtnl_getlink\n- 被调用者: [if_nlmsg_size]\n\n13. 函数名: if_nlmsg_size\n- 参数: [dev, ext_filter_mask]\n- 调用者: nlmsg_new\n- 被调用者: 无\n\n14. 函数名: rtnl_fill_ifinfo\n- 参数: [nskb, dev, net, RTM_NEWLINK, NETLINK_CB(skb).portid, nlh->nlmsg_seq, 0, 0, ext_filter_mask, 0, NULL, netnsid]\n- 调用者: rtnl_getlink\n- 被调用者: 无\n\n15. 函数名: WARN_ON\n- 参数: [err == -EMSGSIZE]\n- 调用者: rtnl_getlink\n- 被调用者: 无\n\n16. 函数名: kfree_skb\n- 参数: [nskb]\n- 调用者: rtnl_getlink\n- 被调用者: 无\n\n17. 函数名: rtnl_unicast\n- 参数: [nskb, net, NETLINK_CB(skb).portid]\n- 调用者: rtnl_getlink\n- 被调用者: 无\n\n18. 函数名: put_net\n- 参数: [tgt_net]\n- 调用者: rtnl_getlink\n- 被调用者: 无"
    },
    {
        "id": 1702,
        "cwe": "CWE-476",
        "cve": "CVE-2018-14646",
        "purpose": "Code purpose:\"\"\"该代码片段实现了通过网络链接回调函数获取和转储网络接口信息的功能，包括处理网络命名空间、过滤条件和设备索引等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当分配了具有netnsid的网络命名空间时，__netlink_ns_capable()函数中的NULL指针解引用导致内核崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: rtnl_dump_ifinfo\n- 参数: [struct sk_buff *skb, struct netlink_callback *cb]\n- 调用者: N/A\n- 被调用者: [sock_net, nlmsg_len, nlmsg_parse, nla_get_s32, get_target_net, IS_ERR, nla_get_u32, linkinfo_to_kind_ops, link_dump_filtered, rtnl_fill_ifinfo, put_net, nl_dump_check_consistent]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: rtnl_dump_ifinfo\n- 被调用者: N/A\n\n3. 函数名: nlmsg_len\n- 参数: [struct nlmsghdr *nlh]\n- 调用者: rtnl_dump_ifinfo\n- 被调用者: N/A\n\n4. 函数名: nlmsg_parse\n- 参数: [struct nlmsghdr *nlh, int hdrlen, struct nlattr *tb[], int maxtype, const struct nla_policy *policy, struct netlink_ext_ack *extack]\n- 调用者: rtnl_dump_ifinfo\n- 被调用者: N/A\n\n5. 函数名: nla_get_s32\n- 参数: [const struct nlattr *nla]\n- 调用者: rtnl_dump_ifinfo\n- 被调用者: N/A\n\n6. 函数名: get_target_net\n- 参数: [struct sk_buff *skb, int netnsid]\n- 调用者: rtnl_dump_ifinfo\n- 被调用者: N/A\n\n7. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: rtnl_dump_ifinfo\n- 被调用者: N/A\n\n8. 函数名: nla_get_u32\n- 参数: [const struct nlattr *nla]\n- 调用者: rtnl_dump_ifinfo\n- 被调用者: N/A\n\n9. 函数名: linkinfo_to_kind_ops\n- 参数: [struct nlattr *tb]\n- 调用者: rtnl_dump_ifinfo\n- 被调用者: N/A\n\n10. 函数名: link_dump_filtered\n- 参数: [struct net_device *dev, int master_idx, const struct rtnl_link_ops *kind_ops]\n- 调用者: rtnl_dump_ifinfo\n- 被调用者: N/A\n\n11. 函数名: rtnl_fill_ifinfo\n- 参数: [struct sk_buff *skb, struct net_device *dev, struct net *net, int type, u32 pid, u32 seq, u32 change, unsigned int flags, u32 ext_filter_mask, int ifindex, struct net_device *master_dev, int netnsid]\n- 调用者: rtnl_dump_ifinfo\n- 被调用者: N/A\n\n12. 函数名: put_net\n- 参数: [struct net *net]\n- 调用者: rtnl_dump_ifinfo\n- 被调用者: N/A\n\n13. 函数名: nl_dump_check_consistent\n- 参数: [struct netlink_callback *cb, struct nlmsghdr *nlh]\n- 调用者: rtnl_dump_ifinfo\n- 被调用者: N/A"
    },
    {
        "id": 1716,
        "cwe": "CWE-476",
        "cve": "CVE-2018-16871",
        "purpose": "Code purpose:\"\"\"验证NFS复制操作中源文件和目标文件的状态ID有效性，并检查文件类型是否为常规文件\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理NFS文件复制操作时，代码未能正确验证源文件和目标文件的状态，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: nfsd4_verify_copy\n- 参数: [struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, stateid_t *src_stateid, struct file **src, stateid_t *dst_stateid, struct file **dst]\n- 调用者: N/A (顶层函数)\n- 被调用者: [nfs4_preprocess_stateid_op, dprintk, fput, file_inode, S_ISREG]\n\n2. 函数名: nfs4_preprocess_stateid_op\n- 参数: [struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct svc_fh *fh, stateid_t *stateid, int flags, struct file **filp, struct nfs4_ol_stateid **stp]\n- 调用者: nfsd4_verify_copy\n- 被调用者: N/A (假设是底层函数)\n\n3. 函数名: dprintk\n- 参数: [const char *fmt, ...]\n- 调用者: nfsd4_verify_copy\n- 被调用者: N/A (内核打印函数)\n\n4. 函数名: fput\n- 参数: [struct file *file]\n- 调用者: nfsd4_verify_copy\n- 被调用者: N/A (内核文件操作函数)\n\n5. 函数名: file_inode\n- 参数: [struct file *file]\n- 调用者: nfsd4_verify_copy\n- 被调用者: N/A (内核文件系统函数)\n\n6. 函数名: S_ISREG\n- 参数: [mode_t mode]\n- 调用者: nfsd4_verify_copy\n- 被调用者: N/A (宏/内核文件系统函数)"
    },
    {
        "id": 1743,
        "cwe": "CWE-476",
        "cve": "CVE-2018-19406",
        "purpose": "Code purpose:\"\"\"该代码用于在KVM虚拟化环境中处理处理器间中断(IPI)的发送，通过位图指定目标APIC ID并设置中断请求参数，最终将中断传递给目标虚拟CPU。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当apic_map未初始化时，代码直接解引用map指针导致NULL指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: kvm_pv_send_ipi\n- 参数: [struct kvm *kvm, unsigned long ipi_bitmap_low, unsigned long ipi_bitmap_high, u32 min, unsigned long icr, int op_64_bit]\n- 调用者: 系统调用（未明确显示）\n- 被调用者: [rcu_read_lock, rcu_dereference, for_each_set_bit, kvm_apic_set_irq, rcu_read_unlock]\n\n2. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: kvm_pv_send_ipi\n- 被调用者: []\n\n3. 函数名: rcu_dereference\n- 参数: [struct kvm *kvm->arch.apic_map]\n- 调用者: kvm_pv_send_ipi\n- 被调用者: []\n\n4. 函数名: for_each_set_bit\n- 参数: [i, &ipi_bitmap_low, min((u32)BITS_PER_LONG, (map->max_apic_id - min + 1))] 和 [i, &ipi_bitmap_high, min((u32)BITS_PER_LONG, (map->max_apic_id - min + 1))]\n- 调用者: kvm_pv_send_ipi\n- 被调用者: []\n\n5. 函数名: kvm_apic_set_irq\n- 参数: [struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq, NULL]\n- 调用者: kvm_pv_send_ipi\n- 被调用者: []\n\n6. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: kvm_pv_send_ipi\n- 被调用者: []"
    },
    {
        "id": 1744,
        "cwe": "CWE-476",
        "cve": "CVE-2018-19407",
        "purpose": "Code purpose:\"\"\"扫描和处理虚拟CPU的IOAPIC中断向量，包括同步中断请求和更新中断处理状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当ioapic未初始化时，通过精心设计的系统调用可能导致空指针解引用，造成拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: vcpu_scan_ioapic\n- 参数: [vcpu]\n- 调用者: N/A\n- 被调用者: [kvm_apic_hw_enabled, bitmap_zero, irqchip_split, kvm_scan_ioapic_routes, kvm_x86_ops->sync_pir_to_irr, kvm_ioapic_scan_entry, is_guest_mode, kvm_make_request]\n\n2. 函数名: kvm_apic_hw_enabled\n- 参数: [vcpu->arch.apic]\n- 调用者: vcpu_scan_ioapic\n- 被调用者: N/A\n\n3. 函数名: bitmap_zero\n- 参数: [vcpu->arch.ioapic_handled_vectors, 256]\n- 调用者: vcpu_scan_ioapic\n- 被调用者: N/A\n\n4. 函数名: irqchip_split\n- 参数: [vcpu->kvm]\n- 调用者: vcpu_scan_ioapic\n- 被调用者: N/A\n\n5. 函数名: kvm_scan_ioapic_routes\n- 参数: [vcpu, vcpu->arch.ioapic_handled_vectors]\n- 调用者: vcpu_scan_ioapic\n- 被调用者: N/A\n\n6. 函数名: kvm_x86_ops->sync_pir_to_irr\n- 参数: [vcpu]\n- 调用者: vcpu_scan_ioapic\n- 被调用者: N/A\n\n7. 函数名: kvm_ioapic_scan_entry\n- 参数: [vcpu, vcpu->arch.ioapic_handled_vectors]\n- 调用者: vcpu_scan_ioapic\n- 被调用者: N/A\n\n8. 函数名: is_guest_mode\n- 参数: [vcpu]\n- 调用者: vcpu_scan_ioapic\n- 被调用者: N/A\n\n9. 函数名: kvm_make_request\n- 参数: [KVM_REQ_LOAD_EOI_EXITMAP, vcpu]\n- 调用者: vcpu_scan_ioapic\n- 被调用者: N/A"
    },
    {
        "id": 1820,
        "cwe": "CWE-476",
        "cve": "CVE-2018-5333",
        "purpose": "Code purpose:\"\"\"处理RDS(Reliable Datagram Sockets)协议中的原子操作消息，包括设置操作类型、验证地址对齐、固定内存页面以及准备远程DMA操作的相关参数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当页面固定失败或提供无效地址时，rds_cmsg_atomic函数未能正确处理错误路径，导致后续rds_atomic_free_op操作中出现空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: rds_cmsg_atomic\n- 参数: [rs, rm, cmsg]\n- 调用者: 未指定\n- 被调用者: [rds_message_alloc_sgs, rds_pin_pages, sg_set_page, kmalloc, put_page, kfree]\n\n2. 函数名: rds_message_alloc_sgs\n- 参数: [rm, 1]\n- 调用者: rds_cmsg_atomic\n- 被调用者: 未指定\n\n3. 函数名: rds_pin_pages\n- 参数: [args->local_addr, 1, &page, 1]\n- 调用者: rds_cmsg_atomic\n- 被调用者: 未指定\n\n4. 函数名: sg_set_page\n- 参数: [rm->atomic.op_sg, page, 8, offset_in_page(args->local_addr)]\n- 调用者: rds_cmsg_atomic\n- 被调用者: 未指定\n\n5. 函数名: kmalloc\n- 参数: [sizeof(*rm->atomic.op_notifier), GFP_KERNEL]\n- 调用者: rds_cmsg_atomic\n- 被调用者: 未指定\n\n6. 函数名: put_page\n- 参数: [page]\n- 调用者: rds_cmsg_atomic\n- 被调用者: 未指定\n\n7. 函数名: kfree\n- 参数: [rm->atomic.op_notifier]\n- 调用者: rds_cmsg_atomic\n- 被调用者: 未指定"
    },
    {
        "id": 1843,
        "cwe": "CWE-476",
        "cve": "CVE-2018-7191",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中tun设备的创建和配置功能，通过ioctl(TUNSETIFF)调用来设置虚拟网络设备的参数和属性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未在注册网络设备前调用dev_get_valid_name验证设备名称，导致包含非法字符(如/)的设备名引发空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: tun_set_iff\n- 参数: [net, file, ifr]\n- 调用者: 未显示（应为ioctl调用者）\n- 被调用者: [__dev_get_by_name, netdev_priv, tun_not_capable, security_tun_dev_open, tun_attach, ns_capable, security_tun_dev_create, alloc_netdev_mqs, dev_net_set, netdev_alloc_pcpu_stats, spin_lock_init, security_tun_dev_alloc_security, tun_net_init, tun_flow_init, register_netdevice, netif_carrier_on, tun_debug, netif_running, netif_tx_wake_all_queues, strcpy, tun_detach_all, tun_flow_uninit, security_tun_dev_free_security, free_percpu, free_netdev]\n\n2. 函数名: __dev_get_by_name\n- 参数: [net, ifr->ifr_name]\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n3. 函数名: netdev_priv\n- 参数: [dev]\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n4. 函数名: tun_not_capable\n- 参数: [tun]\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n5. 函数名: security_tun_dev_open\n- 参数: [tun->security]\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n6. 函数名: tun_attach\n- 参数: [tun, file, ifr->ifr_flags & IFF_NOFILTER]\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n7. 函数名: ns_capable\n- 参数: [net->user_ns, CAP_NET_ADMIN]\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n8. 函数名: security_tun_dev_create\n- 参数: []\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n9. 函数名: alloc_netdev_mqs\n- 参数: [sizeof(struct tun_struct), name, NET_NAME_UNKNOWN, tun_setup, queues, queues]\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n10. 函数名: dev_net_set\n- 参数: [dev, net]\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n11. 函数名: netdev_alloc_pcpu_stats\n- 参数: [struct tun_pcpu_stats]\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n12. 函数名: spin_lock_init\n- 参数: [&tun->lock]\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n13. 函数名: security_tun_dev_alloc_security\n- 参数: [&tun->security]\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n14. 函数名: tun_net_init\n- 参数: [dev]\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n15. 函数名: tun_flow_init\n- 参数: [tun]\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n16. 函数名: register_netdevice\n- 参数: [tun->dev]\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n17. 函数名: netif_carrier_on\n- 参数: [tun->dev]\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n18. 函数名: tun_debug\n- 参数: [KERN_INFO, tun, \"tun_set_iff\\n\"]\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n19. 函数名: netif_running\n- 参数: [tun->dev]\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n20. 函数名: netif_tx_wake_all_queues\n- 参数: [tun->dev]\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n21. 函数名: strcpy\n- 参数: [ifr->ifr_name, tun->dev->name]\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n22. 函数名: tun_detach_all\n- 参数: [dev]\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n23. 函数名: tun_flow_uninit\n- 参数: [tun]\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n24. 函数名: security_tun_dev_free_security\n- 参数: [tun->security]\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n25. 函数名: free_percpu\n- 参数: [tun->pcpu_stats]\n- 调用者: tun_set_iff\n- 被调用者: 未显示\n\n26. 函数名: free_netdev\n- 参数: [dev]\n- 调用者: tun_set_iff\n- 被调用者: 未显示"
    },
    {
        "id": 1844,
        "cwe": "CWE-476",
        "cve": "CVE-2018-7191",
        "purpose": "Code purpose:\"\"\"验证并处理网络设备名称的有效性，防止无效名称导致的系统问题\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未在register_netdevice前调用dev_get_valid_name验证设备名称，导致包含非法字符(如/)的名称引发空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: dev_get_valid_name\n- 参数: [struct net *net, struct net_device *dev, const char *name]\n- 调用者: 未显示（根据漏洞描述可能被ioctl(TUNSETIFF)调用）\n- 被调用者: [dev_valid_name, strchr, dev_alloc_name_ns, __dev_get_by_name, strlcpy]\n\n2. 函数名: dev_valid_name\n- 参数: [const char *name]\n- 调用者: dev_get_valid_name\n- 被调用者: []\n\n3. 函数名: strchr\n- 参数: [const char *name, int '%']\n- 调用者: dev_get_valid_name\n- 被调用者: []\n\n4. 函数名: dev_alloc_name_ns\n- 参数: [struct net *net, struct net_device *dev, const char *name]\n- 调用者: dev_get_valid_name\n- 被调用者: []\n\n5. 函数名: __dev_get_by_name\n- 参数: [struct net *net, const char *name]\n- 调用者: dev_get_valid_name\n- 被调用者: []\n\n6. 函数名: strlcpy\n- 参数: [char *dev->name, const char *name, size_t IFNAMSIZ]\n- 调用者: dev_get_valid_name\n- 被调用者: []"
    },
    {
        "id": 1846,
        "cwe": "CWE-476",
        "cve": "CVE-2018-7492",
        "purpose": "Code purpose:\"\"\"该代码用于在RDS(Reliable Datagram Sockets)协议中实现远程直接内存访问(RDMA)的内存区域映射功能，包括分配内存页、创建分散/聚集列表、获取传输特定的内存区域等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在__rds_rdma_map函数中，当rs->rs_transport->get_mr返回错误时，未对trans_private进行NULL检查就直接使用，导致空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: __rds_rdma_map\n- 参数: [struct rds_sock *rs, struct rds_get_mr_args *args, u64 *cookie_ret, struct rds_mr **mr_ret]\n- 调用者: 未明确（应为RDS协议相关调用）\n- 被调用者: [rds_pages_in_vec, kcalloc, kzalloc, refcount_set, rds_pin_pages, sg_init_table, sg_set_page, put_page, kfree, PTR_ERR, rds_rdma_make_cookie, put_user, spin_lock_irqsave, rds_mr_tree_walk, spin_unlock_irqrestore, refcount_inc, rds_mr_put]\n\n2. 函数名: rds_pages_in_vec\n- 参数: [struct rds_iovec *vec]\n- 调用者: __rds_rdma_map\n- 被调用者: []\n\n3. 函数名: rds_pin_pages\n- 参数: [unsigned long addr, unsigned int nr_pages, struct page **pages, int write]\n- 调用者: __rds_rdma_map\n- 被调用者: []\n\n4. 函数名: sg_init_table\n- 参数: [struct scatterlist *sgl, unsigned int nents]\n- 调用者: __rds_rdma_map\n- 被调用者: []\n\n5. 函数名: sg_set_page\n- 参数: [struct scatterlist *sg, struct page *page, unsigned int len, unsigned int offset]\n- 调用者: __rds_rdma_map\n- 被调用者: []\n\n6. 函数名: put_page\n- 参数: [struct page *page]\n- 调用者: __rds_rdma_map\n- 被调用者: []\n\n7. 函数名: rds_rdma_make_cookie\n- 参数: [u32 r_key, u32 offset]\n- 调用者: __rds_rdma_map\n- 被调用者: []\n\n8. 函数名: rds_mr_tree_walk\n- 参数: [struct rb_root *root, u32 key, struct rds_mr *insert]\n- 调用者: __rds_rdma_map\n- 被调用者: []\n\n9. 函数名: rds_mr_put\n- 参数: [struct rds_mr *mr]\n- 调用者: __rds_rdma_map\n- 被调用者: []"
    },
    {
        "id": 1858,
        "cwe": "CWE-476",
        "cve": "CVE-2018-8043",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中Broadcom UniMAC MDIO总线的探测和初始化功能，用于管理网络PHY设备的通信。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"函数未对platform_get_resource()返回的资源指针进行有效性检查就直接使用，可能导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: unimac_mdio_probe\n- 参数: [struct platform_device *pdev]\n- 调用者: 平台驱动子系统\n- 被调用者: [devm_kzalloc, platform_get_resource, devm_ioremap, dev_err, mdiobus_alloc, snprintf, of_mdiobus_register, platform_set_drvdata, dev_info, mdiobus_free]\n\n2. 函数名: devm_kzalloc\n- 参数: [struct device *dev, size_t size, gfp_t gfp]\n- 调用者: unimac_mdio_probe\n- 被调用者: []\n\n3. 函数名: platform_get_resource\n- 参数: [struct platform_device *dev, unsigned int type, unsigned int num]\n- 调用者: unimac_mdio_probe\n- 被调用者: []\n\n4. 函数名: devm_ioremap\n- 参数: [struct device *dev, resource_size_t offset, resource_size_t size]\n- 调用者: unimac_mdio_probe\n- 被调用者: []\n\n5. 函数名: dev_err\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: unimac_mdio_probe\n- 被调用者: []\n\n6. 函数名: mdiobus_alloc\n- 参数: [void]\n- 调用者: unimac_mdio_probe\n- 被调用者: []\n\n7. 函数名: snprintf\n- 参数: [char *str, size_t size, const char *format, ...]\n- 调用者: unimac_mdio_probe\n- 被调用者: []\n\n8. 函数名: of_mdiobus_register\n- 参数: [struct mii_bus *mdio, struct device_node *np]\n- 调用者: unimac_mdio_probe\n- 被调用者: []\n\n9. 函数名: platform_set_drvdata\n- 参数: [struct platform_device *pdev, void *data]\n- 调用者: unimac_mdio_probe\n- 被调用者: []\n\n10. 函数名: dev_info\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: unimac_mdio_probe\n- 被调用者: []\n\n11. 函数名: mdiobus_free\n- 参数: [struct mii_bus *bus]\n- 调用者: unimac_mdio_probe\n- 被调用者: []"
    },
    {
        "id": 1931,
        "cwe": "CWE-476",
        "cve": "CVE-2019-11810",
        "purpose": "Code purpose:\"\"\"为SCSI设备分配命令结构体数组并初始化，包括内存分配和帧池创建\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当megasas_create_frame_pool()函数调用失败时，未正确处理实例指针，导致后续操作中出现空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: megasas_alloc_cmds\n- 参数: [struct megasas_instance *instance]\n- 调用者: 未显示\n- 被调用者: [kcalloc, dev_printk, memset, kmalloc, kfree, list_add_tail, megasas_create_frame_pool, megasas_free_cmds]\n\n2. 函数名: kcalloc\n- 参数: [max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL]\n- 调用者: megasas_alloc_cmds\n- 被调用者: 无\n\n3. 函数名: dev_printk\n- 参数: [KERN_DEBUG, &instance->pdev->dev, \"out of memory\\n\"]\n- 调用者: megasas_alloc_cmds\n- 被调用者: 无\n\n4. 函数名: memset\n- 参数: [instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd]\n- 调用者: megasas_alloc_cmds\n- 被调用者: 无\n\n5. 函数名: kmalloc\n- 参数: [sizeof(struct megasas_cmd), GFP_KERNEL]\n- 调用者: megasas_alloc_cmds\n- 被调用者: 无\n\n6. 函数名: kfree\n- 参数: [instance->cmd_list[j]]\n- 调用者: megasas_alloc_cmds\n- 被调用者: 无\n\n7. 函数名: list_add_tail\n- 参数: [&cmd->list, &instance->cmd_pool]\n- 调用者: megasas_alloc_cmds\n- 被调用者: 无\n\n8. 函数名: megasas_create_frame_pool\n- 参数: [instance]\n- 调用者: megasas_alloc_cmds\n- 被调用者: 无\n\n9. 函数名: megasas_free_cmds\n- 参数: [instance]\n- 调用者: megasas_alloc_cmds\n- 被调用者: 无"
    },
    {
        "id": 1939,
        "cwe": "CWE-476",
        "cve": "CVE-2019-12378",
        "purpose": "Code purpose:\"\"\"该代码用于控制IPv6路由告警选项的添加和删除操作，通过管理一个路由告警链来实现对原始套接字的配置。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未检查kmalloc分配内存是否成功，可能导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: ip6_ra_control\n- 参数: [struct sock *sk, int sel]\n- 调用者: 未明确（通常是内核其他模块调用）\n- 被调用者: [kmalloc, write_lock_bh, write_unlock_bh, kfree, sock_put, sock_hold]\n\n2. 函数名: kmalloc\n- 参数: [sizeof(*new_ra), GFP_KERNEL]\n- 调用者: ip6_ra_control\n- 被调用者: []\n\n3. 函数名: write_lock_bh\n- 参数: [&ip6_ra_lock]\n- 调用者: ip6_ra_control\n- 被调用者: []\n\n4. 函数名: write_unlock_bh\n- 参数: [&ip6_ra_lock]\n- 调用者: ip6_ra_control\n- 被调用者: []\n\n5. 函数名: kfree\n- 参数: [new_ra], [ra]\n- 调用者: ip6_ra_control\n- 被调用者: []\n\n6. 函数名: sock_put\n- 参数: [sk]\n- 调用者: ip6_ra_control\n- 被调用者: []\n\n7. 函数名: sock_hold\n- 参数: [sk]\n- 调用者: ip6_ra_control\n- 被调用者: []"
    },
    {
        "id": 1943,
        "cwe": "CWE-476",
        "cve": "CVE-2019-12381",
        "purpose": "Code purpose:\"\"\"该代码用于控制IP套接字的原始接收处理链表的添加和删除操作，管理内核中原始套接字的接收处理函数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在分配new_ra内存时未检查kmalloc是否成功，可能导致NULL指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: ip_ra_control\n- 参数: [struct sock *sk, unsigned char on, void (*destructor)(struct sock *)]\n- 调用者: 未明确（通常是内核其他模块调用）\n- 被调用者: [kmalloc, mutex_lock, rcu_dereference_protected, lockdep_is_held, mutex_unlock, kfree, RCU_INIT_POINTER, sock_put, call_rcu, sock_hold, rcu_assign_pointer]\n\n2. 函数名: kmalloc\n- 参数: [sizeof(*new_ra), GFP_KERNEL]\n- 调用者: ip_ra_control\n- 被调用者: []\n\n3. 函数名: mutex_lock\n- 参数: [&net->ipv4.ra_mutex]\n- 调用者: ip_ra_control\n- 被调用者: []\n\n4. 函数名: rcu_dereference_protected\n- 参数: [*rap, lockdep_is_held(&net->ipv4.ra_mutex)]\n- 调用者: ip_ra_control\n- 被调用者: []\n\n5. 函数名: lockdep_is_held\n- 参数: [&net->ipv4.ra_mutex]\n- 调用者: ip_ra_control\n- 被调用者: []\n\n6. 函数名: mutex_unlock\n- 参数: [&net->ipv4.ra_mutex]\n- 调用者: ip_ra_control\n- 被调用者: []\n\n7. 函数名: kfree\n- 参数: [new_ra]\n- 调用者: ip_ra_control\n- 被调用者: []\n\n8. 函数名: RCU_INIT_POINTER\n- 参数: [*rap, ra->next]\n- 调用者: ip_ra_control\n- 被调用者: []\n\n9. 函数名: sock_put\n- 参数: [sk]\n- 调用者: ip_ra_control (通过 ra->destructor间接调用)\n- 被调用者: []\n\n10. 函数名: call_rcu\n- 参数: [&ra->rcu, ip_ra_destroy_rcu]\n- 调用者: ip_ra_control\n- 被调用者: []\n\n11. 函数名: sock_hold\n- 参数: [sk]\n- 调用者: ip_ra_control\n- 被调用者: []\n\n12. 函数名: rcu_assign_pointer\n- 参数: [*rap, new_ra]\n- 调用者: ip_ra_control\n- 被调用者: []"
    },
    {
        "id": 1944,
        "cwe": "CWE-476",
        "cve": "CVE-2019-12382",
        "purpose": "Code purpose:\"\"\"该代码用于从固件文件中加载EDID(扩展显示识别数据)到DRM(直接渲染管理器)连接器，处理多个EDID文件的选择和匹配。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未检查kstrdup()的返回值，可能导致空指针解引用和系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: drm_load_edid_firmware\n- 参数: [struct drm_connector *connector]\n- 调用者: 未显示（外部调用）\n- 被调用者: [kstrdup, strsep, strchr, strncmp, strlen, edid_load, kfree, ERR_PTR]\n\n2. 函数名: kstrdup\n- 参数: [const char *s, gfp_t gfp]\n- 调用者: drm_load_edid_firmware\n- 被调用者: 未显示（内核函数）\n\n3. 函数名: strsep\n- 参数: [char **stringp, const char *delim]\n- 调用者: drm_load_edid_firmware\n- 被调用者: 未显示（标准库函数）\n\n4. 函数名: strchr\n- 参数: [const char *s, int c]\n- 调用者: drm_load_edid_firmware\n- 被调用者: 未显示（标准库函数）\n\n5. 函数名: strncmp\n- 参数: [const char *s1, const char *s2, size_t n]\n- 调用者: drm_load_edid_firmware\n- 被调用者: 未显示（标准库函数）\n\n6. 函数名: strlen\n- 参数: [const char *s]\n- 调用者: drm_load_edid_firmware\n- 被调用者: 未显示（标准库函数）\n\n7. 函数名: edid_load\n- 参数: [struct drm_connector *connector, char *name, const char *connector_name]\n- 调用者: drm_load_edid_firmware\n- 被调用者: 未显示（外部函数）\n\n8. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: drm_load_edid_firmware\n- 被调用者: 未显示（内核函数）\n\n9. 函数名: ERR_PTR\n- 参数: [long error]\n- 调用者: drm_load_edid_firmware\n- 被调用者: 未显示（内核宏/函数）"
    },
    {
        "id": 1946,
        "cwe": "CWE-476",
        "cve": "CVE-2019-12455",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中设置和管理sunxi平台的分频时钟，包括时钟门控、分频器配置和复合时钟注册等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在sunxi_divs_clk_setup函数中，对kstrndup分配的derived_name内存未进行有效性检查，可能导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: sunxi_divs_clk_setup\n- 参数: [node, data]\n- 调用者: 未显示\n- 被调用者: [of_property_read_string_index, strchr, kstrndup, sunxi_factors_clk_setup, __clk_get_name, kfree, of_iomap, iounmap, kmalloc, kcalloc, kzalloc, clk_register_composite, of_clk_add_provider, pr_err]\n\n2. 函数名: of_property_read_string_index\n- 参数: [node, \"clock-output-names\", index, output_string]\n- 调用者: sunxi_divs_clk_setup\n- 被调用者: 未显示\n\n3. 函数名: strchr\n- 参数: [clk_name, '_']\n- 调用者: sunxi_divs_clk_setup\n- 被调用者: 未显示\n\n4. 函数名: kstrndup\n- 参数: [clk_name, length, GFP_KERNEL]\n- 调用者: sunxi_divs_clk_setup\n- 被调用者: 未显示\n\n5. 函数名: sunxi_factors_clk_setup\n- 参数: [node, factors]\n- 调用者: sunxi_divs_clk_setup\n- 被调用者: 未显示\n\n6. 函数名: __clk_get_name\n- 参数: [pclk]\n- 调用者: sunxi_divs_clk_setup\n- 被调用者: 未显示\n\n7. 函数名: kfree\n- 参数: [derived_name]\n- 调用者: sunxi_divs_clk_setup\n- 被调用者: 未显示\n\n8. 函数名: of_iomap\n- 参数: [node, 0]\n- 调用者: sunxi_divs_clk_setup\n- 被调用者: 未显示\n\n9. 函数名: iounmap\n- 参数: [reg]\n- 调用者: sunxi_divs_clk_setup\n- 被调用者: 未显示\n\n10. 函数名: kmalloc\n- 参数: [size, GFP_KERNEL]\n- 调用者: sunxi_divs_clk_setup\n- 被调用者: 未显示\n\n11. 函数名: kcalloc\n- 参数: [ndivs, sizeof(*clks), GFP_KERNEL]\n- 调用者: sunxi_divs_clk_setup\n- 被调用者: 未显示\n\n12. 函数名: kzalloc\n- 参数: [size, GFP_KERNEL]\n- 调用者: sunxi_divs_clk_setup\n- 被调用者: 未显示\n\n13. 函数名: clk_register_composite\n- 参数: [NULL, clk_name, &parent, 1, NULL, NULL, rate_hw, rate_ops, gate_hw, &clk_gate_ops, clkflags | data->div[i].critical ? CLK_IS_CRITICAL : 0]\n- 调用者: sunxi_divs_clk_setup\n- 被调用者: 未显示\n\n14. 函数名: of_clk_add_provider\n- 参数: [node, of_clk_src_onecell_get, clk_data]\n- 调用者: sunxi_divs_clk_setup\n- 被调用者: 未显示\n\n15. 函数名: pr_err\n- 参数: [format_string, __func__, clk_name]\n- 调用者: sunxi_divs_clk_setup\n- 被调用者: 未显示"
    },
    {
        "id": 1948,
        "cwe": "CWE-476",
        "cve": "CVE-2019-12614",
        "purpose": "Code purpose:\"\"\"解析并复制来自cc_workarea结构的属性名称和值到新分配的内存中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未对kstrdup分配prop->name的结果进行NULL检查，可能导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: dlpar_parse_cc_property\n- 参数: [struct cc_workarea *ccwa]\n- 调用者: 未提供\n- 被调用者: [kzalloc, be32_to_cpu, kstrdup, kmemdup, dlpar_free_cc_property]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*prop), GFP_KERNEL]\n- 调用者: dlpar_parse_cc_property\n- 被调用者: 未提供\n\n3. 函数名: be32_to_cpu\n- 参数: [ccwa->name_offset]\n- 调用者: dlpar_parse_cc_property\n- 被调用者: 未提供\n\n4. 函数名: kstrdup\n- 参数: [name, GFP_KERNEL]\n- 调用者: dlpar_parse_cc_property\n- 被调用者: 未提供\n\n5. 函数名: kmemdup\n- 参数: [value, prop->length, GFP_KERNEL]\n- 调用者: dlpar_parse_cc_property\n- 被调用者: 未提供\n\n6. 函数名: dlpar_free_cc_property\n- 参数: [prop]\n- 调用者: dlpar_parse_cc_property\n- 被调用者: 未提供"
    },
    {
        "id": 1949,
        "cwe": "CWE-476",
        "cve": "CVE-2019-12615",
        "purpose": "Code purpose:\"\"\"该代码的功能是从内存描述符中获取虚拟设备端口节点的信息，包括ID、名称和父配置句柄，并将其存储在节点信息结构中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未检查kstrdup_const的返回值，可能导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: get_vdev_port_node_info\n- 参数: [struct mdesc_handle *md, u64 node, union md_node_info *node_info]\n- 调用者: 未提供\n- 被调用者: [mdesc_get_property, parent_cfg_handle, kstrdup_const]\n\n2. 函数名: mdesc_get_property\n- 参数: [struct mdesc_handle *md, u64 node, const char *name, NULL]\n- 调用者: get_vdev_port_node_info\n- 被调用者: 未提供\n\n3. 函数名: parent_cfg_handle\n- 参数: [struct mdesc_handle *md, u64 node]\n- 调用者: get_vdev_port_node_info\n- 被调用者: 未提供\n\n4. 函数名: kstrdup_const\n- 参数: [const char *name, GFP_KERNEL]\n- 调用者: get_vdev_port_node_info\n- 被调用者: 未提供"
    },
    {
        "id": 1951,
        "cwe": "CWE-476",
        "cve": "CVE-2019-12818",
        "purpose": "Code purpose:\"\"\"该代码片段用于在NFC LLCP协议中构建并发送连接控制(CC)数据包，处理MIUX和RW参数的TLV编码，并将数据包加入发送队列。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当nfc_llcp_build_tlv函数返回NULL时，调用者未进行检查就直接使用返回值，导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: nfc_llcp_send_cc\n- 参数: [struct nfc_llcp_sock *sock]\n- 调用者: 未显示\n- 被调用者: [be16_to_cpu, nfc_llcp_build_tlv, llcp_allocate_pdu, llcp_add_tlv, skb_queue_tail, pr_err, kfree]\n\n2. 函数名: be16_to_cpu\n- 参数: [sock->miux]\n- 调用者: nfc_llcp_send_cc\n- 被调用者: 未显示\n\n3. 函数名: nfc_llcp_build_tlv\n- 参数: [LLCP_TLV_MIUX, (u8 *)&miux, 0, &miux_tlv_length] 和 [LLCP_TLV_RW, &rw, 0, &rw_tlv_length]\n- 调用者: nfc_llcp_send_cc\n- 被调用者: 未显示\n\n4. 函数名: llcp_allocate_pdu\n- 参数: [sock, LLCP_PDU_CC, size]\n- 调用者: nfc_llcp_send_cc\n- 被调用者: 未显示\n\n5. 函数名: llcp_add_tlv\n- 参数: [skb, miux_tlv, miux_tlv_length] 和 [skb, rw_tlv, rw_tlv_length]\n- 调用者: nfc_llcp_send_cc\n- 被调用者: 未显示\n\n6. 函数名: skb_queue_tail\n- 参数: [&local->tx_queue, skb]\n- 调用者: nfc_llcp_send_cc\n- 被调用者: 未显示\n\n7. 函数名: pr_err\n- 参数: [\"error %d\\n\", err]\n- 调用者: nfc_llcp_send_cc\n- 被调用者: 未显示\n\n8. 函数名: kfree\n- 参数: [miux_tlv] 和 [rw_tlv]\n- 调用者: nfc_llcp_send_cc\n- 被调用者: 未显示"
    },
    {
        "id": 1952,
        "cwe": "CWE-476",
        "cve": "CVE-2019-12818",
        "purpose": "Code purpose:\"\"\"该代码片段实现了NFC LLCP协议中发送CONNECT请求的功能，包括构建TLV（类型-长度-值）结构并将其添加到SKB缓冲区中以便传输。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当nfc_llcp_build_tlv函数返回NULL时，调用者未进行检查就直接使用返回值，导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: nfc_llcp_send_connect\n- 参数: [struct nfc_llcp_sock *sock]\n- 调用者: 未显示\n- 被调用者: [nfc_llcp_build_tlv, llcp_allocate_pdu, llcp_add_tlv, skb_queue_tail, kfree]\n\n2. 函数名: nfc_llcp_build_tlv\n- 参数: [LLCP_TLV_SN, sock->service_name, sock->service_name_len, &service_name_tlv_length]\n- 调用者: nfc_llcp_send_connect\n- 被调用者: 未显示\n\n3. 函数名: llcp_allocate_pdu\n- 参数: [sock, LLCP_PDU_CONNECT, size]\n- 调用者: nfc_llcp_send_connect\n- 被调用者: 未显示\n\n4. 函数名: llcp_add_tlv\n- 参数: [skb, service_name_tlv, service_name_tlv_length]\n- 调用者: nfc_llcp_send_connect\n- 被调用者: 未显示\n\n5. 函数名: skb_queue_tail\n- 参数: [&local->tx_queue, skb]\n- 调用者: nfc_llcp_send_connect\n- 被调用者: 未显示\n\n6. 函数名: kfree\n- 参数: [service_name_tlv]\n- 调用者: nfc_llcp_send_connect\n- 被调用者: 未显示"
    },
    {
        "id": 1953,
        "cwe": "CWE-476",
        "cve": "CVE-2019-12818",
        "purpose": "Code purpose:\"\"\"构建NFC LLCP协议的通用字节(GB)数据包，包含版本、链路超时、工作模式和最大信息单元扩展等TLV(Type-Length-Value)字段\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当nfc_llcp_build_tlv函数返回NULL时，调用者未进行检查就直接使用返回值，导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: nfc_llcp_build_gb\n- 参数: [struct nfc_llcp_local *local]\n- 调用者: 未显示\n- 被调用者: [nfc_llcp_build_tlv, cpu_to_be16, memcpy, kfree]\n\n2. 函数名: nfc_llcp_build_tlv\n- 参数: [LLCP_TLV_VERSION, &version, 1, &version_length]\n- 调用者: nfc_llcp_build_gb\n- 被调用者: 未显示\n\n3. 函数名: cpu_to_be16\n- 参数: [local->local_wks]\n- 调用者: nfc_llcp_build_gb\n- 被调用者: 未显示\n\n4. 函数名: memcpy\n- 参数: [gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic)]\n- 调用者: nfc_llcp_build_gb\n- 被调用者: 未显示\n\n5. 函数名: kfree\n- 参数: [version_tlv]\n- 调用者: nfc_llcp_build_gb\n- 被调用者: 未显示"
    },
    {
        "id": 1955,
        "cwe": "CWE-476",
        "cve": "CVE-2019-12881",
        "purpose": "Code purpose:\"\"\"该代码实现了i915显卡驱动中处理用户空间指针的ioctl操作，包括内存权限检查、对象创建和初始化，以及用户空间内存映射管理等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在i915_gem_userptr_ioctl函数中，当i915_gem_userptr_init__mm_struct或i915_gem_userptr_init__mmu_notifier调用失败时，未正确处理对象释放，可能导致空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: i915_gem_userptr_ioctl\n- 参数: [struct drm_device *dev, void *data, struct drm_file *file]\n- 调用者: 系统调用（ioctl）\n- 被调用者: [to_i915, HAS_LLC, HAS_SNOOP, offset_in_page, access_ok, i915_gem_object_alloc, drm_gem_private_object_init, i915_gem_object_init, i915_gem_object_set_cache_coherency, i915_gem_userptr_init__mm_struct, i915_gem_userptr_init__mmu_notifier, drm_gem_handle_create, i915_gem_object_put]\n\n2. 函数名: to_i915\n- 参数: [struct drm_device *dev]\n- 调用者: i915_gem_userptr_ioctl\n- 被调用者: []\n\n3. 函数名: HAS_LLC\n- 参数: [struct drm_i915_private *dev_priv]\n- 调用者: i915_gem_userptr_ioctl\n- 被调用者: []\n\n4. 函数名: HAS_SNOOP\n- 参数: [struct drm_i915_private *dev_priv]\n- 调用者: i915_gem_userptr_ioctl\n- 被调用者: []\n\n5. 函数名: offset_in_page\n- 参数: [unsigned long address]\n- 调用者: i915_gem_userptr_ioctl\n- 被调用者: []\n\n6. 函数名: access_ok\n- 参数: [int type, const void __user *addr, unsigned long size]\n- 调用者: i915_gem_userptr_ioctl\n- 被调用者: []\n\n7. 函数名: i915_gem_object_alloc\n- 参数: [struct drm_i915_private *dev_priv]\n- 调用者: i915_gem_userptr_ioctl\n- 被调用者: []\n\n8. 函数名: drm_gem_private_object_init\n- 参数: [struct drm_device *dev, struct drm_gem_object *obj, size_t size]\n- 调用者: i915_gem_userptr_ioctl\n- 被调用者: []\n\n9. 函数名: i915_gem_object_init\n- 参数: [struct drm_i915_gem_object *obj, const struct drm_i915_gem_object_ops *ops]\n- 调用者: i915_gem_userptr_ioctl\n- 被调用者: []\n\n10. 函数名: i915_gem_object_set_cache_coherency\n- 参数: [struct drm_i915_gem_object *obj, unsigned int cache_level]\n- 调用者: i915_gem_userptr_ioctl\n- 被调用者: []\n\n11. 函数名: i915_gem_userptr_init__mm_struct\n- 参数: [struct drm_i915_gem_object *obj]\n- 调用者: i915_gem_userptr_ioctl\n- 被调用者: []\n\n12. 函数名: i915_gem_userptr_init__mmu_notifier\n- 参数: [struct drm_i915_gem_object *obj, unsigned int flags]\n- 调用者: i915_gem_userptr_ioctl\n- 被调用者: []\n\n13. 函数名: drm_gem_handle_create\n- 参数: [struct drm_file *file_priv, struct drm_gem_object *obj, u32 *handlep]\n- 调用者: i915_gem_userptr_ioctl\n- 被调用者: []\n\n14. 函数名: i915_gem_object_put\n- 参数: [struct drm_i915_gem_object *obj]\n- 调用者: i915_gem_userptr_ioctl\n- 被调用者: []"
    },
    {
        "id": 1956,
        "cwe": "CWE-476",
        "cve": "CVE-2019-12984",
        "purpose": "Code purpose:\"\"\"该代码用于处理NFC设备的去激活目标请求，通过设备索引和目标索引来使指定的NFC目标进入睡眠模式。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在函数nfc_genl_deactivate_target()中未检查NFC_ATTR_TARGET_INDEX属性是否存在就直接调用nla_get_u32()，导致可能触发空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: nfc_genl_deactivate_target\n- 参数: [struct sk_buff *skb, struct genl_info *info]\n- 调用者: 未明确显示（由内核通用netlink框架调用）\n- 被调用者: [nla_get_u32, nfc_get_device, nfc_deactivate_target, nfc_put_device]\n\n2. 函数名: nla_get_u32\n- 参数: [struct nlattr *nla]\n- 调用者: nfc_genl_deactivate_target\n- 被调用者: []\n\n3. 函数名: nfc_get_device\n- 参数: [u32 device_idx]\n- 调用者: nfc_genl_deactivate_target\n- 被调用者: []\n\n4. 函数名: nfc_deactivate_target\n- 参数: [struct nfc_dev *dev, u32 target_idx, int mode]\n- 调用者: nfc_genl_deactivate_target\n- 被调用者: []\n\n5. 函数名: nfc_put_device\n- 参数: [struct nfc_dev *dev]\n- 调用者: nfc_genl_deactivate_target\n- 被调用者: []"
    },
    {
        "id": 1987,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15098",
        "purpose": "Code purpose:\"\"\"将URB上下文添加到USB管道的URB列表中并增加管道计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对pipe->ar_usb进行空指针检查，导致当pipe->ar_usb为NULL时发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: ath6kl_usb_free_urb_to_pipe\n- 参数: [pipe, urb_context]\n- 调用者: 未明确（需查看完整代码）\n- 被调用者: [spin_lock_irqsave, spin_unlock_irqrestore, list_add]\n\n2. 函数名: spin_lock_irqsave\n- 参数: [&pipe->ar_usb->cs_lock, flags]\n- 调用者: ath6kl_usb_free_urb_to_pipe\n- 被调用者: []\n\n3. 函数名: spin_unlock_irqrestore\n- 参数: [&pipe->ar_usb->cs_lock, flags]\n- 调用者: ath6kl_usb_free_urb_to_pipe\n- 被调用者: []\n\n4. 函数名: list_add\n- 参数: [&urb_context->link, &pipe->urb_list_head]\n- 调用者: ath6kl_usb_free_urb_to_pipe\n- 被调用者: []"
    },
    {
        "id": 1988,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15098",
        "purpose": "Code purpose:\"\"\"从USB管道中分配一个URB(USB请求块)上下文结构体\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对从urb_list_head获取的urb_context进行空指针检查，导致当端点描述符地址不完整时可能引发空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: ath6kl_usb_alloc_urb_from_pipe\n- 参数: [pipe]\n- 调用者: 未显示\n- 被调用者: [spin_lock_irqsave, list_empty, list_first_entry, list_del, spin_unlock_irqrestore]\n\n2. 函数名: spin_lock_irqsave\n- 参数: [&pipe->ar_usb->cs_lock, flags]\n- 调用者: ath6kl_usb_alloc_urb_from_pipe\n- 被调用者: 未显示\n\n3. 函数名: list_empty\n- 参数: [&pipe->urb_list_head]\n- 调用者: ath6kl_usb_alloc_urb_from_pipe\n- 被调用者: 未显示\n\n4. 函数名: list_first_entry\n- 参数: [&pipe->urb_list_head, struct ath6kl_urb_context, link]\n- 调用者: ath6kl_usb_alloc_urb_from_pipe\n- 被调用者: 未显示\n\n5. 函数名: list_del\n- 参数: [&urb_context->link]\n- 调用者: ath6kl_usb_alloc_urb_from_pipe\n- 被调用者: 未显示\n\n6. 函数名: spin_unlock_irqrestore\n- 参数: [&pipe->ar_usb->cs_lock, flags]\n- 调用者: ath6kl_usb_alloc_urb_from_pipe\n- 被调用者: 未显示"
    },
    {
        "id": 1989,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15099",
        "purpose": "Code purpose:\"\"\"从USB管道中分配一个URB上下文结构体，如果管道列表不为空则取出第一个并减少计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对从urb_list_head获取的urb_context进行空指针检查，导致可能发生空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ath10k_usb_alloc_urb_from_pipe\n- 参数: [pipe]\n- 调用者: 未明确显示（通常由USB驱动相关代码调用）\n- 被调用者: [spin_lock_irqsave, list_empty, list_first_entry, list_del, spin_unlock_irqrestore]\n\n2. 函数名: spin_lock_irqsave\n- 参数: [&pipe->ar_usb->cs_lock, flags]\n- 调用者: ath10k_usb_alloc_urb_from_pipe\n- 被调用者: []\n\n3. 函数名: list_empty\n- 参数: [&pipe->urb_list_head]\n- 调用者: ath10k_usb_alloc_urb_from_pipe\n- 被调用者: []\n\n4. 函数名: list_first_entry\n- 参数: [&pipe->urb_list_head, struct ath10k_urb_context, link]\n- 调用者: ath10k_usb_alloc_urb_from_pipe\n- 被调用者: []\n\n5. 函数名: list_del\n- 参数: [&urb_context->link]\n- 调用者: ath10k_usb_alloc_urb_from_pipe\n- 被调用者: []\n\n6. 函数名: spin_unlock_irqrestore\n- 参数: [&pipe->ar_usb->cs_lock, flags]\n- 调用者: ath10k_usb_alloc_urb_from_pipe\n- 被调用者: []"
    },
    {
        "id": 1990,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15099",
        "purpose": "Code purpose:\"\"\"该代码用于将释放的URB（USB请求块）上下文重新添加到USB管道的URB列表中，并更新管道中的URB计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对pipe->ar_usb进行空指针检查，当其为NULL时会导致空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ath10k_usb_free_urb_to_pipe\n- 参数: [struct ath10k_usb_pipe *pipe, struct ath10k_urb_context *urb_context]\n- 调用者: 未明确（需查看完整代码）\n- 被调用者: [spin_lock_irqsave, list_add, spin_unlock_irqrestore]\n\n2. 函数名: spin_lock_irqsave\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: ath10k_usb_free_urb_to_pipe\n- 被调用者: []\n\n3. 函数名: list_add\n- 参数: [struct list_head *new, struct list_head *head]\n- 调用者: ath10k_usb_free_urb_to_pipe\n- 被调用者: []\n\n4. 函数名: spin_unlock_irqrestore\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: ath10k_usb_free_urb_to_pipe\n- 被调用者: []"
    },
    {
        "id": 1998,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15216",
        "purpose": "Code purpose:\"\"\"处理USB YUREX设备断开连接时的资源清理和状态更新\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在yurex_disconnect函数中，当恶意USB设备触发断开连接时，未对dev指针进行空指针检查就直接访问其成员io_mutex，导致NULL指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: yurex_disconnect\n- 参数: [struct usb_interface *interface]\n- 调用者: 未显示（通常由USB子系统调用）\n- 被调用者: [usb_get_intfdata, usb_set_intfdata, usb_deregister_dev, mutex_lock, mutex_unlock, kill_fasync, wake_up_interruptible, kref_put, dev_info]\n\n2. 函数名: usb_get_intfdata\n- 参数: [struct usb_interface *interface]\n- 调用者: yurex_disconnect\n- 被调用者: []\n\n3. 函数名: usb_set_intfdata\n- 参数: [struct usb_interface *interface, NULL]\n- 调用者: yurex_disconnect\n- 被调用者: []\n\n4. 函数名: usb_deregister_dev\n- 参数: [struct usb_interface *interface, &yurex_class]\n- 调用者: yurex_disconnect\n- 被调用者: []\n\n5. 函数名: mutex_lock\n- 参数: [&dev->io_mutex]\n- 调用者: yurex_disconnect\n- 被调用者: []\n\n6. 函数名: mutex_unlock\n- 参数: [&dev->io_mutex]\n- 调用者: yurex_disconnect\n- 被调用者: []\n\n7. 函数名: kill_fasync\n- 参数: [&dev->async_queue, SIGIO, POLL_IN]\n- 调用者: yurex_disconnect\n- 被调用者: []\n\n8. 函数名: wake_up_interruptible\n- 参数: [&dev->waitq]\n- 调用者: yurex_disconnect\n- 被调用者: []\n\n9. 函数名: kref_put\n- 参数: [&dev->kref, yurex_delete]\n- 调用者: yurex_disconnect\n- 被调用者: [yurex_delete]\n\n10. 函数名: dev_info\n- 参数: [&interface->dev, \"USB YUREX #%d now disconnected\\n\", minor]\n- 调用者: yurex_disconnect\n- 被调用者: []\n\n11. 函数名: yurex_delete\n- 参数: [未显示]\n- 调用者: kref_put\n- 被调用者: []"
    },
    {
        "id": 1999,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15217",
        "purpose": "Code purpose:\"\"\"该代码用于查询视频设备的驱动能力信息，包括驱动名称、设备产品名称和总线信息，并设置设备的能力标志位。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当恶意USB设备没有提供product信息时，cam->udev->product为NULL，导致strscpy函数对NULL指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: zr364xx_vidioc_querycap\n- 参数: [struct file *file, void *priv, struct v4l2_capability *cap]\n- 调用者: 未明确显示（通常由V4L2框架调用）\n- 被调用者: [video_drvdata, strscpy, dev_name]\n\n2. 函数名: video_drvdata\n- 参数: [struct file *file]\n- 调用者: zr364xx_vidioc_querycap\n- 被调用者: 未显示\n\n3. 函数名: strscpy\n- 参数: [char *dest, const char *src, size_t count]\n- 调用者: zr364xx_vidioc_querycap\n- 被调用者: 未显示\n\n4. 函数名: dev_name\n- 参数: [const struct device *dev]\n- 调用者: zr364xx_vidioc_querycap\n- 被调用者: 未显示"
    },
    {
        "id": 2000,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15218",
        "purpose": "Code purpose:\"\"\"初始化并注册一个Siano USB设备，包括设置设备参数、分配缓冲区、初始化URB（USB请求块）以及启动设备流传输功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在smsusb_init_device函数中，当处理恶意USB设备时，未正确验证dev->udev->ep_in[1]是否为NULL，导致可能发生空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: smsusb_init_device\n- 参数: [struct usb_interface *intf, int board_id]\n- 调用者: 未显示\n- 被调用者: [kzalloc, memset, usb_set_intfdata, interface_to_usbdev, sms_get_board, pr_err, le16_to_cpu, pr_debug, usb_make_path, siano_media_device_register, smscore_register_device, smsusb_term_device, media_device_unregister, kfree, smscore_set_board_id, usb_init_urb, smsusb_start_streaming, smscore_start_device]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(struct smsusb_device_t), GFP_KERNEL]\n- 调用者: smsusb_init_device\n- 被调用者: 未显示\n\n3. 函数名: memset\n- 参数: [&params, 0, sizeof(params)]\n- 调用者: smsusb_init_device\n- 被调用者: 未显示\n\n4. 函数名: usb_set_intfdata\n- 参数: [intf, dev]\n- 调用者: smsusb_init_device\n- 被调用者: 未显示\n\n5. 函数名: interface_to_usbdev\n- 参数: [intf]\n- 调用者: smsusb_init_device\n- 被调用者: 未显示\n\n6. 函数名: sms_get_board\n- 参数: [board_id]\n- 调用者: smsusb_init_device\n- 被调用者: 未显示\n\n7. 函数名: pr_err\n- 参数: [\"Unspecified sms device type!\"]\n- 调用者: smsusb_init_device\n- 被调用者: 未显示\n\n8. 函数名: le16_to_cpu\n- 参数: [dev->udev->ep_in[1]->desc.wMaxPacketSize]\n- 调用者: smsusb_init_device\n- 被调用者: 未显示\n\n9. 函数名: pr_debug\n- 参数: [\"in_ep = %02x, out_ep = %02x\\n\", dev->in_ep, dev->out_ep]\n- 调用者: smsusb_init_device\n- 被调用者: 未显示\n\n10. 函数名: usb_make_path\n- 参数: [dev->udev, params.devpath, sizeof(params.devpath)]\n- 调用者: smsusb_init_device\n- 被调用者: 未显示\n\n11. 函数名: siano_media_device_register\n- 参数: [dev, board_id]\n- 调用者: smsusb_init_device\n- 被调用者: 未显示\n\n12. 函数名: smscore_register_device\n- 参数: [&params, &dev->coredev, 0, mdev]\n- 调用者: smsusb_init_device\n- 被调用者: 未显示\n\n13. 函数名: smsusb_term_device\n- 参数: [intf]\n- 调用者: smsusb_init_device\n- 被调用者: 未显示\n\n14. 函数名: media_device_unregister\n- 参数: [mdev]\n- 调用者: smsusb_init_device\n- 被调用者: 未显示\n\n15. 函数名: kfree\n- 参数: [mdev]\n- 调用者: smsusb_init_device\n- 被调用者: 未显示\n\n16. 函数名: smscore_set_board_id\n- 参数: [dev->coredev, board_id]\n- 调用者: smsusb_init_device\n- 被调用者: 未显示\n\n17. 函数名: usb_init_urb\n- 参数: [&dev->surbs[i].urb]\n- 调用者: smsusb_init_device\n- 被调用者: 未显示\n\n18. 函数名: smsusb_start_streaming\n- 参数: [dev]\n- 调用者: smsusb_init_device\n- 被调用者: 未显示\n\n19. 函数名: smscore_start_device\n- 参数: [dev->coredev]\n- 调用者: smsusb_init_device\n- 被调用者: 未显示"
    },
    {
        "id": 2001,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15219",
        "purpose": "Code purpose:\"\"\"该代码是Linux内核中sisusbvga驱动的一部分，用于探测并初始化连接到系统的USB转VGA设备，包括内存分配、缓冲区设置、URB分配等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在sisusb_probe函数中，当usb_register_dev失败后跳转到error_1标签时，sisusb->sisusb_dev尚未被初始化就被用于dev_err调用，导致NULL指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: sisusb_probe\n- 参数: [struct usb_interface *intf, const struct usb_device_id *id]\n- 调用者: 内核USB子系统\n- 被调用者: [interface_to_usbdev, kzalloc, kref_init, mutex_init, usb_register_dev, kmalloc, usb_alloc_urb, usb_set_intfdata, usb_get_dev, sisusb_init_gfxdevice, sisusb_free_urbs, sisusb_free_buffers, usb_deregister_dev, kfree]\n\n2. 函数名: interface_to_usbdev\n- 参数: [struct usb_interface *intf]\n- 调用者: sisusb_probe\n- 被调用者: []\n\n3. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: sisusb_probe\n- 被调用者: []\n\n4. 函数名: kref_init\n- 参数: [struct kref *kref]\n- 调用者: sisusb_probe\n- 被调用者: []\n\n5. 函数名: mutex_init\n- 参数: [struct mutex *lock]\n- 调用者: sisusb_probe\n- 被调用者: []\n\n6. 函数名: usb_register_dev\n- 参数: [struct usb_interface *intf, struct usb_class_driver *class_driver]\n- 调用者: sisusb_probe\n- 被调用者: []\n\n7. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: sisusb_probe\n- 被调用者: []\n\n8. 函数名: usb_alloc_urb\n- 参数: [int iso_packets, gfp_t mem_flags]\n- 调用者: sisusb_probe\n- 被调用者: []\n\n9. 函数名: usb_set_intfdata\n- 参数: [struct usb_interface *intf, void *data]\n- 调用者: sisusb_probe\n- 被调用者: []\n\n10. 函数名: usb_get_dev\n- 参数: [struct usb_device *dev]\n- 调用者: sisusb_probe\n- 被调用者: []\n\n11. 函数名: sisusb_init_gfxdevice\n- 参数: [struct sisusb_usb_data *sisusb, int initscreen]\n- 调用者: sisusb_probe\n- 被调用者: []\n\n12. 函数名: sisusb_free_urbs\n- 参数: [struct sisusb_usb_data *sisusb]\n- 调用者: sisusb_probe\n- 被调用者: []\n\n13. 函数名: sisusb_free_buffers\n- 参数: [struct sisusb_usb_data *sisusb]\n- 调用者: sisusb_probe\n- 被调用者: []\n\n14. 函数名: usb_deregister_dev\n- 参数: [struct usb_interface *intf, struct usb_class_driver *class_driver]\n- 调用者: sisusb_probe\n- 被调用者: []\n\n15. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: sisusb_probe\n- 被调用者: []"
    },
    {
        "id": 2006,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15221",
        "purpose": "Code purpose:\"\"\"初始化Line6 USB音频设备的PCM(脉冲编码调制)功能，包括分配资源、设置参数和创建音频数据缓冲区\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当恶意USB设备提供无效的端点描述符时，代码未进行空指针检查就直接访问，导致空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: line6_init_pcm\n- 参数: [struct usb_line6 *line6, struct line6_pcm_properties *properties]\n- 调用者: N/A\n- 被调用者: [snd_line6_new_pcm, kzalloc, mutex_init, usb_maxpacket, usb_rcvisocpipe, usb_sndisocpipe, spin_lock_init, line6_create_audio_out_urbs, line6_create_audio_in_urbs, snd_ctl_add, snd_ctl_new1]\n\n2. 函数名: snd_line6_new_pcm\n- 参数: [struct usb_line6 *line6, struct snd_pcm **pcm]\n- 调用者: line6_init_pcm\n- 被调用者: N/A\n\n3. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: line6_init_pcm\n- 被调用者: N/A\n\n4. 函数名: mutex_init\n- 参数: [struct mutex *lock]\n- 调用者: line6_init_pcm\n- 被调用者: N/A\n\n5. 函数名: usb_maxpacket\n- 参数: [struct usb_device *udev, int pipe, int is_out]\n- 调用者: line6_init_pcm\n- 被调用者: N/A\n\n6. 函数名: usb_rcvisocpipe\n- 参数: [struct usb_device *dev, unsigned int endpoint]\n- 调用者: line6_init_pcm\n- 被调用者: N/A\n\n7. 函数名: usb_sndisocpipe\n- 参数: [struct usb_device *dev, unsigned int endpoint]\n- 调用者: line6_init_pcm\n- 被调用者: N/A\n\n8. 函数名: spin_lock_init\n- 参数: [spinlock_t *lock]\n- 调用者: line6_init_pcm\n- 被调用者: N/A\n\n9. 函数名: line6_create_audio_out_urbs\n- 参数: [struct snd_line6_pcm *line6pcm]\n- 调用者: line6_init_pcm\n- 被调用者: N/A\n\n10. 函数名: line6_create_audio_in_urbs\n- 参数: [struct snd_line6_pcm *line6pcm]\n- 调用者: line6_init_pcm\n- 被调用者: N/A\n\n11. 函数名: snd_ctl_add\n- 参数: [struct snd_card *card, struct snd_kcontrol *kcontrol]\n- 调用者: line6_init_pcm\n- 被调用者: N/A\n\n12. 函数名: snd_ctl_new1\n- 参数: [const struct snd_kcontrol_new *ncontrol, void *private_data]\n- 调用者: line6_init_pcm\n- 被调用者: N/A"
    },
    {
        "id": 2007,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15222",
        "purpose": "Code purpose:\"\"\"该代码用于检查USB音频设备管道的有效性，确保管道类型与端点描述符类型匹配\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对usb_pipe_endpoint()返回的ep指针进行NULL检查，当恶意USB设备触发时可能导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: snd_usb_pipe_sanity_check\n- 参数: [struct usb_device *dev, unsigned int pipe]\n- 调用者: 未提供（上下文缺失）\n- 被调用者: [usb_pipe_endpoint, usb_pipetype, usb_endpoint_type]\n\n2. 函数名: usb_pipe_endpoint\n- 参数: [struct usb_device *dev, unsigned int pipe]\n- 调用者: snd_usb_pipe_sanity_check\n- 被调用者: 未提供（假设为内核API）\n\n3. 函数名: usb_pipetype\n- 参数: [unsigned int pipe]\n- 调用者: snd_usb_pipe_sanity_check\n- 被调用者: 未提供（假设为内核API）\n\n4. 函数名: usb_endpoint_type\n- 参数: [struct usb_endpoint_descriptor *desc]\n- 调用者: snd_usb_pipe_sanity_check\n- 被调用者: 未提供（假设为内核API）"
    },
    {
        "id": 2008,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15223",
        "purpose": "Code purpose:\"\"\"处理Line6 USB音频设备的断开连接操作，包括停止监听、断开PCM连接、释放资源等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当恶意USB设备导致line6->properties为NULL时，访问line6->properties->name会引发空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: line6_disconnect\n- 参数: [struct usb_interface *interface]\n- 调用者: 未显示（由USB子系统调用）\n- 被调用者: [usb_get_intfdata, interface_to_usbdev, WARN_ON, line6_stop_listen, snd_card_disconnect, line6_pcm_disconnect, dev_info, usb_set_intfdata, snd_card_free_when_closed]\n\n2. 函数名: usb_get_intfdata\n- 参数: [struct usb_interface *interface]\n- 调用者: line6_disconnect\n- 被调用者: []\n\n3. 函数名: interface_to_usbdev\n- 参数: [struct usb_interface *interface]\n- 调用者: line6_disconnect\n- 被调用者: []\n\n4. 函数名: WARN_ON\n- 参数: [condition]\n- 调用者: line6_disconnect\n- 被调用者: []\n\n5. 函数名: line6_stop_listen\n- 参数: [struct usb_line6 *line6]\n- 调用者: line6_disconnect\n- 被调用者: []\n\n6. 函数名: snd_card_disconnect\n- 参数: [struct snd_card *card]\n- 调用者: line6_disconnect\n- 被调用者: []\n\n7. 函数名: line6_pcm_disconnect\n- 参数: [struct snd_line6_pcm *line6pcm]\n- 调用者: line6_disconnect\n- 被调用者: []\n\n8. 函数名: dev_info\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: line6_disconnect\n- 被调用者: []\n\n9. 函数名: usb_set_intfdata\n- 参数: [struct usb_interface *interface, void *data]\n- 调用者: line6_disconnect\n- 被调用者: []\n\n10. 函数名: snd_card_free_when_closed\n- 参数: [struct snd_card *card]\n- 调用者: line6_disconnect\n- 被调用者: []"
    },
    {
        "id": 2009,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15223",
        "purpose": "Code purpose:\"\"\"该代码用于探测和初始化Line6 USB音频设备，包括创建声卡设备、设置USB接口参数以及初始化设备特定数据。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"恶意USB设备导致line6_probe函数中对空指针进行解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: line6_probe\n- 参数: [struct usb_interface *interface, const struct usb_device_id *id, const char *driver_name, const struct line6_properties *properties, int (*private_init)(struct usb_line6 *, const struct usb_device_id *id), size_t data_size]\n- 调用者: 外部USB驱动框架\n- 被调用者: [interface_to_usbdev, snd_card_new, strcpy, sprintf, usb_set_intfdata, usb_get_dev, dev_info, usb_set_interface, line6_get_usb_properties, line6_init_cap_control, line6_disconnect, dev_err]\n\n2. 函数名: interface_to_usbdev\n- 参数: [struct usb_interface *interface]\n- 调用者: line6_probe\n- 被调用者: []\n\n3. 函数名: snd_card_new\n- 参数: [struct device *dev, int idx, const char *xid, struct module *module, size_t extra_size, struct snd_card **card_ret]\n- 调用者: line6_probe\n- 被调用者: []\n\n4. 函数名: strcpy\n- 参数: [char *dest, const char *src]\n- 调用者: line6_probe\n- 被调用者: []\n\n5. 函数名: sprintf\n- 参数: [char *str, const char *format, ...]\n- 调用者: line6_probe\n- 被调用者: []\n\n6. 函数名: usb_set_intfdata\n- 参数: [struct usb_interface *intf, void *data]\n- 调用者: line6_probe\n- 被调用者: []\n\n7. 函数名: usb_get_dev\n- 参数: [struct usb_device *dev]\n- 调用者: line6_probe\n- 被调用者: []\n\n8. 函数名: dev_info\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: line6_probe\n- 被调用者: []\n\n9. 函数名: usb_set_interface\n- 参数: [struct usb_device *dev, int interface, int alternate]\n- 调用者: line6_probe\n- 被调用者: []\n\n10. 函数名: line6_get_usb_properties\n- 参数: [struct usb_line6 *line6]\n- 调用者: line6_probe\n- 被调用者: []\n\n11. 函数名: line6_init_cap_control\n- 参数: [struct usb_line6 *line6]\n- 调用者: line6_probe\n- 被调用者: []\n\n12. 函数名: line6_disconnect\n- 参数: [struct usb_interface *interface]\n- 调用者: line6_probe\n- 被调用者: []\n\n13. 函数名: dev_err\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: line6_probe\n- 被调用者: []"
    },
    {
        "id": 2010,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15223",
        "purpose": "Code purpose:\"\"\"处理TonePort USB音频设备的断开连接操作，包括取消延迟工作和移除LED设备\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当恶意USB设备连接时，toneport指针可能为NULL，导致在取消延迟工作队列时发生空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: line6_toneport_disconnect\n- 参数: [struct usb_line6 *line6]\n- 调用者: 未明确（可能是USB设备断开时的回调函数）\n- 被调用者: [cancel_delayed_work_sync, toneport_has_led, toneport_remove_leds]\n\n2. 函数名: cancel_delayed_work_sync\n- 参数: [&toneport->pcm_work]\n- 调用者: line6_toneport_disconnect\n- 被调用者: []\n\n3. 函数名: toneport_has_led\n- 参数: [toneport]\n- 调用者: line6_toneport_disconnect\n- 被调用者: []\n\n4. 函数名: toneport_remove_leds\n- 参数: [toneport]\n- 调用者: line6_toneport_disconnect\n- 被调用者: []"
    },
    {
        "id": 2011,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15223",
        "purpose": "Code purpose:\"\"\"初始化Line6 Toneport USB音频设备的各个功能组件，包括PCM子系统、监控控制、源选择控制、LED设置等，并注册音频系统。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于恶意USB设备导致line6驱动中的指针未被正确初始化，从而引发NULL指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: toneport_init\n- 参数: [struct usb_line6 *line6, const struct usb_device_id *id]\n- 调用者: 未显示（应为外部USB驱动框架）\n- 被调用者: [INIT_DELAYED_WORK, line6_init_pcm, snd_ctl_add, snd_ctl_new1, toneport_has_source_select, line6_read_serial_number, line6_read_data, toneport_has_led, toneport_init_leds, toneport_setup, snd_card_register]\n\n2. 函数名: toneport_start_pcm\n- 参数: 未显示（通过INIT_DELAYED_WORK传递）\n- 调用者: INIT_DELAYED_WORK\n- 被调用者: 未显示\n\n3. 函数名: line6_toneport_disconnect\n- 参数: 未显示（通过line6->disconnect传递）\n- 调用者: 未显示（应为USB断开时调用）\n- 被调用者: 未显示\n\n4. 函数名: line6_init_pcm\n- 参数: [struct usb_line6 *line6, &toneport_pcm_properties]\n- 调用者: toneport_init\n- 被调用者: 未显示\n\n5. 函数名: snd_ctl_add\n- 参数: [line6->card, snd_ctl_new1(...)]\n- 调用者: toneport_init\n- 被调用者: 未显示\n\n6. 函数名: snd_ctl_new1\n- 参数: [&toneport_control_monitor, line6->line6pcm] 和 [&toneport_control_source, line6->line6pcm]\n- 调用者: toneport_init\n- 被调用者: 未显示\n\n7. 函数名: toneport_has_source_select\n- 参数: [struct usb_line6_toneport *toneport]\n- 调用者: toneport_init\n- 被调用者: 未显示\n\n8. 函数名: line6_read_serial_number\n- 参数: [struct usb_line6 *line6, &toneport->serial_number]\n- 调用者: toneport_init\n- 被调用者: 未显示\n\n9. 函数名: line6_read_data\n- 参数: [struct usb_line6 *line6, 0x80c2, &toneport->firmware_version, 1]\n- 调用者: toneport_init\n- 被调用者: 未显示\n\n10. 函数名: toneport_has_led\n- 参数: [struct usb_line6_toneport *toneport]\n- 调用者: toneport_init\n- 被调用者: 未显示\n\n11. 函数名: toneport_init_leds\n- 参数: [struct usb_line6_toneport *toneport]\n- 调用者: toneport_init\n- 被调用者: 未显示\n\n12. 函数名: toneport_setup\n- 参数: [struct usb_line6_toneport *toneport]\n- 调用者: toneport_init\n- 被调用者: 未显示\n\n13. 函数名: snd_card_register\n- 参数: [line6->card]\n- 调用者: toneport_init\n- 被调用者: 未显示"
    },
    {
        "id": 2012,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15223",
        "purpose": "Code purpose:\"\"\"该代码用于初始化TonePort USB音频设备，包括同步设备与主机时间、启用设备、初始化源选择以及更新LED状态等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"恶意USB设备导致line6_write_data函数中的ticks指针被解引用时可能为NULL，造成空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: toneport_setup\n- 参数: [struct usb_line6_toneport *toneport]\n- 调用者: 未显示\n- 被调用者: [kmalloc, ktime_get_real_seconds, line6_write_data, kfree, toneport_send_cmd, toneport_has_source_select, toneport_update_led, schedule_delayed_work, msecs_to_jiffies]\n\n2. 函数名: kmalloc\n- 参数: [sizeof(*ticks), GFP_KERNEL]\n- 调用者: toneport_setup\n- 被调用者: 未显示\n\n3. 函数名: ktime_get_real_seconds\n- 参数: []\n- 调用者: toneport_setup\n- 被调用者: 未显示\n\n4. 函数名: line6_write_data\n- 参数: [line6, 0x80c6, ticks, 4]\n- 调用者: toneport_setup\n- 被调用者: 未显示\n\n5. 函数名: kfree\n- 参数: [ticks]\n- 调用者: toneport_setup\n- 被调用者: 未显示\n\n6. 函数名: toneport_send_cmd\n- 参数: [usbdev, 0x0301, 0x0000] 和 [usbdev, toneport_source_info[toneport->source].code, 0x0000]\n- 调用者: toneport_setup\n- 被调用者: 未显示\n\n7. 函数名: toneport_has_source_select\n- 参数: [toneport]\n- 调用者: toneport_setup\n- 被调用者: 未显示\n\n8. 函数名: toneport_update_led\n- 参数: [toneport]\n- 调用者: toneport_setup\n- 被调用者: 未显示\n\n9. 函数名: schedule_delayed_work\n- 参数: [&toneport->pcm_work, msecs_to_jiffies(TONEPORT_PCM_DELAY * 1000)]\n- 调用者: toneport_setup\n- 被调用者: 未显示\n\n10. 函数名: msecs_to_jiffies\n- 参数: [TONEPORT_PCM_DELAY * 1000]\n- 调用者: toneport_setup\n- 被调用者: 未显示"
    },
    {
        "id": 2014,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15291",
        "purpose": "Code purpose:\"\"\"该代码用于初始化并连接USB接口的flexcop设备，包括内存分配、设备初始化和数据传输设置等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在flexcop_usb_probe函数中，当flexcop_device_kmalloc分配内存失败返回NULL时，后续直接访问fc->bus_specific导致空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: flexcop_usb_probe\n- 参数: [struct usb_interface *intf, const struct usb_device_id *id]\n- 调用者: 内核USB子系统\n- 被调用者: [interface_to_usbdev, flexcop_device_kmalloc, mutex_init, flexcop_usb_init, flexcop_device_initialize, flexcop_usb_transfer_init, flexcop_device_exit, flexcop_usb_exit, flexcop_device_kfree]\n\n2. 函数名: interface_to_usbdev\n- 参数: [struct usb_interface *intf]\n- 调用者: flexcop_usb_probe\n- 被调用者: []\n\n3. 函数名: flexcop_device_kmalloc\n- 参数: [sizeof(struct flexcop_usb)]\n- 调用者: flexcop_usb_probe\n- 被调用者: []\n\n4. 函数名: mutex_init\n- 参数: [&fc_usb->data_mutex]\n- 调用者: flexcop_usb_probe\n- 被调用者: []\n\n5. 函数名: flexcop_usb_init\n- 参数: [fc_usb]\n- 调用者: flexcop_usb_probe\n- 被调用者: []\n\n6. 函数名: flexcop_device_initialize\n- 参数: [fc]\n- 调用者: flexcop_usb_probe\n- 被调用者: []\n\n7. 函数名: flexcop_usb_transfer_init\n- 参数: [fc_usb]\n- 调用者: flexcop_usb_probe\n- 被调用者: []\n\n8. 函数名: flexcop_device_exit\n- 参数: [fc]\n- 调用者: flexcop_usb_probe\n- 被调用者: []\n\n9. 函数名: flexcop_usb_exit\n- 参数: [fc_usb]\n- 调用者: flexcop_usb_probe\n- 被调用者: []\n\n10. 函数名: flexcop_device_kfree\n- 参数: [fc]\n- 调用者: flexcop_usb_probe\n- 被调用者: []"
    },
    {
        "id": 2029,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15922",
        "purpose": "Code purpose:\"\"\"检测并初始化ATAPI磁盘驱动器，处理驱动注册和磁盘探测失败的情况\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当alloc_disk分配失败时，代码未检查pf->disk是否为NULL就直接访问其成员queue，导致空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: pf_detect\n- 参数: []\n- 调用者: N/A (顶层函数)\n- 被调用者: [printk, pi_register_driver, pr_err, pi_init, pf_probe, pi_release, blk_cleanup_queue, blk_mq_free_tag_set, put_disk, pi_unregister_driver]\n\n2. 函数名: printk\n- 参数: [format string, name, name, PF_VERSION, major, cluster, nice]\n- 调用者: pf_detect\n- 被调用者: []\n\n3. 函数名: pi_register_driver\n- 参数: [name]\n- 调用者: pf_detect\n- 被调用者: []\n\n4. 函数名: pr_err\n- 参数: [format string, name]\n- 调用者: pf_detect\n- 被调用者: []\n\n5. 函数名: pi_init\n- 参数: [pf->pi, 1, -1, -1, -1, -1, -1, pf_scratch, PI_PF, verbose, pf->name] 或 [pf->pi, 0, conf[D_PRT], conf[D_MOD], conf[D_UNI], conf[D_PRO], conf[D_DLY], pf_scratch, PI_PF, verbose, pf->name]\n- 调用者: pf_detect\n- 被调用者: []\n\n6. 函数名: pf_probe\n- 参数: [pf]\n- 调用者: pf_detect\n- 被调用者: []\n\n7. 函数名: pi_release\n- 参数: [pf->pi]\n- 调用者: pf_detect\n- 被调用者: []\n\n8. 函数名: blk_cleanup_queue\n- 参数: [pf->disk->queue]\n- 调用者: pf_detect\n- 被调用者: []\n\n9. 函数名: blk_mq_free_tag_set\n- 参数: [&pf->tag_set]\n- 调用者: pf_detect\n- 被调用者: []\n\n10. 函数名: put_disk\n- 参数: [pf->disk]\n- 调用者: pf_detect\n- 被调用者: []\n\n11. 函数名: pi_unregister_driver\n- 参数: [par_drv]\n- 调用者: pf_detect\n- 被调用者: []"
    },
    {
        "id": 2030,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15922",
        "purpose": "Code purpose:\"\"\"在Linux内核模块卸载时，清理并释放与并行接口磁盘驱动器相关的资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在pf_exit函数中未检查pf->disk是否为NULL就直接访问其成员queue，当alloc_disk分配失败时会导致NULL指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: pf_exit\n- 参数: [void]\n- 调用者: __exit\n- 被调用者: [unregister_blkdev, del_gendisk, blk_cleanup_queue, blk_mq_free_tag_set, put_disk, pi_release]\n\n2. 函数名: unregister_blkdev\n- 参数: [major, name]\n- 调用者: pf_exit\n- 被调用者: []\n\n3. 函数名: del_gendisk\n- 参数: [pf->disk]\n- 调用者: pf_exit\n- 被调用者: []\n\n4. 函数名: blk_cleanup_queue\n- 参数: [pf->disk->queue]\n- 调用者: pf_exit\n- 被调用者: []\n\n5. 函数名: blk_mq_free_tag_set\n- 参数: [&pf->tag_set]\n- 调用者: pf_exit\n- 被调用者: []\n\n6. 函数名: put_disk\n- 参数: [pf->disk]\n- 调用者: pf_exit\n- 被调用者: []\n\n7. 函数名: pi_release\n- 参数: [pf->pi]\n- 调用者: pf_exit\n- 被调用者: []"
    },
    {
        "id": 2031,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15922",
        "purpose": "Code purpose:\"\"\"初始化并注册并行端口IDE磁盘驱动器(pf)设备，包括检测设备、分配资源、注册块设备等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当alloc_disk分配失败时，pf->disk为NULL，后续操作未检查该指针就直接解引用，导致NULL指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: pf_init\n- 参数: [void]\n- 调用者: 模块初始化调用\n- 被调用者: [pf_init_units, pf_detect, register_blkdev, put_disk, add_disk]\n\n2. 函数名: pf_init_units\n- 参数: [void]\n- 调用者: pf_init\n- 被调用者: []\n\n3. 函数名: pf_detect\n- 参数: [void]\n- 调用者: pf_init\n- 被调用者: []\n\n4. 函数名: register_blkdev\n- 参数: [major, name]\n- 调用者: pf_init\n- 被调用者: []\n\n5. 函数名: put_disk\n- 参数: [pf->disk]\n- 调用者: pf_init\n- 被调用者: []\n\n6. 函数名: add_disk\n- 参数: [disk]\n- 调用者: pf_init\n- 被调用者: []"
    },
    {
        "id": 2032,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15923",
        "purpose": "Code purpose:\"\"\"在模块退出时清理和释放与并行端口CD-ROM设备相关的资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在pf.c驱动程序中，当alloc_disk分配失败时未对cd->disk进行NULL检查，导致后续操作中出现空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: pcd_exit\n- 参数: [void]\n- 调用者: __exit宏\n- 被调用者: [del_gendisk, pi_release, unregister_cdrom, blk_cleanup_queue, blk_mq_free_tag_set, put_disk, unregister_blkdev, pi_unregister_driver]\n\n2. 函数名: del_gendisk\n- 参数: [cd->disk]\n- 调用者: pcd_exit\n- 被调用者: []\n\n3. 函数名: pi_release\n- 参数: [cd->pi]\n- 调用者: pcd_exit\n- 被调用者: []\n\n4. 函数名: unregister_cdrom\n- 参数: [&cd->info]\n- 调用者: pcd_exit\n- 被调用者: []\n\n5. 函数名: blk_cleanup_queue\n- 参数: [cd->disk->queue]\n- 调用者: pcd_exit\n- 被调用者: []\n\n6. 函数名: blk_mq_free_tag_set\n- 参数: [&cd->tag_set]\n- 调用者: pcd_exit\n- 被调用者: []\n\n7. 函数名: put_disk\n- 参数: [cd->disk]\n- 调用者: pcd_exit\n- 被调用者: []\n\n8. 函数名: unregister_blkdev\n- 参数: [major, name]\n- 调用者: pcd_exit\n- 被调用者: []\n\n9. 函数名: pi_unregister_driver\n- 参数: [par_drv]\n- 调用者: pcd_exit\n- 被调用者: []"
    },
    {
        "id": 2033,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15923",
        "purpose": "Code purpose:\"\"\"初始化并行端口IDE磁盘驱动器单元，包括分配磁盘结构、设置队列和初始化相关参数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当alloc_disk分配失败时，代码继续使用未初始化的cd指针，导致NULL指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: pcd_init_units\n- 参数: []\n- 调用者: N/A\n- 被调用者: [alloc_disk, blk_mq_init_sq_queue, IS_ERR, INIT_LIST_HEAD, blk_queue_bounce_limit, snprintf, strcpy]\n\n2. 函数名: alloc_disk\n- 参数: [1]\n- 调用者: pcd_init_units\n- 被调用者: []\n\n3. 函数名: blk_mq_init_sq_queue\n- 参数: [&cd->tag_set, &pcd_mq_ops, 1, BLK_MQ_F_SHOULD_MERGE]\n- 调用者: pcd_init_units\n- 被调用者: []\n\n4. 函数名: IS_ERR\n- 参数: [disk->queue]\n- 调用者: pcd_init_units\n- 被调用者: []\n\n5. 函数名: INIT_LIST_HEAD\n- 参数: [&cd->rq_list]\n- 调用者: pcd_init_units\n- 被调用者: []\n\n6. 函数名: blk_queue_bounce_limit\n- 参数: [disk->queue, BLK_BOUNCE_HIGH]\n- 调用者: pcd_init_units\n- 被调用者: []\n\n7. 函数名: snprintf\n- 参数: [cd->name, sizeof(cd->info.name), \"%s%d\", name, unit]\n- 调用者: pcd_init_units\n- 被调用者: []\n\n8. 函数名: strcpy\n- 参数: [disk->disk_name, cd->name]\n- 调用者: pcd_init_units\n- 被调用者: []"
    },
    {
        "id": 2034,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15923",
        "purpose": "Code purpose:\"\"\"初始化并行接口的CD-ROM设备驱动，包括检测设备、注册块设备和光盘设备\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当alloc_disk分配失败时，代码未检查返回的NULL指针就直接访问cd->disk，导致空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: pcd_init\n- 参数: [void]\n- 调用者: 模块初始化调用\n- 被调用者: [pcd_init_units, pcd_detect, pcd_probe_capabilities, register_blkdev, put_disk, register_cdrom, add_disk]\n\n2. 函数名: pcd_init_units\n- 参数: []\n- 调用者: pcd_init\n- 被调用者: []\n\n3. 函数名: pcd_detect\n- 参数: []\n- 调用者: pcd_init\n- 被调用者: []\n\n4. 函数名: pcd_probe_capabilities\n- 参数: []\n- 调用者: pcd_init\n- 被调用者: []\n\n5. 函数名: register_blkdev\n- 参数: [major, name]\n- 调用者: pcd_init\n- 被调用者: []\n\n6. 函数名: put_disk\n- 参数: [cd->disk]\n- 调用者: pcd_init\n- 被调用者: []\n\n7. 函数名: register_cdrom\n- 参数: [&cd->info]\n- 调用者: pcd_init\n- 被调用者: []\n\n8. 函数名: add_disk\n- 参数: [cd->disk]\n- 调用者: pcd_init\n- 被调用者: []"
    },
    {
        "id": 2035,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15923",
        "purpose": "Code purpose:\"\"\"检测并初始化CD-ROM驱动器，处理驱动注册和资源分配，在失败时进行清理操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当alloc_disk分配失败时，代码未检查cd->disk是否为NULL就直接访问其成员queue，导致空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: pcd_detect\n- 参数: []\n- 调用者: N/A\n- 被调用者: [printk, pi_register_driver, pr_err, pi_init, pcd_probe, pi_release, blk_cleanup_queue, blk_mq_free_tag_set, put_disk, pi_unregister_driver]\n\n2. 函数名: printk\n- 参数: [format string, name, name, PCD_VERSION, major, nice]\n- 调用者: pcd_detect\n- 被调用者: []\n\n3. 函数名: pi_register_driver\n- 参数: [name]\n- 调用者: pcd_detect\n- 被调用者: []\n\n4. 函数名: pr_err\n- 参数: [format string, name]\n- 调用者: pcd_detect\n- 被调用者: []\n\n5. 函数名: pi_init\n- 参数: [cd->pi, 1, -1, -1, -1, -1, -1, pcd_buffer, PI_PCD, verbose, cd->name] or [cd->pi, 0, conf[D_PRT], conf[D_MOD], conf[D_UNI], conf[D_PRO], conf[D_DLY], pcd_buffer, PI_PCD, verbose, cd->name]\n- 调用者: pcd_detect\n- 被调用者: []\n\n6. 函数名: pcd_probe\n- 参数: [cd, -1, id] or [cd, conf[D_SLV], id]\n- 调用者: pcd_detect\n- 被调用者: []\n\n7. 函数名: pi_release\n- 参数: [cd->pi]\n- 调用者: pcd_detect\n- 被调用者: []\n\n8. 函数名: blk_cleanup_queue\n- 参数: [cd->disk->queue]\n- 调用者: pcd_detect\n- 被调用者: []\n\n9. 函数名: blk_mq_free_tag_set\n- 参数: [&cd->tag_set]\n- 调用者: pcd_detect\n- 被调用者: []\n\n10. 函数名: put_disk\n- 参数: [cd->disk]\n- 调用者: pcd_detect\n- 被调用者: []\n\n11. 函数名: pi_unregister_driver\n- 参数: [par_drv]\n- 调用者: pcd_detect\n- 被调用者: []"
    },
    {
        "id": 2036,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15924",
        "purpose": "Code purpose:\"\"\"初始化fm10k网络驱动模块，包括创建工作队列、调试初始化和注册PCI驱动\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在fm10k_init_module函数中，当alloc_workqueue分配失败时未检查返回NULL指针的情况，导致后续可能发生空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: __init fm10k_init_module\n- 参数: [void]\n- 调用者: 内核模块初始化调用\n- 被调用者: [pr_info, alloc_workqueue, fm10k_dbg_init, fm10k_register_pci_driver]\n\n2. 函数名: pr_info\n- 参数: [format_string, fm10k_driver_string, fm10k_driver_version], [format_string, fm10k_copyright]\n- 调用者: fm10k_init_module\n- 被调用者: []\n\n3. 函数名: alloc_workqueue\n- 参数: [\"%s\", WQ_MEM_RECLAIM, 0, fm10k_driver_name]\n- 调用者: fm10k_init_module\n- 被调用者: []\n\n4. 函数名: fm10k_dbg_init\n- 参数: []\n- 调用者: fm10k_init_module\n- 被调用者: []\n\n5. 函数名: fm10k_register_pci_driver\n- 参数: []\n- 调用者: fm10k_init_module\n- 被调用者: []"
    },
    {
        "id": 2043,
        "cwe": "CWE-476",
        "cve": "CVE-2019-16229",
        "purpose": "Code purpose:\"\"\"初始化AMD GPU内核模式设置(KFD)设备的中断处理机制，包括分配中断处理FIFO、创建工作队列和初始化中断锁等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未检查alloc_workqueue()函数的返回值，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: kfd_interrupt_init\n- 参数: [struct kfd_dev *kfd]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [kfifo_alloc, dev_err, alloc_workqueue, spin_lock_init, INIT_WORK, smp_wmb]\n\n2. 函数名: kfifo_alloc\n- 参数: [&kfd->ih_fifo, KFD_IH_NUM_ENTRIES * kfd->device_info->ih_ring_entry_size, GFP_KERNEL]\n- 调用者: kfd_interrupt_init\n- 被调用者: 未明确（内核函数）\n\n3. 函数名: dev_err\n- 参数: [kfd_chardev(), \"Failed to allocate IH fifo\\n\"]\n- 调用者: kfd_interrupt_init\n- 被调用者: 未明确（内核日志函数）\n\n4. 函数名: alloc_workqueue\n- 参数: [\"KFD IH\", WQ_HIGHPRI, 1]\n- 调用者: kfd_interrupt_init\n- 被调用者: 未明确（内核函数）\n\n5. 函数名: spin_lock_init\n- 参数: [&kfd->interrupt_lock]\n- 调用者: kfd_interrupt_init\n- 被调用者: 未明确（内核同步原语函数）\n\n6. 函数名: INIT_WORK\n- 参数: [&kfd->interrupt_work, interrupt_wq]\n- 调用者: kfd_interrupt_init\n- 被调用者: 未明确（内核工作队列函数）\n\n7. 函数名: smp_wmb\n- 参数: []\n- 调用者: kfd_interrupt_init\n- 被调用者: 未明确（内存屏障函数）"
    },
    {
        "id": 2044,
        "cwe": "CWE-476",
        "cve": "CVE-2019-16231",
        "purpose": "Code purpose:\"\"\"该代码实现了FJES网络设备的探测和初始化功能，包括分配网络设备、设置私有数据结构、创建工作队列以及注册网络设备等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未检查alloc_workqueue函数返回值是否为NULL，导致后续可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: fjes_probe\n- 参数: [struct platform_device *plat_dev]\n- 调用者: 平台驱动子系统\n- 被调用者: [alloc_netdev_mq, SET_NETDEV_DEV, dev_set_drvdata, netdev_priv, fjes_sw_init, alloc_workqueue, INIT_WORK, INIT_DELAYED_WORK, platform_get_resource, resource_size, platform_get_irq, fjes_hw_init, register_netdev, netif_carrier_off, fjes_dbg_adapter_init, fjes_hw_exit, free_netdev]\n\n2. 函数名: alloc_netdev_mq\n- 参数: [sizeof(struct fjes_adapter), \"es%d\", NET_NAME_UNKNOWN, fjes_netdev_setup, FJES_MAX_QUEUES]\n- 调用者: fjes_probe\n- 被调用者: []\n\n3. 函数名: fjes_sw_init\n- 参数: [struct fjes_adapter *adapter]\n- 调用者: fjes_probe\n- 被调用者: []\n\n4. 函数名: alloc_workqueue\n- 参数: [DRV_NAME \"/txrx\", WQ_MEM_RECLAIM, 0] 和 [DRV_NAME \"/control\", WQ_MEM_RECLAIM, 0]\n- 调用者: fjes_probe\n- 被调用者: []\n\n5. 函数名: fjes_hw_init\n- 参数: [struct fjes_hw *hw]\n- 调用者: fjes_probe\n- 被调用者: []\n\n6. 函数名: register_netdev\n- 参数: [struct net_device *netdev]\n- 调用者: fjes_probe\n- 被调用者: []\n\n7. 函数名: fjes_hw_exit\n- 参数: [struct fjes_hw *hw]\n- 调用者: fjes_probe\n- 被调用者: []\n\n8. 函数名: free_netdev\n- 参数: [struct net_device *netdev]\n- 调用者: fjes_probe\n- 被调用者: []\n\n9. 函数名: fjes_force_close_task\n- 参数: [struct work_struct *work]\n- 调用者: INIT_WORK宏\n- 被调用者: []\n\n10. 函数名: fjes_tx_stall_task\n- 参数: [struct work_struct *work]\n- 调用者: INIT_WORK宏\n- 被调用者: []\n\n11. 函数名: fjes_raise_intr_rxdata_task\n- 参数: [struct work_struct *work]\n- 调用者: INIT_WORK宏\n- 被调用者: []\n\n12. 函数名: fjes_watch_unshare_task\n- 参数: [struct work_struct *work]\n- 调用者: INIT_WORK宏\n- 被调用者: []\n\n13. 函数名: fjes_irq_watch_task\n- 参数: [struct delayed_work *work]\n- 调用者: INIT_DELAYED_WORK宏\n- 被调用者: []\n\n14. 函数名: fjes_dbg_adapter_init\n- 参数: [struct fjes_adapter *adapter]\n- 调用者: fjes_probe\n- 被调用者: []\n\n15. 函数名: fjes_netdev_setup\n- 参数: [struct net_device *netdev]\n- 调用者: alloc_netdev_mq\n- 被调用者: []"
    },
    {
        "id": 2045,
        "cwe": "CWE-476",
        "cve": "CVE-2019-16232",
        "purpose": "Code purpose:\"\"\"该代码实现了SDIO无线网卡的探测和初始化功能，包括识别卡模型、分配资源、设置工作队列以及与Libertas驱动交互等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未检查alloc_workqueue函数返回值是否为NULL，导致后续可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: if_sdio_probe\n- 参数: [struct sdio_func *func, const struct sdio_device_id *id]\n- 调用者: 无（驱动探测函数，由内核调用）\n- 被调用者: [sscanf, strcmp, kzalloc, spin_lock_init, alloc_workqueue, INIT_WORK, init_waitqueue_head, sdio_set_drvdata, lbs_add_card, lbs_deb_sdio, if_sdio_power_on, flush_workqueue, lbs_remove_card, destroy_workqueue, kfree]\n\n2. 函数名: if_sdio_host_to_card_worker\n- 参数: 无（通过INIT_WORK初始化）\n- 调用者: if_sdio_probe\n- 被调用者: 无（未在代码中显示具体实现）\n\n3. 函数名: lbs_add_card\n- 参数: [struct if_sdio_card *card, struct device *dev]\n- 调用者: if_sdio_probe\n- 被调用者: 无（未在代码中显示具体实现）\n\n4. 函数名: if_sdio_power_on\n- 参数: [struct if_sdio_card *card]\n- 调用者: if_sdio_probe\n- 被调用者: 无（未在代码中显示具体实现）\n\n5. 函数名: lbs_remove_card\n- 参数: [struct lbs_private *priv]\n- 调用者: if_sdio_probe\n- 被调用者: 无（未在代码中显示具体实现）\n\n6. 函数名: lbs_deb_sdio\n- 参数: [const char *fmt, ...]\n- 调用者: if_sdio_probe\n- 被调用者: 无（未在代码中显示具体实现）"
    },
    {
        "id": 2046,
        "cwe": "CWE-476",
        "cve": "CVE-2019-16233",
        "purpose": "Code purpose:\"\"\"该代码实现了QLogic光纤通道HBA(主机总线适配器)的PCI设备探测和初始化功能，包括内存分配、中断设置、工作队列创建、适配器配置等操作，以支持SCSI设备连接和数据传输。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核未检查alloc_workqueue()函数的返回值，当内存分配失败返回NULL时导致后续空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: qla2x00_probe_one\n- 参数: [struct pci_dev *pdev, const struct pci_device_id *id]\n- 调用者: 无（驱动入口函数）\n- 被调用者: [pci_select_bars, pci_enable_device_mem, pci_enable_device, pci_enable_pcie_error_reporting, kzalloc, ql_dbg_pci, ql_log_pci, INIT_LIST_HEAD, spin_lock_init, atomic_set, mutex_init, qla2x00_set_isp_flags, kthread_create, INIT_WORK, create_singlethread_workqueue, list_add_tail, qla2x00_start_timer, scsi_add_host, scsi_scan_host, qla2x00_alloc_sysfs_attr, qla2x00_init_host_attr, qla2x00_dfs_setup, ql_log, qlt_add_target, kthread_stop, qla2x00_free_device, scsi_host_put, qla2x00_mem_free, qla2x00_free_req_que, qla2x00_free_rsp_que, qla2x00_clear_drv_active, iounmap, pci_release_selected_regions, kfree, pci_disable_device]\n\n2. 函数名: qla2x00_set_isp_flags\n- 参数: [struct qla_hw_data *ha]\n- 调用者: qla2x00_probe_one\n- 被调用者: 无\n\n3. 函数名: qla2x00_create_host\n- 参数: [struct scsi_host_template *sht, struct qla_hw_data *ha]\n- 调用者: qla2x00_probe_one\n- 被调用者: 无\n\n4. 函数名: qla2x00_reserve_mgmt_server_loop_id\n- 参数: [scsi_qla_host_t *base_vha]\n- 调用者: qla2x00_probe_one\n- 被调用者: 无\n\n5. 函数名: qla2x00_set_fcport_state\n- 参数: [struct fc_port *fcport, int state]\n- 调用者: qla2x00_probe_one\n- 被调用者: 无\n\n6. 函数名: qla2x00_config_dma_addressing\n- 参数: [struct qla_hw_data *ha]\n- 调用者: qla2x00_probe_one\n- 被调用者: 无\n\n7. 函数名: qla2x00_mem_alloc\n- 参数: [struct qla_hw_data *ha, uint16_t req_length, uint16_t rsp_length, struct req_que **req, struct rsp_que **rsp]\n- 调用者: qla2x00_probe_one\n- 被调用者: 无\n\n8. 函数名: qla2x00_request_irqs\n- 参数: [struct qla_hw_data *ha, struct rsp_que *rsp]\n- 调用者: qla2x00_probe_one\n- 被调用者: 无\n\n9. 函数名: qla2x00_alloc_queues\n- 参数: [struct qla_hw_data *ha, struct req_que *req, struct rsp_que *rsp]\n- 调用者: qla2x00_probe_one\n- 被调用者: 无\n\n10. 函数名: qla2xxx_create_qpair\n- 参数: [scsi_qla_host_t *base_vha, int num, int force, bool startit]\n- 调用者: qla2x00_probe_one\n- 被调用者: 无\n\n11. 函数名: qla2x00_do_dpc\n- 参数: [void *data]\n- 调用者: kthread_create\n- 被调用者: 无\n\n12. 函数名: qla2xxx_wake_dpc\n- 参数: [scsi_qla_host_t *vha]\n- 调用者: qla2x00_probe_one\n- 被调用者: 无\n\n13. 函数名: qla2x00_disable_board_on_pci_error\n- 参数: [struct work_struct *work]\n- 调用者: INIT_WORK\n- 被调用者: 无\n\n14. 函数名: qla83xx_service_idc_aen\n- 参数: [struct work_struct *work]\n- 调用者: INIT_WORK\n- 被调用者: 无\n\n15. 函数名: qla83xx_nic_core_reset_work\n- 参数: [struct work_struct *work]\n- 调用者: INIT_WORK\n- 被调用者: 无\n\n16. 函数名: qla83xx_idc_state_handler_work\n- 参数: [struct work_struct *work]\n- 调用者: INIT_WORK\n- 被调用者: 无\n\n17. 函数名: qla83xx_nic_core_unrecoverable_work\n- 参数: [struct work_struct *work]\n- 调用者: INIT_WORK\n- 被调用者: 无\n\n18. 函数名: qla2x00_iocb_work_fn\n- 参数: [struct work_struct *work]\n- 调用者: INIT_WORK\n- 被调用者: 无\n\n19. 函数名: qlt_probe_one_stage1\n- 参数: [scsi_qla_host_t *base_vha, struct qla_hw_data *ha]\n- 调用者: qla2x00_probe_one\n- 被调用者: 无\n\n20. 函数名: qla2x00_initialize_adapter\n- 参数: [scsi_qla_host_t *base_vha]\n- 调用者: qla2x00_probe_one\n- 被调用者: 无\n\n21. 函数名: qla2x00_free_device\n- 参数: [scsi_qla_host_t *base_vha]\n- 调用者: qla2x00_probe_one\n- 被调用者: 无\n\n22. 函数名: qla2x00_free_queues\n- 参数: [struct qla_hw_data *ha]\n- 调用者: qla2x00_free_device\n- 被调用者: 无\n\n23. 函数名: qla2x00_stop_timer\n- 参数: [scsi_qla_host_t *vha]\n- 调用者: qla2x00_probe_one\n- 被调用者: 无\n\n24. 函数名: qla2x00_clear_drv_active\n- 参数: [struct qla_hw_data *ha]\n- 调用者: qla2x00_probe_one\n- 被调用者: 无\n\n25. 函数名: qlafx00_fx_disc\n- 参数: [scsi_qla_host_t *vha, struct fc_port *fcport, int cmd]\n- 调用者: qla2x00_probe_one\n- 被调用者: 无"
    },
    {
        "id": 2047,
        "cwe": "CWE-476",
        "cve": "CVE-2019-16234",
        "purpose": "Code purpose:\"\"\"该代码用于为Intel无线网卡设备分配和初始化PCIe传输层结构体，包括内存分配、中断处理、DMA设置等硬件资源初始化工作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未检查alloc_workqueue()函数的返回值，当内存分配失败返回NULL时，后续操作会导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: iwl_trans_pcie_alloc\n- 参数: [pdev, ent, cfg_trans]\n- 调用者: N/A (顶层函数)\n- 被调用者: [pcim_enable_device, iwl_trans_alloc, IWL_TRANS_GET_PCIE_TRANS, alloc_percpu, pci_disable_link_state, pci_set_master, pci_set_dma_mask, pci_set_consistent_dma_mask, pcim_iomap_regions_request_all, pcim_iomap_table, pci_write_config_byte, iwl_disable_interrupts, iwl_read32, iwl_pcie_prepare_card_hw, iwl_finish_nic_init, iwl_pcie_set_interrupt_capa, snprintf, iwl_pcie_init_msix_handler, iwl_pcie_alloc_ict, devm_request_threaded_irq, alloc_workqueue, INIT_WORK, iwl_pcie_free_ict, free_percpu, iwl_trans_free]\n\n2. 函数名: pcim_enable_device\n- 参数: [pdev]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n3. 函数名: iwl_trans_alloc\n- 参数: [sizeof(struct iwl_trans_pcie), &pdev->dev, &trans_ops_pcie_gen2/&trans_ops_pcie]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n4. 函数名: IWL_TRANS_GET_PCIE_TRANS\n- 参数: [trans]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n5. 函数名: alloc_percpu\n- 参数: [struct iwl_tso_hdr_page]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n6. 函数名: pci_disable_link_state\n- 参数: [pdev, PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1 | PCIE_LINK_STATE_CLKPM]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n7. 函数名: pci_set_master\n- 参数: [pdev]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n8. 函数名: pci_set_dma_mask\n- 参数: [pdev, DMA_BIT_MASK(addr_size)/DMA_BIT_MASK(32)]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n9. 函数名: pci_set_consistent_dma_mask\n- 参数: [pdev, DMA_BIT_MASK(addr_size)/DMA_BIT_MASK(32)]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n10. 函数名: pcim_iomap_regions_request_all\n- 参数: [pdev, BIT(0), DRV_NAME]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n11. 函数名: pcim_iomap_table\n- 参数: [pdev]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n12. 函数名: pci_write_config_byte\n- 参数: [pdev, PCI_CFG_RETRY_TIMEOUT, 0x00]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n13. 函数名: iwl_disable_interrupts\n- 参数: [trans]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n14. 函数名: iwl_read32\n- 参数: [trans, CSR_HW_REV]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n15. 函数名: iwl_pcie_prepare_card_hw\n- 参数: [trans]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n16. 函数名: iwl_finish_nic_init\n- 参数: [trans, cfg_trans]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n17. 函数名: iwl_pcie_set_interrupt_capa\n- 参数: [pdev, trans, cfg_trans]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n18. 函数名: snprintf\n- 参数: [trans->hw_id_str, sizeof(trans->hw_id_str), \"PCI ID: 0x%04X:0x%04X\", pdev->device, pdev->subsystem_device]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n19. 函数名: iwl_pcie_init_msix_handler\n- 参数: [pdev, trans_pcie]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n20. 函数名: iwl_pcie_alloc_ict\n- 参数: [trans]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n21. 函数名: devm_request_threaded_irq\n- 参数: [&pdev->dev, pdev->irq, iwl_pcie_isr, iwl_pcie_irq_handler, IRQF_SHARED, DRV_NAME, trans]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n22. 函数名: alloc_workqueue\n- 参数: [\"rb_allocator\", WQ_HIGHPRI | WQ_UNBOUND, 1]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n23. 函数名: INIT_WORK\n- 参数: [&trans_pcie->rba.rx_alloc, iwl_pcie_rx_allocator_work]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n24. 函数名: iwl_pcie_free_ict\n- 参数: [trans]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n25. 函数名: free_percpu\n- 参数: [trans_pcie->tso_hdr_page]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []\n\n26. 函数名: iwl_trans_free\n- 参数: [trans]\n- 调用者: iwl_trans_pcie_alloc\n- 被调用者: []"
    },
    {
        "id": 2090,
        "cwe": "CWE-476",
        "cve": "CVE-2019-18680",
        "purpose": "Code purpose:\"\"\"该代码用于在指定网络命名空间中停止RDS-TCP监听并销毁相关连接，处理连接列表时存在潜在的NULL指针解引用问题\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在rds_tcp_kill_sock函数中，当rtn->rds_tcp_listen_sock为NULL时，直接将其传递给rds_tcp_listen_stop函数，导致NULL指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: rds_tcp_kill_sock\n- 参数: [net]\n- 调用者: 未明确（可能是内核其他模块）\n- 被调用者: [net_generic, rds_tcp_listen_stop, spin_lock_irq, list_for_each_entry_safe, read_pnet, list_has_conn, list_move_tail, list_del, spin_unlock_irq, rds_conn_destroy]\n\n2. 函数名: net_generic\n- 参数: [net, rds_tcp_netid]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: []\n\n3. 函数名: rds_tcp_listen_stop\n- 参数: [lsock, &rtn->rds_tcp_accept_w]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: []\n\n4. 函数名: spin_lock_irq\n- 参数: [&rds_tcp_conn_lock]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: []\n\n5. 函数名: list_for_each_entry_safe\n- 参数: [tc, _tc, &rds_tcp_conn_list, t_tcp_node]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: []\n\n6. 函数名: read_pnet\n- 参数: [&tc->t_cpath->cp_conn->c_net]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: []\n\n7. 函数名: list_has_conn\n- 参数: [&tmp_list, tc->t_cpath->cp_conn]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: []\n\n8. 函数名: list_move_tail\n- 参数: [&tc->t_tcp_node, &tmp_list]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: []\n\n9. 函数名: list_del\n- 参数: [&tc->t_tcp_node]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: []\n\n10. 函数名: spin_unlock_irq\n- 参数: [&rds_tcp_conn_lock]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: []\n\n11. 函数名: rds_conn_destroy\n- 参数: [tc->t_cpath->cp_conn]\n- 调用者: rds_tcp_kill_sock\n- 被调用者: []"
    },
    {
        "id": 2107,
        "cwe": "CWE-476",
        "cve": "CVE-2019-18885",
        "purpose": "Code purpose:\"\"\"初始化Btrfs文件系统的设备替换功能，包括查找设备替换条目、验证设备状态以及设置替换设备的相关参数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在btrfs_init_dev_replace函数中，当处理设备替换操作时，由于未正确验证fs_devices->devices的有效性，导致在find_device函数中可能引发空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: btrfs_init_dev_replace\n- 参数: [struct btrfs_fs_info *fs_info]\n- 调用者: 未显示（外部调用）\n- 被调用者: [btrfs_alloc_path, btrfs_search_slot, btrfs_item_size_nr, btrfs_item_ptr, btrfs_dev_replace_src_devid, btrfs_dev_replace_cont_reading_from_srcdev_mode, btrfs_dev_replace_replace_state, btrfs_dev_replace_time_started, btrfs_dev_replace_time_stopped, btrfs_dev_replace_num_write_errors, btrfs_dev_replace_num_uncorrectable_read_errors, btrfs_dev_replace_cursor_left, btrfs_dev_replace_cursor_right, btrfs_find_device, btrfs_test_opt, btrfs_warn, btrfs_free_path]\n\n2. 函数名: btrfs_alloc_path\n- 参数: []\n- 调用者: btrfs_init_dev_replace\n- 被调用者: []\n\n3. 函数名: btrfs_search_slot\n- 参数: [NULL, dev_root, &key, path, 0, 0]\n- 调用者: btrfs_init_dev_replace\n- 被调用者: []\n\n4. 函数名: btrfs_item_size_nr\n- 参数: [eb, slot]\n- 调用者: btrfs_init_dev_replace\n- 被调用者: []\n\n5. 函数名: btrfs_item_ptr\n- 参数: [eb, slot, struct btrfs_dev_replace_item]\n- 调用者: btrfs_init_dev_replace\n- 被调用者: []\n\n6. 函数名: btrfs_dev_replace_src_devid\n- 参数: [eb, ptr]\n- 调用者: btrfs_init_dev_replace\n- 被调用者: []\n\n7. 函数名: btrfs_dev_replace_cont_reading_from_srcdev_mode\n- 参数: [eb, ptr]\n- 调用者: btrfs_init_dev_replace\n- 被调用者: []\n\n8. 函数名: btrfs_dev_replace_replace_state\n- 参数: [eb, ptr]\n- 调用者: btrfs_init_dev_replace\n- 被调用者: []\n\n9. 函数名: btrfs_dev_replace_time_started\n- 参数: [eb, ptr]\n- 调用者: btrfs_init_dev_replace\n- 被调用者: []\n\n10. 函数名: btrfs_dev_replace_time_stopped\n- 参数: [eb, ptr]\n- 调用者: btrfs_init_dev_replace\n- 被调用者: []\n\n11. 函数名: btrfs_dev_replace_num_write_errors\n- 参数: [eb, ptr]\n- 调用者: btrfs_init_dev_replace\n- 被调用者: []\n\n12. 函数名: btrfs_dev_replace_num_uncorrectable_read_errors\n- 参数: [eb, ptr]\n- 调用者: btrfs_init_dev_replace\n- 被调用者: []\n\n13. 函数名: btrfs_dev_replace_cursor_left\n- 参数: [eb, ptr]\n- 调用者: btrfs_init_dev_replace\n- 被调用者: []\n\n14. 函数名: btrfs_dev_replace_cursor_right\n- 参数: [eb, ptr]\n- 调用者: btrfs_init_dev_replace\n- 被调用者: []\n\n15. 函数名: btrfs_find_device\n- 参数: [fs_info->fs_devices, src_devid, NULL, NULL], [fs_info->fs_devices, BTRFS_DEV_REPLACE_DEVID, NULL, NULL]\n- 调用者: btrfs_init_dev_replace\n- 被调用者: []\n\n16. 函数名: btrfs_test_opt\n- 参数: [fs_info, DEGRADED]\n- 调用者: btrfs_init_dev_replace\n- 被调用者: []\n\n17. 函数名: btrfs_warn\n- 参数: [fs_info, \"dev_replace entry found has unexpected size, ignore entry\"], [fs_info, \"cannot mount because device replace operation is ongoing and\"], [fs_info, \"srcdev (devid %llu) is missing, need to run 'btrfs dev scan'?\", src_devid], [fs_info, \"tgtdev (devid %llu) is missing, need to run 'btrfs dev scan'?\", BTRFS_DEV_REPLACE_DEVID]\n- 调用者: btrfs_init_dev_replace\n- 被调用者: []\n\n18. 函数名: btrfs_free_path\n- 参数: [path]\n- 调用者: btrfs_init_dev_replace\n- 被调用者: []"
    },
    {
        "id": 2108,
        "cwe": "CWE-476",
        "cve": "CVE-2019-18885",
        "purpose": "Code purpose:\"\"\"该代码实现了Btrfs文件系统中通过ioctl调用调整设备大小的功能，包括检查权限、验证设备、计算新大小并执行扩容或缩容操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在btrfs_ioctl_resize函数中，当调用btrfs_find_device查找设备时，未正确处理fs_devices->devices为NULL的情况，导致空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: btrfs_ioctl_resize\n- 参数: [struct file *file, void __user *arg]\n- 调用者: 未显示（应为ioctl系统调用的处理函数）\n- 被调用者: [file_inode, btrfs_sb, capable, mnt_want_write_file, test_and_set_bit, mnt_drop_write_file, memdup_user, strchr, kstrtoull, btrfs_find_device, test_bit, strcmp, memparse, btrfs_device_get_total_bytes, round_down, btrfs_info_in_rcu, btrfs_start_transaction, btrfs_grow_device, btrfs_commit_transaction, btrfs_shrink_device, kfree, clear_bit]\n\n2. 函数名: file_inode\n- 参数: [struct file *file]\n- 调用者: btrfs_ioctl_resize\n- 被调用者: []\n\n3. 函数名: btrfs_sb\n- 参数: [struct super_block *sb]\n- 调用者: btrfs_ioctl_resize\n- 被调用者: []\n\n4. 函数名: capable\n- 参数: [int cap]\n- 调用者: btrfs_ioctl_resize\n- 被调用者: []\n\n5. 函数名: mnt_want_write_file\n- 参数: [struct file *file]\n- 调用者: btrfs_ioctl_resize\n- 被调用者: []\n\n6. 函数名: test_and_set_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: btrfs_ioctl_resize\n- 被调用者: []\n\n7. 函数名: mnt_drop_write_file\n- 参数: [struct file *file]\n- 调用者: btrfs_ioctl_resize\n- 被调用者: []\n\n8. 函数名: memdup_user\n- 参数: [void __user *src, size_t len]\n- 调用者: btrfs_ioctl_resize\n- 被调用者: []\n\n9. 函数名: strchr\n- 参数: [const char *s, int c]\n- 调用者: btrfs_ioctl_resize\n- 被调用者: []\n\n10. 函数名: kstrtoull\n- 参数: [const char *s, unsigned int base, unsigned long long *res]\n- 调用者: btrfs_ioctl_resize\n- 被调用者: []\n\n11. 函数名: btrfs_find_device\n- 参数: [struct btrfs_fs_devices *fs_devices, u64 devid, u8 *uuid, u8 *fsid]\n- 调用者: btrfs_ioctl_resize\n- 被调用者: []\n\n12. 函数名: test_bit\n- 参数: [int nr, const volatile unsigned long *addr]\n- 调用者: btrfs_ioctl_resize\n- 被调用者: []\n\n13. 函数名: strcmp\n- 参数: [const char *cs, const char *ct]\n- 调用者: btrfs_ioctl_resize\n- 被调用者: []\n\n14. 函数名: memparse\n- 参数: [const char *ptr, char **retptr]\n- 调用者: btrfs_ioctl_resize\n- 被调用者: []\n\n15. 函数名: btrfs_device_get_total_bytes\n- 参数: [struct btrfs_device *device]\n- 调用者: btrfs_ioctl_resize\n- 被调用者: []\n\n16. 函数名: round_down\n- 参数: [u64 size, u64 sectorsize]\n- 调用者: btrfs_ioctl_resize\n- 被调用者: []\n\n17. 函数名: btrfs_info_in_rcu\n- 参数: [struct btrfs_fs_info *fs_info, const char *fmt, ...]\n- 调用者: btrfs_ioctl_resize\n- 被调用者: []\n\n18. 函数名: btrfs_start_transaction\n- 参数: [struct btrfs_root *root, int num_items]\n- 调用者: btrfs_ioctl_resize\n- 被调用者: []\n\n19. 函数名: btrfs_grow_device\n- 参数: [struct btrfs_trans_handle *trans, struct btrfs_device *device, u64 new_size]\n- 调用者: btrfs_ioctl_resize\n- 被调用者: []\n\n20. 函数名: btrfs_commit_transaction\n- 参数: [struct btrfs_trans_handle *trans]\n- 调用者: btrfs_ioctl_resize\n- 被调用者: []\n\n21. 函数名: btrfs_shrink_device\n- 参数: [struct btrfs_device *device, u64 new_size]\n- 调用者: btrfs_ioctl_resize\n- 被调用者: []\n\n22. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: btrfs_ioctl_resize\n- 被调用者: []\n\n23. 函数名: clear_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: btrfs_ioctl_resize\n- 被调用者: []"
    },
    {
        "id": 2109,
        "cwe": "CWE-476",
        "cve": "CVE-2019-18885",
        "purpose": "Code purpose:\"\"\"该代码用于处理Btrfs文件系统的设备信息IOCTL请求，包括查找设备、获取设备ID、使用空间、总空间和UUID等信息，并将结果返回给用户空间。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在find_device函数中未正确处理fs_devices->devices为空的情况，导致当传入精心构造的btrfs镜像时可能引发空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: btrfs_ioctl_dev_info\n- 参数: [struct btrfs_fs_info *fs_info, void __user *arg]\n- 调用者: 未显示\n- 被调用者: [memdup_user, IS_ERR, PTR_ERR, btrfs_is_empty_uuid, rcu_read_lock, btrfs_find_device, btrfs_device_get_bytes_used, btrfs_device_get_total_bytes, memcpy, strncpy, rcu_str_deref, rcu_read_unlock, copy_to_user, kfree]\n\n2. 函数名: memdup_user\n- 参数: [void __user *arg, size_t size]\n- 调用者: btrfs_ioctl_dev_info\n- 被调用者: 未显示\n\n3. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: btrfs_ioctl_dev_info\n- 被调用者: 未显示\n\n4. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: btrfs_ioctl_dev_info\n- 被调用者: 未显示\n\n5. 函数名: btrfs_is_empty_uuid\n- 参数: [u8 *uuid]\n- 调用者: btrfs_ioctl_dev_info\n- 被调用者: 未显示\n\n6. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: btrfs_ioctl_dev_info\n- 被调用者: 未显示\n\n7. 函数名: btrfs_find_device\n- 参数: [struct btrfs_fs_devices *fs_devices, u64 devid, char *uuid, bool *missing]\n- 调用者: btrfs_ioctl_dev_info\n- 被调用者: 未显示\n\n8. 函数名: btrfs_device_get_bytes_used\n- 参数: [struct btrfs_device *dev]\n- 调用者: btrfs_ioctl_dev_info\n- 被调用者: 未显示\n\n9. 函数名: btrfs_device_get_total_bytes\n- 参数: [struct btrfs_device *dev]\n- 调用者: btrfs_ioctl_dev_info\n- 被调用者: 未显示\n\n10. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: btrfs_ioctl_dev_info\n- 被调用者: 未显示\n\n11. 函数名: strncpy\n- 参数: [char *dest, const char *src, size_t n]\n- 调用者: btrfs_ioctl_dev_info\n- 被调用者: 未显示\n\n12. 函数名: rcu_str_deref\n- 参数: [const char **ptr]\n- 调用者: btrfs_ioctl_dev_info\n- 被调用者: 未显示\n\n13. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: btrfs_ioctl_dev_info\n- 被调用者: 未显示\n\n14. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: btrfs_ioctl_dev_info\n- 被调用者: 未显示\n\n15. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: btrfs_ioctl_dev_info\n- 被调用者: 未显示"
    },
    {
        "id": 2110,
        "cwe": "CWE-476",
        "cve": "CVE-2019-18885",
        "purpose": "Code purpose:\"\"\"该代码实现了Btrfs文件系统中设备数据校验和修复的功能，包括设备查找、状态检查、校验过程设置以及错误处理等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在find_device函数中未正确处理fs_devices->devices为空的情况，导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: btrfs_scrub_dev\n- 参数: [struct btrfs_fs_info *fs_info, u64 devid, u64 start, u64 end, struct btrfs_scrub_progress *progress, int readonly, int is_dev_replace]\n- 调用者: N/A (top-level function)\n- 被调用者: [btrfs_fs_closing, scrub_setup_ctx, btrfs_find_device, scrub_workers_get, __scrub_blocked_if_needed, scrub_supers, scrub_enumerate_chunks, scrub_free_ctx, scrub_put_ctx, scrub_workers_put]\n\n2. 函数名: btrfs_fs_closing\n- 参数: [struct btrfs_fs_info *fs_info]\n- 调用者: btrfs_scrub_dev\n- 被调用者: []\n\n3. 函数名: scrub_setup_ctx\n- 参数: [struct btrfs_fs_info *fs_info, int is_dev_replace]\n- 调用者: btrfs_scrub_dev\n- 被调用者: []\n\n4. 函数名: btrfs_find_device\n- 参数: [struct btrfs_fs_devices *fs_devices, u64 devid, u8 *uuid, u8 *fsid]\n- 调用者: btrfs_scrub_dev\n- 被调用者: []\n\n5. 函数名: scrub_workers_get\n- 参数: [struct btrfs_fs_info *fs_info, int is_dev_replace]\n- 调用者: btrfs_scrub_dev\n- 被调用者: []\n\n6. 函数名: __scrub_blocked_if_needed\n- 参数: [struct btrfs_fs_info *fs_info]\n- 调用者: btrfs_scrub_dev\n- 被调用者: []\n\n7. 函数名: scrub_supers\n- 参数: [struct scrub_ctx *sctx, struct btrfs_device *dev]\n- 调用者: btrfs_scrub_dev\n- 被调用者: []\n\n8. 函数名: scrub_enumerate_chunks\n- 参数: [struct scrub_ctx *sctx, struct btrfs_device *dev, u64 start, u64 end]\n- 调用者: btrfs_scrub_dev\n- 被调用者: []\n\n9. 函数名: scrub_free_ctx\n- 参数: [struct scrub_ctx *sctx]\n- 调用者: btrfs_scrub_dev\n- 被调用者: []\n\n10. 函数名: scrub_put_ctx\n- 参数: [struct scrub_ctx *sctx]\n- 调用者: btrfs_scrub_dev\n- 被调用者: []\n\n11. 函数名: scrub_workers_put\n- 参数: [struct btrfs_fs_info *fs_info]\n- 调用者: btrfs_scrub_dev\n- 被调用者: []\n\n12. 函数名: btrfs_dev_replace_is_ongoing\n- 参数: [struct btrfs_dev_replace *dev_replace]\n- 调用者: btrfs_scrub_dev\n- 被调用者: []\n\n13. 函数名: btrfs_err\n- 参数: [struct btrfs_fs_info *fs_info, const char *fmt, ...]\n- 调用者: btrfs_scrub_dev\n- 被调用者: []\n\n14. 函数名: btrfs_err_rl\n- 参数: [struct btrfs_fs_info *fs_info, const char *fmt, ...]\n- 调用者: btrfs_scrub_dev\n- 被调用者: []\n\n15. 函数名: btrfs_err_in_rcu\n- 参数: [struct btrfs_fs_info *fs_info, const char *fmt, ...]\n- 调用者: btrfs_scrub_dev\n- 被调用者: []\n\n16. 函数名: memalloc_nofs_save\n- 参数: []\n- 调用者: btrfs_scrub_dev\n- 被调用者: []\n\n17. 函数名: memalloc_nofs_restore\n- 参数: [unsigned int flags]\n- 调用者: btrfs_scrub_dev\n- 被调用者: []\n\n18. 函数名: wait_event\n- 参数: [wait_queue_head_t *wq_head, condition]\n- 调用者: btrfs_scrub_dev\n- 被调用者: []\n\n19. 函数名: wake_up\n- 参数: [wait_queue_head_t *q]\n- 调用者: btrfs_scrub_dev\n- 被调用者: []\n\n20. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: btrfs_scrub_dev\n- 被调用者: []"
    },
    {
        "id": 2111,
        "cwe": "CWE-476",
        "cve": "CVE-2019-18885",
        "purpose": "Code purpose:\"\"\"该代码用于获取并复制Btrfs文件系统中指定设备的scrub进度信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在find_device函数中未正确处理fs_devices->devices为空的情况，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: btrfs_scrub_progress\n- 参数: [struct btrfs_fs_info *fs_info, u64 devid, struct btrfs_scrub_progress *progress]\n- 调用者: 未指定\n- 被调用者: [mutex_lock, btrfs_find_device, mutex_unlock, memcpy]\n\n2. 函数名: btrfs_find_device\n- 参数: [struct btrfs_fs_devices *fs_devices, u64 devid, u8 *uuid, u8 *fsid]\n- 调用者: btrfs_scrub_progress\n- 被调用者: 未指定\n\n3. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: btrfs_scrub_progress\n- 被调用者: 未指定\n\n4. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: btrfs_scrub_progress\n- 被调用者: 未指定\n\n5. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: btrfs_scrub_progress\n- 被调用者: 未指定"
    },
    {
        "id": 2112,
        "cwe": "CWE-476",
        "cve": "CVE-2019-18885",
        "purpose": "Code purpose:\"\"\"该代码用于获取和重置Btrfs文件系统中设备的统计信息，包括处理设备查找、统计信息有效性检查以及统计数据的读取或重置操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在find_device函数中未正确处理fs_devices->devices为空的情况，导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: btrfs_get_dev_stats\n- 参数: [struct btrfs_fs_info *fs_info, struct btrfs_ioctl_get_dev_stats *stats]\n- 调用者: 未指定\n- 被调用者: [btrfs_find_device, btrfs_warn, btrfs_dev_stat_read_and_reset, btrfs_dev_stat_reset, btrfs_dev_stat_read]\n\n2. 函数名: btrfs_find_device\n- 参数: [struct btrfs_fs_devices *fs_devices, stats->devid, NULL, NULL]\n- 调用者: btrfs_get_dev_stats\n- 被调用者: 未指定\n\n3. 函数名: btrfs_warn\n- 参数: [struct btrfs_fs_info *fs_info, \"get dev_stats failed, device not found\"]\n- 调用者: btrfs_get_dev_stats\n- 被调用者: 未指定\n\n4. 函数名: btrfs_dev_stat_read_and_reset\n- 参数: [struct btrfs_device *dev, int i]\n- 调用者: btrfs_get_dev_stats\n- 被调用者: 未指定\n\n5. 函数名: btrfs_dev_stat_reset\n- 参数: [struct btrfs_device *dev, int i]\n- 调用者: btrfs_get_dev_stats\n- 被调用者: 未指定\n\n6. 函数名: btrfs_dev_stat_read\n- 参数: [struct btrfs_device *dev, int i]\n- 调用者: btrfs_get_dev_stats\n- 被调用者: 未指定"
    },
    {
        "id": 2113,
        "cwe": "CWE-476",
        "cve": "CVE-2019-18885",
        "purpose": "Code purpose:\"\"\"该代码用于在Btrfs文件系统中读取并验证设备信息，处理设备缺失或损坏的情况，并维护设备状态的一致性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在find_device函数中未正确处理fs_devices->devices为空的情况，导致当处理恶意构造的btrfs镜像时可能引发空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: read_one_dev\n- 参数: [struct btrfs_fs_info *fs_info, struct extent_buffer *leaf, struct btrfs_dev_item *dev_item]\n- 调用者: 未显示\n- 被调用者: [btrfs_device_id, read_extent_buffer, memcmp, open_seed_devices, btrfs_find_device, btrfs_test_opt, btrfs_report_missing_device, add_missing_dev, test_bit, set_bit, list_move, fill_device_from_item, atomic64_add]\n\n2. 函数名: btrfs_device_id\n- 参数: [struct extent_buffer *leaf, struct btrfs_dev_item *dev_item]\n- 调用者: read_one_dev\n- 被调用者: 未显示\n\n3. 函数名: read_extent_buffer\n- 参数: [struct extent_buffer *leaf, u8 *dev_uuid, btrfs_device_uuid(dev_item), BTRFS_UUID_SIZE]\n- 调用者: read_one_dev\n- 被调用者: 未显示\n\n4. 函数名: memcmp\n- 参数: [u8 *fs_uuid, u8 *fs_devices->metadata_uuid, BTRFS_FSID_SIZE]\n- 调用者: read_one_dev\n- 被调用者: 未显示\n\n5. 函数名: open_seed_devices\n- 参数: [struct btrfs_fs_info *fs_info, u8 *fs_uuid]\n- 调用者: read_one_dev\n- 被调用者: 未显示\n\n6. 函数名: btrfs_find_device\n- 参数: [struct btrfs_fs_devices *fs_devices, u64 devid, u8 *dev_uuid, u8 *fs_uuid]\n- 调用者: read_one_dev\n- 被调用者: 未显示\n\n7. 函数名: btrfs_test_opt\n- 参数: [struct btrfs_fs_info *fs_info, DEGRADED]\n- 调用者: read_one_dev\n- 被调用者: 未显示\n\n8. 函数名: btrfs_report_missing_device\n- 参数: [struct btrfs_fs_info *fs_info, u64 devid, u8 *dev_uuid, bool]\n- 调用者: read_one_dev\n- 被调用者: 未显示\n\n9. 函数名: add_missing_dev\n- 参数: [struct btrfs_fs_devices *fs_devices, u64 devid, u8 *dev_uuid]\n- 调用者: read_one_dev\n- 被调用者: 未显示\n\n10. 函数名: test_bit\n- 参数: [BTRFS_DEV_STATE_MISSING, &device->dev_state]\n- 调用者: read_one_dev\n- 被调用者: 未显示\n\n11. 函数名: set_bit\n- 参数: [BTRFS_DEV_STATE_MISSING, &device->dev_state]\n- 调用者: read_one_dev\n- 被调用者: 未显示\n\n12. 函数名: list_move\n- 参数: [&device->dev_list, &fs_devices->devices]\n- 调用者: read_one_dev\n- 被调用者: 未显示\n\n13. 函数名: fill_device_from_item\n- 参数: [struct extent_buffer *leaf, struct btrfs_dev_item *dev_item, struct btrfs_device *device]\n- 调用者: read_one_dev\n- 被调用者: 未显示\n\n14. 函数名: atomic64_add\n- 参数: [device->total_bytes - device->bytes_used, &fs_info->free_chunk_space]\n- 调用者: read_one_dev\n- 被调用者: 未显示"
    },
    {
        "id": 2114,
        "cwe": "CWE-476",
        "cve": "CVE-2019-18885",
        "purpose": "Code purpose:\"\"\"通过设备路径查找并返回对应的Btrfs文件系统设备信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在btrfs_find_device_by_path函数中，当btrfs_find_device返回NULL时，未正确处理fs_devices->devices为空的情况，导致后续可能发生空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: btrfs_find_device_by_path\n- 参数: [struct btrfs_fs_info *fs_info, const char *device_path]\n- 调用者: N/A\n- 被调用者: [btrfs_get_bdev_and_sb, btrfs_stack_device_id, btrfs_fs_incompat, btrfs_find_device, brelse, blkdev_put]\n\n2. 函数名: btrfs_get_bdev_and_sb\n- 参数: [const char *device_path, FMODE_READ, fs_info->bdev_holder, 0, &bdev, &bh]\n- 调用者: btrfs_find_device_by_path\n- 被调用者: N/A\n\n3. 函数名: btrfs_stack_device_id\n- 参数: [&disk_super->dev_item]\n- 调用者: btrfs_find_device_by_path\n- 被调用者: N/A\n\n4. 函数名: btrfs_fs_incompat\n- 参数: [struct btrfs_fs_info *fs_info, METADATA_UUID]\n- 调用者: btrfs_find_device_by_path\n- 被调用者: N/A\n\n5. 函数名: btrfs_find_device\n- 参数: [fs_info->fs_devices, devid, dev_uuid, disk_super->metadata_uuid] 或 [fs_info->fs_devices, devid, dev_uuid, disk_super->fsid]\n- 调用者: btrfs_find_device_by_path\n- 被调用者: N/A\n\n6. 函数名: brelse\n- 参数: [bh]\n- 调用者: btrfs_find_device_by_path\n- 被调用者: N/A\n\n7. 函数名: blkdev_put\n- 参数: [bdev, FMODE_READ]\n- 调用者: btrfs_find_device_by_path\n- 被调用者: N/A"
    },
    {
        "id": 2115,
        "cwe": "CWE-476",
        "cve": "CVE-2019-18885",
        "purpose": "Code purpose:\"\"\"该代码用于读取并验证Btrfs文件系统中的数据块(chunk)信息，将其映射到内存中的数据结构，并处理相关的设备条纹(stripe)信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在find_device函数中未正确处理fs_devices->devices为空的情况，导致当处理恶意构造的btrfs镜像时可能引发空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: read_one_chunk\n- 参数: [struct btrfs_fs_info *fs_info, struct btrfs_key *key, struct extent_buffer *leaf, struct btrfs_chunk *chunk]\n- 调用者: N/A\n- 被调用者: [btrfs_chunk_length, btrfs_chunk_num_stripes, btrfs_check_chunk_valid, lookup_extent_mapping, free_extent_map, alloc_extent_map, kmalloc, set_bit, btrfs_chunk_io_width, btrfs_chunk_io_align, btrfs_chunk_stripe_len, btrfs_chunk_type, btrfs_chunk_sub_stripes, btrfs_stripe_offset_nr, btrfs_stripe_devid_nr, read_extent_buffer, btrfs_stripe_dev_uuid_nr, btrfs_find_device, btrfs_test_opt, btrfs_report_missing_device, add_missing_dev, IS_ERR, PTR_ERR, add_extent_mapping, btrfs_err]\n\n2. 函数名: btrfs_chunk_length\n- 参数: [struct extent_buffer *leaf, struct btrfs_chunk *chunk]\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n3. 函数名: btrfs_chunk_num_stripes\n- 参数: [struct extent_buffer *leaf, struct btrfs_chunk *chunk]\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n4. 函数名: btrfs_check_chunk_valid\n- 参数: [struct btrfs_fs_info *fs_info, struct extent_buffer *leaf, struct btrfs_chunk *chunk, u64 logical]\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n5. 函数名: lookup_extent_mapping\n- 参数: [struct extent_map_tree *tree, u64 start, u64 len]\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n6. 函数名: free_extent_map\n- 参数: [struct extent_map *em]\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n7. 函数名: alloc_extent_map\n- 参数: []\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n8. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n9. 函数名: set_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n10. 函数名: btrfs_chunk_io_width\n- 参数: [struct extent_buffer *leaf, struct btrfs_chunk *chunk]\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n11. 函数名: btrfs_chunk_io_align\n- 参数: [struct extent_buffer *leaf, struct btrfs_chunk *chunk]\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n12. 函数名: btrfs_chunk_stripe_len\n- 参数: [struct extent_buffer *leaf, struct btrfs_chunk *chunk]\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n13. 函数名: btrfs_chunk_type\n- 参数: [struct extent_buffer *leaf, struct btrfs_chunk *chunk]\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n14. 函数名: btrfs_chunk_sub_stripes\n- 参数: [struct extent_buffer *leaf, struct btrfs_chunk *chunk]\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n15. 函数名: btrfs_stripe_offset_nr\n- 参数: [struct extent_buffer *leaf, struct btrfs_chunk *chunk, int nr]\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n16. 函数名: btrfs_stripe_devid_nr\n- 参数: [struct extent_buffer *leaf, struct btrfs_chunk *chunk, int nr]\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n17. 函数名: read_extent_buffer\n- 参数: [struct extent_buffer *eb, void *dst, unsigned long start, unsigned long len]\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n18. 函数名: btrfs_stripe_dev_uuid_nr\n- 参数: [struct btrfs_chunk *chunk, int nr]\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n19. 函数名: btrfs_find_device\n- 参数: [struct btrfs_fs_devices *fs_devices, u64 devid, u8 *uuid, u8 *fsid]\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n20. 函数名: btrfs_test_opt\n- 参数: [struct btrfs_fs_info *info, int opt]\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n21. 函数名: btrfs_report_missing_device\n- 参数: [struct btrfs_fs_info *fs_info, u64 devid, u8 *uuid, bool error]\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n22. 函数名: add_missing_dev\n- 参数: [struct btrfs_fs_devices *fs_devices, u64 devid, u8 *uuid]\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n23. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n24. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n25. 函数名: add_extent_mapping\n- 参数: [struct extent_map_tree *tree, struct extent_map *em, int modified]\n- 调用者: read_one_chunk\n- 被调用者: N/A\n\n26. 函数名: btrfs_err\n- 参数: [struct btrfs_fs_info *fs_info, const char *fmt, ...]\n- 调用者: read_one_chunk\n- 被调用者: N/A"
    },
    {
        "id": 2116,
        "cwe": "CWE-476",
        "cve": "CVE-2019-18885",
        "purpose": "Code purpose:\"\"\"该代码用于在Btrfs文件系统中根据设备ID或设备路径查找对应的设备结构体，并处理特殊情况如缺失设备的情况。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当fs_devices->devices为空时，代码未进行空指针检查就直接访问，导致NULL指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: btrfs_find_device_by_devspec\n- 参数: [struct btrfs_fs_info *fs_info, u64 devid, const char *device_path]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [btrfs_find_device, ERR_PTR, strcmp, test_bit, btrfs_find_device_by_path]\n\n2. 函数名: btrfs_find_device\n- 参数: [struct btrfs_fs_devices *fs_devices, u64 devid, NULL, NULL]\n- 调用者: btrfs_find_device_by_devspec\n- 被调用者: 未明确（代码片段中未显示）\n\n3. 函数名: ERR_PTR\n- 参数: [long error_code]\n- 调用者: btrfs_find_device_by_devspec\n- 被调用者: 未明确（通常是内核宏/函数）\n\n4. 函数名: strcmp\n- 参数: [const char *str1, const char *str2]\n- 调用者: btrfs_find_device_by_devspec\n- 被调用者: 未明确（标准库函数）\n\n5. 函数名: test_bit\n- 参数: [int nr, const volatile unsigned long *addr]\n- 调用者: btrfs_find_device_by_devspec\n- 被调用者: 未明确（通常是内核宏/函数）\n\n6. 函数名: btrfs_find_device_by_path\n- 参数: [struct btrfs_fs_info *fs_info, const char *device_path]\n- 调用者: btrfs_find_device_by_devspec\n- 被调用者: 未明确（代码片段中未显示）"
    },
    {
        "id": 2117,
        "cwe": "CWE-476",
        "cve": "CVE-2019-18885",
        "purpose": "Code purpose:\"\"\"该代码用于管理Btrfs文件系统中的设备列表，处理设备的添加、查找和更新操作，包括处理设备ID、UUID和文件系统ID等元数据。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在find_device函数中未正确处理fs_devices->devices为空的情况，导致可能发生空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: device_list_add\n- 参数: [path, disk_super, new_device_added]\n- 调用者: 未显示\n- 被调用者: [btrfs_super_generation, btrfs_stack_device_id, btrfs_super_incompat_flags, btrfs_super_flags, find_fsid_inprogress, find_fsid, find_fsid_changed, alloc_fs_devices, IS_ERR, ERR_CAST, mutex_lock, list_add, find_device, memcpy, mutex_unlock, btrfs_alloc_device, rcu_string_strdup, btrfs_free_device, rcu_assign_pointer, list_add_rcu, pr_info, strcmp, lookup_bdev, bdput, btrfs_warn_in_rcu, rcu_str_deref, btrfs_info_in_rcu, rcu_string_free, test_bit, clear_bit, max_t, btrfs_super_num_devices]\n\n2. 函数名: find_fsid_inprogress\n- 参数: [disk_super]\n- 调用者: device_list_add\n- 被调用者: 未显示\n\n3. 函数名: find_fsid\n- 参数: [fsid, metadata_uuid]\n- 调用者: device_list_add\n- 被调用者: 未显示\n\n4. 函数名: find_fsid_changed\n- 参数: [disk_super]\n- 调用者: device_list_add\n- 被调用者: 未显示\n\n5. 函数名: alloc_fs_devices\n- 参数: [fsid, metadata_uuid]\n- 调用者: device_list_add\n- 被调用者: 未显示\n\n6. 函数名: find_device\n- 参数: [fs_devices, devid, uuid]\n- 调用者: device_list_add\n- 被调用者: 未显示\n\n7. 函数名: btrfs_alloc_device\n- 参数: [NULL, devid, uuid]\n- 调用者: device_list_add\n- 被调用者: 未显示\n\n8. 函数名: rcu_string_strdup\n- 参数: [path, GFP_NOFS]\n- 调用者: device_list_add\n- 被调用者: 未显示\n\n9. 函数名: rcu_string_free\n- 参数: [device->name]\n- 调用者: device_list_add\n- 被调用者: 未显示\n\n10. 函数名: lookup_bdev\n- 参数: [path]\n- 调用者: device_list_add\n- 被调用者: 未显示"
    },
    {
        "id": 2118,
        "cwe": "CWE-476",
        "cve": "CVE-2019-18885",
        "purpose": "Code purpose:\"\"\"该代码用于处理Btrfs文件系统中的设备项，完成设备生成和更新的操作，包括查找设备、更新设备生成信息并标记缓冲区为脏。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在btrfs_finish_sprout函数中，当btrfs_find_device无法找到设备时，未对返回的NULL指针进行检查就直接使用，导致NULL指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: btrfs_finish_sprout\n- 参数: [trans, fs_info]\n- 调用者: 未显示\n- 被调用者: [btrfs_alloc_path, btrfs_search_slot, btrfs_next_leaf, btrfs_item_key_to_cpu, btrfs_release_path, btrfs_item_ptr, btrfs_device_id, read_extent_buffer, btrfs_find_device, btrfs_set_device_generation, btrfs_mark_buffer_dirty, btrfs_free_path]\n\n2. 函数名: btrfs_alloc_path\n- 参数: []\n- 调用者: btrfs_finish_sprout\n- 被调用者: 未显示\n\n3. 函数名: btrfs_search_slot\n- 参数: [trans, root, key, path, 0, 1]\n- 调用者: btrfs_finish_sprout\n- 被调用者: 未显示\n\n4. 函数名: btrfs_next_leaf\n- 参数: [root, path]\n- 调用者: btrfs_finish_sprout\n- 被调用者: 未显示\n\n5. 函数名: btrfs_item_key_to_cpu\n- 参数: [leaf, key, path->slots[0]]\n- 调用者: btrfs_finish_sprout\n- 被调用者: 未显示\n\n6. 函数名: btrfs_release_path\n- 参数: [path]\n- 调用者: btrfs_finish_sprout\n- 被调用者: 未显示\n\n7. 函数名: btrfs_item_ptr\n- 参数: [leaf, path->slots[0], struct btrfs_dev_item]\n- 调用者: btrfs_finish_sprout\n- 被调用者: 未显示\n\n8. 函数名: btrfs_device_id\n- 参数: [leaf, dev_item]\n- 调用者: btrfs_finish_sprout\n- 被调用者: 未显示\n\n9. 函数名: read_extent_buffer\n- 参数: [leaf, dev_uuid, btrfs_device_uuid(dev_item), BTRFS_UUID_SIZE]\n- 调用者: btrfs_finish_sprout\n- 被调用者: 未显示\n\n10. 函数名: read_extent_buffer\n- 参数: [leaf, fs_uuid, btrfs_device_fsid(dev_item), BTRFS_FSID_SIZE]\n- 调用者: btrfs_finish_sprout\n- 被调用者: 未显示\n\n11. 函数名: btrfs_find_device\n- 参数: [fs_info->fs_devices, devid, dev_uuid, fs_uuid]\n- 调用者: btrfs_finish_sprout\n- 被调用者: 未显示\n\n12. 函数名: btrfs_set_device_generation\n- 参数: [leaf, dev_item, device->generation]\n- 调用者: btrfs_finish_sprout\n- 被调用者: 未显示\n\n13. 函数名: btrfs_mark_buffer_dirty\n- 参数: [leaf]\n- 调用者: btrfs_finish_sprout\n- 被调用者: 未显示\n\n14. 函数名: btrfs_free_path\n- 参数: [path]\n- 调用者: btrfs_finish_sprout\n- 被调用者: 未显示"
    },
    {
        "id": 2119,
        "cwe": "CWE-476",
        "cve": "CVE-2019-18885",
        "purpose": "Code purpose:\"\"\"验证Btrfs文件系统中设备扩展(dev extent)的物理偏移和长度是否与对应的chunk匹配，并检查设备扩展是否超出设备边界\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在find_device函数中未正确处理fs_devices->devices为空的情况，导致空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: verify_one_dev_extent\n- 参数: [struct btrfs_fs_info *fs_info, u64 chunk_offset, u64 devid, u64 physical_offset, u64 physical_len]\n- 调用者: N/A (顶层函数)\n- 被调用者: [lookup_extent_mapping, calc_stripe_length, btrfs_find_device, find_device, free_extent_map]\n\n2. 函数名: lookup_extent_mapping\n- 参数: [struct extent_map_tree *em_tree, u64 chunk_offset, int 1]\n- 调用者: verify_one_dev_extent\n- 被调用者: N/A\n\n3. 函数名: calc_stripe_length\n- 参数: [map->type, em->len, map->num_stripes]\n- 调用者: verify_one_dev_extent\n- 被调用者: N/A\n\n4. 函数名: btrfs_find_device\n- 参数: [fs_info->fs_devices, devid, NULL, NULL]\n- 调用者: verify_one_dev_extent\n- 被调用者: N/A\n\n5. 函数名: find_device\n- 参数: [fs_info->fs_devices->seed, devid, NULL]\n- 调用者: verify_one_dev_extent\n- 被调用者: N/A\n\n6. 函数名: free_extent_map\n- 参数: [em]\n- 调用者: verify_one_dev_extent\n- 被调用者: N/A"
    },
    {
        "id": 2120,
        "cwe": "CWE-476",
        "cve": "CVE-2019-19036",
        "purpose": "Code purpose:\"\"\"验证Btrfs树块的级别和第一个键值是否匹配，确保树块数据的正确性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在btrfs_root_node函数中，未对rcu_dereference(root->node)返回的指针进行空指针检查，导致可能发生空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: btrfs_verify_level_key\n- 参数: [struct extent_buffer *eb, int level, struct btrfs_key *first_key, u64 parent_transid]\n- 调用者: 未明确显示（通常是Btrfs文件系统相关调用）\n- 被调用者: [btrfs_header_level, WARN, btrfs_err, btrfs_header_generation, btrfs_node_key_to_cpu, btrfs_item_key_to_cpu, btrfs_comp_cpu_keys]\n\n2. 函数名: btrfs_header_level\n- 参数: [struct extent_buffer *eb]\n- 调用者: btrfs_verify_level_key\n- 被调用者: 未显示\n\n3. 函数名: WARN\n- 参数: [IS_ENABLED(CONFIG_BTRFS_DEBUG), KERN_ERR \"BTRFS: tree level check failed\\n\"]\n- 调用者: btrfs_verify_level_key\n- 被调用者: 未显示\n\n4. 函数名: btrfs_err\n- 参数: [struct btrfs_fs_info *fs_info, \"tree level mismatch detected, bytenr=%llu level expected=%u has=%u\", eb->start, level, found_level]\n- 调用者: btrfs_verify_level_key\n- 被调用者: 未显示\n\n5. 函数名: btrfs_header_generation\n- 参数: [struct extent_buffer *eb]\n- 调用者: btrfs_verify_level_key\n- 被调用者: 未显示\n\n6. 函数名: btrfs_node_key_to_cpu\n- 参数: [struct extent_buffer *eb, struct btrfs_key *found_key, 0]\n- 调用者: btrfs_verify_level_key\n- 被调用者: 未显示\n\n7. 函数名: btrfs_item_key_to_cpu\n- 参数: [struct extent_buffer *eb, struct btrfs_key *found_key, 0]\n- 调用者: btrfs_verify_level_key\n- 被调用者: 未显示\n\n8. 函数名: btrfs_comp_cpu_keys\n- 参数: [struct btrfs_key *first_key, struct btrfs_key *found_key]\n- 调用者: btrfs_verify_level_key\n- 被调用者: 未显示"
    },
    {
        "id": 2121,
        "cwe": "CWE-476",
        "cve": "CVE-2019-19036",
        "purpose": "Code purpose:\"\"\"检查Btrfs文件系统中叶子节点的有效性和一致性，包括键顺序、项偏移和大小、项内容等，确保叶子节点数据结构的正确性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核的btrfs文件系统中，由于未对rcu_dereference(root->node)返回的NULL指针进行有效检查，导致空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: check_leaf\n- 参数: [struct extent_buffer *leaf, bool check_item_data]\n- 调用者: 未显示\n- 被调用者: [generic_err, btrfs_header_nritems, btrfs_header_level, btrfs_header_flag, btrfs_header_owner, btrfs_item_key_to_cpu, btrfs_comp_cpu_keys, btrfs_item_offset_nr, btrfs_item_end_nr, btrfs_item_nr_offset, btrfs_item_ptr_offset, check_leaf_item]\n\n2. 函数名: generic_err\n- 参数: [struct extent_buffer *leaf, int slot, const char *fmt, ...]\n- 调用者: check_leaf\n- 被调用者: 未显示\n\n3. 函数名: btrfs_header_nritems\n- 参数: [struct extent_buffer *leaf]\n- 调用者: check_leaf\n- 被调用者: 未显示\n\n4. 函数名: btrfs_header_level\n- 参数: [struct extent_buffer *leaf]\n- 调用者: check_leaf\n- 被调用者: 未显示\n\n5. 函数名: btrfs_header_flag\n- 参数: [struct extent_buffer *leaf, int flag]\n- 调用者: check_leaf\n- 被调用者: 未显示\n\n6. 函数名: btrfs_header_owner\n- 参数: [struct extent_buffer *leaf]\n- 调用者: check_leaf\n- 被调用者: 未显示\n\n7. 函数名: btrfs_item_key_to_cpu\n- 参数: [struct extent_buffer *leaf, struct btrfs_key *key, int slot]\n- 调用者: check_leaf\n- 被调用者: 未显示\n\n8. 函数名: btrfs_comp_cpu_keys\n- 参数: [struct btrfs_key *k1, struct btrfs_key *k2]\n- 调用者: check_leaf\n- 被调用者: 未显示\n\n9. 函数名: btrfs_item_offset_nr\n- 参数: [struct extent_buffer *leaf, int slot]\n- 调用者: check_leaf\n- 被调用者: 未显示\n\n10. 函数名: btrfs_item_end_nr\n- 参数: [struct extent_buffer *leaf, int slot]\n- 调用者: check_leaf\n- 被调用者: 未显示\n\n11. 函数名: btrfs_item_nr_offset\n- 参数: [int slot]\n- 调用者: check_leaf\n- 被调用者: 未显示\n\n12. 函数名: btrfs_item_ptr_offset\n- 参数: [struct extent_buffer *leaf, int slot]\n- 调用者: check_leaf\n- 被调用者: 未显示\n\n13. 函数名: check_leaf_item\n- 参数: [struct extent_buffer *leaf, struct btrfs_key *key, int slot, struct btrfs_key *prev_key]\n- 调用者: check_leaf\n- 被调用者: 未显示"
    },
    {
        "id": 2122,
        "cwe": "CWE-476",
        "cve": "CVE-2019-19037",
        "purpose": "Code purpose:\"\"\"检查ext4文件系统中的目录是否为空\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当ext4_read_dirblock(inode,0,DIRENT_HTREE)返回零时，代码未正确处理该情况，导致后续对bh->b_data的访问引发空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_empty_dir\n- 参数: [struct inode *inode]\n- 调用者: N/A (顶层函数)\n- 被调用者: [ext4_has_inline_data, empty_inline_dir, EXT4_ERROR_INODE, ext4_read_dirblock, le32_to_cpu, strcmp, ext4_warning_inode, brelse, ext4_rec_len_from_disk, ext4_next_entry, EXT4_BLOCK_SIZE_BITS, ext4_check_dir_entry]\n\n2. 函数名: ext4_has_inline_data\n- 参数: [struct inode *inode]\n- 调用者: ext4_empty_dir\n- 被调用者: []\n\n3. 函数名: empty_inline_dir\n- 参数: [struct inode *inode, int *has_inline_data]\n- 调用者: ext4_empty_dir\n- 被调用者: []\n\n4. 函数名: EXT4_ERROR_INODE\n- 参数: [struct inode *inode, const char *msg]\n- 调用者: ext4_empty_dir\n- 被调用者: []\n\n5. 函数名: ext4_read_dirblock\n- 参数: [struct inode *inode, unsigned int block, int dir_type]\n- 调用者: ext4_empty_dir\n- 被调用者: []\n\n6. 函数名: le32_to_cpu\n- 参数: [__le32 val]\n- 调用者: ext4_empty_dir\n- 被调用者: []\n\n7. 函数名: strcmp\n- 参数: [const char *s1, const char *s2]\n- 调用者: ext4_empty_dir\n- 被调用者: []\n\n8. 函数名: ext4_warning_inode\n- 参数: [struct inode *inode, const char *msg]\n- 调用者: ext4_empty_dir\n- 被调用者: []\n\n9. 函数名: brelse\n- 参数: [struct buffer_head *bh]\n- 调用者: ext4_empty_dir\n- 被调用者: []\n\n10. 函数名: ext4_rec_len_from_disk\n- 参数: [__le16 rec_len, unsigned int blocksize]\n- 调用者: ext4_empty_dir\n- 被调用者: []\n\n11. 函数名: ext4_next_entry\n- 参数: [struct ext4_dir_entry_2 *p, unsigned int blocksize]\n- 调用者: ext4_empty_dir\n- 被调用者: []\n\n12. 函数名: EXT4_BLOCK_SIZE_BITS\n- 参数: [struct super_block *sb]\n- 调用者: ext4_empty_dir\n- 被调用者: []\n\n13. 函数名: ext4_check_dir_entry\n- 参数: [struct inode *dir, struct file *filp, struct ext4_dir_entry_2 *de, struct buffer_head *bh, void *buf, int size, unsigned int offset]\n- 调用者: ext4_empty_dir\n- 被调用者: []"
    },
    {
        "id": 2177,
        "cwe": "CWE-476",
        "cve": "CVE-2019-19227",
        "purpose": "Code purpose:\"\"\"初始化AppleTalk地址解析协议(AARP)，注册SNAP客户端并设置定时器和网络设备通知器\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当register_snap_client返回NULL时未进行有效检查，导致后续可能对空指针进行解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: aarp_proto_init\n- 参数: []\n- 调用者: 无（初始化函数）\n- 被调用者: [register_snap_client, printk, timer_setup, add_timer, register_netdevice_notifier]\n\n2. 函数名: register_snap_client\n- 参数: [aarp_snap_id, aarp_rcv]\n- 调用者: aarp_proto_init\n- 被调用者: 无（假设为内核API）\n\n3. 函数名: printk\n- 参数: [KERN_CRIT, \"Unable to register AARP with SNAP.\\n\"]\n- 调用者: aarp_proto_init\n- 被调用者: 无（内核日志函数）\n\n4. 函数名: timer_setup\n- 参数: [&aarp_timer, aarp_expire_timeout, 0]\n- 调用者: aarp_proto_init\n- 被调用者: 无（内核定时器API）\n\n5. 函数名: add_timer\n- 参数: [&aarp_timer]\n- 调用者: aarp_proto_init\n- 被调用者: 无（内核定时器API）\n\n6. 函数名: register_netdevice_notifier\n- 参数: [&aarp_notifier]\n- 调用者: aarp_proto_init\n- 被调用者: 无（内核网络设备API）"
    },
    {
        "id": 2178,
        "cwe": "CWE-476",
        "cve": "CVE-2019-19227",
        "purpose": "Code purpose:\"\"\"初始化AppleTalk网络子系统并注册相关协议和处理程序\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核的AppleTalk子系统中，register_snap_client可能返回NULL，但后续代码未对此情况进行充分检查，导致潜在的NULL指针解引用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: atalk_init\n- 参数: [void]\n- 调用者: N/A (module initialization)\n- 被调用者: [proto_register, sock_register, register_snap_client, printk, dev_add_pack, register_netdevice_notifier, aarp_proto_init, atalk_proc_init, atalk_register_sysctl, atalk_proc_exit, aarp_cleanup_module, unregister_netdevice_notifier, dev_remove_pack, unregister_snap_client, sock_unregister, proto_unregister]\n\n2. 函数名: proto_register\n- 参数: [&ddp_proto, 0]\n- 调用者: atalk_init\n- 被调用者: []\n\n3. 函数名: sock_register\n- 参数: [&atalk_family_ops]\n- 调用者: atalk_init\n- 被调用者: []\n\n4. 函数名: register_snap_client\n- 参数: [ddp_snap_id, atalk_rcv]\n- 调用者: atalk_init\n- 被调用者: []\n\n5. 函数名: printk\n- 参数: [atalk_err_snap]\n- 调用者: atalk_init\n- 被调用者: []\n\n6. 函数名: dev_add_pack\n- 参数: [&ltalk_packet_type]\n- 调用者: atalk_init\n- 被调用者: []\n\n7. 函数名: dev_add_pack\n- 参数: [&ppptalk_packet_type]\n- 调用者: atalk_init\n- 被调用者: []\n\n8. 函数名: register_netdevice_notifier\n- 参数: [&ddp_notifier]\n- 调用者: atalk_init\n- 被调用者: []\n\n9. 函数名: aarp_proto_init\n- 参数: []\n- 调用者: atalk_init\n- 被调用者: []\n\n10. 函数名: atalk_proc_init\n- 参数: []\n- 调用者: atalk_init\n- 被调用者: []\n\n11. 函数名: atalk_register_sysctl\n- 参数: []\n- 调用者: atalk_init\n- 被调用者: []\n\n12. 函数名: atalk_proc_exit\n- 参数: []\n- 调用者: atalk_init\n- 被调用者: []\n\n13. 函数名: aarp_cleanup_module\n- 参数: []\n- 调用者: atalk_init\n- 被调用者: []\n\n14. 函数名: unregister_netdevice_notifier\n- 参数: [&ddp_notifier]\n- 调用者: atalk_init\n- 被调用者: []\n\n15. 函数名: dev_remove_pack\n- 参数: [&ppptalk_packet_type]\n- 调用者: atalk_init\n- 被调用者: []\n\n16. 函数名: dev_remove_pack\n- 参数: [&ltalk_packet_type]\n- 调用者: atalk_init\n- 被调用者: []\n\n17. 函数名: unregister_snap_client\n- 参数: [ddp_dl]\n- 调用者: atalk_init\n- 被调用者: []\n\n18. 函数名: sock_unregister\n- 参数: [PF_APPLETALK]\n- 调用者: atalk_init\n- 被调用者: []\n\n19. 函数名: proto_unregister\n- 参数: [&ddp_proto]\n- 调用者: atalk_init\n- 被调用者: []"
    },
    {
        "id": 2197,
        "cwe": "CWE-476",
        "cve": "CVE-2019-19462",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中创建和管理relay通道，实现CPU间的数据缓冲和传输功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在relay_open函数中，未检查alloc_percpu分配内存是否成功，导致当分配失败返回NULL时，后续操作可能引发拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: relay_open\n- 参数: [base_filename, parent, subbuf_size, n_subbufs, cb, private_data]\n- 调用者: N/A (kernel-level function)\n- 被调用者: [kzalloc, alloc_percpu, PAGE_ALIGN, strlcpy, setup_callbacks, kref_init, mutex_lock, for_each_online_cpu, relay_open_buf, per_cpu_ptr, list_add, mutex_unlock, for_each_possible_cpu, relay_close_buf, kref_put, relay_destroy_channel]\n\n2. 函数名: relay_open_buf\n- 参数: [chan, i]\n- 调用者: relay_open\n- 被调用者: N/A (implied but not shown in snippet)\n\n3. 函数名: relay_close_buf\n- 参数: [buf]\n- 调用者: relay_open\n- 被调用者: N/A (implied but not shown in snippet)\n\n4. 函数名: relay_destroy_channel\n- 参数: N/A (implied by kref_put usage)\n- 调用者: relay_open (via kref_put)\n- 被调用者: N/A (implied but not shown in snippet)\n\n5. 函数名: setup_callbacks\n- 参数: [chan, cb]\n- 调用者: relay_open\n- 被调用者: N/A (implied but not shown in snippet)\n\n6. 函数名: kzalloc\n- 参数: [sizeof(struct rchan), GFP_KERNEL]\n- 调用者: relay_open\n- 被调用者: N/A (kernel memory allocation function)\n\n7. 函数名: alloc_percpu\n- 参数: [struct rchan_buf *]\n- 调用者: relay_open\n- 被调用者: N/A (kernel memory allocation function)\n\n8. 函数名: strlcpy\n- 参数: [chan->base_filename, base_filename, NAME_MAX]\n- 调用者: relay_open\n- 被调用者: N/A (string operation function)\n\n9. 函数名: kref_init\n- 参数: [&chan->kref]\n- 调用者: relay_open\n- 被调用者: N/A (kernel reference counting function)\n\n10. 函数名: mutex_lock\n- 参数: [&relay_channels_mutex]\n- 调用者: relay_open\n- 被调用者: N/A (kernel synchronization function)\n\n11. 函数名: mutex_unlock\n- 参数: [&relay_channels_mutex]\n- 调用者: relay_open\n- 被调用者: N/A (kernel synchronization function)\n\n12. 函数名: list_add\n- 参数: [&chan->list, &relay_channels]\n- 调用者: relay_open\n- 被调用者: N/A (kernel list operation function)\n\n13. 函数名: kref_put\n- 参数: [&chan->kref, relay_destroy_channel]\n- 调用者: relay_open\n- 被调用者: [relay_destroy_channel]"
    },
    {
        "id": 2248,
        "cwe": "CWE-476",
        "cve": "CVE-2019-19815",
        "purpose": "Code purpose:\"\"\"该代码用于根据页面映射关系判断并返回F2FS文件系统中页面的读取类型（元数据、节点或数据）。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当page->mapping为NULL时，代码未进行有效检查导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: __read_io_type\n- 参数: [struct page *page]\n- 调用者: 未在代码片段中显示\n- 被调用者: [F2FS_I_SB]\n\n2. 函数名: F2FS_I_SB\n- 参数: [struct inode *inode]\n- 调用者: __read_io_type\n- 被调用者: 未在代码片段中显示"
    },
    {
        "id": 2249,
        "cwe": "CWE-476",
        "cve": "CVE-2019-19815",
        "purpose": "Code purpose:\"\"\"该代码用于处理F2FS文件系统中单个页面的读取操作，包括映射块、验证块地址、处理BIO提交以及处理超出EOF的情况\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在尝试恢复fsync数据时，由于未正确处理空指针情况，导致对空指针进行解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: f2fs_read_single_page\n- 参数: [inode, page, nr_pages, map, bio_ret, last_block_in_bio, is_readahead]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [i_size_read, f2fs_map_blocks, cleancache_get_page, f2fs_is_valid_blkaddr, zero_user_segment, __same_bdev, __submit_bio, f2fs_grab_read_bio, f2fs_wait_on_block_writeback, bio_add_page, inc_page_count]\n\n2. 函数名: i_size_read\n- 参数: [inode]\n- 调用者: f2fs_read_single_page\n- 被调用者: []\n\n3. 函数名: f2fs_map_blocks\n- 参数: [inode, map, 0, F2FS_GET_BLOCK_DEFAULT]\n- 调用者: f2fs_read_single_page\n- 被调用者: []\n\n4. 函数名: cleancache_get_page\n- 参数: [page]\n- 调用者: f2fs_read_single_page\n- 被调用者: []\n\n5. 函数名: f2fs_is_valid_blkaddr\n- 参数: [F2FS_I_SB(inode), block_nr, DATA_GENERIC_ENHANCE_READ]\n- 调用者: f2fs_read_single_page\n- 被调用者: []\n\n6. 函数名: zero_user_segment\n- 参数: [page, 0, PAGE_SIZE]\n- 调用者: f2fs_read_single_page\n- 被调用者: []\n\n7. 函数名: __same_bdev\n- 参数: [F2FS_I_SB(inode), block_nr, bio]\n- 调用者: f2fs_read_single_page\n- 被调用者: []\n\n8. 函数名: __submit_bio\n- 参数: [F2FS_I_SB(inode), bio, DATA]\n- 调用者: f2fs_read_single_page\n- 被调用者: []\n\n9. 函数名: f2fs_grab_read_bio\n- 参数: [inode, block_nr, nr_pages, is_readahead ? REQ_RAHEAD : 0]\n- 调用者: f2fs_read_single_page\n- 被调用者: []\n\n10. 函数名: f2fs_wait_on_block_writeback\n- 参数: [inode, block_nr]\n- 调用者: f2fs_read_single_page\n- 被调用者: []\n\n11. 函数名: bio_add_page\n- 参数: [bio, page, blocksize, 0]\n- 调用者: f2fs_read_single_page\n- 被调用者: []\n\n12. 函数名: inc_page_count\n- 参数: [F2FS_I_SB(inode), F2FS_RD_DATA]\n- 调用者: f2fs_read_single_page\n- 被调用者: []"
    },
    {
        "id": 2250,
        "cwe": "CWE-476",
        "cve": "CVE-2019-19815",
        "purpose": "Code purpose:\"\"\"该代码片段的功能是处理F2FS文件系统中数据页的脏页标记和原子写入状态管理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在f2fs_set_data_page_dirty函数中，未对page->mapping指针进行空指针检查，可能导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: f2fs_set_data_page_dirty\n- 参数: [struct page *page]\n- 调用者: 未明确（通常是文件系统操作调用）\n- 被调用者: [PageUptodate, SetPageUptodate, f2fs_is_atomic_file, f2fs_is_commit_atomic_write, IS_ATOMIC_WRITTEN_PAGE, f2fs_register_inmem_page, PageDirty, __set_page_dirty_nobuffers, f2fs_update_dirty_page]\n\n2. 函数名: PageUptodate\n- 参数: [struct page *page]\n- 调用者: f2fs_set_data_page_dirty\n- 被调用者: []\n\n3. 函数名: SetPageUptodate\n- 参数: [struct page *page]\n- 调用者: f2fs_set_data_page_dirty\n- 被调用者: []\n\n4. 函数名: f2fs_is_atomic_file\n- 参数: [struct inode *inode]\n- 调用者: f2fs_set_data_page_dirty\n- 被调用者: []\n\n5. 函数名: f2fs_is_commit_atomic_write\n- 参数: [struct inode *inode]\n- 调用者: f2fs_set_data_page_dirty\n- 被调用者: []\n\n6. 函数名: IS_ATOMIC_WRITTEN_PAGE\n- 参数: [struct page *page]\n- 调用者: f2fs_set_data_page_dirty\n- 被调用者: []\n\n7. 函数名: f2fs_register_inmem_page\n- 参数: [struct inode *inode, struct page *page]\n- 调用者: f2fs_set_data_page_dirty\n- 被调用者: []\n\n8. 函数名: PageDirty\n- 参数: [struct page *page]\n- 调用者: f2fs_set_data_page_dirty\n- 被调用者: []\n\n9. 函数名: __set_page_dirty_nobuffers\n- 参数: [struct page *page]\n- 调用者: f2fs_set_data_page_dirty\n- 被调用者: []\n\n10. 函数名: f2fs_update_dirty_page\n- 参数: [struct inode *inode, struct page *page]\n- 调用者: f2fs_set_data_page_dirty\n- 被调用者: []"
    },
    {
        "id": 2251,
        "cwe": "CWE-476",
        "cve": "CVE-2019-19815",
        "purpose": "Code purpose:\"\"\"该代码片段实现了F2FS文件系统中多页读取功能，处理页面缓存和生物块提交，用于从存储设备读取多个页面数据\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核5.0.21中，挂载特制的f2fs文件系统镜像时，由于未正确处理空指针情况，导致在f2fs_recover_fsync_data函数中发生空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: f2fs_mpage_readpages\n- 参数: [struct address_space *mapping, struct list_head *pages, struct page *page, unsigned nr_pages, bool is_readahead]\n- 调用者: 未显示（由文件系统调用）\n- 被调用者: [prefetchw, list_last_entry, list_del, add_to_page_cache_lru, f2fs_read_single_page, SetPageError, zero_user_segment, unlock_page, put_page, __submit_bio]\n\n2. 函数名: prefetchw\n- 参数: [&page->flags]\n- 调用者: f2fs_mpage_readpages\n- 被调用者: []\n\n3. 函数名: list_last_entry\n- 参数: [pages, struct page, lru]\n- 调用者: f2fs_mpage_readpages\n- 被调用者: []\n\n4. 函数名: list_del\n- 参数: [&page->lru]\n- 调用者: f2fs_mpage_readpages\n- 被调用者: []\n\n5. 函数名: add_to_page_cache_lru\n- 参数: [page, mapping, page->index, readahead_gfp_mask(mapping)]\n- 调用者: f2fs_mpage_readpages\n- 被调用者: []\n\n6. 函数名: f2fs_read_single_page\n- 参数: [inode, page, nr_pages, &map, &bio, &last_block_in_bio, is_readahead]\n- 调用者: f2fs_mpage_readpages\n- 被调用者: []\n\n7. 函数名: SetPageError\n- 参数: [page]\n- 调用者: f2fs_mpage_readpages\n- 被调用者: []\n\n8. 函数名: zero_user_segment\n- 参数: [page, 0, PAGE_SIZE]\n- 调用者: f2fs_mpage_readpages\n- 被调用者: []\n\n9. 函数名: unlock_page\n- 参数: [page]\n- 调用者: f2fs_mpage_readpages\n- 被调用者: []\n\n10. 函数名: put_page\n- 参数: [page]\n- 调用者: f2fs_mpage_readpages\n- 被调用者: []\n\n11. 函数名: __submit_bio\n- 参数: [F2FS_I_SB(inode), bio, DATA]\n- 调用者: f2fs_mpage_readpages\n- 被调用者: []\n\n12. 函数名: readahead_gfp_mask\n- 参数: [mapping]\n- 调用者: add_to_page_cache_lru (通过参数传递)\n- 被调用者: []"
    },
    {
        "id": 2252,
        "cwe": "CWE-476",
        "cve": "CVE-2019-19815",
        "purpose": "Code purpose:\"\"\"该代码片段实现了F2FS文件系统中读取数据页的功能，包括处理内联数据和普通数据页的读取\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在f2fs文件系统恢复过程中，由于未正确处理空指针引用导致内核崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: f2fs_read_data_page\n- 参数: [file, page]\n- 调用者: 未显示（由文件系统操作调用）\n- 被调用者: [f2fs_has_inline_data, f2fs_read_inline_data, f2fs_mpage_readpages]\n\n2. 函数名: f2fs_has_inline_data\n- 参数: [inode]\n- 调用者: f2fs_read_data_page\n- 被调用者: 未显示\n\n3. 函数名: f2fs_read_inline_data\n- 参数: [inode, page]\n- 调用者: f2fs_read_data_page\n- 被调用者: 未显示\n\n4. 函数名: f2fs_mpage_readpages\n- 参数: [page->mapping, NULL, page, 1, false]\n- 调用者: f2fs_read_data_page\n- 被调用者: 未显示"
    },
    {
        "id": 2253,
        "cwe": "CWE-476",
        "cve": "CVE-2019-19815",
        "purpose": "Code purpose:\"\"\"该代码片段定义了一个内联函数F2FS_P_SB，用于通过页面结构获取对应的f2fs超级块信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对page->mapping进行空指针检查，导致在访问空指针映射时引发空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: F2FS_P_SB\n- 参数: [struct page *page]\n- 调用者: f2fs_recover_fsync_data (根据漏洞描述)\n- 被调用者: [F2FS_M_SB]\n\n2. 函数名: F2FS_M_SB\n- 参数: [struct address_space *mapping]\n- 调用者: F2FS_P_SB\n- 被调用者: []"
    },
    {
        "id": 2254,
        "cwe": "CWE-476",
        "cve": "CVE-2019-19815",
        "purpose": "Code purpose:\"\"\"该代码用于判断在F2FS文件系统中是否强制使用缓冲I/O而非直接I/O，基于多种条件如设备类型、挂载选项和I/O特性等\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核5.0.21中，挂载特制的f2fs文件系统镜像时，由于未正确处理F2FS_P_SB指针导致的空指针解引用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: f2fs_force_buffered_io\n- 参数: [struct inode *inode, struct kiocb *iocb, struct iov_iter *iter]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [F2FS_I_SB, iov_iter_rw, f2fs_post_read_required, f2fs_is_multi_device, f2fs_sb_has_blkzoned, test_opt, block_unaligned_IO, is_sbi_flag_set]\n\n2. 函数名: F2FS_I_SB\n- 参数: [struct inode *inode]\n- 调用者: f2fs_force_buffered_io\n- 被调用者: 未明确\n\n3. 函数名: iov_iter_rw\n- 参数: [struct iov_iter *iter]\n- 调用者: f2fs_force_buffered_io\n- 被调用者: 未明确\n\n4. 函数名: f2fs_post_read_required\n- 参数: [struct inode *inode]\n- 调用者: f2fs_force_buffered_io\n- 被调用者: 未明确\n\n5. 函数名: f2fs_is_multi_device\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_force_buffered_io\n- 被调用者: 未明确\n\n6. 函数名: f2fs_sb_has_blkzoned\n- 参数: [struct f2fs_sb_info *sbi]\n- 调用者: f2fs_force_buffered_io\n- 被调用者: 未明确\n\n7. 函数名: test_opt\n- 参数: [struct f2fs_sb_info *sbi, LFS]\n- 调用者: f2fs_force_buffered_io\n- 被调用者: 未明确\n\n8. 函数名: block_unaligned_IO\n- 参数: [struct inode *inode, struct kiocb *iocb, struct iov_iter *iter]\n- 调用者: f2fs_force_buffered_io\n- 被调用者: 未明确\n\n9. 函数名: is_sbi_flag_set\n- 参数: [struct f2fs_sb_info *sbi, SBI_CP_DISABLED]\n- 调用者: f2fs_force_buffered_io\n- 被调用者: 未明确"
    },
    {
        "id": 2269,
        "cwe": "CWE-476",
        "cve": "CVE-2019-19965",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理SAS(串行连接SCSI)端口的设备发现过程，包括设备类型识别、初始化和资源分配等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在端口断开连接期间处理发现过程时，由于PHY下线竞争条件导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: sas_get_port_device\n- 参数: [struct asd_sas_port *port]\n- 调用者: 未显示（外部调用）\n- 被调用者: [sas_alloc_device, sas_put_device, container_of, memcpy, sas_init_dev, sas_ata_init, sas_end_device_alloc, sas_expander_alloc, pr_warn, sas_fill_in_rphy, sas_hash_addr, sas_device_set_phy, get_device, dev_is_sata, list_add_tail, sas_phy_set_target]\n\n2. 函数名: sas_alloc_device\n- 参数: []\n- 调用者: sas_get_port_device\n- 被调用者: []\n\n3. 函数名: sas_put_device\n- 参数: [struct domain_device *dev]\n- 调用者: sas_get_port_device\n- 被调用者: []\n\n4. 函数名: container_of\n- 参数: [port->phy_list.next, struct asd_sas_phy, port_phy_el]\n- 调用者: sas_get_port_device\n- 被调用者: []\n\n5. 函数名: memcpy\n- 参数: [dev->frame_rcvd, phy->frame_rcvd, min(sizeof(dev->frame_rcvd), (size_t)phy->frame_rcvd_size)]\n- 调用者: sas_get_port_device\n- 被调用者: []\n\n6. 函数名: sas_init_dev\n- 参数: [struct domain_device *dev]\n- 调用者: sas_get_port_device\n- 被调用者: []\n\n7. 函数名: sas_ata_init\n- 参数: [struct domain_device *dev]\n- 调用者: sas_get_port_device\n- 被调用者: []\n\n8. 函数名: sas_end_device_alloc\n- 参数: [port->port]\n- 调用者: sas_get_port_device\n- 被调用者: []\n\n9. 函数名: sas_expander_alloc\n- 参数: [port->port, SAS_EDGE_EXPANDER_DEVICE] 或 [port->port, SAS_FANOUT_EXPANDER_DEVICE]\n- 调用者: sas_get_port_device\n- 被调用者: []\n\n10. 函数名: pr_warn\n- 参数: [\"ERROR: Unidentified device type %d\", dev->dev_type]\n- 调用者: sas_get_port_device\n- 被调用者: []\n\n11. 函数名: sas_fill_in_rphy\n- 参数: [struct domain_device *dev, struct sas_rphy *rphy]\n- 调用者: sas_get_port_device\n- 被调用者: []\n\n12. 函数名: sas_hash_addr\n- 参数: [dev->hashed_sas_addr, dev->sas_addr]\n- 调用者: sas_get_port_device\n- 被调用者: []\n\n13. 函数名: sas_device_set_phy\n- 参数: [struct domain_device *dev, port->port]\n- 调用者: sas_get_port_device\n- 被调用者: []\n\n14. 函数名: get_device\n- 参数: [&dev->rphy->dev]\n- 调用者: sas_get_port_device\n- 被调用者: []\n\n15. 函数名: dev_is_sata\n- 参数: [struct domain_device *dev]\n- 调用者: sas_get_port_device\n- 被调用者: []\n\n16. 函数名: list_add_tail\n- 参数: [&dev->disco_list_node, &port->disco_list] 或 [&dev->dev_list_node, &port->dev_list]\n- 调用者: sas_get_port_device\n- 被调用者: []\n\n17. 函数名: sas_phy_set_target\n- 参数: [struct asd_sas_phy *phy, struct domain_device *dev]\n- 调用者: sas_get_port_device\n- 被调用者: []"
    },
    {
        "id": 2272,
        "cwe": "CWE-476",
        "cve": "CVE-2019-20054",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中释放sysctl表资源，包括减少引用计数、解除注册并在引用计数为零时释放内存。\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在drop_sysctl_table函数中，当header->nreg递减后不为零时直接返回，但后续操作可能在没有检查header是否有效的情况下被调用，导致空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: drop_sysctl_table\n- 参数: [struct ctl_table_header *header]\n- 调用者: drop_sysctl_table (递归调用)\n- 被调用者: [put_links, start_unregistering, kfree_rcu, drop_sysctl_table]\n\n2. 函数名: put_links\n- 参数: [struct ctl_table_header *header]\n- 调用者: drop_sysctl_table\n- 被调用者: []\n\n3. 函数名: start_unregistering\n- 参数: [struct ctl_table_header *header]\n- 调用者: drop_sysctl_table\n- 被调用者: []\n\n4. 函数名: kfree_rcu\n- 参数: [struct ctl_table_header *header, rcu]\n- 调用者: drop_sysctl_table\n- 被调用者: []"
    },
    {
        "id": 2283,
        "cwe": "CWE-476",
        "cve": "CVE-2019-20806",
        "purpose": "Code purpose:\"\"\"处理视频帧数据并进行H.264编码，包括帧校验、缓冲区管理、运动检测事件触发等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在tw5864_handle_frame函数中，对vb指针进行解引用后才检查其是否为NULL，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: tw5864_handle_frame\n- 参数: [struct tw5864_h264_frame *frame]\n- 调用者: 未显示（由内核调用）\n- 被调用者: [tw5864_vlc_checksum, dev_err, spin_lock_irqsave, spin_unlock_irqrestore, to_vb2_v4l2_buffer, dev_dbg, dev_err_once, vb2_set_plane_payload, vb2_plane_vaddr, tw5864_is_motion_triggered, v4l2_event_queue, vb2_buffer_done]\n\n2. 函数名: tw5864_vlc_checksum\n- 参数: [u32 *, int]\n- 调用者: tw5864_handle_frame\n- 被调用者: 未显示\n\n3. 函数名: dev_err\n- 参数: [struct device *, const char *, ...]\n- 调用者: tw5864_handle_frame\n- 被调用者: 未显示\n\n4. 函数名: spin_lock_irqsave\n- 参数: [spinlock_t *, unsigned long]\n- 调用者: tw5864_handle_frame\n- 被调用者: 未显示\n\n5. 函数名: spin_unlock_irqrestore\n- 参数: [spinlock_t *, unsigned long]\n- 调用者: tw5864_handle_frame\n- 被调用者: 未显示\n\n6. 函数名: to_vb2_v4l2_buffer\n- 参数: [struct vb2_buffer *]\n- 调用者: tw5864_handle_frame\n- 被调用者: 未显示\n\n7. 函数名: dev_dbg\n- 参数: [struct device *, const char *, ...]\n- 调用者: tw5864_handle_frame\n- 被调用者: 未显示\n\n8. 函数名: dev_err_once\n- 参数: [struct device *, const char *, ...]\n- 调用者: tw5864_handle_frame\n- 被调用者: 未显示\n\n9. 函数名: vb2_set_plane_payload\n- 参数: [struct vb2_buffer *, unsigned int, unsigned long]\n- 调用者: tw5864_handle_frame\n- 被调用者: 未显示\n\n10. 函数名: vb2_plane_vaddr\n- 参数: [struct vb2_buffer *, unsigned int]\n- 调用者: tw5864_handle_frame\n- 被调用者: 未显示\n\n11. 函数名: tw5864_is_motion_triggered\n- 参数: [struct tw5864_h264_frame *]\n- 调用者: tw5864_handle_frame\n- 被调用者: 未显示\n\n12. 函数名: v4l2_event_queue\n- 参数: [struct video_device *, struct v4l2_event *]\n- 调用者: tw5864_handle_frame\n- 被调用者: 未显示\n\n13. 函数名: vb2_buffer_done\n- 参数: [struct vb2_buffer *, enum vb2_buffer_state]\n- 调用者: tw5864_handle_frame\n- 被调用者: 未显示"
    },
    {
        "id": 2354,
        "cwe": "CWE-476",
        "cve": "CVE-2019-9213",
        "purpose": "Code purpose:\"\"\"该代码用于向下扩展虚拟内存区域(vma)，处理内存映射的地址检查和调整，确保内存区域的合法性和安全性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码在扩展向下内存区域时未检查mmap最小地址限制，导致可能利用内核空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: expand_downwards\n- 参数: [struct vm_area_struct *vma, unsigned long address]\n- 调用者: 未明确显示（通常是内核内存管理相关代码）\n- 被调用者: [security_mmap_addr, anon_vma_prepare, anon_vma_lock_write, acct_stack_growth, spin_lock, vm_stat_account, anon_vma_interval_tree_pre_update_vma, anon_vma_interval_tree_post_update_vma, vma_gap_update, spin_unlock, perf_event_mmap, anon_vma_unlock_write, khugepaged_enter_vma_merge, validate_mm]\n\n2. 函数名: security_mmap_addr\n- 参数: [unsigned long address]\n- 调用者: expand_downwards\n- 被调用者: []\n\n3. 函数名: anon_vma_prepare\n- 参数: [struct vm_area_struct *vma]\n- 调用者: expand_downwards\n- 被调用者: []\n\n4. 函数名: anon_vma_lock_write\n- 参数: [struct anon_vma *anon_vma]\n- 调用者: expand_downwards\n- 被调用者: []\n\n5. 函数名: acct_stack_growth\n- 参数: [struct vm_area_struct *vma, unsigned long size, unsigned long grow]\n- 调用者: expand_downwards\n- 被调用者: []\n\n6. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: expand_downwards\n- 被调用者: []\n\n7. 函数名: vm_stat_account\n- 参数: [struct mm_struct *mm, unsigned long flags, long pages]\n- 调用者: expand_downwards\n- 被调用者: []\n\n8. 函数名: anon_vma_interval_tree_pre_update_vma\n- 参数: [struct vm_area_struct *vma]\n- 调用者: expand_downwards\n- 被调用者: []\n\n9. 函数名: anon_vma_interval_tree_post_update_vma\n- 参数: [struct vm_area_struct *vma]\n- 调用者: expand_downwards\n- 被调用者: []\n\n10. 函数名: vma_gap_update\n- 参数: [struct vm_area_struct *vma]\n- 调用者: expand_downwards\n- 被调用者: []\n\n11. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: expand_downwards\n- 被调用者: []\n\n12. 函数名: perf_event_mmap\n- 参数: [struct vm_area_struct *vma]\n- 调用者: expand_downwards\n- 被调用者: []\n\n13. 函数名: anon_vma_unlock_write\n- 参数: [struct anon_vma *anon_vma]\n- 调用者: expand_downwards\n- 被调用者: []\n\n14. 函数名: khugepaged_enter_vma_merge\n- 参数: [struct vm_area_struct *vma, unsigned long vm_flags]\n- 调用者: expand_downwards\n- 被调用者: []\n\n15. 函数名: validate_mm\n- 参数: [struct mm_struct *mm]\n- 调用者: expand_downwards\n- 被调用者: []"
    },
    {
        "id": 2403,
        "cwe": "CWE-476",
        "cve": "CVE-2020-10711",
        "purpose": "Code purpose:\"\"\"解析CIPSO协议中的标签数据并将其转换为安全属性，用于SELinux的安全标记处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理CIPSO受限位图标签时，代码设置了安全属性标志表明类别位图存在，但实际上该位图可能未被分配，导致后续导入SELinux时出现空指针解引用问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: cipso_v4_parsetag_rng\n- 参数: [doi_def, tag, secattr]\n- 调用者: 未指定\n- 被调用者: [cipso_v4_map_lvl_ntoh, cipso_v4_map_cat_rng_ntoh, netlbl_catmap_free]\n\n2. 函数名: cipso_v4_map_lvl_ntoh\n- 参数: [doi_def, tag[3], &level]\n- 调用者: cipso_v4_parsetag_rng\n- 被调用者: 未指定\n\n3. 函数名: cipso_v4_map_cat_rng_ntoh\n- 参数: [doi_def, &tag[4], tag_len - 4, secattr]\n- 调用者: cipso_v4_parsetag_rng\n- 被调用者: 未指定\n\n4. 函数名: netlbl_catmap_free\n- 参数: [secattr->attr.mls.cat]\n- 调用者: cipso_v4_parsetag_rng\n- 被调用者: 未指定"
    },
    {
        "id": 2404,
        "cwe": "CWE-476",
        "cve": "CVE-2020-10711",
        "purpose": "Code purpose:\"\"\"该代码用于解析CIPSO协议中的受限位图标签，将安全级别和类别位图信息映射到SELinux的安全属性中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理CIPSO受限位图标签时，代码设置了安全属性标志表示类别位图存在，但未确保该位图已实际分配，导致后续导入操作中出现空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: cipso_v4_parsetag_rbm\n- 参数: [const struct cipso_v4_doi *doi_def, const unsigned char *tag, struct netlbl_lsm_secattr *secattr]\n- 调用者: 未指定\n- 被调用者: [cipso_v4_map_lvl_ntoh, cipso_v4_map_cat_rbm_ntoh, netlbl_catmap_free]\n\n2. 函数名: cipso_v4_map_lvl_ntoh\n- 参数: [const struct cipso_v4_doi *doi_def, u8 tag, u32 *level]\n- 调用者: cipso_v4_parsetag_rbm\n- 被调用者: 未指定\n\n3. 函数名: cipso_v4_map_cat_rbm_ntoh\n- 参数: [const struct cipso_v4_doi *doi_def, const unsigned char *tag, u8 tag_len, struct netlbl_lsm_secattr *secattr]\n- 调用者: cipso_v4_parsetag_rbm\n- 被调用者: 未指定\n\n4. 函数名: netlbl_catmap_free\n- 参数: [struct netlbl_lsm_secattr->attr.mls.cat]\n- 调用者: cipso_v4_parsetag_rbm\n- 被调用者: 未指定"
    },
    {
        "id": 2405,
        "cwe": "CWE-476",
        "cve": "CVE-2020-10711",
        "purpose": "Code purpose:\"\"\"该代码用于处理CALIPSO协议的安全属性获取，包括解析DOI、分类位图等操作，并将这些属性设置到网络安全标签中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理CIPSO受限位图标签时，代码设置了安全属性表明类别位图存在，但未实际分配该位图内存，导致后续导入SELinux时出现空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: calipso_opt_getattr\n- 参数: [const unsigned char *calipso, struct netlbl_lsm_secattr *secattr]\n- 调用者: 未指定\n- 被调用者: [calipso_cache_check, get_unaligned_be32, calipso_doi_search, calipso_map_cat_ntoh, netlbl_catmap_free]\n\n2. 函数名: calipso_cache_check\n- 参数: [const unsigned char *calipso + 2, calipso[1], struct netlbl_lsm_secattr *secattr]\n- 调用者: calipso_opt_getattr\n- 被调用者: 未指定\n\n3. 函数名: get_unaligned_be32\n- 参数: [const unsigned char *calipso + 2]\n- 调用者: calipso_opt_getattr\n- 被调用者: 未指定\n\n4. 函数名: calipso_doi_search\n- 参数: [u32 doi]\n- 调用者: calipso_opt_getattr\n- 被调用者: 未指定\n\n5. 函数名: calipso_map_cat_ntoh\n- 参数: [struct calipso_doi *doi_def, const unsigned char *calipso + 10, u32 cat_len, struct netlbl_lsm_secattr *secattr]\n- 调用者: calipso_opt_getattr\n- 被调用者: 未指定\n\n6. 函数名: netlbl_catmap_free\n- 参数: [secattr->attr.mls.cat]\n- 调用者: calipso_opt_getattr\n- 被调用者: 未指定"
    },
    {
        "id": 2406,
        "cwe": "CWE-476",
        "cve": "CVE-2020-10711",
        "purpose": "Code purpose:\"\"\"该代码用于从netlbl_lsm_catmap结构中获取指定偏移量处的位图值，并处理相关的对齐和边界检查\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理CIPSO受限位图标签时，即使未分配类别位图也设置了安全属性，导致后续导入SELinux时出现空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: netlbl_catmap_getlong\n- 参数: [struct netlbl_lsm_catmap *catmap, u32 *offset, unsigned long *bitmap]\n- 调用者: ebitmap_netlbl_import (根据漏洞描述推断)\n- 被调用者: [_netlbl_catmap_getnode]\n\n2. 函数名: _netlbl_catmap_getnode\n- 参数: [struct netlbl_lsm_catmap **catmap, u32 offset, int cm_flags, gfp_t flags]\n- 调用者: netlbl_catmap_getlong\n- 被调用者: [] (根据代码片段无法确定)"
    },
    {
        "id": 2427,
        "cwe": "CWE-476",
        "cve": "CVE-2020-11608",
        "purpose": "Code purpose:\"\"\"初始化OV518摄像头模式相关寄存器，包括设置数据包大小、输入输出格式、帧率等参数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当USB接口的替代设置(alt)中没有端点(endpoint)时，代码直接访问alt->endpoint[0]导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: ov518_mode_init_regs\n- 参数: [struct sd *sd]\n- 调用者: 未显示（外部调用）\n- 被调用者: [usb_ifnum_to_if, usb_altnum_to_altsetting, gspca_err, le16_to_cpu, ov518_reg_w32, reg_w, reg_w_mask, i2c_w]\n\n2. 函数名: usb_ifnum_to_if\n- 参数: [未显示完整参数]\n- 调用者: ov518_mode_init_regs\n- 被调用者: []\n\n3. 函数名: usb_altnum_to_altsetting\n- 参数: [struct usb_interface *intf, int altnum]\n- 调用者: ov518_mode_init_regs\n- 被调用者: []\n\n4. 函数名: gspca_err\n- 参数: [struct gspca_dev *gspca_dev, const char *msg]\n- 调用者: ov518_mode_init_regs\n- 被调用者: []\n\n5. 函数名: le16_to_cpu\n- 参数: [__le16]\n- 调用者: ov518_mode_init_regs\n- 被调用者: []\n\n6. 函数名: ov518_reg_w32\n- 参数: [struct sd *sd, u16 index, u32 value, int size]\n- 调用者: ov518_mode_init_regs\n- 被调用者: []\n\n7. 函数名: reg_w\n- 参数: [struct sd *sd, u8 index, u8 value]\n- 调用者: ov518_mode_init_regs\n- 被调用者: []\n\n8. 函数名: reg_w_mask\n- 参数: [struct sd *sd, u8 index, u8 value, u8 mask]\n- 调用者: ov518_mode_init_regs\n- 被调用者: []\n\n9. 函数名: i2c_w\n- 参数: [struct sd *sd, u8 reg, u8 value]\n- 调用者: ov518_mode_init_regs\n- 被调用者: []"
    },
    {
        "id": 2428,
        "cwe": "CWE-476",
        "cve": "CVE-2020-11608",
        "purpose": "Code purpose:\"\"\"初始化OV511摄像头模式并设置相关寄存器参数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当USB接口的alt设置中没有端点时，代码未检查alt->endpoint数组是否为空就直接访问其第一个元素，导致空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ov511_mode_init_regs\n- 参数: [struct sd *sd]\n- 调用者: 未显示（外部调用）\n- 被调用者: [usb_ifnum_to_if, usb_altnum_to_altsetting, le16_to_cpu, reg_w]\n\n2. 函数名: usb_ifnum_to_if\n- 参数: [sd->gspca_dev.dev, sd->gspca_dev.iface]\n- 调用者: ov511_mode_init_regs\n- 被调用者: 未显示（系统函数）\n\n3. 函数名: usb_altnum_to_altsetting\n- 参数: [intf, sd->gspca_dev.alt]\n- 调用者: ov511_mode_init_regs\n- 被调用者: 未显示（系统函数）\n\n4. 函数名: le16_to_cpu\n- 参数: [alt->endpoint[0].desc.wMaxPacketSize]\n- 调用者: ov511_mode_init_regs\n- 被调用者: 未显示（系统函数）\n\n5. 函数名: reg_w\n- 参数: [sd, R51x_FIFO_PSIZE, packet_size >> 5], [sd, R511_CAM_UV_EN, 0x01], [sd, R511_SNAP_UV_EN, 0x01], [sd, R511_SNAP_OPTS, 0x03], [sd, R511_CAM_PXCNT, hsegs], [sd, R511_CAM_LNCNT, vsegs], [sd, R511_CAM_PXDIV, 0x00], [sd, R511_CAM_LNDIV, 0x00], [sd, R511_CAM_OPTS, 0x03], [sd, R511_SNAP_PXCNT, hsegs], [sd, R511_SNAP_LNCNT, vsegs], [sd, R511_SNAP_PXDIV, 0x00], [sd, R511_SNAP_LNDIV, 0x00], [sd, R511_COMP_EN, 0x07], [sd, R511_COMP_LUT_EN, 0x03], [sd, R511_COMP_EN, 0x06], [sd, R511_COMP_LUT_EN, 0x00], [sd, R51x_SYS_RESET, OV511_RESET_OMNICE], [sd, R51x_SYS_RESET, 0]\n- 调用者: ov511_mode_init_regs\n- 被调用者: 未显示（设备驱动函数）"
    },
    {
        "id": 2429,
        "cwe": "CWE-476",
        "cve": "CVE-2020-11609",
        "purpose": "Code purpose:\"\"\"该代码用于协商USB摄像头的等时传输数据包大小，确保其不小于传感器要求的最小数据包大小。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未对usb_host_interface结构体指针alt及其成员进行空指针检查，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: stv06xx_isoc_nego\n- 参数: [struct gspca_dev *gspca_dev]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [le16_to_cpu, cpu_to_le16, usb_set_interface, gspca_err]\n\n2. 函数名: le16_to_cpu\n- 参数: [u16]\n- 调用者: stv06xx_isoc_nego\n- 被调用者: []\n\n3. 函数名: cpu_to_le16\n- 参数: [u16]\n- 调用者: stv06xx_isoc_nego\n- 被调用者: []\n\n4. 函数名: usb_set_interface\n- 参数: [struct usb_device *dev, int interface, int alternate]\n- 调用者: stv06xx_isoc_nego\n- 被调用者: []\n\n5. 函数名: gspca_err\n- 参数: [struct gspca_dev *gspca_dev, const char *fmt, ...]\n- 调用者: stv06xx_isoc_nego\n- 被调用者: []"
    },
    {
        "id": 2430,
        "cwe": "CWE-476",
        "cve": "CVE-2020-11609",
        "purpose": "Code purpose:\"\"\"该代码用于初始化USB摄像头的等时传输带宽，通过设置端点描述符中的最大包大小来协商带宽。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未对gspca_dev->dev->actconfig->intf_cache[0]进行空指针检查，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: stv06xx_isoc_init\n- 参数: [struct gspca_dev *gspca_dev]\n- 调用者: 未明确显示（通常由USB设备驱动框架调用）\n- 被调用者: [cpu_to_le16]\n\n2. 函数名: cpu_to_le16\n- 参数: [sd->sensor->max_packet_size[gspca_dev->curr_mode]]\n- 调用者: stv06xx_isoc_init\n- 被调用者: []"
    },
    {
        "id": 2431,
        "cwe": "CWE-476",
        "cve": "CVE-2020-11609",
        "purpose": "Code purpose:\"\"\"该代码用于启动STV06xx USB摄像头的视频流捕获功能，包括设置USB接口、配置数据包大小和启动传感器等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未对usb_ifnum_to_if()和usb_altnum_to_altsetting()返回的指针进行有效性检查，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: stv06xx_start\n- 参数: [struct gspca_dev *gspca_dev]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [usb_ifnum_to_if, usb_altnum_to_altsetting, le16_to_cpu, stv06xx_write_bridge, gspca_err, gspca_dbg]\n\n2. 函数名: usb_ifnum_to_if\n- 参数: [struct usb_device *dev, unsigned ifnum]\n- 调用者: stv06xx_start\n- 被调用者: 未显示（内核API）\n\n3. 函数名: usb_altnum_to_altsetting\n- 参数: [struct usb_interface *intf, unsigned int altsetting]\n- 调用者: stv06xx_start\n- 被调用者: 未显示（内核API）\n\n4. 函数名: le16_to_cpu\n- 参数: [__le16 val]\n- 调用者: stv06xx_start\n- 被调用者: 未显示（内核宏/函数）\n\n5. 函数名: stv06xx_write_bridge\n- 参数: [struct sd *sd, u16 address, u16 value]\n- 调用者: stv06xx_start\n- 被调用者: 未显示（外部函数）\n\n6. 函数名: gspca_err\n- 参数: [struct gspca_dev *gspca_dev, const char *fmt, ...]\n- 调用者: stv06xx_start\n- 被调用者: 未显示（外部函数）\n\n7. 函数名: gspca_dbg\n- 参数: [struct gspca_dev *gspca_dev, int level, const char *fmt, ...]\n- 调用者: stv06xx_start\n- 被调用者: 未显示（外部函数）"
    },
    {
        "id": 2432,
        "cwe": "CWE-476",
        "cve": "CVE-2020-11609",
        "purpose": "Code purpose:\"\"\"该代码用于初始化并启动STV06xx系列USB摄像头的传感器，配置传感器窗口模式和带宽设置，并处理可能的无效描述符情况。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未对usb_altnum_to_altsetting()返回的alt指针进行有效性检查，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: pb0100_start\n- 参数: [struct sd *sd]\n- 调用者: 未明确显示（应为外部调用）\n- 被调用者: [usb_ifnum_to_if, usb_altnum_to_altsetting, le16_to_cpu, stv06xx_write_sensor, gspca_dbg]\n\n2. 函数名: usb_ifnum_to_if\n- 参数: [struct usb_device *dev, unsigned ifnum]\n- 调用者: pb0100_start\n- 被调用者: []\n\n3. 函数名: usb_altnum_to_altsetting\n- 参数: [struct usb_interface *intf, unsigned int altnum]\n- 调用者: pb0100_start\n- 被调用者: []\n\n4. 函数名: le16_to_cpu\n- 参数: [__le16 val]\n- 调用者: pb0100_start\n- 被调用者: []\n\n5. 函数名: stv06xx_write_sensor\n- 参数: [struct sd *sd, u8 address, u8 value]\n- 调用者: pb0100_start\n- 被调用者: []\n\n6. 函数名: stv06xx_write_bridge\n- 参数: [struct sd *sd, u16 address, u16 value]\n- 调用者: pb0100_start\n- 被调用者: []\n\n7. 函数名: gspca_dbg\n- 参数: [struct gspca_dev *gspca_dev, int level, const char *fmt, ...]\n- 调用者: pb0100_start\n- 被调用者: []"
    },
    {
        "id": 2433,
        "cwe": "CWE-476",
        "cve": "CVE-2020-11668",
        "purpose": "Code purpose:\"\"\"该代码片段用于初始化Xirlink相机USB驱动中的等时传输带宽，根据图像宽度设置最大数据包大小并配置USB端点描述符。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理USB设备描述符时未对无效描述符进行充分验证，导致空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: sd_isoc_init\n- 参数: [struct gspca_dev *gspca_dev]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [cpu_to_le16]\n\n2. 函数名: cpu_to_le16\n- 参数: [max_packet_size]\n- 调用者: sd_isoc_init\n- 被调用者: 未显示（系统/库函数）"
    },
    {
        "id": 2434,
        "cwe": "CWE-476",
        "cve": "CVE-2020-11668",
        "purpose": "Code purpose:\"\"\"获取USB设备的端点描述符中的最大数据包大小\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未验证alt->endpoint数组是否存在就直接访问其第一个元素，导致空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: cit_get_packet_size\n- 参数: [struct gspca_dev *gspca_dev]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [usb_ifnum_to_if, usb_altnum_to_altsetting, pr_err, le16_to_cpu]\n\n2. 函数名: usb_ifnum_to_if\n- 参数: [struct usb_device *dev, unsigned ifnum]\n- 调用者: cit_get_packet_size\n- 被调用者: 未明确（内核USB核心函数）\n\n3. 函数名: usb_altnum_to_altsetting\n- 参数: [struct usb_interface *intf, unsigned int altsetting]\n- 调用者: cit_get_packet_size\n- 被调用者: 未明确（内核USB核心函数）\n\n4. 函数名: pr_err\n- 参数: [const char *fmt, ...]\n- 调用者: cit_get_packet_size\n- 被调用者: 未明确（内核打印函数）\n\n5. 函数名: le16_to_cpu\n- 参数: [__le16 val]\n- 调用者: cit_get_packet_size\n- 被调用者: 未明确（字节序转换宏/函数）"
    },
    {
        "id": 2435,
        "cwe": "CWE-476",
        "cve": "CVE-2020-11668",
        "purpose": "Code purpose:\"\"\"该代码用于协商USB摄像头的等时传输数据包大小，根据图像宽度设置最小包大小并调整USB接口设置。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未对USB描述符进行有效性验证，导致可能访问空指针或无效内存\"\"\"",
        "functions": "Functions:\n1. 函数名: sd_isoc_nego\n- 参数: [struct gspca_dev *gspca_dev]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [le16_to_cpu, cpu_to_le16, usb_set_interface, pr_err]\n\n2. 函数名: le16_to_cpu\n- 参数: [未显示（传入alt->endpoint[0].desc.wMaxPacketSize）]\n- 调用者: sd_isoc_nego\n- 被调用者: []\n\n3. 函数名: cpu_to_le16\n- 参数: [packet_size]\n- 调用者: sd_isoc_nego\n- 被调用者: []\n\n4. 函数名: usb_set_interface\n- 参数: [gspca_dev->dev, gspca_dev->iface, 1]\n- 调用者: sd_isoc_nego\n- 被调用者: []\n\n5. 函数名: pr_err\n- 参数: [\"set alt 1 err %d\\n\", ret]\n- 调用者: sd_isoc_nego\n- 被调用者: []"
    },
    {
        "id": 2464,
        "cwe": "CWE-476",
        "cve": "CVE-2020-12364",
        "purpose": "Code purpose:\"\"\"该代码用于在Intel图形驱动中设置和初始化特定引擎的结构体，包括分配内存、配置引擎属性、验证参数有效性以及建立引擎与全局结构的关系。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在intel_engine_setup函数中，未对engine指针进行空指针检查就直接访问其成员变量，可能导致空指针引用\"\"\"",
        "functions": "Functions:\n1. 函数名: intel_engine_setup\n- 参数: [struct intel_gt *gt, enum intel_engine_id id]\n- 调用者: 未显示\n- 被调用者: [GEM_DEBUG_WARN_ON, kzalloc, __engine_mmio_base, __sprint_engine_name, intel_engine_context_size, WARN_ON, DRIVER_CAPS, ewma__engine_latency_init, seqlock_init, ATOMIC_INIT_NOTIFIER_HEAD, intel_engine_sanitize_mmio]\n\n2. 函数名: GEM_DEBUG_WARN_ON\n- 参数: [条件表达式]\n- 调用者: intel_engine_setup\n- 被调用者: 未显示\n\n3. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: intel_engine_setup\n- 被调用者: 未显示\n\n4. 函数名: __engine_mmio_base\n- 参数: [struct drm_i915_private *i915, mmio_bases信息]\n- 调用者: intel_engine_setup\n- 被调用者: 未显示\n\n5. 函数名: __sprint_engine_name\n- 参数: [struct intel_engine_cs *engine]\n- 调用者: intel_engine_setup\n- 被调用者: 未显示\n\n6. 函数名: intel_engine_context_size\n- 参数: [struct intel_gt *gt, engine_class信息]\n- 调用者: intel_engine_setup\n- 被调用者: 未显示\n\n7. 函数名: WARN_ON\n- 参数: [条件表达式]\n- 调用者: intel_engine_setup\n- 被调用者: 未显示\n\n8. 函数名: DRIVER_CAPS\n- 参数: [struct drm_i915_private *i915]\n- 调用者: intel_engine_setup\n- 被调用者: 未显示\n\n9. 函数名: ewma__engine_latency_init\n- 参数: [engine->latency]\n- 调用者: intel_engine_setup\n- 被调用者: 未显示\n\n10. 函数名: seqlock_init\n- 参数: [engine->stats.lock]\n- 调用者: intel_engine_setup\n- 被调用者: 未显示\n\n11. 函数名: ATOMIC_INIT_NOTIFIER_HEAD\n- 参数: [engine->context_status_notifier]\n- 调用者: intel_engine_setup\n- 被调用者: 未显示\n\n12. 函数名: intel_engine_sanitize_mmio\n- 参数: [struct intel_engine_cs *engine]\n- 调用者: intel_engine_setup\n- 被调用者: 未显示"
    },
    {
        "id": 2465,
        "cwe": "CWE-476",
        "cve": "CVE-2020-12364",
        "purpose": "Code purpose:\"\"\"初始化Intel GuC（Graphics micro Controller）的控制参数并进行调试输出\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码中未对guc指针或guc->params进行空指针检查，可能导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: guc_init_params\n- 参数: [struct intel_guc *guc]\n- 调用者: 未显示\n- 被调用者: [guc_ctl_ctxinfo_flags, guc_ctl_log_params_flags, guc_ctl_feature_flags, guc_ctl_debug_flags, guc_ctl_ads_flags, DRM_DEBUG_DRIVER]\n\n2. 函数名: guc_ctl_ctxinfo_flags\n- 参数: [struct intel_guc *guc]\n- 调用者: guc_init_params\n- 被调用者: 未显示\n\n3. 函数名: guc_ctl_log_params_flags\n- 参数: [struct intel_guc *guc]\n- 调用者: guc_init_params\n- 被调用者: 未显示\n\n4. 函数名: guc_ctl_feature_flags\n- 参数: [struct intel_guc *guc]\n- 调用者: guc_init_params\n- 被调用者: 未显示\n\n5. 函数名: guc_ctl_debug_flags\n- 参数: [struct intel_guc *guc]\n- 调用者: guc_init_params\n- 被调用者: 未显示\n\n6. 函数名: guc_ctl_ads_flags\n- 参数: [struct intel_guc *guc]\n- 调用者: guc_init_params\n- 被调用者: 未显示"
    },
    {
        "id": 2466,
        "cwe": "CWE-476",
        "cve": "CVE-2020-12364",
        "purpose": "Code purpose:\"\"\"初始化Intel GuC (Graphics microController)的ADS(Additional Data Structures)数据结构，包括调度策略、引擎类上下文信息、系统信息和客户端信息等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码中对guc->ads_blob指针的解引用未进行空指针检查，可能导致空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: __guc_ads_init\n- 参数: [struct intel_guc *guc]\n- 调用者: 未显示\n- 被调用者: [guc_to_gt, guc_policies_init, intel_engine_context_size, hweight8, VDBOX_MASK, VEBOX_MASK, intel_guc_ggtt_offset, guc_ct_pool_entries_init, ptr_offset, i915_gem_object_flush_map]\n\n2. 函数名: guc_policies_init\n- 参数: [&blob->policies]\n- 调用者: __guc_ads_init\n- 被调用者: 未显示\n\n3. 函数名: guc_to_gt\n- 参数: [struct intel_guc *guc]\n- 调用者: __guc_ads_init\n- 被调用者: 未显示\n\n4. 函数名: intel_engine_context_size\n- 参数: [guc_to_gt(guc), engine_class]\n- 调用者: __guc_ads_init\n- 被调用者: 未显示\n\n5. 函数名: hweight8\n- 参数: [gt->info.sseu.slice_mask]\n- 调用者: __guc_ads_init\n- 被调用者: 未显示\n\n6. 函数名: VDBOX_MASK\n- 参数: [gt]\n- 调用者: __guc_ads_init\n- 被调用者: 未显示\n\n7. 函数名: VEBOX_MASK\n- 参数: [gt]\n- 调用者: __guc_ads_init\n- 被调用者: 未显示\n\n8. 函数名: intel_guc_ggtt_offset\n- 参数: [guc, guc->ads_vma]\n- 调用者: __guc_ads_init\n- 被调用者: 未显示\n\n9. 函数名: guc_ct_pool_entries_init\n- 参数: [blob->ct_pool, ARRAY_SIZE(blob->ct_pool)]\n- 调用者: __guc_ads_init\n- 被调用者: 未显示\n\n10. 函数名: ptr_offset\n- 参数: [blob, ct_pool], [blob, policies], [blob, reg_state_buffer], [blob, reg_state], [blob, system_info], [blob, clients_info]\n- 调用者: __guc_ads_init\n- 被调用者: 未显示\n\n11. 函数名: i915_gem_object_flush_map\n- 参数: [guc->ads_vma->obj]\n- 调用者: __guc_ads_init\n- 被调用者: 未显示"
    },
    {
        "id": 2467,
        "cwe": "CWE-476",
        "cve": "CVE-2020-12364",
        "purpose": "Code purpose:\"\"\"为Intel图形处理器中的GuC（Graphics micro Controller）分配和初始化广告服务数据结构\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在分配和映射虚拟内存区域时未正确处理空指针引用，导致特权用户可能通过本地访问造成拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: intel_guc_ads_create\n- 参数: [struct intel_guc *guc]\n- 调用者: 未显示\n- 被调用者: [PAGE_ALIGN, sizeof, GEM_BUG_ON, intel_guc_allocate_and_map_vma, __guc_ads_init]\n\n2. 函数名: PAGE_ALIGN\n- 参数: [sizeof(struct __guc_ads_blob)]\n- 调用者: intel_guc_ads_create\n- 被调用者: []\n\n3. 函数名: sizeof\n- 参数: [struct __guc_ads_blob]\n- 调用者: intel_guc_ads_create\n- 被调用者: []\n\n4. 函数名: GEM_BUG_ON\n- 参数: [guc->ads_vma]\n- 调用者: intel_guc_ads_create\n- 被调用者: []\n\n5. 函数名: intel_guc_allocate_and_map_vma\n- 参数: [guc, size, &guc->ads_vma, (void **)&guc->ads_blob]\n- 调用者: intel_guc_ads_create\n- 被调用者: []\n\n6. 函数名: __guc_ads_init\n- 参数: [guc]\n- 调用者: intel_guc_ads_create\n- 被调用者: []"
    },
    {
        "id": 2468,
        "cwe": "CWE-476",
        "cve": "CVE-2020-12364",
        "purpose": "Code purpose:\"\"\"初始化Intel GuC广告状态，若ads_vma为空则直接返回\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在检查guc->ads_vma为空指针后直接返回，而未对guc指针本身进行空值检查，可能导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: intel_guc_ads_reset\n- 参数: [guc]\n- 调用者: 未提供\n- 被调用者: [__guc_ads_init]\n\n2. 函数名: __guc_ads_init\n- 参数: [guc]\n- 调用者: [intel_guc_ads_reset]\n- 被调用者: 未提供"
    },
    {
        "id": 2469,
        "cwe": "CWE-476",
        "cve": "CVE-2020-12364",
        "purpose": "Code purpose:\"\"\"该代码用于从Intel图形驱动中获取并验证微控制器固件，包括检查固件大小、完整性、版本信息，并将其加载到内存中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Intel图形驱动程序中，由于未对指针进行充分的空指针检查，导致特权用户可能通过本地访问触发空指针解引用，从而造成拒绝服务漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: intel_uc_fw_fetch\n- 参数: [struct intel_uc_fw *uc_fw]\n- 调用者: 未显示（外部调用）\n- 被调用者: [__uc_fw_to_gt, intel_uc_fw_is_enabled, i915_inject_probe_error, __force_fw_fetch_failures, request_firmware, intel_uc_fw_type_repr, FIELD_GET, intel_uc_fw_is_overridden, i915_gem_object_create_shmem_from_data, intel_uc_fw_change_status, release_firmware, __intel_uc_fw_get_upload_size]\n\n2. 函数名: __uc_fw_to_gt\n- 参数: [struct intel_uc_fw *uc_fw]\n- 调用者: intel_uc_fw_fetch\n- 被调用者: 未显示\n\n3. 函数名: intel_uc_fw_is_enabled\n- 参数: [struct intel_uc_fw *uc_fw]\n- 调用者: intel_uc_fw_fetch\n- 被调用者: 未显示\n\n4. 函数名: i915_inject_probe_error\n- 参数: [struct drm_i915_private *i915, -ENXIO]\n- 调用者: intel_uc_fw_fetch\n- 被调用者: 未显示\n\n5. 函数名: __force_fw_fetch_failures\n- 参数: [struct intel_uc_fw *uc_fw, -EINVAL], [struct intel_uc_fw *uc_fw, -ESTALE]\n- 调用者: intel_uc_fw_fetch\n- 被调用者: 未显示\n\n6. 函数名: request_firmware\n- 参数: [const struct firmware **fw, uc_fw->path, dev]\n- 调用者: intel_uc_fw_fetch\n- 被调用者: 未显示\n\n7. 函数名: intel_uc_fw_type_repr\n- 参数: [uc_fw->type]\n- 调用者: intel_uc_fw_fetch\n- 被调用者: 未显示\n\n8. 函数名: FIELD_GET\n- 参数: [CSS_SW_VERSION_UC_MAJOR, css->sw_version], [CSS_SW_VERSION_UC_MINOR, css->sw_version]\n- 调用者: intel_uc_fw_fetch\n- 被调用者: 未显示\n\n9. 函数名: intel_uc_fw_is_overridden\n- 参数: [struct intel_uc_fw *uc_fw]\n- 调用者: intel_uc_fw_fetch\n- 被调用者: 未显示\n\n10. 函数名: i915_gem_object_create_shmem_from_data\n- 参数: [struct drm_i915_private *i915, fw->data, fw->size]\n- 调用者: intel_uc_fw_fetch\n- 被调用者: 未显示\n\n11. 函数名: intel_uc_fw_change_status\n- 参数: [struct intel_uc_fw *uc_fw, INTEL_UC_FIRMWARE_AVAILABLE], [struct intel_uc_fw *uc_fw, err == -ENOENT ? INTEL_UC_FIRMWARE_MISSING : INTEL_UC_FIRMWARE_ERROR]\n- 调用者: intel_uc_fw_fetch\n- 被调用者: 未显示\n\n12. 函数名: release_firmware\n- 参数: [const struct firmware *fw]\n- 调用者: intel_uc_fw_fetch\n- 被调用者: 未显示\n\n13. 函数名: __intel_uc_fw_get_upload_size\n- 参数: [struct intel_uc_fw *uc_fw]\n- 调用者: intel_uc_fw_fetch\n- 被调用者: 未显示"
    },
    {
        "id": 2515,
        "cwe": "CWE-476",
        "cve": "CVE-2020-14356",
        "purpose": "Code purpose:\"\"\"该代码用于安全地获取与socket关联的cgroup指针，处理32位和64位系统的兼容性问题，并提供默认cgroup指针作为回退\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在系统重启时，Linux内核cgroupv2子系统中存在空指针解引用漏洞，当处理sock_cgroup_ptr函数中的指针转换时，可能导致空指针被解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: sock_cgroup_ptr\n- 参数: [struct sock_cgroup_data *skcd]\n- 调用者: 未明确显示（通常是内核中处理socket cgroup相关的代码）\n- 被调用者: [READ_ONCE]"
    },
    {
        "id": 2516,
        "cwe": "CWE-476",
        "cve": "CVE-2020-14356",
        "purpose": "Code purpose:\"\"\"释放与套接字关联的cgroup资源，包括BPF相关资源和cgroup引用计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在系统重启时，Linux内核cgroupv2子系统中未正确处理空指针解引用，导致本地用户可利用此漏洞使系统崩溃或提升权限\"\"\"",
        "functions": "Functions:\n1. 函数名: cgroup_sk_free\n- 参数: [struct sock_cgroup_data *skcd]\n- 调用者: 未提供\n- 被调用者: [sock_cgroup_ptr, cgroup_bpf_put, cgroup_put]\n\n2. 函数名: sock_cgroup_ptr\n- 参数: [struct sock_cgroup_data *skcd]\n- 调用者: cgroup_sk_free\n- 被调用者: 未提供\n\n3. 函数名: cgroup_bpf_put\n- 参数: [struct cgroup *cgrp]\n- 调用者: cgroup_sk_free\n- 被调用者: 未提供\n\n4. 函数名: cgroup_put\n- 参数: [struct cgroup *cgrp]\n- 调用者: cgroup_sk_free\n- 被调用者: 未提供"
    },
    {
        "id": 2517,
        "cwe": "CWE-476",
        "cve": "CVE-2020-14356",
        "purpose": "Code purpose:\"\"\"该代码用于为套接字分配cgroup资源，处理套接字克隆和中断情况下的cgroup关联\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当系统重启时，Linux内核cgroupv2子系统中存在空指针解引用问题，导致本地用户可利用此漏洞使系统崩溃或提升权限\"\"\"",
        "functions": "Functions:\n1. 函数名: cgroup_sk_alloc\n- 参数: [struct sock_cgroup_data *skcd]\n- 调用者: 未明确显示（通常是内核中socket创建或克隆的相关代码）\n- 被调用者: [cgroup_get, sock_cgroup_ptr, cgroup_bpf_get, in_interrupt, rcu_read_lock, task_css_set, cgroup_tryget, cgroup_bpf_get, cpu_relax, rcu_read_unlock]\n\n2. 函数名: cgroup_get\n- 参数: [未明确显示，应为cgroup结构体指针]\n- 调用者: cgroup_sk_alloc\n- 被调用者: []\n\n3. 函数名: sock_cgroup_ptr\n- 参数: [struct sock_cgroup_data *skcd]\n- 调用者: cgroup_sk_alloc\n- 被调用者: []\n\n4. 函数名: cgroup_bpf_get\n- 参数: [未明确显示，应为cgroup结构体指针]\n- 调用者: cgroup_sk_alloc\n- 被调用者: []\n\n5. 函数名: in_interrupt\n- 参数: []\n- 调用者: cgroup_sk_alloc\n- 被调用者: []\n\n6. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: cgroup_sk_alloc\n- 被调用者: []\n\n7. 函数名: task_css_set\n- 参数: [struct task_struct *task]\n- 调用者: cgroup_sk_alloc\n- 被调用者: []\n\n8. 函数名: cgroup_tryget\n- 参数: [struct cgroup *cgrp]\n- 调用者: cgroup_sk_alloc\n- 被调用者: []\n\n9. 函数名: cpu_relax\n- 参数: []\n- 调用者: cgroup_sk_alloc\n- 被调用者: []\n\n10. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: cgroup_sk_alloc\n- 被调用者: []"
    },
    {
        "id": 2518,
        "cwe": "CWE-476",
        "cve": "CVE-2020-14356",
        "purpose": "Code purpose:\"\"\"该代码用于克隆并初始化一个新的socket结构体，复制原始socket的属性和配置，同时处理相关的内存分配和引用计数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核cgroupv2子系统中，当系统重启时存在空指针解引用问题，导致本地用户可能利用此漏洞使系统崩溃或提升权限\"\"\"",
        "functions": "Functions:\n1. 函数名: sk_clone_lock\n- 参数: [sk, priority]\n- 调用者: 未指定\n- 被调用者: [READ_ONCE, sk_prot_alloc, sock_copy, get_net, sock_net, sk_node_init, sock_lock_init, bh_lock_sock, atomic_set, refcount_set, sk_init_common, sock_reset_flag, cgroup_sk_alloc, rcu_read_lock, rcu_dereference, sk_filter_charge, RCU_INIT_POINTER, rcu_read_unlock, xfrm_sk_clone_policy, sk_free_unlock_clone, bpf_sk_storage_clone, sk_user_data_is_nocopy, raw_smp_processor_id, sock_inuse_add, smp_wmb, sk_refcnt_debug_inc, sk_set_socket, sk_tx_queue_clear, sk_sockets_allocated_inc, sock_needs_netstamp, net_enable_timestamp]\n\n2. 函数名: READ_ONCE\n- 参数: [sk->sk_prot]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n3. 函数名: sk_prot_alloc\n- 参数: [prot, priority, sk->sk_family]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n4. 函数名: sock_copy\n- 参数: [newsk, sk]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n5. 函数名: get_net\n- 参数: [sock_net(newsk)]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n6. 函数名: sock_net\n- 参数: [newsk]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n7. 函数名: sk_node_init\n- 参数: [&newsk->sk_node]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n8. 函数名: sock_lock_init\n- 参数: [newsk]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n9. 函数名: bh_lock_sock\n- 参数: [newsk]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n10. 函数名: atomic_set\n- 参数: [&newsk->sk_rmem_alloc, 0], [&newsk->sk_omem_alloc, 0], [&newsk->sk_drops, 0], [&newsk->sk_zckey, 0]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n11. 函数名: refcount_set\n- 参数: [&newsk->sk_wmem_alloc, 1], [&newsk->sk_refcnt, 2]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n12. 函数名: sk_init_common\n- 参数: [newsk]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n13. 函数名: sock_reset_flag\n- 参数: [newsk, SOCK_DONE]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n14. 函数名: cgroup_sk_alloc\n- 参数: [&newsk->sk_cgrp_data]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n15. 函数名: rcu_read_lock\n- 参数: 无\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n16. 函数名: rcu_dereference\n- 参数: [sk->sk_filter]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n17. 函数名: sk_filter_charge\n- 参数: [newsk, filter]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n18. 函数名: RCU_INIT_POINTER\n- 参数: [newsk->sk_filter, filter], [newsk->sk_filter, NULL], [newsk->sk_reuseport_cb, NULL], [newsk->sk_wq, NULL]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n19. 函数名: rcu_read_unlock\n- 参数: 无\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n20. 函数名: xfrm_sk_clone_policy\n- 参数: [newsk, sk]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n21. 函数名: sk_free_unlock_clone\n- 参数: [newsk]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n22. 函数名: bpf_sk_storage_clone\n- 参数: [sk, newsk]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n23. 函数名: sk_user_data_is_nocopy\n- 参数: [newsk]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n24. 函数名: raw_smp_processor_id\n- 参数: 无\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n25. 函数名: sock_inuse_add\n- 参数: [sock_net(newsk), 1]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n26. 函数名: smp_wmb\n- 参数: 无\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n27. 函数名: sk_refcnt_debug_inc\n- 参数: [newsk]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n28. 函数名: sk_set_socket\n- 参数: [newsk, NULL]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n29. 函数名: sk_tx_queue_clear\n- 参数: [newsk]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n30. 函数名: sk_sockets_allocated_inc\n- 参数: [newsk]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n31. 函数名: sock_needs_netstamp\n- 参数: [sk]\n- 调用者: sk_clone_lock\n- 被调用者: 未指定\n\n32. 函数名: net_enable_timestamp\n- 参数: 无\n- 调用者: sk_clone_lock\n- 被调用者: 未指定"
    },
    {
        "id": 2545,
        "cwe": "CWE-476",
        "cve": "CVE-2020-15437",
        "purpose": "Code purpose:\"\"\"初始化8250串行端口的ISA总线相关参数和配置\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在serial8250_isa_init_ports()函数中，未初始化p->serial_in指针就进行解引用操作，导致空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: serial8250_isa_init_ports\n- 参数: []\n- 调用者: 未显示（系统初始化调用）\n- 被调用者: [serial8250_init_port, timer_setup, irq_canonicalize, serial8250_set_defaults, serial8250_isa_config]\n\n2. 函数名: serial8250_init_port\n- 参数: [up]\n- 调用者: serial8250_isa_init_ports\n- 被调用者: []\n\n3. 函数名: timer_setup\n- 参数: [&up->timer, serial8250_timeout, 0]\n- 调用者: serial8250_isa_init_ports\n- 被调用者: []\n\n4. 函数名: irq_canonicalize\n- 参数: [old_serial_port[i].irq]\n- 调用者: serial8250_isa_init_ports\n- 被调用者: []\n\n5. 函数名: serial8250_set_defaults\n- 参数: [up]\n- 调用者: serial8250_isa_init_ports\n- 被调用者: []\n\n6. 函数名: serial8250_isa_config\n- 参数: [i, &up->port, &up->capabilities]\n- 调用者: serial8250_isa_init_ports\n- 被调用者: []\n\n7. 函数名: univ8250_rsa_support\n- 参数: [&univ8250_port_ops]\n- 调用者: serial8250_isa_init_ports\n- 被调用者: []\n\n8. 函数名: serial8250_timeout\n- 参数: 未显示（作为回调函数）\n- 调用者: timer_setup\n- 被调用者: []"
    },
    {
        "id": 2586,
        "cwe": "CWE-476",
        "cve": "CVE-2020-25285",
        "purpose": "Code purpose:\"\"\"该代码用于处理Linux内核中hugetlb子系统的overcommit内存管理设置，允许读取和修改大页内存的overcommit计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在hugetlb sysctl处理程序中存在竞态条件，多个处理器同时访问和修改临时变量tmp可能导致内存损坏或空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: hugetlb_overcommit_handler\n- 参数: [struct ctl_table *table, int write, void *buffer, size_t *length, loff_t *ppos]\n- 调用者: 未显示（应为内核sysctl处理机制）\n- 被调用者: [hugepages_supported, hstate_is_gigantic, proc_doulongvec_minmax]\n\n2. 函数名: hugepages_supported\n- 参数: []\n- 调用者: hugetlb_overcommit_handler\n- 被调用者: []\n\n3. 函数名: hstate_is_gigantic\n- 参数: [struct hstate *h]\n- 调用者: hugetlb_overcommit_handler\n- 被调用者: []\n\n4. 函数名: proc_doulongvec_minmax\n- 参数: [struct ctl_table *table, int write, void *buffer, size_t *length, loff_t *ppos]\n- 调用者: hugetlb_overcommit_handler\n- 被调用者: []"
    },
    {
        "id": 2587,
        "cwe": "CWE-476",
        "cve": "CVE-2020-25285",
        "purpose": "Code purpose:\"\"\"该代码用于处理hugetlb系统控制参数，允许通过sysctl接口读取和修改大页内存的最大数量\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于hugetlb_sysctl_handler_common函数中存在竞态条件，多个处理器同时访问和修改tmp变量可能导致内存损坏或空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: hugetlb_sysctl_handler_common\n- 参数: [obey_mempolicy, table, write, buffer, length, ppos]\n- 调用者: 未明确显示（通常是sysctl处理调用链）\n- 被调用者: [hugepages_supported, proc_doulongvec_minmax, __nr_hugepages_store_common]\n\n2. 函数名: hugepages_supported\n- 参数: []\n- 调用者: hugetlb_sysctl_handler_common\n- 被调用者: []\n\n3. 函数名: proc_doulongvec_minmax\n- 参数: [table, write, buffer, length, ppos]\n- 调用者: hugetlb_sysctl_handler_common\n- 被调用者: []\n\n4. 函数名: __nr_hugepages_store_common\n- 参数: [obey_mempolicy, h, NUMA_NO_NODE, tmp, *length]\n- 调用者: hugetlb_sysctl_handler_common\n- 被调用者: []"
    },
    {
        "id": 2588,
        "cwe": "CWE-476",
        "cve": "CVE-2020-25639",
        "purpose": "Code purpose:\"\"\"该代码用于在Nouveau驱动中创建和初始化一个新的GPU通道，处理通道创建失败的情况，并恢复权限状态。\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在调用nouveau_svmm_join函数时未对(*pchan)->vmm指针进行空指针检查，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: nouveau_channel_new\n- 参数: [struct nouveau_drm *drm, struct nvif_device *device, u32 arg0, u32 arg1, bool priv, struct nouveau_channel **pchan]\n- 调用者: 外部调用（如DRM_IOCTL_NOUVEAU_CHANNEL_ALLOC）\n- 被调用者: [nouveau_channel_ind, nouveau_channel_dma, nouveau_channel_init, nouveau_channel_del, nouveau_svmm_join]\n\n2. 函数名: nouveau_channel_ind\n- 参数: [struct nouveau_drm *drm, struct nvif_device *device, u32 arg0, bool priv, struct nouveau_channel **pchan]\n- 调用者: nouveau_channel_new\n- 被调用者: []\n\n3. 函数名: nouveau_channel_dma\n- 参数: [struct nouveau_drm *drm, struct nvif_device *device, struct nouveau_channel **pchan]\n- 调用者: nouveau_channel_new\n- 被调用者: []\n\n4. 函数名: nouveau_channel_init\n- 参数: [struct nouveau_channel *pchan, u32 arg0, u32 arg1]\n- 调用者: nouveau_channel_new\n- 被调用者: []\n\n5. 函数名: nouveau_channel_del\n- 参数: [struct nouveau_channel **pchan]\n- 调用者: nouveau_channel_new\n- 被调用者: []\n\n6. 函数名: nouveau_svmm_join\n- 参数: [struct nouveau_svmm *svmm, u64 inst]\n- 调用者: nouveau_channel_new\n- 被调用者: []"
    },
    {
        "id": 2621,
        "cwe": "CWE-476",
        "cve": "CVE-2020-27675",
        "purpose": "Code purpose:\"\"\"该代码用于根据事件通道号(evtchn)获取对应的中断号(irq)，并进行边界检查和空指针检查\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环中存在竞态条件，允许在事件处理期间移除事件通道，导致可能发生空指针解引用或释放后使用\"\"\"",
        "functions": "Functions:\n1. 函数名: get_evtchn_to_irq\n- 参数: [evtchn_port_t evtchn]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [xen_evtchn_max_channels]\n\n2. 函数名: xen_evtchn_max_channels\n- 参数: []\n- 调用者: get_evtchn_to_irq\n- 被调用者: 未明确"
    },
    {
        "id": 2622,
        "cwe": "CWE-476",
        "cve": "CVE-2020-27675",
        "purpose": "Code purpose:\"\"\"清除指定行中所有事件通道到中断号的映射关系\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环中删除事件通道导致竞态条件，可能引发释放后使用或空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: clear_evtchn_to_irq_row\n- 参数: [row]\n- 调用者: 未在代码片段中显示\n- 被调用者: []"
    },
    {
        "id": 2623,
        "cwe": "CWE-476",
        "cve": "CVE-2020-27675",
        "purpose": "Code purpose:\"\"\"该代码用于在Xen虚拟化环境中释放中断请求(IRQ)资源，包括从链表中删除中断信息、释放内存以及处理传统中断描述符。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环中存在竞态条件，允许在事件处理期间删除事件通道，导致可能发生释放后使用或空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: xen_free_irq\n- 参数: [unsigned irq]\n- 调用者: 未显示\n- 被调用者: [info_for_irq, WARN_ON, list_del, set_info_for_irq, kfree, nr_legacy_irqs, irq_free_desc]\n\n2. 函数名: info_for_irq\n- 参数: [unsigned irq]\n- 调用者: xen_free_irq\n- 被调用者: 未显示\n\n3. 函数名: WARN_ON\n- 参数: [condition]\n- 调用者: xen_free_irq\n- 被调用者: 未显示\n\n4. 函数名: list_del\n- 参数: [struct list_head *entry]\n- 调用者: xen_free_irq\n- 被调用者: 未显示\n\n5. 函数名: set_info_for_irq\n- 参数: [unsigned irq, struct irq_info *info]\n- 调用者: xen_free_irq\n- 被调用者: 未显示\n\n6. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: xen_free_irq\n- 被调用者: 未显示\n\n7. 函数名: nr_legacy_irqs\n- 参数: []\n- 调用者: xen_free_irq\n- 被调用者: 未显示\n\n8. 函数名: irq_free_desc\n- 参数: [unsigned int irq]\n- 调用者: xen_free_irq\n- 被调用者: 未显示"
    },
    {
        "id": 2624,
        "cwe": "CWE-476",
        "cve": "CVE-2020-27675",
        "purpose": "Code purpose:\"\"\"该代码用于设置Xen事件通道与中断请求号(IRQ)之间的映射关系\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环中存在竞态条件，允许在事件处理过程中删除事件通道，导致可能发生释放后使用或空指针解引用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: set_evtchn_to_irq\n- 参数: [evtchn_port_t evtchn, unsigned int irq]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [xen_evtchn_max_channels, EVTCHN_ROW, EVTCHN_COL, get_zeroed_page, clear_evtchn_to_irq_row]\n\n2. 函数名: xen_evtchn_max_channels\n- 参数: []\n- 调用者: set_evtchn_to_irq\n- 被调用者: []\n\n3. 函数名: EVTCHN_ROW\n- 参数: [evtchn_port_t evtchn]\n- 调用者: set_evtchn_to_irq\n- 被调用者: []\n\n4. 函数名: EVTCHN_COL\n- 参数: [evtchn_port_t evtchn]\n- 调用者: set_evtchn_to_irq\n- 被调用者: []\n\n5. 函数名: get_zeroed_page\n- 参数: [GFP_KERNEL]\n- 调用者: set_evtchn_to_irq\n- 被调用者: []\n\n6. 函数名: clear_evtchn_to_irq_row\n- 参数: [unsigned row]\n- 调用者: set_evtchn_to_irq\n- 被调用者: []"
    },
    {
        "id": 2625,
        "cwe": "CWE-476",
        "cve": "CVE-2020-27675",
        "purpose": "Code purpose:\"\"\"处理Xen事件通道的上调事件，循环检查并处理挂起的事件\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环中允许移除事件通道导致竞态条件，可能引发释放后使用或空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: __xen_evtchn_do_upcall\n- 参数: []\n- 调用者: N/A (static function)\n- 被调用者: [__this_cpu_read, smp_processor_id, xen_evtchn_handle_events, BUG_ON, virt_rmb]\n\n2. 函数名: __this_cpu_read\n- 参数: [xen_vcpu]\n- 调用者: __xen_evtchn_do_upcall\n- 被调用者: []\n\n3. 函数名: smp_processor_id\n- 参数: []\n- 调用者: __xen_evtchn_do_upcall\n- 被调用者: []\n\n4. 函数名: xen_evtchn_handle_events\n- 参数: [cpu]\n- 调用者: __xen_evtchn_do_upcall\n- 被调用者: []\n\n5. 函数名: BUG_ON\n- 参数: [!irqs_disabled()]\n- 调用者: __xen_evtchn_do_upcall\n- 被调用者: []\n\n6. 函数名: virt_rmb\n- 参数: []\n- 调用者: __xen_evtchn_do_upcall\n- 被调用者: []\n\n7. 函数名: irqs_disabled\n- 参数: []\n- 调用者: BUG_ON\n- 被调用者: []"
    },
    {
        "id": 2626,
        "cwe": "CWE-476",
        "cve": "CVE-2020-27675",
        "purpose": "Code purpose:\"\"\"该代码用于从给定的IRQ（中断请求）号获取对应的事件通道（event channel），并进行有效性检查。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在事件处理循环中存在竞态条件，允许在事件处理过程中移除事件通道，导致可能发生空指针解引用或释放后使用的问题\"\"\"",
        "functions": "Functions:\n1. 函数名: evtchn_from_irq\n- 参数: [unsigned irq]\n- 调用者: 未指定\n- 被调用者: [WARN, info_for_irq]\n\n2. 函数名: WARN\n- 参数: [irq >= nr_irqs, \"Invalid irq %d!\\n\", irq]\n- 调用者: evtchn_from_irq\n- 被调用者: 未指定\n\n3. 函数名: info_for_irq\n- 参数: [irq]\n- 调用者: evtchn_from_irq\n- 被调用者: 未指定"
    },
    {
        "id": 2639,
        "cwe": "CWE-476",
        "cve": "CVE-2020-27830",
        "purpose": "Code purpose:\"\"\"该代码片段实现了Linux内核中语音合成器通过TTY线路规程进行通信的初始化功能，包括检查TTY写操作支持、分配内存空间并初始化相关数据结构。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在spk_ttyio_receive_buf2()函数中未对spk_ttyio_synth进行NULL检查就直接解引用，导致可能发生空指针解引用崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: spk_ttyio_ldisc_open\n- 参数: [struct tty_struct *tty]\n- 调用者: 未明确（由内核调用）\n- 被调用者: [kmalloc, init_completion, mutex_lock, mutex_unlock]\n\n2. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: spk_ttyio_ldisc_open\n- 被调用者: []\n\n3. 函数名: init_completion\n- 参数: [struct completion *x]\n- 调用者: spk_ttyio_ldisc_open\n- 被调用者: []\n\n4. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: spk_ttyio_ldisc_open\n- 被调用者: []\n\n5. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: spk_ttyio_ldisc_open\n- 被调用者: []"
    },
    {
        "id": 2640,
        "cwe": "CWE-476",
        "cve": "CVE-2020-27830",
        "purpose": "Code purpose:\"\"\"初始化并设置串行线路规程用于语音合成器的输入输出操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在spk_ttyio_receive_buf2()函数中未检查spk_ttyio_synth是否为NULL就直接解引用，导致可能发生空指针解引用崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: spk_ttyio_initialise_ldisc\n- 参数: [struct spk_synth *synth]\n- 调用者: 未提供\n- 被调用者: [get_dev_to_use, tty_kopen, IS_ERR, PTR_ERR, tty_unlock, get_termios, tty_set_termios, pr_warn, tty_set_ldisc, pr_err]\n\n2. 函数名: get_dev_to_use\n- 参数: [struct spk_synth *synth, dev_t *dev]\n- 调用者: spk_ttyio_initialise_ldisc\n- 被调用者: 未提供\n\n3. 函数名: tty_kopen\n- 参数: [dev_t dev]\n- 调用者: spk_ttyio_initialise_ldisc\n- 被调用者: 未提供\n\n4. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: spk_ttyio_initialise_ldisc\n- 被调用者: 未提供\n\n5. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: spk_ttyio_initialise_ldisc\n- 被调用者: 未提供\n\n6. 函数名: tty_unlock\n- 参数: [struct tty_struct *tty]\n- 调用者: spk_ttyio_initialise_ldisc\n- 被调用者: 未提供\n\n7. 函数名: get_termios\n- 参数: [struct tty_struct *tty, struct ktermios *tmp_termios]\n- 调用者: spk_ttyio_initialise_ldisc\n- 被调用者: 未提供\n\n8. 函数名: tty_set_termios\n- 参数: [struct tty_struct *tty, struct ktermios *tmp_termios]\n- 调用者: spk_ttyio_initialise_ldisc\n- 被调用者: 未提供\n\n9. 函数名: pr_warn\n- 参数: [const char *fmt, ...]\n- 调用者: spk_ttyio_initialise_ldisc\n- 被调用者: 未提供\n\n10. 函数名: tty_set_ldisc\n- 参数: [struct tty_struct *tty, int ldisc]\n- 调用者: spk_ttyio_initialise_ldisc\n- 被调用者: 未提供\n\n11. 函数名: pr_err\n- 参数: [const char *fmt, ...]\n- 调用者: spk_ttyio_initialise_ldisc\n- 被调用者: 未提供"
    },
    {
        "id": 2705,
        "cwe": "CWE-476",
        "cve": "CVE-2020-35499",
        "purpose": "Code purpose:\"\"\"该代码实现了蓝牙SCO套接字的getsockopt操作，用于获取各种蓝牙SCO套接字选项的值，如延迟设置、语音设置、物理层参数、包状态和MTU大小等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在sco_sock_getsockopt函数中，当处理BT_SNDMTU/BT_RCVMTU选项时，未对sco_pi(sk)->conn进行NULL指针检查，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: sco_sock_getsockopt\n- 参数: [struct socket *sock, int level, int optname, char __user *optval, int __user *optlen]\n- 调用者: 未显示（由内核调用）\n- 被调用者: [sco_sock_getsockopt_old, get_user, lock_sock, put_user, test_bit, min_t, copy_to_user, hci_conn_get_phy, release_sock]\n\n2. 函数名: sco_sock_getsockopt_old\n- 参数: [struct socket *sock, int optname, char __user *optval, int __user *optlen]\n- 调用者: sco_sock_getsockopt\n- 被调用者: 未显示\n\n3. 函数名: get_user\n- 参数: [len, optlen]\n- 调用者: sco_sock_getsockopt\n- 被调用者: 未显示\n\n4. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: sco_sock_getsockopt\n- 被调用者: 未显示\n\n5. 函数名: put_user\n- 参数: [test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags), (u32 __user *)optval]\n- 调用者: sco_sock_getsockopt\n- 被调用者: 未显示\n\n6. 函数名: test_bit\n- 参数: [BT_SK_DEFER_SETUP, &bt_sk(sk)->flags]\n- 调用者: sco_sock_getsockopt\n- 被调用者: 未显示\n\n7. 函数名: min_t\n- 参数: [unsigned int, len, sizeof(voice)]\n- 调用者: sco_sock_getsockopt\n- 被调用者: 未显示\n\n8. 函数名: copy_to_user\n- 参数: [optval, (char *)&voice, len]\n- 调用者: sco_sock_getsockopt\n- 被调用者: 未显示\n\n9. 函数名: hci_conn_get_phy\n- 参数: [sco_pi(sk)->conn->hcon]\n- 调用者: sco_sock_getsockopt\n- 被调用者: 未显示\n\n10. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: sco_sock_getsockopt\n- 被调用者: 未显示"
    },
    {
        "id": 2767,
        "cwe": "CWE-476",
        "cve": "CVE-2020-36558",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中虚拟终端(VT)的ioctl系统调用处理功能，用于控制和管理虚拟终端的各种操作，包括字体设置、屏幕大小调整、键盘模式切换等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在VT_RESIZEX操作中，由于缺乏对vc_cons数组元素的同步访问保护，导致在多线程环境下可能发生竞态条件，从而引发空指针解引用和一般保护错误。\"\"\"",
        "functions": "Functions:\n1. 函数名: vt_ioctl\n- 参数: [struct tty_struct *tty, unsigned int cmd, unsigned long arg]\n- 调用者: N/A (kernel-level function)\n- 被调用者: [vc_cons_allocated, tioclinux, kd_mksound, msecs_to_jiffies, put_user, ksys_ioperm, copy_from_user, kbd_rate, copy_to_user, vt_do_kdskbmode, tty_ldisc_flush, vt_do_kdgkbmode, vt_do_kdskbmeta, vt_do_kdgkbmeta, vt_do_kbkeycode_ioctl, vt_do_kdsk_ioctl, vt_do_kdgkb_ioctl, vt_do_diacrit, vt_do_kdskled, valid_signal, put_pid, get_pid, task_pid, copy_from_user, memcpy, copy_to_user, vc_allocate, set_console, vt_waitactive, complete_change_console, vt_disallocate_all, vt_disallocate, vc_resize, con_font_op, con_set_cmap, con_get_cmap, do_fontx_ioctl, con_set_default_unimap, con_set_trans_old, con_get_trans_old, con_set_trans_new, con_get_trans_new, con_clear_unimap, do_unimap_ioctl, vt_event_wait_ioctl]\n\n2. 函数名: vc_cons_allocated\n- 参数: [unsigned int console]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n3. 函数名: tioclinux\n- 参数: [struct tty_struct *tty, unsigned long arg]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n4. 函数名: kd_mksound\n- 参数: [unsigned long arg, int ticks]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n5. 函数名: msecs_to_jiffies\n- 参数: [unsigned int msecs]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n6. 函数名: put_user\n- 参数: [type val, type __user *addr]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n7. 函数名: ksys_ioperm\n- 参数: [unsigned long from, unsigned long num, int turn_on]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n8. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n9. 函数名: kbd_rate\n- 参数: [struct kbd_repeat *kbrep]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n10. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n11. 函数名: vt_do_kdskbmode\n- 参数: [unsigned int console, unsigned int arg]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n12. 函数名: tty_ldisc_flush\n- 参数: [struct tty_struct *tty]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n13. 函数名: vt_do_kdgkbmode\n- 参数: [unsigned int console]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n14. 函数名: vt_do_kdskbmeta\n- 参数: [unsigned int console, unsigned int arg]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n15. 函数名: vt_do_kdgkbmeta\n- 参数: [unsigned int console]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n16. 函数名: vt_do_kbkeycode_ioctl\n- 参数: [unsigned int cmd, void __user *up, int perm]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n17. 函数名: vt_do_kdsk_ioctl\n- 参数: [unsigned int cmd, void __user *up, int perm, unsigned int console]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n18. 函数名: vt_do_kdgkb_ioctl\n- 参数: [unsigned int cmd, void __user *up, int perm]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n19. 函数名: vt_do_diacrit\n- 参数: [unsigned int cmd, void __user *up, int perm]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n20. 函数名: vt_do_kdskled\n- 参数: [unsigned int console, unsigned int cmd, unsigned long arg, int perm]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n21. 函数名: valid_signal\n- 参数: [unsigned long sig]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n22. 函数名: put_pid\n- 参数: [struct pid *pid]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n23. 函数名: get_pid\n- 参数: [struct pid *pid]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n24. 函数名: task_pid\n- 参数: [struct task_struct *task]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n25. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n26. 函数名: vc_allocate\n- 参数: [unsigned int console]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n27. 函数名: set_console\n- 参数: [unsigned int console]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n28. 函数名: vt_waitactive\n- 参数: [unsigned int console]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n29. 函数名: complete_change_console\n- 参数: [struct vc_data *vc]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n30. 函数名: vt_disallocate_all\n- 参数: []\n- 调用者: vt_ioctl\n- 被调用者: []\n\n31. 函数名: vt_disallocate\n- 参数: [unsigned int console]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n32. 函数名: vc_resize\n- 参数: [struct vc_data *vc, unsigned int cols, unsigned int rows]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n33. 函数名: con_font_op\n- 参数: [struct vc_data *vc, struct console_font_op *op]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n34. 函数名: con_set_cmap\n- 参数: [unsigned char __user *arg]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n35. 函数名: con_get_cmap\n- 参数: [unsigned char __user *arg]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n36. 函数名: do_fontx_ioctl\n- 参数: [unsigned int cmd, void __user *up, int perm, struct console_font_op *op]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n37. 函数名: con_set_default_unimap\n- 参数: [struct vc_data *vc]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n38. 函数名: con_set_trans_old\n- 参数: [unsigned char __user *arg]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n39. 函数名: con_get_trans_old\n- 参数: [unsigned char __user *arg]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n40. 函数名: con_set_trans_new\n- 参数: [unsigned short __user *arg]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n41. 函数名: con_get_trans_new\n- 参数: [unsigned short __user *arg]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n42. 函数名: con_clear_unimap\n- 参数: [struct vc_data *vc]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n43. 函数名: do_unimap_ioctl\n- 参数: [unsigned int cmd, void __user *up, int perm, struct vc_data *vc]\n- 调用者: vt_ioctl\n- 被调用者: []\n\n44. 函数名: vt_event_wait_ioctl\n- 参数: [struct vt_event __user *event]\n- 调用者: vt_ioctl\n- 被调用者: []"
    },
    {
        "id": 2959,
        "cwe": "CWE-476",
        "cve": "CVE-2021-30178",
        "purpose": "Code purpose:\"\"\"通过vpidx获取对应虚拟CPU的Hyper-V SynIC上下文，并检查其是否处于活动状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在访问Hyper-V的SynIC上下文时，未充分验证synic指针是否为空，导致可能发生空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: synic_get\n- 参数: [kvm, vpidx]\n- 调用者: 未指定\n- 被调用者: [get_vcpu_by_vpidx, to_hv_synic]\n\n2. 函数名: get_vcpu_by_vpidx\n- 参数: [kvm, vpidx]\n- 调用者: synic_get\n- 被调用者: 未指定\n\n3. 函数名: to_hv_synic\n- 参数: [vcpu]\n- 调用者: synic_get\n- 被调用者: 未指定"
    },
    {
        "id": 3017,
        "cwe": "CWE-476",
        "cve": "CVE-2021-3543",
        "purpose": "Code purpose:\"\"\"处理Nitro Enclaves内核驱动中创建虚拟机并管理相关文件描述符和互斥锁的ioctl操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在NE_CREATE_VM命令处理中，当copy_to_user失败时，未检查enclave_file是否为NULL就直接调用fput，可能导致空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: ne_ioctl\n- 参数: [struct file *file, unsigned int cmd, unsigned long arg]\n- 调用者: 无（内核驱动接口函数）\n- 被调用者: [mutex_lock, ne_create_vm_ioctl, mutex_unlock, copy_to_user, fget, fput, put_unused_fd]\n\n2. 函数名: ne_create_vm_ioctl\n- 参数: [struct ne_pci_dev *ne_pci_dev, u64 *slot_uid]\n- 调用者: ne_ioctl\n- 被调用者: 无（假设为外部定义函数）\n\n3. 函数名: mutex_lock\n- 参数: [struct mutex *enclaves_list_mutex]\n- 调用者: ne_ioctl\n- 被调用者: 无（内核同步原语）\n\n4. 函数名: mutex_unlock\n- 参数: [struct mutex *enclaves_list_mutex]\n- 调用者: ne_ioctl\n- 被调用者: 无（内核同步原语）\n\n5. 函数名: copy_to_user\n- 参数: [void __user *arg, u64 *slot_uid, sizeof(slot_uid)]\n- 调用者: ne_ioctl\n- 被调用者: 无（内核内存操作函数）\n\n6. 函数名: fget\n- 参数: [int enclave_fd]\n- 调用者: ne_ioctl\n- 被调用者: 无（内核文件操作函数）\n\n7. 函数名: fput\n- 参数: [struct file *enclave_file]\n- 调用者: ne_ioctl\n- 被调用者: 无（内核文件操作函数）\n\n8. 函数名: put_unused_fd\n- 参数: [int enclave_fd]\n- 调用者: ne_ioctl\n- 被调用者: 无（内核文件描述符操作函数）"
    },
    {
        "id": 3039,
        "cwe": "CWE-476",
        "cve": "CVE-2021-3659",
        "purpose": "Code purpose:\"\"\"为IEEE 802.15.4无线网络子系统分配和初始化加密密钥及相关转换模块\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在关闭LR-WPAN连接时未正确处理空指针引用，导致系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: llsec_key_alloc\n- 参数: [const struct ieee802154_llsec_key *template]\n- 调用者: 未显示\n- 被调用者: [kzalloc, kref_init, BUILD_BUG_ON, crypto_alloc_aead, IS_ERR, crypto_aead_setkey, crypto_aead_setauthsize, crypto_alloc_sync_skcipher, crypto_sync_skcipher_setkey, crypto_free_sync_skcipher, crypto_free_aead, kfree_sensitive]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*key), GFP_KERNEL]\n- 调用者: llsec_key_alloc\n- 被调用者: 未显示\n\n3. 函数名: kref_init\n- 参数: [&key->ref]\n- 调用者: llsec_key_alloc\n- 被调用者: 未显示\n\n4. 函数名: BUILD_BUG_ON\n- 参数: [ARRAY_SIZE(authsizes) != ARRAY_SIZE(key->tfm)]\n- 调用者: llsec_key_alloc\n- 被调用者: 未显示\n\n5. 函数名: crypto_alloc_aead\n- 参数: [\"ccm(aes)\", 0, CRYPTO_ALG_ASYNC]\n- 调用者: llsec_key_alloc\n- 被调用者: 未显示\n\n6. 函数名: IS_ERR\n- 参数: [key->tfm[i]]\n- 调用者: llsec_key_alloc\n- 被调用者: 未显示\n\n7. 函数名: crypto_aead_setkey\n- 参数: [key->tfm[i], template->key, IEEE802154_LLSEC_KEY_SIZE]\n- 调用者: llsec_key_alloc\n- 被调用者: 未显示\n\n8. 函数名: crypto_aead_setauthsize\n- 参数: [key->tfm[i], authsizes[i]]\n- 调用者: llsec_key_alloc\n- 被调用者: 未显示\n\n9. 函数名: crypto_alloc_sync_skcipher\n- 参数: [\"ctr(aes)\", 0, 0]\n- 调用者: llsec_key_alloc\n- 被调用者: 未显示\n\n10. 函数名: crypto_sync_skcipher_setkey\n- 参数: [key->tfm0, template->key, IEEE802154_LLSEC_KEY_SIZE]\n- 调用者: llsec_key_alloc\n- 被调用者: 未显示\n\n11. 函数名: crypto_free_sync_skcipher\n- 参数: [key->tfm0]\n- 调用者: llsec_key_alloc\n- 被调用者: 未显示\n\n12. 函数名: crypto_free_aead\n- 参数: [key->tfm[i]]\n- 调用者: llsec_key_alloc\n- 被调用者: 未显示\n\n13. 函数名: kfree_sensitive\n- 参数: [key]\n- 调用者: llsec_key_alloc\n- 被调用者: 未显示"
    },
    {
        "id": 3050,
        "cwe": "CWE-476",
        "cve": "CVE-2021-3739",
        "purpose": "Code purpose:\"\"\"该代码用于从Btrfs文件系统中移除指定设备，处理设备移除过程中的各种状态检查和资源清理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在btrfs_rm_device函数中，当设备路径为'missing'且设备查找失败时，未正确处理NULL指针解引用问题，导致系统崩溃或内核信息泄露。\"\"\"",
        "functions": "Functions:\n1. 函数名: btrfs_rm_device\n- 参数: [struct btrfs_fs_info *fs_info, const char *device_path, u64 devid]\n- 调用者: N/A\n- 被调用者: [btrfs_num_devices, btrfs_check_raid_min_devices, btrfs_find_device_by_devspec, btrfs_pinned_by_swapfile, btrfs_warn_in_rcu, btrfs_shrink_device, btrfs_reada_remove_dev, btrfs_rm_dev_item, btrfs_scrub_cancel_dev, btrfs_assign_next_active_device, btrfs_sysfs_remove_device, btrfs_set_super_num_devices, btrfs_scratch_superblocks, btrfs_close_bdev, btrfs_free_device, close_fs_devices, free_fs_devices, btrfs_reada_undo_remove_dev]\n\n2. 函数名: btrfs_num_devices\n- 参数: [struct btrfs_fs_info *fs_info]\n- 调用者: btrfs_rm_device\n- 被调用者: N/A\n\n3. 函数名: btrfs_check_raid_min_devices\n- 参数: [struct btrfs_fs_info *fs_info, u64 num_devices]\n- 调用者: btrfs_rm_device\n- 被调用者: N/A\n\n4. 函数名: btrfs_find_device_by_devspec\n- 参数: [struct btrfs_fs_info *fs_info, u64 devid, const char *device_path]\n- 调用者: btrfs_rm_device\n- 被调用者: N/A\n\n5. 函数名: btrfs_pinned_by_swapfile\n- 参数: [struct btrfs_fs_info *fs_info, struct btrfs_device *device]\n- 调用者: btrfs_rm_device\n- 被调用者: N/A\n\n6. 函数名: btrfs_warn_in_rcu\n- 参数: [struct btrfs_fs_info *fs_info, const char *fmt, ...]\n- 调用者: btrfs_rm_device\n- 被调用者: N/A\n\n7. 函数名: btrfs_shrink_device\n- 参数: [struct btrfs_device *device, u64 new_size]\n- 调用者: btrfs_rm_device\n- 被调用者: N/A\n\n8. 函数名: btrfs_reada_remove_dev\n- 参数: [struct btrfs_device *device]\n- 调用者: btrfs_rm_device\n- 被调用者: N/A\n\n9. 函数名: btrfs_rm_dev_item\n- 参数: [struct btrfs_device *device]\n- 调用者: btrfs_rm_device\n- 被调用者: N/A\n\n10. 函数名: btrfs_scrub_cancel_dev\n- 参数: [struct btrfs_device *device]\n- 调用者: btrfs_rm_device\n- 被调用者: N/A\n\n11. 函数名: btrfs_assign_next_active_device\n- 参数: [struct btrfs_device *device, struct btrfs_device *next_active]\n- 调用者: btrfs_rm_device\n- 被调用者: N/A\n\n12. 函数名: btrfs_sysfs_remove_device\n- 参数: [struct btrfs_device *device]\n- 调用者: btrfs_rm_device\n- 被调用者: N/A\n\n13. 函数名: btrfs_set_super_num_devices\n- 参数: [struct btrfs_super_block *sb, u64 num_devices]\n- 调用者: btrfs_rm_device\n- 被调用者: N/A\n\n14. 函数名: btrfs_scratch_superblocks\n- 参数: [struct btrfs_fs_info *fs_info, struct block_device *bdev, const char *device_path]\n- 调用者: btrfs_rm_device\n- 被调用者: N/A\n\n15. 函数名: btrfs_close_bdev\n- 参数: [struct btrfs_device *device]\n- 调用者: btrfs_rm_device\n- 被调用者: N/A\n\n16. 函数名: btrfs_free_device\n- 参数: [struct btrfs_device *device]\n- 调用者: btrfs_rm_device\n- 被调用者: N/A\n\n17. 函数名: close_fs_devices\n- 参数: [struct btrfs_fs_devices *fs_devices]\n- 调用者: btrfs_rm_device\n- 被调用者: N/A\n\n18. 函数名: free_fs_devices\n- 参数: [struct btrfs_fs_devices *fs_devices]\n- 调用者: btrfs_rm_device\n- 被调用者: N/A\n\n19. 函数名: btrfs_reada_undo_remove_dev\n- 参数: [struct btrfs_device *device]\n- 调用者: btrfs_rm_device\n- 被调用者: N/A"
    },
    {
        "id": 3074,
        "cwe": "CWE-476",
        "cve": "CVE-2021-38200",
        "purpose": "Code purpose:\"\"\"该代码用于在PowerPC架构上获取性能监控单元(PMU)的指令指针地址，根据不同的处理器标志和寄存器状态返回正确的指令指针值。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当系统没有注册特定PMU驱动支持且perf_event_paranoid设为-1时，ppmu指针可能为NULL，导致NULL指针解引用引发拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: perf_instruction_pointer\n- 参数: [struct pt_regs *regs]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [regs_use_siar, mfspr, siar_valid, perf_ip_adjust]\n\n2. 函数名: regs_use_siar\n- 参数: [struct pt_regs *regs]\n- 调用者: [perf_instruction_pointer]\n- 被调用者: 未明确\n\n3. 函数名: mfspr\n- 参数: [SPRN_SIAR]\n- 调用者: [perf_instruction_pointer]\n- 被调用者: 未明确\n\n4. 函数名: siar_valid\n- 参数: [struct pt_regs *regs]\n- 调用者: [perf_instruction_pointer]\n- 被调用者: 未明确\n\n5. 函数名: perf_ip_adjust\n- 参数: [struct pt_regs *regs]\n- 调用者: [perf_instruction_pointer]\n- 被调用者: 未明确"
    },
    {
        "id": 3082,
        "cwe": "CWE-476",
        "cve": "CVE-2021-38206",
        "purpose": "Code purpose:\"\"\"解析802.11无线网络数据包中的radiotap头部信息，提取并设置传输参数如速率、重试次数等，用于无线网络数据包的发送控制\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当使用仅支持5GHz的设备时，代码未正确处理802.11a速率导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: ieee80211_parse_tx_radiotap\n- 参数: [skb, dev]\n- 调用者: N/A (top-level function)\n- 被调用者: [wdev_priv, ieee80211_radiotap_iterator_init, ieee80211_radiotap_iterator_next, get_unaligned_le16, skb_trim, u8_get_bits, u32_encode_bits, ieee80211_rate_set_vht, min_t]\n\n2. 函数名: wdev_priv\n- 参数: [dev->ieee80211_ptr]\n- 调用者: ieee80211_parse_tx_radiotap\n- 被调用者: []\n\n3. 函数名: ieee80211_radiotap_iterator_init\n- 参数: [&iterator, rthdr, skb->len, NULL]\n- 调用者: ieee80211_parse_tx_radiotap\n- 被调用者: []\n\n4. 函数名: ieee80211_radiotap_iterator_next\n- 参数: [&iterator]\n- 调用者: ieee80211_parse_tx_radiotap\n- 被调用者: []\n\n5. 函数名: get_unaligned_le16\n- 参数: [iterator.this_arg]\n- 调用者: ieee80211_parse_tx_radiotap\n- 被调用者: []\n\n6. 函数名: skb_trim\n- 参数: [skb, skb->len - FCS_LEN]\n- 调用者: ieee80211_parse_tx_radiotap\n- 被调用者: []\n\n7. 函数名: u8_get_bits\n- 参数: [mcs_flags, IEEE80211_RADIOTAP_MCS_STBC_MASK]\n- 调用者: ieee80211_parse_tx_radiotap\n- 被调用者: []\n\n8. 函数名: u32_encode_bits\n- 参数: [stbc, IEEE80211_TX_CTL_STBC]\n- 调用者: ieee80211_parse_tx_radiotap\n- 被调用者: []\n\n9. 函数名: ieee80211_rate_set_vht\n- 参数: [info->control.rates, vht_mcs, vht_nss]\n- 调用者: ieee80211_parse_tx_radiotap\n- 被调用者: []\n\n10. 函数名: min_t\n- 参数: [u8, rate_retries + 1, local->hw.max_rate_tries]\n- 调用者: ieee80211_parse_tx_radiotap\n- 被调用者: []"
    },
    {
        "id": 3083,
        "cwe": "CWE-476",
        "cve": "CVE-2021-38206",
        "purpose": "Code purpose:\"\"\"处理并转发通过监控接口注入的802.11无线帧，包括解析radiotap头部、设置网络协议头、验证帧有效性以及选择合适的传输队列等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当使用仅支持5GHz的设备时，注入带有802.11a速率的帧会导致radiotap解析器中空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: ieee80211_monitor_start_xmit\n- 参数: [struct sk_buff *skb, struct net_device *dev]\n- 调用者: 网络设备驱动（未在代码中显示）\n- 被调用者: [wdev_priv, IEEE80211_SKB_CB, memset, ieee80211_parse_tx_radiotap, ieee80211_get_radiotap_len, skb_set_mac_header, skb_set_network_header, skb_set_transport_header, ieee80211_hdrlen, ieee80211_is_data, ether_addr_equal, cpu_to_be16, rcu_read_lock, IEEE80211_DEV_TO_SUB_IF, list_for_each_entry_rcu, ieee80211_sdata_running, rcu_dereference, cfg80211_reg_can_beacon, ieee80211_select_queue_80211, ieee80211_ac_from_tid, skb_pull, ieee80211_xmit, rcu_read_unlock, dev_kfree_skb]\n\n2. 函数名: wdev_priv\n- 参数: [未显示完整参数]\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []\n\n3. 函数名: IEEE80211_SKB_CB\n- 参数: [struct sk_buff *skb]\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []\n\n4. 函数名: memset\n- 参数: [void *info, int 0, size_t sizeof(*info)]\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []\n\n5. 函数名: ieee80211_parse_tx_radiotap\n- 参数: [struct sk_buff *skb, struct net_device *dev]\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []\n\n6. 函数名: ieee80211_get_radiotap_len\n- 参数: [skb->data]\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []\n\n7. 函数名: skb_set_mac_header\n- 参数: [struct sk_buff *skb, len_rthdr]\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []\n\n8. 函数名: skb_set_network_header\n- 参数: [struct sk_buff *skb, len_rthdr]\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []\n\n9. 函数名: skb_set_transport_header\n- 参数: [struct sk_buff *skb, len_rthdr]\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []\n\n10. 函数名: ieee80211_hdrlen\n- 参数: [hdr->frame_control]\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []\n\n11. 函数名: ieee80211_is_data\n- 参数: [hdr->frame_control]\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []\n\n12. 函数名: ether_addr_equal\n- 参数: [payload, rfc1042_header]\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []\n\n13. 函数名: cpu_to_be16\n- 参数: [(payload[6] << 8) | payload[7]]\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []\n\n14. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []\n\n15. 函数名: IEEE80211_DEV_TO_SUB_IF\n- 参数: [dev]\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []\n\n16. 函数名: list_for_each_entry_rcu\n- 参数: [tmp_sdata, &local->interfaces, list]\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []\n\n17. 函数名: ieee80211_sdata_running\n- 参数: [tmp_sdata]\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []\n\n18. 函数名: rcu_dereference\n- 参数: [sdata->vif.chanctx_conf], [local->monitor_sdata], [tmp_sdata->vif.chanctx_conf]\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []\n\n19. 函数名: cfg80211_reg_can_beacon\n- 参数: [local->hw.wiphy, chandef, sdata->vif.type]\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []\n\n20. 函数名: ieee80211_select_queue_80211\n- 参数: [sdata, skb, hdr]\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []\n\n21. 函数名: ieee80211_ac_from_tid\n- 参数: [skb->priority]\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []\n\n22. 函数名: skb_pull\n- 参数: [struct sk_buff *skb, len_rthdr]\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []\n\n23. 函数名: ieee80211_xmit\n- 参数: [sdata, NULL, skb]\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []\n\n24. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []\n\n25. 函数名: dev_kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: ieee80211_monitor_start_xmit\n- 被调用者: []"
    },
    {
        "id": 3085,
        "cwe": "CWE-476",
        "cve": "CVE-2021-38208",
        "purpose": "Code purpose:\"\"\"实现NFC LLCP套接字绑定功能，包括验证地址参数、设备查找、服务名分配和SSAP分配等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在bind调用失败后未正确清理socket状态，导致后续getsockname调用时出现空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: llcp_sock_bind\n- 参数: [sock, addr, alen]\n- 调用者: 未显示（系统调用或内核其他部分）\n- 被调用者: [nfc_llcp_sock, min_t, memcpy, lock_sock, nfc_get_device, nfc_llcp_find_local, nfc_llcp_local_get, kmemdup, nfc_llcp_get_sdp_ssap, nfc_llcp_local_put, kfree, nfc_llcp_sock_link, nfc_put_device, release_sock]\n\n2. 函数名: nfc_llcp_sock\n- 参数: [sk]\n- 调用者: llcp_sock_bind\n- 被调用者: []\n\n3. 函数名: min_t\n- 参数: [unsigned int, sizeof(llcp_addr), alen]\n- 调用者: llcp_sock_bind\n- 被调用者: []\n\n4. 函数名: memcpy\n- 参数: [&llcp_addr, addr, len]\n- 调用者: llcp_sock_bind\n- 被调用者: []\n\n5. 函数名: lock_sock\n- 参数: [sk]\n- 调用者: llcp_sock_bind\n- 被调用者: []\n\n6. 函数名: nfc_get_device\n- 参数: [llcp_addr.dev_idx]\n- 调用者: llcp_sock_bind\n- 被调用者: []\n\n7. 函数名: nfc_llcp_find_local\n- 参数: [dev]\n- 调用者: llcp_sock_bind\n- 被调用者: []\n\n8. 函数名: nfc_llcp_local_get\n- 参数: [local]\n- 调用者: llcp_sock_bind\n- 被调用者: []\n\n9. 函数名: kmemdup\n- 参数: [llcp_addr.service_name, llcp_sock->service_name_len, GFP_KERNEL]\n- 调用者: llcp_sock_bind\n- 被调用者: []\n\n10. 函数名: nfc_llcp_get_sdp_ssap\n- 参数: [local, llcp_sock]\n- 调用者: llcp_sock_bind\n- 被调用者: []\n\n11. 函数名: nfc_llcp_local_put\n- 参数: [llcp_sock->local]\n- 调用者: llcp_sock_bind\n- 被调用者: []\n\n12. 函数名: kfree\n- 参数: [llcp_sock->service_name]\n- 调用者: llcp_sock_bind\n- 被调用者: []\n\n13. 函数名: nfc_llcp_sock_link\n- 参数: [&local->sockets, sk]\n- 调用者: llcp_sock_bind\n- 被调用者: []\n\n14. 函数名: nfc_put_device\n- 参数: [dev]\n- 调用者: llcp_sock_bind\n- 被调用者: []\n\n15. 函数名: release_sock\n- 参数: [sk]\n- 调用者: llcp_sock_bind\n- 被调用者: []"
    },
    {
        "id": 3132,
        "cwe": "CWE-476",
        "cve": "CVE-2021-4095",
        "purpose": "Code purpose:\"\"\"该代码用于在KVM虚拟化环境中向客户机写入墙钟时间信息，并处理相关版本控制和时间计算。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当启用脏环日志记录但没有活跃的vCPU上下文时，KVM中的空指针解引用导致内核异常\"\"\"",
        "functions": "Functions:\n1. 函数名: kvm_write_wall_clock\n- 参数: [struct kvm *kvm, gpa_t wall_clock, int sec_hi_ofs]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [kvm_read_guest, kvm_write_guest, ktime_get_real_ns, get_kvmclock_ns, do_div]\n\n2. 函数名: kvm_read_guest\n- 参数: [struct kvm *kvm, gpa_t wall_clock, &version, sizeof(version)]\n- 调用者: kvm_write_wall_clock\n- 被调用者: 未明确（内核函数）\n\n3. 函数名: kvm_write_guest\n- 参数: [struct kvm *kvm, gpa_t wall_clock, &version, sizeof(version)] 或其他参数组合\n- 调用者: kvm_write_wall_clock\n- 被调用者: 未明确（内核函数）\n\n4. 函数名: ktime_get_real_ns\n- 参数: []\n- 调用者: kvm_write_wall_clock\n- 被调用者: 未明确（内核函数）\n\n5. 函数名: get_kvmclock_ns\n- 参数: [struct kvm *kvm]\n- 调用者: kvm_write_wall_clock\n- 被调用者: 未明确（内核函数）\n\n6. 函数名: do_div\n- 参数: [wall_nsec, 1000000000]\n- 调用者: kvm_write_wall_clock\n- 被调用者: 未明确（内核函数）"
    },
    {
        "id": 3133,
        "cwe": "CWE-476",
        "cve": "CVE-2021-4095",
        "purpose": "Code purpose:\"\"\"初始化Xen共享信息缓存并设置wall clock，用于KVM虚拟化环境中的Xen功能支持\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当启用脏环日志记录但没有活跃的vCPU上下文时，KVM_XEN_HVM_SET_ATTR ioctl操作会导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: kvm_xen_shared_info_init\n- 参数: [struct kvm *kvm, gfn_t gfn]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [srcu_read_lock, kvm_gfn_to_pfn_cache_destroy, kvm_gfn_to_pfn_cache_init, kvm_write_wall_clock, kvm_make_all_cpus_request, srcu_read_unlock]\n\n2. 函数名: srcu_read_lock\n- 参数: [&kvm->srcu]\n- 调用者: kvm_xen_shared_info_init\n- 被调用者: 未显示（内核函数）\n\n3. 函数名: kvm_gfn_to_pfn_cache_destroy\n- 参数: [struct kvm *kvm, struct gfn_to_pfn_cache *gpc]\n- 调用者: kvm_xen_shared_info_init\n- 被调用者: 未显示（内核函数）\n\n4. 函数名: kvm_gfn_to_pfn_cache_init\n- 参数: [struct kvm *kvm, struct gfn_to_pfn_cache *gpc, NULL, false, true, gpa, PAGE_SIZE, false]\n- 调用者: kvm_xen_shared_info_init\n- 被调用者: 未显示（内核函数）\n\n5. 函数名: kvm_write_wall_clock\n- 参数: [struct kvm *kvm, gpa + wc_ofs, sec_hi_ofs - wc_ofs]\n- 调用者: kvm_xen_shared_info_init\n- 被调用者: 未显示（内核函数）\n\n6. 函数名: kvm_make_all_cpus_request\n- 参数: [struct kvm *kvm, KVM_REQ_MASTERCLOCK_UPDATE]\n- 调用者: kvm_xen_shared_info_init\n- 被调用者: 未显示（内核函数）\n\n7. 函数名: srcu_read_unlock\n- 参数: [&kvm->srcu, idx]\n- 调用者: kvm_xen_shared_info_init\n- 被调用者: 未显示（内核函数）"
    },
    {
        "id": 3173,
        "cwe": "CWE-476",
        "cve": "CVE-2021-44879",
        "purpose": "Code purpose:\"\"\"该代码片段实现了Linux内核中F2FS文件系统的垃圾回收功能，主要处理数据段的垃圾收集操作，包括读取、验证和移动数据块等步骤。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理特殊文件时未进行充分检查，导致在move_data_page操作中出现空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: gc_data_segment\n- 参数: [sbi, sum, gc_list, segno, gc_type, force_migrate]\n- 调用者: N/A\n- 被调用者: [f2fs_usable_blks_in_seg, START_BLOCK, le32_to_cpu, has_not_enough_free_secs, get_valid_blocks, check_valid_map, f2fs_ra_meta_pages, f2fs_ra_node_page, is_alive, le16_to_cpu, f2fs_iget, down_write_trylock, iput, f2fs_start_bidx_of_node, ra_data_block, up_write, add_gc_inode, f2fs_get_read_data_page, f2fs_put_page, find_gc_inode, inode_dio_wait, move_data_block, move_data_page, stat_inc_data_blk_count]\n\n2. 函数名: f2fs_usable_blks_in_seg\n- 参数: [sbi, segno]\n- 调用者: gc_data_segment\n- 被调用者: N/A\n\n3. 函数名: START_BLOCK\n- 参数: [sbi, segno]\n- 调用者: gc_data_segment\n- 被调用者: N/A\n\n4. 函数名: le32_to_cpu\n- 参数: [entry->nid]\n- 调用者: gc_data_segment\n- 被调用者: N/A\n\n5. 函数名: has_not_enough_free_secs\n- 参数: [sbi, 0, 0]\n- 调用者: gc_data_segment\n- 被调用者: N/A\n\n6. 函数名: get_valid_blocks\n- 参数: [sbi, segno, true]\n- 调用者: gc_data_segment\n- 被调用者: N/A\n\n7. 函数名: check_valid_map\n- 参数: [sbi, segno, off]\n- 调用者: gc_data_segment\n- 被调用者: N/A\n\n8. 函数名: f2fs_ra_meta_pages\n- 参数: [sbi, NAT_BLOCK_OFFSET(nid), 1, META_NAT, true]\n- 调用者: gc_data_segment\n- 被调用者: N/A\n\n9. 函数名: f2fs_ra_node_page\n- 参数: [sbi, nid]\n- 调用者: gc_data_segment\n- 被调用者: N/A\n\n10. 函数名: is_alive\n- 参数: [sbi, entry, &dni, start_addr + off, &nofs]\n- 调用者: gc_data_segment\n- 被调用者: N/A\n\n11. 函数名: le16_to_cpu\n- 参数: [entry->ofs_in_node]\n- 调用者: gc_data_segment\n- 被调用者: N/A\n\n12. 函数名: f2fs_iget\n- 参数: [sb, dni.ino]\n- 调用者: gc_data_segment\n- 被调用者: N/A\n\n13. 函数名: down_write_trylock\n- 参数: [&F2FS_I(inode)->i_gc_rwsem[WRITE]]\n- 调用者: gc_data_segment\n- 被调用者: N/A\n\n14. 函数名: iput\n- 参数: [inode]\n- 调用者: gc_data_segment\n- 被调用者: N/A\n\n15. 函数名: f2fs_start_bidx_of_node\n- 参数: [nofs, inode]\n- 调用者: gc_data_segment\n- 被调用者: N/A\n\n16. 函数名: ra_data_block\n- 参数: [inode, start_bidx]\n- 调用者: gc_data_segment\n- 被调用者: N/A\n\n17. 函数名: up_write\n- 参数: [&F2FS_I(inode)->i_gc_rwsem[WRITE]]\n- 调用者: gc_data_segment\n- 被调用者: N/A\n\n18. 函数名: add_gc_inode\n- 参数: [gc_list, inode]\n- 调用者: gc_data_segment\n- 被调用者: N/A\n\n19. 函数名: f2fs_get_read_data_page\n- 参数: [inode, start_bidx, REQ_RAHEAD, true]\n- 调用者: gc_data_segment\n- 被调用者: N/A\n\n20. 函数名: f2fs_put_page\n- 参数: [data_page, 0]\n- 调用者: gc_data_segment\n- 被调用者: N/A\n\n21. 函数名: find_gc_inode\n- 参数: [gc_list, dni.ino]\n- 调用者: gc_data_segment\n- 被调用者: N/A\n\n22. 函数名: inode_dio_wait\n- 参数: [inode]\n- 调用者: gc_data_segment\n- 被调用者: N/A\n\n23. 函数名: move_data_block\n- 参数: [inode, start_bidx, gc_type, segno, off]\n- 调用者: gc_data_segment\n- 被调用者: N/A\n\n24. 函数名: move_data_page\n- 参数: [inode, start_bidx, gc_type, segno, off]\n- 调用者: gc_data_segment\n- 被调用者: N/A\n\n25. 函数名: stat_inc_data_blk_count\n- 参数: [sbi, 1, gc_type]\n- 调用者: gc_data_segment\n- 被调用者: N/A"
    },
    {
        "id": 3190,
        "cwe": "CWE-476",
        "cve": "CVE-2022-0168",
        "purpose": "Code purpose:\"\"\"处理SMB2协议中的IOCTL查询信息请求，包括打开文件、查询/设置文件信息和关闭文件等操作，并将结果返回给用户空间。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于memdup_user函数返回错误时未正确处理，导致本地特权用户(CAP_SYS_ADMIN)可利用此漏洞造成系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: smb2_ioctl_query_info\n- 参数: [xid, tcon, cifs_sb, path, is_dir, p]\n- 调用者: N/A (top-level function)\n- 被调用者: [kzalloc, kfree, copy_from_user, smb3_encryption_required, memdup_user, SMB2_open_init, smb2_set_next_command, capable, SMB2_ioctl_init, SMB2_set_info_init, SMB2_query_info_init, cifs_tcon_dbg, SMB2_close_init, compound_send_recv, copy_to_user, cifs_small_buf_release, free_rsp_buf]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*vars), GFP_ATOMIC]\n- 调用者: smb2_ioctl_query_info\n- 被调用者: N/A\n\n3. 函数名: kfree\n- 参数: [vars]\n- 调用者: smb2_ioctl_query_info\n- 被调用者: N/A\n\n4. 函数名: copy_from_user\n- 参数: [&qi, arg, sizeof(struct smb_query_info)]\n- 调用者: smb2_ioctl_query_info\n- 被调用者: N/A\n\n5. 函数名: smb3_encryption_required\n- 参数: [tcon]\n- 调用者: smb2_ioctl_query_info\n- 被调用者: N/A\n\n6. 函数名: memdup_user\n- 参数: [arg + sizeof(struct smb_query_info), qi.output_buffer_length]\n- 调用者: smb2_ioctl_query_info\n- 被调用者: N/A\n\n7. 函数名: SMB2_open_init\n- 参数: [tcon, server, &rqst[0], &oplock, &oparms, path]\n- 调用者: smb2_ioctl_query_info\n- 被调用者: N/A\n\n8. 函数名: smb2_set_next_command\n- 参数: [tcon, &rqst[0]]\n- 调用者: smb2_ioctl_query_info\n- 被调用者: N/A\n\n9. 函数名: capable\n- 参数: [CAP_SYS_ADMIN]\n- 调用者: smb2_ioctl_query_info\n- 被调用者: N/A\n\n10. 函数名: SMB2_ioctl_init\n- 参数: [tcon, server, &rqst[1], COMPOUND_FID, COMPOUND_FID, qi.info_type, true, buffer, qi.output_buffer_length, CIFSMaxBufSize - MAX_SMB2_CREATE_RESPONSE_SIZE - MAX_SMB2_CLOSE_RESPONSE_SIZE]\n- 调用者: smb2_ioctl_query_info\n- 被调用者: N/A\n\n11. 函数名: SMB2_set_info_init\n- 参数: [tcon, server, &rqst[1], COMPOUND_FID, COMPOUND_FID, current->tgid, FILE_END_OF_FILE_INFORMATION, SMB2_O_INFO_FILE, 0, data, size]\n- 调用者: smb2_ioctl_query_info\n- 被调用者: N/A\n\n12. 函数名: SMB2_query_info_init\n- 参数: [tcon, server, &rqst[1], COMPOUND_FID, COMPOUND_FID, qi.file_info_class, qi.info_type, qi.additional_information, qi.input_buffer_length, qi.output_buffer_length, buffer]\n- 调用者: smb2_ioctl_query_info\n- 被调用者: N/A\n\n13. 函数名: cifs_tcon_dbg\n- 参数: [VFS, \"Invalid passthru query flags: 0x%x\\n\", qi.flags]\n- 调用者: smb2_ioctl_query_info\n- 被调用者: N/A\n\n14. 函数名: SMB2_close_init\n- 参数: [tcon, server, &rqst[2], COMPOUND_FID, COMPOUND_FID, false]\n- 调用者: smb2_ioctl_query_info\n- 被调用者: N/A\n\n15. 函数名: compound_send_recv\n- 参数: [xid, ses, server, flags, 3, rqst, resp_buftype, rsp_iov]\n- 调用者: smb2_ioctl_query_info\n- 被调用者: N/A\n\n16. 函数名: copy_to_user\n- 参数: [&pqi->input_buffer_length, &qi.input_buffer_length, sizeof(qi.input_buffer_length)]\n- 调用者: smb2_ioctl_query_info\n- 被调用者: N/A\n\n17. 函数名: cifs_small_buf_release\n- 参数: [rqst[0].rq_iov[0].iov_base]\n- 调用者: smb2_ioctl_query_info\n- 被调用者: N/A\n\n18. 函数名: free_rsp_buf\n- 参数: [resp_buftype[0], rsp_iov[0].iov_base]\n- 调用者: smb2_ioctl_query_info\n- 被调用者: N/A"
    },
    {
        "id": 3215,
        "cwe": "CWE-476",
        "cve": "CVE-2022-0617",
        "purpose": "Code purpose:\"\"\"该代码用于处理UDF文件系统中文件的扩展操作，包括内存页的分配、数据拷贝和同步写回，以支持文件从内联存储转换为常规存储模式。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当处理恶意构造的UDF镜像时，由于未充分验证指针有效性，导致在udf_file_write_iter函数中可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: udf_expand_file_adinicb\n- 参数: [struct inode *inode]\n- 调用者: 未明确（应为外部调用）\n- 被调用者: [inode_is_locked, UDF_QUERY_FLAG, up_write, mark_inode_dirty, find_or_create_page, kmap_atomic, memset, memcpy, flush_dcache_page, SetPageUptodate, kunmap_atomic, down_write, writepage, lock_page, unlock_page, put_page]\n\n2. 函数名: inode_is_locked\n- 参数: [struct inode *inode]\n- 调用者: udf_expand_file_adinicb\n- 被调用者: []\n\n3. 函数名: UDF_QUERY_FLAG\n- 参数: [struct super_block *sb, int flag]\n- 调用者: udf_expand_file_adinicb\n- 被调用者: []\n\n4. 函数名: up_write\n- 参数: [struct rw_semaphore *sem]\n- 调用者: udf_expand_file_adinicb\n- 被调用者: []\n\n5. 函数名: mark_inode_dirty\n- 参数: [struct inode *inode]\n- 调用者: udf_expand_file_adinicb\n- 被调用者: []\n\n6. 函数名: find_or_create_page\n- 参数: [struct address_space *mapping, pgoff_t index, gfp_t gfp_mask]\n- 调用者: udf_expand_file_adinicb\n- 被调用者: []\n\n7. 函数名: kmap_atomic\n- 参数: [struct page *page]\n- 调用者: udf_expand_file_adinicb\n- 被调用者: []\n\n8. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: udf_expand_file_adinicb\n- 被调用者: []\n\n9. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: udf_expand_file_adinicb\n- 被调用者: []\n\n10. 函数名: flush_dcache_page\n- 参数: [struct page *page]\n- 调用者: udf_expand_file_adinicb\n- 被调用者: []\n\n11. 函数名: SetPageUptodate\n- 参数: [struct page *page]\n- 调用者: udf_expand_file_adinicb\n- 被调用者: []\n\n12. 函数名: kunmap_atomic\n- 参数: [void *addr]\n- 调用者: udf_expand_file_adinicb\n- 被调用者: []\n\n13. 函数名: down_write\n- 参数: [struct rw_semaphore *sem]\n- 调用者: udf_expand_file_adinicb\n- 被调用者: []\n\n14. 函数名: writepage\n- 参数: [struct page *page, struct writeback_control *wbc]\n- 调用者: udf_expand_file_adinicb\n- 被调用者: []\n\n15. 函数名: lock_page\n- 参数: [struct page *page]\n- 调用者: udf_expand_file_adinicb\n- 被调用者: []\n\n16. 函数名: unlock_page\n- 参数: [struct page *page]\n- 调用者: udf_expand_file_adinicb\n- 被调用者: []\n\n17. 函数名: put_page\n- 参数: [struct page *page]\n- 调用者: udf_expand_file_adinicb\n- 被调用者: []"
    },
    {
        "id": 3255,
        "cwe": "CWE-476",
        "cve": "CVE-2022-1205",
        "purpose": "Code purpose:\"\"\"在AX.25协议实现中，当网络设备被移除时，清理与该设备相关的所有连接和资源。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在检查sk->sk_socket是否为NULL之前，代码未验证ax25_dev->dev是否有效，可能导致NULL指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: ax25_kill_by_device\n- 参数: [struct net_device *dev]\n- 调用者: 无（顶级函数）\n- 被调用者: [ax25_dev_ax25dev, spin_lock_bh, ax25_for_each, spin_unlock_bh, ax25_disconnect, sock_hold, lock_sock, dev_put_track, ax25_dev_put, release_sock, sock_put]\n\n2. 函数名: ax25_dev_ax25dev\n- 参数: [struct net_device *dev]\n- 调用者: ax25_kill_by_device\n- 被调用者: 无\n\n3. 函数名: spin_lock_bh\n- 参数: [&ax25_list_lock]\n- 调用者: ax25_kill_by_device\n- 被调用者: 无\n\n4. 函数名: ax25_for_each\n- 参数: [s, &ax25_list]\n- 调用者: ax25_kill_by_device\n- 被调用者: 无\n\n5. 函数名: spin_unlock_bh\n- 参数: [&ax25_list_lock]\n- 调用者: ax25_kill_by_device\n- 被调用者: 无\n\n6. 函数名: ax25_disconnect\n- 参数: [s, ENETUNREACH]\n- 调用者: ax25_kill_by_device\n- 被调用者: 无\n\n7. 函数名: sock_hold\n- 参数: [sk]\n- 调用者: ax25_kill_by_device\n- 被调用者: 无\n\n8. 函数名: lock_sock\n- 参数: [sk]\n- 调用者: ax25_kill_by_device\n- 被调用者: 无\n\n9. 函数名: dev_put_track\n- 参数: [ax25_dev->dev, &ax25_dev->dev_tracker]\n- 调用者: ax25_kill_by_device\n- 被调用者: 无\n\n10. 函数名: ax25_dev_put\n- 参数: [ax25_dev]\n- 调用者: ax25_kill_by_device\n- 被调用者: 无\n\n11. 函数名: release_sock\n- 参数: [sk]\n- 调用者: ax25_kill_by_device\n- 被调用者: 无\n\n12. 函数名: sock_put\n- 参数: [sk]\n- 调用者: ax25_kill_by_device\n- 被调用者: 无"
    },
    {
        "id": 3256,
        "cwe": "CWE-476",
        "cve": "CVE-2022-1205",
        "purpose": "Code purpose:\"\"\"该代码用于处理AX.25协议连接的断开操作，包括清理队列、停止各种定时器、更新连接状态并通知套接字状态变更\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ax25_disconnect函数中，当ax25->sk为NULL时，未进行充分检查就直接访问ax25->sk的成员，导致空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ax25_disconnect\n- 参数: [ax25_cb *ax25, int reason]\n- 调用者: 不适用（顶层函数）\n- 被调用者: [ax25_clear_queues, sock_flag, ax25_stop_heartbeat, ax25_stop_t1timer, ax25_stop_t2timer, ax25_stop_t3timer, ax25_stop_idletimer, ax25_link_failed, local_bh_disable, bh_lock_sock, sock_set_flag, bh_unlock_sock, local_bh_enable]\n\n2. 函数名: ax25_clear_queues\n- 参数: [ax25_cb *ax25]\n- 调用者: ax25_disconnect\n- 被调用者: []\n\n3. 函数名: sock_flag\n- 参数: [struct sock *sk, SOCK_DESTROY/SOCK_DEAD]\n- 调用者: ax25_disconnect\n- 被调用者: []\n\n4. 函数名: ax25_stop_heartbeat\n- 参数: [ax25_cb *ax25]\n- 调用者: ax25_disconnect\n- 被调用者: []\n\n5. 函数名: ax25_stop_t1timer\n- 参数: [ax25_cb *ax25]\n- 调用者: ax25_disconnect\n- 被调用者: []\n\n6. 函数名: ax25_stop_t2timer\n- 参数: [ax25_cb *ax25]\n- 调用者: ax25_disconnect\n- 被调用者: []\n\n7. 函数名: ax25_stop_t3timer\n- 参数: [ax25_cb *ax25]\n- 调用者: ax25_disconnect\n- 被调用者: []\n\n8. 函数名: ax25_stop_idletimer\n- 参数: [ax25_cb *ax25]\n- 调用者: ax25_disconnect\n- 被调用者: []\n\n9. 函数名: ax25_link_failed\n- 参数: [ax25_cb *ax25, int reason]\n- 调用者: ax25_disconnect\n- 被调用者: []\n\n10. 函数名: local_bh_disable\n- 参数: []\n- 调用者: ax25_disconnect\n- 被调用者: []\n\n11. 函数名: bh_lock_sock\n- 参数: [struct sock *sk]\n- 调用者: ax25_disconnect\n- 被调用者: []\n\n12. 函数名: sock_set_flag\n- 参数: [struct sock *sk, SOCK_DEAD]\n- 调用者: ax25_disconnect\n- 被调用者: []\n\n13. 函数名: bh_unlock_sock\n- 参数: [struct sock *sk]\n- 调用者: ax25_disconnect\n- 被调用者: []\n\n14. 函数名: local_bh_enable\n- 参数: []\n- 调用者: ax25_disconnect\n- 被调用者: []"
    },
    {
        "id": 3257,
        "cwe": "CWE-476",
        "cve": "CVE-2022-1263",
        "purpose": "Code purpose:\"\"\"释放KVM虚拟CPU资源并清理相关数据结构\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放带有脏环支持的vCPU时，未正确处理空指针解引用问题，导致内核异常和拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: kvm_vcpu_destroy\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: 未指定\n- 被调用者: [kvm_dirty_ring_free, kvm_arch_vcpu_destroy, rcu_dereference_protected, put_pid, free_page, kmem_cache_free]\n\n2. 函数名: kvm_dirty_ring_free\n- 参数: [&vcpu->dirty_ring]\n- 调用者: kvm_vcpu_destroy\n- 被调用者: 未指定\n\n3. 函数名: kvm_arch_vcpu_destroy\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: kvm_vcpu_destroy\n- 被调用者: 未指定\n\n4. 函数名: rcu_dereference_protected\n- 参数: [vcpu->pid, 1]\n- 调用者: kvm_vcpu_destroy\n- 被调用者: 未指定\n\n5. 函数名: put_pid\n- 参数: [rcu_dereference_protected(vcpu->pid, 1)]\n- 调用者: kvm_vcpu_destroy\n- 被调用者: 未指定\n\n6. 函数名: free_page\n- 参数: [(unsigned long)vcpu->run]\n- 调用者: kvm_vcpu_destroy\n- 被调用者: 未指定\n\n7. 函数名: kmem_cache_free\n- 参数: [kvm_vcpu_cache, vcpu]\n- 调用者: kvm_vcpu_destroy\n- 被调用者: 未指定"
    },
    {
        "id": 3264,
        "cwe": "CWE-476",
        "cve": "CVE-2022-1516",
        "purpose": "Code purpose:\"\"\"该代码用于在X.25网络协议中，当邻居节点不可达时，终止所有通过该邻居建立的连接并清除相关转发条目。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在x25_kill_by_neigh函数中，当nb->dev为NULL时，调用x25_clear_forward_by_dev函数会导致空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: x25_kill_by_neigh\n- 参数: [struct x25_neigh *nb]\n- 调用者: 未指定（外部调用）\n- 被调用者: [write_lock_bh, sk_for_each, x25_sk, x25_disconnect, write_unlock_bh, x25_clear_forward_by_dev]\n\n2. 函数名: write_lock_bh\n- 参数: [&x25_list_lock]\n- 调用者: x25_kill_by_neigh\n- 被调用者: 未指定（系统/内核函数）\n\n3. 函数名: sk_for_each\n- 参数: [s, &x25_list]\n- 调用者: x25_kill_by_neigh\n- 被调用者: 未指定（宏/内核函数）\n\n4. 函数名: x25_sk\n- 参数: [s]\n- 调用者: x25_kill_by_neigh\n- 被调用者: 未指定（内核函数）\n\n5. 函数名: x25_disconnect\n- 参数: [s, ENETUNREACH, 0, 0]\n- 调用者: x25_kill_by_neigh\n- 被调用者: 未指定（内核函数）\n\n6. 函数名: write_unlock_bh\n- 参数: [&x25_list_lock]\n- 调用者: x25_kill_by_neigh\n- 被调用者: 未指定（系统/内核函数）\n\n7. 函数名: x25_clear_forward_by_dev\n- 参数: [nb->dev]\n- 调用者: x25_kill_by_neigh\n- 被调用者: 未指定（内核函数）"
    },
    {
        "id": 3271,
        "cwe": "CWE-476",
        "cve": "CVE-2022-1671",
        "purpose": "Code purpose:\"\"\"该代码片段用于销毁服务器密钥，通过调用安全模块的destroy_server_key函数来清理密钥资源。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在未验证key->payload.data[1]是否为NULL的情况下直接访问其成员，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: rxrpc_destroy_s\n- 参数: [key]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [sec->destroy_server_key]\n\n2. 函数名: destroy_server_key\n- 参数: [key]\n- 调用者: rxrpc_destroy_s\n- 被调用者: 未明确（上下文未提供）"
    },
    {
        "id": 3272,
        "cwe": "CWE-476",
        "cve": "CVE-2022-1671",
        "purpose": "Code purpose:\"\"\"该代码用于解析并准备服务器密钥的安全相关信息，包括服务号和安全类别的提取与验证\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在rxrpc_preparse_s函数中，当sec->preparse_server_key为NULL时未进行检查就直接调用，导致空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: rxrpc_preparse_s\n- 参数: [struct key_preparsed_payload *prep]\n- 调用者: 未明确（由内核调用）\n- 被调用者: [rxrpc_security_lookup, sec->preparse_server_key]\n\n2. 函数名: rxrpc_security_lookup\n- 参数: [unsigned int sec_class]\n- 调用者: rxrpc_preparse_s\n- 被调用者: []\n\n3. 函数名: sec->preparse_server_key\n- 参数: [struct key_preparsed_payload *prep]\n- 调用者: rxrpc_preparse_s\n- 被调用者: []"
    },
    {
        "id": 3273,
        "cwe": "CWE-476",
        "cve": "CVE-2022-1671",
        "purpose": "Code purpose:\"\"\"释放服务器密钥预处理结构体时检查并调用安全模块的释放函数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在rxrpc_free_preparse_s函数中，当sec指针为NULL时未进行检查就直接调用其成员函数，导致空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: rxrpc_free_preparse_s\n- 参数: [prep]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [sec->free_preparse_server_key]\n\n2. 函数名: free_preparse_server_key\n- 参数: [prep]\n- 调用者: rxrpc_free_preparse_s\n- 被调用者: 未明确（由安全模块实现）"
    },
    {
        "id": 3292,
        "cwe": "CWE-476",
        "cve": "CVE-2022-1789",
        "purpose": "Code purpose:\"\"\"该代码用于处理虚拟机的INVPCID指令，通过无效化指定GVA的TLB条目来维护内存管理单元的正确性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当CR0.PG=0时执行INVPCID指令导致invlpg回调未设置，引发空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: kvm_mmu_invpcid_gva\n- 参数: [vcpu, gva, pcid]\n- 调用者: INVPCID instruction handler (when shadow paging is enabled)\n- 被调用者: [kvm_get_active_pcid, mmu->invlpg, kvm_get_pcid, static_call(kvm_x86_flush_tlb_gva)]\n\n2. 函数名: kvm_get_active_pcid\n- 参数: [vcpu]\n- 调用者: kvm_mmu_invpcid_gva\n- 被调用者: []\n\n3. 函数名: kvm_get_pcid\n- 参数: [vcpu, mmu->prev_roots[i].pgd]\n- 调用者: kvm_mmu_invpcid_gva\n- 被调用者: []\n\n4. 函数名: mmu->invlpg\n- 参数: [vcpu, gva, mmu->root.hpa] or [vcpu, gva, mmu->prev_roots[i].hpa]\n- 调用者: kvm_mmu_invpcid_gva\n- 被调用者: []\n\n5. 函数名: static_call(kvm_x86_flush_tlb_gva)\n- 参数: [vcpu, gva]\n- 调用者: kvm_mmu_invpcid_gva\n- 被调用者: []"
    },
    {
        "id": 3294,
        "cwe": "CWE-476",
        "cve": "CVE-2022-1852",
        "purpose": "Code purpose:\"\"\"模拟执行x86指令并处理相关异常，用于KVM虚拟化环境中的指令仿真\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在模拟执行x86指令时未正确处理非法指令导致的空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: x86_emulate_instruction\n- 参数: [vcpu, cr2_or_gpa, emulation_type, insn, insn_len]\n- 调用者: N/A (top-level function)\n- 被调用者: [kvm_can_emulate_insn, kvm_clear_exception_queue, x86_decode_emulated_instruction, kvm_queue_exception, reexecute_instruction, inject_emulated_exception, handle_emulation_failure, is_vmware_backdoor_opcode, kvm_queue_exception_e, kvm_rip_write, kvm_set_rflags, retry_instruction, emulator_invalidate_register_cache, x86_emulate_insn, static_call(kvm_x86_get_rflags), toggle_interruptibility, kvm_pmu_trigger_event, kvm_vcpu_do_singlestep, static_call_cond(kvm_x86_update_emulated_instruction), __kvm_set_rflags, kvm_make_request]\n\n2. 函数名: kvm_can_emulate_insn\n- 参数: [vcpu, emulation_type, insn, insn_len]\n- 调用者: x86_emulate_instruction\n- 被调用者: []\n\n3. 函数名: kvm_clear_exception_queue\n- 参数: [vcpu]\n- 调用者: x86_emulate_instruction\n- 被调用者: []\n\n4. 函数名: x86_decode_emulated_instruction\n- 参数: [vcpu, emulation_type, insn, insn_len]\n- 调用者: x86_emulate_instruction\n- 被调用者: []\n\n5. 函数名: kvm_queue_exception\n- 参数: [vcpu, UD_VECTOR]\n- 调用者: x86_emulate_instruction\n- 被调用者: []\n\n6. 函数名: reexecute_instruction\n- 参数: [vcpu, cr2_or_gpa, write_fault_to_spt, emulation_type]\n- 调用者: x86_emulate_instruction\n- 被调用者: []\n\n7. 函数名: inject_emulated_exception\n- 参数: [vcpu]\n- 调用者: x86_emulate_instruction\n- 被调用者: []\n\n8. 函数名: handle_emulation_failure\n- 参数: [vcpu, emulation_type]\n- 调用者: x86_emulate_instruction\n- 被调用者: []\n\n9. 函数名: is_vmware_backdoor_opcode\n- 参数: [ctxt]\n- 调用者: x86_emulate_instruction\n- 被调用者: []\n\n10. 函数名: kvm_queue_exception_e\n- 参数: [vcpu, GP_VECTOR, 0]\n- 调用者: x86_emulate_instruction\n- 被调用者: []\n\n11. 函数名: kvm_rip_write\n- 参数: [vcpu, ctxt->eip]\n- 调用者: x86_emulate_instruction\n- 被调用者: []\n\n12. 函数名: kvm_set_rflags\n- 参数: [vcpu, ctxt->eflags & ~X86_EFLAGS_RF]\n- 调用者: x86_emulate_instruction\n- 被调用者: []\n\n13. 函数名: retry_instruction\n- 参数: [ctxt, cr2_or_gpa, emulation_type]\n- 调用者: x86_emulate_instruction\n- 被调用者: []\n\n14. 函数名: emulator_invalidate_register_cache\n- 参数: [ctxt]\n- 调用者: x86_emulate_instruction\n- 被调用者: []\n\n15. 函数名: x86_emulate_insn\n- 参数: [ctxt]\n- 调用者: x86_emulate_instruction\n- 被调用者: []\n\n16. 函数名: static_call(kvm_x86_get_rflags)\n- 参数: [vcpu]\n- 调用者: x86_emulate_instruction\n- 被调用者: []\n\n17. 函数名: toggle_interruptibility\n- 参数: [vcpu, ctxt->interruptibility]\n- 调用者: x86_emulate_instruction\n- 被调用者: []\n\n18. 函数名: kvm_pmu_trigger_event\n- 参数: [vcpu, PERF_COUNT_HW_INSTRUCTIONS] or [vcpu, PERF_COUNT_HW_BRANCH_INSTRUCTIONS]\n- 调用者: x86_emulate_instruction\n- 被调用者: []\n\n19. 函数名: kvm_vcpu_do_singlestep\n- 参数: [vcpu]\n- 调用者: x86_emulate_instruction\n- 被调用者: []\n\n20. 函数名: static_call_cond(kvm_x86_update_emulated_instruction)\n- 参数: [vcpu]\n- 调用者: x86_emulate_instruction\n- 被调用者: []\n\n21. 函数名: __kvm_set_rflags\n- 参数: [vcpu, ctxt->eflags]\n- 调用者: x86_emulate_instruction\n- 被调用者: []\n\n22. 函数名: kvm_make_request\n- 参数: [KVM_REQ_EVENT, vcpu]\n- 调用者: x86_emulate_instruction\n- 被调用者: []"
    },
    {
        "id": 3295,
        "cwe": "CWE-476",
        "cve": "CVE-2022-1852",
        "purpose": "Code purpose:\"\"\"该代码用于在KVM虚拟化环境中解码并模拟执行x86客户机指令，处理断点检查并记录模拟执行状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在x86_decode_emulated_instruction函数中，当处理非法指令时未对ctxt指针进行空指针检查，导致空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: x86_decode_emulated_instruction\n- 参数: [struct kvm_vcpu *vcpu, int emulation_type, void *insn, int insn_len]\n- 调用者: 未明确显示（由外部调用）\n- 被调用者: [init_emulate_ctxt, kvm_vcpu_check_breakpoint, x86_decode_insn, trace_kvm_emulate_insn_start]\n\n2. 函数名: init_emulate_ctxt\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: x86_decode_emulated_instruction\n- 被调用者: []\n\n3. 函数名: kvm_vcpu_check_breakpoint\n- 参数: [struct kvm_vcpu *vcpu, int *r]\n- 调用者: x86_decode_emulated_instruction\n- 被调用者: []\n\n4. 函数名: x86_decode_insn\n- 参数: [struct x86_emulate_ctxt *ctxt, void *insn, int insn_len, int emulation_type]\n- 调用者: x86_decode_emulated_instruction\n- 被调用者: []\n\n5. 函数名: trace_kvm_emulate_insn_start\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: x86_decode_emulated_instruction\n- 被调用者: []"
    },
    {
        "id": 3413,
        "cwe": "CWE-476",
        "cve": "CVE-2022-2153",
        "purpose": "Code purpose:\"\"\"该代码用于快速将中断请求(IRQ)传递给目标APIC(高级可编程中断控制器)，处理虚拟机的虚拟中断传递，并可能涉及自中断或向多个目标APIC传递中断的场景。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在KVM处理SynIC IRQ时，由于未充分验证VMM对SYNIC/STIMER MSRs的写入操作，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: kvm_irq_delivery_to_apic_fast\n- 参数: [kvm, src, irq, r, dest_map]\n- 调用者: N/A\n- 被调用者: [kvm_apic_set_irq, rcu_read_lock, rcu_dereference, kvm_apic_map_get_dest_lapic, for_each_set_bit, rcu_read_unlock]\n\n2. 函数名: kvm_apic_set_irq\n- 参数: [vcpu, irq, dest_map]\n- 调用者: kvm_irq_delivery_to_apic_fast\n- 被调用者: N/A\n\n3. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: kvm_irq_delivery_to_apic_fast\n- 被调用者: N/A\n\n4. 函数名: rcu_dereference\n- 参数: [kvm->arch.apic_map]\n- 调用者: kvm_irq_delivery_to_apic_fast\n- 被调用者: N/A\n\n5. 函数名: kvm_apic_map_get_dest_lapic\n- 参数: [kvm, &src, irq, map, &dst, &bitmap]\n- 调用者: kvm_irq_delivery_to_apic_fast\n- 被调用者: N/A\n\n6. 函数名: for_each_set_bit\n- 参数: [i, &bitmap, 16]\n- 调用者: kvm_irq_delivery_to_apic_fast\n- 被调用者: N/A\n\n7. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: kvm_irq_delivery_to_apic_fast\n- 被调用者: N/A"
    },
    {
        "id": 3440,
        "cwe": "CWE-476",
        "cve": "CVE-2022-23222",
        "purpose": "Code purpose:\"\"\"该代码用于验证和调整BPF程序对内核函数参数的访问权限，确保指针操作的安全性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中某些_OR_NULL指针类型允许进行指针算术运算，导致本地用户可利用此漏洞提升权限\"\"\"",
        "functions": "Functions:\n1. 函数名: btf_ctx_access\n- 参数: [off, size, type, prog, info]\n- 调用者: 未明确显示（可能是BPF验证器调用）\n- 被调用者: [bpf_log, bpf_prog_get_target_btf, btf_type_vlen, btf_type_by_id, btf_type_skip_modifiers, btf_type_is_small_int, btf_type_is_enum, btf_type_is_ptr, btf_type_is_modifier, __btf_name_by_offset, is_int_ptr, btf_translate_to_vmlinux, btf_type_is_struct]\n\n2. 函数名: bpf_log\n- 参数: [log, format, ...]\n- 调用者: btf_ctx_access\n- 被调用者: []\n\n3. 函数名: bpf_prog_get_target_btf\n- 参数: [prog]\n- 调用者: btf_ctx_access\n- 被调用者: []\n\n4. 函数名: btf_type_vlen\n- 参数: [t]\n- 调用者: btf_ctx_access\n- 被调用者: []\n\n5. 函数名: btf_type_by_id\n- 参数: [btf, type_id]\n- 调用者: btf_ctx_access\n- 被调用者: []\n\n6. 函数名: btf_type_skip_modifiers\n- 参数: [btf, type_id, NULL]\n- 调用者: btf_ctx_access\n- 被调用者: []\n\n7. 函数名: btf_type_is_small_int\n- 参数: [t]\n- 调用者: btf_ctx_access\n- 被调用者: []\n\n8. 函数名: btf_type_is_enum\n- 参数: [t]\n- 调用者: btf_ctx_access\n- 被调用者: []\n\n9. 函数名: btf_type_is_ptr\n- 参数: [t]\n- 调用者: btf_ctx_access\n- 被调用者: []\n\n10. 函数名: btf_type_is_modifier\n- 参数: [t]\n- 调用者: btf_ctx_access\n- 被调用者: []\n\n11. 函数名: __btf_name_by_offset\n- 参数: [btf, name_off]\n- 调用者: btf_ctx_access\n- 被调用者: []\n\n12. 函数名: is_int_ptr\n- 参数: [btf, t]\n- 调用者: btf_ctx_access\n- 被调用者: []\n\n13. 函数名: btf_translate_to_vmlinux\n- 参数: [log, btf, t, tgt_type, arg]\n- 调用者: btf_ctx_access\n- 被调用者: []\n\n14. 函数名: btf_type_is_struct\n- 参数: [t]\n- 调用者: btf_ctx_access\n- 被调用者: []"
    },
    {
        "id": 3441,
        "cwe": "CWE-476",
        "cve": "CVE-2022-23222",
        "purpose": "Code purpose:\"\"\"该代码用于验证BPF程序中的条件跳转指令，检查寄存器状态并确定分支路径，防止指针算术操作导致的安全问题\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中某些_OR_NULL指针类型允许进行指针算术运算，导致本地用户可利用此漏洞提升权限\"\"\"",
        "functions": "Functions:\n1. 函数名: check_cond_jmp_op\n- 参数: [struct bpf_verifier_env *env, struct bpf_insn *insn, int *insn_idx]\n- 调用者: N/A\n- 被调用者: [verbose, check_reg_arg, is_pointer_value, is_branch_taken, is_pkt_ptr_branch_taken, __is_pointer_value, mark_chain_precision, sanitize_speculative_path, push_stack, reg_set_min_max, reg_set_min_max_inv, reg_combine_min_max, find_equal_scalars, mark_ptr_or_null_regs, try_match_pkt_pointers, print_insn_state]\n\n2. 函数名: verbose\n- 参数: [struct bpf_verifier_env *env, const char *fmt, ...]\n- 调用者: check_cond_jmp_op\n- 被调用者: N/A\n\n3. 函数名: check_reg_arg\n- 参数: [struct bpf_verifier_env *env, u32 regno, enum reg_arg_type type]\n- 调用者: check_cond_jmp_op\n- 被调用者: N/A\n\n4. 函数名: is_pointer_value\n- 参数: [struct bpf_verifier_env *env, int regno]\n- 调用者: check_cond_jmp_op\n- 被调用者: N/A\n\n5. 函数名: is_branch_taken\n- 参数: [struct bpf_reg_state *reg, u64 val, u8 opcode, bool is_jmp32]\n- 调用者: check_cond_jmp_op\n- 被调用者: N/A\n\n6. 函数名: is_pkt_ptr_branch_taken\n- 参数: [struct bpf_reg_state *dst_reg, struct bpf_reg_state *src_reg, u8 opcode]\n- 调用者: check_cond_jmp_op\n- 被调用者: N/A\n\n7. 函数名: __is_pointer_value\n- 参数: [bool allow_ptr_leaks, struct bpf_reg_state *reg]\n- 调用者: check_cond_jmp_op\n- 被调用者: N/A\n\n8. 函数名: mark_chain_precision\n- 参数: [struct bpf_verifier_env *env, u32 regno]\n- 调用者: check_cond_jmp_op\n- 被调用者: N/A\n\n9. 函数名: sanitize_speculative_path\n- 参数: [struct bpf_verifier_env *env, struct bpf_insn *insn, int next_idx, int insn_idx]\n- 调用者: check_cond_jmp_op\n- 被调用者: N/A\n\n10. 函数名: push_stack\n- 参数: [struct bpf_verifier_env *env, int insn_idx, int prev_insn_idx, bool speculative]\n- 调用者: check_cond_jmp_op\n- 被调用者: N/A\n\n11. 函数名: reg_set_min_max\n- 参数: [struct bpf_reg_state *true_reg, struct bpf_reg_state *false_reg, u64 val, u32 val32, u8 opcode, bool is_jmp32]\n- 调用者: check_cond_jmp_op\n- 被调用者: N/A\n\n12. 函数名: reg_set_min_max_inv\n- 参数: [struct bpf_reg_state *true_reg, struct bpf_reg_state *false_reg, u64 val, u32 val32, u8 opcode, bool is_jmp32]\n- 调用者: check_cond_jmp_op\n- 被调用者: N/A\n\n13. 函数名: reg_combine_min_max\n- 参数: [struct bpf_reg_state *true_src, struct bpf_reg_state *true_dst, struct bpf_reg_state *false_src, struct bpf_reg_state *false_dst, u8 opcode]\n- 调用者: check_cond_jmp_op\n- 被调用者: N/A\n\n14. 函数名: find_equal_scalars\n- 参数: [struct bpf_verifier_state *vstate, struct bpf_reg_state *known_reg]\n- 调用者: check_cond_jmp_op\n- 被调用者: N/A\n\n15. 函数名: mark_ptr_or_null_regs\n- 参数: [struct bpf_verifier_state *vstate, u32 regno, bool is_null]\n- 调用者: check_cond_jmp_op\n- 被调用者: N/A\n\n16. 函数名: try_match_pkt_pointers\n- 参数: [struct bpf_insn *insn, struct bpf_reg_state *dst_reg, struct bpf_reg_state *src_reg, struct bpf_verifier_state *this_branch, struct bpf_verifier_state *other_branch]\n- 调用者: check_cond_jmp_op\n- 被调用者: N/A\n\n17. 函数名: print_insn_state\n- 参数: [struct bpf_verifier_env *env, struct bpf_func_state *state]\n- 调用者: check_cond_jmp_op\n- 被调用者: N/A"
    },
    {
        "id": 3442,
        "cwe": "CWE-476",
        "cve": "CVE-2022-23222",
        "purpose": "Code purpose:\"\"\"判断给定的BPF寄存器类型是否为可溢出的指针类型\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于内核在处理某些_OR_NULL指针类型时允许进行指针算术运算，导致本地用户可能通过此缺陷提升权限。\"\"\"",
        "functions": "Functions:\n1. 函数名: is_spillable_regtype\n- 参数: [enum bpf_reg_type type]\n- 调用者: 未提供（代码片段中未显示）\n- 被调用者: []"
    },
    {
        "id": 3443,
        "cwe": "CWE-476",
        "cve": "CVE-2022-23222",
        "purpose": "Code purpose:\"\"\"该代码用于验证和检查BPF(伯克利包过滤器)程序中的辅助函数调用，确保其参数、返回值和相关操作符合安全规范，防止指针算术操作导致的权限提升漏洞。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中某些_OR_NULL指针类型允许进行指针算术运算，导致本地用户可利用此漏洞提升权限。\"\"\"",
        "functions": "Functions:\n1. 函数名: check_helper_call\n- 参数: [struct bpf_verifier_env *env, struct bpf_insn *insn, int *insn_idx_p]\n- 调用者: 未明确（应为BPF验证器调用）\n- 被调用者: [verbose, env->ops->get_func_proto, bpf_helper_changes_pkt_data, memset, check_func_proto, check_func_arg, record_func_map, record_func_key, check_mem_access, is_release_function, release_reference, cur_regs, check_reference_leak, register_is_null, __check_func_call, set_map_elem_callback_state, set_timer_callback_state, set_find_vma_callback_state, check_bpf_snprintf_call, set_loop_callback_state, mark_reg_not_init, check_reg_arg, mark_reg_unknown, mark_reg_known_zero, map_value_has_spin_lock, btf_type_skip_modifiers, btf_type_is_struct, btf_resolve_size, btf_name_by_offset, reg_type_may_be_null, is_ptr_cast_function, is_acquire_function, acquire_reference_state, do_refine_retval_range, check_map_func_compatibility, get_callchain_buffers, check_get_func_ip, clear_all_pkt_pointers]\n\n2. 函数名: verbose\n- 参数: [struct bpf_verifier_env *env, const char *fmt, ...]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n3. 函数名: get_func_proto\n- 参数: [int func_id, struct bpf_prog *prog]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n4. 函数名: bpf_helper_changes_pkt_data\n- 参数: [fn->func]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n5. 函数名: check_func_proto\n- 参数: [const struct bpf_func_proto *fn, int func_id]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n6. 函数名: check_func_arg\n- 参数: [struct bpf_verifier_env *env, int i, struct bpf_call_arg_meta *meta, const struct bpf_func_proto *fn]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n7. 函数名: record_func_map\n- 参数: [struct bpf_verifier_env *env, struct bpf_call_arg_meta *meta, int func_id, int insn_idx]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n8. 函数名: record_func_key\n- 参数: [struct bpf_verifier_env *env, struct bpf_call_arg_meta *meta, int func_id, int insn_idx]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n9. 函数名: check_mem_access\n- 参数: [struct bpf_verifier_env *env, int insn_idx, int regno, int i, enum bpf_access_type type, enum bpf_access_src src, int size, bool zero_size_allowed]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n10. 函数名: is_release_function\n- 参数: [int func_id]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n11. 函数名: release_reference\n- 参数: [struct bpf_verifier_env *env, int ref_obj_id]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n12. 函数名: cur_regs\n- 参数: [struct bpf_verifier_env *env]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n13. 函数名: check_reference_leak\n- 参数: [struct bpf_verifier_env *env]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n14. 函数名: register_is_null\n- 参数: [struct bpf_reg_state *reg]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n15. 函数名: __check_func_call\n- 参数: [struct bpf_verifier_env *env, struct bpf_insn *insn, int *insn_idx_p, int subprogno, callback_state_fn callback]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n16. 函数名: check_bpf_snprintf_call\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *regs]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n17. 函数名: mark_reg_not_init\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *regs, int regno]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n18. 函数名: check_reg_arg\n- 参数: [struct bpf_verifier_env *env, u32 regno, enum reg_arg_type t]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n19. 函数名: mark_reg_unknown\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *regs, int regno]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n20. 函数名: mark_reg_known_zero\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *regs, int regno]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n21. 函数名: map_value_has_spin_lock\n- 参数: [struct bpf_map *map]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n22. 函数名: btf_type_skip_modifiers\n- 参数: [const struct btf *btf, u32 id, u32 *res_id]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n23. 函数名: btf_type_is_struct\n- 参数: [const struct btf_type *t]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n24. 函数名: btf_resolve_size\n- 参数: [const struct btf *btf, const struct btf_type *type, u32 *type_size]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n25. 函数名: btf_name_by_offset\n- 参数: [const struct btf *btf, u32 offset]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n26. 函数名: reg_type_may_be_null\n- 参数: [enum bpf_reg_type type]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n27. 函数名: is_ptr_cast_function\n- 参数: [int func_id]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n28. 函数名: is_acquire_function\n- 参数: [int func_id, struct bpf_map *map]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n29. 函数名: acquire_reference_state\n- 参数: [struct bpf_verifier_env *env, int insn_idx]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n30. 函数名: do_refine_retval_range\n- 参数: [struct bpf_reg_state *regs, enum bpf_return_type ret_type, int func_id, struct bpf_call_arg_meta *meta]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n31. 函数名: check_map_func_compatibility\n- 参数: [struct bpf_verifier_env *env, struct bpf_map *map, int func_id]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n32. 函数名: get_callchain_buffers\n- 参数: [int max_stack]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n33. 函数名: check_get_func_ip\n- 参数: [struct bpf_verifier_env *env]\n- 调用者: check_helper_call\n- 被调用者: 无\n\n34. 函数名: clear_all_pkt_pointers\n- 参数: [struct bpf_verifier_env *env]\n- 调用者: check_helper_call\n- 被调用者: 无"
    },
    {
        "id": 3444,
        "cwe": "CWE-476",
        "cve": "CVE-2022-23222",
        "purpose": "Code purpose:\"\"\"该代码用于在BPF验证器中标记寄存器读取操作，并跟踪寄存器之间的依赖关系以确保正确性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于内核BPF验证器中允许对某些_OR_NULL指针类型进行指针算术运算，导致本地用户可利用此缺陷提升权限\"\"\"",
        "functions": "Functions:\n1. 函数名: mark_reg_read\n- 参数: [env, state, parent, flag]\n- 调用者: 未明确显示（应为BPF验证器相关代码）\n- 被调用者: [verbose, reg_type_str]\n\n2. 函数名: verbose\n- 参数: [env, format_string, ...] (变参函数)\n- 调用者: mark_reg_read\n- 被调用者: 未显示\n\n3. 函数名: reg_type_str\n- 参数: 无（应为字符串数组访问）\n- 调用者: mark_reg_read\n- 被调用者: 无"
    },
    {
        "id": 3445,
        "cwe": "CWE-476",
        "cve": "CVE-2022-23222",
        "purpose": "Code purpose:\"\"\"该代码用于判断给定的BPF寄存器类型是否为可能被引用计数或可为空的指针类型\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于内核BPF验证器允许对某些_OR_NULL指针类型进行算术运算，导致本地用户可能通过空指针解引用或越界访问来提升权限。\"\"\"",
        "functions": "Functions:\n1. 函数名: reg_type_may_be_refcounted_or_null\n- 参数: [enum bpf_reg_type type]\n- 调用者: 未提供（代码片段中未显示）\n- 被调用者: []"
    },
    {
        "id": 3446,
        "cwe": "CWE-476",
        "cve": "CVE-2022-23222",
        "purpose": "Code purpose:\"\"\"检查BPF程序中对套接字指针的访问是否合法，防止越界或非法访问\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于内核在验证BPF程序中对某些可为NULL的指针类型(如*_OR_NULL)进行算术运算时缺乏充分检查，导致本地用户可利用指针运算进行权限提升。\"\"\"",
        "functions": "Functions:\n1. 函数名: check_sock_access\n- 参数: [struct bpf_verifier_env *env, int insn_idx, u32 regno, int off, int size, enum bpf_access_type t]\n- 调用者: 未明确（由BPF验证器调用）\n- 被调用者: [cur_regs, verbose, bpf_sock_common_is_valid_access, bpf_sock_is_valid_access, bpf_tcp_sock_is_valid_access, bpf_xdp_sock_is_valid_access]\n\n2. 函数名: cur_regs\n- 参数: [struct bpf_verifier_env *env]\n- 调用者: check_sock_access\n- 被调用者: []\n\n3. 函数名: verbose\n- 参数: [struct bpf_verifier_env *env, const char *fmt, ...]\n- 调用者: check_sock_access\n- 被调用者: []\n\n4. 函数名: bpf_sock_common_is_valid_access\n- 参数: [int off, int size, enum bpf_access_type t, struct bpf_insn_access_aux *info]\n- 调用者: check_sock_access\n- 被调用者: []\n\n5. 函数名: bpf_sock_is_valid_access\n- 参数: [int off, int size, enum bpf_access_type t, struct bpf_insn_access_aux *info]\n- 调用者: check_sock_access\n- 被调用者: []\n\n6. 函数名: bpf_tcp_sock_is_valid_access\n- 参数: [int off, int size, enum bpf_access_type t, struct bpf_insn_access_aux *info]\n- 调用者: check_sock_access\n- 被调用者: []\n\n7. 函数名: bpf_xdp_sock_is_valid_access\n- 参数: [int off, int size, enum bpf_access_type t, struct bpf_insn_access_aux *info]\n- 调用者: check_sock_access\n- 被调用者: []"
    },
    {
        "id": 3447,
        "cwe": "CWE-476",
        "cve": "CVE-2022-23222",
        "purpose": "Code purpose:\"\"\"该代码是Linux内核中BPF验证器的一部分，用于验证BPF程序指令的安全性，防止非法内存访问和指针操作，确保程序不会导致特权提升等安全问题。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中的BPF验证器允许使用某些_OR_NULL指针类型进行指针算术运算，导致本地用户可能通过此漏洞提升权限\"\"\"",
        "functions": "Functions:\n1. 函数名: do_check\n- 参数: [struct bpf_verifier_env *env]\n- 调用者: N/A (顶层函数)\n- 被调用者: [verbose, is_state_visited, signal_pending, need_resched, cond_resched, print_verifier_state, verifier_state_scratched, print_insn_state, verbose_linfo, print_bpf_insn, bpf_prog_is_dev_bound, bpf_prog_offload_verify_insn, sanitize_mark_insn_seen, check_alu_op, check_reg_arg, check_mem_access, check_atomic, is_ctx_reg, check_func_call, check_kfunc_call, check_helper_call, check_cond_jmp_op, check_ld_abs, check_ld_imm, prepare_func_exit, check_reference_leak, check_return_code, mark_verifier_state_scratched, update_branch_counts, pop_stack]\n\n2. 函数名: verbose\n- 参数: [struct bpf_verifier_env *env, const char *fmt, ...]\n- 调用者: [do_check]\n- 被调用者: []\n\n3. 函数名: is_state_visited\n- 参数: [struct bpf_verifier_env *env, int insn_idx]\n- 调用者: [do_check]\n- 被调用者: []\n\n4. 函数名: signal_pending\n- 参数: [struct task_struct *p]\n- 调用者: [do_check]\n- 被调用者: []\n\n5. 函数名: need_resched\n- 参数: []\n- 调用者: [do_check]\n- 被调用者: []\n\n6. 函数名: cond_resched\n- 参数: []\n- 调用者: [do_check]\n- 被调用者: []\n\n7. 函数名: print_verifier_state\n- 参数: [struct bpf_verifier_env *env, struct bpf_func_state *state, bool print_all]\n- 调用者: [do_check]\n- 被调用者: []\n\n8. 函数名: verifier_state_scratched\n- 参数: [struct bpf_verifier_env *env]\n- 调用者: [do_check]\n- 被调用者: []\n\n9. 函数名: print_insn_state\n- 参数: [struct bpf_verifier_env *env, struct bpf_func_state *state]\n- 调用者: [do_check]\n- 被调用者: []\n\n10. 函数名: verbose_linfo\n- 参数: [struct bpf_verifier_env *env, int insn_idx, const char *prefix]\n- 调用者: [do_check]\n- 被调用者: []\n\n11. 函数名: print_bpf_insn\n- 参数: [const struct bpf_insn_cbs *cbs, const struct bpf_insn *insn, bool allow_ptr_leaks]\n- 调用者: [do_check]\n- 被调用者: []\n\n12. 函数名: bpf_prog_is_dev_bound\n- 参数: [struct bpf_prog_aux *aux]\n- 调用者: [do_check]\n- 被调用者: []\n\n13. 函数名: bpf_prog_offload_verify_insn\n- 参数: [struct bpf_verifier_env *env, int insn_idx, int prev_insn_idx]\n- 调用者: [do_check]\n- 被调用者: []\n\n14. 函数名: sanitize_mark_insn_seen\n- 参数: [struct bpf_verifier_env *env]\n- 调用者: [do_check]\n- 被调用者: []\n\n15. 函数名: check_alu_op\n- 参数: [struct bpf_verifier_env *env, struct bpf_insn *insn]\n- 调用者: [do_check]\n- 被调用者: []\n\n16. 函数名: check_reg_arg\n- 参数: [struct bpf_verifier_env *env, u32 reg, enum reg_arg_type t]\n- 调用者: [do_check]\n- 被调用者: []\n\n17. 函数名: check_mem_access\n- 参数: [struct bpf_verifier_env *env, int insn_idx, u32 regno, int off, int bpf_size, enum bpf_access_type type, u32 dst_regno, bool zero_size_allowed]\n- 调用者: [do_check]\n- 被调用者: []\n\n18. 函数名: check_atomic\n- 参数: [struct bpf_verifier_env *env, int insn_idx, struct bpf_insn *insn]\n- 调用者: [do_check]\n- 被调用者: []\n\n19. 函数名: is_ctx_reg\n- 参数: [struct bpf_verifier_env *env, int regno]\n- 调用者: [do_check]\n- 被调用者: []\n\n20. 函数名: check_func_call\n- 参数: [struct bpf_verifier_env *env, struct bpf_insn *insn, int *insn_idx]\n- 调用者: [do_check]\n- 被调用者: []\n\n21. 函数名: check_kfunc_call\n- 参数: [struct bpf_verifier_env *env, struct bpf_insn *insn]\n- 调用者: [do_check]\n- 被调用者: []\n\n22. 函数名: check_helper_call\n- 参数: [struct bpf_verifier_env *env, struct bpf_insn *insn, int *insn_idx]\n- 调用者: [do_check]\n- 被调用者: []\n\n23. 函数名: check_cond_jmp_op\n- 参数: [struct bpf_verifier_env *env, struct bpf_insn *insn, int *insn_idx]\n- 调用者: [do_check]\n- 被调用者: []\n\n24. 函数名: check_ld_abs\n- 参数: [struct bpf_verifier_env *env, struct bpf_insn *insn]\n- 调用者: [do_check]\n- 被调用者: []\n\n25. 函数名: check_ld_imm\n- 参数: [struct bpf_verifier_env *env, struct bpf_insn *insn]\n- 调用者: [do_check]\n- 被调用者: []\n\n26. 函数名: prepare_func_exit\n- 参数: [struct bpf_verifier_env *env, int *insn_idx]\n- 调用者: [do_check]\n- 被调用者: []\n\n27. 函数名: check_reference_leak\n- 参数: [struct bpf_verifier_env *env]\n- 调用者: [do_check]\n- 被调用者: []\n\n28. 函数名: check_return_code\n- 参数: [struct bpf_verifier_env *env]\n- 调用者: [do_check]\n- 被调用者: []\n\n29. 函数名: mark_verifier_state_scratched\n- 参数: [struct bpf_verifier_env *env]\n- 调用者: [do_check]\n- 被调用者: []\n\n30. 函数名: update_branch_counts\n- 参数: [struct bpf_verifier_env *env, struct bpf_verifier_state *st]\n- 调用者: [do_check]\n- 被调用者: []\n\n31. 函数名: pop_stack\n- 参数: [struct bpf_verifier_env *env, int *prev_insn_idx, int *insn_idx, bool pop_log]\n- 调用者: [do_check]\n- 被调用者: []"
    },
    {
        "id": 3448,
        "cwe": "CWE-476",
        "cve": "CVE-2022-23222",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的BPF验证器中检查内存访问操作的合法性，包括指针对齐、访问权限和边界检查等，以防止非法内存访问和权限提升漏洞。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中某些_OR_NULL指针类型允许进行指针算术运算，导致本地用户可利用此漏洞提升权限\"\"\"",
        "functions": "Functions:\n1. 函数名: check_mem_access\n- 参数: [struct bpf_verifier_env *env, int insn_idx, u32 regno, int off, int bpf_size, enum bpf_access_type t, int value_regno, bool strict_alignment_once]\n- 调用者: N/A (顶层函数)\n- 被调用者: [bpf_size_to_bytes, check_ptr_alignment, check_mem_region_access, mark_reg_unknown, check_map_access_type, check_map_access, bpf_map_is_rdonly, bpf_map_direct_read, __mark_reg_known, check_ctx_reg, check_ctx_access, mark_reg_known_zero, check_stack_access_within_bounds, func, update_stack_depth, check_stack_read, check_stack_write, check_packet_access, check_flow_keys_access, check_sock_access, check_tp_buffer_access, check_ptr_to_btf_access, check_ptr_to_map_access, check_buffer_access, coerce_reg_to_size]\n\n2. 函数名: bpf_size_to_bytes\n- 参数: [int bpf_size]\n- 调用者: check_mem_access\n- 被调用者: []\n\n3. 函数名: check_ptr_alignment\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *reg, int off, int size, bool strict_alignment_once]\n- 调用者: check_mem_access\n- 被调用者: []\n\n4. 函数名: check_mem_region_access\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int size, int mem_size, bool false]\n- 调用者: check_mem_access\n- 被调用者: []\n\n5. 函数名: mark_reg_unknown\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *regs, int value_regno]\n- 调用者: check_mem_access\n- 被调用者: []\n\n6. 函数名: check_map_access_type\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int size, enum bpf_access_type t]\n- 调用者: check_mem_access\n- 被调用者: []\n\n7. 函数名: check_map_access\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int size, bool false]\n- 调用者: check_mem_access\n- 被调用者: []\n\n8. 函数名: bpf_map_is_rdonly\n- 参数: [struct bpf_map *map]\n- 调用者: check_mem_access\n- 被调用者: []\n\n9. 函数名: bpf_map_direct_read\n- 参数: [struct bpf_map *map, int map_off, int size, u64 *val]\n- 调用者: check_mem_access\n- 被调用者: []\n\n10. 函数名: __mark_reg_known\n- 参数: [struct bpf_reg_state *reg, u64 val]\n- 调用者: check_mem_access\n- 被调用者: []\n\n11. 函数名: check_ctx_reg\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *reg, int regno]\n- 调用者: check_mem_access\n- 被调用者: []\n\n12. 函数名: check_ctx_access\n- 参数: [struct bpf_verifier_env *env, int insn_idx, int off, int size, enum bpf_access_type t, enum bpf_reg_type *reg_type, struct btf **btf, u32 *btf_id]\n- 调用者: check_mem_access\n- 被调用者: []\n\n13. 函数名: mark_reg_known_zero\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *regs, int value_regno]\n- 调用者: check_mem_access\n- 被调用者: []\n\n14. 函数名: check_stack_access_within_bounds\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int size, enum bpf_access_type ACCESS_DIRECT, enum bpf_access_type t]\n- 调用者: check_mem_access\n- 被调用者: []\n\n15. 函数名: func\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *reg]\n- 调用者: check_mem_access\n- 被调用者: []\n\n16. 函数名: update_stack_depth\n- 参数: [struct bpf_verifier_env *env, struct bpf_func_state *state, int off]\n- 调用者: check_mem_access\n- 被调用者: []\n\n17. 函数名: check_stack_read\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int size, int value_regno]\n- 调用者: check_mem_access\n- 被调用者: []\n\n18. 函数名: check_stack_write\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int size, int value_regno, int insn_idx]\n- 调用者: check_mem_access\n- 被调用者: []\n\n19. 函数名: check_packet_access\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int size, bool false]\n- 调用者: check_mem_access\n- 被调用者: []\n\n20. 函数名: check_flow_keys_access\n- 参数: [struct bpf_verifier_env *env, int off, int size]\n- 调用者: check_mem_access\n- 被调用者: []\n\n21. 函数名: check_sock_access\n- 参数: [struct bpf_verifier_env *env, int insn_idx, int regno, int off, int size, enum bpf_access_type t]\n- 调用者: check_mem_access\n- 被调用者: []\n\n22. 函数名: check_tp_buffer_access\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *reg, int regno, int off, int size]\n- 调用者: check_mem_access\n- 被调用者: []\n\n23. 函数名: check_ptr_to_btf_access\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *regs, int regno, int off, int size, enum bpf_access_type t, int value_regno]\n- 调用者: check_mem_access\n- 被调用者: []\n\n24. 函数名: check_ptr_to_map_access\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *regs, int regno, int off, int size, enum bpf_access_type t, int value_regno]\n- 调用者: check_mem_access\n- 被调用者: []\n\n25. 函数名: check_buffer_access\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *reg, int regno, int off, int size, bool false, char *rdonly, size_t *max_access]\n- 调用者: check_mem_access\n- 被调用者: []\n\n26. 函数名: coerce_reg_to_size\n- 参数: [struct bpf_reg_state *reg, int size]\n- 调用者: check_mem_access\n- 被调用者: []"
    },
    {
        "id": 3449,
        "cwe": "CWE-476",
        "cve": "CVE-2022-23222",
        "purpose": "Code purpose:\"\"\"验证BPF程序对上下文访问的合法性，包括检查偏移量、大小和访问类型，并处理指针类型转换和访问权限控制。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核在验证BPF程序对上下文的访问时，未能正确处理PTR_TO_BTF_ID_OR_NULL类型的指针算术运算，导致本地用户可利用此缺陷提升权限。\"\"\"",
        "functions": "Functions:\n1. 函数名: check_ctx_access\n- 参数: [struct bpf_verifier_env *env, int insn_idx, int off, int size, enum bpf_access_type t, enum bpf_reg_type *reg_type, struct btf **btf, u32 *btf_id]\n- 调用者: 未明确（由BPF验证器调用）\n- 被调用者: [env->ops->is_valid_access, verbose]\n\n2. 函数名: is_valid_access\n- 参数: [int off, int size, enum bpf_access_type t, struct bpf_prog *prog, struct bpf_insn_access_aux *info]\n- 调用者: check_ctx_access\n- 被调用者: 未明确（由env->ops指向的函数实现）\n\n3. 函数名: verbose\n- 参数: [struct bpf_verifier_env *env, const char *fmt, ...]\n- 调用者: check_ctx_access\n- 被调用者: 未明确（内核打印函数）"
    },
    {
        "id": 3450,
        "cwe": "CWE-476",
        "cve": "CVE-2022-23222",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的BPF验证器中检查寄存器类型是否符合预期，防止指针算术操作导致的安全漏洞。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核在验证BPF程序时，未能正确处理某些OR_NULL指针类型的算术运算，导致本地用户可利用指针运算提升权限。\"\"\"",
        "functions": "Functions:\n1. 函数名: check_reg_type\n- 参数: [struct bpf_verifier_env *env, u32 regno, enum bpf_arg_type arg_type, const u32 *arg_btf_id]\n- 调用者: 未明确显示（应为BPF验证器相关调用）\n- 被调用者: [cur_regs, verbose, base_type, btf_struct_ids_match, kernel_type_name, tnum_is_const]\n\n2. 函数名: cur_regs\n- 参数: [struct bpf_verifier_env *env]\n- 调用者: check_reg_type\n- 被调用者: []\n\n3. 函数名: verbose\n- 参数: [struct bpf_verifier_env *env, const char *fmt, ...]\n- 调用者: check_reg_type\n- 被调用者: []\n\n4. 函数名: base_type\n- 参数: [enum bpf_arg_type arg_type]\n- 调用者: check_reg_type\n- 被调用者: []\n\n5. 函数名: btf_struct_ids_match\n- 参数: [struct bpf_verifier_log *log, struct btf *btf1, u32 id1, s32 off1, struct btf *btf2, u32 id2]\n- 调用者: check_reg_type\n- 被调用者: []\n\n6. 函数名: kernel_type_name\n- 参数: [struct btf *btf, u32 id]\n- 调用者: check_reg_type\n- 被调用者: []\n\n7. 函数名: tnum_is_const\n- 参数: [struct tnum a]\n- 调用者: check_reg_type\n- 被调用者: []"
    },
    {
        "id": 3451,
        "cwe": "CWE-476",
        "cve": "CVE-2022-23222",
        "purpose": "Code purpose:\"\"\"该代码用于验证BPF程序中的寄存器状态是否安全，确保指针操作不会导致越界或非法访问，防止权限提升漏洞。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中某些_OR_NULL指针类型允许进行指针算术运算，导致本地用户可利用此漏洞提升权限\"\"\"",
        "functions": "Functions:\n1. 函数名: regsafe\n- 参数: [env, rold, rcur, idmap]\n- 调用者: 未明确显示（应为BPF验证器相关调用）\n- 被调用者: [memcmp, range_within, tnum_in, check_ids, WARN_ON_ONCE]\n\n2. 函数名: memcmp\n- 参数: [rold, rcur, offsetof(struct bpf_reg_state, parent)]\n- 调用者: regsafe\n- 被调用者: []\n\n3. 函数名: range_within\n- 参数: [rold, rcur]\n- 调用者: regsafe\n- 被调用者: []\n\n4. 函数名: tnum_in\n- 参数: [rold->var_off, rcur->var_off]\n- 调用者: regsafe\n- 被调用者: []\n\n5. 函数名: check_ids\n- 参数: [rold->id, rcur->id, idmap]\n- 调用者: regsafe\n- 被调用者: []\n\n6. 函数名: WARN_ON_ONCE\n- 参数: [1]\n- 调用者: regsafe\n- 被调用者: []"
    },
    {
        "id": 3452,
        "cwe": "CWE-476",
        "cve": "CVE-2022-23222",
        "purpose": "Code purpose:\"\"\"该代码用于检查BPF寄存器类型是否允许指针算术运算，特定类型的指针(如PTR_TO_SOCKET_OR_NULL等)返回false表示不允许，其他类型返回true表示允许\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞允许通过某些_OR_NULL指针类型进行指针算术运算，导致本地用户可能提升权限\"\"\"",
        "functions": "Functions:\n1. 函数名: reg_type_mismatch_ok\n- 参数: [enum bpf_reg_type type]\n- 调用者: 未提供（代码片段中未显示）\n- 被调用者: []"
    },
    {
        "id": 3453,
        "cwe": "CWE-476",
        "cve": "CVE-2022-23222",
        "purpose": "Code purpose:\"\"\"该代码用于验证BPF程序中对可能为NULL的指针类型的内存访问是否安全\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于对可能为NULL的指针类型进行了算术运算而未充分验证其非空性，导致存在特权提升的风险\"\"\"",
        "functions": "Functions:\n1. 函数名: check_mem_reg\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *reg, u32 regno, u32 mem_size]\n- 调用者: 未明确（由BPF验证器调用）\n- 被调用者: [register_is_null, reg_type_may_be_null, mark_ptr_not_null_reg, check_helper_mem_access]\n\n2. 函数名: register_is_null\n- 参数: [struct bpf_reg_state *reg]\n- 调用者: check_mem_reg\n- 被调用者: []\n\n3. 函数名: reg_type_may_be_null\n- 参数: [enum bpf_reg_type type]\n- 调用者: check_mem_reg\n- 被调用者: []\n\n4. 函数名: mark_ptr_not_null_reg\n- 参数: [struct bpf_reg_state *reg]\n- 调用者: check_mem_reg\n- 被调用者: []\n\n5. 函数名: check_helper_mem_access\n- 参数: [struct bpf_verifier_env *env, u32 regno, u32 mem_size, bool zero_size_allowed, struct bpf_call_arg_meta *meta]\n- 调用者: check_mem_reg\n- 被调用者: []"
    },
    {
        "id": 3454,
        "cwe": "CWE-476",
        "cve": "CVE-2022-23222",
        "purpose": "Code purpose:\"\"\"该代码用于处理BPF验证器中可为空的指针类型，将其转换为对应的非空指针类型，以确保指针操作的安全性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核在处理某些可为空的指针类型(PTR_TO_*_OR_NULL)时，未正确限制指针算术运算，导致本地用户可利用此漏洞进行权限提升\"\"\"",
        "functions": "Functions:\n1. 函数名: mark_ptr_not_null_reg\n- 参数: [struct bpf_reg_state *reg]\n- 调用者: 未明确（应为内核BPF验证器相关代码）\n- 被调用者: [map_value_has_timer, WARN_ONCE]\n\n2. 函数名: map_value_has_timer\n- 参数: [const struct bpf_map *map]\n- 调用者: mark_ptr_not_null_reg\n- 被调用者: 未明确"
    },
    {
        "id": 3455,
        "cwe": "CWE-476",
        "cve": "CVE-2022-23222",
        "purpose": "Code purpose:\"\"\"该代码用于打印BPF验证器的状态信息，包括寄存器状态、栈状态和引用状态等，用于调试和验证BPF程序的正确性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中某些_OR_NULL指针类型允许进行指针算术运算，导致本地用户可利用此漏洞提升权限。\"\"\"",
        "functions": "Functions:\n1. 函数名: print_verifier_state\n- 参数: [struct bpf_verifier_env *env, const struct bpf_func_state *state, bool print_all]\n- 调用者: N/A\n- 被调用者: [verbose, print_liveness, reg_scratched, kernel_type_name, reg_type_may_be_refcounted_or_null, type_is_pkt_pointer, tnum_is_const, tnum_strn, stack_slot_scratched, is_spilled_reg, mark_verifier_state_clean]\n\n2. 函数名: verbose\n- 参数: [struct bpf_verifier_env *env, const char *fmt, ...]\n- 调用者: print_verifier_state\n- 被调用者: N/A\n\n3. 函数名: print_liveness\n- 参数: [struct bpf_verifier_env *env, unsigned long live]\n- 调用者: print_verifier_state\n- 被调用者: N/A\n\n4. 函数名: reg_scratched\n- 参数: [struct bpf_verifier_env *env, int i]\n- 调用者: print_verifier_state\n- 被调用者: N/A\n\n5. 函数名: kernel_type_name\n- 参数: [struct btf *btf, u32 btf_id]\n- 调用者: print_verifier_state\n- 被调用者: N/A\n\n6. 函数名: reg_type_may_be_refcounted_or_null\n- 参数: [enum bpf_reg_type t]\n- 调用者: print_verifier_state\n- 被调用者: N/A\n\n7. 函数名: type_is_pkt_pointer\n- 参数: [enum bpf_reg_type t]\n- 调用者: print_verifier_state\n- 被调用者: N/A\n\n8. 函数名: tnum_is_const\n- 参数: [struct tnum a]\n- 调用者: print_verifier_state\n- 被调用者: N/A\n\n9. 函数名: tnum_strn\n- 参数: [char *str, size_t size, struct tnum a]\n- 调用者: print_verifier_state\n- 被调用者: N/A\n\n10. 函数名: stack_slot_scratched\n- 参数: [struct bpf_verifier_env *env, int i]\n- 调用者: print_verifier_state\n- 被调用者: N/A\n\n11. 函数名: is_spilled_reg\n- 参数: [const struct bpf_stack_state *stack]\n- 调用者: print_verifier_state\n- 被调用者: N/A\n\n12. 函数名: mark_verifier_state_clean\n- 参数: [struct bpf_verifier_env *env]\n- 调用者: print_verifier_state\n- 被调用者: N/A"
    },
    {
        "id": 3456,
        "cwe": "CWE-476",
        "cve": "CVE-2022-23222",
        "purpose": "Code purpose:\"\"\"该代码用于验证BPF程序中对不同类型指针的内存访问权限和边界检查，确保内存访问的安全性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理某些_OR_NULL指针类型时未正确限制指针算术运算，导致本地用户可利用此漏洞提升权限\"\"\"",
        "functions": "Functions:\n1. 函数名: check_helper_mem_access\n- 参数: [struct bpf_verifier_env *env, int regno, int access_size, bool zero_size_allowed, struct bpf_call_arg_meta *meta]\n- 调用者: N/A\n- 被调用者: [check_packet_access, check_mem_region_access, check_map_access_type, check_map_access, check_buffer_access, check_stack_range_initialized, register_is_null, verbose]\n\n2. 函数名: check_packet_access\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int access_size, bool zero_size_allowed]\n- 调用者: check_helper_mem_access\n- 被调用者: []\n\n3. 函数名: check_mem_region_access\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int access_size, int mem_size, bool zero_size_allowed]\n- 调用者: check_helper_mem_access\n- 被调用者: []\n\n4. 函数名: check_map_access_type\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int access_size, int access_type]\n- 调用者: check_helper_mem_access\n- 被调用者: []\n\n5. 函数名: check_map_access\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int access_size, bool zero_size_allowed]\n- 调用者: check_helper_mem_access\n- 被调用者: []\n\n6. 函数名: check_buffer_access\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *reg, int regno, int off, int access_size, bool zero_size_allowed, const char *buf_type, u32 *max_access]\n- 调用者: check_helper_mem_access\n- 被调用者: []\n\n7. 函数名: check_stack_range_initialized\n- 参数: [struct bpf_verifier_env *env, int regno, int off, int access_size, bool zero_size_allowed, int access_type, struct bpf_call_arg_meta *meta]\n- 调用者: check_helper_mem_access\n- 被调用者: []\n\n8. 函数名: register_is_null\n- 参数: [struct bpf_reg_state *reg]\n- 调用者: check_helper_mem_access\n- 被调用者: []\n\n9. 函数名: verbose\n- 参数: [struct bpf_verifier_env *env, const char *fmt, ...]\n- 调用者: check_helper_mem_access\n- 被调用者: []"
    },
    {
        "id": 3457,
        "cwe": "CWE-476",
        "cve": "CVE-2022-23222",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的BPF验证器中处理指针算术运算，确保指针操作的安全性，防止通过某些特定指针类型进行非法算术运算导致权限提升漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中某些_OR_NULL指针类型允许进行指针算术运算，导致本地用户可利用此漏洞提升权限。\"\"\"",
        "functions": "Functions:\n1. 函数名: adjust_ptr_min_max_vals\n- 参数: [struct bpf_verifier_env *env, struct bpf_insn *insn, const struct bpf_reg_state *ptr_reg, const struct bpf_reg_state *off_reg]\n- 调用者: N/A (顶层函数)\n- 被调用者: [tnum_is_const, __mark_reg_unknown, BPF_CLASS, BPF_OP, verbose, __mark_reg32_unbounded, check_reg_sane_offset, sanitize_needed, sanitize_ptr_alu, sanitize_err, signed_add_overflows, tnum_add, reg_is_pkt_pointer, memset, signed_sub_overflows, tnum_sub, __update_reg_bounds, __reg_deduce_bounds, __reg_bound_offset, sanitize_check_bounds]\n\n2. 函数名: tnum_is_const\n- 参数: [const struct tnum *var_off]\n- 调用者: adjust_ptr_min_max_vals\n- 被调用者: []\n\n3. 函数名: __mark_reg_unknown\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *reg]\n- 调用者: adjust_ptr_min_max_vals\n- 被调用者: []\n\n4. 函数名: verbose\n- 参数: [struct bpf_verifier_env *env, const char *fmt, ...]\n- 调用者: adjust_ptr_min_max_vals\n- 被调用者: []\n\n5. 函数名: __mark_reg32_unbounded\n- 参数: [struct bpf_reg_state *reg]\n- 调用者: adjust_ptr_min_max_vals\n- 被调用者: []\n\n6. 函数名: check_reg_sane_offset\n- 参数: [struct bpf_verifier_env *env, const struct bpf_reg_state *reg, enum bpf_reg_type type]\n- 调用者: adjust_ptr_min_max_vals\n- 被调用者: []\n\n7. 函数名: sanitize_needed\n- 参数: [u8 opcode]\n- 调用者: adjust_ptr_min_max_vals\n- 被调用者: []\n\n8. 函数名: sanitize_ptr_alu\n- 参数: [struct bpf_verifier_env *env, struct bpf_insn *insn, const struct bpf_reg_state *ptr_reg, const struct bpf_reg_state *off_reg, struct bpf_reg_state *dst_reg, struct bpf_sanitize_info *info, bool is_off_reg]\n- 调用者: adjust_ptr_min_max_vals\n- 被调用者: []\n\n9. 函数名: sanitize_err\n- 参数: [struct bpf_verifier_env *env, struct bpf_insn *insn, int ret, const struct bpf_reg_state *off_reg, struct bpf_reg_state *dst_reg]\n- 调用者: adjust_ptr_min_max_vals\n- 被调用者: []\n\n10. 函数名: signed_add_overflows\n- 参数: [s64 a, s64 b]\n- 调用者: adjust_ptr_min_max_vals\n- 被调用者: []\n\n11. 函数名: tnum_add\n- 参数: [struct tnum a, struct tnum b]\n- 调用者: adjust_ptr_min_max_vals\n- 被调用者: []\n\n12. 函数名: reg_is_pkt_pointer\n- 参数: [const struct bpf_reg_state *reg]\n- 调用者: adjust_ptr_min_max_vals\n- 被调用者: []\n\n13. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: adjust_ptr_min_max_vals\n- 被调用者: []\n\n14. 函数名: signed_sub_overflows\n- 参数: [s64 a, s64 b]\n- 调用者: adjust_ptr_min_max_vals\n- 被调用者: []\n\n15. 函数名: tnum_sub\n- 参数: [struct tnum a, struct tnum b]\n- 调用者: adjust_ptr_min_max_vals\n- 被调用者: []\n\n16. 函数名: __update_reg_bounds\n- 参数: [struct bpf_reg_state *reg]\n- 调用者: adjust_ptr_min_max_vals\n- 被调用者: []\n\n17. 函数名: __reg_deduce_bounds\n- 参数: [struct bpf_reg_state *reg]\n- 调用者: adjust_ptr_min_max_vals\n- 被调用者: []\n\n18. 函数名: __reg_bound_offset\n- 参数: [struct bpf_reg_state *reg]\n- 调用者: adjust_ptr_min_max_vals\n- 被调用者: []\n\n19. 函数名: sanitize_check_bounds\n- 参数: [struct bpf_verifier_env *env, struct bpf_insn *insn, struct bpf_reg_state *dst_reg]\n- 调用者: adjust_ptr_min_max_vals\n- 被调用者: []"
    },
    {
        "id": 3458,
        "cwe": "CWE-476",
        "cve": "CVE-2022-23222",
        "purpose": "Code purpose:\"\"\"检查BPF寄存器偏移量是否在允许范围内，防止指针算术运算导致越界访问\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确处理某些_OR_NULL指针类型的算术运算，导致本地用户可利用指针越界访问来提升权限\"\"\"",
        "functions": "Functions:\n1. 函数名: check_reg_sane_offset\n- 参数: [env, reg, type]\n- 调用者: 未明确（应为BPF验证器相关函数）\n- 被调用者: [tnum_is_const, verbose, reg_type_str]\n\n2. 函数名: tnum_is_const\n- 参数: [reg->var_off]\n- 调用者: check_reg_sane_offset\n- 被调用者: 无\n\n3. 函数名: verbose\n- 参数: [env, format string, ...]\n- 调用者: check_reg_sane_offset\n- 被调用者: 无\n\n4. 函数名: reg_type_str\n- 参数: [type]\n- 调用者: check_reg_sane_offset\n- 被调用者: 无"
    },
    {
        "id": 3459,
        "cwe": "CWE-476",
        "cve": "CVE-2022-23222",
        "purpose": "Code purpose:\"\"\"该代码用于验证eBPF程序退出时寄存器R0的返回值是否符合预期范围和安全要求，防止指针算术操作导致权限提升漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中某些_OR_NULL指针类型允许进行指针算术运算，导致本地用户可利用此漏洞提升权限\"\"\"",
        "functions": "Functions:\n1. 函数名: check_return_code\n- 参数: [struct bpf_verifier_env *env]\n- 调用者: N/A (顶级函数)\n- 被调用者: [tnum_unknown, tnum_range, resolve_prog_type, check_reg_arg, is_pointer_value, cur_regs, tnum_in, tnum_const, verbose, verbose_invalid_scalar, tnum_is_unknown]\n\n2. 函数名: tnum_unknown\n- 参数: []\n- 调用者: check_return_code\n- 被调用者: []\n\n3. 函数名: tnum_range\n- 参数: [int min, int max]\n- 调用者: check_return_code\n- 被调用者: []\n\n4. 函数名: resolve_prog_type\n- 参数: [struct bpf_prog *prog]\n- 调用者: check_return_code\n- 被调用者: []\n\n5. 函数名: check_reg_arg\n- 参数: [struct bpf_verifier_env *env, int regno, enum bpf_reg_type type]\n- 调用者: check_return_code\n- 被调用者: []\n\n6. 函数名: is_pointer_value\n- 参数: [struct bpf_verifier_env *env, int regno]\n- 调用者: check_return_code\n- 被调用者: []\n\n7. 函数名: cur_regs\n- 参数: [struct bpf_verifier_env *env]\n- 调用者: check_return_code\n- 被调用者: []\n\n8. 函数名: tnum_in\n- 参数: [struct tnum range, struct tnum var_off]\n- 调用者: check_return_code\n- 被调用者: []\n\n9. 函数名: tnum_const\n- 参数: [int value]\n- 调用者: check_return_code\n- 被调用者: []\n\n10. 函数名: verbose\n- 参数: [struct bpf_verifier_env *env, const char *fmt, ...]\n- 调用者: check_return_code\n- 被调用者: []\n\n11. 函数名: verbose_invalid_scalar\n- 参数: [struct bpf_verifier_env *env, struct bpf_reg_state *reg, struct tnum *range, const char *ctx, const char *reg_name]\n- 调用者: check_return_code\n- 被调用者: []\n\n12. 函数名: tnum_is_unknown\n- 参数: [struct tnum range]\n- 调用者: check_return_code\n- 被调用者: []"
    },
    {
        "id": 3460,
        "cwe": "CWE-476",
        "cve": "CVE-2022-23222",
        "purpose": "Code purpose:\"\"\"该代码用于在BPF验证器中标记可能为NULL的指针寄存器状态，并根据是否为NULL来更新寄存器类型和相关属性，以防止对可能为NULL的指针进行算术运算。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核在验证可能为NULL的指针类型时，未能正确处理指针算术运算，导致攻击者可通过特定操作提升权限。\"\"\"",
        "functions": "Functions:\n1. 函数名: mark_ptr_or_null_reg\n- 参数: [state, reg, id, is_null]\n- 调用者: 未明确（上下文不足）\n- 被调用者: [reg_type_may_be_null, WARN_ON_ONCE, __mark_reg_known_zero, tnum_equals_const, mark_ptr_not_null_reg, reg_may_point_to_spin_lock]\n\n2. 函数名: reg_type_may_be_null\n- 参数: [type]\n- 调用者: mark_ptr_or_null_reg\n- 被调用者: 未明确\n\n3. 函数名: WARN_ON_ONCE\n- 参数: [condition]\n- 调用者: mark_ptr_or_null_reg\n- 被调用者: 未明确\n\n4. 函数名: __mark_reg_known_zero\n- 参数: [reg]\n- 调用者: mark_ptr_or_null_reg\n- 被调用者: 未明确\n\n5. 函数名: tnum_equals_const\n- 参数: [var_off, const]\n- 调用者: mark_ptr_or_null_reg\n- 被调用者: 未明确\n\n6. 函数名: mark_ptr_not_null_reg\n- 参数: [reg]\n- 调用者: mark_ptr_or_null_reg\n- 被调用者: 未明确\n\n7. 函数名: reg_may_point_to_spin_lock\n- 参数: [reg]\n- 调用者: mark_ptr_or_null_reg\n- 被调用者: 未明确"
    },
    {
        "id": 3475,
        "cwe": "CWE-476",
        "cve": "CVE-2022-25258",
        "purpose": "Code purpose:\"\"\"处理USB复合设备的控制请求，包括描述符获取、配置设置、接口管理等功能的实现。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核USB Gadget子系统在处理接口OS描述符请求时，未充分验证大数组索引和NULL函数指针检索的情况，可能导致内存损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: composite_setup\n- 参数: [struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl]\n- 调用者: 无（顶层函数）\n- 被调用者: [get_gadget_data, le16_to_cpu, count_configs, gadget_is_superspeed, cpu_to_le16, min, memcpy, device_qual, min_t, config_desc, get_string, bos_desc, list_first_entry, set_config, put_unaligned_le16, count_ext_compat, fill_ext_compat, count_ext_prop, len_ext_prop, fill_ext_prop, composite_ep0_queue, composite_setup_complete]\n\n2. 函数名: get_gadget_data\n- 参数: [struct usb_gadget *gadget]\n- 调用者: composite_setup\n- 被调用者: 无\n\n3. 函数名: le16_to_cpu\n- 参数: [__le16]\n- 调用者: composite_setup\n- 被调用者: 无\n\n4. 函数名: count_configs\n- 参数: [struct usb_composite_dev *cdev, int type]\n- 调用者: composite_setup\n- 被调用者: 无\n\n5. 函数名: gadget_is_superspeed\n- 参数: [struct usb_gadget *gadget]\n- 调用者: composite_setup\n- 被调用者: 无\n\n6. 函数名: cpu_to_le16\n- 参数: [u16]\n- 调用者: composite_setup\n- 被调用者: 无\n\n7. 函数名: min\n- 参数: [u16, u16]\n- 调用者: composite_setup\n- 被调用者: 无\n\n8. 函数名: memcpy\n- 参数: [void *, const void *, size_t]\n- 调用者: composite_setup\n- 被调用者: 无\n\n9. 函数名: device_qual\n- 参数: [struct usb_composite_dev *cdev]\n- 调用者: composite_setup\n- 被调用者: 无\n\n10. 函数名: min_t\n- 参数: [int, int, size_t]\n- 调用者: composite_setup\n- 被调用者: 无\n\n11. 函数名: config_desc\n- 参数: [struct usb_composite_dev *cdev, u16 w_value]\n- 调用者: composite_setup\n- 被调用者: 无\n\n12. 函数名: get_string\n- 参数: [struct usb_composite_dev *cdev, u8 *buf, u16 w_index, u8]\n- 调用者: composite_setup\n- 被调用者: 无\n\n13. 函数名: bos_desc\n- 参数: [struct usb_composite_dev *cdev]\n- 调用者: composite_setup\n- 被调用者: 无\n\n14. 函数名: list_first_entry\n- 参数: [struct list_head *, struct usb_configuration, list]\n- 调用者: composite_setup\n- 被调用者: 无\n\n15. 函数名: set_config\n- 参数: [struct usb_composite_dev *cdev, const struct usb_ctrlrequest *ctrl, u16 w_value]\n- 调用者: composite_setup\n- 被调用者: 无\n\n16. 函数名: put_unaligned_le16\n- 参数: [u16, u8 *]\n- 调用者: composite_setup\n- 被调用者: 无\n\n17. 函数名: count_ext_compat\n- 参数: [struct usb_configuration *os_desc_cfg]\n- 调用者: composite_setup\n- 被调用者: 无\n\n18. 函数名: fill_ext_compat\n- 参数: [struct usb_configuration *os_desc_cfg, u8 *buf]\n- 调用者: composite_setup\n- 被调用者: 无\n\n19. 函数名: count_ext_prop\n- 参数: [struct usb_configuration *os_desc_cfg, int interface]\n- 调用者: composite_setup\n- 被调用者: 无\n\n20. 函数名: len_ext_prop\n- 参数: [struct usb_configuration *os_desc_cfg, int interface]\n- 调用者: composite_setup\n- 被调用者: 无\n\n21. 函数名: fill_ext_prop\n- 参数: [struct usb_configuration *os_desc_cfg, int interface, u8 *buf]\n- 调用者: composite_setup\n- 被调用者: 无\n\n22. 函数名: composite_ep0_queue\n- 参数: [struct usb_composite_dev *cdev, struct usb_request *req, gfp_t gfp_flags]\n- 调用者: composite_setup\n- 被调用者: 无\n\n23. 函数名: composite_setup_complete\n- 参数: [struct usb_ep *ep, struct usb_request *req]\n- 调用者: composite_setup\n- 被调用者: 无"
    },
    {
        "id": 3547,
        "cwe": "CWE-476",
        "cve": "CVE-2022-3078",
        "purpose": "Code purpose:\"\"\"初始化一个S302M编码器，分配相关内存并设置编码器参数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在调用vzalloc()分配内存后未检查返回值是否为空，且在内存分配失败时未正确释放之前分配的资源\"\"\"",
        "functions": "Functions:\n1. 函数名: vidtv_s302m_encoder_init\n- 参数: [struct vidtv_s302m_encoder_init_args args]\n- 调用者: 未显示\n- 被调用者: [kzalloc, kstrdup, vzalloc, kfree, cpu_to_be16, vidtv_s302m_encode, vidtv_s302m_clear, vidtv_s302m_encoder_destroy]\n\n2. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: vidtv_s302m_encoder_init\n- 被调用者: 未显示\n\n3. 函数名: kstrdup\n- 参数: [const char *s, gfp_t gfp]\n- 调用者: vidtv_s302m_encoder_init\n- 被调用者: 未显示\n\n4. 函数名: vzalloc\n- 参数: [size_t size]\n- 调用者: vidtv_s302m_encoder_init\n- 被调用者: 未显示\n\n5. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: vidtv_s302m_encoder_init\n- 被调用者: 未显示\n\n6. 函数名: cpu_to_be16\n- 参数: [__u16 x]\n- 调用者: vidtv_s302m_encoder_init\n- 被调用者: 未显示\n\n7. 函数名: vidtv_s302m_encode\n- 参数: 未显示\n- 调用者: vidtv_s302m_encoder_init\n- 被调用者: 未显示\n\n8. 函数名: vidtv_s302m_clear\n- 参数: 未显示\n- 调用者: vidtv_s302m_encoder_init\n- 被调用者: 未显示\n\n9. 函数名: vidtv_s302m_encoder_destroy\n- 参数: 未显示\n- 调用者: vidtv_s302m_encoder_init\n- 被调用者: 未显示"
    },
    {
        "id": 3549,
        "cwe": "CWE-476",
        "cve": "CVE-2022-3104",
        "purpose": "Code purpose:\"\"\"测试数组边界检查功能，包括合法访问和故意越界访问，但未检查kmalloc()返回值可能导致空指针解引用漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未检查kmalloc()的返回值，导致可能对空指针进行解引用操作\"\"\"",
        "functions": "Functions:\n1. 函数名: lkdtm_ARRAY_BOUNDS\n- 参数: [void]\n- 调用者: 未显示\n- 被调用者: [kmalloc, pr_info, pr_err, pr_expected_config, kfree]\n\n2. 函数名: kmalloc\n- 参数: [size, flags]\n- 调用者: lkdtm_ARRAY_BOUNDS\n- 被调用者: 未显示\n\n3. 函数名: pr_info\n- 参数: [format string]\n- 调用者: lkdtm_ARRAY_BOUNDS\n- 被调用者: 未显示\n\n4. 函数名: pr_err\n- 参数: [format string]\n- 调用者: lkdtm_ARRAY_BOUNDS\n- 被调用者: 未显示\n\n5. 函数名: pr_expected_config\n- 参数: [config option]\n- 调用者: lkdtm_ARRAY_BOUNDS\n- 被调用者: 未显示\n\n6. 函数名: kfree\n- 参数: [pointer]\n- 调用者: lkdtm_ARRAY_BOUNDS\n- 被调用者: 未显示"
    },
    {
        "id": 3550,
        "cwe": "CWE-476",
        "cve": "CVE-2022-3105",
        "purpose": "Code purpose:\"\"\"该代码用于初始化并处理用户空间API的I/O控制方法和写入方法，包括分配内存空间和设置方法处理函数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码中调用kmalloc_array()分配内存时未检查返回值是否为NULL，可能导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: uapi_finalize\n- 参数: [struct uverbs_api *uapi]\n- 调用者: 未显示\n- 被调用者: [uapi_key_is_ioctl_method, uapi_finalize_ioctl_method, uapi_key_is_write_method, uapi_key_is_write_ex_method, max, kmalloc_array, rcu_dereference_protected]\n\n2. 函数名: uapi_key_is_ioctl_method\n- 参数: [unsigned long iter.index]\n- 调用者: uapi_finalize\n- 被调用者: 未显示\n\n3. 函数名: uapi_finalize_ioctl_method\n- 参数: [struct uverbs_api *uapi, struct uverbs_api_ioctl_method *method_elm, unsigned long iter.index]\n- 调用者: uapi_finalize\n- 被调用者: 未显示\n\n4. 函数名: uapi_key_is_write_method\n- 参数: [unsigned long iter.index]\n- 调用者: uapi_finalize\n- 被调用者: 未显示\n\n5. 函数名: uapi_key_is_write_ex_method\n- 参数: [unsigned long iter.index]\n- 调用者: uapi_finalize\n- 被调用者: 未显示\n\n6. 函数名: max\n- 参数: [unsigned long max_write/max_write_ex, unsigned long iter.index & UVERBS_API_ATTR_KEY_MASK]\n- 调用者: uapi_finalize\n- 被调用者: 未显示\n\n7. 函数名: kmalloc_array\n- 参数: [uapi->num_write + uapi->num_write_ex, sizeof(*uapi->write_methods), GFP_KERNEL]\n- 调用者: uapi_finalize\n- 被调用者: 未显示\n\n8. 函数名: rcu_dereference_protected\n- 参数: [*slot, true]\n- 调用者: uapi_finalize\n- 被调用者: 未显示"
    },
    {
        "id": 3551,
        "cwe": "CWE-476",
        "cve": "CVE-2022-3106",
        "purpose": "Code purpose:\"\"\"该代码片段用于更新网络接口的统计信息，包括分配内存存储统计值、复制和更新统计信息，最后释放内存并返回更新结果。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未检查kmalloc()内存分配是否成功，导致可能解引用空指针\"\"\"",
        "functions": "Functions:\n1. 函数名: ef100_update_stats\n- 参数: [struct efx_nic *efx, u64 *full_stats, struct rtnl_link_stats64 *core_stats]\n- 调用者: 未指定\n- 被调用者: [kmalloc, ef100_common_stat_mask, ef100_ethtool_stat_mask, efx_nic_copy_stats, efx_nic_update_stats, kfree, ef100_update_stats_common]\n\n2. 函数名: ef100_common_stat_mask\n- 参数: [DECLARE_BITMAP(mask, EF100_STAT_COUNT)]\n- 调用者: ef100_update_stats\n- 被调用者: 未指定\n\n3. 函数名: ef100_ethtool_stat_mask\n- 参数: [DECLARE_BITMAP(mask, EF100_STAT_COUNT)]\n- 调用者: ef100_update_stats\n- 被调用者: 未指定\n\n4. 函数名: efx_nic_copy_stats\n- 参数: [struct efx_nic *efx, __le64 *mc_stats]\n- 调用者: ef100_update_stats\n- 被调用者: 未指定\n\n5. 函数名: efx_nic_update_stats\n- 参数: [ef100_stat_desc, EF100_STAT_COUNT, mask, stats, mc_stats, false]\n- 调用者: ef100_update_stats\n- 被调用者: 未指定\n\n6. 函数名: ef100_update_stats_common\n- 参数: [struct efx_nic *efx, u64 *full_stats, struct rtnl_link_stats64 *core_stats]\n- 调用者: ef100_update_stats\n- 被调用者: 未指定"
    },
    {
        "id": 3552,
        "cwe": "CWE-476",
        "cve": "CVE-2022-3107",
        "purpose": "Code purpose:\"\"\"该代码用于收集和统计网络设备的性能数据，包括全局统计、虚拟功能统计、通道统计和每个CPU的统计信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未检查kvmalloc_array()的返回值，导致可能因内存分配失败而引发空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: netvsc_get_ethtool_stats\n- 参数: [struct net_device *dev, struct ethtool_stats *stats, u64 *data]\n- 调用者: 未显示（由内核调用）\n- 被调用者: [netdev_priv, rtnl_dereference, netvsc_get_vf_stats, u64_stats_fetch_begin_irq, u64_stats_fetch_retry_irq, kvmalloc_array, netvsc_get_pcpu_stats, kvfree]\n\n2. 函数名: netdev_priv\n- 参数: [struct net_device *dev]\n- 调用者: netvsc_get_ethtool_stats\n- 被调用者: []\n\n3. 函数名: rtnl_dereference\n- 参数: [struct net_device_context *ndc]\n- 调用者: netvsc_get_ethtool_stats\n- 被调用者: []\n\n4. 函数名: netvsc_get_vf_stats\n- 参数: [struct net_device *dev, struct netvsc_vf_pcpu_stats *sum]\n- 调用者: netvsc_get_ethtool_stats\n- 被调用者: []\n\n5. 函数名: u64_stats_fetch_begin_irq\n- 参数: [&qstats->syncp]\n- 调用者: netvsc_get_ethtool_stats\n- 被调用者: []\n\n6. 函数名: u64_stats_fetch_retry_irq\n- 参数: [&qstats->syncp, start]\n- 调用者: netvsc_get_ethtool_stats\n- 被调用者: []\n\n7. 函数名: kvmalloc_array\n- 参数: [num_possible_cpus(), sizeof(struct netvsc_ethtool_pcpu_stats), GFP_KERNEL]\n- 调用者: netvsc_get_ethtool_stats\n- 被调用者: []\n\n8. 函数名: netvsc_get_pcpu_stats\n- 参数: [struct net_device *dev, struct netvsc_ethtool_pcpu_stats *pcpu_sum]\n- 调用者: netvsc_get_ethtool_stats\n- 被调用者: []\n\n9. 函数名: kvfree\n- 参数: [pcpu_sum]\n- 调用者: netvsc_get_ethtool_stats\n- 被调用者: []\n\n10. 函数名: num_possible_cpus\n- 参数: []\n- 调用者: netvsc_get_ethtool_stats\n- 被调用者: []\n\n11. 函数名: for_each_present_cpu\n- 参数: [cpu]\n- 调用者: netvsc_get_ethtool_stats\n- 被调用者: []"
    },
    {
        "id": 3554,
        "cwe": "CWE-476",
        "cve": "CVE-2022-3110",
        "purpose": "Code purpose:\"\"\"为网络适配器分配硬件传输结构体数组并初始化队列指针\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未检查kzalloc内存分配是否成功，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: rtw_alloc_hwxmits\n- 参数: [struct adapter *padapter]\n- 调用者: _rtw_init_xmit_priv\n- 被调用者: [kzalloc]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(struct hw_xmit) * pxmitpriv->hwxmit_entry, GFP_KERNEL]\n- 调用者: rtw_alloc_hwxmits\n- 被调用者: []"
    },
    {
        "id": 3555,
        "cwe": "CWE-476",
        "cve": "CVE-2022-3110",
        "purpose": "Code purpose:\"\"\"初始化网络适配器的传输私有数据结构，包括分配内存、初始化队列和缓冲区，为数据传输做准备\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"函数_rtw_init_xmit_priv未检查rtw_alloc_hwxmits()的返回值，导致可能发生空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: _rtw_init_xmit_priv\n- 参数: [pxmitpriv, padapter]\n- 调用者: N/A\n- 被调用者: [spin_lock_init, sema_init, rtw_init_queue, vzalloc, N_BYTE_ALIGMENT, INIT_LIST_HEAD, list_add_tail, rtw_os_xmit_resource_alloc, msleep, rtw_alloc_hwxmits, rtw_init_hwxmits, mutex_init, rtw_sctx_init, rtl8188eu_init_xmit_priv]\n\n2. 函数名: spin_lock_init\n- 参数: [&pxmitpriv->lock]\n- 调用者: _rtw_init_xmit_priv\n- 被调用者: N/A\n\n3. 函数名: sema_init\n- 参数: [&pxmitpriv->terminate_xmitthread_sema, 0]\n- 调用者: _rtw_init_xmit_priv\n- 被调用者: N/A\n\n4. 函数名: rtw_init_queue\n- 参数: [&pxmitpriv->be_pending], [&pxmitpriv->bk_pending], [&pxmitpriv->vi_pending], [&pxmitpriv->vo_pending], [&pxmitpriv->bm_pending], [&pxmitpriv->free_xmit_queue], [&pxmitpriv->free_xmitbuf_queue], [&pxmitpriv->pending_xmitbuf_queue], [&pxmitpriv->free_xmit_extbuf_queue]\n- 调用者: _rtw_init_xmit_priv\n- 被调用者: N/A\n\n5. 函数名: vzalloc\n- 参数: [NR_XMITFRAME * sizeof(struct xmit_frame) + 4], [NR_XMITBUFF * sizeof(struct xmit_buf) + 4], [num_xmit_extbuf * sizeof(struct xmit_buf) + 4]\n- 调用者: _rtw_init_xmit_priv\n- 被调用者: N/A\n\n6. 函数名: N_BYTE_ALIGMENT\n- 参数: [(size_t)(pxmitpriv->pallocated_frame_buf), 4], [(size_t)(pxmitpriv->pallocated_xmitbuf), 4], [(size_t)(pxmitpriv->pallocated_xmit_extbuf), 4]\n- 调用者: _rtw_init_xmit_priv\n- 被调用者: N/A\n\n7. 函数名: INIT_LIST_HEAD\n- 参数: [&pxframe->list], [&pxmitbuf->list]\n- 调用者: _rtw_init_xmit_priv\n- 被调用者: N/A\n\n8. 函数名: list_add_tail\n- 参数: [&pxframe->list, &pxmitpriv->free_xmit_queue.queue], [&pxmitbuf->list, &pxmitpriv->free_xmitbuf_queue.queue], [&pxmitbuf->list, &pxmitpriv->free_xmit_extbuf_queue.queue]\n- 调用者: _rtw_init_xmit_priv\n- 被调用者: N/A\n\n9. 函数名: rtw_os_xmit_resource_alloc\n- 参数: [padapter, pxmitbuf, (MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ)], [padapter, pxmitbuf, max_xmit_extbuf_size + XMITBUF_ALIGN_SZ]\n- 调用者: _rtw_init_xmit_priv\n- 被调用者: N/A\n\n10. 函数名: msleep\n- 参数: [10]\n- 调用者: _rtw_init_xmit_priv\n- 被调用者: N/A\n\n11. 函数名: rtw_alloc_hwxmits\n- 参数: [padapter]\n- 调用者: _rtw_init_xmit_priv\n- 被调用者: N/A\n\n12. 函数名: rtw_init_hwxmits\n- 参数: [pxmitpriv->hwxmits, pxmitpriv->hwxmit_entry]\n- 调用者: _rtw_init_xmit_priv\n- 被调用者: N/A\n\n13. 函数名: mutex_init\n- 参数: [&pxmitpriv->ack_tx_mutex]\n- 调用者: _rtw_init_xmit_priv\n- 被调用者: N/A\n\n14. 函数名: rtw_sctx_init\n- 参数: [&pxmitpriv->ack_tx_ops, 0]\n- 调用者: _rtw_init_xmit_priv\n- 被调用者: N/A\n\n15. 函数名: rtl8188eu_init_xmit_priv\n- 参数: [padapter]\n- 调用者: _rtw_init_xmit_priv\n- 被调用者: N/A"
    },
    {
        "id": 3556,
        "cwe": "CWE-476",
        "cve": "CVE-2022-3111",
        "purpose": "Code purpose:\"\"\"释放与WM8350电源管理芯片充电功能相关的中断资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在free_charger_irq()函数中未释放WM8350_IRQ_CHG_FAST_RDY中断，而该中断在wm8350_init_charger()中被注册，导致内存泄漏。\"\"\"",
        "functions": "Functions:\n1. 函数名: free_charger_irq\n- 参数: [struct wm8350 *wm8350]\n- 调用者: 未显示\n- 被调用者: [wm8350_free_irq]\n\n2. 函数名: wm8350_free_irq\n- 参数: [struct wm8350 *wm8350, int irq, void *data]\n- 调用者: free_charger_irq\n- 被调用者: 未显示"
    },
    {
        "id": 3557,
        "cwe": "CWE-476",
        "cve": "CVE-2022-3112",
        "purpose": "Code purpose:\"\"\"该代码片段实现了视频解码会话中解析器队列的功能，负责处理视频缓冲区数据并将其写入解码器进行解析处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未检查kzalloc()的返回值导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: esparser_queue\n- 参数: [struct amvdec_session *sess, struct vb2_v4l2_buffer *vbuf]\n- 调用者: 未显示\n- 被调用者: [vb2_get_plane_payload, vb2_dma_contig_plane_dma_addr, codec_ops->num_pending_bufs, v4l2_m2m_num_dst_bufs_ready, esparser_vififo_get_free_space, v4l2_m2m_src_buf_remove_by_buf, esparser_get_offset, amvdec_add_ts, dev_dbg, vp9_update_header, amvdec_remove_ts, v4l2_m2m_buf_done, esparser_pad_start_code, esparser_write_data, dev_warn, amvdec_write_parser, atomic_inc]\n\n2. 函数名: vb2_get_plane_payload\n- 参数: [struct vb2_buffer *vb, int plane_no]\n- 调用者: esparser_queue\n- 被调用者: 未显示\n\n3. 函数名: vb2_dma_contig_plane_dma_addr\n- 参数: [struct vb2_buffer *vb, int plane_no]\n- 调用者: esparser_queue\n- 被调用者: 未显示\n\n4. 函数名: num_pending_bufs\n- 参数: [struct amvdec_session *sess]\n- 调用者: esparser_queue\n- 被调用者: 未显示\n\n5. 函数名: v4l2_m2m_num_dst_bufs_ready\n- 参数: [struct v4l2_m2m_ctx *m2m_ctx]\n- 调用者: esparser_queue\n- 被调用者: 未显示\n\n6. 函数名: esparser_vififo_get_free_space\n- 参数: [struct amvdec_session *sess]\n- 调用者: esparser_queue\n- 被调用者: 未显示\n\n7. 函数名: v4l2_m2m_src_buf_remove_by_buf\n- 参数: [struct v4l2_m2m_ctx *m2m_ctx, struct vb2_v4l2_buffer *vbuf]\n- 调用者: esparser_queue\n- 被调用者: 未显示\n\n8. 函数名: esparser_get_offset\n- 参数: [struct amvdec_session *sess]\n- 调用者: esparser_queue\n- 被调用者: 未显示\n\n9. 函数名: amvdec_add_ts\n- 参数: [struct amvdec_session *sess, u64 timestamp, struct v4l2_timecode timecode, u32 offset, u32 flags]\n- 调用者: esparser_queue\n- 被调用者: 未显示\n\n10. 函数名: dev_dbg\n- 参数: [struct device *dev, const char *fmt, ...]\n- 调用者: esparser_queue\n- 被调用者: 未显示\n\n11. 函数名: vp9_update_header\n- 参数: [struct amvdec_core *core, struct vb2_buffer *vb]\n- 调用者: esparser_queue\n- 被调用者: 未显示\n\n12. 函数名: amvdec_remove_ts\n- 参数: [struct amvdec_session *sess, u64 timestamp]\n- 调用者: esparser_queue\n- 被调用者: 未显示\n\n13. 函数名: v4l2_m2m_buf_done\n- 参数: [struct vb2_v4l2_buffer *vbuf, enum vb2_buffer_state state]\n- 调用者: esparser_queue\n- 被调用者: 未显示\n\n14. 函数名: esparser_pad_start_code\n- 参数: [struct amvdec_core *core, struct vb2_buffer *vb, u32 payload_size]\n- 调用者: esparser_queue\n- 被调用者: 未显示\n\n15. 函数名: esparser_write_data\n- 参数: [struct amvdec_core *core, dma_addr_t phy, u32 size]\n- 调用者: esparser_queue\n- 被调用者: 未显示\n\n16. 函数名: dev_warn\n- 参数: [struct device *dev, const char *fmt, ...]\n- 调用者: esparser_queue\n- 被调用者: 未显示\n\n17. 函数名: amvdec_write_parser\n- 参数: [struct amvdec_core *core, u32 cmd, u32 val]\n- 调用者: esparser_queue\n- 被调用者: 未显示\n\n18. 函数名: atomic_inc\n- 参数: [atomic_t *v]\n- 调用者: esparser_queue\n- 被调用者: 未显示"
    },
    {
        "id": 3558,
        "cwe": "CWE-476",
        "cve": "CVE-2022-3112",
        "purpose": "Code purpose:\"\"\"该代码用于为视频解码会话添加时间戳信息，包括分配内存、设置时间戳值并将其添加到会话的时间戳列表中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未检查kzalloc()内存分配是否成功，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: amvdec_add_ts\n- 参数: [struct amvdec_session *sess, u64 ts, struct v4l2_timecode tc, u32 offset, u32 vbuf_flags]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [kzalloc, spin_lock_irqsave, list_add_tail, spin_unlock_irqrestore]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*new_ts), GFP_KERNEL]\n- 调用者: amvdec_add_ts\n- 被调用者: []\n\n3. 函数名: spin_lock_irqsave\n- 参数: [&sess->ts_spinlock, flags]\n- 调用者: amvdec_add_ts\n- 被调用者: []\n\n4. 函数名: list_add_tail\n- 参数: [&new_ts->list, &sess->timestamps]\n- 调用者: amvdec_add_ts\n- 被调用者: []\n\n5. 函数名: spin_unlock_irqrestore\n- 参数: [&sess->ts_spinlock, flags]\n- 调用者: amvdec_add_ts\n- 被调用者: []"
    },
    {
        "id": 3559,
        "cwe": "CWE-476",
        "cve": "CVE-2022-3113",
        "purpose": "Code purpose:\"\"\"初始化视频编解码器的VPU固件，设置相关操作和复位处理程序\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未检查devm_kzalloc()的返回值就直接使用，可能导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: mtk_vcodec_fw_vpu_init\n- 参数: [struct mtk_vcodec_dev *dev, enum mtk_vcodec_fw_use fw_use]\n- 调用者: 未指定\n- 被调用者: [vpu_get_plat_device, mtk_v4l2_err, vpu_wdt_reg_handler, devm_kzalloc]\n\n2. 函数名: vpu_get_plat_device\n- 参数: [struct platform_device *plat_dev]\n- 调用者: mtk_vcodec_fw_vpu_init\n- 被调用者: 未指定\n\n3. 函数名: mtk_v4l2_err\n- 参数: [const char *fmt, ...]\n- 调用者: mtk_vcodec_fw_vpu_init\n- 被调用者: 未指定\n\n4. 函数名: vpu_wdt_reg_handler\n- 参数: [struct platform_device *pdev, void (*handler)(void *, unsigned int), void *priv, enum rst_id id]\n- 调用者: mtk_vcodec_fw_vpu_init\n- 被调用者: 未指定\n\n5. 函数名: devm_kzalloc\n- 参数: [struct device *dev, size_t size, gfp_t gfp]\n- 调用者: mtk_vcodec_fw_vpu_init\n- 被调用者: 未指定\n\n6. 函数名: mtk_vcodec_vpu_reset_handler\n- 参数: [void *priv, unsigned int id]\n- 调用者: vpu_wdt_reg_handler (通过函数指针)\n- 被调用者: 未指定"
    },
    {
        "id": 3560,
        "cwe": "CWE-476",
        "cve": "CVE-2022-3114",
        "purpose": "Code purpose:\"\"\"注册并启用i.MX系列处理器的UART时钟，通过设备树配置时钟资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未检查kcalloc()的返回值就直接使用分配的内存，导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: imx_register_uart_clocks\n- 参数: [unsigned int clk_count]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [kcalloc, of_clk_get, IS_ERR, clk_prepare_enable]\n\n2. 函数名: kcalloc\n- 参数: [size_t n, size_t size, gfp_t flags]\n- 调用者: imx_register_uart_clocks\n- 被调用者: []\n\n3. 函数名: of_clk_get\n- 参数: [struct device_node *np, int index]\n- 调用者: imx_register_uart_clocks\n- 被调用者: []\n\n4. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: imx_register_uart_clocks\n- 被调用者: []\n\n5. 函数名: clk_prepare_enable\n- 参数: [struct clk *clk]\n- 调用者: imx_register_uart_clocks\n- 被调用者: []"
    },
    {
        "id": 3561,
        "cwe": "CWE-476",
        "cve": "CVE-2022-3115",
        "purpose": "Code purpose:\"\"\"该代码片段用于重置显示控制器的状态，包括分配新的状态内存并替换旧状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未检查kzalloc()的内存分配是否成功，导致可能发生空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: malidp_crtc_reset\n- 参数: [struct drm_crtc *crtc]\n- 调用者: 未显示\n- 被调用者: [kzalloc, malidp_crtc_destroy_state, __drm_atomic_helper_crtc_reset]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*state), GFP_KERNEL]\n- 调用者: malidp_crtc_reset\n- 被调用者: 无\n\n3. 函数名: malidp_crtc_destroy_state\n- 参数: [struct drm_crtc *crtc, crtc->state]\n- 调用者: malidp_crtc_reset\n- 被调用者: 无\n\n4. 函数名: __drm_atomic_helper_crtc_reset\n- 参数: [struct drm_crtc *crtc, &state->base]\n- 调用者: malidp_crtc_reset\n- 被调用者: 无"
    },
    {
        "id": 3567,
        "cwe": "CWE-476",
        "cve": "CVE-2022-3202",
        "purpose": "Code purpose:\"\"\"该代码片段实现了JFS文件系统中inode的清理和释放功能，包括处理无链接的inode、释放相关资源以及维护文件系统数据结构。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在jfs_evict_inode函数中，当JFS_SBI(inode->i_sb)->ipimap为空时，调用diFree(inode)会导致空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: jfs_evict_inode\n- 参数: [struct inode *inode]\n- 调用者: 未显示\n- 被调用者: [JFS_IP, jfs_info, is_bad_inode, dquot_initialize, truncate_inode_pages_final, test_cflag, jfs_free_zero_link, diFree, dquot_free_inode, clear_inode, dquot_drop, list_empty, spin_lock_irq, atomic_dec, spin_unlock_irq]\n\n2. 函数名: JFS_IP\n- 参数: [struct inode *inode]\n- 调用者: jfs_evict_inode\n- 被调用者: 未显示\n\n3. 函数名: jfs_info\n- 参数: [const char *fmt, ...]\n- 调用者: jfs_evict_inode\n- 被调用者: 未显示\n\n4. 函数名: is_bad_inode\n- 参数: [struct inode *inode]\n- 调用者: jfs_evict_inode\n- 被调用者: 未显示\n\n5. 函数名: dquot_initialize\n- 参数: [struct inode *inode]\n- 调用者: jfs_evict_inode\n- 被调用者: 未显示\n\n6. 函数名: truncate_inode_pages_final\n- 参数: [struct address_space *mapping]\n- 调用者: jfs_evict_inode\n- 被调用者: 未显示\n\n7. 函数名: test_cflag\n- 参数: [int flag, struct inode *inode]\n- 调用者: jfs_evict_inode\n- 被调用者: 未显示\n\n8. 函数名: jfs_free_zero_link\n- 参数: [struct inode *inode]\n- 调用者: jfs_evict_inode\n- 被调用者: 未显示\n\n9. 函数名: diFree\n- 参数: [struct inode *inode]\n- 调用者: jfs_evict_inode\n- 被调用者: 未显示\n\n10. 函数名: dquot_free_inode\n- 参数: [struct inode *inode]\n- 调用者: jfs_evict_inode\n- 被调用者: 未显示\n\n11. 函数名: clear_inode\n- 参数: [struct inode *inode]\n- 调用者: jfs_evict_inode\n- 被调用者: 未显示\n\n12. 函数名: dquot_drop\n- 参数: [struct inode *inode]\n- 调用者: jfs_evict_inode\n- 被调用者: 未显示\n\n13. 函数名: list_empty\n- 参数: [const struct list_head *head]\n- 调用者: jfs_evict_inode\n- 被调用者: 未显示\n\n14. 函数名: spin_lock_irq\n- 参数: [spinlock_t *lock]\n- 调用者: jfs_evict_inode\n- 被调用者: 未显示\n\n15. 函数名: atomic_dec\n- 参数: [atomic_t *v]\n- 调用者: jfs_evict_inode\n- 被调用者: 未显示\n\n16. 函数名: spin_unlock_irq\n- 参数: [spinlock_t *lock]\n- 调用者: jfs_evict_inode\n- 被调用者: 未显示"
    },
    {
        "id": 3704,
        "cwe": "CWE-476",
        "cve": "CVE-2022-40476",
        "purpose": "Code purpose:\"\"\"跟踪IO请求的飞行状态并增加计数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未对current->io_uring指针进行空指针检查就直接访问其成员inflight_tracked，可能导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: io_req_track_inflight\n- 参数: [struct io_kiocb *req]\n- 调用者: 未提供\n- 被调用者: [atomic_inc]"
    },
    {
        "id": 3714,
        "cwe": "CWE-476",
        "cve": "CVE-2022-4127",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理文件描述符的更新和分配操作，通过用户空间传入的文件描述符数组进行文件获取和固定索引分配。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理用户提供的文件描述符时，未充分验证fget()返回的file指针是否为NULL，导致可能发生空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_files_update_with_index_alloc\n- 参数: [req, issue_flags]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [u64_to_user_ptr, copy_from_user, fget, io_fixed_fd_install, copy_to_user, __io_close_fixed]\n\n2. 函数名: u64_to_user_ptr\n- 参数: [req->rsrc_update.arg]\n- 调用者: io_files_update_with_index_alloc\n- 被调用者: []\n\n3. 函数名: copy_from_user\n- 参数: [&fd, &fds[done], sizeof(fd)]\n- 调用者: io_files_update_with_index_alloc\n- 被调用者: []\n\n4. 函数名: fget\n- 参数: [fd]\n- 调用者: io_files_update_with_index_alloc\n- 被调用者: []\n\n5. 函数名: io_fixed_fd_install\n- 参数: [req, issue_flags, file, IORING_FILE_INDEX_ALLOC]\n- 调用者: io_files_update_with_index_alloc\n- 被调用者: []\n\n6. 函数名: copy_to_user\n- 参数: [&fds[done], &ret, sizeof(ret)]\n- 调用者: io_files_update_with_index_alloc\n- 被调用者: []\n\n7. 函数名: __io_close_fixed\n- 参数: [req, issue_flags, ret]\n- 调用者: io_files_update_with_index_alloc\n- 被调用者: []"
    },
    {
        "id": 3715,
        "cwe": "CWE-476",
        "cve": "CVE-2022-4128",
        "purpose": "Code purpose:\"\"\"在MPTCP协议断开连接时清理子流和相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在MPTCP协议断开连接时遍历子流列表时未正确处理空指针情况，导致本地用户可能通过触发空指针解引用使系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: mptcp_disconnect\n- 参数: [struct sock *sk, int flags]\n- 调用者: 未显示\n- 被调用者: [mptcp_sk, inet_sk_state_store, mptcp_for_each_subflow, mptcp_subflow_tcp_sock, __mptcp_close_ssk, mptcp_stop_timer, sk_stop_timer, mptcp_event, mptcp_destroy_common, WRITE_ONCE, mptcp_is_checksum_enabled, sock_net, mptcp_pm_data_reset, mptcp_ca_reset, sk_error_report]\n\n2. 函数名: mptcp_sk\n- 参数: [struct sock *sk]\n- 调用者: mptcp_disconnect\n- 被调用者: 未显示\n\n3. 函数名: inet_sk_state_store\n- 参数: [struct sock *sk, TCP_CLOSE]\n- 调用者: mptcp_disconnect\n- 被调用者: 未显示\n\n4. 函数名: mptcp_for_each_subflow\n- 参数: [struct mptcp_sock *msk, struct mptcp_subflow_context *subflow]\n- 调用者: mptcp_disconnect\n- 被调用者: [mptcp_subflow_tcp_sock, __mptcp_close_ssk]\n\n5. 函数名: mptcp_subflow_tcp_sock\n- 参数: [struct mptcp_subflow_context *subflow]\n- 调用者: mptcp_for_each_subflow\n- 被调用者: 未显示\n\n6. 函数名: __mptcp_close_ssk\n- 参数: [struct sock *sk, struct sock *ssk, struct mptcp_subflow_context *subflow, MPTCP_CF_FASTCLOSE]\n- 调用者: mptcp_for_each_subflow\n- 被调用者: 未显示\n\n7. 函数名: mptcp_stop_timer\n- 参数: [struct sock *sk]\n- 调用者: mptcp_disconnect\n- 被调用者: 未显示\n\n8. 函数名: sk_stop_timer\n- 参数: [struct sock *sk, &sk->sk_timer]\n- 调用者: mptcp_disconnect\n- 被调用者: 未显示\n\n9. 函数名: mptcp_event\n- 参数: [MPTCP_EVENT_CLOSED, mptcp_sk(sk), NULL, GFP_KERNEL]\n- 调用者: mptcp_disconnect\n- 被调用者: 未显示\n\n10. 函数名: mptcp_destroy_common\n- 参数: [struct mptcp_sock *msk]\n- 调用者: mptcp_disconnect\n- 被调用者: 未显示\n\n11. 函数名: WRITE_ONCE\n- 参数: [msk->flags, 0], [msk->csum_enabled, mptcp_is_checksum_enabled(sock_net(sk))]\n- 调用者: mptcp_disconnect\n- 被调用者: [mptcp_is_checksum_enabled, sock_net]\n\n12. 函数名: mptcp_is_checksum_enabled\n- 参数: [sock_net(sk)]\n- 调用者: WRITE_ONCE\n- 被调用者: [sock_net]\n\n13. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: mptcp_is_checksum_enabled\n- 被调用者: 未显示\n\n14. 函数名: mptcp_pm_data_reset\n- 参数: [struct mptcp_sock *msk]\n- 调用者: mptcp_disconnect\n- 被调用者: 未显示\n\n15. 函数名: mptcp_ca_reset\n- 参数: [struct sock *sk]\n- 调用者: mptcp_disconnect\n- 被调用者: 未显示\n\n16. 函数名: sk_error_report\n- 参数: [struct sock *sk]\n- 调用者: mptcp_disconnect\n- 被调用者: 未显示"
    },
    {
        "id": 3737,
        "cwe": "CWE-476",
        "cve": "CVE-2022-42722",
        "purpose": "Code purpose:\"\"\"该代码实现了IEEE 802.11无线网络数据帧的解密处理功能，包括密钥选择、解密操作及错误处理等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理P2P设备的信标保护时，代码未能正确验证指针是否为空，导致攻击者可通过注入特定WLAN帧触发空指针解引用造成拒绝服务。\"\"\"",
        "functions": "Functions:\n1. 函数名: ieee80211_rx_h_decrypt\n- 参数: [struct ieee80211_rx_data *rx]\n- 调用者: N/A (top-level function)\n- 被调用者: [ieee80211_is_ext, ieee80211_has_protected, ieee80211_get_keyid, ieee80211_get_mmie_keyidx, is_multicast_ether_addr, ieee80211_is_beacon, cfg80211_rx_unprot_mlme_mgmt, ieee80211_rx_get_bigtk, ieee80211_is_group_privacy_action, test_sta_flag, ieee80211_is_mgmt, ieee80211_crypto_wep_decrypt, ieee80211_crypto_tkip_decrypt, ieee80211_crypto_ccmp_decrypt, ieee80211_crypto_aes_cmac_decrypt, ieee80211_crypto_aes_cmac_256_decrypt, ieee80211_crypto_aes_gmac_decrypt, ieee80211_crypto_gcmp_decrypt]\n\n2. 函数名: ieee80211_is_ext\n- 参数: [__le16 frame_control]\n- 调用者: ieee80211_rx_h_decrypt\n- 被调用者: []\n\n3. 函数名: ieee80211_has_protected\n- 参数: [__le16 fc]\n- 调用者: ieee80211_rx_h_decrypt\n- 被调用者: []\n\n4. 函数名: ieee80211_get_keyid\n- 参数: [struct sk_buff *skb]\n- 调用者: ieee80211_rx_h_decrypt\n- 被调用者: []\n\n5. 函数名: ieee80211_get_mmie_keyidx\n- 参数: [struct sk_buff *skb]\n- 调用者: ieee80211_rx_h_decrypt\n- 被调用者: []\n\n6. 函数名: is_multicast_ether_addr\n- 参数: [const u8 *addr]\n- 调用者: ieee80211_rx_h_decrypt\n- 被调用者: []\n\n7. 函数名: ieee80211_is_beacon\n- 参数: [__le16 fc]\n- 调用者: ieee80211_rx_h_decrypt\n- 被调用者: []\n\n8. 函数名: cfg80211_rx_unprot_mlme_mgmt\n- 参数: [struct net_device *dev, const u8 *buf, size_t len]\n- 调用者: ieee80211_rx_h_decrypt\n- 被调用者: []\n\n9. 函数名: ieee80211_rx_get_bigtk\n- 参数: [struct ieee80211_rx_data *rx, int keyidx]\n- 调用者: ieee80211_rx_h_decrypt\n- 被调用者: []\n\n10. 函数名: ieee80211_is_group_privacy_action\n- 参数: [struct sk_buff *skb]\n- 调用者: ieee80211_rx_h_decrypt\n- 被调用者: []\n\n11. 函数名: test_sta_flag\n- 参数: [struct sta_info *sta, enum ieee80211_sta_info_flags flag]\n- 调用者: ieee80211_rx_h_decrypt\n- 被调用者: []\n\n12. 函数名: ieee80211_is_mgmt\n- 参数: [__le16 fc]\n- 调用者: ieee80211_rx_h_decrypt\n- 被调用者: []\n\n13. 函数名: ieee80211_crypto_wep_decrypt\n- 参数: [struct ieee80211_rx_data *rx]\n- 调用者: ieee80211_rx_h_decrypt\n- 被调用者: []\n\n14. 函数名: ieee80211_crypto_tkip_decrypt\n- 参数: [struct ieee80211_rx_data *rx]\n- 调用者: ieee80211_rx_h_decrypt\n- 被调用者: []\n\n15. 函数名: ieee80211_crypto_ccmp_decrypt\n- 参数: [struct ieee80211_rx_data *rx, int mic_len]\n- 调用者: ieee80211_rx_h_decrypt\n- 被调用者: []\n\n16. 函数名: ieee80211_crypto_aes_cmac_decrypt\n- 参数: [struct ieee80211_rx_data *rx]\n- 调用者: ieee80211_rx_h_decrypt\n- 被调用者: []\n\n17. 函数名: ieee80211_crypto_aes_cmac_256_decrypt\n- 参数: [struct ieee80211_rx_data *rx]\n- 调用者: ieee80211_rx_h_decrypt\n- 被调用者: []\n\n18. 函数名: ieee80211_crypto_aes_gmac_decrypt\n- 参数: [struct ieee80211_rx_data *rx]\n- 调用者: ieee80211_rx_h_decrypt\n- 被调用者: []\n\n19. 函数名: ieee80211_crypto_gcmp_decrypt\n- 参数: [struct ieee80211_rx_data *rx]\n- 调用者: ieee80211_rx_h_decrypt\n- 被调用者: []"
    },
    {
        "id": 3766,
        "cwe": "CWE-476",
        "cve": "CVE-2022-47929",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中流量控制子系统中的qdisc嫁接功能，用于替换或修改网络设备上的队列规则和类结构。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当设备没有入口队列时，代码未正确处理dev_ingress_queue(dev)返回NULL的情况，导致后续对dev_queue的访问引发空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: qdisc_graft\n- 参数: [struct net_device *dev, struct Qdisc *parent, struct sk_buff *skb, struct nlmsghdr *n, u32 classid, struct Qdisc *new, struct Qdisc *old, struct netlink_ext_ack *extack]\n- 调用者: N/A (kernel internal function)\n- 被调用者: [dev_net, dev_ingress_queue, dev_deactivate, qdisc_offload_graft_root, netdev_get_tx_queue, dev_graft_qdisc, qdisc_refcount_inc, qdisc_put, rtnl_dereference, notify_and_destroy, qdisc_clear_nolock, dev_activate]\n\n2. 函数名: dev_net\n- 参数: [struct net_device *dev]\n- 调用者: qdisc_graft\n- 被调用者: N/A\n\n3. 函数名: dev_ingress_queue\n- 参数: [struct net_device *dev]\n- 调用者: qdisc_graft\n- 被调用者: N/A\n\n4. 函数名: dev_deactivate\n- 参数: [struct net_device *dev]\n- 调用者: qdisc_graft\n- 被调用者: N/A\n\n5. 函数名: qdisc_offload_graft_root\n- 参数: [struct net_device *dev, struct Qdisc *new, struct Qdisc *old, struct netlink_ext_ack *extack]\n- 调用者: qdisc_graft\n- 被调用者: N/A\n\n6. 函数名: netdev_get_tx_queue\n- 参数: [struct net_device *dev, unsigned int index]\n- 调用者: qdisc_graft\n- 被调用者: N/A\n\n7. 函数名: dev_graft_qdisc\n- 参数: [struct netdev_queue *dev_queue, struct Qdisc *new]\n- 调用者: qdisc_graft\n- 被调用者: N/A\n\n8. 函数名: qdisc_refcount_inc\n- 参数: [struct Qdisc *q]\n- 调用者: qdisc_graft\n- 被调用者: N/A\n\n9. 函数名: qdisc_put\n- 参数: [struct Qdisc *q]\n- 调用者: qdisc_graft\n- 被调用者: N/A\n\n10. 函数名: rtnl_dereference\n- 参数: [struct Qdisc *q]\n- 调用者: qdisc_graft\n- 被调用者: N/A\n\n11. 函数名: notify_and_destroy\n- 参数: [struct net *net, struct sk_buff *skb, struct nlmsghdr *n, u32 classid, struct Qdisc *old, struct Qdisc *new]\n- 调用者: qdisc_graft\n- 被调用者: N/A\n\n12. 函数名: qdisc_clear_nolock\n- 参数: [struct Qdisc *q]\n- 调用者: qdisc_graft\n- 被调用者: N/A\n\n13. 函数名: dev_activate\n- 参数: [struct net_device *dev]\n- 调用者: qdisc_graft\n- 被调用者: N/A"
    },
    {
        "id": 3788,
        "cwe": "CWE-476",
        "cve": "CVE-2022-4842",
        "purpose": "Code purpose:\"\"\"该代码用于在NTFS3驱动中实现文件打孔功能，即释放文件中指定范围的簇并将其置为稀疏状态，同时更新文件属性和元数据。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在attr_punch_hole函数中，当处理resident属性时，错误地引用了未初始化的attr指针而非attr_b，导致空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: attr_punch_hole\n- 参数: [ni, vbo, bytes, frame_size]\n- 调用者: 无（顶级函数）\n- 被调用者: [ni_find_attr, min_t, memset, resident_data, is_attr_ext, le32_to_cpu, le64_to_cpu, down_write, run_init, run_truncate, run_clone, run_add_entry, mi_pack_runs, ni_insert_nonresident, run_deallocate_ex, ni_enum_attr_ex, inode_set_bytes, mark_inode_dirty, run_close, up_write, _ntfs_bad_inode]\n\n2. 函数名: ni_find_attr\n- 参数: [ni, attr, le, type, name, name_len, vcn, mi]\n- 调用者: attr_punch_hole\n- 被调用者: 无\n\n3. 函数名: min_t\n- 参数: [type, x, y]\n- 调用者: attr_punch_hole\n- 被调用者: 无\n\n4. 函数名: memset\n- 参数: [ptr, value, num]\n- 调用者: attr_punch_hole\n- 被调用者: 无\n\n5. 函数名: resident_data\n- 参数: [attr]\n- 调用者: attr_punch_hole\n- 被调用者: 无\n\n6. 函数名: is_attr_ext\n- 参数: [attr]\n- 调用者: attr_punch_hole\n- 被调用者: 无\n\n7. 函数名: le32_to_cpu\n- 参数: [val]\n- 调用者: attr_punch_hole\n- 被调用者: 无\n\n8. 函数名: le64_to_cpu\n- 参数: [val]\n- 调用者: attr_punch_hole\n- 被调用者: 无\n\n9. 函数名: down_write\n- 参数: [sem]\n- 调用者: attr_punch_hole\n- 被调用者: 无\n\n10. 函数名: run_init\n- 参数: [run]\n- 调用者: attr_punch_hole\n- 被调用者: 无\n\n11. 函数名: run_truncate\n- 参数: [run, size]\n- 调用者: attr_punch_hole\n- 被调用者: 无\n\n12. 函数名: run_clone\n- 参数: [run, run2]\n- 调用者: attr_punch_hole\n- 被调用者: 无\n\n13. 函数名: run_add_entry\n- 参数: [run, vcn, lcn, len, is_mft]\n- 调用者: attr_punch_hole\n- 被调用者: 无\n\n14. 函数名: mi_pack_runs\n- 参数: [mi, attr, run, evcn]\n- 调用者: attr_punch_hole\n- 被调用者: 无\n\n15. 函数名: ni_insert_nonresident\n- 参数: [ni, type, name, name_len, run, svcn, len, flags, attr, mi, le]\n- 调用者: attr_punch_hole\n- 被调用者: 无\n\n16. 函数名: run_deallocate_ex\n- 参数: [sbi, run, vcn, len, hole, dealloc]\n- 调用者: attr_punch_hole\n- 被调用者: 无\n\n17. 函数名: ni_enum_attr_ex\n- 参数: [ni, attr, le, mi]\n- 调用者: attr_punch_hole\n- 被调用者: 无\n\n18. 函数名: inode_set_bytes\n- 参数: [inode, bytes]\n- 调用者: attr_punch_hole\n- 被调用者: 无\n\n19. 函数名: mark_inode_dirty\n- 参数: [inode]\n- 调用者: attr_punch_hole\n- 被调用者: 无\n\n20. 函数名: run_close\n- 参数: [run]\n- 调用者: attr_punch_hole\n- 被调用者: 无\n\n21. 函数名: up_write\n- 参数: [sem]\n- 调用者: attr_punch_hole\n- 被调用者: 无\n\n22. 函数名: _ntfs_bad_inode\n- 参数: [inode]\n- 调用者: attr_punch_hole\n- 被调用者: 无"
    },
    {
        "id": 3810,
        "cwe": "CWE-476",
        "cve": "CVE-2023-0122",
        "purpose": "Code purpose:\"\"\"该代码用于设置NVMe控制器的认证参数，包括主机认证和控制器认证的密钥及哈希算法，并处理相关的错误情况。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在nvmet_setup_auth()函数中，当处理dhchap_ctrl_secret时未对ctrl_key进行NULL检查就直接访问其成员，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: nvmet_setup_auth\n- 参数: [struct nvmet_ctrl *ctrl]\n- 调用者: (未在代码片段中显示)\n- 被调用者: [down_read, nvmet_is_disc_subsys, strcmp, nvmet_setup_dhgroup, nvme_auth_hmac_name, nvme_auth_free_key, nvme_auth_extract_key, up_read]\n\n2. 函数名: down_read\n- 参数: [&nvmet_config_sem]\n- 调用者: nvmet_setup_auth\n- 被调用者: (未在代码片段中显示)\n\n3. 函数名: nvmet_is_disc_subsys\n- 参数: [ctrl->subsys]\n- 调用者: nvmet_setup_auth\n- 被调用者: (未在代码片段中显示)\n\n4. 函数名: strcmp\n- 参数: [nvmet_host_name(p->host), ctrl->hostnqn]\n- 调用者: nvmet_setup_auth\n- 被调用者: (未在代码片段中显示)\n\n5. 函数名: nvmet_setup_dhgroup\n- 参数: [ctrl, host->dhchap_dhgroup_id]\n- 调用者: nvmet_setup_auth\n- 被调用者: (未在代码片段中显示)\n\n6. 函数名: nvme_auth_hmac_name\n- 参数: [host->dhchap_hash_id]\n- 调用者: nvmet_setup_auth\n- 被调用者: (未在代码片段中显示)\n\n7. 函数名: nvme_auth_free_key\n- 参数: [ctrl->host_key], [ctrl->ctrl_key]\n- 调用者: nvmet_setup_auth\n- 被调用者: (未在代码片段中显示)\n\n8. 函数名: nvme_auth_extract_key\n- 参数: [host->dhchap_secret + 10, host->dhchap_key_hash], [host->dhchap_ctrl_secret + 10, host->dhchap_ctrl_key_hash]\n- 调用者: nvmet_setup_auth\n- 被调用者: (未在代码片段中显示)\n\n9. 函数名: up_read\n- 参数: [&nvmet_config_sem]\n- 调用者: nvmet_setup_auth\n- 被调用者: (未在代码片段中显示)"
    },
    {
        "id": 3824,
        "cwe": "CWE-476",
        "cve": "CVE-2023-0394",
        "purpose": "Code purpose:\"\"\"处理IPv6原始套接字待发送数据帧的校验和计算与发送\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在rawv6_push_pending_frames函数中，当处理校验和时，如果csum_skb未被初始化且offset调整后仍不满足条件，会导致后续对未初始化的csum_skb进行解引用操作，引发空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: rawv6_push_pending_frames\n- 参数: [sk, fl6, rp]\n- 调用者: 未显示\n- 被调用者: [skb_peek, ip6_flush_pending_frames, skb_queue_len, skb_queue_walk, csum_add, skb_transport_offset, skb_copy_bits, csum_sub, csum_unfold, csum_ipv6_magic, skb_store_bits, ip6_push_pending_frames]\n\n2. 函数名: skb_peek\n- 参数: [&sk->sk_write_queue]\n- 调用者: rawv6_push_pending_frames\n- 被调用者: 未显示\n\n3. 函数名: ip6_flush_pending_frames\n- 参数: [sk]\n- 调用者: rawv6_push_pending_frames\n- 被调用者: 未显示\n\n4. 函数名: skb_queue_len\n- 参数: [&sk->sk_write_queue]\n- 调用者: rawv6_push_pending_frames\n- 被调用者: 未显示\n\n5. 函数名: skb_queue_walk\n- 参数: [&sk->sk_write_queue, skb]\n- 调用者: rawv6_push_pending_frames\n- 被调用者: 未显示\n\n6. 函数名: csum_add\n- 参数: [tmp_csum, skb->csum]\n- 调用者: rawv6_push_pending_frames\n- 被调用者: 未显示\n\n7. 函数名: skb_transport_offset\n- 参数: [skb]\n- 调用者: rawv6_push_pending_frames\n- 被调用者: 未显示\n\n8. 函数名: skb_copy_bits\n- 参数: [skb, offset, &csum, 2]\n- 调用者: rawv6_push_pending_frames\n- 被调用者: 未显示\n\n9. 函数名: csum_sub\n- 参数: [tmp_csum, csum_unfold(csum)]\n- 调用者: rawv6_push_pending_frames\n- 被调用者: 未显示\n\n10. 函数名: csum_unfold\n- 参数: [csum]\n- 调用者: rawv6_push_pending_frames\n- 被调用者: 未显示\n\n11. 函数名: csum_ipv6_magic\n- 参数: [&fl6->saddr, &fl6->daddr, total_len, fl6->flowi6_proto, tmp_csum]\n- 调用者: rawv6_push_pending_frames\n- 被调用者: 未显示\n\n12. 函数名: skb_store_bits\n- 参数: [skb, offset, &csum, 2]\n- 调用者: rawv6_push_pending_frames\n- 被调用者: 未显示\n\n13. 函数名: ip6_push_pending_frames\n- 参数: [sk]\n- 调用者: rawv6_push_pending_frames\n- 被调用者: 未显示"
    },
    {
        "id": 3825,
        "cwe": "CWE-476",
        "cve": "CVE-2023-0458",
        "purpose": "Code purpose:\"\"\"该代码用于实现Linux内核中对进程资源限制(prlimit)的设置和获取功能，包括检查资源限制值的有效性并进行相应更新。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在do_prlimit()函数中，未对resource参数进行充分验证，导致可能通过受控的resource值进行越界访问，造成信息泄露。\"\"\"",
        "functions": "Functions:\n1. 函数名: do_prlimit\n- 参数: [struct task_struct *tsk, unsigned int resource, struct rlimit *new_rlim, struct rlimit *old_rlim]\n- 调用者: 未明确（通常是系统调用或内核其他模块）\n- 被调用者: [capable, security_task_setrlimit, task_lock, task_unlock, update_rlimit_cpu]\n\n2. 函数名: capable\n- 参数: [CAP_SYS_RESOURCE]\n- 调用者: do_prlimit\n- 被调用者: []\n\n3. 函数名: security_task_setrlimit\n- 参数: [struct task_struct *tsk, unsigned int resource, struct rlimit *new_rlim]\n- 调用者: do_prlimit\n- 被调用者: []\n\n4. 函数名: task_lock\n- 参数: [struct task_struct *tsk->group_leader]\n- 调用者: do_prlimit\n- 被调用者: []\n\n5. 函数名: task_unlock\n- 参数: [struct task_struct *tsk->group_leader]\n- 调用者: do_prlimit\n- 被调用者: []\n\n6. 函数名: update_rlimit_cpu\n- 参数: [struct task_struct *tsk->group_leader, new_rlim->rlim_cur]\n- 调用者: do_prlimit\n- 被调用者: []"
    },
    {
        "id": 3848,
        "cwe": "CWE-476",
        "cve": "CVE-2023-1095",
        "purpose": "Code purpose:\"\"\"为nftables事务分配内存并初始化事务结构体\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在事务对象未被正确初始化并添加到链表的情况下，尝试调用list_del()进行删除操作导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_trans_alloc_gfp\n- 参数: [const struct nft_ctx *ctx, int msg_type, u32 size, gfp_t gfp]\n- 调用者: nf_tables_updtable (根据漏洞描述推断)\n- 被调用者: [kzalloc]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(struct nft_trans) + size, gfp]\n- 调用者: nft_trans_alloc_gfp\n- 被调用者: []\n\n3. 函数名: nft_trans_destroy\n- 参数: [struct nft_trans *trans] (根据漏洞描述推断)\n- 调用者: nf_tables_updtable (根据漏洞描述推断)\n- 被调用者: [list_del]\n\n4. 函数名: list_del\n- 参数: [struct list_head *entry] (根据漏洞描述推断)\n- 调用者: nft_trans_destroy\n- 被调用者: []\n\n5. 函数名: nf_tables_table_enable\n- 参数: [] (根据漏洞描述推断)\n- 调用者: nf_tables_updtable (根据漏洞描述推断)\n- 被调用者: []\n\n6. 函数名: nf_tables_updtable\n- 参数: [] (根据漏洞描述推断)\n- 调用者: 未明确\n- 被调用者: [nft_trans_alloc_gfp, nft_trans_destroy, nf_tables_table_enable]"
    },
    {
        "id": 3865,
        "cwe": "CWE-476",
        "cve": "CVE-2023-1382",
        "purpose": "Code purpose:\"\"\"该代码用于在TIPC协议中处理内核订阅请求，包括分配连接、设置订阅参数并进行接收处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在分配con和设置con->sock之间存在数据竞争，导致可能访问到未初始化的con->sock指针\"\"\"",
        "functions": "Functions:\n1. 函数名: tipc_topsrv_kern_subscr\n- 参数: [net, port, type, lower, upper, filter, conid]\n- 调用者: N/A\n- 被调用者: [tipc_topsrv, tipc_conn_alloc, IS_ERR, tipc_conn_rcv_sub, conn_put]\n\n2. 函数名: tipc_topsrv\n- 参数: [net]\n- 调用者: tipc_topsrv_kern_subscr\n- 被调用者: N/A\n\n3. 函数名: tipc_conn_alloc\n- 参数: [tipc_topsrv(net)]\n- 调用者: tipc_topsrv_kern_subscr\n- 被调用者: N/A\n\n4. 函数名: IS_ERR\n- 参数: [con]\n- 调用者: tipc_topsrv_kern_subscr\n- 被调用者: N/A\n\n5. 函数名: tipc_conn_rcv_sub\n- 参数: [tipc_topsrv(net), con, &sub]\n- 调用者: tipc_topsrv_kern_subscr\n- 被调用者: N/A\n\n6. 函数名: conn_put\n- 参数: [con]\n- 调用者: tipc_topsrv_kern_subscr\n- 被调用者: N/A"
    },
    {
        "id": 3866,
        "cwe": "CWE-476",
        "cve": "CVE-2023-1382",
        "purpose": "Code purpose:\"\"\"处理TIPC协议中的服务端连接请求，包括接受新连接、分配连接资源并设置回调函数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在con分配和con->sock设置之间存在数据竞争，导致可能访问到未初始化的con->sock->sk造成空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: tipc_topsrv_accept\n- 参数: [work]\n- 调用者: 未显示（由工作队列调用）\n- 被调用者: [container_of, kernel_accept, tipc_conn_alloc, IS_ERR, PTR_ERR, sock_release, write_lock_bh, write_unlock_bh]\n\n2. 函数名: container_of\n- 参数: [work, struct tipc_topsrv, awork]\n- 调用者: tipc_topsrv_accept\n- 被调用者: []\n\n3. 函数名: kernel_accept\n- 参数: [lsock, &newsock, O_NONBLOCK]\n- 调用者: tipc_topsrv_accept\n- 被调用者: []\n\n4. 函数名: tipc_conn_alloc\n- 参数: [srv]\n- 调用者: tipc_topsrv_accept\n- 被调用者: []\n\n5. 函数名: IS_ERR\n- 参数: [con]\n- 调用者: tipc_topsrv_accept\n- 被调用者: []\n\n6. 函数名: PTR_ERR\n- 参数: [con]\n- 调用者: tipc_topsrv_accept\n- 被调用者: []\n\n7. 函数名: sock_release\n- 参数: [newsock]\n- 调用者: tipc_topsrv_accept\n- 被调用者: []\n\n8. 函数名: write_lock_bh\n- 参数: [&newsk->sk_callback_lock]\n- 调用者: tipc_topsrv_accept\n- 被调用者: []\n\n9. 函数名: write_unlock_bh\n- 参数: [&newsk->sk_callback_lock]\n- 调用者: tipc_topsrv_accept\n- 被调用者: []"
    },
    {
        "id": 3872,
        "cwe": "CWE-476",
        "cve": "CVE-2023-1583",
        "purpose": "Code purpose:\"\"\"在io_uring子系统中查找文件表中下一个可用的文件描述符索引\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当固定文件被注销时，未清除相关的上下文信息(file_alloc_{start,end}和alloc_hint)，导致后续启用自动索引选择的请求可能引发空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: io_file_bitmap_get\n- 参数: [struct io_ring_ctx *ctx]\n- 调用者: 未明确（由漏洞描述推测可能是IORING_FILE_INDEX_ALLOC相关调用）\n- 被调用者: [find_next_zero_bit]"
    },
    {
        "id": 3873,
        "cwe": "CWE-476",
        "cve": "CVE-2023-1583",
        "purpose": "Code purpose:\"\"\"在io_uring子系统中取消注册文件时清理文件表和相关资源，但存在未完全清除上下文信息的问题可能导致空指针解引用漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在取消注册固定文件时未清除上下文信息(file_alloc_{start,end}和alloc_hint)，导致后续启用自动索引选择的请求可能引发空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: __io_sqe_files_unregister\n- 参数: [struct io_ring_ctx *ctx]\n- 调用者: 未显示\n- 被调用者: [io_file_from_index, io_file_need_scm, io_file_bitmap_clear, fput, skb_dequeue, kfree_skb, io_free_file_tables, io_rsrc_data_free]\n\n2. 函数名: io_file_from_index\n- 参数: [&ctx->file_table, i]\n- 调用者: __io_sqe_files_unregister\n- 被调用者: 未显示\n\n3. 函数名: io_file_need_scm\n- 参数: [file]\n- 调用者: __io_sqe_files_unregister\n- 被调用者: 未显示\n\n4. 函数名: io_file_bitmap_clear\n- 参数: [&ctx->file_table, i]\n- 调用者: __io_sqe_files_unregister\n- 被调用者: 未显示\n\n5. 函数名: fput\n- 参数: [file]\n- 调用者: __io_sqe_files_unregister\n- 被调用者: 未显示\n\n6. 函数名: skb_dequeue\n- 参数: [&sock->sk_receive_queue]\n- 调用者: __io_sqe_files_unregister\n- 被调用者: 未显示\n\n7. 函数名: kfree_skb\n- 参数: [skb]\n- 调用者: __io_sqe_files_unregister\n- 被调用者: 未显示\n\n8. 函数名: io_free_file_tables\n- 参数: [&ctx->file_table]\n- 调用者: __io_sqe_files_unregister\n- 被调用者: 未显示\n\n9. 函数名: io_rsrc_data_free\n- 参数: [ctx->file_data]\n- 调用者: __io_sqe_files_unregister\n- 被调用者: 未显示"
    },
    {
        "id": 3926,
        "cwe": "CWE-476",
        "cve": "CVE-2023-2166",
        "purpose": "Code purpose:\"\"\"该代码片段用于处理接收到的CAN帧数据包，验证其有效性并通过can_receive函数进行后续处理，同时过滤掉不符合要求的CAN数据包。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在接收CAN帧的路径中，ml_priv可能未被初始化，导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: can_rcv\n- 参数: [struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev]\n- 调用者: 未明确显示（通常由网络协议栈调用）\n- 被调用者: [pr_warn_once, kfree_skb, can_receive]\n\n2. 函数名: pr_warn_once\n- 参数: [const char *fmt, ...]\n- 调用者: can_rcv\n- 被调用者: []\n\n3. 函数名: kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: can_rcv\n- 被调用者: []\n\n4. 函数名: can_receive\n- 参数: [struct sk_buff *skb, struct net_device *dev]\n- 调用者: can_rcv\n- 被调用者: []\n\n5. 函数名: can_is_can_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: can_rcv\n- 被调用者: []"
    },
    {
        "id": 3927,
        "cwe": "CWE-476",
        "cve": "CVE-2023-2166",
        "purpose": "Code purpose:\"\"\"该代码片段实现了CAN FD协议接收路径中对非标准数据包的过滤和处理功能，确保只有符合规范的CAN FD帧会被进一步处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在接收CAN帧的路径中，ml_priv可能未被初始化，导致空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: canfd_rcv\n- 参数: [struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev]\n- 调用者: 未指定（由网络协议栈调用）\n- 被调用者: [can_is_canfd_skb, pr_warn_once, kfree_skb, can_receive]\n\n2. 函数名: can_is_canfd_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: canfd_rcv\n- 被调用者: 未指定\n\n3. 函数名: pr_warn_once\n- 参数: [const char *fmt, ...]\n- 调用者: canfd_rcv\n- 被调用者: 未指定\n\n4. 函数名: kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: canfd_rcv\n- 被调用者: 未指定\n\n5. 函数名: can_receive\n- 参数: [struct sk_buff *skb, struct net_device *dev]\n- 调用者: canfd_rcv\n- 被调用者: 未指定"
    },
    {
        "id": 3928,
        "cwe": "CWE-476",
        "cve": "CVE-2023-2166",
        "purpose": "Code purpose:\"\"\"该代码片段用于处理接收到的CAN XL网络数据包，验证其有效性后传递给上层处理或丢弃无效数据包\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在接收CAN帧的路径中，ml_priv可能未被初始化，导致空指针解引用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: canxl_rcv\n- 参数: [struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev]\n- 调用者: 未指定（通常由网络协议栈调用）\n- 被调用者: [unlikely, pr_warn_once, kfree_skb, can_receive]\n\n2. 函数名: unlikely\n- 参数: [条件表达式]\n- 调用者: canxl_rcv\n- 被调用者: []\n\n3. 函数名: pr_warn_once\n- 参数: [格式化字符串, dev->type, skb->len]\n- 调用者: canxl_rcv\n- 被调用者: []\n\n4. 函数名: kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: canxl_rcv\n- 被调用者: []\n\n5. 函数名: can_receive\n- 参数: [struct sk_buff *skb, struct net_device *dev]\n- 调用者: canxl_rcv\n- 被调用者: []\n\n6. 函数名: can_is_canxl_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: canxl_rcv\n- 被调用者: []"
    },
    {
        "id": 3932,
        "cwe": "CWE-476",
        "cve": "CVE-2023-2177",
        "purpose": "Code purpose:\"\"\"初始化SCTP协议中的关联结构体，包括设置各种参数、定时器、流控制和认证信息等，为SCTP通信建立基础配置。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当stream_in分配失败时，代码释放了stream_out但后续仍会访问它，导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: sctp_association_init\n- 参数: [asoc, ep, sk, scope, gfp]\n- 调用者: N/A (顶级函数)\n- 被调用者: [sctp_sk, sock_net, sctp_endpoint_hold, sock_hold, refcount_set, sctp_bind_addr_init, ms_to_ktime, msecs_to_jiffies, timer_setup, sctp_generate_tag, sctp_generate_tsn, sctp_inq_init, sctp_inq_set_th_handler, sctp_outq_init, sctp_ulpq_init, sctp_stream_init, sctp_assoc_update_frag_point, sctp_auth_asoc_copy_shkeys, memcpy, ntohs, get_random_bytes, sctp_stream_free, sock_put, sctp_endpoint_put]\n\n2. 函数名: sctp_sk\n- 参数: [sk]\n- 调用者: sctp_association_init\n- 被调用者: N/A\n\n3. 函数名: sock_net\n- 参数: [sk]\n- 调用者: sctp_association_init\n- 被调用者: N/A\n\n4. 函数名: sctp_endpoint_hold\n- 参数: [ep]\n- 调用者: sctp_association_init\n- 被调用者: N/A\n\n5. 函数名: sock_hold\n- 参数: [sk]\n- 调用者: sctp_association_init\n- 被调用者: N/A\n\n6. 函数名: refcount_set\n- 参数: [&asoc->base.refcnt, 1]\n- 调用者: sctp_association_init\n- 被调用者: N/A\n\n7. 函数名: sctp_bind_addr_init\n- 参数: [&asoc->base.bind_addr, ep->base.bind_addr.port]\n- 调用者: sctp_association_init\n- 被调用者: N/A\n\n8. 函数名: ms_to_ktime\n- 参数: [sp->assocparams.sasoc_cookie_life]\n- 调用者: sctp_association_init\n- 被调用者: N/A\n\n9. 函数名: msecs_to_jiffies\n- 参数: [sp->rtoinfo.srto_initial, sp->rtoinfo.srto_max, sp->rtoinfo.srto_min, sp->hbinterval, sp->probe_interval, sp->sackdelay, sp->initmsg.sinit_max_init_timeo]\n- 调用者: sctp_association_init\n- 被调用者: N/A\n\n10. 函数名: timer_setup\n- 参数: [&asoc->timers[i], sctp_timer_events[i], 0]\n- 调用者: sctp_association_init\n- 被调用者: N/A\n\n11. 函数名: sctp_generate_tag\n- 参数: [ep]\n- 调用者: sctp_association_init\n- 被调用者: N/A\n\n12. 函数名: sctp_generate_tsn\n- 参数: [ep]\n- 调用者: sctp_association_init\n- 被调用者: N/A\n\n13. 函数名: sctp_inq_init\n- 参数: [&asoc->base.inqueue]\n- 调用者: sctp_association_init\n- 被调用者: N/A\n\n14. 函数名: sctp_inq_set_th_handler\n- 参数: [&asoc->base.inqueue, sctp_assoc_bh_rcv]\n- 调用者: sctp_association_init\n- 被调用者: N/A\n\n15. 函数名: sctp_outq_init\n- 参数: [asoc, &asoc->outqueue]\n- 调用者: sctp_association_init\n- 被调用者: N/A\n\n16. 函数名: sctp_ulpq_init\n- 参数: [&asoc->ulpq, asoc]\n- 调用者: sctp_association_init\n- 被调用者: N/A\n\n17. 函数名: sctp_stream_init\n- 参数: [&asoc->stream, asoc->c.sinit_num_ostreams, 0, gfp]\n- 调用者: sctp_association_init\n- 被调用者: N/A\n\n18. 函数名: sctp_assoc_update_frag_point\n- 参数: [asoc]\n- 调用者: sctp_association_init\n- 被调用者: N/A\n\n19. 函数名: sctp_auth_asoc_copy_shkeys\n- 参数: [ep, asoc, gfp]\n- 调用者: sctp_association_init\n- 被调用者: N/A\n\n20. 函数名: memcpy\n- 参数: [asoc->c.auth_hmacs, ep->auth_hmacs_list, ntohs(ep->auth_hmacs_list->param_hdr.length), asoc->c.auth_chunks, ep->auth_chunk_list, ntohs(ep->auth_chunk_list->param_hdr.length)]\n- 调用者: sctp_association_init\n- 被调用者: N/A\n\n21. 函数名: ntohs\n- 参数: [ep->auth_hmacs_list->param_hdr.length, ep->auth_chunk_list->param_hdr.length]\n- 调用者: sctp_association_init\n- 被调用者: N/A\n\n22. 函数名: get_random_bytes\n- 参数: [p+1, SCTP_AUTH_RANDOM_LENGTH]\n- 调用者: sctp_association_init\n- 被调用者: N/A\n\n23. 函数名: sctp_stream_free\n- 参数: [&asoc->stream]\n- 调用者: sctp_association_init\n- 被调用者: N/A\n\n24. 函数名: sock_put\n- 参数: [asoc->base.sk]\n- 调用者: sctp_association_init\n- 被调用者: N/A\n\n25. 函数名: sctp_endpoint_put\n- 参数: [asoc->ep]\n- 调用者: sctp_association_init\n- 被调用者: N/A"
    },
    {
        "id": 3933,
        "cwe": "CWE-476",
        "cve": "CVE-2023-2177",
        "purpose": "Code purpose:\"\"\"初始化SCTP协议的流结构，包括分配输出流和输入流的内存空间，并处理可能的分配失败情况\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当stream_in分配失败时，代码释放了stream_out但后续仍可能被访问，导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: sctp_stream_init\n- 参数: [struct sctp_stream *stream, __u16 outcnt, __u16 incnt, gfp_t gfp]\n- 调用者: 未显示\n- 被调用者: [sctp_sched_ops_from_stream, sched->unsched_all, sctp_stream_outq_migrate, sched->sched_all, sctp_stream_alloc_out, SCTP_SO, sctp_stream_interleave_init, sctp_stream_alloc_in, sched->free, genradix_free]\n\n2. 函数名: sctp_sched_ops_from_stream\n- 参数: [struct sctp_stream *stream]\n- 调用者: sctp_stream_init\n- 被调用者: 未显示\n\n3. 函数名: unsched_all\n- 参数: [struct sctp_stream *stream]\n- 调用者: sctp_stream_init\n- 被调用者: 未显示\n\n4. 函数名: sctp_stream_outq_migrate\n- 参数: [struct sctp_stream *stream, NULL, outcnt]\n- 调用者: sctp_stream_init\n- 被调用者: 未显示\n\n5. 函数名: sched_all\n- 参数: [struct sctp_stream *stream]\n- 调用者: sctp_stream_init\n- 被调用者: 未显示\n\n6. 函数名: sctp_stream_alloc_out\n- 参数: [struct sctp_stream *stream, outcnt, gfp]\n- 调用者: sctp_stream_init\n- 被调用者: 未显示\n\n7. 函数名: SCTP_SO\n- 参数: [stream, i]\n- 调用者: sctp_stream_init\n- 被调用者: 未显示\n\n8. 函数名: sctp_stream_interleave_init\n- 参数: [struct sctp_stream *stream]\n- 调用者: sctp_stream_init\n- 被调用者: 未显示\n\n9. 函数名: sctp_stream_alloc_in\n- 参数: [struct sctp_stream *stream, incnt, gfp]\n- 调用者: sctp_stream_init\n- 被调用者: 未显示\n\n10. 函数名: free\n- 参数: [struct sctp_stream *stream]\n- 调用者: sctp_stream_init\n- 被调用者: 未显示\n\n11. 函数名: genradix_free\n- 参数: [&stream->in], [&stream->out]\n- 调用者: sctp_stream_init\n- 被调用者: 未显示"
    },
    {
        "id": 3939,
        "cwe": "CWE-476",
        "cve": "CVE-2023-22997",
        "purpose": "Code purpose:\"\"\"该代码用于解压缩Linux内核模块中的gzip压缩数据，并将解压后的内容加载到内存中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码错误地将module_get_next_page返回的错误指针当作NULL处理，导致对错误情况的错误判断\"\"\"",
        "functions": "Functions:\n1. 函数名: module_gzip_decompress\n- 参数: [struct load_info *info, const void *buf, size_t size]\n- 调用者: 未提供\n- 被调用者: [module_gzip_header_len, kmalloc, zlib_inflateInit2, module_get_next_page, kmap_local_page, zlib_inflate, kunmap_local, zlib_inflateEnd, kfree]\n\n2. 函数名: module_gzip_header_len\n- 参数: [const void *buf, size_t size]\n- 调用者: module_gzip_decompress\n- 被调用者: 未提供\n\n3. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: module_gzip_decompress\n- 被调用者: 未提供\n\n4. 函数名: zlib_inflateInit2\n- 参数: [struct z_stream_s *strm, int windowBits]\n- 调用者: module_gzip_decompress\n- 被调用者: 未提供\n\n5. 函数名: module_get_next_page\n- 参数: [struct load_info *info]\n- 调用者: module_gzip_decompress\n- 被调用者: 未提供\n\n6. 函数名: kmap_local_page\n- 参数: [struct page *page]\n- 调用者: module_gzip_decompress\n- 被调用者: 未提供\n\n7. 函数名: zlib_inflate\n- 参数: [struct z_stream_s *strm, int flush]\n- 调用者: module_gzip_decompress\n- 被调用者: 未提供\n\n8. 函数名: kunmap_local\n- 参数: [void *vaddr]\n- 调用者: module_gzip_decompress\n- 被调用者: 未提供\n\n9. 函数名: zlib_inflateEnd\n- 参数: [struct z_stream_s *strm]\n- 调用者: module_gzip_decompress\n- 被调用者: 未提供\n\n10. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: module_gzip_decompress\n- 被调用者: 未提供"
    },
    {
        "id": 3940,
        "cwe": "CWE-476",
        "cve": "CVE-2023-22997",
        "purpose": "Code purpose:\"\"\"该代码用于解压Linux内核模块中的xz压缩数据，验证签名并处理解压过程，包括内存分配和错误处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"漏洞产生的原因是代码错误地将module_get_next_page返回的错误指针当作NULL处理，而实际上错误情况下返回的是错误指针而非NULL。\"\"\"",
        "functions": "Functions:\n1. 函数名: module_xz_decompress\n- 参数: [struct load_info *info, const void *buf, size_t size]\n- 调用者: 未显示\n- 被调用者: [memcmp, xz_dec_init, module_get_next_page, kmap_local_page, xz_dec_run, kunmap_local, xz_dec_end, pr_err]\n\n2. 函数名: memcmp\n- 参数: [const void *buf, const u8 *signature, size_t sizeof(signature)]\n- 调用者: module_xz_decompress\n- 被调用者: []\n\n3. 函数名: xz_dec_init\n- 参数: [XZ_DYNALLOC, (u32)-1]\n- 调用者: module_xz_decompress\n- 被调用者: []\n\n4. 函数名: module_get_next_page\n- 参数: [struct load_info *info]\n- 调用者: module_xz_decompress\n- 被调用者: []\n\n5. 函数名: kmap_local_page\n- 参数: [struct page *page]\n- 调用者: module_xz_decompress\n- 被调用者: []\n\n6. 函数名: xz_dec_run\n- 参数: [struct xz_dec *xz_dec, struct xz_buf *xz_buf]\n- 调用者: module_xz_decompress\n- 被调用者: []\n\n7. 函数名: kunmap_local\n- 参数: [void *xz_buf.out]\n- 调用者: module_xz_decompress\n- 被调用者: []\n\n8. 函数名: xz_dec_end\n- 参数: [struct xz_dec *xz_dec]\n- 调用者: module_xz_decompress\n- 被调用者: []\n\n9. 函数名: pr_err\n- 参数: [const char *fmt, ...]\n- 调用者: module_xz_decompress\n- 被调用者: []"
    },
    {
        "id": 3942,
        "cwe": "CWE-476",
        "cve": "CVE-2023-22999",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中DWC3 USB控制器在Qualcomm平台上的驱动初始化、资源配置和中断设置等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"错误地将错误指针与NULL进行比较，导致对dwc3_qcom_create_urs_usb_platdev函数返回值的错误处理\"\"\"",
        "functions": "Functions:\n1. 函数名: dwc3_qcom_probe\n- 参数: [struct platform_device *pdev]\n- 调用者: 无（驱动入口函数）\n- 被调用者: [devm_kzalloc, platform_set_drvdata, has_acpi_companion, acpi_device_get_match_data, dev_err, devm_reset_control_array_get_optional_exclusive, IS_ERR, PTR_ERR, reset_control_assert, usleep_range, reset_control_deassert, of_clk_get_parent_count, dwc3_qcom_clk_init, platform_get_resource, kmemdup, dwc3_qcom_create_urs_usb_platdev, devm_ioremap_resource, dwc3_qcom_setup_irq, device_property_read_bool, dwc3_qcom_select_utmi_clk, dwc3_qcom_of_register_core, dwc3_qcom_acpi_register_core, dwc3_qcom_interconnect_init, usb_get_dr_mode, dwc3_qcom_vbus_override_enable, dwc3_qcom_register_extcon, device_init_wakeup, pm_runtime_set_active, pm_runtime_enable, pm_runtime_forbid, dwc3_qcom_interconnect_exit, of_platform_depopulate, platform_device_put, clk_disable_unprepare, clk_put, reset_control_assert]\n\n2. 函数名: dwc3_qcom_clk_init\n- 参数: [struct dwc3_qcom *qcom, int count]\n- 调用者: dwc3_qcom_probe\n- 被调用者: 无（具体实现未显示）\n\n3. 函数名: dwc3_qcom_create_urs_usb_platdev\n- 参数: [struct device *dev]\n- 调用者: dwc3_qcom_probe\n- 被调用者: 无（具体实现未显示）\n\n4. 函数名: dwc3_qcom_setup_irq\n- 参数: [struct platform_device *pdev]\n- 调用者: dwc3_qcom_probe\n- 被调用者: 无（具体实现未显示）\n\n5. 函数名: dwc3_qcom_select_utmi_clk\n- 参数: [struct dwc3_qcom *qcom]\n- 调用者: dwc3_qcom_probe\n- 被调用者: 无（具体实现未显示）\n\n6. 函数名: dwc3_qcom_of_register_core\n- 参数: [struct platform_device *pdev]\n- 调用者: dwc3_qcom_probe\n- 被调用者: 无（具体实现未显示）\n\n7. 函数名: dwc3_qcom_acpi_register_core\n- 参数: [struct platform_device *pdev]\n- 调用者: dwc3_qcom_probe\n- 被调用者: 无（具体实现未显示）\n\n8. 函数名: dwc3_qcom_interconnect_init\n- 参数: [struct dwc3_qcom *qcom]\n- 调用者: dwc3_qcom_probe\n- 被调用者: 无（具体实现未显示）\n\n9. 函数名: dwc3_qcom_vbus_override_enable\n- 参数: [struct dwc3_qcom *qcom, bool enable]\n- 调用者: dwc3_qcom_probe\n- 被调用者: 无（具体实现未显示）\n\n10. 函数名: dwc3_qcom_register_extcon\n- 参数: [struct dwc3_qcom *qcom]\n- 调用者: dwc3_qcom_probe\n- 被调用者: 无（具体实现未显示）\n\n11. 函数名: dwc3_qcom_interconnect_exit\n- 参数: [struct dwc3_qcom *qcom]\n- 调用者: dwc3_qcom_probe\n- 被调用者: 无（具体实现未显示）"
    },
    {
        "id": 3943,
        "cwe": "CWE-476",
        "cve": "CVE-2023-23000",
        "purpose": "Code purpose:\"\"\"在Tegra XUSB控制器驱动中，通过设备树查找指定类型和索引的端口节点\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"函数在内存分配失败时返回错误指针ERR_PTR(-ENOMEM)，而调用者期望返回NULL，导致空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: tegra_xusb_find_port_node\n- 参数: [struct tegra_xusb_padctl *padctl, const char *type, unsigned int index]\n- 调用者: 未指定\n- 被调用者: [of_get_child_by_name, kasprintf, of_node_put, kfree]\n\n2. 函数名: of_get_child_by_name\n- 参数: [struct device_node *node, const char *name]\n- 调用者: tegra_xusb_find_port_node\n- 被调用者: 未指定\n\n3. 函数名: kasprintf\n- 参数: [gfp_t gfp, const char *fmt, ...]\n- 调用者: tegra_xusb_find_port_node\n- 被调用者: 未指定\n\n4. 函数名: of_node_put\n- 参数: [struct device_node *node]\n- 调用者: tegra_xusb_find_port_node\n- 被调用者: 未指定\n\n5. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: tegra_xusb_find_port_node\n- 被调用者: 未指定"
    },
    {
        "id": 3944,
        "cwe": "CWE-476",
        "cve": "CVE-2023-23001",
        "purpose": "Code purpose:\"\"\"该代码片段用于初始化并获取va09电源控制器的调节器，若获取失败则记录信息，成功则设置相关能力标志位。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"错误地将regulator_get返回的错误指针与NULL进行比较，而未使用IS_ERR函数检查错误指针\"\"\"",
        "functions": "Functions:\n1. 函数名: ufs_mtk_init_va09_pwr_ctrl\n- 参数: [struct ufs_hba *hba]\n- 调用者: 未显示（上下文未提供）\n- 被调用者: [ufshcd_get_variant, regulator_get, dev_info]\n\n2. 函数名: ufshcd_get_variant\n- 参数: [struct ufs_hba *hba]\n- 调用者: ufs_mtk_init_va09_pwr_ctrl\n- 被调用者: 未显示（上下文未提供）\n\n3. 函数名: regulator_get\n- 参数: [struct device *dev, const char *id]\n- 调用者: ufs_mtk_init_va09_pwr_ctrl\n- 被调用者: 未显示（上下文未提供）\n\n4. 函数名: dev_info\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: ufs_mtk_init_va09_pwr_ctrl\n- 被调用者: 未显示（上下文未提供）"
    },
    {
        "id": 3945,
        "cwe": "CWE-476",
        "cve": "CVE-2023-23002",
        "purpose": "Code purpose:\"\"\"该代码用于实现高通蓝牙芯片(QCA)的串行设备驱动探测功能，包括初始化设备、配置电源管理、时钟和GPIO控制，并注册HCI UART设备。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码错误地将devm_gpiod_get_optional函数返回的错误指针与NULL进行比较，而实际上错误情况下应检查IS_ERR()而非NULL\"\"\"",
        "functions": "Functions:\n1. 函数名: qca_serdev_probe\n- 参数: [struct serdev_device *serdev]\n- 调用者: 内核驱动框架\n- 被调用者: [devm_kzalloc, device_get_match_data, serdev_device_set_drvdata, device_property_read_string, device_property_read_u32, qca_is_wcn399x, qca_is_wcn6750, devm_gpiod_get_optional, qca_init_regulators, hci_uart_register_device, clk_set_rate, clk_prepare_enable, clk_disable_unprepare, set_bit]\n\n2. 函数名: qca_is_wcn399x\n- 参数: [未知]\n- 调用者: qca_serdev_probe\n- 被调用者: []\n\n3. 函数名: qca_is_wcn6750\n- 参数: [未知]\n- 调用者: qca_serdev_probe\n- 被调用者: []\n\n4. 函数名: qca_init_regulators\n- 参数: [struct qca_power *, 未知, 未知]\n- 调用者: qca_serdev_probe\n- 被调用者: []\n\n5. 函数名: hci_uart_register_device\n- 参数: [struct hci_uart *, 未知]\n- 调用者: qca_serdev_probe\n- 被调用者: []\n\n6. 函数名: clk_set_rate\n- 参数: [未知, SUSCLK_RATE_32KHZ]\n- 调用者: qca_serdev_probe\n- 被调用者: []\n\n7. 函数名: clk_prepare_enable\n- 参数: [未知]\n- 调用者: qca_serdev_probe\n- 被调用者: []\n\n8. 函数名: clk_disable_unprepare\n- 参数: [未知]\n- 调用者: qca_serdev_probe\n- 被调用者: []\n\n9. 函数名: set_bit\n- 参数: [HCI_QUIRK_NON_PERSISTENT_SETUP, &hdev->quirks], [HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED, &hdev->quirks], [HCI_QUIRK_VALID_LE_STATES, &hdev->quirks]\n- 调用者: qca_serdev_probe\n- 被调用者: []\n\n10. 函数名: qca_power_off\n- 参数: [未知]\n- 调用者: 通过函数指针调用\n- 被调用者: []"
    },
    {
        "id": 3947,
        "cwe": "CWE-476",
        "cve": "CVE-2023-23004",
        "purpose": "Code purpose:\"\"\"检查Mali显示处理器平面状态中各个平面的内存页大小是否满足给定阈值\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码错误地将错误指针当作NULL来处理，导致对get_sg_table返回值的错误检查\"\"\"",
        "functions": "Functions:\n1. 函数名: malidp_check_pages_threshold\n- 参数: [struct malidp_plane_state *ms, u32 pgsize]\n- 调用者: 未显示\n- 被调用者: [drm_gem_fb_get_obj, to_drm_gem_cma_obj, kfree, sg_next]\n\n2. 函数名: drm_gem_fb_get_obj\n- 参数: [struct drm_framebuffer *fb, int i]\n- 调用者: malidp_check_pages_threshold\n- 被调用者: 未显示\n\n3. 函数名: to_drm_gem_cma_obj\n- 参数: [struct drm_gem_object *obj]\n- 调用者: malidp_check_pages_threshold\n- 被调用者: 未显示\n\n4. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: malidp_check_pages_threshold\n- 被调用者: 未显示\n\n5. 函数名: sg_next\n- 参数: [struct scatterlist *sg]\n- 调用者: malidp_check_pages_threshold\n- 被调用者: 未显示\n\n6. 函数名: get_sg_table\n- 参数: [struct drm_gem_object *obj]\n- 调用者: malidp_check_pages_threshold\n- 被调用者: 未显示"
    },
    {
        "id": 3948,
        "cwe": "CWE-476",
        "cve": "CVE-2023-23005",
        "purpose": "Code purpose:\"\"\"初始化内存层级子系统，分配默认DRAM层级，并为现有内存节点设置适当的内存层级\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码错误地将alloc_memory_type()返回的错误指针与NULL进行比较，而实际上应该检查IS_ERR()来判断是否出错\"\"\"",
        "functions": "Functions:\n1. 函数名: memory_tier_init\n- 参数: [void]\n- 调用者: 内核初始化过程\n- 被调用者: [subsys_virtual_register, kcalloc, alloc_memory_type, set_node_memory_tier, establish_demotion_targets, hotplug_memory_notifier]\n\n2. 函数名: subsys_virtual_register\n- 参数: [&memory_tier_subsys, NULL]\n- 调用者: memory_tier_init\n- 被调用者: []\n\n3. 函数名: kcalloc\n- 参数: [nr_node_ids, sizeof(struct demotion_nodes), GFP_KERNEL]\n- 调用者: memory_tier_init\n- 被调用者: []\n\n4. 函数名: alloc_memory_type\n- 参数: [MEMTIER_ADISTANCE_DRAM]\n- 调用者: memory_tier_init\n- 被调用者: []\n\n5. 函数名: set_node_memory_tier\n- 参数: [node]\n- 调用者: memory_tier_init\n- 被调用者: []\n\n6. 函数名: establish_demotion_targets\n- 参数: []\n- 调用者: memory_tier_init\n- 被调用者: []\n\n7. 函数名: hotplug_memory_notifier\n- 参数: [memtier_hotplug_callback, MEMTIER_HOTPLUG_PRI]\n- 调用者: memory_tier_init\n- 被调用者: []\n\n8. 函数名: mutex_lock\n- 参数: [&memory_tier_lock]\n- 调用者: memory_tier_init\n- 被调用者: []\n\n9. 函数名: mutex_unlock\n- 参数: [&memory_tier_lock]\n- 调用者: memory_tier_init\n- 被调用者: []\n\n10. 函数名: for_each_node_state\n- 参数: [node, N_MEMORY]\n- 调用者: memory_tier_init\n- 被调用者: []"
    },
    {
        "id": 3949,
        "cwe": "CWE-476",
        "cve": "CVE-2023-23006",
        "purpose": "Code purpose:\"\"\"初始化并分配MLX5驱动域所需的资源，包括STE上下文、保护域(PD)、UAR页、ICM内存池和发送环等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码错误地将mlx5_get_uars_page返回的错误指针与NULL进行比较，而实际上错误情况下应检查IS_ERR()而非NULL\"\"\"",
        "functions": "Functions:\n1. 函数名: dr_domain_init_resources\n- 参数: [struct mlx5dr_domain *dmn]\n- 调用者: N/A (top-level function)\n- 被调用者: [mlx5dr_ste_get_ctx, mlx5_core_alloc_pd, mlx5_get_uars_page, mlx5dr_icm_pool_create, mlx5dr_send_ring_alloc, mlx5dr_icm_pool_destroy, mlx5_put_uars_page, mlx5_core_dealloc_pd]\n\n2. 函数名: mlx5dr_ste_get_ctx\n- 参数: [dmn->info.caps.sw_format_ver]\n- 调用者: dr_domain_init_resources\n- 被调用者: []\n\n3. 函数名: mlx5_core_alloc_pd\n- 参数: [dmn->mdev, &dmn->pdn]\n- 调用者: dr_domain_init_resources\n- 被调用者: []\n\n4. 函数名: mlx5_get_uars_page\n- 参数: [dmn->mdev]\n- 调用者: dr_domain_init_resources\n- 被调用者: []\n\n5. 函数名: mlx5dr_icm_pool_create\n- 参数: [dmn, DR_ICM_TYPE_STE]\n- 调用者: dr_domain_init_resources\n- 被调用者: []\n\n6. 函数名: mlx5dr_send_ring_alloc\n- 参数: [dmn]\n- 调用者: dr_domain_init_resources\n- 被调用者: []\n\n7. 函数名: mlx5dr_icm_pool_destroy\n- 参数: [dmn->action_icm_pool]\n- 调用者: dr_domain_init_resources\n- 被调用者: []\n\n8. 函数名: mlx5_put_uars_page\n- 参数: [dmn->mdev, dmn->uar]\n- 调用者: dr_domain_init_resources\n- 被调用者: []\n\n9. 函数名: mlx5_core_dealloc_pd\n- 参数: [dmn->mdev, dmn->pdn]\n- 调用者: dr_domain_init_resources\n- 被调用者: []"
    },
    {
        "id": 3974,
        "cwe": "CWE-476",
        "cve": "CVE-2023-28327",
        "purpose": "Code purpose:\"\"\"该代码用于通过UNIX域套接字诊断接口转储套接字状态信息，供诊断工具使用\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"新分配的skb没有设置sk成员，导致在访问skb->sk时出现空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: unix_diag_dump\n- 参数: [struct sk_buff *skb, struct netlink_callback *cb]\n- 调用者: 未显示\n- 被调用者: [sock_net, nlmsg_data, spin_lock, sk_for_each, sk_diag_dump, spin_unlock]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: unix_diag_dump\n- 被调用者: 未显示\n\n3. 函数名: nlmsg_data\n- 参数: [struct nlmsghdr *nlh]\n- 调用者: unix_diag_dump\n- 被调用者: 未显示\n\n4. 函数名: spin_lock\n- 参数: [spinlock_t *lock]\n- 调用者: unix_diag_dump\n- 被调用者: 未显示\n\n5. 函数名: sk_for_each\n- 参数: [struct sock *sk, struct hlist_head *head]\n- 调用者: unix_diag_dump\n- 被调用者: 未显示\n\n6. 函数名: sk_diag_dump\n- 参数: [struct sock *sk, struct sk_buff *skb, struct unix_diag_req *req, u32 portid, u32 seq, int flag]\n- 调用者: unix_diag_dump\n- 被调用者: 未显示\n\n7. 函数名: spin_unlock\n- 参数: [spinlock_t *lock]\n- 调用者: unix_diag_dump\n- 被调用者: 未显示"
    },
    {
        "id": 3975,
        "cwe": "CWE-476",
        "cve": "CVE-2023-28327",
        "purpose": "Code purpose:\"\"\"该代码用于通过UNIX域套接字的inode号精确查找并返回对应的诊断信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在unix_diag_get_exact函数中，新分配的skb没有设置sk成员，导致后续操作可能引发空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: unix_diag_get_exact\n- 参数: [struct sk_buff *in_skb, const struct nlmsghdr *nlh, struct unix_diag_req *req]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [sock_net, unix_lookup_by_ino, sock_diag_check_cookie, nlmsg_new, sk_diag_fill, nlmsg_free, nlmsg_unicast, sock_put]\n\n2. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: unix_diag_get_exact\n- 被调用者: []\n\n3. 函数名: unix_lookup_by_ino\n- 参数: [struct net *net, unsigned int ino]\n- 调用者: unix_diag_get_exact\n- 被调用者: []\n\n4. 函数名: sock_diag_check_cookie\n- 参数: [struct sock *sk, __u32 cookie]\n- 调用者: unix_diag_get_exact\n- 被调用者: []\n\n5. 函数名: nlmsg_new\n- 参数: [size_t payload, gfp_t flags]\n- 调用者: unix_diag_get_exact\n- 被调用者: []\n\n6. 函数名: sk_diag_fill\n- 参数: [struct sock *sk, struct sk_buff *skb, struct unix_diag_req *req, __u32 portid, __u32 seq, u32 flags, int sk_ino]\n- 调用者: unix_diag_get_exact\n- 被调用者: []\n\n7. 函数名: nlmsg_free\n- 参数: [struct sk_buff *skb]\n- 调用者: unix_diag_get_exact\n- 被调用者: []\n\n8. 函数名: nlmsg_unicast\n- 参数: [struct sock *ssk, struct sk_buff *skb, u32 portid]\n- 调用者: unix_diag_get_exact\n- 被调用者: []\n\n9. 函数名: sock_put\n- 参数: [struct sock *sk]\n- 调用者: unix_diag_get_exact\n- 被调用者: []"
    },
    {
        "id": 3976,
        "cwe": "CWE-476",
        "cve": "CVE-2023-28328",
        "purpose": "Code purpose:\"\"\"该代码实现了az6027驱动中I2C总线数据传输功能，处理来自用户空间的消息并与设备进行通信。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未对用户空间传入的msg[i].buf指针进行有效性检查，可能导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: az6027_i2c_xfer\n- 参数: [struct i2c_adapter *adap, struct i2c_msg msg[], int num]\n- 调用者: 未显示（应为I2C子系统调用）\n- 被调用者: [i2c_get_adapdata, kmalloc, mutex_lock_interruptible, kfree, warn, az6027_usb_out_op, az6027_usb_in_op, mutex_unlock]\n\n2. 函数名: i2c_get_adapdata\n- 参数: [struct i2c_adapter *adap]\n- 调用者: az6027_i2c_xfer\n- 被调用者: 未显示（内核I2C核心函数）\n\n3. 函数名: kmalloc\n- 参数: [256, GFP_KERNEL]\n- 调用者: az6027_i2c_xfer\n- 被调用者: 未显示（内核内存分配函数）\n\n4. 函数名: mutex_lock_interruptible\n- 参数: [&d->i2c_mutex]\n- 调用者: az6027_i2c_xfer\n- 被调用者: 未显示（内核互斥锁函数）\n\n5. 函数名: kfree\n- 参数: [data]\n- 调用者: az6027_i2c_xfer\n- 被调用者: 未显示（内核内存释放函数）\n\n6. 函数名: warn\n- 参数: [\"more than 2 i2c messages at a time is not handled yet. TODO.\"]\n- 调用者: az6027_i2c_xfer\n- 被调用者: 未显示（内核警告函数）\n\n7. 函数名: az6027_usb_out_op\n- 参数: [d, req, value, index, data, length]\n- 调用者: az6027_i2c_xfer\n- 被调用者: 未显示（设备特定USB操作函数）\n\n8. 函数名: az6027_usb_in_op\n- 参数: [d, req, value, index, data, length]\n- 调用者: az6027_i2c_xfer\n- 被调用者: 未显示（设备特定USB操作函数）\n\n9. 函数名: mutex_unlock\n- 参数: [&d->i2c_mutex]\n- 调用者: az6027_i2c_xfer\n- 被调用者: 未显示（内核互斥锁函数）"
    },
    {
        "id": 3980,
        "cwe": "CWE-476",
        "cve": "CVE-2023-28466",
        "purpose": "Code purpose:\"\"\"该代码实现了一个TLS套接字选项获取功能，用于检查并返回TLS连接中是否启用了无填充选项(rx_no_pad)的值。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码中缺少对sock结构的锁定保护，导致在多线程环境下可能发生竞态条件，引发使用后释放或空指针解引用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: do_tls_getsockopt_no_pad\n- 参数: [sk, optval, optlen]\n- 调用者: 未明确显示（应为内核中调用getsockopt的相关代码）\n- 被调用者: [tls_get_ctx, get_user, lock_sock, release_sock, put_user, copy_to_user]\n\n2. 函数名: tls_get_ctx\n- 参数: [sk]\n- 调用者: do_tls_getsockopt_no_pad\n- 被调用者: 未显示\n\n3. 函数名: get_user\n- 参数: [len, optlen]\n- 调用者: do_tls_getsockopt_no_pad\n- 被调用者: 未显示\n\n4. 函数名: lock_sock\n- 参数: [sk]\n- 调用者: do_tls_getsockopt_no_pad\n- 被调用者: 未显示\n\n5. 函数名: release_sock\n- 参数: [sk]\n- 调用者: do_tls_getsockopt_no_pad\n- 被调用者: 未显示\n\n6. 函数名: put_user\n- 参数: [sizeof(value), optlen]\n- 调用者: do_tls_getsockopt_no_pad\n- 被调用者: 未显示\n\n7. 函数名: copy_to_user\n- 参数: [optval, &value, sizeof(value)]\n- 调用者: do_tls_getsockopt_no_pad\n- 被调用者: 未显示"
    },
    {
        "id": 3981,
        "cwe": "CWE-476",
        "cve": "CVE-2023-28466",
        "purpose": "Code purpose:\"\"\"该代码实现了TLS套接字选项的获取功能，根据不同的选项名称调用相应的处理函数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"缺少lock_sock调用导致竞态条件，可能引发释放后使用或空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: do_tls_getsockopt\n- 参数: [sk, optname, optval, optlen]\n- 调用者: 未显示（应为内核中调用getsockopt的相关代码）\n- 被调用者: [do_tls_getsockopt_conf, do_tls_getsockopt_tx_zc, do_tls_getsockopt_no_pad]\n\n2. 函数名: do_tls_getsockopt_conf\n- 参数: [sk, optval, optlen, (optname == TLS_TX)]\n- 调用者: do_tls_getsockopt\n- 被调用者: []\n\n3. 函数名: do_tls_getsockopt_tx_zc\n- 参数: [sk, optval, optlen]\n- 调用者: do_tls_getsockopt\n- 被调用者: []\n\n4. 函数名: do_tls_getsockopt_no_pad\n- 参数: [sk, optval, optlen]\n- 调用者: do_tls_getsockopt\n- 被调用者: []"
    },
    {
        "id": 3982,
        "cwe": "CWE-476",
        "cve": "CVE-2023-28466",
        "purpose": "Code purpose:\"\"\"该代码实现了TLS套接字选项的获取功能，处理不同类型的加密信息并复制到用户空间\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码在处理TLS套接字选项时，在检查crypto_info是否就绪后未立即加锁，导致在后续操作中可能出现竞态条件，引发空指针解引用或释放后使用问题\"\"\"",
        "functions": "Functions:\n1. 函数名: do_tls_getsockopt_conf\n- 参数: [sk, optval, optlen, tx]\n- 调用者: 未显示（应为内核中调用getsockopt的相关代码）\n- 被调用者: [tls_get_ctx, get_user, copy_to_user, lock_sock, memcpy, release_sock, container_of]\n\n2. 函数名: tls_get_ctx\n- 参数: [sk]\n- 调用者: do_tls_getsockopt_conf\n- 被调用者: 未显示\n\n3. 函数名: get_user\n- 参数: [len, optlen]\n- 调用者: do_tls_getsockopt_conf\n- 被调用者: 未显示\n\n4. 函数名: copy_to_user\n- 参数: [optval, crypto_info, sizeof(*crypto_info)] 或 [optval, crypto_info_aes_gcm_128, sizeof(*crypto_info_aes_gcm_128)] 等类似参数组合\n- 调用者: do_tls_getsockopt_conf\n- 被调用者: 未显示\n\n5. 函数名: lock_sock\n- 参数: [sk]\n- 调用者: do_tls_getsockopt_conf\n- 被调用者: 未显示\n\n6. 函数名: memcpy\n- 参数: [crypto_info_aes_gcm_128->iv, cctx->iv + TLS_CIPHER_AES_GCM_128_SALT_SIZE, TLS_CIPHER_AES_GCM_128_IV_SIZE] 等类似参数组合\n- 调用者: do_tls_getsockopt_conf\n- 被调用者: 未显示\n\n7. 函数名: release_sock\n- 参数: [sk]\n- 调用者: do_tls_getsockopt_conf\n- 被调用者: 未显示\n\n8. 函数名: container_of\n- 参数: [crypto_info, struct tls12_crypto_info_aes_gcm_128, info] 等类似参数组合\n- 调用者: do_tls_getsockopt_conf\n- 被调用者: 未显示"
    },
    {
        "id": 3983,
        "cwe": "CWE-476",
        "cve": "CVE-2023-2898",
        "purpose": "Code purpose:\"\"\"该代码片段实现了F2FS文件系统的调整大小功能，通过用户空间传入的块数量参数来调整文件系统大小，需要管理员权限且文件系统不能为只读状态。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在f2fs_ioc_resize_fs函数中未对用户传入的block_count参数进行有效性验证，可能导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: f2fs_ioc_resize_fs\n- 参数: [struct file *filp, unsigned long arg]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [file_inode, capable, f2fs_readonly, copy_from_user, f2fs_resize_fs]\n\n2. 函数名: file_inode\n- 参数: [struct file *filp]\n- 调用者: f2fs_ioc_resize_fs\n- 被调用者: []\n\n3. 函数名: capable\n- 参数: [CAP_SYS_ADMIN]\n- 调用者: f2fs_ioc_resize_fs\n- 被调用者: []\n\n4. 函数名: f2fs_readonly\n- 参数: [struct super_block *sbi->sb]\n- 调用者: f2fs_ioc_resize_fs\n- 被调用者: []\n\n5. 函数名: copy_from_user\n- 参数: [&block_count, (void __user *)arg, sizeof(block_count)]\n- 调用者: f2fs_ioc_resize_fs\n- 被调用者: []\n\n6. 函数名: f2fs_resize_fs\n- 参数: [struct f2fs_sb_info *sbi, __u64 block_count]\n- 调用者: f2fs_ioc_resize_fs\n- 被调用者: []"
    },
    {
        "id": 3991,
        "cwe": "CWE-476",
        "cve": "CVE-2023-3106",
        "purpose": "Code purpose:\"\"\"该代码用于在完成XFRM状态转储操作后清理相关资源并返回0\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当Netlink socket接收设置了DUMP标志的XFRM_MSG_GETSA或XFRM_MSG_GETPOLICY类型消息时，由于未正确处理空指针解引用导致漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: xfrm_dump_sa_done\n- 参数: [struct netlink_callback *cb]\n- 调用者: 未明确（由Netlink消息处理机制调用）\n- 被调用者: [xfrm_state_walk_done, sock_net]\n\n2. 函数名: xfrm_state_walk_done\n- 参数: [struct xfrm_state_walk *walk, struct net *net]\n- 调用者: xfrm_dump_sa_done\n- 被调用者: []\n\n3. 函数名: sock_net\n- 参数: [struct sock *sk]\n- 调用者: xfrm_dump_sa_done\n- 被调用者: []"
    },
    {
        "id": 3992,
        "cwe": "CWE-476",
        "cve": "CVE-2023-3106",
        "purpose": "Code purpose:\"\"\"该代码用于通过Netlink套接字处理和转储XFRM状态信息，包括安全关联(SA)和策略的查询功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理XFRM_MSG_GETSA或XFRM_MSG_GETPOLICY类型的Netlink消息时，未对cb->nlh指针进行空指针检查，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: xfrm_dump_sa\n- 参数: [skb, cb]\n- 调用者: 未显示（由Netlink消息处理调用）\n- 被调用者: [sock_net, nlmsg_parse, kmemdup, nla_get_u8, xfrm_state_walk_init, xfrm_state_walk]\n\n2. 函数名: sock_net\n- 参数: [sk]\n- 调用者: xfrm_dump_sa\n- 被调用者: []\n\n3. 函数名: nlmsg_parse\n- 参数: [cb->nlh, 0, attrs, XFRMA_MAX, xfrma_policy]\n- 调用者: xfrm_dump_sa\n- 被调用者: []\n\n4. 函数名: kmemdup\n- 参数: [nla_data(attrs[XFRMA_ADDRESS_FILTER]), sizeof(*filter), GFP_KERNEL]\n- 调用者: xfrm_dump_sa\n- 被调用者: []\n\n5. 函数名: nla_get_u8\n- 参数: [attrs[XFRMA_PROTO]]\n- 调用者: xfrm_dump_sa\n- 被调用者: []\n\n6. 函数名: xfrm_state_walk_init\n- 参数: [walk, proto, filter]\n- 调用者: xfrm_dump_sa\n- 被调用者: []\n\n7. 函数名: xfrm_state_walk\n- 参数: [net, walk, dump_one_state, &info]\n- 调用者: xfrm_dump_sa\n- 被调用者: []\n\n8. 函数名: nla_data\n- 参数: [attrs[XFRMA_ADDRESS_FILTER]]\n- 调用者: kmemdup (间接通过xfrm_dump_sa调用)\n- 被调用者: []"
    },
    {
        "id": 3995,
        "cwe": "CWE-476",
        "cve": "CVE-2023-31083",
        "purpose": "Code purpose:\"\"\"该代码实现了HCI UART TTY设备的IO控制功能，包括设置/获取协议、设备ID和标志位等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在设置协议标志位HCI_UART_PROTO_SET和实际设置hu->proto之间存在竞态条件，导致HCIUARTGETPROTO可能在hu->proto未设置时被调用，引发空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: hci_uart_tty_ioctl\n- 参数: [tty, cmd, arg]\n- 调用者: 未指定（由TTY子系统调用）\n- 被调用者: [test_and_set_bit, hci_uart_set_proto, clear_bit, test_bit, hci_uart_set_flags, n_tty_ioctl_helper]\n\n2. 函数名: test_and_set_bit\n- 参数: [HCI_UART_PROTO_SET, &hu->flags]\n- 调用者: hci_uart_tty_ioctl\n- 被调用者: []\n\n3. 函数名: hci_uart_set_proto\n- 参数: [hu, arg]\n- 调用者: hci_uart_tty_ioctl\n- 被调用者: []\n\n4. 函数名: clear_bit\n- 参数: [HCI_UART_PROTO_SET, &hu->flags]\n- 调用者: hci_uart_tty_ioctl\n- 被调用者: []\n\n5. 函数名: test_bit\n- 参数: [HCI_UART_PROTO_SET, &hu->flags] 或 [HCI_UART_REGISTERED, &hu->flags]\n- 调用者: hci_uart_tty_ioctl\n- 被调用者: []\n\n6. 函数名: hci_uart_set_flags\n- 参数: [hu, arg]\n- 调用者: hci_uart_tty_ioctl\n- 被调用者: []\n\n7. 函数名: n_tty_ioctl_helper\n- 参数: [tty, cmd, arg]\n- 调用者: hci_uart_tty_ioctl\n- 被调用者: []"
    },
    {
        "id": 4004,
        "cwe": "CWE-476",
        "cve": "CVE-2023-3212",
        "purpose": "Code purpose:\"\"\"该代码实现了GFS2文件系统中inode的回收清理功能，包括处理链接状态、释放资源、解除glock绑定等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当gfs2文件系统损坏时，evict代码尝试引用已被释放并设置为NULL的日志描述符结构，导致空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: gfs2_evict_inode\n- 参数: [struct inode *inode]\n- 调用者: (未显示)\n- 被调用者: [sb_rdonly, GFS2_I, gfs2_holder_mark_uninitialized, evict_should_delete, evict_unlinked_inode, evict_linked_inode, gfs2_rs_active, gfs2_rs_deltree, gfs2_holder_initialized, gfs2_glock_dq_uninit, fs_warn, truncate_inode_pages_final, gfs2_assert_warn, gfs2_ordered_del_inode, clear_inode, gfs2_dir_hash_inval, glock_clear_object, gfs2_glock_hold, gfs2_glock_dq_uninit, gfs2_glock_put_eventually, wait_on_bit_io, gfs2_glock_add_to_lru]\n\n2. 函数名: sb_rdonly\n- 参数: [struct super_block *sb]\n- 调用者: gfs2_evict_inode\n- 被调用者: (未显示)\n\n3. 函数名: GFS2_I\n- 参数: [struct inode *inode]\n- 调用者: gfs2_evict_inode\n- 被调用者: (未显示)\n\n4. 函数名: gfs2_holder_mark_uninitialized\n- 参数: [struct gfs2_holder *gh]\n- 调用者: gfs2_evict_inode\n- 被调用者: (未显示)\n\n5. 函数名: evict_should_delete\n- 参数: [struct inode *inode, struct gfs2_holder *gh]\n- 调用者: gfs2_evict_inode\n- 被调用者: (未显示)\n\n6. 函数名: evict_unlinked_inode\n- 参数: [struct inode *inode]\n- 调用者: gfs2_evict_inode\n- 被调用者: (未显示)\n\n7. 函数名: evict_linked_inode\n- 参数: [struct inode *inode]\n- 调用者: gfs2_evict_inode\n- 被调用者: (未显示)\n\n8. 函数名: gfs2_rs_active\n- 参数: [struct gfs2_blkreserv *res]\n- 调用者: gfs2_evict_inode\n- 被调用者: (未显示)\n\n9. 函数名: gfs2_rs_deltree\n- 参数: [struct gfs2_blkreserv *res]\n- 调用者: gfs2_evict_inode\n- 被调用者: (未显示)\n\n10. 函数名: gfs2_holder_initialized\n- 参数: [struct gfs2_holder *gh]\n- 调用者: gfs2_evict_inode\n- 被调用者: (未显示)\n\n11. 函数名: gfs2_glock_dq_uninit\n- 参数: [struct gfs2_holder *gh]\n- 调用者: gfs2_evict_inode\n- 被调用者: (未显示)\n\n12. 函数名: fs_warn\n- 参数: [struct gfs2_sbd *sdp, const char *fmt, ...]\n- 调用者: gfs2_evict_inode\n- 被调用者: (未显示)\n\n13. 函数名: truncate_inode_pages_final\n- 参数: [struct address_space *mapping]\n- 调用者: gfs2_evict_inode\n- 被调用者: (未显示)\n\n14. 函数名: gfs2_assert_warn\n- 参数: [struct gfs2_sbd *sdp, char *assertion]\n- 调用者: gfs2_evict_inode\n- 被调用者: (未显示)\n\n15. 函数名: gfs2_ordered_del_inode\n- 参数: [struct gfs2_inode *ip]\n- 调用者: gfs2_evict_inode\n- 被调用者: (未显示)\n\n16. 函数名: clear_inode\n- 参数: [struct inode *inode]\n- 调用者: gfs2_evict_inode\n- 被调用者: (未显示)\n\n17. 函数名: gfs2_dir_hash_inval\n- 参数: [struct gfs2_inode *ip]\n- 调用者: gfs2_evict_inode\n- 被调用者: (未显示)\n\n18. 函数名: glock_clear_object\n- 参数: [struct gfs2_glock *gl, void *object]\n- 调用者: gfs2_evict_inode\n- 被调用者: (未显示)\n\n19. 函数名: gfs2_glock_hold\n- 参数: [struct gfs2_glock *gl]\n- 调用者: gfs2_evict_inode\n- 被调用者: (未显示)\n\n20. 函数名: gfs2_glock_put_eventually\n- 参数: [struct gfs2_glock *gl]\n- 调用者: gfs2_evict_inode\n- 被调用者: (未显示)\n\n21. 函数名: wait_on_bit_io\n- 参数: [unsigned long *word, int bit, unsigned mode]\n- 调用者: gfs2_evict_inode\n- 被调用者: (未显示)\n\n22. 函数名: gfs2_glock_add_to_lru\n- 参数: [struct gfs2_glock *gl]\n- 调用者: gfs2_evict_inode\n- 被调用者: (未显示)"
    },
    {
        "id": 4005,
        "cwe": "CWE-476",
        "cve": "CVE-2023-3220",
        "purpose": "Code purpose:\"\"\"该代码用于检查DRM CRTC的原子状态，包括验证平面状态、混合器配置和性能检查，以确保显示控制器的正确配置。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码中调用kzalloc()分配内存后未检查返回值是否为NULL就直接使用，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: dpu_crtc_atomic_check\n- 参数: [crtc, state]\n- 调用者: 未显示（通常由DRM框架调用）\n- 被调用者: [drm_atomic_get_new_crtc_state, to_dpu_crtc, to_dpu_crtc_state, kzalloc, memset, dpu_crtc_needs_dirtyfb, _dpu_crtc_setup_lm_bounds, drm_atomic_crtc_state_for_each_plane_state, dpu_plane_pipe, drm_plane_state_dest, drm_rect_intersect, dpu_plane_clear_multirect, dpu_plane_validate_multirect_v2, atomic_inc, _dpu_crtc_get_kms, dpu_core_perf_crtc_check, kfree]\n\n2. 函数名: to_dpu_crtc\n- 参数: [crtc]\n- 调用者: dpu_crtc_atomic_check\n- 被调用者: []\n\n3. 函数名: to_dpu_crtc_state\n- 参数: [crtc_state]\n- 调用者: dpu_crtc_atomic_check\n- 被调用者: []\n\n4. 函数名: dpu_crtc_needs_dirtyfb\n- 参数: [crtc_state]\n- 调用者: dpu_crtc_atomic_check\n- 被调用者: []\n\n5. 函数名: _dpu_crtc_setup_lm_bounds\n- 参数: [crtc, crtc_state]\n- 调用者: dpu_crtc_atomic_check\n- 被调用者: []\n\n6. 函数名: dpu_plane_pipe\n- 参数: [plane]\n- 调用者: dpu_crtc_atomic_check\n- 被调用者: []\n\n7. 函数名: dpu_plane_clear_multirect\n- 参数: [pipe_staged[i]]\n- 调用者: dpu_crtc_atomic_check\n- 被调用者: []\n\n8. 函数名: dpu_plane_validate_multirect_v2\n- 参数: [&multirect_plane[i]]\n- 调用者: dpu_crtc_atomic_check\n- 被调用者: []\n\n9. 函数名: _dpu_crtc_get_kms\n- 参数: [crtc]\n- 调用者: dpu_crtc_atomic_check\n- 被调用者: []\n\n10. 函数名: dpu_core_perf_crtc_check\n- 参数: [crtc, crtc_state]\n- 调用者: dpu_crtc_atomic_check\n- 被调用者: []\n\n11. 函数名: drm_atomic_get_new_crtc_state\n- 参数: [state, crtc]\n- 调用者: dpu_crtc_atomic_check\n- 被调用者: []\n\n12. 函数名: drm_atomic_crtc_state_for_each_plane_state\n- 参数: [plane, pstate, crtc_state]\n- 调用者: dpu_crtc_atomic_check\n- 被调用者: []\n\n13. 函数名: drm_plane_state_dest\n- 参数: [pstate]\n- 调用者: dpu_crtc_atomic_check\n- 被调用者: []\n\n14. 函数名: drm_rect_intersect\n- 参数: [&clip, &dst]\n- 调用者: dpu_crtc_atomic_check\n- 被调用者: []"
    },
    {
        "id": 4016,
        "cwe": "CWE-476",
        "cve": "CVE-2023-32248",
        "purpose": "Code purpose:\"\"\"该代码实现了SMB2协议中查询文件系统信息的功能，根据不同的信息类别(FileInfoClass)返回相应的文件系统属性、设备信息、卷信息等数据。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_QUERY_INFO命令时，未对指针进行充分验证就直接访问，导致空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: smb2_get_info_filesystem\n- 参数: [work, req, rsp]\n- 调用者: 未显示\n- 被调用者: [kern_path, vfs_statfs, path_put, cpu_to_le32, inc_rfc1001_len, smbConvertToUTF16, test_share_config_flag, crc32_le, ksmbd_netbios_name, strlen, user_guest, user_passkey, memset, memcpy, min_t, buffer_check_err, le32_to_cpu]\n\n2. 函数名: kern_path\n- 参数: [share->path, LOOKUP_NO_SYMLINKS, &path]\n- 调用者: smb2_get_info_filesystem\n- 被调用者: 未显示\n\n3. 函数名: vfs_statfs\n- 参数: [&path, &stfs]\n- 调用者: smb2_get_info_filesystem\n- 被调用者: 未显示\n\n4. 函数名: path_put\n- 参数: [&path]\n- 调用者: smb2_get_info_filesystem\n- 被调用者: 未显示\n\n5. 函数名: cpu_to_le32\n- 参数: [数值]\n- 调用者: smb2_get_info_filesystem\n- 被调用者: 未显示\n\n6. 函数名: inc_rfc1001_len\n- 参数: [work->response_buf, 长度值]\n- 调用者: smb2_get_info_filesystem\n- 被调用者: 未显示\n\n7. 函数名: smbConvertToUTF16\n- 参数: [(__le16 *)info->FileSystemName/VolumeLabel, 字符串, PATH_MAX, conn->local_nls, 0]\n- 调用者: smb2_get_info_filesystem\n- 被调用者: 未显示\n\n8. 函数名: test_share_config_flag\n- 参数: [work->tcon->share_conf, KSMBD_SHARE_FLAG_STREAMS]\n- 调用者: smb2_get_info_filesystem\n- 被调用者: 未显示\n\n9. 函数名: crc32_le\n- 参数: [serial_crc, 字符串, strlen(字符串)]\n- 调用者: smb2_get_info_filesystem\n- 被调用者: 未显示\n\n10. 函数名: ksmbd_netbios_name\n- 参数: []\n- 调用者: smb2_get_info_filesystem\n- 被调用者: 未显示\n\n11. 函数名: strlen\n- 参数: [字符串]\n- 调用者: smb2_get_info_filesystem\n- 被调用者: 未显示\n\n12. 函数名: user_guest\n- 参数: [sess->user]\n- 调用者: smb2_get_info_filesystem\n- 被调用者: 未显示\n\n13. 函数名: user_passkey\n- 参数: [sess->user]\n- 调用者: smb2_get_info_filesystem\n- 被调用者: 未显示\n\n14. 函数名: memset\n- 参数: [info->objid, 0, 16]\n- 调用者: smb2_get_info_filesystem\n- 被调用者: 未显示\n\n15. 函数名: memcpy\n- 参数: [info->objid/extended_info.version_string, 源数据, 长度]\n- 调用者: smb2_get_info_filesystem\n- 被调用者: 未显示\n\n16. 函数名: min_t\n- 参数: [unsigned int, path.mnt->mnt_sb->s_blocksize, 4096]\n- 调用者: smb2_get_info_filesystem\n- 被调用者: 未显示\n\n17. 函数名: buffer_check_err\n- 参数: [le32_to_cpu(req->OutputBufferLength), rsp, work->response_buf, fs_infoclass_size]\n- 调用者: smb2_get_info_filesystem\n- 被调用者: 未显示\n\n18. 函数名: le32_to_cpu\n- 参数: [req->OutputBufferLength]\n- 调用者: smb2_get_info_filesystem\n- 被调用者: 未显示"
    },
    {
        "id": 4025,
        "cwe": "CWE-476",
        "cve": "CVE-2023-32252",
        "purpose": "Code purpose:\"\"\"释放ksmbd连接中的服务器互斥锁\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ksmbd处理SMB2_LOGOFF命令时，未对conn指针进行有效性验证就直接访问其成员srv_mutex，导致空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ksmbd_conn_unlock\n- 参数: [struct ksmbd_conn *conn]\n- 调用者: 未明确（需查看完整代码）\n- 被调用者: [mutex_unlock]"
    },
    {
        "id": 4026,
        "cwe": "CWE-476",
        "cve": "CVE-2023-32252",
        "purpose": "Code purpose:\"\"\"通过获取互斥锁来保护对ksmbd连接结构的访问\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ksmbd处理SMB2_LOGOFF命令时，未对conn指针进行有效验证就直接访问其成员srv_mutex，导致空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ksmbd_conn_lock\n- 参数: [conn]\n- 调用者: 未明确（需更多上下文）\n- 被调用者: [mutex_lock]"
    },
    {
        "id": 4027,
        "cwe": "CWE-476",
        "cve": "CVE-2023-32252",
        "purpose": "Code purpose:\"\"\"检查ksmbd连接是否仍然活跃，根据服务器状态、连接状态、文件打开计数和最后活动时间等因素决定是否保持连接\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_LOGOFF命令时，未能正确验证指针的有效性就直接访问它\"\"\"",
        "functions": "Functions:\n1. 函数名: ksmbd_conn_alive\n- 参数: [struct ksmbd_conn *conn]\n- 调用者: 未显示\n- 被调用者: [ksmbd_server_running, atomic_read, time_after, ksmbd_debug]\n\n2. 函数名: ksmbd_server_running\n- 参数: []\n- 调用者: ksmbd_conn_alive\n- 被调用者: 未显示\n\n3. 函数名: atomic_read\n- 参数: [&conn->stats.open_files_count]\n- 调用者: ksmbd_conn_alive\n- 被调用者: 未显示\n\n4. 函数名: time_after\n- 参数: [jiffies, conn->last_active + server_conf.deadtime]\n- 调用者: ksmbd_conn_alive\n- 被调用者: 未显示\n\n5. 函数名: ksmbd_debug\n- 参数: [CONN, \"No response from client in %lu minutes\\n\", server_conf.deadtime / SMB_ECHO_INTERVAL]\n- 调用者: ksmbd_conn_alive\n- 被调用者: 未显示"
    },
    {
        "id": 4028,
        "cwe": "CWE-476",
        "cve": "CVE-2023-32252",
        "purpose": "Code purpose:\"\"\"检查SMB连接状态并在需要断开连接时设置错误状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_LOGOFF命令时，未对work->response_buf指针进行有效验证就直接访问，导致空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: check_conn_state\n- 参数: [struct ksmbd_work *work]\n- 调用者: 未明确（需根据完整代码确定）\n- 被调用者: [ksmbd_conn_exiting, ksmbd_conn_need_reconnect]\n\n2. 函数名: ksmbd_conn_exiting\n- 参数: [struct ksmbd_work *work]\n- 调用者: check_conn_state\n- 被调用者: []\n\n3. 函数名: ksmbd_conn_need_reconnect\n- 参数: [struct ksmbd_work *work]\n- 调用者: check_conn_state\n- 被调用者: []"
    },
    {
        "id": 4029,
        "cwe": "CWE-476",
        "cve": "CVE-2023-32252",
        "purpose": "Code purpose:\"\"\"处理SMB2协议的协商请求，包括验证请求参数、初始化服务器配置以及设置连接的安全模式等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_LOGOFF命令时，缺乏对指针的适当验证导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: smb2_handle_negotiate\n- 参数: [struct ksmbd_work *work]\n- 调用者: 未显示\n- 被调用者: [smb2_get_msg, ksmbd_debug, ksmbd_conn_good, get_rfc1002_len, le32_to_cpu, le16_to_cpu, kzalloc, deassemble_neg_contexts, kfree, init_smb3_11_server, ksmbd_gen_preauth_integrity_hash, cpu_to_le32, assemble_neg_contexts, init_smb3_02_server, init_smb3_0_server, init_smb2_1_server, memset, ksmbd_systime, ksmbd_copy_gss_neg_header, inc_rfc1001_len, smb2_set_err_rsp]\n\n2. 函数名: smb2_get_msg\n- 参数: [work->request_buf, work->response_buf]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n3. 函数名: ksmbd_debug\n- 参数: [SMB, \"Received negotiate request\\n\", \"Server dialect :0x%x not supported\\n\", \"negotiate context offset %d, count %d\\n\"]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n4. 函数名: ksmbd_conn_good\n- 参数: [work]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n5. 函数名: get_rfc1002_len\n- 参数: [work->request_buf]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n6. 函数名: le32_to_cpu\n- 参数: [req->NegotiateContextOffset, req->Capabilities, rsp->NegotiateContextOffset]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n7. 函数名: le16_to_cpu\n- 参数: [req->DialectCount, req->SecurityMode, rsp->SecurityBufferOffset]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n8. 函数名: kzalloc\n- 参数: [sizeof(struct preauth_integrity_info), GFP_KERNEL]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n9. 函数名: deassemble_neg_contexts\n- 参数: [conn, req, get_rfc1002_len(work->request_buf)]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n10. 函数名: kfree\n- 参数: [conn->preauth_info]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n11. 函数名: init_smb3_11_server\n- 参数: [conn]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n12. 函数名: ksmbd_gen_preauth_integrity_hash\n- 参数: [conn, work->request_buf, conn->preauth_info->Preauth_HashValue]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n13. 函数名: cpu_to_le32\n- 参数: [OFFSET_OF_NEG_CONTEXT, conn->vals->capabilities, conn->vals->max_trans_size, conn->vals->max_read_size, conn->vals->max_write_size]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n14. 函数名: assemble_neg_contexts\n- 参数: [conn, rsp, work->response_buf]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n15. 函数名: init_smb3_02_server\n- 参数: [conn]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n16. 函数名: init_smb3_0_server\n- 参数: [conn]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n17. 函数名: init_smb2_1_server\n- 参数: [conn]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n18. 函数名: memset\n- 参数: [rsp->ServerGUID, 0, SMB2_CLIENT_GUID_SIZE]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n19. 函数名: ksmbd_systime\n- 参数: []\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n20. 函数名: ksmbd_copy_gss_neg_header\n- 参数: [(char *)(&rsp->hdr) + le16_to_cpu(rsp->SecurityBufferOffset)]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n21. 函数名: inc_rfc1001_len\n- 参数: [work->response_buf, sizeof(struct smb2_negotiate_rsp) - sizeof(struct smb2_hdr) + AUTH_GSS_LENGTH]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示\n\n22. 函数名: smb2_set_err_rsp\n- 参数: [work]\n- 调用者: smb2_handle_negotiate\n- 被调用者: 未显示"
    },
    {
        "id": 4030,
        "cwe": "CWE-476",
        "cve": "CVE-2023-32252",
        "purpose": "Code purpose:\"\"\"该代码用于在ksmbd服务中处理SMB2_LOGOFF命令时销毁之前的会话，包括验证会话用户信息并标记会话和通道状态为过期或退出\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_LOGOFF命令时，未对prev_sess指针进行充分验证就进行访问，导致空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: destroy_previous_session\n- 参数: [conn, user, id]\n- 调用者: 未指定\n- 被调用者: [ksmbd_session_lookup_slowpath, strcmp, memcmp]\n\n2. 函数名: ksmbd_session_lookup_slowpath\n- 参数: [id]\n- 调用者: destroy_previous_session\n- 被调用者: 未指定\n\n3. 函数名: strcmp\n- 参数: [user->name, prev_user->name]\n- 调用者: destroy_previous_session\n- 被调用者: 未指定\n\n4. 函数名: memcmp\n- 参数: [user->passkey, prev_user->passkey, user->passkey_sz]\n- 调用者: destroy_previous_session\n- 被调用者: 未指定"
    },
    {
        "id": 4031,
        "cwe": "CWE-476",
        "cve": "CVE-2023-32252",
        "purpose": "Code purpose:\"\"\"该代码实现了SMB2协议协商响应的初始化功能，包括设置协议头、协商参数和安全认证相关信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_LOGOFF命令时，由于未对指针进行适当验证就直接访问，导致空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: init_smb2_neg_rsp\n- 参数: [struct ksmbd_work *work]\n- 调用者: 未显示\n- 被调用者: [cpu_to_be32, smb2_get_msg, memset, WARN_ON, ksmbd_conn_good, cpu_to_le16, ksmbd_debug, cpu_to_le32, cpu_to_le64, ksmbd_systime, ksmbd_copy_gss_neg_header, le16_to_cpu, inc_rfc1001_len, ksmbd_conn_set_need_negotiate]\n\n2. 函数名: cpu_to_be32\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n3. 函数名: smb2_get_msg\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n4. 函数名: memset\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n5. 函数名: WARN_ON\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n6. 函数名: ksmbd_conn_good\n- 参数: [未显示]\n- 调用者: WARN_ON\n- 被调用者: []\n\n7. 函数名: cpu_to_le16\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n8. 函数名: ksmbd_debug\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n9. 函数名: cpu_to_le32\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n10. 函数名: cpu_to_le64\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n11. 函数名: ksmbd_systime\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n12. 函数名: ksmbd_copy_gss_neg_header\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n13. 函数名: le16_to_cpu\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n14. 函数名: inc_rfc1001_len\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []\n\n15. 函数名: ksmbd_conn_set_need_negotiate\n- 参数: [未显示]\n- 调用者: init_smb2_neg_rsp\n- 被调用者: []"
    },
    {
        "id": 4032,
        "cwe": "CWE-476",
        "cve": "CVE-2023-32252",
        "purpose": "Code purpose:\"\"\"该代码片段实现了ksmbd内核模块中TCP读取功能，处理来自客户端的SMB协议数据读取请求，包括错误处理和连接状态检查。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_LOGOFF命令时，ksmbd未能正确验证指针的有效性就直接访问它\"\"\"",
        "functions": "Functions:\n1. 函数名: ksmbd_tcp_readv\n- 参数: [t, iov_orig, nr_segs, to_read, max_retries]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [get_conn_iovec, ksmbd_conn_alive, kvec_array_init, kernel_recvmsg, usleep_range]\n\n2. 函数名: get_conn_iovec\n- 参数: [t, nr_segs]\n- 调用者: ksmbd_tcp_readv\n- 被调用者: 未明确\n\n3. 函数名: ksmbd_conn_alive\n- 参数: [conn]\n- 调用者: ksmbd_tcp_readv\n- 被调用者: 未明确\n\n4. 函数名: kvec_array_init\n- 参数: [iov, iov_orig, nr_segs, total_read]\n- 调用者: ksmbd_tcp_readv\n- 被调用者: 未明确\n\n5. 函数名: kernel_recvmsg\n- 参数: [t->sock, &ksmbd_msg, iov, segs, to_read, 0]\n- 调用者: ksmbd_tcp_readv\n- 被调用者: 未明确\n\n6. 函数名: usleep_range\n- 参数: [1000, 2000]\n- 调用者: ksmbd_tcp_readv\n- 被调用者: 未明确"
    },
    {
        "id": 4060,
        "cwe": "CWE-476",
        "cve": "CVE-2023-3355",
        "purpose": "Code purpose:\"\"\"该代码用于处理用户空间提交的GPU命令，验证并复制命令数据到内核空间，以便后续执行。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码在调用kmalloc分配内存后未检查返回值是否为NULL，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: submit_lookup_cmds\n- 参数: [struct msm_gem_submit *submit, struct drm_msm_gem_submit *args, struct drm_file *file]\n- 调用者: 未显示\n- 被调用者: [copy_from_user, u64_to_user_ptr, DRM_ERROR, array_size, kmalloc]\n\n2. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: submit_lookup_cmds\n- 被调用者: 未显示\n\n3. 函数名: u64_to_user_ptr\n- 参数: [u64 addr]\n- 调用者: submit_lookup_cmds\n- 被调用者: 未显示\n\n4. 函数名: DRM_ERROR\n- 参数: [const char *fmt, ...]\n- 调用者: submit_lookup_cmds\n- 被调用者: 未显示\n\n5. 函数名: array_size\n- 参数: [size_t a, size_t b]\n- 调用者: submit_lookup_cmds\n- 被调用者: 未显示\n\n6. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: submit_lookup_cmds\n- 被调用者: 未显示"
    },
    {
        "id": 4061,
        "cwe": "CWE-476",
        "cve": "CVE-2023-3357",
        "purpose": "Code purpose:\"\"\"初始化AMD Sensor Fusion Hub驱动中的HID客户端，包括传感器数据分配、状态管理和设备探测等功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在AMD Sensor Fusion Hub驱动程序中，未正确验证指针是否为空就直接解引用，导致本地用户可通过空指针解引用使系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: amd_sfh_hid_client_init\n- 参数: [struct amd_mp2_dev *privdata]\n- 调用者: N/A (top-level function)\n- 被调用者: [amd_mp2_get_sensor_num, amd_sfh_set_desc_ops, dma_alloc_coherent, mp2_ops->get_desc_sz, devm_kzalloc, mp2_ops->get_rep_desc, mp2_ops->start, amd_sfh_wait_for_response, amdtp_hid_probe, mp2_ops->stop, get_sensor_name, dev_dbg, mp2_ops->discovery_status, amd_sfh_hid_client_deinit, devm_kfree, schedule_delayed_work, dma_free_coherent]\n\n2. 函数名: amd_mp2_get_sensor_num\n- 参数: [struct amd_mp2_dev *privdata, &cl_data->sensor_idx[0]]\n- 调用者: amd_sfh_hid_client_init\n- 被调用者: N/A\n\n3. 函数名: amd_sfh_set_desc_ops\n- 参数: [struct amd_mp2_ops *mp2_ops]\n- 调用者: amd_sfh_hid_client_init\n- 被调用者: N/A\n\n4. 函数名: dma_alloc_coherent\n- 参数: [struct device *dev, sizeof(int) * 8, &cl_data->sensor_dma_addr[i], GFP_KERNEL]\n- 调用者: amd_sfh_hid_client_init\n- 被调用者: N/A\n\n5. 函数名: mp2_ops->get_desc_sz\n- 参数: [cl_idx, descr_size/feature_size/input_size]\n- 调用者: amd_sfh_hid_client_init\n- 被调用者: N/A\n\n6. 函数名: devm_kzalloc\n- 参数: [struct device *dev, feature_report_size/input_report_size/cl_data->report_descr_sz[i], GFP_KERNEL]\n- 调用者: amd_sfh_hid_client_init\n- 被调用者: N/A\n\n7. 函数名: mp2_ops->get_rep_desc\n- 参数: [cl_idx, cl_data->report_descr[i]]\n- 调用者: amd_sfh_hid_client_init\n- 被调用者: N/A\n\n8. 函数名: mp2_ops->start\n- 参数: [privdata, info]\n- 调用者: amd_sfh_hid_client_init\n- 被调用者: N/A\n\n9. 函数名: amd_sfh_wait_for_response\n- 参数: [privdata, cl_data->sensor_idx[i], SENSOR_ENABLED/SENSOR_DISABLED]\n- 调用者: amd_sfh_hid_client_init\n- 被调用者: N/A\n\n10. 函数名: amdtp_hid_probe\n- 参数: [cl_data->cur_hid_dev, cl_data]\n- 调用者: amd_sfh_hid_client_init\n- 被调用者: N/A\n\n11. 函数名: mp2_ops->stop\n- 参数: [privdata, cl_data->sensor_idx[i]]\n- 调用者: amd_sfh_hid_client_init\n- 被调用者: N/A\n\n12. 函数名: get_sensor_name\n- 参数: [cl_data->sensor_idx[i]]\n- 调用者: amd_sfh_hid_client_init\n- 被调用者: N/A\n\n13. 函数名: dev_dbg\n- 参数: [dev, format string, cl_data->sensor_idx[i], get_sensor_name(cl_data->sensor_idx[i]), cl_data->sensor_sts[i]]\n- 调用者: amd_sfh_hid_client_init\n- 被调用者: N/A\n\n14. 函数名: mp2_ops->discovery_status\n- 参数: [privdata]\n- 调用者: amd_sfh_hid_client_init\n- 被调用者: N/A\n\n15. 函数名: amd_sfh_hid_client_deinit\n- 参数: [privdata]\n- 调用者: amd_sfh_hid_client_init\n- 被调用者: N/A\n\n16. 函数名: devm_kfree\n- 参数: [dev, cl_data->feature_report[i]/in_data->input_report[i]/cl_data->report_descr[i]]\n- 调用者: amd_sfh_hid_client_init\n- 被调用者: N/A\n\n17. 函数名: schedule_delayed_work\n- 参数: [&cl_data->work_buffer, msecs_to_jiffies(AMD_SFH_IDLE_LOOP)]\n- 调用者: amd_sfh_hid_client_init\n- 被调用者: N/A\n\n18. 函数名: dma_free_coherent\n- 参数: [&privdata->pdev->dev, 8 * sizeof(int), in_data->sensor_virt_addr[i], cl_data->sensor_dma_addr[i]]\n- 调用者: amd_sfh_hid_client_init\n- 被调用者: N/A"
    },
    {
        "id": 4062,
        "cwe": "CWE-476",
        "cve": "CVE-2023-3358",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的集成传感器中心(ISH)驱动中获取DMA发送缓冲区，并返回可用缓冲区的指针或NULL\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核的集成传感器中心(ISH)驱动程序中，当dev指针为空时未进行检查就直接解引用，导致空指针解引用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ishtp_cl_get_dma_send_buf\n- 参数: [struct ishtp_device *dev, uint32_t size]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [spin_lock_irqsave, spin_unlock_irqrestore, dev_err]\n\n2. 函数名: spin_lock_irqsave\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: ishtp_cl_get_dma_send_buf\n- 被调用者: []\n\n3. 函数名: spin_unlock_irqrestore\n- 参数: [spinlock_t *lock, unsigned long flags]\n- 调用者: ishtp_cl_get_dma_send_buf\n- 被调用者: []\n\n4. 函数名: dev_err\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: ishtp_cl_get_dma_send_buf\n- 被调用者: []"
    },
    {
        "id": 4063,
        "cwe": "CWE-476",
        "cve": "CVE-2023-3358",
        "purpose": "Code purpose:\"\"\"释放已被DMA确认的内存槽位并更新映射状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在检查DMA Tx确认地址时未对msg_addr指针进行空指针检查，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: ishtp_cl_release_dma_acked_mem\n- 参数: [dev, msg_addr, size]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [dev_err, spin_lock_irqsave, spin_unlock_irqrestore]\n\n2. 函数名: dev_err\n- 参数: [dev->devc, \"Bad DMA Tx ack address\"]\n- 调用者: ishtp_cl_release_dma_acked_mem\n- 被调用者: 未显示（可能是内核日志函数）\n\n3. 函数名: spin_lock_irqsave\n- 参数: [&dev->ishtp_dma_tx_lock, flags]\n- 调用者: ishtp_cl_release_dma_acked_mem\n- 被调用者: 未显示（内核自旋锁函数）\n\n4. 函数名: spin_unlock_irqrestore\n- 参数: [&dev->ishtp_dma_tx_lock, flags]\n- 调用者: ishtp_cl_release_dma_acked_mem\n- 被调用者: 未显示（内核自旋锁函数）"
    },
    {
        "id": 4064,
        "cwe": "CWE-476",
        "cve": "CVE-2023-3359",
        "purpose": "Code purpose:\"\"\"该代码用于解析Broadcom NVRAM数据，包括验证魔术字、分配内存、拷贝数据并添加单元格，但缺少对内存分配失败的检查。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未检查kzalloc()的返回值导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: brcm_nvram_parse\n- 参数: [struct brcm_nvram *priv]\n- 调用者: 未显示\n- 被调用者: [memcpy_fromio, memcmp, dev_err, le32_to_cpu, kzalloc, brcm_nvram_add_cells, kfree]\n\n2. 函数名: memcpy_fromio\n- 参数: [&header, priv->base, sizeof(header)] 和 [data, priv->base, len]\n- 调用者: brcm_nvram_parse\n- 被调用者: 未显示\n\n3. 函数名: memcmp\n- 参数: [header.magic, NVRAM_MAGIC, 4]\n- 调用者: brcm_nvram_parse\n- 被调用者: 未显示\n\n4. 函数名: dev_err\n- 参数: [dev, \"Invalid NVRAM magic\"] 和 [dev, \"Failed to add cells: %d\\n\", err]\n- 调用者: brcm_nvram_parse\n- 被调用者: 未显示\n\n5. 函数名: le32_to_cpu\n- 参数: [header.len]\n- 调用者: brcm_nvram_parse\n- 被调用者: 未显示\n\n6. 函数名: kzalloc\n- 参数: [len, GFP_KERNEL]\n- 调用者: brcm_nvram_parse\n- 被调用者: 未显示\n\n7. 函数名: brcm_nvram_add_cells\n- 参数: [priv, data, len]\n- 调用者: brcm_nvram_parse\n- 被调用者: 未显示\n\n8. 函数名: kfree\n- 参数: [data]\n- 调用者: brcm_nvram_parse\n- 被调用者: 未显示"
    },
    {
        "id": 4134,
        "cwe": "CWE-476",
        "cve": "CVE-2023-3772",
        "purpose": "Code purpose:\"\"\"该代码用于更新XFRM（IP框架转换子系统）中的状态参数，包括重放保护、生命周期和计时器阈值等网络相关配置。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在xfrm_update_ae_params函数中未对attrs数组元素进行空指针检查，导致当恶意用户提供空属性时可能引发空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: xfrm_update_ae_params\n- 参数: [struct xfrm_state *x, struct nlattr **attrs, int update_esn]\n- 调用者: 未明确（由XFRM子系统调用）\n- 被调用者: [nla_data, memcpy, xfrm_replay_state_esn_len, nla_get_u32]\n\n2. 函数名: nla_data\n- 参数: [struct nlattr *]\n- 调用者: xfrm_update_ae_params\n- 被调用者: []\n\n3. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: xfrm_update_ae_params\n- 被调用者: []\n\n4. 函数名: xfrm_replay_state_esn_len\n- 参数: [struct xfrm_replay_state_esn *replay_esn]\n- 调用者: xfrm_update_ae_params\n- 被调用者: []\n\n5. 函数名: nla_get_u32\n- 参数: [struct nlattr *]\n- 调用者: xfrm_update_ae_params\n- 被调用者: []"
    },
    {
        "id": 4207,
        "cwe": "CWE-476",
        "cve": "CVE-2023-42754",
        "purpose": "Code purpose:\"\"\"处理IPv4目标不可达的ICMP消息发送，包括IP选项的编译和验证\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在调用__ip_options_compile时未验证skb是否关联了网络设备，当skb被ipvs重路由时可能导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: ipv4_send_dest_unreach\n- 参数: [struct sk_buff *skb]\n- 调用者: 未显示\n- 被调用者: [pskb_network_may_pull, ip_hdr, memset, __ip_options_compile, __icmp_send]\n\n2. 函数名: pskb_network_may_pull\n- 参数: [struct sk_buff *skb, unsigned int len]\n- 调用者: ipv4_send_dest_unreach\n- 被调用者: 未显示\n\n3. 函数名: ip_hdr\n- 参数: [struct sk_buff *skb]\n- 调用者: ipv4_send_dest_unreach\n- 被调用者: 未显示\n\n4. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: ipv4_send_dest_unreach\n- 被调用者: 未显示\n\n5. 函数名: __ip_options_compile\n- 参数: [struct net *net, struct ip_options *opt, struct sk_buff *skb, __be32 *info]\n- 调用者: ipv4_send_dest_unreach\n- 被调用者: 未显示\n\n6. 函数名: __icmp_send\n- 参数: [struct sk_buff *skb_in, int type, int code, __be32 info, struct ip_options *opt]\n- 调用者: ipv4_send_dest_unreach\n- 被调用者: 未显示\n\n7. 函数名: dev_net\n- 参数: [const struct net_device *dev]\n- 调用者: ipv4_send_dest_unreach (通过__ip_options_compile参数传递)\n- 被调用者: 未显示"
    },
    {
        "id": 4209,
        "cwe": "CWE-476",
        "cve": "CVE-2023-4385",
        "purpose": "Code purpose:\"\"\"释放文件系统中指定范围的磁盘块，并处理可能的TRIM操作和错误检查\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放块操作时未对读取的元页面(mp)进行有效性检查，导致可能解引用空指针\"\"\"",
        "functions": "Functions:\n1. 函数名: dbFree\n- 参数: [struct inode *ip, s64 blkno, s64 nblocks]\n- 调用者: 未显示\n- 被调用者: [JFS_SBI, IREAD_LOCK, IREAD_UNLOCK, printk, jfs_error, jfs_issue_discard, write_metapage, BLKTODMAP, read_metapage, min, dbFreeDmap, release_metapage]\n\n2. 函数名: JFS_SBI\n- 参数: [struct super_block *sb]\n- 调用者: dbFree\n- 被调用者: 未显示\n\n3. 函数名: IREAD_LOCK\n- 参数: [struct inode *ipbmap, RDWRLOCK_DMAP]\n- 调用者: dbFree\n- 被调用者: 未显示\n\n4. 函数名: IREAD_UNLOCK\n- 参数: [struct inode *ipbmap]\n- 调用者: dbFree\n- 被调用者: 未显示\n\n5. 函数名: printk\n- 参数: [KERN_ERR, \"blkno = %Lx, nblocks = %Lx\\n\", (unsigned long long) blkno, (unsigned long long) nblocks]\n- 调用者: dbFree\n- 被调用者: 未显示\n\n6. 函数名: jfs_error\n- 参数: [struct super_block *sb, \"block to be freed is outside the map\\n\"]\n- 调用者: dbFree\n- 被调用者: 未显示\n\n7. 函数名: jfs_issue_discard\n- 参数: [struct inode *ipbmap, s64 blkno, s64 nblocks]\n- 调用者: dbFree\n- 被调用者: 未显示\n\n8. 函数名: write_metapage\n- 参数: [struct metapage *mp]\n- 调用者: dbFree\n- 被调用者: 未显示\n\n9. 函数名: BLKTODMAP\n- 参数: [s64 blkno, bmp->db_l2nbperpage]\n- 调用者: dbFree\n- 被调用者: 未显示\n\n10. 函数名: read_metapage\n- 参数: [struct inode *ipbmap, s64 lblkno, PSIZE, 0]\n- 调用者: dbFree\n- 被调用者: 未显示\n\n11. 函数名: min\n- 参数: [rem, BPERDMAP - (blkno & (BPERDMAP - 1))]\n- 调用者: dbFree\n- 被调用者: 未显示\n\n12. 函数名: dbFreeDmap\n- 参数: [struct bmap *bmp, struct dmap *dp, s64 blkno, int nb]\n- 调用者: dbFree\n- 被调用者: 未显示\n\n13. 函数名: release_metapage\n- 参数: [struct metapage *mp]\n- 调用者: dbFree\n- 被调用者: 未显示"
    },
    {
        "id": 4216,
        "cwe": "CWE-476",
        "cve": "CVE-2023-4459",
        "purpose": "Code purpose:\"\"\"清理VMXNET3网络设备接收队列中的描述符和缓冲区资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在清理过程中缺少对rxd指针的有效性检查，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: vmxnet3_rq_cleanup\n- 参数: [struct vmxnet3_rx_queue *rq, struct vmxnet3_adapter *adapter]\n- 调用者: 未显示\n- 被调用者: [vmxnet3_getRxDesc, dma_unmap_single, dev_kfree_skb, dma_unmap_page, put_page]\n\n2. 函数名: vmxnet3_getRxDesc\n- 参数: [struct Vmxnet3_RxDesc *rxd, struct Vmxnet3_RxDesc *base_rxd, struct Vmxnet3_RxDesc *rxDesc]\n- 调用者: vmxnet3_rq_cleanup\n- 被调用者: 未显示\n\n3. 函数名: dma_unmap_single\n- 参数: [struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir]\n- 调用者: vmxnet3_rq_cleanup\n- 被调用者: 未显示\n\n4. 函数名: dev_kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: vmxnet3_rq_cleanup\n- 被调用者: 未显示\n\n5. 函数名: dma_unmap_page\n- 参数: [struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir]\n- 调用者: vmxnet3_rq_cleanup\n- 被调用者: 未显示\n\n6. 函数名: put_page\n- 参数: [struct page *page]\n- 调用者: vmxnet3_rq_cleanup\n- 被调用者: 未显示"
    },
    {
        "id": 4242,
        "cwe": "CWE-476",
        "cve": "CVE-2023-46862",
        "purpose": "Code purpose:\"\"\"该代码用于在io_uring子系统中显示文件描述符信息，包括SQ/CQ队列状态、线程信息、用户文件和缓冲区等详细数据\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在SQ线程退出时发生竞态条件，导致io_uring_show_fdinfo函数中对ctx->sq_data的访问出现空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: io_uring_show_fdinfo\n- 参数: [m, f]\n- 调用者: N/A\n- 被调用者: [READ_ONCE, seq_printf, io_uring_get_opcode, min, mutex_trylock, task_pid_nr, task_cpu, io_file_from_index, file_dentry, io_uring_show_cred, xa_empty, xa_for_each, spin_lock, hlist_for_each_entry, spin_unlock, mutex_unlock, seq_puts, list_for_each_entry]\n\n2. 函数名: io_uring_get_opcode\n- 参数: [opcode]\n- 调用者: io_uring_show_fdinfo\n- 被调用者: N/A\n\n3. 函数名: io_file_from_index\n- 参数: [file_table, i]\n- 调用者: io_uring_show_fdinfo\n- 被调用者: N/A\n\n4. 函数名: io_uring_show_cred\n- 参数: [m, index, cred]\n- 调用者: io_uring_show_fdinfo\n- 被调用者: N/A\n\n5. 函数名: READ_ONCE\n- 参数: [variable]\n- 调用者: io_uring_show_fdinfo\n- 被调用者: N/A\n\n6. 函数名: seq_printf\n- 参数: [m, format, ...]\n- 调用者: io_uring_show_fdinfo\n- 被调用者: N/A\n\n7. 函数名: min\n- 参数: [a, b]\n- 调用者: io_uring_show_fdinfo\n- 被调用者: N/A\n\n8. 函数名: mutex_trylock\n- 参数: [lock]\n- 调用者: io_uring_show_fdinfo\n- 被调用者: N/A\n\n9. 函数名: task_pid_nr\n- 参数: [task]\n- 调用者: io_uring_show_fdinfo\n- 被调用者: N/A\n\n10. 函数名: task_cpu\n- 参数: [task]\n- 调用者: io_uring_show_fdinfo\n- 被调用者: N/A\n\n11. 函数名: file_dentry\n- 参数: [f]\n- 调用者: io_uring_show_fdinfo\n- 被调用者: N/A\n\n12. 函数名: xa_empty\n- 参数: [xa]\n- 调用者: io_uring_show_fdinfo\n- 被调用者: N/A\n\n13. 函数名: xa_for_each\n- 参数: [xa, index, entry]\n- 调用者: io_uring_show_fdinfo\n- 被调用者: N/A\n\n14. 函数名: spin_lock\n- 参数: [lock]\n- 调用者: io_uring_show_fdinfo\n- 被调用者: N/A\n\n15. 函数名: hlist_for_each_entry\n- 参数: [pos, head, member]\n- 调用者: io_uring_show_fdinfo\n- 被调用者: N/A\n\n16. 函数名: spin_unlock\n- 参数: [lock]\n- 调用者: io_uring_show_fdinfo\n- 被调用者: N/A\n\n17. 函数名: mutex_unlock\n- 参数: [lock]\n- 调用者: io_uring_show_fdinfo\n- 被调用者: N/A\n\n18. 函数名: seq_puts\n- 参数: [m, s]\n- 调用者: io_uring_show_fdinfo\n- 被调用者: N/A\n\n19. 函数名: list_for_each_entry\n- 参数: [pos, head, member]\n- 调用者: io_uring_show_fdinfo\n- 被调用者: N/A"
    },
    {
        "id": 4293,
        "cwe": "CWE-476",
        "cve": "CVE-2023-5972",
        "purpose": "Code purpose:\"\"\"解析网络过滤器(nftables)表达式内部数据并验证其有效性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在nft_expr_inner_parse函数中，当type->inner_ops为空指针时未进行充分验证，导致可能发生空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_expr_inner_parse\n- 参数: [const struct nft_ctx *ctx, const struct nlattr *nla, struct nft_expr_info *info]\n- 调用者: 未提供\n- 被调用者: [nla_parse_nested_deprecated, __nft_expr_type_get]\n\n2. 函数名: nla_parse_nested_deprecated\n- 参数: [tb, NFTA_EXPR_MAX, nla, nft_expr_policy, NULL]\n- 调用者: nft_expr_inner_parse\n- 被调用者: 未提供\n\n3. 函数名: __nft_expr_type_get\n- 参数: [ctx->family, tb[NFTA_EXPR_NAME]]\n- 调用者: nft_expr_inner_parse\n- 被调用者: 未提供"
    },
    {
        "id": 4300,
        "cwe": "CWE-476",
        "cve": "CVE-2023-6176",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中BPF执行传输判决的功能，处理TLS记录的消息传递、重定向和验证，并管理相关的套接字和内存资源。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当用户构造恶意数据包并使用特定套接字配置时，会导致内核API中的scatterwalk功能出现空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: bpf_exec_tx_verdict\n- 参数: [msg, sk, full_record, record_type, copied, flags]\n- 调用者: N/A\n- 被调用者: [tls_get_ctx, tls_sw_ctx_tx, sk_psock_get, tls_push_record, sk_msg_free, tls_free_open_rec, sk_psock_put, sk_psock_msg_verdict, sk_msg_free_nocharge, sk_msg_free_partial, sock_put, tcp_bpf_sendmsg_redir, release_sock, lock_sock]\n\n2. 函数名: tls_get_ctx\n- 参数: [sk]\n- 调用者: bpf_exec_tx_verdict\n- 被调用者: N/A\n\n3. 函数名: tls_sw_ctx_tx\n- 参数: [tls_ctx]\n- 调用者: bpf_exec_tx_verdict\n- 被调用者: N/A\n\n4. 函数名: sk_psock_get\n- 参数: [sk]\n- 调用者: bpf_exec_tx_verdict\n- 被调用者: N/A\n\n5. 函数名: tls_push_record\n- 参数: [sk, flags, record_type]\n- 调用者: bpf_exec_tx_verdict\n- 被调用者: N/A\n\n6. 函数名: sk_msg_free\n- 参数: [sk, msg]\n- 调用者: bpf_exec_tx_verdict\n- 被调用者: N/A\n\n7. 函数名: tls_free_open_rec\n- 参数: [sk]\n- 调用者: bpf_exec_tx_verdict\n- 被调用者: N/A\n\n8. 函数名: sk_psock_put\n- 参数: [sk, psock]\n- 调用者: bpf_exec_tx_verdict\n- 被调用者: N/A\n\n9. 函数名: sk_psock_msg_verdict\n- 参数: [sk, psock, msg]\n- 调用者: bpf_exec_tx_verdict\n- 被调用者: N/A\n\n10. 函数名: sk_msg_free_nocharge\n- 参数: [sk, msg_redir]\n- 调用者: bpf_exec_tx_verdict\n- 被调用者: N/A\n\n11. 函数名: sk_msg_free_partial\n- 参数: [sk, msg, send]\n- 调用者: bpf_exec_tx_verdict\n- 被调用者: N/A\n\n12. 函数名: sock_put\n- 参数: [psock->sk_redir]\n- 调用者: bpf_exec_tx_verdict\n- 被调用者: N/A\n\n13. 函数名: tcp_bpf_sendmsg_redir\n- 参数: [sk_redir, redir_ingress, msg_redir, send, flags]\n- 调用者: bpf_exec_tx_verdict\n- 被调用者: N/A\n\n14. 函数名: release_sock\n- 参数: [sk]\n- 调用者: bpf_exec_tx_verdict\n- 被调用者: N/A\n\n15. 函数名: lock_sock\n- 参数: [sk]\n- 调用者: bpf_exec_tx_verdict\n- 被调用者: N/A"
    },
    {
        "id": 4307,
        "cwe": "CWE-476",
        "cve": "CVE-2023-6622",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中nftables动态集合(nft_dynset)的初始化功能，用于处理网络过滤规则中的动态集合操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在nft_dynset_init函数中，当处理动态集合表达式时，未充分验证priv->expr_array的初始化状态，可能导致空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_dynset_init\n- 参数: [const struct nft_ctx *ctx, const struct nft_expr *expr, const struct nlattr * const tb[]]\n- 调用者: (未明确显示，应为内核中调用nft_dynset_init的代码)\n- 被调用者: [nft_pernet, nft_expr_priv, nft_genmask_next, ntohl, nla_get_be32, nft_set_lookup_global, nf_msecs_to_jiffies64, nft_parse_register_load, nft_dynset_expr_alloc, nft_set_elem_expr_clone, nft_set_ext_prepare, nft_set_ext_add_length, nft_set_ext_add, nft_dynset_ext_add_expr, nf_tables_bind_set, nft_expr_destroy]\n\n2. 函数名: nft_pernet\n- 参数: [ctx->net]\n- 调用者: nft_dynset_init\n- 被调用者: []\n\n3. 函数名: nft_expr_priv\n- 参数: [expr]\n- 调用者: nft_dynset_init\n- 被调用者: []\n\n4. 函数名: nft_genmask_next\n- 参数: [ctx->net]\n- 调用者: nft_dynset_init\n- 被调用者: []\n\n5. 函数名: ntohl\n- 参数: [nla_get_be32(tb[NFTA_DYNSET_FLAGS])]\n- 调用者: nft_dynset_init\n- 被调用者: []\n\n6. 函数名: nla_get_be32\n- 参数: [tb[NFTA_DYNSET_FLAGS], tb[NFTA_DYNSET_OP]]\n- 调用者: nft_dynset_init\n- 被调用者: []\n\n7. 函数名: nft_set_lookup_global\n- 参数: [ctx->net, ctx->table, tb[NFTA_DYNSET_SET_NAME], tb[NFTA_DYNSET_SET_ID], genmask]\n- 调用者: nft_dynset_init\n- 被调用者: []\n\n8. 函数名: nf_msecs_to_jiffies64\n- 参数: [tb[NFTA_DYNSET_TIMEOUT], &timeout]\n- 调用者: nft_dynset_init\n- 被调用者: []\n\n9. 函数名: nft_parse_register_load\n- 参数: [tb[NFTA_DYNSET_SREG_KEY], &priv->sreg_key, set->klen], [tb[NFTA_DYNSET_SREG_DATA], &priv->sreg_data, set->dlen]\n- 调用者: nft_dynset_init\n- 被调用者: []\n\n10. 函数名: nft_dynset_expr_alloc\n- 参数: [ctx, set, tb[NFTA_DYNSET_EXPR], 0], [ctx, set, tmp, i]\n- 调用者: nft_dynset_init\n- 被调用者: []\n\n11. 函数名: nft_set_elem_expr_clone\n- 参数: [ctx, set, priv->expr_array]\n- 调用者: nft_dynset_init\n- 被调用者: []\n\n12. 函数名: nft_set_ext_prepare\n- 参数: [&priv->tmpl]\n- 调用者: nft_dynset_init\n- 被调用者: []\n\n13. 函数名: nft_set_ext_add_length\n- 参数: [&priv->tmpl, NFT_SET_EXT_KEY, set->klen], [&priv->tmpl, NFT_SET_EXT_DATA, set->dlen]\n- 调用者: nft_dynset_init\n- 被调用者: []\n\n14. 函数名: nft_set_ext_add\n- 参数: [&priv->tmpl, NFT_SET_EXT_TIMEOUT], [&priv->tmpl, NFT_SET_EXT_EXPIRATION]\n- 调用者: nft_dynset_init\n- 被调用者: []\n\n15. 函数名: nft_dynset_ext_add_expr\n- 参数: [priv]\n- 调用者: nft_dynset_init\n- 被调用者: []\n\n16. 函数名: nf_tables_bind_set\n- 参数: [ctx, set, &priv->binding]\n- 调用者: nft_dynset_init\n- 被调用者: []\n\n17. 函数名: nft_expr_destroy\n- 参数: [ctx, priv->expr_array[i]]\n- 调用者: nft_dynset_init\n- 被调用者: []"
    },
    {
        "id": 4308,
        "cwe": "CWE-476",
        "cve": "CVE-2023-6679",
        "purpose": "Code purpose:\"\"\"该代码用于设置数字锁相环(DPLL)子系统中引脚与父引脚的关系状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在dpll_pin_parent_pin_set函数中，未对tb[DPLL_A_PIN_STATE]进行空指针检查就直接调用nla_get_u32，可能导致空指针解引用\"\"\"",
        "functions": "Functions:\n1. 函数名: dpll_pin_parent_pin_set\n- 参数: [pin, parent_nest, extack]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [nla_parse_nested, NL_SET_ERR_MSG, nla_get_u32, dpll_pin_on_pin_state_set]\n\n2. 函数名: nla_parse_nested\n- 参数: [tb, DPLL_A_PIN_MAX, parent_nest, dpll_pin_parent_pin_nl_policy, extack]\n- 调用者: dpll_pin_parent_pin_set\n- 被调用者: 未明确（可能是内核函数）\n\n3. 函数名: NL_SET_ERR_MSG\n- 参数: [extack, \"device parent id expected\"]\n- 调用者: dpll_pin_parent_pin_set\n- 被调用者: 未明确（内核宏/函数）\n\n4. 函数名: nla_get_u32\n- 参数: [tb[DPLL_A_PIN_PARENT_ID]] 和 [tb[DPLL_A_PIN_STATE]]\n- 调用者: dpll_pin_parent_pin_set\n- 被调用者: 未明确（内核函数）\n\n5. 函数名: dpll_pin_on_pin_state_set\n- 参数: [pin, ppin_idx, state, extack]\n- 调用者: dpll_pin_parent_pin_set\n- 被调用者: 未明确（内核函数）"
    },
    {
        "id": 59,
        "cwe": "CWE-787",
        "cve": "CVE-2012-3400",
        "purpose": "Code purpose:\"\"\"加载并解析UDF文件系统中的逻辑卷描述符，处理分区映射表信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理UDF文件系统的逻辑卷描述符时，未充分验证分区表长度(table_len)与块大小(sb->s_blocksize)的关系，导致堆缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: udf_load_logicalvol\n- 参数: [struct super_block *sb, sector_t block, struct kernel_lb_addr *fileset]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [udf_read_tagged, udf_sb_alloc_partition_maps, udf_load_logicalvolint, brelse, udf_err, udf_debug]\n\n2. 函数名: udf_read_tagged\n- 参数: [struct super_block *sb, sector_t block, sector_t block, uint16_t *ident]\n- 调用者: udf_load_logicalvol\n- 被调用者: 未显示（可能是底层函数）\n\n3. 函数名: udf_sb_alloc_partition_maps\n- 参数: [struct super_block *sb, uint32_t numPartitionMaps]\n- 调用者: udf_load_logicalvol\n- 被调用者: 未显示（可能是内存分配函数）\n\n4. 函数名: udf_load_logicalvolint\n- 参数: [struct super_block *sb, struct extent_address *ea]\n- 调用者: udf_load_logicalvol\n- 被调用者: 未显示\n\n5. 函数名: brelse\n- 参数: [struct buffer_head *bh]\n- 调用者: udf_load_logicalvol\n- 被调用者: 未显示（内核释放buffer_head的函数）\n\n6. 函数名: udf_err\n- 参数: [struct super_block *sb, const char *fmt, ...]\n- 调用者: udf_load_logicalvol\n- 被调用者: 未显示（错误打印函数）\n\n7. 函数名: udf_debug\n- 参数: [const char *fmt, ...]\n- 调用者: udf_load_logicalvol\n- 被调用者: 未显示（调试信息打印函数）\n\n8. 函数名: udf_get_pblock_virt15\n- 参数: 未显示（通过函数指针调用）\n- 调用者: 未直接显示（通过map->s_partition_func调用）\n- 被调用者: 未显示\n\n9. 函数名: udf_get_pblock_virt20\n- 参数: 未显示（通过函数指针调用）\n- 调用者: 未直接显示（通过map->s_partition_func调用）\n- 被调用者: 未显示\n\n10. 函数名: udf_get_pblock_spar15\n- 参数: 未显示（通过函数指针调用）\n- 调用者: 未直接显示（通过map->s_partition_func调用）\n- 被调用者: 未显示\n\n11. 函数名: udf_get_pblock_meta25\n- 参数: 未显示（通过函数指针调用）\n- 调用者: 未直接显示（通过map->s_partition_func调用）\n- 被调用者: 未显示"
    },
    {
        "id": 427,
        "cwe": "CWE-787",
        "cve": "CVE-2014-0077",
        "purpose": "Code purpose:\"\"\"处理虚拟网络设备接收数据包的功能，包括缓冲区管理和数据包长度验证\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当合并缓冲区被禁用时，代码未正确验证数据包长度，导致恶意数据包可能引发内存破坏或主机系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: handle_rx\n- 参数: [struct vhost_net *net]\n- 调用者: N/A\n- 被调用者: [mutex_lock, mutex_unlock, vhost_disable_notify, peek_head_len, get_rx_bufs, vhost_enable_notify, move_iovec_hdr, copy_iovec_hdr, recvmsg, vhost_discard_vq_desc, memcpy_toiovecend, vhost_add_used_and_signal_n, vhost_log_write, vhost_poll_queue]\n\n2. 函数名: mutex_lock\n- 参数: [struct mutex *vq->mutex]\n- 调用者: handle_rx\n- 被调用者: N/A\n\n3. 函数名: mutex_unlock\n- 参数: [struct mutex *vq->mutex]\n- 调用者: handle_rx\n- 被调用者: N/A\n\n4. 函数名: vhost_disable_notify\n- 参数: [struct vhost_dev *net->dev, struct vhost_virtqueue *vq]\n- 调用者: handle_rx\n- 被调用者: N/A\n\n5. 函数名: peek_head_len\n- 参数: [struct sock *sock->sk]\n- 调用者: handle_rx\n- 被调用者: N/A\n\n6. 函数名: get_rx_bufs\n- 参数: [struct vhost_virtqueue *vq, struct vring_desc *vq->heads, size_t vhost_len, unsigned int *in, struct vhost_log *vq_log, unsigned int *log, int (likely(mergeable) ? UIO_MAXIOV : 1)]\n- 调用者: handle_rx\n- 被调用者: N/A\n\n7. 函数名: vhost_enable_notify\n- 参数: [struct vhost_dev *net->dev, struct vhost_virtqueue *vq]\n- 调用者: handle_rx\n- 被调用者: N/A\n\n8. 函数名: move_iovec_hdr\n- 参数: [struct iovec *vq->iov, void *nvq->hdr, size_t vhost_hlen, unsigned int in]\n- 调用者: handle_rx\n- 被调用者: N/A\n\n9. 函数名: copy_iovec_hdr\n- 参数: [struct iovec *vq->iov, void *nvq->hdr, size_t sock_hlen, unsigned int in]\n- 调用者: handle_rx\n- 被调用者: N/A\n\n10. 函数名: recvmsg\n- 参数: [NULL, struct socket *sock, struct msghdr *msg, size_t sock_len, int (MSG_DONTWAIT | MSG_TRUNC)]\n- 调用者: handle_rx\n- 被调用者: N/A\n\n11. 函数名: vhost_discard_vq_desc\n- 参数: [struct vhost_virtqueue *vq, s16 headcount]\n- 调用者: handle_rx\n- 被调用者: N/A\n\n12. 函数名: memcpy_toiovecend\n- 参数: [struct iovec *nvq->hdr, unsigned char *&hdr, int 0, size_t vhost_hlen]\n- 调用者: handle_rx\n- 被调用者: N/A\n\n13. 函数名: vhost_add_used_and_signal_n\n- 参数: [struct vhost_dev *net->dev, struct vhost_virtqueue *vq, struct vring_desc *vq->heads, s16 headcount]\n- 调用者: handle_rx\n- 被调用者: N/A\n\n14. 函数名: vhost_log_write\n- 参数: [struct vhost_virtqueue *vq, struct vhost_log *vq_log, unsigned int log, size_t vhost_len]\n- 调用者: handle_rx\n- 被调用者: N/A\n\n15. 函数名: vhost_poll_queue\n- 参数: [struct vhost_poll *vq->poll]\n- 调用者: handle_rx\n- 被调用者: N/A"
    },
    {
        "id": 1162,
        "cwe": "CWE-787",
        "cve": "CVE-2016-9755",
        "purpose": "Code purpose:\"\"\"处理IPv6分片数据包的重组，包括查找分片队列、将分片加入队列以及完成重组操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统中IPv6重组处理不当，存在整数溢出和越界写入漏洞，导致本地用户可通过特制应用触发拒绝服务或其他未明确影响\"\"\"",
        "functions": "Functions:\n1. 函数名: nf_ct_frag6_gather\n- 参数: [net, skb, user]\n- 调用者: 未显示\n- 被调用者: [ipv6_hdr, find_prev_fhdr, pskb_may_pull, skb_set_transport_header, skb_transport_header, fq_find, ip6_frag_ecn, spin_lock_bh, nf_ct_frag6_queue, spin_unlock_bh, inet_frag_put, nf_ct_frag6_reasm]\n\n2. 函数名: ipv6_hdr\n- 参数: [skb]\n- 调用者: nf_ct_frag6_gather\n- 被调用者: []\n\n3. 函数名: find_prev_fhdr\n- 参数: [skb, prevhdr, nhoff, fhoff]\n- 调用者: nf_ct_frag6_gather\n- 被调用者: []\n\n4. 函数名: pskb_may_pull\n- 参数: [skb, fhoff + sizeof(*fhdr)]\n- 调用者: nf_ct_frag6_gather\n- 被调用者: []\n\n5. 函数名: skb_set_transport_header\n- 参数: [skb, fhoff]\n- 调用者: nf_ct_frag6_gather\n- 被调用者: []\n\n6. 函数名: skb_transport_header\n- 参数: [skb]\n- 调用者: nf_ct_frag6_gather\n- 被调用者: []\n\n7. 函数名: fq_find\n- 参数: [net, fhdr->identification, user, &hdr->saddr, &hdr->daddr, skb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr)]\n- 调用者: nf_ct_frag6_gather\n- 被调用者: [ip6_frag_ecn]\n\n8. 函数名: ip6_frag_ecn\n- 参数: [hdr]\n- 调用者: fq_find\n- 被调用者: []\n\n9. 函数名: spin_lock_bh\n- 参数: [&fq->q.lock]\n- 调用者: nf_ct_frag6_gather\n- 被调用者: []\n\n10. 函数名: nf_ct_frag6_queue\n- 参数: [fq, skb, fhdr, nhoff]\n- 调用者: nf_ct_frag6_gather\n- 被调用者: []\n\n11. 函数名: spin_unlock_bh\n- 参数: [&fq->q.lock]\n- 调用者: nf_ct_frag6_gather\n- 被调用者: []\n\n12. 函数名: inet_frag_put\n- 参数: [&fq->q, &nf_frags]\n- 调用者: nf_ct_frag6_gather\n- 被调用者: []\n\n13. 函数名: nf_ct_frag6_reasm\n- 参数: [fq, skb, dev]\n- 调用者: nf_ct_frag6_gather\n- 被调用者: []"
    },
    {
        "id": 1163,
        "cwe": "CWE-787",
        "cve": "CVE-2016-9755",
        "purpose": "Code purpose:\"\"\"该代码片段实现了IPv6数据包的重组功能，处理网络过滤子系统中的IPv6分片重组过程，并决定是否接受或暂存数据包。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核netfilter子系统中IPv6重组处理不当，存在整数溢出和越界写入漏洞，导致本地用户可通过特制应用程序触发拒绝服务或其他未明确影响。\"\"\"",
        "functions": "Functions:\n1. 函数名: ipv6_defrag\n- 参数: [priv, skb, state]\n- 调用者: 未明确显示（由netfilter子系统调用）\n- 被调用者: [nf_ct_is_template, nf_ct_frag6_gather, nf_ct6_defrag_user]\n\n2. 函数名: nf_ct_is_template\n- 参数: [(struct nf_conn *)skb->nfct]\n- 调用者: ipv6_defrag\n- 被调用者: []\n\n3. 函数名: nf_ct_frag6_gather\n- 参数: [state->net, skb, nf_ct6_defrag_user(state->hook, skb)]\n- 调用者: ipv6_defrag\n- 被调用者: []\n\n4. 函数名: nf_ct6_defrag_user\n- 参数: [state->hook, skb]\n- 调用者: ipv6_defrag\n- 被调用者: []"
    },
    {
        "id": 1173,
        "cwe": "CWE-787",
        "cve": "CVE-2017-0750",
        "purpose": "Code purpose:\"\"\"对F2FS文件系统的超级块进行完整性检查，验证其魔法数、块大小、扇区大小等关键参数是否符合要求\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未对raw_super->log_blocksize进行有效范围检查，可能导致整数溢出或越界访问\"\"\"",
        "functions": "Functions:\n1. 函数名: sanity_check_raw_super\n- 参数: [struct super_block *sb, struct f2fs_super_block *raw_super]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [le32_to_cpu, f2fs_msg]\n\n2. 函数名: le32_to_cpu\n- 参数: [未显示（参数应为32位值）]\n- 调用者: sanity_check_raw_super\n- 被调用者: 无\n\n3. 函数名: f2fs_msg\n- 参数: [struct super_block *sb, int KERN_INFO, const char *fmt, ...]\n- 调用者: sanity_check_raw_super\n- 被调用者: 无"
    },
    {
        "id": 1180,
        "cwe": "CWE-787",
        "cve": "CVE-2017-1000111",
        "purpose": "Code purpose:\"\"\"处理AF_PACKET套接字的选项设置，包括成员管理、环形缓冲区配置、版本控制等网络数据包操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在PACKET_RESERVE选项处理时未锁定socket，导致与packet_set_ring的安全检查存在竞争条件，可能引发堆越界访问\"\"\"",
        "functions": "Functions:\n1. 函数名: packet_setsockopt\n- 参数: [struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen]\n- 调用者: 未显示（应为内核socket选项设置调用）\n- 被调用者: [pkt_sk, memset, copy_from_user, packet_mc_add, packet_mc_drop, packet_set_ring, lock_sock, release_sock, fanout_add, fanout_set_data]\n\n2. 函数名: pkt_sk\n- 参数: [struct sock *sk]\n- 调用者: packet_setsockopt\n- 被调用者: []\n\n3. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: packet_setsockopt\n- 被调用者: []\n\n4. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: packet_setsockopt\n- 被调用者: []\n\n5. 函数名: packet_mc_add\n- 参数: [struct sock *sk, struct packet_mreq_max *mreq]\n- 调用者: packet_setsockopt\n- 被调用者: []\n\n6. 函数名: packet_mc_drop\n- 参数: [struct sock *sk, struct packet_mreq_max *mreq]\n- 调用者: packet_setsockopt\n- 被调用者: []\n\n7. 函数名: packet_set_ring\n- 参数: [struct sock *sk, union tpacket_req_u *req_u, int flag, int tx_ring]\n- 调用者: packet_setsockopt\n- 被调用者: []\n\n8. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: packet_setsockopt\n- 被调用者: []\n\n9. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: packet_setsockopt\n- 被调用者: []\n\n10. 函数名: fanout_add\n- 参数: [struct sock *sk, int val1, int val2]\n- 调用者: packet_setsockopt\n- 被调用者: []\n\n11. 函数名: fanout_set_data\n- 参数: [struct packet_sock *po, char __user *optval, unsigned int optlen]\n- 调用者: packet_setsockopt\n- 被调用者: []"
    },
    {
        "id": 1185,
        "cwe": "CWE-787",
        "cve": "CVE-2017-1000251",
        "purpose": "Code purpose:\"\"\"处理L2CAP连接响应并配置蓝牙通道参数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理L2CAP配置响应时，由于缺乏对输入数据长度的充分验证，导致栈缓冲区溢出漏洞，可能允许远程代码执行。\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_connect_create_rsp\n- 参数: [conn, cmd, cmd_len, data]\n- 调用者: 未显示（由L2CAP协议处理流程调用）\n- 被调用者: [__le16_to_cpu, __l2cap_get_chan_by_scid, __l2cap_get_chan_by_ident, mutex_lock, l2cap_chan_lock, l2cap_state_change, clear_bit, test_and_set_bit, l2cap_send_cmd, l2cap_get_ident, l2cap_build_conf_req, l2cap_chan_del, l2cap_chan_unlock, mutex_unlock]\n\n2. 函数名: __le16_to_cpu\n- 参数: [rsp->scid, rsp->dcid, rsp->result, rsp->status]\n- 调用者: l2cap_connect_create_rsp\n- 被调用者: []\n\n3. 函数名: __l2cap_get_chan_by_scid\n- 参数: [conn, scid]\n- 调用者: l2cap_connect_create_rsp\n- 被调用者: []\n\n4. 函数名: __l2cap_get_chan_by_ident\n- 参数: [conn, cmd->ident]\n- 调用者: l2cap_connect_create_rsp\n- 被调用者: []\n\n5. 函数名: mutex_lock\n- 参数: [&conn->chan_lock]\n- 调用者: l2cap_connect_create_rsp\n- 被调用者: []\n\n6. 函数名: l2cap_chan_lock\n- 参数: [chan]\n- 调用者: l2cap_connect_create_rsp\n- 被调用者: []\n\n7. 函数名: l2cap_state_change\n- 参数: [chan, BT_CONFIG]\n- 调用者: l2cap_connect_create_rsp\n- 被调用者: []\n\n8. 函数名: clear_bit\n- 参数: [CONF_CONNECT_PEND, &chan->conf_state]\n- 调用者: l2cap_connect_create_rsp\n- 被调用者: []\n\n9. 函数名: test_and_set_bit\n- 参数: [CONF_REQ_SENT, &chan->conf_state]\n- 调用者: l2cap_connect_create_rsp\n- 被调用者: []\n\n10. 函数名: l2cap_send_cmd\n- 参数: [conn, l2cap_get_ident(conn), L2CAP_CONF_REQ, l2cap_build_conf_req(chan, req), req]\n- 调用者: l2cap_connect_create_rsp\n- 被调用者: []\n\n11. 函数名: l2cap_get_ident\n- 参数: [conn]\n- 调用者: l2cap_send_cmd\n- 被调用者: []\n\n12. 函数名: l2cap_build_conf_req\n- 参数: [chan, req]\n- 调用者: l2cap_send_cmd\n- 被调用者: []\n\n13. 函数名: l2cap_chan_del\n- 参数: [chan, ECONNREFUSED]\n- 调用者: l2cap_connect_create_rsp\n- 被调用者: []\n\n14. 函数名: l2cap_chan_unlock\n- 参数: [chan]\n- 调用者: l2cap_connect_create_rsp\n- 被调用者: []\n\n15. 函数名: mutex_unlock\n- 参数: [&conn->chan_lock]\n- 调用者: l2cap_connect_create_rsp\n- 被调用者: []"
    },
    {
        "id": 1186,
        "cwe": "CWE-787",
        "cve": "CVE-2017-1000251",
        "purpose": "Code purpose:\"\"\"处理L2CAP连接响应并发送配置请求的蓝牙协议栈功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对L2CAP配置响应中的数据进行有效边界检查，导致缓冲区溢出漏洞，可能允许远程代码执行。\"\"\"",
        "functions": "Functions:\n1. 函数名: __l2cap_connect_rsp_defer\n- 参数: [struct l2cap_chan *chan]\n- 调用者: 未显示\n- 被调用者: [cpu_to_le16, l2cap_send_cmd, test_and_set_bit, l2cap_get_ident, l2cap_build_conf_req]\n\n2. 函数名: cpu_to_le16\n- 参数: [u16]\n- 调用者: __l2cap_connect_rsp_defer\n- 被调用者: 未显示\n\n3. 函数名: l2cap_send_cmd\n- 参数: [struct l2cap_conn *conn, u8 ident, u8 code, u16 len, void *data]\n- 调用者: __l2cap_connect_rsp_defer\n- 被调用者: 未显示\n\n4. 函数名: test_and_set_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: __l2cap_connect_rsp_defer\n- 被调用者: 未显示\n\n5. 函数名: l2cap_get_ident\n- 参数: [struct l2cap_conn *conn]\n- 调用者: __l2cap_connect_rsp_defer\n- 被调用者: 未显示\n\n6. 函数名: l2cap_build_conf_req\n- 参数: [struct l2cap_chan *chan, u8 *buf]\n- 调用者: __l2cap_connect_rsp_defer\n- 被调用者: 未显示"
    },
    {
        "id": 1187,
        "cwe": "CWE-787",
        "cve": "CVE-2017-1000251",
        "purpose": "Code purpose:\"\"\"处理L2CAP连接请求并建立蓝牙通信通道\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核蓝牙栈在处理L2CAP配置响应时存在栈溢出漏洞，导致可远程执行内核空间代码\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_connect\n- 参数: [conn, cmd, data, rsp_code, amp_id]\n- 调用者: 未显示\n- 被调用者: [l2cap_global_chan_by_psm, hci_conn_check_link_mode, __l2cap_get_chan_by_dcid, pchan->ops->new_connection, bacpy, bdaddr_src_type, bdaddr_dst_type, __l2cap_chan_add, __set_chan_timer, chan->ops->get_sndtimeo, l2cap_chan_check_security, chan->ops->defer, l2cap_state_change, l2cap_chan_unlock, mutex_unlock, l2cap_chan_put, l2cap_send_cmd, l2cap_get_ident, schedule_delayed_work, l2cap_build_conf_req]\n\n2. 函数名: l2cap_global_chan_by_psm\n- 参数: [BT_LISTEN, psm, &conn->hcon->src, &conn->hcon->dst, ACL_LINK]\n- 调用者: l2cap_connect\n- 被调用者: 未显示\n\n3. 函数名: hci_conn_check_link_mode\n- 参数: [conn->hcon]\n- 调用者: l2cap_connect\n- 被调用者: 未显示\n\n4. 函数名: __l2cap_get_chan_by_dcid\n- 参数: [conn, scid]\n- 调用者: l2cap_connect\n- 被调用者: 未显示\n\n5. 函数名: new_connection\n- 参数: [pchan]\n- 调用者: l2cap_connect (通过 pchan->ops->new_connection)\n- 被调用者: 未显示\n\n6. 函数名: bacpy\n- 参数: [&chan->src, &conn->hcon->src], [&chan->dst, &conn->hcon->dst]\n- 调用者: l2cap_connect\n- 被调用者: 未显示\n\n7. 函数名: bdaddr_src_type\n- 参数: [conn->hcon]\n- 调用者: l2cap_connect\n- 被调用者: 未显示\n\n8. 函数名: bdaddr_dst_type\n- 参数: [conn->hcon]\n- 调用者: l2cap_connect\n- 被调用者: 未显示\n\n9. 函数名: __l2cap_chan_add\n- 参数: [conn, chan]\n- 调用者: l2cap_connect\n- 被调用者: 未显示\n\n10. 函数名: __set_chan_timer\n- 参数: [chan, chan->ops->get_sndtimeo(chan)]\n- 调用者: l2cap_connect\n- 被调用者: 未显示\n\n11. 函数名: get_sndtimeo\n- 参数: [chan]\n- 调用者: l2cap_connect (通过 chan->ops->get_sndtimeo)\n- 被调用者: 未显示\n\n12. 函数名: l2cap_chan_check_security\n- 参数: [chan, false]\n- 调用者: l2cap_connect\n- 被调用者: 未显示\n\n13. 函数名: defer\n- 参数: [chan]\n- 调用者: l2cap_connect (通过 chan->ops->defer)\n- 被调用者: 未显示\n\n14. 函数名: l2cap_state_change\n- 参数: [chan, BT_CONNECT2], [chan, BT_CONFIG]\n- 调用者: l2cap_connect\n- 被调用者: 未显示\n\n15. 函数名: l2cap_chan_unlock\n- 参数: [pchan]\n- 调用者: l2cap_connect\n- 被调用者: 未显示\n\n16. 函数名: mutex_unlock\n- 参数: [&conn->chan_lock]\n- 调用者: l2cap_connect\n- 被调用者: 未显示\n\n17. 函数名: l2cap_chan_put\n- 参数: [pchan]\n- 调用者: l2cap_connect\n- 被调用者: 未显示\n\n18. 函数名: l2cap_send_cmd\n- 参数: [conn, cmd->ident, rsp_code, sizeof(rsp), &rsp], [conn, conn->info_ident, L2CAP_INFO_REQ, sizeof(info), &info], [conn, l2cap_get_ident(conn), L2CAP_CONF_REQ, l2cap_build_conf_req(chan, buf), buf]\n- 调用者: l2cap_connect\n- 被调用者: 未显示\n\n19. 函数名: l2cap_get_ident\n- 参数: [conn]\n- 调用者: l2cap_connect\n- 被调用者: 未显示\n\n20. 函数名: schedule_delayed_work\n- 参数: [&conn->info_timer, L2CAP_INFO_TIMEOUT]\n- 调用者: l2cap_connect\n- 被调用者: 未显示\n\n21. 函数名: l2cap_build_conf_req\n- 参数: [chan, buf]\n- 调用者: l2cap_connect\n- 被调用者: 未显示"
    },
    {
        "id": 1188,
        "cwe": "CWE-787",
        "cve": "CVE-2017-1000251",
        "purpose": "Code purpose:\"\"\"处理L2CAP连接启动过程中的通道状态检查和配置响应，包括安全验证、模式支持和状态转换等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核蓝牙栈在处理L2CAP配置响应时存在栈缓冲区溢出漏洞，导致远程代码执行。\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_conn_start\n- 参数: [struct l2cap_conn *conn]\n- 调用者: 未显示\n- 被调用者: [mutex_lock, list_for_each_entry_safe, l2cap_chan_lock, l2cap_chan_ready, l2cap_chan_unlock, l2cap_chan_check_security, __l2cap_no_conn_pending, l2cap_mode_supported, test_bit, l2cap_chan_close, l2cap_start_connection, l2cap_state_change, l2cap_send_cmd, l2cap_get_ident, l2cap_build_conf_req, mutex_unlock]\n\n2. 函数名: l2cap_chan_ready\n- 参数: [struct l2cap_chan *chan]\n- 调用者: l2cap_conn_start\n- 被调用者: 未显示\n\n3. 函数名: l2cap_chan_lock\n- 参数: [struct l2cap_chan *chan]\n- 调用者: l2cap_conn_start\n- 被调用者: 未显示\n\n4. 函数名: l2cap_chan_unlock\n- 参数: [struct l2cap_chan *chan]\n- 调用者: l2cap_conn_start\n- 被调用者: 未显示\n\n5. 函数名: l2cap_chan_check_security\n- 参数: [struct l2cap_chan *chan, bool]\n- 调用者: l2cap_conn_start\n- 被调用者: 未显示\n\n6. 函数名: __l2cap_no_conn_pending\n- 参数: [struct l2cap_chan *chan]\n- 调用者: l2cap_conn_start\n- 被调用者: 未显示\n\n7. 函数名: l2cap_mode_supported\n- 参数: [chan->mode, conn->feat_mask]\n- 调用者: l2cap_conn_start\n- 被调用者: 未显示\n\n8. 函数名: test_bit\n- 参数: [CONF_STATE2_DEVICE, &chan->conf_state], [FLAG_DEFER_SETUP, &chan->flags], [CONF_REQ_SENT, &chan->conf_state]\n- 调用者: l2cap_conn_start\n- 被调用者: 未显示\n\n9. 函数名: l2cap_chan_close\n- 参数: [struct l2cap_chan *chan, ECONNRESET]\n- 调用者: l2cap_conn_start\n- 被调用者: 未显示\n\n10. 函数名: l2cap_start_connection\n- 参数: [struct l2cap_chan *chan]\n- 调用者: l2cap_conn_start\n- 被调用者: 未显示\n\n11. 函数名: l2cap_state_change\n- 参数: [struct l2cap_chan *chan, BT_CONFIG]\n- 调用者: l2cap_conn_start\n- 被调用者: 未显示\n\n12. 函数名: l2cap_send_cmd\n- 参数: [conn, chan->ident, L2CAP_CONN_RSP, sizeof(rsp), &rsp], [conn, l2cap_get_ident(conn), L2CAP_CONF_REQ, l2cap_build_conf_req(chan, buf), buf]\n- 调用者: l2cap_conn_start\n- 被调用者: 未显示\n\n13. 函数名: l2cap_get_ident\n- 参数: [conn]\n- 调用者: l2cap_conn_start\n- 被调用者: 未显示\n\n14. 函数名: l2cap_build_conf_req\n- 参数: [chan, buf]\n- 调用者: l2cap_conn_start\n- 被调用者: 未显示\n\n15. 函数名: mutex_lock\n- 参数: [&conn->chan_lock]\n- 调用者: l2cap_conn_start\n- 被调用者: 未显示\n\n16. 函数名: mutex_unlock\n- 参数: [&conn->chan_lock]\n- 调用者: l2cap_conn_start\n- 被调用者: 未显示"
    },
    {
        "id": 1189,
        "cwe": "CWE-787",
        "cve": "CVE-2017-1000251",
        "purpose": "Code purpose:\"\"\"处理蓝牙L2CAP协议中的配置请求，包括验证请求参数、存储配置数据、发送响应以及管理连接状态。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理L2CAP配置响应时，由于未充分验证输入数据的长度，导致栈缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_config_req\n- 参数: [conn, cmd, cmd_len, data]\n- 调用者: 未显示\n- 被调用者: [__le16_to_cpu, BT_DBG, l2cap_get_chan_by_scid, cmd_reject_invalid_cid, l2cap_send_cmd, l2cap_build_conf_rsp, memcpy, l2cap_parse_conf_req, l2cap_send_disconn_req, set_default_fcs, l2cap_ertm_init, l2cap_chan_ready, test_bit, test_and_set_bit, l2cap_get_ident, l2cap_build_conf_req, l2cap_send_efs_conf_rsp, l2cap_chan_unlock]\n\n2. 函数名: __le16_to_cpu\n- 参数: [req->dcid, req->flags]\n- 调用者: l2cap_config_req\n- 被调用者: 未显示\n\n3. 函数名: BT_DBG\n- 参数: [\"dcid 0x%4.4x flags 0x%2.2x\", dcid, flags]\n- 调用者: l2cap_config_req\n- 被调用者: 未显示\n\n4. 函数名: l2cap_get_chan_by_scid\n- 参数: [conn, dcid]\n- 调用者: l2cap_config_req\n- 被调用者: 未显示\n\n5. 函数名: cmd_reject_invalid_cid\n- 参数: [conn, cmd->ident, dcid, 0], [conn, cmd->ident, chan->scid, chan->dcid]\n- 调用者: l2cap_config_req\n- 被调用者: 未显示\n\n6. 函数名: l2cap_send_cmd\n- 参数: [conn, cmd->ident, L2CAP_CONF_RSP, l2cap_build_conf_rsp(chan, rsp, L2CAP_CONF_REJECT, flags), rsp], [conn, cmd->ident, L2CAP_CONF_RSP, l2cap_build_conf_rsp(chan, rsp, L2CAP_CONF_SUCCESS, flags), rsp], [conn, cmd->ident, L2CAP_CONF_RSP, len, rsp], [conn, l2cap_get_ident(conn), L2CAP_CONF_REQ, l2cap_build_conf_req(chan, buf), buf]\n- 调用者: l2cap_config_req\n- 被调用者: 未显示\n\n7. 函数名: l2cap_build_conf_rsp\n- 参数: [chan, rsp, L2CAP_CONF_REJECT, flags], [chan, rsp, L2CAP_CONF_SUCCESS, flags]\n- 调用者: l2cap_config_req\n- 被调用者: 未显示\n\n8. 函数名: memcpy\n- 参数: [chan->conf_req + chan->conf_len, req->data, len]\n- 调用者: l2cap_config_req\n- 被调用者: 未显示\n\n9. 函数名: l2cap_parse_conf_req\n- 参数: [chan, rsp]\n- 调用者: l2cap_config_req\n- 被调用者: 未显示\n\n10. 函数名: l2cap_send_disconn_req\n- 参数: [chan, ECONNRESET], [chan, -err]\n- 调用者: l2cap_config_req\n- 被调用者: 未显示\n\n11. 函数名: set_default_fcs\n- 参数: [chan]\n- 调用者: l2cap_config_req\n- 被调用者: 未显示\n\n12. 函数名: l2cap_ertm_init\n- 参数: [chan]\n- 调用者: l2cap_config_req\n- 被调用者: 未显示\n\n13. 函数名: l2cap_chan_ready\n- 参数: [chan]\n- 调用者: l2cap_config_req\n- 被调用者: 未显示\n\n14. 函数名: test_bit\n- 参数: [CONF_OUTPUT_DONE, &chan->conf_state], [CONF_INPUT_DONE, &chan->conf_state]\n- 调用者: l2cap_config_req\n- 被调用者: 未显示\n\n15. 函数名: test_and_set_bit\n- 参数: [CONF_REQ_SENT, &chan->conf_state]\n- 调用者: l2cap_config_req\n- 被调用者: 未显示\n\n16. 函数名: l2cap_get_ident\n- 参数: [conn]\n- 调用者: l2cap_config_req\n- 被调用者: 未显示\n\n17. 函数名: l2cap_build_conf_req\n- 参数: [chan, buf]\n- 调用者: l2cap_config_req\n- 被调用者: 未显示\n\n18. 函数名: l2cap_send_efs_conf_rsp\n- 参数: [chan, rsp, cmd->ident, flags]\n- 调用者: l2cap_config_req\n- 被调用者: 未显示\n\n19. 函数名: l2cap_chan_unlock\n- 参数: [chan]\n- 调用者: l2cap_config_req\n- 被调用者: 未显示"
    },
    {
        "id": 1190,
        "cwe": "CWE-787",
        "cve": "CVE-2017-1000251",
        "purpose": "Code purpose:\"\"\"处理L2CAP配置响应，包括解析响应数据、更新通道状态并根据结果执行相应操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理L2CAP配置响应时，由于未充分验证输入数据的长度，导致栈缓冲区溢出漏洞，可能允许远程代码执行。\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_config_rsp\n- 参数: [conn, cmd, cmd_len, data]\n- 调用者: 无（顶层函数）\n- 被调用者: [__le16_to_cpu, BT_DBG, l2cap_get_chan_by_scid, l2cap_conf_rfc_get, clear_bit, set_bit, test_bit, l2cap_parse_conf_rsp, l2cap_send_disconn_req, l2cap_send_efs_conf_rsp, l2cap_check_efs, amp_create_logical_link, l2cap_send_cmd, l2cap_get_ident, l2cap_chan_set_err, __set_chan_timer, set_default_fcs, l2cap_ertm_init, l2cap_chan_ready, l2cap_chan_unlock]\n\n2. 函数名: __le16_to_cpu\n- 参数: [rsp->scid, rsp->flags, rsp->result]\n- 调用者: l2cap_config_rsp\n- 被调用者: 无\n\n3. 函数名: BT_DBG\n- 参数: [\"scid 0x%4.4x flags 0x%2.2x result 0x%2.2x len %d\", scid, flags, result, len]\n- 调用者: l2cap_config_rsp\n- 被调用者: 无\n\n4. 函数名: l2cap_get_chan_by_scid\n- 参数: [conn, scid]\n- 调用者: l2cap_config_rsp\n- 被调用者: 无\n\n5. 函数名: l2cap_conf_rfc_get\n- 参数: [chan, rsp->data, len]\n- 调用者: l2cap_config_rsp\n- 被调用者: 无\n\n6. 函数名: clear_bit\n- 参数: [CONF_REM_CONF_PEND, &chan->conf_state]\n- 调用者: l2cap_config_rsp\n- 被调用者: 无\n\n7. 函数名: set_bit\n- 参数: [CONF_REM_CONF_PEND, &chan->conf_state], [CONF_INPUT_DONE, &chan->conf_state], [CONF_OUTPUT_DONE, &chan->conf_state]\n- 调用者: l2cap_config_rsp\n- 被调用者: 无\n\n8. 函数名: test_bit\n- 参数: [CONF_LOC_CONF_PEND, &chan->conf_state], [CONF_OUTPUT_DONE, &chan->conf_state]\n- 调用者: l2cap_config_rsp\n- 被调用者: 无\n\n9. 函数名: l2cap_parse_conf_rsp\n- 参数: [chan, rsp->data, len, buf, &result], [chan, rsp->data, len, req, &result]\n- 调用者: l2cap_config_rsp\n- 被调用者: 无\n\n10. 函数名: l2cap_send_disconn_req\n- 参数: [chan, ECONNRESET], [chan, -err]\n- 调用者: l2cap_config_rsp\n- 被调用者: 无\n\n11. 函数名: l2cap_send_efs_conf_rsp\n- 参数: [chan, buf, cmd->ident, 0]\n- 调用者: l2cap_config_rsp\n- 被调用者: 无\n\n12. 函数名: l2cap_check_efs\n- 参数: [chan]\n- 调用者: l2cap_config_rsp\n- 被调用者: 无\n\n13. 函数名: amp_create_logical_link\n- 参数: [chan]\n- 调用者: l2cap_config_rsp\n- 被调用者: 无\n\n14. 函数名: l2cap_send_cmd\n- 参数: [conn, l2cap_get_ident(conn), L2CAP_CONF_REQ, len, req]\n- 调用者: l2cap_config_rsp\n- 被调用者: 无\n\n15. 函数名: l2cap_get_ident\n- 参数: [conn]\n- 调用者: l2cap_config_rsp\n- 被调用者: 无\n\n16. 函数名: l2cap_chan_set_err\n- 参数: [chan, ECONNRESET]\n- 调用者: l2cap_config_rsp\n- 被调用者: 无\n\n17. 函数名: __set_chan_timer\n- 参数: [chan, L2CAP_DISC_REJ_TIMEOUT]\n- 调用者: l2cap_config_rsp\n- 被调用者: 无\n\n18. 函数名: set_default_fcs\n- 参数: [chan]\n- 调用者: l2cap_config_rsp\n- 被调用者: 无\n\n19. 函数名: l2cap_ertm_init\n- 参数: [chan]\n- 调用者: l2cap_config_rsp\n- 被调用者: 无\n\n20. 函数名: l2cap_chan_ready\n- 参数: [chan]\n- 调用者: l2cap_config_rsp\n- 被调用者: 无\n\n21. 函数名: l2cap_chan_unlock\n- 参数: [chan]\n- 调用者: l2cap_config_rsp\n- 被调用者: 无"
    },
    {
        "id": 1191,
        "cwe": "CWE-787",
        "cve": "CVE-2017-1000251",
        "purpose": "Code purpose:\"\"\"处理L2CAP通道创建过程中的状态转换和配置响应，包括发送创建请求、连接请求和配置请求等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理L2CAP配置响应时，由于未对输入数据进行充分验证，导致栈缓冲区溢出漏洞，可能允许远程代码在内核空间执行。\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_do_create\n- 参数: [chan, result, local_amp_id, remote_amp_id]\n- 调用者: 未显示\n- 被调用者: [state_to_string, l2cap_send_create_chan_req, l2cap_send_conn_req, __l2cap_no_conn_pending, l2cap_send_cmd, l2cap_state_change, l2cap_get_ident, l2cap_build_conf_req]\n\n2. 函数名: state_to_string\n- 参数: [chan->state]\n- 调用者: l2cap_do_create\n- 被调用者: 未显示\n\n3. 函数名: l2cap_send_create_chan_req\n- 参数: [chan, remote_amp_id]\n- 调用者: l2cap_do_create\n- 被调用者: 未显示\n\n4. 函数名: l2cap_send_conn_req\n- 参数: [chan]\n- 调用者: l2cap_do_create\n- 被调用者: 未显示\n\n5. 函数名: __l2cap_no_conn_pending\n- 参数: [chan]\n- 调用者: l2cap_do_create\n- 被调用者: 未显示\n\n6. 函数名: l2cap_send_cmd\n- 参数: [chan->conn, chan->ident, L2CAP_CREATE_CHAN_RSP, sizeof(rsp), &rsp]\n- 调用者: l2cap_do_create\n- 被调用者: 未显示\n\n7. 函数名: l2cap_state_change\n- 参数: [chan, BT_CONFIG]\n- 调用者: l2cap_do_create\n- 被调用者: 未显示\n\n8. 函数名: l2cap_get_ident\n- 参数: [chan->conn]\n- 调用者: l2cap_do_create\n- 被调用者: 未显示\n\n9. 函数名: l2cap_build_conf_req\n- 参数: [chan, buf]\n- 调用者: l2cap_do_create\n- 被调用者: 未显示"
    },
    {
        "id": 1192,
        "cwe": "CWE-787",
        "cve": "CVE-2017-1000251",
        "purpose": "Code purpose:\"\"\"处理蓝牙L2CAP连接的安全确认和配置响应，包括安全级别设置、连接状态管理和配置请求发送等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核蓝牙栈在处理L2CAP配置响应时存在栈缓冲区溢出漏洞，导致远程代码执行\"\"\"",
        "functions": "Functions:\n1. 函数名: l2cap_security_cfm\n- 参数: [struct hci_conn *hcon, u8 status, u8 encrypt]\n- 调用者: 外部调用\n- 被调用者: [BT_DBG, mutex_lock, list_for_each_entry, l2cap_chan_lock, l2cap_chan_unlock, __l2cap_no_conn_pending, state_to_string, chan->ops->resume, l2cap_check_encryption, l2cap_start_connection, __set_chan_timer, l2cap_state_change, cpu_to_le16, l2cap_send_cmd, test_bit, l2cap_get_ident, l2cap_build_conf_req, mutex_unlock]\n\n2. 函数名: state_to_string\n- 参数: [chan->state]\n- 调用者: l2cap_security_cfm\n- 被调用者: []\n\n3. 函数名: __l2cap_no_conn_pending\n- 参数: [chan]\n- 调用者: l2cap_security_cfm\n- 被调用者: []\n\n4. 函数名: l2cap_chan_lock\n- 参数: [chan]\n- 调用者: l2cap_security_cfm\n- 被调用者: []\n\n5. 函数名: l2cap_chan_unlock\n- 参数: [chan]\n- 调用者: l2cap_security_cfm\n- 被调用者: []\n\n6. 函数名: chan->ops->resume\n- 参数: [chan]\n- 调用者: l2cap_security_cfm\n- 被调用者: []\n\n7. 函数名: l2cap_check_encryption\n- 参数: [chan, encrypt]\n- 调用者: l2cap_security_cfm\n- 被调用者: []\n\n8. 函数名: l2cap_start_connection\n- 参数: [chan]\n- 调用者: l2cap_security_cfm\n- 被调用者: []\n\n9. 函数名: __set_chan_timer\n- 参数: [chan, L2CAP_DISC_TIMEOUT]\n- 调用者: l2cap_security_cfm\n- 被调用者: []\n\n10. 函数名: l2cap_state_change\n- 参数: [chan, BT_CONFIG/BT_DISCONN]\n- 调用者: l2cap_security_cfm\n- 被调用者: []\n\n11. 函数名: cpu_to_le16\n- 参数: [chan->dcid/chan->scid/res/stat]\n- 调用者: l2cap_security_cfm\n- 被调用者: []\n\n12. 函数名: l2cap_send_cmd\n- 参数: [conn, chan->ident/l2cap_get_ident(conn), L2CAP_CONN_RSP/L2CAP_CONF_REQ, sizeof(rsp)/l2cap_build_conf_req(chan, buf), &rsp/buf]\n- 调用者: l2cap_security_cfm\n- 被调用者: []\n\n13. 函数名: test_bit\n- 参数: [FLAG_DEFER_SETUP/CONF_REQ_SENT, &chan->flags/&chan->conf_state]\n- 调用者: l2cap_security_cfm\n- 被调用者: []\n\n14. 函数名: chan->ops->defer\n- 参数: [chan]\n- 调用者: l2cap_security_cfm\n- 被调用者: []\n\n15. 函数名: l2cap_get_ident\n- 参数: [conn]\n- 调用者: l2cap_security_cfm\n- 被调用者: []\n\n16. 函数名: l2cap_build_conf_req\n- 参数: [chan, buf]\n- 调用者: l2cap_security_cfm\n- 被调用者: []\n\n17. 函数名: mutex_lock\n- 参数: [&conn->chan_lock]\n- 调用者: l2cap_security_cfm\n- 被调用者: []\n\n18. 函数名: mutex_unlock\n- 参数: [&conn->chan_lock]\n- 调用者: l2cap_security_cfm\n- 被调用者: []"
    },
    {
        "id": 1195,
        "cwe": "CWE-787",
        "cve": "CVE-2017-1000363",
        "purpose": "Code purpose:\"\"\"该代码用于初始化并配置Linux并行端口(lp)驱动程序的参数，包括禁用驱动、设置端口号、自动检测端口、不设置端口或重置驱动等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺少对parport_ptr的边界检查且该变量为静态变量，攻击者可通过添加大量'lp=none'参数导致parport_nr数组越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: lp_setup\n- 参数: [char *str]\n- 调用者: 未明确显示（通常由内核模块初始化代码调用）\n- 被调用者: [get_option, strncmp, simple_strtoul, strcmp, printk]\n\n2. 函数名: get_option\n- 参数: [char **str, int *x]\n- 调用者: lp_setup\n- 被调用者: 未显示\n\n3. 函数名: strncmp\n- 参数: [const char *str1, const char *str2, size_t n]\n- 调用者: lp_setup\n- 被调用者: 未显示\n\n4. 函数名: simple_strtoul\n- 参数: [const char *str, char **endptr, int base]\n- 调用者: lp_setup\n- 被调用者: 未显示\n\n5. 函数名: strcmp\n- 参数: [const char *str1, const char *str2]\n- 调用者: lp_setup\n- 被调用者: 未显示\n\n6. 函数名: printk\n- 参数: [const char *fmt, ...]\n- 调用者: lp_setup\n- 被调用者: 未显示"
    },
    {
        "id": 1266,
        "cwe": "CWE-787",
        "cve": "CVE-2017-13166",
        "purpose": "Code purpose:\"\"\"该代码用于处理视频4Linux2(V4L2)驱动中的格式尝试操作，验证并执行不同类型视频缓冲区的格式设置请求。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核v4l2视频驱动在处理视频格式时未充分验证用户空间传入的参数，导致存在越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: v4l_try_fmt\n- 参数: [const struct v4l2_ioctl_ops *ops, struct file *file, void *fh, void *arg]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [v4l_sanitize_format, ops->vidioc_try_fmt_vid_cap, ops->vidioc_try_fmt_vid_cap_mplane, ops->vidioc_try_fmt_vid_overlay, ops->vidioc_try_fmt_vbi_cap, ops->vidioc_try_fmt_sliced_vbi_cap, ops->vidioc_try_fmt_vid_out, ops->vidioc_try_fmt_vid_out_mplane, ops->vidioc_try_fmt_vid_out_overlay, ops->vidioc_try_fmt_vbi_out, ops->vidioc_try_fmt_sliced_vbi_out, ops->vidioc_try_fmt_sdr_cap, ops->vidioc_try_fmt_sdr_out, ops->vidioc_try_fmt_meta_cap]\n\n2. 函数名: v4l_sanitize_format\n- 参数: [struct v4l2_format *p]\n- 调用者: v4l_try_fmt\n- 被调用者: 未显示\n\n3. 函数名: video_devdata\n- 参数: [struct file *file]\n- 调用者: v4l_try_fmt\n- 被调用者: 未显示\n\n4. 函数名: CLEAR_AFTER_FIELD\n- 参数: [struct v4l2_format *p, field_name]\n- 调用者: v4l_try_fmt\n- 被调用者: 未显示\n\n注意：ops结构体中的各个vidioc_try_fmt_*函数指针也被视为被调用者，但由于它们是动态绑定的，具体实现取决于运行时情况。"
    },
    {
        "id": 1267,
        "cwe": "CWE-787",
        "cve": "CVE-2017-13166",
        "purpose": "Code purpose:\"\"\"该代码用于处理视频设备驱动中不同缓冲区类型的格式枚举请求，并根据设备类型和方向调用相应的操作函数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核v4l2视频驱动在处理视频格式枚举时未充分验证用户空间传入的参数，导致权限提升漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: v4l_enum_fmt\n- 参数: [const struct v4l2_ioctl_ops *ops, struct file *file, void *fh, void *arg]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [ops->vidioc_enum_fmt_vid_cap, ops->vidioc_enum_fmt_vid_cap_mplane, ops->vidioc_enum_fmt_vid_overlay, ops->vidioc_enum_fmt_vid_out, ops->vidioc_enum_fmt_vid_out_mplane, ops->vidioc_enum_fmt_sdr_cap, ops->vidioc_enum_fmt_sdr_out, ops->vidioc_enum_fmt_meta_cap, v4l_fill_fmtdesc]\n\n2. 函数名: video_devdata\n- 参数: [struct file *file]\n- 调用者: v4l_enum_fmt\n- 被调用者: 未显示（假设是外部函数）\n\n3. 函数名: v4l_fill_fmtdesc\n- 参数: [struct v4l2_fmtdesc *p]\n- 调用者: v4l_enum_fmt\n- 被调用者: 未显示（假设是外部函数）"
    },
    {
        "id": 1268,
        "cwe": "CWE-787",
        "cve": "CVE-2017-13166",
        "purpose": "Code purpose:\"\"\"处理视频设备的格式设置请求，验证设备类型和操作权限后调用相应的驱动操作函数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核v4l2视频驱动在处理视频格式设置时未充分验证用户提供的参数，导致存在权限提升漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: v4l_s_fmt\n- 参数: [const struct v4l2_ioctl_ops *ops, struct file *file, void *fh, void *arg]\n- 调用者: 未明确显示（应为v4l2 ioctl处理流程）\n- 被调用者: [v4l_enable_media_source, v4l_sanitize_format, ops->vidioc_s_fmt_vid_cap, v4l_pix_format_touch, ops->vidioc_s_fmt_vid_cap_mplane, ops->vidioc_s_fmt_vid_overlay, ops->vidioc_s_fmt_vbi_cap, ops->vidioc_s_fmt_sliced_vbi_cap, ops->vidioc_s_fmt_vid_out, ops->vidioc_s_fmt_vid_out_mplane, ops->vidioc_s_fmt_vid_out_overlay, ops->vidioc_s_fmt_vbi_out, ops->vidioc_s_fmt_sliced_vbi_out, ops->vidioc_s_fmt_sdr_cap, ops->vidioc_s_fmt_sdr_out, ops->vidioc_s_fmt_meta_cap]\n\n2. 函数名: v4l_enable_media_source\n- 参数: [struct video_device *vfd]\n- 调用者: v4l_s_fmt\n- 被调用者: 未显示\n\n3. 函数名: v4l_sanitize_format\n- 参数: [struct v4l2_format *p]\n- 调用者: v4l_s_fmt\n- 被调用者: 未显示\n\n4. 函数名: v4l_pix_format_touch\n- 参数: [struct v4l2_pix_format *pix]\n- 调用者: v4l_s_fmt\n- 被调用者: 未显示\n\n5. 函数名: CLEAR_AFTER_FIELD\n- 参数: [struct v4l2_format *p, field_name]\n- 调用者: v4l_s_fmt\n- 被调用者: 未显示\n\n6. 函数名: video_devdata\n- 参数: [struct file *file]\n- 调用者: v4l_s_fmt\n- 被调用者: 未显示\n\n注：ops结构体中的vidioc_*系列函数作为函数指针被调用，未在代码中显示具体实现。"
    },
    {
        "id": 1269,
        "cwe": "CWE-787",
        "cve": "CVE-2017-13166",
        "purpose": "Code purpose:\"\"\"处理视频设备的格式获取请求，根据不同类型进行相应的格式初始化和操作调用\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核v4l2视频驱动在处理VIDEO_OVERLAY和VIDEO_OUTPUT_OVERLAY类型时未正确验证用户提供的clipcount值，导致可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: v4l_g_fmt\n- 参数: [const struct v4l2_ioctl_ops *ops, struct file *file, void *fh, void *arg]\n- 调用者: 未明确显示（应为内核v4l2视频驱动相关调用）\n- 被调用者: [video_devdata, memset, ops->vidioc_g_fmt_vid_cap, ops->vidioc_g_fmt_vid_cap_mplane, ops->vidioc_g_fmt_vid_overlay, ops->vidioc_g_fmt_vbi_cap, ops->vidioc_g_fmt_sliced_vbi_cap, ops->vidioc_g_fmt_vid_out, ops->vidioc_g_fmt_vid_out_mplane, ops->vidioc_g_fmt_vid_out_overlay, ops->vidioc_g_fmt_vbi_out, ops->vidioc_g_fmt_sliced_vbi_out, ops->vidioc_g_fmt_sdr_cap, ops->vidioc_g_fmt_sdr_out, ops->vidioc_g_fmt_meta_cap]\n\n2. 函数名: video_devdata\n- 参数: [struct file *file]\n- 调用者: v4l_g_fmt\n- 被调用者: 未显示（应为内核视频子系统函数）\n\n3. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: v4l_g_fmt\n- 被调用者: 标准库函数\n\n4. 函数名: ops->vidioc_g_fmt_vid_cap\n- 参数: [struct file *file, void *fh, void *arg]\n- 调用者: v4l_g_fmt\n- 被调用者: 未显示（驱动特定实现）\n\n5. 函数名: ops->vidioc_g_fmt_vid_cap_mplane\n- 参数: [struct file *file, void *fh, void *arg]\n- 调用者: v4l_g_fmt\n- 被调用者: 未显示\n\n6. 函数名: ops->vidioc_g_fmt_vid_overlay\n- 参数: [struct file *file, void *fh, void *arg]\n- 调用者: v4l_g_fmt\n- 被调用者: 未显示\n\n7. 函数名: ops->vidioc_g_fmt_vbi_cap\n- 参数: [struct file *file, void *fh, void *arg]\n- 调用者: v4l_g_fmt\n- 被调用者: 未显示\n\n8. 函数名: ops->vidioc_g_fmt_sliced_vbi_cap\n- 参数: [struct file *file, void *fh, void *arg]\n- 调用者: v4l_g_fmt\n- 被调用者: 未显示\n\n9. 函数名: ops->vidioc_g_fmt_vid_out\n- 参数: [struct file *file, void *fh, void *arg]\n- 调用者: v4l_g_fmt\n- 被调用者: 未显示\n\n10. 函数名: ops->vidioc_g_fmt_vid_out_mplane\n- 参数: [struct file *file, void *fh, void *arg]\n- 调用者: v4l_g_fmt\n- 被调用者: 未显示\n\n11. 函数名: ops->vidioc_g_fmt_vid_out_overlay\n- 参数: [struct file *file, void *fh, void *arg]\n- 调用者: v4l_g_fmt\n- 被调用者: 未显示\n\n12. 函数名: ops->vidioc_g_fmt_vbi_out\n- 参数: [struct file *file, void *fh, void *arg]\n- 调用者: v4l_g_fmt\n- 被调用者: 未显示\n\n13. 函数名: ops->vidioc_g_fmt_sliced_vbi_out\n- 参数: [struct file *file, void *fh, void *arg]\n- 调用者: v4l_g_fmt\n- 被调用者: 未显示\n\n14. 函数名: ops->vidioc_g_fmt_sdr_cap\n- 参数: [struct file *file, void *fh, void *arg]\n- 调用者: v4l_g_fmt\n- 被调用者: 未显示\n\n15. 函数名: ops->vidioc_g_fmt_sdr_out\n- 参数: [struct file *file, void *fh, void *arg]\n- 调用者: v4l_g_fmt\n- 被调用者: 未显示\n\n16. 函数名: ops->vidioc_g_fmt_meta_cap\n- 参数: [struct file *file, void *fh, void *arg]\n- 调用者: v4l_g_fmt\n- 被调用者: 未显示"
    },
    {
        "id": 1274,
        "cwe": "CWE-787",
        "cve": "CVE-2017-13216",
        "purpose": "Code purpose:\"\"\"该代码实现了Android共享内存(ashmem)的ioctl接口，用于处理设置名称、大小、保护掩码以及内存区域管理等功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在访问asma时缺乏足够的锁保护，导致存在越界写入的风险\"\"\"",
        "functions": "Functions:\n1. 函数名: ashmem_ioctl\n- 参数: [struct file *file, unsigned int cmd, unsigned long arg]\n- 调用者: 未指定（由内核IOCTL机制调用）\n- 被调用者: [set_name, get_name, ashmem_pin_unpin, ashmem_shrink_count, ashmem_shrink_scan]\n\n2. 函数名: set_name\n- 参数: [struct ashmem_area *asma, void __user *arg]\n- 调用者: ashmem_ioctl\n- 被调用者: []\n\n3. 函数名: get_name\n- 参数: [struct ashmem_area *asma, void __user *arg]\n- 调用者: ashmem_ioctl\n- 被调用者: []\n\n4. 函数名: set_prot_mask\n- 参数: [struct ashmem_area *asma, unsigned long arg]\n- 调用者: ashmem_ioctl\n- 被调用者: []\n\n5. 函数名: ashmem_pin_unpin\n- 参数: [struct ashmem_area *asma, unsigned int cmd, void __user *arg]\n- 调用者: ashmem_ioctl\n- 被调用者: []\n\n6. 函数名: ashmem_shrink_count\n- 参数: [struct shrinker *shrinker, struct shrink_control *sc]\n- 调用者: ashmem_ioctl\n- 被调用者: []\n\n7. 函数名: ashmem_shrink_scan\n- 参数: [struct shrinker *shrinker, struct shrink_control *sc]\n- 调用者: ashmem_ioctl\n- 被调用者: []"
    },
    {
        "id": 1365,
        "cwe": "CWE-787",
        "cve": "CVE-2017-17558",
        "purpose": "Code purpose:\"\"\"解析USB设备的配置描述符，验证其有效性并分配相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码在处理USB配置描述符时未充分验证配置和接口数量的上限，导致可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: usb_parse_configuration\n- 参数: [struct usb_device *dev, int cfgidx, struct usb_host_config *config, unsigned char *buffer, int size]\n- 调用者: N/A (顶层函数)\n- 被调用者: [memcpy, dev_err, dev_warn, cpu_to_le16, kzalloc, kref_init, find_next_descriptor, usb_parse_interface]\n\n2. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: usb_parse_configuration\n- 被调用者: N/A\n\n3. 函数名: dev_err\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: usb_parse_configuration\n- 被调用者: N/A\n\n4. 函数名: dev_warn\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: usb_parse_configuration\n- 被调用者: N/A\n\n5. 函数名: cpu_to_le16\n- 参数: [u16 val]\n- 调用者: usb_parse_configuration\n- 被调用者: N/A\n\n6. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: usb_parse_configuration\n- 被调用者: N/A\n\n7. 函数名: kref_init\n- 参数: [struct kref *kref]\n- 调用者: usb_parse_configuration\n- 被调用者: N/A\n\n8. 函数名: find_next_descriptor\n- 参数: [unsigned char *buffer, int size, u8 desc_type, u8 desc_type_mask, int *num_skipped]\n- 调用者: usb_parse_configuration\n- 被调用者: N/A\n\n9. 函数名: usb_parse_interface\n- 参数: [struct device *ddev, int cfgno, struct usb_host_config *config, unsigned char *buffer, int size, u8 *inums, u8 *nalts]\n- 调用者: usb_parse_configuration\n- 被调用者: N/A\n\n10. 函数名: plural\n- 参数: [int n]\n- 调用者: usb_parse_configuration\n- 被调用者: N/A"
    },
    {
        "id": 1375,
        "cwe": "CWE-787",
        "cve": "CVE-2017-17806",
        "purpose": "Code purpose:\"\"\"实现HMAC加密算法的创建和注册功能，包括对底层哈希算法的属性检查和初始化。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"HMAC实现未验证底层哈希算法是否无密钥，导致攻击者可通过特制的系统调用序列触发SHA-3初始化缺失，造成内核栈缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: hmac_create\n- 参数: [struct crypto_template *tmpl, struct rtattr **tb]\n- 调用者: N/A (顶层函数)\n- 被调用者: [crypto_check_attr_type, shash_attr_alg, PTR_ERR, IS_ERR, shash_alloc_instance, crypto_init_shash_spawn, shash_instance_ctx, shash_crypto_instance, ALIGN, crypto_tfm_ctx_alignment, shash_register_instance, shash_free_instance, crypto_mod_put]\n\n2. 函数名: crypto_check_attr_type\n- 参数: [struct rtattr **tb, int type]\n- 调用者: hmac_create\n- 被调用者: N/A\n\n3. 函数名: shash_attr_alg\n- 参数: [struct rtattr *rta, int type, int mask]\n- 调用者: hmac_create\n- 被调用者: N/A\n\n4. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: hmac_create\n- 被调用者: N/A\n\n5. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: hmac_create\n- 被调用者: N/A\n\n6. 函数名: shash_alloc_instance\n- 参数: [const char *name, struct crypto_alg *alg]\n- 调用者: hmac_create\n- 被调用者: N/A\n\n7. 函数名: crypto_init_shash_spawn\n- 参数: [struct crypto_shash_spawn *spawn, struct shash_alg *alg, struct crypto_instance *inst]\n- 调用者: hmac_create\n- 被调用者: N/A\n\n8. 函数名: shash_instance_ctx\n- 参数: [struct shash_instance *inst]\n- 调用者: hmac_create\n- 被调用者: N/A\n\n9. 函数名: shash_crypto_instance\n- 参数: [struct shash_instance *inst]\n- 调用者: hmac_create\n- 被调用者: N/A\n\n10. 函数名: ALIGN\n- 参数: [int x, int a]\n- 调用者: hmac_create\n- 被调用者: N/A\n\n11. 函数名: crypto_tfm_ctx_alignment\n- 参数: []\n- 调用者: hmac_create\n- 被调用者: N/A\n\n12. 函数名: shash_register_instance\n- 参数: [struct crypto_template *tmpl, struct shash_instance *inst]\n- 调用者: hmac_create\n- 被调用者: N/A\n\n13. 函数名: shash_free_instance\n- 参数: [struct crypto_instance *inst]\n- 调用者: hmac_create\n- 被调用者: N/A\n\n14. 函数名: crypto_mod_put\n- 参数: [struct crypto_alg *alg]\n- 调用者: hmac_create\n- 被调用者: N/A"
    },
    {
        "id": 1376,
        "cwe": "CWE-787",
        "cve": "CVE-2017-17806",
        "purpose": "Code purpose:\"\"\"该代码片段实现了一个不执行任何操作的哈希算法密钥设置函数，总是返回不支持操作的错误。\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"HMAC实现未验证底层哈希算法是否无需密钥，导致攻击者可通过特制的系统调用序列触发SHA-3初始化缺失，造成内核栈缓冲区溢出。\"\"\"",
        "functions": "Functions:\n1. 函数名: shash_no_setkey\n- 参数: [struct crypto_shash *tfm, const u8 *key, unsigned int keylen]\n- 调用者: 未提供（上下文不足）\n- 被调用者: []"
    },
    {
        "id": 1439,
        "cwe": "CWE-787",
        "cve": "CVE-2017-18551",
        "purpose": "Code purpose:\"\"\"该代码实现了I2C SMBus协议的模拟传输功能，处理不同大小的数据传输请求，包括读写操作和各种数据格式的处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在I2C_SMBUS_BLOCK_DATA和I2C_SMBUS_BLOCK_PROC_CALL情况下，未正确验证输入数据长度，导致缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: i2c_smbus_xfer_emulated\n- 参数: [struct i2c_adapter *adapter, u16 addr, unsigned short flags, char read_write, u8 command, int size, union i2c_smbus_data *data]\n- 调用者: 未明确显示（通常是I2C核心或SMBus相关调用）\n- 被调用者: [dev_err, i2c_smbus_add_pec, i2c_smbus_msg_pec, i2c_transfer, i2c_smbus_check_pec]\n\n2. 函数名: dev_err\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: i2c_smbus_xfer_emulated\n- 被调用者: []\n\n3. 函数名: i2c_smbus_add_pec\n- 参数: [struct i2c_msg *msg]\n- 调用者: i2c_smbus_xfer_emulated\n- 被调用者: []\n\n4. 函数名: i2c_smbus_msg_pec\n- 参数: [u8 pec, struct i2c_msg *msg]\n- 调用者: i2c_smbus_xfer_emulated\n- 被调用者: []\n\n5. 函数名: i2c_transfer\n- 参数: [struct i2c_adapter *adap, struct i2c_msg *msgs, int num]\n- 调用者: i2c_smbus_xfer_emulated\n- 被调用者: []\n\n6. 函数名: i2c_smbus_check_pec\n- 参数: [u8 pec, struct i2c_msg *msg]\n- 调用者: i2c_smbus_xfer_emulated\n- 被调用者: []"
    },
    {
        "id": 1440,
        "cwe": "CWE-787",
        "cve": "CVE-2017-18552",
        "purpose": "Code purpose:\"\"\"该代码用于从用户空间接收并处理RDS套接字的接收延迟跟踪数据，将跟踪位置信息存储到内核空间的结构体中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证用户输入的rx_traces值，导致数组越界读写漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: rds_recv_track_latency\n- 参数: [struct rds_sock *rs, char __user *optval, int optlen]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [copy_from_user]"
    },
    {
        "id": 1495,
        "cwe": "CWE-787",
        "cve": "CVE-2017-7294",
        "purpose": "Code purpose:\"\"\"处理用户空间通过ioctl请求创建3D表面的操作，包括验证参数、分配内存、初始化表面数据结构等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未对用户输入的mip_levels数组元素进行充分验证，导致整数溢出和越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_surface_define_ioctl\n- 参数: [struct drm_device *dev, void *data, struct drm_file *file_priv]\n- 调用者: 外部ioctl调用\n- 被调用者: [vmw_priv, ttm_round_pot, svga3dsurface_get_desc, ttm_read_lock, ttm_mem_global_alloc, kzalloc, memcpy, memdup_user, kmalloc_array, svga3dsurface_calculate_pitch, svga3dsurface_get_image_buffer_size, kzalloc, drm_is_primary_client, drm_master_get, vmw_surface_init, vmw_user_dmabuf_alloc, vmw_resource_reference, ttm_prime_object_init, vmw_resource_unreference, ttm_read_unlock, kfree, ttm_mem_global_free, ttm_prime_object_kfree]\n\n2. 函数名: vmw_priv\n- 参数: [struct drm_device *dev]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n3. 函数名: ttm_round_pot\n- 参数: [size_t size]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n4. 函数名: svga3dsurface_get_desc\n- 参数: [uint32 format]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n5. 函数名: ttm_read_lock\n- 参数: [struct ww_mutex *lock, bool interruptible]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n6. 函数名: ttm_mem_global_alloc\n- 参数: [struct ttm_mem_global *glob, size_t size, bool no_wait, bool interruptible]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n7. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n8. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n9. 函数名: memdup_user\n- 参数: [void __user *src, size_t len]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n10. 函数名: kmalloc_array\n- 参数: [size_t n, size_t size, gfp_t flags]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n11. 函数名: svga3dsurface_calculate_pitch\n- 参数: [const struct svga3d_surface_desc *desc, struct drm_vmw_size *size]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n12. 函数名: svga3dsurface_get_image_buffer_size\n- 参数: [const struct svga3d_surface_desc *desc, struct drm_vmw_size *size, uint32_t pitch]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n13. 函数名: drm_is_primary_client\n- 参数: [struct drm_file *file_priv]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n14. 函数名: drm_master_get\n- 参数: [struct drm_master *master]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n15. 函数名: vmw_surface_init\n- 参数: [struct vmw_private *dev_priv, struct vmw_surface *srf, void (*free)(struct vmw_resource *)]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n16. 函数名: vmw_user_dmabuf_alloc\n- 参数: [struct vmw_private *dev_priv, struct ttm_object_file *tfile, uint32_t size, bool shareable, uint32_t *handle, struct vmw_dma_buffer **buf, struct ttm_base_object **p_base]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n17. 函数名: vmw_resource_reference\n- 参数: [struct vmw_resource **res]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n18. 函数名: ttm_prime_object_init\n- 参数: [struct ttm_object_file *tfile, size_t size, struct ttm_prime_object *prime, bool shareable, enum ttm_object_type type, void (*refcount_release)(struct ttm_base_object **), void (*ref_obj_release)(struct ttm_base_object *, enum ttm_ref_type)]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n19. 函数名: vmw_resource_unreference\n- 参数: [struct vmw_resource **res]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n20. 函数名: ttm_read_unlock\n- 参数: [struct ww_mutex *lock]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n21. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n22. 函数名: ttm_mem_global_free\n- 参数: [struct ttm_mem_global *glob, size_t amount]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []\n\n23. 函数名: ttm_prime_object_kfree\n- 参数: [struct ttm_prime_object *prime, void *p]\n- 调用者: vmw_surface_define_ioctl\n- 被调用者: []"
    },
    {
        "id": 1496,
        "cwe": "CWE-787",
        "cve": "CVE-2017-7308",
        "purpose": "Code purpose:\"\"\"该代码用于设置和管理Linux内核中AF_PACKET套接字的环形缓冲区，处理数据包的接收和发送环形缓冲区的配置和操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未正确验证用户提供的块大小数据，导致整数符号错误和越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: packet_set_ring\n- 参数: [struct sock *sk, union tpacket_req_u *req_u, int closing, int tx_ring]\n- 调用者: 未显示\n- 被调用者: [lock_sock, pkt_sk, atomic_read, packet_read_pending, PAGE_ALIGNED, get_order, alloc_pg_vec, init_prb_bdqc, __unregister_prot_hook, synchronize_net, mutex_lock, spin_lock_bh, swap, skb_queue_purge, register_prot_hook, prb_shutdown_retire_blk_timer, free_pg_vec, release_sock]\n\n2. 函数名: lock_sock\n- 参数: [struct sock *sk]\n- 调用者: packet_set_ring\n- 被调用者: 未显示\n\n3. 函数名: pkt_sk\n- 参数: [struct sock *sk]\n- 调用者: packet_set_ring\n- 被调用者: 未显示\n\n4. 函数名: atomic_read\n- 参数: [atomic_t *v]\n- 调用者: packet_set_ring\n- 被调用者: 未显示\n\n5. 函数名: packet_read_pending\n- 参数: [struct packet_ring_buffer *rb]\n- 调用者: packet_set_ring\n- 被调用者: 未显示\n\n6. 函数名: PAGE_ALIGNED\n- 参数: [unsigned long addr]\n- 调用者: packet_set_ring\n- 被调用者: 未显示\n\n7. 函数名: get_order\n- 参数: [unsigned long size]\n- 调用者: packet_set_ring\n- 被调用者: 未显示\n\n8. 函数名: alloc_pg_vec\n- 参数: [struct tpacket_req *req, int order]\n- 调用者: packet_set_ring\n- 被调用者: 未显示\n\n9. 函数名: init_prb_bdqc\n- 参数: [struct packet_sock *po, struct packet_ring_buffer *rb, struct pgv *pg_vec, union tpacket_req_u *req_u]\n- 调用者: packet_set_ring\n- 被调用者: 未显示\n\n10. 函数名: __unregister_prot_hook\n- 参数: [struct sock *sk, bool sync]\n- 调用者: packet_set_ring\n- 被调用者: 未显示\n\n11. 函数名: synchronize_net\n- 参数: []\n- 调用者: packet_set_ring\n- 被调用者: 未显示\n\n12. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: packet_set_ring\n- 被调用者: 未显示\n\n13. 函数名: spin_lock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: packet_set_ring\n- 被调用者: 未显示\n\n14. 函数名: swap\n- 参数: [type *a, type *b]\n- 调用者: packet_set_ring\n- 被调用者: 未显示\n\n15. 函数名: skb_queue_purge\n- 参数: [struct sk_buff_head *list]\n- 调用者: packet_set_ring\n- 被调用者: 未显示\n\n16. 函数名: register_prot_hook\n- 参数: [struct sock *sk]\n- 调用者: packet_set_ring\n- 被调用者: 未显示\n\n17. 函数名: prb_shutdown_retire_blk_timer\n- 参数: [struct packet_sock *po, struct sk_buff_head *rb_queue]\n- 调用者: packet_set_ring\n- 被调用者: 未显示\n\n18. 函数名: free_pg_vec\n- 参数: [struct pgv *pg_vec, int order, int len]\n- 调用者: packet_set_ring\n- 被调用者: 未显示\n\n19. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: packet_set_ring\n- 被调用者: 未显示"
    },
    {
        "id": 1541,
        "cwe": "CWE-787",
        "cve": "CVE-2017-8067",
        "purpose": "Code purpose:\"\"\"将指定数量的字符通过虚拟终端端口发送到目标端口\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当启用CONFIG_VMAP_STACK选项时，代码错误地将可能跨多个虚拟页的栈缓冲区直接用于DMA操作，导致系统崩溃或内存损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: put_chars\n- 参数: [u32 vtermno, const char *buf, int count]\n- 调用者: 未指定\n- 被调用者: [early_put_chars, find_port_by_vtermno, sg_init_one, __send_to_port]\n\n2. 函数名: early_put_chars\n- 参数: [u32 vtermno, const char *buf, int count]\n- 调用者: put_chars\n- 被调用者: 未指定\n\n3. 函数名: find_port_by_vtermno\n- 参数: [u32 vtermno]\n- 调用者: put_chars\n- 被调用者: 未指定\n\n4. 函数名: sg_init_one\n- 参数: [struct scatterlist *sg, const char *buf, int count]\n- 调用者: put_chars\n- 被调用者: 未指定\n\n5. 函数名: __send_to_port\n- 参数: [struct port *port, struct scatterlist *sg, int sg_count, int count, void *data, bool false]\n- 调用者: put_chars\n- 被调用者: 未指定"
    },
    {
        "id": 1594,
        "cwe": "CWE-787",
        "cve": "CVE-2018-1068",
        "purpose": "Code purpose:\"\"\"该代码用于处理ebtables规则中entry结构体的匹配、观察和目标部分的大小计算及内存缓冲区管理，实现32位系统调用接口的兼容性处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在32位系统调用接口的桥接实现中，由于对偏移量的边界检查不足，导致特权用户可以通过精心构造的输入数据向有限的内核内存范围进行任意写入。\"\"\"",
        "functions": "Functions:\n1. 函数名: size_entry_mwt\n- 参数: [struct ebt_entry *entry, const unsigned char *base, unsigned int *total, struct ebt_entries_buf_state *state]\n- 调用者: 未显示\n- 被调用者: [ebt_buf_add, ebt_size_mwt, xt_compat_add_offset]\n\n2. 函数名: ebt_buf_add\n- 参数: [struct ebt_entries_buf_state *state, void *data, unsigned int size]\n- 调用者: size_entry_mwt\n- 被调用者: 未显示\n\n3. 函数名: ebt_size_mwt\n- 参数: [struct compat_ebt_entry_mwt *match32, unsigned int size, int i, struct ebt_entries_buf_state *state, const unsigned char *base]\n- 调用者: size_entry_mwt\n- 被调用者: 未显示\n\n4. 函数名: xt_compat_add_offset\n- 参数: [NFPROTO_BRIDGE, unsigned int offset, unsigned int new_offset]\n- 调用者: size_entry_mwt\n- 被调用者: 未显示"
    },
    {
        "id": 1595,
        "cwe": "CWE-787",
        "cve": "CVE-2018-1068",
        "purpose": "Code purpose:\"\"\"该代码用于处理32位系统调用接口中的ebtables匹配规则转换，将用户空间的匹配规则数据复制到内核空间并计算所需的内存增长量。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核在处理32位系统调用接口的桥接功能时，未能正确验证用户提供的match32->match_size大小，导致越界写入内核内存。\"\"\"",
        "functions": "Functions:\n1. 函数名: ebt_size_mwt\n- 参数: [struct compat_ebt_entry_mwt *match32, unsigned int size_left, enum compat_mwt type, struct ebt_entries_buf_state *state, const void *base]\n- 调用者: 未明确（由内核调用）\n- 被调用者: [ebt_buf_add, ebt_buf_add_pad, compat_mtw_from_user]\n\n2. 函数名: ebt_buf_add\n- 参数: [struct ebt_entries_buf_state *state, char *buf, sizeof(*match32)]\n- 调用者: ebt_size_mwt\n- 被调用者: 未明确\n\n3. 函数名: ebt_buf_add_pad\n- 参数: [struct ebt_entries_buf_state *state, ebt_compat_entry_padsize()]\n- 调用者: ebt_size_mwt\n- 被调用者: 未明确\n\n4. 函数名: compat_mtw_from_user\n- 参数: [match32, type, state, base]\n- 调用者: ebt_size_mwt\n- 被调用者: 未明确\n\n5. 函数名: ebt_compat_entry_padsize\n- 参数: []\n- 调用者: ebt_size_mwt\n- 被调用者: 未明确"
    },
    {
        "id": 1611,
        "cwe": "CWE-787",
        "cve": "CVE-2018-10878",
        "purpose": "Code purpose:\"\"\"初始化ext4文件系统的块位图，设置块组中各种元数据结构的位图标记\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4文件系统的块位图初始化函数中，未正确验证输入参数导致可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_init_block_bitmap\n- 参数: [struct super_block *sb, struct buffer_head *bh, ext4_group_t block_group, struct ext4_group_desc *gdp]\n- 调用者: N/A (顶层函数)\n- 被调用者: [J_ASSERT_BH, ext4_group_desc_csum_verify, ext4_mark_group_bitmap_corrupted, memset, ext4_num_base_meta_clusters, ext4_set_bit, ext4_group_first_block_no, ext4_has_feature_flex_bg, ext4_block_bitmap, ext4_block_in_group, ext4_inode_bitmap, ext4_inode_table, num_clusters_in_group, ext4_mark_bitmap_end]\n\n2. 函数名: J_ASSERT_BH\n- 参数: [struct buffer_head *bh, int condition]\n- 调用者: ext4_init_block_bitmap\n- 被调用者: []\n\n3. 函数名: ext4_group_desc_csum_verify\n- 参数: [struct super_block *sb, ext4_group_t block_group, struct ext4_group_desc *gdp]\n- 调用者: ext4_init_block_bitmap\n- 被调用者: []\n\n4. 函数名: ext4_mark_group_bitmap_corrupted\n- 参数: [struct super_block *sb, ext4_group_t block_group, int flags]\n- 调用者: ext4_init_block_bitmap\n- 被调用者: []\n\n5. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: ext4_init_block_bitmap\n- 被调用者: []\n\n6. 函数名: ext4_num_base_meta_clusters\n- 参数: [struct super_block *sb, ext4_group_t block_group]\n- 调用者: ext4_init_block_bitmap\n- 被调用者: []\n\n7. 函数名: ext4_set_bit\n- 参数: [int nr, void *addr]\n- 调用者: ext4_init_block_bitmap\n- 被调用者: []\n\n8. 函数名: ext4_group_first_block_no\n- 参数: [struct super_block *sb, ext4_group_t block_group]\n- 调用者: ext4_init_block_bitmap\n- 被调用者: []\n\n9. 函数名: ext4_has_feature_flex_bg\n- 参数: [struct super_block *sb]\n- 调用者: ext4_init_block_bitmap\n- 被调用者: []\n\n10. 函数名: ext4_block_bitmap\n- 参数: [struct super_block *sb, struct ext4_group_desc *gdp]\n- 调用者: ext4_init_block_bitmap\n- 被调用者: []\n\n11. 函数名: ext4_block_in_group\n- 参数: [struct super_block *sb, ext4_fsblk_t block, ext4_group_t block_group]\n- 调用者: ext4_init_block_bitmap\n- 被调用者: []\n\n12. 函数名: ext4_inode_bitmap\n- 参数: [struct super_block *sb, struct ext4_group_desc *gdp]\n- 调用者: ext4_init_block_bitmap\n- 被调用者: []\n\n13. 函数名: ext4_inode_table\n- 参数: [struct super_block *sb, struct ext4_group_desc *gdp]\n- 调用者: ext4_init_block_bitmap\n- 被调用者: []\n\n14. 函数名: num_clusters_in_group\n- 参数: [struct super_block *sb, ext4_group_t block_group]\n- 调用者: ext4_init_block_bitmap\n- 被调用者: []\n\n15. 函数名: ext4_mark_bitmap_end\n- 参数: [int num_bits, int total_bits, void *addr]\n- 调用者: ext4_init_block_bitmap\n- 被调用者: []"
    },
    {
        "id": 1613,
        "cwe": "CWE-787",
        "cve": "CVE-2018-10880",
        "purpose": "Code purpose:\"\"\"该代码用于在ext4文件系统中处理扩展属性(EA)的空间调整，当inode空间不足时将部分EA项移动到块中，以释放inode空间。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理ext4文件系统的内联xattr属性时，由于未充分验证输入数据的边界，导致可以越界写入堆栈内存。\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_xattr_make_inode_space\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_inode *raw_inode, int isize_diff, size_t ifree, size_t bfree, int *total_ino]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [EXT4_XATTR_NEXT, EXT4_XATTR_LEN, EXT4_XATTR_SIZE, le32_to_cpu, IS_LAST_ENTRY, ext4_xattr_move_to_block]\n\n2. 函数名: EXT4_XATTR_NEXT\n- 参数: [struct ext4_xattr_entry *last]\n- 调用者: ext4_xattr_make_inode_space\n- 被调用者: []\n\n3. 函数名: EXT4_XATTR_LEN\n- 参数: [last->e_name_len]\n- 调用者: ext4_xattr_make_inode_space\n- 被调用者: []\n\n4. 函数名: EXT4_XATTR_SIZE\n- 参数: [le32_to_cpu(last->e_value_size)]\n- 调用者: ext4_xattr_make_inode_space\n- 被调用者: []\n\n5. 函数名: le32_to_cpu\n- 参数: [last->e_value_size]\n- 调用者: ext4_xattr_make_inode_space\n- 被调用者: []\n\n6. 函数名: IS_LAST_ENTRY\n- 参数: [last]\n- 调用者: ext4_xattr_make_inode_space\n- 被调用者: []\n\n7. 函数名: ext4_xattr_move_to_block\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_inode *raw_inode, struct ext4_xattr_entry *entry]\n- 调用者: ext4_xattr_make_inode_space\n- 被调用者: []"
    },
    {
        "id": 1614,
        "cwe": "CWE-787",
        "cve": "CVE-2018-10881",
        "purpose": "Code purpose:\"\"\"该代码片段的功能是处理ext4文件系统中内联数据的销毁操作，包括清除内联数据标志、更新inode状态以及释放相关资源。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4文件系统中处理特制的文件系统镜像时，ext4_get_group_info函数存在越界访问漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_destroy_inline_data_nolock\n- 参数: [handle_t *handle, struct inode *inode]\n- 调用者: N/A\n- 被调用者: [ext4_get_inode_loc, ext4_xattr_ibody_find, ext4_journal_get_write_access, ext4_xattr_ibody_inline_set, memset, ext4_has_feature_extents, S_ISDIR, S_ISREG, S_ISLNK, ext4_set_inode_flag, ext4_ext_tree_init, ext4_clear_inode_flag, get_bh, ext4_mark_iloc_dirty, brelse]\n\n2. 函数名: ext4_get_inode_loc\n- 参数: [struct inode *inode, struct ext4_iloc *iloc]\n- 调用者: ext4_destroy_inline_data_nolock\n- 被调用者: N/A\n\n3. 函数名: ext4_xattr_ibody_find\n- 参数: [struct inode *inode, struct ext4_xattr_info *i, struct ext4_xattr_ibody_find *is]\n- 调用者: ext4_destroy_inline_data_nolock\n- 被调用者: N/A\n\n4. 函数名: ext4_journal_get_write_access\n- 参数: [handle_t *handle, struct buffer_head *bh]\n- 调用者: ext4_destroy_inline_data_nolock\n- 被调用者: N/A\n\n5. 函数名: ext4_xattr_ibody_inline_set\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_xattr_info *i, struct ext4_xattr_ibody_find *is]\n- 调用者: ext4_destroy_inline_data_nolock\n- 被调用者: N/A\n\n6. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: ext4_destroy_inline_data_nolock\n- 被调用者: N/A\n\n7. 函数名: ext4_has_feature_extents\n- 参数: [struct super_block *sb]\n- 调用者: ext4_destroy_inline_data_nolock\n- 被调用者: N/A\n\n8. 函数名: S_ISDIR\n- 参数: [unsigned int mode]\n- 调用者: ext4_destroy_inline_data_nolock\n- 被调用者: N/A\n\n9. 函数名: S_ISREG\n- 参数: [unsigned int mode]\n- 调用者: ext4_destroy_inline_data_nolock\n- 被调用者: N/A\n\n10. 函数名: S_ISLNK\n- 参数: [unsigned int mode]\n- 调用者: ext4_destroy_inline_data_nolock\n- 被调用者: N/A\n\n11. 函数名: ext4_set_inode_flag\n- 参数: [struct inode *inode, unsigned int flag]\n- 调用者: ext4_destroy_inline_data_nolock\n- 被调用者: N/A\n\n12. 函数名: ext4_ext_tree_init\n- 参数: [handle_t *handle, struct inode *inode]\n- 调用者: ext4_destroy_inline_data_nolock\n- 被调用者: N/A\n\n13. 函数名: ext4_clear_inode_flag\n- 参数: [struct inode *inode, unsigned int flag]\n- 调用者: ext4_destroy_inline_data_nolock\n- 被调用者: N/A\n\n14. 函数名: get_bh\n- 参数: [struct buffer_head *bh]\n- 调用者: ext4_destroy_inline_data_nolock\n- 被调用者: N/A\n\n15. 函数名: ext4_mark_iloc_dirty\n- 参数: [handle_t *handle, struct inode *inode, struct ext4_iloc *iloc]\n- 调用者: ext4_destroy_inline_data_nolock\n- 被调用者: N/A\n\n16. 函数名: brelse\n- 参数: [struct buffer_head *bh]\n- 调用者: ext4_destroy_inline_data_nolock\n- 被调用者: N/A"
    },
    {
        "id": 1615,
        "cwe": "CWE-787",
        "cve": "CVE-2018-10882",
        "purpose": "Code purpose:\"\"\"验证给定的inode号是否在ext4文件系统的有效范围内\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"ext4_valid_inum函数未充分验证inode号的有效性，导致可能通过特制的ext4文件系统映像触发越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_valid_inum\n- 参数: [struct super_block *sb, unsigned long ino]\n- 调用者: 未提供（需要更多上下文）\n- 被调用者: [le32_to_cpu, EXT4_FIRST_INO, EXT4_SB]\n\n2. 函数名: le32_to_cpu\n- 参数: [未明确显示参数名（通常接收32位小端值）]\n- 调用者: ext4_valid_inum\n- 被调用者: []\n\n3. 函数名: EXT4_FIRST_INO\n- 参数: [struct super_block *sb]\n- 调用者: ext4_valid_inum\n- 被调用者: []\n\n4. 函数名: EXT4_SB\n- 参数: [struct super_block *sb]\n- 调用者: ext4_valid_inum\n- 被调用者: []"
    },
    {
        "id": 1616,
        "cwe": "CWE-787",
        "cve": "CVE-2018-10882",
        "purpose": "Code purpose:\"\"\"该代码用于在ext4文件系统中定位和读取指定inode的磁盘位置信息，并处理相关的缓冲区和I/O操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于ext4文件系统在处理精心构造的文件系统镜像时，未能正确验证边界条件，导致在fs/jbd2/transaction.c中可以发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: __ext4_get_inode_loc\n- 参数: [inode, iloc, in_mem]\n- 调用者: N/A (顶级函数)\n- 被调用者: [ext4_valid_inum, ext4_get_group_desc, sb_getblk, lock_buffer, buffer_write_io_error, buffer_uptodate, unlock_buffer, ext4_test_bit, brelse, memset, set_buffer_uptodate, sb_breadahead, get_bh, submit_bh, wait_on_buffer, EXT4_ERROR_INODE_BLOCK]\n\n2. 函数名: ext4_valid_inum\n- 参数: [sb, i_ino]\n- 调用者: __ext4_get_inode_loc\n- 被调用者: []\n\n3. 函数名: ext4_get_group_desc\n- 参数: [sb, block_group, NULL]\n- 调用者: __ext4_get_inode_loc\n- 被调用者: []\n\n4. 函数名: sb_getblk\n- 参数: [sb, block]\n- 调用者: __ext4_get_inode_loc\n- 被调用者: []\n\n5. 函数名: lock_buffer\n- 参数: [bh]\n- 调用者: __ext4_get_inode_loc\n- 被调用者: []\n\n6. 函数名: buffer_write_io_error\n- 参数: [bh]\n- 调用者: __ext4_get_inode_loc\n- 被调用者: []\n\n7. 函数名: buffer_uptodate\n- 参数: [bh]\n- 调用者: __ext4_get_inode_loc\n- 被调用者: []\n\n8. 函数名: unlock_buffer\n- 参数: [bh]\n- 调用者: __ext4_get_inode_loc\n- 被调用者: []\n\n9. 函数名: ext4_test_bit\n- 参数: [i, bitmap_bh->b_data]\n- 调用者: __ext4_get_inode_loc\n- 被调用者: []\n\n10. 函数名: brelse\n- 参数: [bitmap_bh]\n- 调用者: __ext4_get_inode_loc\n- 被调用者: []\n\n11. 函数名: memset\n- 参数: [bh->b_data, 0, bh->b_size]\n- 调用者: __ext4_get_inode_loc\n- 被调用者: []\n\n12. 函数名: set_buffer_uptodate\n- 参数: [bh]\n- 调用者: __ext4_get_inode_loc\n- 被调用者: []\n\n13. 函数名: sb_breadahead\n- 参数: [sb, b++]\n- 调用者: __ext4_get_inode_loc\n- 被调用者: []\n\n14. 函数名: get_bh\n- 参数: [bh]\n- 调用者: __ext4_get_inode_loc\n- 被调用者: []\n\n15. 函数名: submit_bh\n- 参数: [REQ_OP_READ, REQ_META | REQ_PRIO, bh]\n- 调用者: __ext4_get_inode_loc\n- 被调用者: []\n\n16. 函数名: wait_on_buffer\n- 参数: [bh]\n- 调用者: __ext4_get_inode_loc\n- 被调用者: []\n\n17. 函数名: EXT4_ERROR_INODE_BLOCK\n- 参数: [inode, block, \"unable to read itable block\"]\n- 调用者: __ext4_get_inode_loc\n- 被调用者: []\n\n18. 函数名: end_buffer_read_sync\n- 参数: N/A (函数指针)\n- 调用者: __ext4_get_inode_loc (通过bh->b_end_io赋值)\n- 被调用者: []"
    },
    {
        "id": 1617,
        "cwe": "CWE-787",
        "cve": "CVE-2018-10882",
        "purpose": "Code purpose:\"\"\"该代码实现了ext4文件系统的挂载功能，包括初始化超级块、检查文件系统特性、设置挂载选项、处理日志恢复等操作，以将ext4文件系统挂载到Linux系统中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ext4文件系统卸载过程中，由于对事务处理的不当操作导致越界写入，可能造成服务拒绝或系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_fill_super\n- 参数: [struct super_block *sb, void *data, int silent]\n- 调用者: N/A (mount operation)\n- 被调用者: [kstrdup, kzalloc, get_sb_block, sb_bread_unmovable, ext4_has_feature_metadata_csum, ext4_has_feature_gdt_csum, ext4_verify_csum_type, crypto_alloc_shash, ext4_superblock_csum_verify, ext4_chksum, ext4_has_feature_csum_seed, ext4_has_metadata_csum, ext4_has_feature_ea_inode, ext4_has_feature_dir_index, ext4_has_feature_bigalloc, ext4_has_feature_64bit, ext4_has_feature_meta_bg, ext4_has_feature_quota, ext4_has_feature_encrypt, ext4_has_feature_journal, ext4_has_feature_journal_needs_recovery, ext4_has_feature_mmp, ext4_has_feature_extra_isize, ext4_has_feature_flex_bg, ext4_load_journal, ext4_multi_mount_protect, ext4_iget, ext4_setup_super, ext4_setup_system_zone, ext4_ext_init, ext4_mb_init, ext4_count_free_clusters, ext4_count_free_inodes, ext4_count_dirs, ext4_fill_flex_info, ext4_register_li_request, ext4_register_sysfs, ext4_enable_quotas, ext4_orphan_cleanup, ext4_mark_recovery_complete, ext4_unregister_sysfs, ext4_unregister_li_request, ext4_mb_release, ext4_ext_release, ext4_release_system_zone, ext4_es_unregister_shrinker, ext4_blkdev_remove, ext4_xattr_destroy_cache, jbd2_journal_destroy, kthread_stop, brelse, kvfree, crypto_free_shash, kfree, fs_put_dax]\n\n2. 函数名: get_sb_block\n- 参数: [void **data]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n3. 函数名: sb_bread_unmovable\n- 参数: [struct super_block *sb, sector_t block]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n4. 函数名: ext4_has_feature_metadata_csum\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n5. 函数名: ext4_has_feature_gdt_csum\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n6. 函数名: ext4_verify_csum_type\n- 参数: [struct super_block *sb, struct ext4_super_block *es]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n7. 函数名: crypto_alloc_shash\n- 参数: [const char *alg_name, u32 type, u32 mask]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n8. 函数名: ext4_superblock_csum_verify\n- 参数: [struct super_block *sb, struct ext4_super_block *es]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n9. 函数名: ext4_chksum\n- 参数: [struct ext4_sb_info *sbi, __u32 crc, void *address, unsigned int length]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n10. 函数名: ext4_has_feature_csum_seed\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n11. 函数名: ext4_has_metadata_csum\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n12. 函数名: ext4_has_feature_ea_inode\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n13. 函数名: ext4_has_feature_dir_index\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n14. 函数名: ext4_has_feature_bigalloc\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n15. 函数名: ext4_has_feature_64bit\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n16. 函数名: ext4_has_feature_meta_bg\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n17. 函数名: ext4_has_feature_quota\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n18. 函数名: ext4_has_feature_encrypt\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n19. 函数名: ext4_has_feature_journal\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n20. 函数名: ext4_has_feature_journal_needs_recovery\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n21. 函数名: ext4_has_feature_mmp\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n22. 函数名: ext4_has_feature_extra_isize\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n23. 函数名: ext4_has_feature_flex_bg\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n24. 函数名: ext4_load_journal\n- 参数: [struct super_block *sb, struct ext4_super_block *es, unsigned int journal_devnum]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n25. 函数名: ext4_multi_mount_protect\n- 参数: [struct super_block *sb, ext4_fsblk_t mmp_block]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n26. 函数名: ext4_iget\n- 参数: [struct super_block *sb, unsigned long ino]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n27. 函数名: ext4_setup_super\n- 参数: [struct super_block *sb, struct ext4_super_block *es, int read_only]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n28. 函数名: ext4_setup_system_zone\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n29. 函数名: ext4_ext_init\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n30. 函数名: ext4_mb_init\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n31. 函数名: ext4_count_free_clusters\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n32. 函数名: ext4_count_free_inodes\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n33. 函数名: ext4_count_dirs\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n34. 函数名: ext4_fill_flex_info\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n35. 函数名: ext4_register_li_request\n- 参数: [struct super_block *sb, ext4_group_t first_not_zeroed]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n36. 函数名: ext4_register_sysfs\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n37. 函数名: ext4_enable_quotas\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n38. 函数名: ext4_orphan_cleanup\n- 参数: [struct super_block *sb, struct ext4_super_block *es]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n39. 函数名: ext4_mark_recovery_complete\n- 参数: [struct super_block *sb, struct ext4_super_block *es]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n40. 函数名: ext4_unregister_sysfs\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n41. 函数名: ext4_unregister_li_request\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n42. 函数名: ext4_mb_release\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n43. 函数名: ext4_ext_release\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n44. 函数名: ext4_release_system_zone\n- 参数: [struct super_block *sb]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n45. 函数名: ext4_es_unregister_shrinker\n- 参数: [struct ext4_sb_info *sbi]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n46. 函数名: ext4_blkdev_remove\n- 参数: [struct ext4_sb_info *sbi]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n47. 函数名: ext4_xattr_destroy_cache\n- 参数: [struct mb_cache *cache]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n48. 函数名: jbd2_journal_destroy\n- 参数: [journal_t *journal]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n49. 函数名: kthread_stop\n- 参数: [struct task_struct *k]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n50. 函数名: brelse\n- 参数: [struct buffer_head *bh]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n51. 函数名: kvfree\n- 参数: [const void *addr]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n52. 函数名: crypto_free_shash\n- 参数: [struct crypto_shash *tfm]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n53. 函数名: kfree\n- 参数: [const void *x]\n- 调用者: ext4_fill_super\n- 被调用者: N/A\n\n54. 函数名: fs_put_dax\n- 参数: [struct dax_device *dax_dev]\n- 调用者: ext4_fill_super\n- 被调用者: N/A"
    },
    {
        "id": 1618,
        "cwe": "CWE-787",
        "cve": "CVE-2018-10883",
        "purpose": "Code purpose:\"\"\"该代码用于处理文件系统日志中元数据缓冲区的脏标记操作，确保事务一致性并防止数据损坏\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于jbd2_journal_dirty_metadata()函数在处理特制的ext4文件系统镜像时，未能正确验证journal head(bh)的状态，导致可能发生越界写入。\"\"\"",
        "functions": "Functions:\n1. 函数名: jbd2_journal_dirty_metadata\n- 参数: [handle_t *handle, struct buffer_head *bh]\n- 调用者: N/A (top-level function)\n- 被调用者: [is_handle_aborted, buffer_jbd, bh2jh, jbd_lock_bh_state, J_ASSERT_JH, jbd_unlock_bh_state, jbd_debug, JBUFFER_TRACE, set_buffer_jbddirty, __jbd2_journal_file_buffer]\n\n2. 函数名: is_handle_aborted\n- 参数: [handle_t *handle]\n- 调用者: jbd2_journal_dirty_metadata\n- 被调用者: []\n\n3. 函数名: buffer_jbd\n- 参数: [struct buffer_head *bh]\n- 调用者: jbd2_journal_dirty_metadata\n- 被调用者: []\n\n4. 函数名: bh2jh\n- 参数: [struct buffer_head *bh]\n- 调用者: jbd2_journal_dirty_metadata\n- 被调用者: []\n\n5. 函数名: jbd_lock_bh_state\n- 参数: [struct buffer_head *bh]\n- 调用者: jbd2_journal_dirty_metadata\n- 被调用者: []\n\n6. 函数名: J_ASSERT_JH\n- 参数: [struct journal_head *jh, condition]\n- 调用者: jbd2_journal_dirty_metadata\n- 被调用者: []\n\n7. 函数名: jbd_unlock_bh_state\n- 参数: [struct buffer_head *bh]\n- 调用者: jbd2_journal_dirty_metadata\n- 被调用者: []\n\n8. 函数名: jbd_debug\n- 参数: [int level, const char *fmt, ...]\n- 调用者: jbd2_journal_dirty_metadata\n- 被调用者: []\n\n9. 函数名: JBUFFER_TRACE\n- 参数: [struct journal_head *jh, const char *msg]\n- 调用者: jbd2_journal_dirty_metadata\n- 被调用者: []\n\n10. 函数名: set_buffer_jbddirty\n- 参数: [struct buffer_head *bh]\n- 调用者: jbd2_journal_dirty_metadata\n- 被调用者: []\n\n11. 函数名: __jbd2_journal_file_buffer\n- 参数: [struct journal_head *jh, transaction_t *transaction, enum BJ_Type type]\n- 调用者: jbd2_journal_dirty_metadata\n- 被调用者: []"
    },
    {
        "id": 1644,
        "cwe": "CWE-787",
        "cve": "CVE-2018-11506",
        "purpose": "Code purpose:\"\"\"处理SCSI CD-ROM设备的IOCTL命令，执行相关操作并处理可能的错误情况\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于CDROM层和SCSI层的sense缓冲区大小不一致，导致在sr_do_ioctl函数中处理ioctl调用时可能发生栈缓冲区溢出。\"\"\"",
        "functions": "Functions:\n1. 函数名: sr_do_ioctl\n- 参数: [Scsi_CD *cd, struct packet_command *cgc]\n- 调用者: 未显示（应为外部IOCTL调用者）\n- 被调用者: [scsi_block_when_processing_errors, scsi_execute, sr_printk, ssleep]\n\n2. 函数名: scsi_block_when_processing_errors\n- 参数: [struct scsi_device *SDev]\n- 调用者: sr_do_ioctl\n- 被调用者: 未显示\n\n3. 函数名: scsi_execute\n- 参数: [struct scsi_device *SDev, cgc->cmd, cgc->data_direction, cgc->buffer, cgc->buflen, (unsigned char *)cgc->sense, &sshdr, cgc->timeout, IOCTL_RETRIES, 0, 0, NULL]\n- 调用者: sr_do_ioctl\n- 被调用者: 未显示\n\n4. 函数名: sr_printk\n- 参数: [KERN_INFO, cd, format_string]\n- 调用者: sr_do_ioctl\n- 被调用者: 未显示\n\n5. 函数名: ssleep\n- 参数: [2]\n- 调用者: sr_do_ioctl\n- 被调用者: 未显示"
    },
    {
        "id": 1654,
        "cwe": "CWE-787",
        "cve": "CVE-2018-12714",
        "purpose": "Code purpose:\"\"\"解析并处理事件过滤器谓词表达式，构建程序执行流程\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当没有提供过滤器输入时(N=0)，代码尝试访问prog[N-1]导致数组越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: predicate_parse\n- 参数: [const char *str, int nr_parens, int nr_preds, parse_pred_fn parse_pred, void *data, struct filter_parse_error *pe]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [parse_error, kmalloc_array, isspace, is_not, parse_pred, update_preds, kfree, WARN_ON]\n\n2. 函数名: parse_error\n- 参数: [struct filter_parse_error *pe, int err, int pos]\n- 调用者: predicate_parse\n- 被调用者: 未显示\n\n3. 函数名: kmalloc_array\n- 参数: [size_t n, size_t size, gfp_t flags]\n- 调用者: predicate_parse\n- 被调用者: 未显示\n\n4. 函数名: isspace\n- 参数: [int c]\n- 调用者: predicate_parse\n- 被调用者: 未显示\n\n5. 函数名: is_not\n- 参数: [const char *next]\n- 调用者: predicate_parse\n- 被调用者: 未显示\n\n6. 函数名: parse_pred\n- 参数: [const char *next, void *data, int pos, struct filter_parse_error *pe, struct filter_pred *pred]\n- 调用者: predicate_parse\n- 被调用者: 未显示\n\n7. 函数名: update_preds\n- 参数: [struct prog_entry *prog, int N, int invert]\n- 调用者: predicate_parse\n- 被调用者: 未显示\n\n8. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: predicate_parse\n- 被调用者: 未显示\n\n9. 函数名: WARN_ON\n- 参数: [int condition]\n- 调用者: predicate_parse\n- 被调用者: 未显示"
    },
    {
        "id": 1670,
        "cwe": "CWE-787",
        "cve": "CVE-2018-13095",
        "purpose": "Code purpose:\"\"\"验证XFS文件系统中磁盘inode数据的完整性和有效性，防止处理损坏或不合法inode导致的内存破坏或系统崩溃\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当xfs文件系统中遇到一个采用extent格式但包含超出inode fork容量范围的extents数量的损坏inode时，会导致内存损坏和系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: xfs_dinode_verify\n- 参数: [struct xfs_mount *mp, xfs_ino_t ino, struct xfs_dinode *dip]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [cpu_to_be16, xfs_sb_version_hascrc, xfs_verify_cksum, be64_to_cpu, uuid_equal, be16_to_cpu, xfs_mode_to_ftype, XFS_DFORK_BOFF, XFS_DFORK_Q, xfs_inode_validate_extsize, xfs_sb_version_hasreflink, xfs_inode_validate_cowextsize]\n\n2. 函数名: cpu_to_be16\n- 参数: [未显示]\n- 调用者: xfs_dinode_verify\n- 被调用者: []\n\n3. 函数名: xfs_sb_version_hascrc\n- 参数: [未显示]\n- 调用者: xfs_dinode_verify\n- 被调用者: []\n\n4. 函数名: xfs_verify_cksum\n- 参数: [char *dip, sb_inodesize, XFS_DINODE_CRC_OFF]\n- 调用者: xfs_dinode_verify\n- 被调用者: []\n\n5. 函数名: be64_to_cpu\n- 参数: [未显示]\n- 调用者: xfs_dinode_verify\n- 被调用者: []\n\n6. 函数名: uuid_equal\n- 参数: [未显示]\n- 调用者: xfs_dinode_verify\n- 被调用者: []\n\n7. 函数名: be16_to_cpu\n- 参数: [未显示]\n- 调用者: xfs_dinode_verify\n- 被调用者: []\n\n8. 函数名: xfs_mode_to_ftype\n- 参数: [未显示]\n- 调用者: xfs_dinode_verify\n- 被调用者: []\n\n9. 函数名: XFS_DFORK_BOFF\n- 参数: [未显示]\n- 调用者: xfs_dinode_verify\n- 被调用者: []\n\n10. 函数名: XFS_DFORK_Q\n- 参数: [未显示]\n- 调用者: xfs_dinode_verify\n- 被调用者: []\n\n11. 函数名: xfs_inode_validate_extsize\n- 参数: [mp, be32_to_cpu(dip->di_extsize), mode, flags]\n- 调用者: xfs_dinode_verify\n- 被调用者: []\n\n12. 函数名: xfs_sb_version_hasreflink\n- 参数: [未显示]\n- 调用者: xfs_dinode_verify\n- 被调用者: []\n\n13. 函数名: xfs_inode_validate_cowextsize\n- 参数: [mp, be32_to_cpu(dip->di_cowextsize), mode, flags, flags2]\n- 调用者: xfs_dinode_verify\n- 被调用者: []"
    },
    {
        "id": 1679,
        "cwe": "CWE-787",
        "cve": "CVE-2018-14610",
        "purpose": "Code purpose:\"\"\"在btrfs文件系统中查找第一个有效的块组并验证其对应的chunk是否存在\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在挂载时未验证每个块组是否有对应的chunk，导致在处理精心构造的btrfs镜像时，write_extent_buffer()函数出现越界访问\"\"\"",
        "functions": "Functions:\n1. 函数名: find_first_block_group\n- 参数: [struct btrfs_fs_info *fs_info, struct btrfs_path *path, struct btrfs_key *key]\n- 调用者: 未显示\n- 被调用者: [btrfs_search_slot, btrfs_next_leaf, btrfs_item_key_to_cpu, lookup_extent_mapping, free_extent_map, btrfs_err]\n\n2. 函数名: btrfs_search_slot\n- 参数: [NULL, struct btrfs_root *root, struct btrfs_key *key, struct btrfs_path *path, 0, 0]\n- 调用者: find_first_block_group\n- 被调用者: 未显示\n\n3. 函数名: btrfs_next_leaf\n- 参数: [struct btrfs_root *root, struct btrfs_path *path]\n- 调用者: find_first_block_group\n- 被调用者: 未显示\n\n4. 函数名: btrfs_item_key_to_cpu\n- 参数: [struct extent_buffer *leaf, struct btrfs_key *found_key, int slot]\n- 调用者: find_first_block_group\n- 被调用者: 未显示\n\n5. 函数名: lookup_extent_mapping\n- 参数: [struct extent_map_tree *em_tree, u64 found_key.objectid, u64 found_key.offset]\n- 调用者: find_first_block_group\n- 被调用者: 未显示\n\n6. 函数名: free_extent_map\n- 参数: [struct extent_map *em]\n- 调用者: find_first_block_group\n- 被调用者: 未显示\n\n7. 函数名: btrfs_err\n- 参数: [struct btrfs_fs_info *fs_info, const char *fmt, u64 found_key.objectid, u64 found_key.offset]\n- 调用者: find_first_block_group\n- 被调用者: 未显示"
    },
    {
        "id": 1711,
        "cwe": "CWE-787",
        "cve": "CVE-2018-16276",
        "purpose": "Code purpose:\"\"\"该代码用于从yurex USB设备读取数据并将其复制到用户空间缓冲区\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于yurex_read函数在将数据从内核空间复制到用户空间时，未正确验证用户提供的缓冲区大小和偏移量，导致可能发生越界读取或写入，造成内核崩溃或权限提升。\"\"\"",
        "functions": "Functions:\n1. 函数名: yurex_read\n- 参数: [struct file *file, char __user *buffer, size_t count, loff_t *ppos]\n- 调用者: 内核文件操作接口\n- 被调用者: [mutex_lock, spin_lock_irqsave, snprintf, spin_unlock_irqrestore, copy_to_user, mutex_unlock]\n\n2. 函数名: mutex_lock\n- 参数: [&dev->io_mutex]\n- 调用者: yurex_read\n- 被调用者: []\n\n3. 函数名: spin_lock_irqsave\n- 参数: [&dev->lock, flags]\n- 调用者: yurex_read\n- 被调用者: []\n\n4. 函数名: snprintf\n- 参数: [in_buffer, 20, \"%lld\\n\", dev->bbu]\n- 调用者: yurex_read\n- 被调用者: []\n\n5. 函数名: spin_unlock_irqrestore\n- 参数: [&dev->lock, flags]\n- 调用者: yurex_read\n- 被调用者: []\n\n6. 函数名: copy_to_user\n- 参数: [buffer, in_buffer + *ppos, bytes_read - *ppos]\n- 调用者: yurex_read\n- 被调用者: []\n\n7. 函数名: mutex_unlock\n- 参数: [&dev->io_mutex]\n- 调用者: yurex_read\n- 被调用者: []"
    },
    {
        "id": 1717,
        "cwe": "CWE-787",
        "cve": "CVE-2018-16880",
        "purpose": "Code purpose:\"\"\"该代码实现了vhost_net设备的打开和初始化功能，包括内存分配、虚拟队列设置和回调函数注册等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"vhost_net驱动中的handle_rx()函数在特定条件下未正确验证输入边界，导致恶意虚拟机客户可以触发kmalloc-8 slab的越界写入，造成内核内存损坏\"\"\"",
        "functions": "Functions:\n1. 函数名: vhost_net_open\n- 参数: [struct inode *inode, struct file *f]\n- 调用者: 未显示（通常由文件操作结构体中的open函数指针调用）\n- 被调用者: [kvmalloc, kmalloc_array, kvfree, kfree, vhost_dev_init, vhost_poll_init, vhost_net_buf_init]\n\n2. 函数名: kvmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: vhost_net_open\n- 被调用者: []\n\n3. 函数名: kmalloc_array\n- 参数: [size_t n, size_t size, gfp_t flags]\n- 调用者: vhost_net_open\n- 被调用者: []\n\n4. 函数名: kvfree\n- 参数: [const void *addr]\n- 调用者: vhost_net_open\n- 被调用者: []\n\n5. 函数名: kfree\n- 参数: [const void *x]\n- 调用者: vhost_net_open\n- 被调用者: []\n\n6. 函数名: vhost_dev_init\n- 参数: [struct vhost_dev *dev, struct vhost_virtqueue **vqs, int nvqs]\n- 调用者: vhost_net_open\n- 被调用者: []\n\n7. 函数名: vhost_poll_init\n- 参数: [struct vhost_poll *poll, vhost_work_fn_t fn, unsigned long mask, struct vhost_dev *dev]\n- 调用者: vhost_net_open\n- 被调用者: []\n\n8. 函数名: vhost_net_buf_init\n- 参数: [struct vhost_net_buf *rxq]\n- 调用者: vhost_net_open\n- 被调用者: []"
    },
    {
        "id": 1718,
        "cwe": "CWE-787",
        "cve": "CVE-2018-16880",
        "purpose": "Code purpose:\"\"\"该代码实现了vhost_scsi设备的打开功能，包括初始化虚拟队列、工作队列和事件处理，用于支持SCSI设备的虚拟化操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于vhost_scsi_open函数中未对VHOST_SCSI_MAX_VQ进行有效边界检查，导致可能发生越界写入，造成内存损坏\"\"\"",
        "functions": "Functions:\n1. 函数名: vhost_scsi_open\n- 参数: [struct inode *inode, struct file *f]\n- 调用者: 未明确（通常是文件操作结构体中的open函数指针）\n- 被调用者: [kzalloc, vzalloc, kmalloc_array, vhost_work_init, vhost_dev_init, vhost_scsi_init_inflight, kvfree]\n\n2. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: vhost_scsi_open\n- 被调用者: []\n\n3. 函数名: vzalloc\n- 参数: [size_t size]\n- 调用者: vhost_scsi_open\n- 被调用者: []\n\n4. 函数名: kmalloc_array\n- 参数: [size_t n, size_t size, gfp_t flags]\n- 调用者: vhost_scsi_open\n- 被调用者: []\n\n5. 函数名: vhost_work_init\n- 参数: [struct vhost_work *work, vhost_work_fn_t fn]\n- 调用者: vhost_scsi_open\n- 被调用者: []\n\n6. 函数名: vhost_dev_init\n- 参数: [struct vhost_dev *dev, struct vhost_virtqueue **vqs, int nvqs]\n- 调用者: vhost_scsi_open\n- 被调用者: []\n\n7. 函数名: vhost_scsi_init_inflight\n- 参数: [struct vhost_scsi *vs, struct vhost_scsi_inflight *old_inflight]\n- 调用者: vhost_scsi_open\n- 被调用者: []\n\n8. 函数名: kvfree\n- 参数: [const void *addr]\n- 调用者: vhost_scsi_open\n- 被调用者: []"
    },
    {
        "id": 1719,
        "cwe": "CWE-787",
        "cve": "CVE-2018-16880",
        "purpose": "Code purpose:\"\"\"为虚拟主机设备分配和管理IO向量缓冲区内存\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在vhost_dev_alloc_iovecs函数中，当内存分配失败时，错误处理循环可能因整数下溢导致越界访问，造成内存损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: vhost_dev_alloc_iovecs\n- 参数: [struct vhost_dev *dev]\n- 调用者: 未显示\n- 被调用者: [kmalloc_array, vhost_vq_free_iovecs]\n\n2. 函数名: kmalloc_array\n- 参数: [size_t n, size_t size, gfp_t flags]\n- 调用者: vhost_dev_alloc_iovecs\n- 被调用者: 未显示\n\n3. 函数名: vhost_vq_free_iovecs\n- 参数: [struct vhost_virtqueue *vq]\n- 调用者: vhost_dev_alloc_iovecs\n- 被调用者: 未显示"
    },
    {
        "id": 1720,
        "cwe": "CWE-787",
        "cve": "CVE-2018-16880",
        "purpose": "Code purpose:\"\"\"该代码实现了vhost_vsock设备的打开功能，包括内存分配、虚拟队列初始化和设备初始化等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于vhost_vsock_dev_open函数中未对vqs数组的索引进行边界检查，可能导致越界写入，造成内存损坏\"\"\"",
        "functions": "Functions:\n1. 函数名: vhost_vsock_dev_open\n- 参数: [struct inode *inode, struct file *file]\n- 调用者: 未显示（通常由文件操作结构体中的open函数指针调用）\n- 被调用者: [kvmalloc, kmalloc_array, atomic_set, vhost_dev_init, spin_lock_init, INIT_LIST_HEAD, vhost_work_init, vhost_vsock_free]\n\n2. 函数名: kvmalloc\n- 参数: [sizeof(*vsock), GFP_KERNEL | __GFP_RETRY_MAYFAIL]\n- 调用者: vhost_vsock_dev_open\n- 被调用者: []\n\n3. 函数名: kmalloc_array\n- 参数: [ARRAY_SIZE(vsock->vqs), sizeof(*vqs), GFP_KERNEL]\n- 调用者: vhost_vsock_dev_open\n- 被调用者: []\n\n4. 函数名: atomic_set\n- 参数: [&vsock->queued_replies, 0]\n- 调用者: vhost_vsock_dev_open\n- 被调用者: []\n\n5. 函数名: vhost_dev_init\n- 参数: [&vsock->dev, vqs, ARRAY_SIZE(vsock->vqs)]\n- 调用者: vhost_vsock_dev_open\n- 被调用者: []\n\n6. 函数名: spin_lock_init\n- 参数: [&vsock->send_pkt_list_lock]\n- 调用者: vhost_vsock_dev_open\n- 被调用者: []\n\n7. 函数名: INIT_LIST_HEAD\n- 参数: [&vsock->send_pkt_list]\n- 调用者: vhost_vsock_dev_open\n- 被调用者: []\n\n8. 函数名: vhost_work_init\n- 参数: [&vsock->send_pkt_work, vhost_transport_send_pkt_work]\n- 调用者: vhost_vsock_dev_open\n- 被调用者: []\n\n9. 函数名: vhost_vsock_free\n- 参数: [vsock]\n- 调用者: vhost_vsock_dev_open\n- 被调用者: []"
    },
    {
        "id": 1819,
        "cwe": "CWE-787",
        "cve": "CVE-2018-5332",
        "purpose": "Code purpose:\"\"\"计算RDS RDMA操作中所需额外内存的大小，用于DMA页面分配\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"rds_rdma_extra_size函数未充分验证tot_pages的计算结果，导致可能发生整数溢出，进而引发堆越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: rds_rdma_extra_size\n- 参数: [struct rds_rdma_args *args]\n- 调用者: 未明确（应为rds_message_alloc_sgs）\n- 被调用者: [copy_from_user, rds_pages_in_vec]\n\n2. 函数名: copy_from_user\n- 参数: [&vec, &local_vec[i], sizeof(struct rds_iovec)]\n- 调用者: rds_rdma_extra_size\n- 被调用者: []\n\n3. 函数名: rds_pages_in_vec\n- 参数: [&vec]\n- 调用者: rds_rdma_extra_size\n- 被调用者: []"
    },
    {
        "id": 1824,
        "cwe": "CWE-787",
        "cve": "CVE-2018-5703",
        "purpose": "Code purpose:\"\"\"初始化TCP套接字的TLS上下文，为已建立的TCP连接设置TLS相关配置和操作函数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理TCPv6 SYN接收套接字时，未正确验证TLS上下文的状态，导致可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: tls_init\n- 参数: [struct sock *sk]\n- 调用者: 未明确显示（可能是TCP协议栈中调用ULP初始化的地方）\n- 被调用者: [inet_csk, kzalloc, update_sk_prot]\n\n2. 函数名: inet_csk\n- 参数: [struct sock *sk]\n- 调用者: tls_init\n- 被调用者: []\n\n3. 函数名: kzalloc\n- 参数: [sizeof(*ctx), GFP_KERNEL]\n- 调用者: tls_init\n- 被调用者: []\n\n4. 函数名: update_sk_prot\n- 参数: [struct sock *sk, struct tls_context *ctx]\n- 调用者: tls_init\n- 被调用者: []"
    },
    {
        "id": 1825,
        "cwe": "CWE-787",
        "cve": "CVE-2018-5703",
        "purpose": "Code purpose:\"\"\"该代码片段用于在Linux内核中注册TLS协议作为TCP的上层协议(ULP)\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中tcp_v6_syn_recv_sock函数在处理TLS协议时存在边界检查不足，导致可通过特制向量触发越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: tls_register\n- 参数: []\n- 调用者: __init\n- 被调用者: [build_protos, tcp_register_ulp]\n\n2. 函数名: build_protos\n- 参数: [tls_prots, &tcp_prot]\n- 调用者: tls_register\n- 被调用者: []\n\n3. 函数名: tcp_register_ulp\n- 参数: [&tcp_tls_ulp_ops]\n- 调用者: tls_register\n- 被调用者: []"
    },
    {
        "id": 1826,
        "cwe": "CWE-787",
        "cve": "CVE-2018-5703",
        "purpose": "Code purpose:\"\"\"更新套接字的协议处理函数指针以匹配传输层安全(TLS)上下文中的传输配置\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对ctx->tx_conf进行边界检查，导致数组越界访问，可能造成拒绝服务或其他未明确影响\"\"\"",
        "functions": "Functions:\n1. 函数名: update_sk_prot\n- 参数: [sk, ctx]\n- 调用者: 未明确（可能是tcp_v6_syn_recv_sock或其他TLS相关函数）\n- 被调用者: []"
    },
    {
        "id": 1863,
        "cwe": "CWE-787",
        "cve": "CVE-2018-9385",
        "purpose": "Code purpose:\"\"\"该代码用于处理设备驱动覆盖的存储操作，允许通过用户空间输入修改设备的驱动覆盖设置。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于边界检查不正确导致可能发生越界写入，当输入数据长度恰好等于PATH_MAX时，kstrndup函数会复制PATH_MAX个字节而不保留空间给终止空字符\"\"\"",
        "functions": "Functions:\n1. 函数名: driver_override_store\n- 参数: [_dev, attr, buf, count]\n- 调用者: 未指定（通常由设备属性文件系统调用）\n- 被调用者: [to_amba_device, kstrndup, strchr, device_lock, strlen, kfree, device_unlock]\n\n2. 函数名: to_amba_device\n- 参数: [_dev]\n- 调用者: driver_override_store\n- 被调用者: []\n\n3. 函数名: kstrndup\n- 参数: [buf, count, GFP_KERNEL]\n- 调用者: driver_override_store\n- 被调用者: []\n\n4. 函数名: strchr\n- 参数: [driver_override, '\\n']\n- 调用者: driver_override_store\n- 被调用者: []\n\n5. 函数名: device_lock\n- 参数: [_dev]\n- 调用者: driver_override_store\n- 被调用者: []\n\n6. 函数名: strlen\n- 参数: [driver_override]\n- 调用者: driver_override_store\n- 被调用者: []\n\n7. 函数名: kfree\n- 参数: [driver_override], [old]\n- 调用者: driver_override_store\n- 被调用者: []\n\n8. 函数名: device_unlock\n- 参数: [_dev]\n- 调用者: driver_override_store\n- 被调用者: []"
    },
    {
        "id": 1874,
        "cwe": "CWE-787",
        "cve": "CVE-2018-9518",
        "purpose": "Code purpose:\"\"\"构建NFC LLCP协议的SDP请求TLV结构体，包含URI数据并分配内存空间\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺少对uri_len参数的边界检查，可能导致在memcpy操作时发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: nfc_llcp_build_sdreq_tlv\n- 参数: [u8 tid, char *uri, size_t uri_len]\n- 调用者: 未提供\n- 被调用者: [kzalloc, kfree, memcpy, INIT_HLIST_NODE]\n\n2. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: nfc_llcp_build_sdreq_tlv\n- 被调用者: 未提供\n\n3. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: nfc_llcp_build_sdreq_tlv\n- 被调用者: 未提供\n\n4. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: nfc_llcp_build_sdreq_tlv\n- 被调用者: 未提供\n\n5. 函数名: INIT_HLIST_NODE\n- 参数: [struct hlist_node *h]\n- 调用者: nfc_llcp_build_sdreq_tlv\n- 被调用者: 未提供"
    },
    {
        "id": 1930,
        "cwe": "CWE-787",
        "cve": "CVE-2019-11683",
        "purpose": "Code purpose:\"\"\"处理UDP数据包的GRO(Generic Receive Offload)接收和合并，以提高网络性能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在处理UDP协议栈的GRO(Generic Receive Offload)功能时，对零负载的填充数据包处理不当，导致内存越界访问\"\"\"",
        "functions": "Functions:\n1. 函数名: udp_gro_receive_segment\n- 参数: [head, skb]\n- 调用者: 未明确显示（通常是UDP GRO接收路径中的上层函数）\n- 被调用者: [udp_hdr, skb_gro_pull, skb_gro_postpull_rcsum, skb_gro_receive]\n\n2. 函数名: udp_hdr\n- 参数: [skb]\n- 调用者: udp_gro_receive_segment\n- 被调用者: []\n\n3. 函数名: skb_gro_pull\n- 参数: [skb, sizeof(struct udphdr)]\n- 调用者: udp_gro_receive_segment\n- 被调用者: []\n\n4. 函数名: skb_gro_postpull_rcsum\n- 参数: [skb, uh, sizeof(struct udphdr)]\n- 调用者: udp_gro_receive_segment\n- 被调用者: []\n\n5. 函数名: skb_gro_receive\n- 参数: [p, skb]\n- 调用者: udp_gro_receive_segment\n- 被调用者: []"
    },
    {
        "id": 1950,
        "cwe": "CWE-787",
        "cve": "CVE-2019-12817",
        "purpose": "Code purpose:\"\"\"为新的内存管理结构分配上下文ID并初始化相关上下文信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在特定条件下，由于未正确处理mmap高于512TB的内存区域，导致无关进程可能相互读写对方的虚拟内存。\"\"\"",
        "functions": "Functions:\n1. 函数名: hash__init_new_context\n- 参数: [struct mm_struct *mm]\n- 调用者: 未明确显示（通常是内核初始化或进程创建相关代码）\n- 被调用者: [hash__alloc_context_id, slice_init_new_context_exec, subpage_prot_init_new_context, pkey_mm_init]\n\n2. 函数名: hash__alloc_context_id\n- 参数: []\n- 调用者: hash__init_new_context\n- 被调用者: []\n\n3. 函数名: slice_init_new_context_exec\n- 参数: [struct mm_struct *mm]\n- 调用者: hash__init_new_context\n- 被调用者: []\n\n4. 函数名: subpage_prot_init_new_context\n- 参数: [struct mm_struct *mm]\n- 调用者: hash__init_new_context\n- 被调用者: []\n\n5. 函数名: pkey_mm_init\n- 参数: [struct mm_struct *mm]\n- 调用者: hash__init_new_context\n- 被调用者: []"
    },
    {
        "id": 1961,
        "cwe": "CWE-787",
        "cve": "CVE-2019-13631",
        "purpose": "Code purpose:\"\"\"解析HID报告描述符并提取设备信息，包括坐标、倾斜度和压力等输入数据，同时生成调试信息。\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理恶意USB设备发送的HID报告时，由于未充分验证输入数据的边界，导致在生成调试消息时发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: parse_hid_report_descriptor\n- 参数: [struct gtco *device, char * report, int length]\n- 调用者: 未显示（应为外部USB设备驱动）\n- 被调用者: [dev_dbg, dev_err, get_unaligned_le16, get_unaligned_le32, strcpy]\n\n2. 函数名: dev_dbg\n- 参数: [struct device *ddev, const char *fmt, ...]\n- 调用者: parse_hid_report_descriptor\n- 被调用者: 无\n\n3. 函数名: dev_err\n- 参数: [struct device *ddev, const char *fmt, ...]\n- 调用者: parse_hid_report_descriptor\n- 被调用者: 无\n\n4. 函数名: get_unaligned_le16\n- 参数: [const void *p]\n- 调用者: parse_hid_report_descriptor\n- 被调用者: 无\n\n5. 函数名: get_unaligned_le32\n- 参数: [const void *p]\n- 调用者: parse_hid_report_descriptor\n- 被调用者: 无\n\n6. 函数名: strcpy\n- 参数: [char *dest, const char *src]\n- 调用者: parse_hid_report_descriptor\n- 被调用者: 无"
    },
    {
        "id": 1972,
        "cwe": "CWE-787",
        "cve": "CVE-2019-14821",
        "purpose": "Code purpose:\"\"\"该代码实现了KVM虚拟化环境中合并MMIO写操作的功能，通过环形缓冲区处理来自客户机的MMIO写请求。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证用户空间提供的ring->last索引值，导致可以越界访问MMIO环形缓冲区，造成内存越界写入漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: coalesced_mmio_write\n- 参数: [vcpu, this, addr, len, val]\n- 调用者: 未指定\n- 被调用者: [to_mmio, coalesced_mmio_in_range, spin_lock, coalesced_mmio_has_room, spin_unlock, memcpy, smp_wmb]\n\n2. 函数名: to_mmio\n- 参数: [this]\n- 调用者: coalesced_mmio_write\n- 被调用者: 未指定\n\n3. 函数名: coalesced_mmio_in_range\n- 参数: [dev, addr, len]\n- 调用者: coalesced_mmio_write\n- 被调用者: 未指定\n\n4. 函数名: spin_lock\n- 参数: [&dev->kvm->ring_lock]\n- 调用者: coalesced_mmio_write\n- 被调用者: 未指定\n\n5. 函数名: coalesced_mmio_has_room\n- 参数: [dev]\n- 调用者: coalesced_mmio_write\n- 被调用者: 未指定\n\n6. 函数名: spin_unlock\n- 参数: [&dev->kvm->ring_lock]\n- 调用者: coalesced_mmio_write\n- 被调用者: 未指定\n\n7. 函数名: memcpy\n- 参数: [ring->coalesced_mmio[ring->last].data, val, len]\n- 调用者: coalesced_mmio_write\n- 被调用者: 未指定\n\n8. 函数名: smp_wmb\n- 参数: []\n- 调用者: coalesced_mmio_write\n- 被调用者: 未指定"
    },
    {
        "id": 2188,
        "cwe": "CWE-787",
        "cve": "CVE-2019-19319",
        "purpose": "Code purpose:\"\"\"该代码用于设置ext4文件系统的系统区域，包括处理块组描述符、位图和inode表等系统数据结构，并验证块的有效性。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核5.2之前版本中，挂载特制的ext4镜像后执行setxattr操作时，由于ext4_xattr_set_entry中存在对已释放内存的使用（use-after-free），当memset调用使用较大的old_size值时会导致slab越界写入。\"\"\"",
        "functions": "Functions:\n1. 函数名: ext4_setup_system_zone\n- 参数: [struct super_block *sb]\n- 调用者: N/A (顶层函数)\n- 被调用者: [ext4_get_groups_count, ext4_flex_bg_size, test_opt, ext4_release_system_zone, ext4_bg_has_super, ext4_group_first_block_no, ext4_bg_num_gdb, add_system_zone, ext4_get_group_desc, ext4_block_bitmap, ext4_inode_bitmap, ext4_inode_table, debug_print_tree]\n\n2. 函数名: ext4_get_groups_count\n- 参数: [struct super_block *sb]\n- 调用者: ext4_setup_system_zone\n- 被调用者: []\n\n3. 函数名: ext4_flex_bg_size\n- 参数: [struct ext4_sb_info *sbi]\n- 调用者: ext4_setup_system_zone\n- 被调用者: []\n\n4. 函数名: test_opt\n- 参数: [struct super_block *sb, int BLOCK_VALIDITY]\n- 调用者: ext4_setup_system_zone\n- 被调用者: []\n\n5. 函数名: ext4_release_system_zone\n- 参数: [struct super_block *sb]\n- 调用者: ext4_setup_system_zone\n- 被调用者: []\n\n6. 函数名: ext4_bg_has_super\n- 参数: [struct super_block *sb, ext4_group_t i]\n- 调用者: ext4_setup_system_zone\n- 被调用者: []\n\n7. 函数名: ext4_group_first_block_no\n- 参数: [struct super_block *sb, ext4_group_t i]\n- 调用者: ext4_setup_system_zone\n- 被调用者: []\n\n8. 函数名: ext4_bg_num_gdb\n- 参数: [struct super_block *sb, ext4_group_t i]\n- 调用者: ext4_setup_system_zone\n- 被调用者: []\n\n9. 函数名: add_system_zone\n- 参数: [struct ext4_sb_info *sbi, [type] block, [type] num]\n- 调用者: ext4_setup_system_zone\n- 被调用者: []\n\n10. 函数名: ext4_get_group_desc\n- 参数: [struct super_block *sb, ext4_group_t i, NULL]\n- 调用者: ext4_setup_system_zone\n- 被调用者: []\n\n11. 函数名: ext4_block_bitmap\n- 参数: [struct super_block *sb, struct ext4_group_desc *gdp]\n- 调用者: ext4_setup_system_zone\n- 被调用者: []\n\n12. 函数名: ext4_inode_bitmap\n- 参数: [struct super_block *sb, struct ext4_group_desc *gdp]\n- 调用者: ext4_setup_system_zone\n- 被调用者: []\n\n13. 函数名: ext4_inode_table\n- 参数: [struct super_block *sb, struct ext4_group_desc *gdp]\n- 调用者: ext4_setup_system_zone\n- 被调用者: []\n\n14. 函数名: debug_print_tree\n- 参数: [struct ext4_sb_info *sbi]\n- 调用者: ext4_setup_system_zone\n- 被调用者: []"
    },
    {
        "id": 2189,
        "cwe": "CWE-787",
        "cve": "CVE-2019-19319",
        "purpose": "Code purpose:\"\"\"检查ext4文件系统中数据块的合法性，防止非法块访问\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核5.2之前版本中，挂载特制的ext4镜像后执行setxattr操作时，由于ext4_xattr_set_entry函数中对大old_size值的memset调用存在释放后使用问题，导致可越界写入的漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: __check_block_validity\n- 参数: [struct inode *inode, const char *func, unsigned int line, struct ext4_map_blocks *map]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [ext4_data_block_valid, ext4_error_inode]\n\n2. 函数名: ext4_data_block_valid\n- 参数: [EXT4_SB(inode->i_sb), map->m_pblk, map->m_len]\n- 调用者: __check_block_validity\n- 被调用者: 未明确（上下文未提供）\n\n3. 函数名: ext4_error_inode\n- 参数: [inode, func, line, map->m_pblk, \"lblock %lu mapped to illegal pblock %llu (length %d)\", (unsigned long) map->m_lblk, map->m_pblk, map->m_len]\n- 调用者: __check_block_validity\n- 被调用者: 未明确（上下文未提供）"
    },
    {
        "id": 2190,
        "cwe": "CWE-787",
        "cve": "CVE-2019-19332",
        "purpose": "Code purpose:\"\"\"该代码实现了KVM虚拟化环境中处理CPUID指令的功能，包括过滤和设置虚拟CPU的特性标志位，以支持客户机操作系统的CPU特性查询。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理KVM_GET_EMULATED_CPUID ioctl请求时，由于未正确验证用户提供的输入参数，导致可以越界写入内存，造成系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: __do_cpuid_func\n- 参数: [struct kvm_cpuid_entry2 *entry, u32 function, int *nent, int maxnent]\n- 调用者: N/A (顶层函数)\n- 被调用者: [is_efer_nx, kvm_x86_ops->get_lpage_level, kvm_x86_ops->rdtscp_supported, kvm_x86_ops->xsaves_supported, kvm_x86_ops->pt_supported, get_cpu, do_host_cpuid, cpuid_mask, do_cpuid_7_mask, perf_get_x86_pmu_capability, xstate_required_size, kvm_x86_ops->set_supported_cpuid, put_cpu]\n\n2. 函数名: is_efer_nx\n- 参数: []\n- 调用者: __do_cpuid_func\n- 被调用者: []\n\n3. 函数名: get_lpage_level\n- 参数: []\n- 调用者: __do_cpuid_func\n- 被调用者: []\n\n4. 函数名: rdtscp_supported\n- 参数: []\n- 调用者: __do_cpuid_func\n- 被调用者: []\n\n5. 函数名: xsaves_supported\n- 参数: []\n- 调用者: __do_cpuid_func\n- 被调用者: []\n\n6. 函数名: pt_supported\n- 参数: []\n- 调用者: __do_cpuid_func\n- 被调用者: []\n\n7. 函数名: get_cpu\n- 参数: []\n- 调用者: __do_cpuid_func\n- 被调用者: []\n\n8. 函数名: do_host_cpuid\n- 参数: [struct kvm_cpuid_entry2 *entry, u32 function, u32 index]\n- 调用者: __do_cpuid_func\n- 被调用者: []\n\n9. 函数名: cpuid_mask\n- 参数: [u32 *word, int wordnum]\n- 调用者: __do_cpuid_func\n- 被调用者: []\n\n10. 函数名: do_cpuid_7_mask\n- 参数: [struct kvm_cpuid_entry2 *entry, int index]\n- 调用者: __do_cpuid_func\n- 被调用者: []\n\n11. 函数名: perf_get_x86_pmu_capability\n- 参数: [struct x86_pmu_capability *cap]\n- 调用者: __do_cpuid_func\n- 被调用者: []\n\n12. 函数名: xstate_required_size\n- 参数: [u64 xcr0, bool compacted]\n- 调用者: __do_cpuid_func\n- 被调用者: []\n\n13. 函数名: set_supported_cpuid\n- 参数: [u32 function, struct kvm_cpuid_entry2 *entry]\n- 调用者: __do_cpuid_func\n- 被调用者: []\n\n14. 函数名: put_cpu\n- 参数: []\n- 调用者: __do_cpuid_func\n- 被调用者: []"
    },
    {
        "id": 2191,
        "cwe": "CWE-787",
        "cve": "CVE-2019-19332",
        "purpose": "Code purpose:\"\"\"该代码片段用于处理KVM虚拟化环境中的CPUID功能请求，根据请求类型选择执行模拟CPUID功能或直接执行CPUID功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对'nent'和'maxnent'参数进行边界检查，导致在处理'KVM_GET_EMULATED_CPUID'请求时可能发生越界内存写入\"\"\"",
        "functions": "Functions:\n1. 函数名: do_cpuid_func\n- 参数: [struct kvm_cpuid_entry2 *entry, u32 func, int *nent, int maxnent, unsigned int type]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [__do_cpuid_func_emulated, __do_cpuid_func]\n\n2. 函数名: __do_cpuid_func_emulated\n- 参数: [struct kvm_cpuid_entry2 *entry, u32 func, int *nent, int maxnent]\n- 调用者: do_cpuid_func\n- 被调用者: 未明确\n\n3. 函数名: __do_cpuid_func\n- 参数: [struct kvm_cpuid_entry2 *entry, u32 func, int *nent, int maxnent]\n- 调用者: do_cpuid_func\n- 被调用者: 未明确"
    },
    {
        "id": 2207,
        "cwe": "CWE-787",
        "cve": "CVE-2019-19532",
        "purpose": "Code purpose:\"\"\"初始化EMS设备的力反馈功能，设置相关报告字段并通过USB HID协议与设备通信\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码在访问report->field[0]->value数组时未充分验证数组边界，导致恶意USB设备可能触发越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: emsff_init\n- 参数: [struct hid_device *hid]\n- 调用者: 未显示（由HID子系统调用）\n- 被调用者: [list_first_entry, hid_err, kzalloc, set_bit, input_ff_create_memless, kfree, hid_hw_request, hid_info]\n\n2. 函数名: list_first_entry\n- 参数: [&hid->inputs, struct hid_input, list] 和 [report_list, struct hid_report, list]\n- 调用者: emsff_init\n- 被调用者: 无（宏定义）\n\n3. 函数名: hid_err\n- 参数: [hid, \"no output reports found\"] 和 [hid, \"no fields in the report\"] 和 [hid, \"not enough values in the field\"]\n- 调用者: emsff_init\n- 被调用者: 无（内核日志函数）\n\n4. 函数名: kzalloc\n- 参数: [sizeof(struct emsff_device), GFP_KERNEL]\n- 调用者: emsff_init\n- 被调用者: 无（内存分配函数）\n\n5. 函数名: set_bit\n- 参数: [FF_RUMBLE, dev->ffbit]\n- 调用者: emsff_init\n- 被调用者: 无（位操作函数）\n\n6. 函数名: input_ff_create_memless\n- 参数: [dev, emsff, emsff_play]\n- 调用者: emsff_init\n- 被调用者: 无（输入子系统函数）\n\n7. 函数名: kfree\n- 参数: [emsff]\n- 调用者: emsff_init\n- 被调用者: 无（内存释放函数）\n\n8. 函数名: hid_hw_request\n- 参数: [hid, emsff->report, HID_REQ_SET_REPORT]\n- 调用者: emsff_init\n- 被调用者: 无（硬件请求函数）\n\n9. 函数名: hid_info\n- 参数: [hid, \"force feedback for EMS based devices by Ignaz Forster <ignaz.forster@gmx.de>\"]\n- 调用者: emsff_init\n- 被调用者: 无（内核日志函数）"
    },
    {
        "id": 2208,
        "cwe": "CWE-787",
        "cve": "CVE-2019-19532",
        "purpose": "Code purpose:\"\"\"初始化GreenAsia 0x12设备的力反馈功能，通过HID接口设置输出报告来控制设备震动效果。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码在访问HID设备报告字段时未充分验证数组边界，导致恶意USB设备可触发越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: gaff_init\n- 参数: [struct hid_device *hid]\n- 调用者: (未明确显示，应为HID驱动框架)\n- 被调用者: [list_entry, hid_err, kzalloc, set_bit, input_ff_create_memless, kfree, hid_hw_request, hid_info]\n\n2. 函数名: list_entry\n- 参数: [report_ptr, struct hid_report, list]\n- 调用者: gaff_init\n- 被调用者: (无)\n\n3. 函数名: hid_err\n- 参数: [hid, \"no output reports found\"] / [hid, \"no fields in the report\"] / [hid, \"not enough values in the field\"]\n- 调用者: gaff_init\n- 被调用者: (无)\n\n4. 函数名: kzalloc\n- 参数: [sizeof(struct gaff_device), GFP_KERNEL]\n- 调用者: gaff_init\n- 被调用者: (无)\n\n5. 函数名: set_bit\n- 参数: [FF_RUMBLE, dev->ffbit]\n- 调用者: gaff_init\n- 被调用者: (无)\n\n6. 函数名: input_ff_create_memless\n- 参数: [dev, gaff, hid_gaff_play]\n- 调用者: gaff_init\n- 被调用者: (无)\n\n7. 函数名: kfree\n- 参数: [gaff]\n- 调用者: gaff_init\n- 被调用者: (无)\n\n8. 函数名: hid_hw_request\n- 参数: [hid, gaff->report, HID_REQ_SET_REPORT]\n- 调用者: gaff_init\n- 被调用者: (无)\n\n9. 函数名: hid_info\n- 参数: [hid, \"Force Feedback for GreenAsia 0x12 devices by Lukasz Lubojanski <lukasz@lubojanski.info>\"]\n- 调用者: gaff_init\n- 被调用者: (无)"
    },
    {
        "id": 2209,
        "cwe": "CWE-787",
        "cve": "CVE-2019-19532",
        "purpose": "Code purpose:\"\"\"初始化Logitech variant 2设备的力反馈功能，包括分配内存、设置报告值并通过USB HID协议发送给设备\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对USB设备提供的报告数据进行充分验证，导致内核HID驱动在处理恶意USB设备时可能发生越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: lg2ff_init\n- 参数: [struct hid_device *hid]\n- 调用者: 未显示\n- 被调用者: [list_entry, hid_validate_values, kmalloc, set_bit, input_ff_create_memless, kfree, hid_hw_request, hid_info]\n\n2. 函数名: list_entry\n- 参数: [hid->inputs.next, struct hid_input, list]\n- 调用者: lg2ff_init\n- 被调用者: 未显示\n\n3. 函数名: hid_validate_values\n- 参数: [hid, HID_OUTPUT_REPORT, 0, 0, 7]\n- 调用者: lg2ff_init\n- 被调用者: 未显示\n\n4. 函数名: kmalloc\n- 参数: [sizeof(struct lg2ff_device), GFP_KERNEL]\n- 调用者: lg2ff_init\n- 被调用者: 未显示\n\n5. 函数名: set_bit\n- 参数: [FF_RUMBLE, dev->ffbit]\n- 调用者: lg2ff_init\n- 被调用者: 未显示\n\n6. 函数名: input_ff_create_memless\n- 参数: [dev, lg2ff, play_effect]\n- 调用者: lg2ff_init\n- 被调用者: 未显示\n\n7. 函数名: kfree\n- 参数: [lg2ff]\n- 调用者: lg2ff_init\n- 被调用者: 未显示\n\n8. 函数名: hid_hw_request\n- 参数: [hid, report, HID_REQ_SET_REPORT]\n- 调用者: lg2ff_init\n- 被调用者: 未显示\n\n9. 函数名: hid_info\n- 参数: [hid, \"Force feedback for Logitech variant 2 rumble devices by Anssi Hannula <anssi.hannula@gmail.com>\"]\n- 调用者: lg2ff_init\n- 被调用者: 未显示"
    },
    {
        "id": 2210,
        "cwe": "CWE-787",
        "cve": "CVE-2019-19532",
        "purpose": "Code purpose:\"\"\"初始化Logitech Flight System G940设备的力反馈功能，设置输入设备的力反馈位图并创建内存无关的力反馈处理机制。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证USB设备输入的ff_bits数组边界，导致可能发生越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: lg3ff_init\n- 参数: [struct hid_device *hid]\n- 调用者: 未显示\n- 被调用者: [list_entry, hid_validate_values, set_bit, input_ff_create_memless, test_bit, hid_info]\n\n2. 函数名: list_entry\n- 参数: [hid->inputs.next, struct hid_input, list]\n- 调用者: lg3ff_init\n- 被调用者: 未显示\n\n3. 函数名: hid_validate_values\n- 参数: [hid, HID_OUTPUT_REPORT, 0, 0, 35]\n- 调用者: lg3ff_init\n- 被调用者: 未显示\n\n4. 函数名: set_bit\n- 参数: [ff_bits[i], dev->ffbit]\n- 调用者: lg3ff_init\n- 被调用者: 未显示\n\n5. 函数名: input_ff_create_memless\n- 参数: [dev, NULL, hid_lg3ff_play]\n- 调用者: lg3ff_init\n- 被调用者: 未显示\n\n6. 函数名: test_bit\n- 参数: [FF_AUTOCENTER, dev->ffbit]\n- 调用者: lg3ff_init\n- 被调用者: 未显示\n\n7. 函数名: hid_info\n- 参数: [hid, \"Force feedback for Logitech Flight System G940 by Gary Stein <LordCnidarian@gmail.com>\\n\"]\n- 调用者: lg3ff_init\n- 被调用者: 未显示"
    },
    {
        "id": 2211,
        "cwe": "CWE-787",
        "cve": "CVE-2019-19532",
        "purpose": "Code purpose:\"\"\"初始化Logitech游戏方向盘设备的力反馈功能，包括多模式处理、设备属性设置和LED控制等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对USB设备输入进行充分验证，导致恶意USB设备可触发多个HID驱动程序的越界写入漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: lg4ff_init\n- 参数: [struct hid_device *hid]\n- 调用者: N/A (driver initialization)\n- 被调用者: [list_entry, hid_validate_values, hid_get_drvdata, kzalloc, spin_lock_init, lg4ff_handle_multimode_wheel, hid_err, dbg_hid, set_bit, input_ff_create_memless, lg4ff_init_wheel_data, test_bit, device_create_file, hid_warn, lg4ff_set_autocenter_ffex, lg4ff_set_autocenter_default, snprintf, led_classdev_register, led_classdev_unregister, kfree]\n\n2. 函数名: lg4ff_handle_multimode_wheel\n- 参数: [struct hid_device *hid, u16 *real_product_id, u16 bcdDevice]\n- 调用者: lg4ff_init\n- 被调用者: N/A (not visible in this snippet)\n\n3. 函数名: lg4ff_play\n- 参数: N/A (only referenced as callback)\n- 调用者: input_ff_create_memless\n- 被调用者: N/A\n\n4. 函数名: lg4ff_set_autocenter_ffex\n- 参数: N/A (only referenced as callback)\n- 调用者: dev->ff->set_autocenter\n- 被调用者: N/A\n\n5. 函数名: lg4ff_set_autocenter_default\n- 参数: N/A (only referenced as callback)\n- 调用者: dev->ff->set_autocenter\n- 被调用者: N/A\n\n6. 函数名: lg4ff_init_wheel_data\n- 参数: [struct lg4ff_wheel_data *wdata, const struct lg4ff_wheel *wheel, const struct lg4ff_multimode_wheel *mmode_wheel, u16 real_product_id]\n- 调用者: lg4ff_init\n- 被调用者: N/A\n\n7. 函数名: lg4ff_set_leds\n- 参数: [struct hid_device *hid, int value]\n- 调用者: lg4ff_init\n- 被调用者: N/A\n\n8. 函数名: lg4ff_led_get_brightness\n- 参数: N/A (only referenced as callback)\n- 调用者: led->brightness_get\n- 被调用者: N/A\n\n9. 函数名: lg4ff_led_set_brightness\n- 参数: N/A (only referenced as callback)\n- 调用者: led->brightness_set\n- 被调用者: N/A"
    },
    {
        "id": 2212,
        "cwe": "CWE-787",
        "cve": "CVE-2019-19532",
        "purpose": "Code purpose:\"\"\"初始化Logitech力反馈设备的输入设备并设置力反馈功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对ff_bits数组的索引进行边界检查，导致恶意USB设备可以触发越界写入漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: lgff_init\n- 参数: [struct hid_device* hid]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [list_entry, hid_validate_values, set_bit, input_ff_create_memless, test_bit, pr_info]\n\n2. 函数名: list_entry\n- 参数: [hid->inputs.next, struct hid_input, list]\n- 调用者: lgff_init\n- 被调用者: 未显示（可能是宏或内联函数）\n\n3. 函数名: hid_validate_values\n- 参数: [hid, HID_OUTPUT_REPORT, 0, 0, 7]\n- 调用者: lgff_init\n- 被调用者: 未显示\n\n4. 函数名: set_bit\n- 参数: [ff_bits[i], dev->ffbit]\n- 调用者: lgff_init\n- 被调用者: 未显示\n\n5. 函数名: input_ff_create_memless\n- 参数: [dev, NULL, hid_lgff_play]\n- 调用者: lgff_init\n- 被调用者: 未显示\n\n6. 函数名: test_bit\n- 参数: [FF_AUTOCENTER, dev->ffbit]\n- 调用者: lgff_init\n- 被调用者: 未显示\n\n7. 函数名: pr_info\n- 参数: [\"Force feedback for Logitech force feedback devices by Johann Deneux <johann.deneux@it.uu.se>\"]\n- 调用者: lgff_init\n- 被调用者: 未显示"
    },
    {
        "id": 2213,
        "cwe": "CWE-787",
        "cve": "CVE-2019-19532",
        "purpose": "Code purpose:\"\"\"该代码用于初始化HID设备的力反馈功能，包括设置反馈效果、创建反馈设备、分配内存资源以及配置相关参数和回调函数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理USB HID设备输入时，未充分验证设备返回的数据长度，导致可能发生越界写入漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: hidpp_ff_init\n- 参数: [struct hidpp_device *hidpp, u8 feature_index]\n- 调用者: 未显示\n- 被调用者: [list_entry, set_bit, hidpp_send_fap_command_sync, input_ff_create, kzalloc, kcalloc, create_singlethread_workqueue, kfree, get_unaligned_be16, device_create_file, atomic_set, hidpp_ff_set_autocenter]\n\n2. 函数名: list_entry\n- 参数: [hid->inputs.next, struct hid_input, list]\n- 调用者: hidpp_ff_init\n- 被调用者: 未显示\n\n3. 函数名: set_bit\n- 参数: [hidpp_ff_effects[j], dev->ffbit], [hidpp_ff_effects_v2[j], dev->ffbit]\n- 调用者: hidpp_ff_init\n- 被调用者: 未显示\n\n4. 函数名: hidpp_send_fap_command_sync\n- 参数: [hidpp, feature_index, HIDPP_FF_GET_INFO, NULL, 0, &response], [hidpp, feature_index, HIDPP_FF_RESET_ALL, NULL, 0, &response], [hidpp, feature_index, HIDPP_FF_GET_APERTURE, NULL, 0, &response], [hidpp, feature_index, HIDPP_FF_GET_GLOBAL_GAINS, NULL, 0, &response]\n- 调用者: hidpp_ff_init\n- 被调用者: 未显示\n\n5. 函数名: input_ff_create\n- 参数: [dev, num_slots]\n- 调用者: hidpp_ff_init\n- 被调用者: 未显示\n\n6. 函数名: kzalloc\n- 参数: [sizeof(*data), GFP_KERNEL]\n- 调用者: hidpp_ff_init\n- 被调用者: 未显示\n\n7. 函数名: kcalloc\n- 参数: [num_slots, sizeof(int), GFP_KERNEL]\n- 调用者: hidpp_ff_init\n- 被调用者: 未显示\n\n8. 函数名: create_singlethread_workqueue\n- 参数: [\"hidpp-ff-sendqueue\"]\n- 调用者: hidpp_ff_init\n- 被调用者: 未显示\n\n9. 函数名: kfree\n- 参数: [data], [data->effect_ids]\n- 调用者: hidpp_ff_init\n- 被调用者: 未显示\n\n10. 函数名: get_unaligned_be16\n- 参数: [&response.fap.params[0]]\n- 调用者: hidpp_ff_init\n- 被调用者: 未显示\n\n11. 函数名: device_create_file\n- 参数: [&(hidpp->hid_dev->dev), &dev_attr_range]\n- 调用者: hidpp_ff_init\n- 被调用者: 未显示\n\n12. 函数名: atomic_set\n- 参数: [&data->workqueue_size, 0]\n- 调用者: hidpp_ff_init\n- 被调用者: 未显示\n\n13. 函数名: hidpp_ff_set_autocenter\n- 参数: [dev, 0]\n- 调用者: hidpp_ff_init\n- 被调用者: 未显示"
    },
    {
        "id": 2214,
        "cwe": "CWE-787",
        "cve": "CVE-2019-19532",
        "purpose": "Code purpose:\"\"\"初始化微软设备力反馈功能，包括分配内存、设置输入设备能力并创建内存无关的力反馈效果\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于Linux内核HID驱动在处理恶意USB设备输入时缺乏对输出报告缓冲区大小的充分验证，导致可能发生越界写入漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: ms_init_ff\n- 参数: [struct hid_device *hdev]\n- 调用者: 未明确显示（应为HID驱动初始化相关代码）\n- 被调用者: [list_entry, hid_get_drvdata, INIT_WORK, devm_kzalloc, input_set_capability, input_ff_create_memless]\n\n2. 函数名: list_entry\n- 参数: [hdev->inputs.next, struct hid_input, list]\n- 调用者: ms_init_ff\n- 被调用者: []\n\n3. 函数名: hid_get_drvdata\n- 参数: [struct hid_device *hdev]\n- 调用者: ms_init_ff\n- 被调用者: []\n\n4. 函数名: INIT_WORK\n- 参数: [&ms->ff_worker, ms_ff_worker]\n- 调用者: ms_init_ff\n- 被调用者: []\n\n5. 函数名: devm_kzalloc\n- 参数: [&hdev->dev, sizeof(struct xb1s_ff_report), GFP_KERNEL]\n- 调用者: ms_init_ff\n- 被调用者: []\n\n6. 函数名: input_set_capability\n- 参数: [input_dev, EV_FF, FF_RUMBLE]\n- 调用者: ms_init_ff\n- 被调用者: []\n\n7. 函数名: input_ff_create_memless\n- 参数: [input_dev, NULL, ms_play_effect]\n- 调用者: ms_init_ff\n- 被调用者: []"
    },
    {
        "id": 2255,
        "cwe": "CWE-787",
        "cve": "CVE-2019-19816",
        "purpose": "Code purpose:\"\"\"该代码用于在btrfs文件系统中查找并返回与给定目录项(dentry)对应的inode，处理包括子卷在内的各种情况。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理Btrfs文件系统时，由于对数据条带数量为1的情况处理不当，导致在__btrfs_map_block函数中出现了slab越界写入访问。\"\"\"",
        "functions": "Functions:\n1. 函数名: btrfs_lookup_dentry\n- 参数: [dir, dentry]\n- 调用者: 未显示（通常由文件系统操作调用）\n- 被调用者: [btrfs_sb, BTRFS_I, ERR_PTR, btrfs_inode_by_name, btrfs_iget, srcu_read_lock, fixup_tree_root_location, new_simple_dir, srcu_read_unlock, IS_ERR, down_read, sb_rdonly, btrfs_orphan_cleanup, up_read, iput]\n\n2. 函数名: btrfs_sb\n- 参数: [i_sb]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n3. 函数名: BTRFS_I\n- 参数: [dir]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n4. 函数名: ERR_PTR\n- 参数: [error_code]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n5. 函数名: btrfs_inode_by_name\n- 参数: [dir, dentry, location]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n6. 函数名: btrfs_iget\n- 参数: [i_sb, location, root, NULL]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n7. 函数名: srcu_read_lock\n- 参数: [subvol_srcu]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n8. 函数名: fixup_tree_root_location\n- 参数: [fs_info, dir, dentry, location, sub_root]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n9. 函数名: new_simple_dir\n- 参数: [i_sb, location, sub_root]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n10. 函数名: srcu_read_unlock\n- 参数: [subvol_srcu, index]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n11. 函数名: IS_ERR\n- 参数: [inode]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n12. 函数名: down_read\n- 参数: [cleanup_work_sem]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n13. 函数名: sb_rdonly\n- 参数: [i_sb]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n14. 函数名: btrfs_orphan_cleanup\n- 参数: [sub_root]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n15. 函数名: up_read\n- 参数: [cleanup_work_sem]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []\n\n16. 函数名: iput\n- 参数: [inode]\n- 调用者: btrfs_lookup_dentry\n- 被调用者: []"
    },
    {
        "id": 2256,
        "cwe": "CWE-787",
        "cve": "CVE-2019-19816",
        "purpose": "Code purpose:\"\"\"该代码用于在Btrfs文件系统中获取指定范围的extent映射信息，处理常规、预分配和内联三种类型的extent，并管理extent映射树的查找、分配和插入操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理Btrfs文件系统镜像时，由于对数据条带数量为1的情况处理不当，导致在__btrfs_map_block函数中出现了slab越界写入访问。\"\"\"",
        "functions": "Functions:\n1. 函数名: btrfs_get_extent\n- 参数: [struct btrfs_inode *inode, struct page *page, size_t pg_offset, u64 start, u64 len, int create]\n- 调用者: N/A (顶层函数)\n- 被调用者: [lookup_extent_mapping, free_extent_map, alloc_extent_map, btrfs_alloc_path, btrfs_lookup_file_extent, btrfs_item_ptr, btrfs_item_key_to_cpu, btrfs_file_extent_type, btrfs_file_extent_num_bytes, trace_btrfs_get_extent_show_fi_regular, btrfs_file_extent_ram_bytes, ALIGN, trace_btrfs_get_extent_show_fi_inline, btrfs_next_leaf, btrfs_extent_item_to_extent_map, btrfs_file_extent_compression, uncompress_inline, kmap, read_extent_buffer, kunmap, flush_dcache_page, set_extent_uptodate, extent_map_end, btrfs_release_path, btrfs_err, btrfs_add_extent_mapping, btrfs_free_path, trace_btrfs_get_extent, free_extent_map]\n\n2. 函数名: lookup_extent_mapping\n- 参数: [struct extent_map_tree *em_tree, u64 start, u64 len]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n3. 函数名: free_extent_map\n- 参数: [struct extent_map *em]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n4. 函数名: alloc_extent_map\n- 参数: []\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n5. 函数名: btrfs_alloc_path\n- 参数: []\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n6. 函数名: btrfs_lookup_file_extent\n- 参数: [NULL, struct btrfs_root *root, struct btrfs_path *path, u64 objectid, u64 start, 0]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n7. 函数名: btrfs_item_ptr\n- 参数: [struct extent_buffer *leaf, int slot, struct btrfs_file_extent_item]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n8. 函数名: btrfs_item_key_to_cpu\n- 参数: [struct extent_buffer *leaf, struct btrfs_key *key, int slot]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n9. 函数名: btrfs_file_extent_type\n- 参数: [struct extent_buffer *leaf, struct btrfs_file_extent_item *item]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n10. 函数名: btrfs_file_extent_num_bytes\n- 参数: [struct extent_buffer *leaf, struct btrfs_file_extent_item *item]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n11. 函数名: trace_btrfs_get_extent_show_fi_regular\n- 参数: [struct btrfs_inode *inode, struct extent_buffer *leaf, struct btrfs_file_extent_item *item, u64 extent_start]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n12. 函数名: btrfs_file_extent_ram_bytes\n- 参数: [struct extent_buffer *leaf, struct btrfs_file_extent_item *item]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n13. 函数名: ALIGN\n- 参数: [u64 value, u64 alignment]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n14. 函数名: trace_btrfs_get_extent_show_fi_inline\n- 参数: [struct btrfs_inode *inode, struct extent_buffer *leaf, struct btrfs_file_extent_item *item, int slot, u64 extent_start]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n15. 函数名: btrfs_next_leaf\n- 参数: [struct btrfs_root *root, struct btrfs_path *path]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n16. 函数名: btrfs_extent_item_to_extent_map\n- 参数: [struct btrfs_inode *inode, struct btrfs_path *path, struct btrfs_file_extent_item *item, bool new_inline, struct extent_map *em]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n17. 函数名: btrfs_file_extent_compression\n- 参数: [struct extent_buffer *leaf, struct btrfs_file_extent_item *item]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n18. 函数名: uncompress_inline\n- 参数: [struct btrfs_path *path, struct page *page, size_t pg_offset, size_t extent_offset, struct btrfs_file_extent_item *item]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n19. 函数名: kmap\n- 参数: [struct page *page]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n20. 函数名: read_extent_buffer\n- 参数: [struct extent_buffer *eb, void *dst, unsigned long src, unsigned long len]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n21. 函数名: kunmap\n- 参数: [struct page *page]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n22. 函数名: flush_dcache_page\n- 参数: [struct page *page]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n23. 函数名: set_extent_uptodate\n- 参数: [struct extent_io_tree *tree, u64 start, u64 end, struct extent_state **cached, gfp_t mask]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n24. 函数名: extent_map_end\n- 参数: [struct extent_map *em]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n25. 函数名: btrfs_release_path\n- 参数: [struct btrfs_path *path]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n26. 函数名: btrfs_err\n- 参数: [struct btrfs_fs_info *fs_info, const char *fmt, ...]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n27. 函数名: btrfs_add_extent_mapping\n- 参数: [struct btrfs_fs_info *fs_info, struct extent_map_tree *em_tree, struct extent_map **em_inout, u64 start, u64 len]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n28. 函数名: btrfs_free_path\n- 参数: [struct btrfs_path *path]\n- 调用者: btrfs_get_extent\n- 被调用者: []\n\n29. 函数名: trace_btrfs_get_extent\n- 参数: [struct btrfs_root *root, struct btrfs_inode *inode, struct extent_map *em]\n- 调用者: btrfs_get_extent\n- 被调用者: []"
    },
    {
        "id": 2257,
        "cwe": "CWE-787",
        "cve": "CVE-2019-19816",
        "purpose": "Code purpose:\"\"\"测试btrfs文件系统中获取extent映射的功能，验证不同情况下extent的起始位置、长度、标志等属性是否正确\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理Btrfs文件系统镜像时，当数据条带数被设置为1时，__btrfs_map_block函数未能正确处理该边界情况，导致越界写入漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: test_btrfs_get_extent\n- 参数: [u32 sectorsize, u32 nodesize]\n- 调用者: N/A (测试函数)\n- 被调用者: [btrfs_new_test_inode, test_std_err, btrfs_alloc_dummy_fs_info, btrfs_alloc_dummy_root, alloc_dummy_extent_buffer, btrfs_set_header_nritems, btrfs_set_header_level, btrfs_get_extent, free_extent_map, btrfs_drop_extent_cache, setup_file_extents, iput, btrfs_free_dummy_root, btrfs_free_dummy_fs_info]\n\n2. 函数名: btrfs_new_test_inode\n- 参数: []\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n3. 函数名: test_std_err\n- 参数: [TEST_ALLOC_INODE/TEST_ALLOC_FS_INFO/TEST_ALLOC_ROOT]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n4. 函数名: btrfs_alloc_dummy_fs_info\n- 参数: [nodesize, sectorsize]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n5. 函数名: btrfs_alloc_dummy_root\n- 参数: [fs_info]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n6. 函数名: alloc_dummy_extent_buffer\n- 参数: [fs_info, nodesize]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n7. 函数名: btrfs_set_header_nritems\n- 参数: [root->node, 0]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n8. 函数名: btrfs_set_header_level\n- 参数: [root->node, 0]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n9. 函数名: btrfs_get_extent\n- 参数: [BTRFS_I(inode), NULL, 0, offset, sectorsize, 0] (多次调用参数不同)\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n10. 函数名: free_extent_map\n- 参数: [em]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n11. 函数名: btrfs_drop_extent_cache\n- 参数: [BTRFS_I(inode), 0, (u64)-1, 0]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n12. 函数名: setup_file_extents\n- 参数: [root, sectorsize]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n13. 函数名: iput\n- 参数: [inode]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n14. 函数名: btrfs_free_dummy_root\n- 参数: [root]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n15. 函数名: btrfs_free_dummy_fs_info\n- 参数: [fs_info]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n16. 函数名: test_err\n- 参数: [error message strings]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []\n\n17. 函数名: test_msg\n- 参数: [\"running btrfs_get_extent tests\"]\n- 调用者: test_btrfs_get_extent\n- 被调用者: []"
    },
    {
        "id": 2281,
        "cwe": "CWE-787",
        "cve": "CVE-2019-20636",
        "purpose": "Code purpose:\"\"\"该代码用于处理输入设备键码的设置，包括验证键码有效性、更新键位映射以及模拟按键释放事件。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证输入键码的有效性，导致在设置键码时可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: input_set_keycode\n- 参数: [struct input_dev *dev, const struct input_keymap_entry *ke]\n- 调用者: 未指定\n- 被调用者: [spin_lock_irqsave, dev->setkeycode, __clear_bit, test_bit, is_event_supported, __test_and_clear_bit, input_pass_values, spin_unlock_irqrestore]\n\n2. 函数名: spin_lock_irqsave\n- 参数: [&dev->event_lock, flags]\n- 调用者: input_set_keycode\n- 被调用者: 未指定\n\n3. 函数名: dev->setkeycode\n- 参数: [dev, ke, &old_keycode]\n- 调用者: input_set_keycode\n- 被调用者: 未指定\n\n4. 函数名: __clear_bit\n- 参数: [KEY_RESERVED, dev->keybit]\n- 调用者: input_set_keycode\n- 被调用者: 未指定\n\n5. 函数名: test_bit\n- 参数: [EV_KEY, dev->evbit]\n- 调用者: input_set_keycode\n- 被调用者: 未指定\n\n6. 函数名: is_event_supported\n- 参数: [old_keycode, dev->keybit, KEY_MAX]\n- 调用者: input_set_keycode\n- 被调用者: 未指定\n\n7. 函数名: __test_and_clear_bit\n- 参数: [old_keycode, dev->key]\n- 调用者: input_set_keycode\n- 被调用者: 未指定\n\n8. 函数名: input_pass_values\n- 参数: [dev, vals, ARRAY_SIZE(vals)]\n- 调用者: input_set_keycode\n- 被调用者: 未指定\n\n9. 函数名: spin_unlock_irqrestore\n- 参数: [&dev->event_lock, flags]\n- 调用者: input_set_keycode\n- 被调用者: 未指定"
    },
    {
        "id": 2282,
        "cwe": "CWE-787",
        "cve": "CVE-2019-20636",
        "purpose": "Code purpose:\"\"\"该代码用于处理输入设备键码的更新操作，包括验证键码范围、更新键码值以及维护键位映射关系。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证输入参数index的范围，导致在写入keycode时可能发生越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: input_default_setkeycode\n- 参数: [struct input_dev *dev, const struct input_keymap_entry *ke, unsigned int *old_keycode]\n- 调用者: N/A (顶层函数)\n- 被调用者: [input_scancode_to_scalar, __clear_bit, __set_bit, input_fetch_keycode]\n\n2. 函数名: input_scancode_to_scalar\n- 参数: [const struct input_keymap_entry *ke, unsigned int *index]\n- 调用者: input_default_setkeycode\n- 被调用者: N/A\n\n3. 函数名: __clear_bit\n- 参数: [unsigned int *old_keycode, dev->keybit]\n- 调用者: input_default_setkeycode\n- 被调用者: N/A\n\n4. 函数名: __set_bit\n- 参数: [ke->keycode, dev->keybit] 和 [*old_keycode, dev->keybit]\n- 调用者: input_default_setkeycode\n- 被调用者: N/A\n\n5. 函数名: input_fetch_keycode\n- 参数: [struct input_dev *dev, int i]\n- 调用者: input_default_setkeycode\n- 被调用者: N/A"
    },
    {
        "id": 2291,
        "cwe": "CWE-787",
        "cve": "CVE-2019-2181",
        "purpose": "Code purpose:\"\"\"处理Android内核中Binder进程间通信(IPC)的事务传输，包括数据复制、对象转换和错误处理等功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于整数溢出导致边界检查失效，从而可能造成越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_transaction\n- 参数: [struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply, binder_size_t extra_buffers_size]\n- 调用者: N/A (top-level function)\n- 被调用者: [binder_transaction_log_add, binder_inner_proc_lock, binder_inner_proc_unlock, binder_user_error, binder_set_nice, binder_get_txn_from_and_acq_inner, binder_proc_lock, binder_get_ref_olocked, binder_get_node_refs_for_txn, binder_proc_unlock, mutex_lock, mutex_unlock, security_binder_transaction, list_first_entry_or_null, atomic_inc_return, security_task_getsecid, security_secid_to_secctx, binder_alloc_new_buf, security_release_secctx, binder_alloc_copy_to_buffer, binder_alloc_copy_user_to_buffer, binder_get_object, binder_translate_binder, binder_translate_handle, binder_translate_fd, binder_validate_ptr, binder_validate_fixup, binder_translate_fd_array, binder_fixup_parent, binder_enqueue_thread_work, binder_pop_transaction_ilocked, binder_enqueue_thread_work_ilocked, wake_up_interruptible_sync, binder_free_transaction, binder_enqueue_deferred_thread_work_ilocked, binder_proc_transaction, binder_pop_transaction_ilocked, binder_thread_dec_tmpref, binder_proc_dec_tmpref, binder_dec_node_tmpref, binder_dec_node, binder_dequeue_work, binder_free_txn_fixups, binder_transaction_buffer_release, binder_alloc_free_buf, kfree, binder_stats_deleted, binder_debug, binder_send_failed_reply]\n\n2. 函数名: binder_transaction_log_add\n- 参数: [struct binder_transaction_log *log]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n3. 函数名: binder_inner_proc_lock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n4. 函数名: binder_inner_proc_unlock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n5. 函数名: binder_user_error\n- 参数: [const char *fmt, ...]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n6. 函数名: binder_set_nice\n- 参数: [long nice]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n7. 函数名: binder_get_txn_from_and_acq_inner\n- 参数: [struct binder_transaction *t]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n8. 函数名: binder_proc_lock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n9. 函数名: binder_get_ref_olocked\n- 参数: [struct binder_proc *proc, uint32_t desc, bool need_strong_ref]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n10. 函数名: binder_get_node_refs_for_txn\n- 参数: [struct binder_node *node, struct binder_proc **procp, uint32_t *error]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n11. 函数名: binder_proc_unlock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n12. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n13. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n14. 函数名: security_binder_transaction\n- 参数: [struct task_struct *from, struct task_struct *to]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n15. 函数名: list_first_entry_or_null\n- 参数: [struct list_head *head, size_t size, int member]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n16. 函数名: atomic_inc_return\n- 参数: [atomic_t *v]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n17. 函数名: security_task_getsecid\n- 参数: [struct task_struct *p, u32 *secid]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n18. 函数名: security_secid_to_secctx\n- 参数: [u32 secid, char **secdata, u32 *seclen]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n19. 函数名: binder_alloc_new_buf\n- 参数: [struct binder_alloc *alloc, size_t data_size, size_t offsets_size, size_t extra_buffers_size, int is_async]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n20. 函数名: security_release_secctx\n- 参数: [char *secdata, u32 seclen]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n21. 函数名: binder_alloc_copy_to_buffer\n- 参数: [struct binder_alloc *alloc, struct binder_buffer *buffer, binder_size_t buffer_offset, const void *from, size_t bytes]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n22. 函数名: binder_alloc_copy_user_to_buffer\n- 参数: [struct binder_alloc *alloc, struct binder_buffer *buffer, binder_size_t buffer_offset, const void __user *from, size_t bytes]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n23. 函数名: binder_get_object\n- 参数: [struct binder_proc *proc, struct binder_buffer *buffer, binder_size_t offset, struct binder_object *object]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n24. 函数名: binder_translate_binder\n- 参数: [struct flat_binder_object *fp, struct binder_transaction *t, struct binder_thread *thread]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n25. 函数名: binder_translate_handle\n- 参数: [struct flat_binder_object *fp, struct binder_transaction *t, struct binder_thread *thread]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n26. 函数名: binder_translate_fd\n- 参数: [int fd, binder_size_t fd_offset, struct binder_transaction *t, struct binder_thread *thread, struct binder_transaction *in_reply_to]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n27. 函数名: binder_validate_ptr\n- 参数: [struct binder_proc *proc, struct binder_buffer *buffer, struct binder_object *object, binder_size_t ptr, binder_size_t off_start_offset, binder_size_t *offp, size_t num_valid]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n28. 函数名: binder_validate_fixup\n- 参数: [struct binder_proc *proc, struct binder_buffer *buffer, binder_size_t off_start_offset, binder_size_t object_offset, binder_size_t fixup_offset, binder_size_t last_obj_offset, binder_size_t last_min_offset]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n29. 函数名: binder_translate_fd_array\n- 参数: [struct binder_fd_array_object *fda, struct binder_buffer_object *parent, struct binder_transaction *t, struct binder_thread *thread, struct binder_transaction *in_reply_to]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n30. 函数名: binder_fixup_parent\n- 参数: [struct binder_transaction *t, struct binder_thread *thread, struct binder_buffer_object *bp, binder_size_t off_start_offset, size_t num_valid, binder_size_t last_obj_offset, binder_size_t last_min_offset]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n31. 函数名: binder_enqueue_thread_work\n- 参数: [struct binder_thread *thread, struct binder_work *work]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n32. 函数名: binder_pop_transaction_ilocked\n- 参数: [struct binder_thread *thread, struct binder_transaction *t]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n33. 函数名: binder_enqueue_thread_work_ilocked\n- 参数: [struct binder_thread *thread, struct binder_work *work]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n34. 函数名: wake_up_interruptible_sync\n- 参数: [wait_queue_head_t *q]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n35. 函数名: binder_free_transaction\n- 参数: [struct binder_transaction *t]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n36. 函数名: binder_enqueue_deferred_thread_work_ilocked\n- 参数: [struct binder_thread *thread, struct binder_work *work]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n37. 函数名: binder_proc_transaction\n- 参数: [struct binder_transaction *t, struct binder_proc *target_proc, struct binder_thread *target_thread]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n38. 函数名: binder_thread_dec_tmpref\n- 参数: [struct binder_thread *thread]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n39. 函数名: binder_proc_dec_tmpref\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n40. 函数名: binder_dec_node_tmpref\n- 参数: [struct binder_node *node]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n41. 函数名: binder_dec_node\n- 参数: [struct binder_node *node, int strong, int internal]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n42. 函数名: binder_dequeue_work\n- 参数: [struct binder_proc *proc, struct binder_work *work]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n43. 函数名: binder_free_txn_fixups\n- 参数: [struct binder_transaction *t]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n44. 函数名: binder_transaction_buffer_release\n- 参数: [struct binder_proc *proc, struct binder_buffer *buffer, binder_size_t off_end_offset, bool update_page_count]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n45. 函数名: binder_alloc_free_buf\n- 参数: [struct binder_alloc *alloc, struct binder_buffer *buffer]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n46. 函数名: kfree\n- 参数: [const void *x]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n47. 函数名: binder_stats_deleted\n- 参数: [enum binder_stat_types type]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n48. 函数名: binder_debug\n- 参数: [int id, const char *fmt, ...]\n- 调用者: binder_transaction\n- 被调用者: N/A\n\n49. 函数名: binder_send_failed_reply\n- 参数: [struct binder_transaction *t, uint32_t error_code]\n- 调用者: binder_transaction\n- 被调用者: N/A"
    },
    {
        "id": 2296,
        "cwe": "CWE-787",
        "cve": "CVE-2019-2214",
        "purpose": "Code purpose:\"\"\"处理Android Binder驱动中的进程间通信事务，包括事务的创建、数据传输、对象转换和错误处理等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在binder_transaction函数中处理BINDER_TYPE_FDA类型对象时，缺少对父缓冲区偏移量的有效边界检查，导致可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_transaction\n- 参数: [struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply, binder_size_t extra_buffers_size]\n- 调用者: N/A (top-level function)\n- 被调用者: [binder_transaction_log_add, binder_inner_proc_lock, binder_inner_proc_unlock, binder_user_error, binder_set_nice, binder_get_txn_from_and_acq_inner, binder_proc_lock, binder_get_ref_olocked, binder_get_node_refs_for_txn, binder_proc_unlock, mutex_lock, mutex_unlock, security_binder_transaction, list_first_entry_or_null, atomic_inc_return, binder_alloc_new_buf, binder_alloc_copy_to_buffer, binder_alloc_copy_user_to_buffer, binder_get_object, binder_translate_binder, binder_translate_handle, binder_translate_fd, binder_validate_ptr, binder_validate_fixup, binder_translate_fd_array, binder_fixup_parent, binder_enqueue_thread_work, binder_pop_transaction_ilocked, binder_enqueue_thread_work_ilocked, wake_up_interruptible_sync, binder_free_transaction, binder_enqueue_deferred_thread_work_ilocked, binder_proc_transaction, binder_pop_transaction_ilocked, binder_thread_dec_tmpref, binder_proc_dec_tmpref, binder_dec_node_tmpref, binder_dec_node, binder_free_txn_fixups, binder_transaction_buffer_release, binder_alloc_free_buf, security_release_secctx, kfree, binder_stats_deleted, binder_debug, binder_send_failed_reply]\n\n2. 函数名: binder_transaction_log_add\n- 参数: [struct binder_transaction_log *log]\n- 调用者: binder_transaction\n- 被调用者: []\n\n3. 函数名: binder_inner_proc_lock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_transaction\n- 被调用者: []\n\n4. 函数名: binder_inner_proc_unlock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_transaction\n- 被调用者: []\n\n5. 函数名: binder_user_error\n- 参数: [const char *fmt, ...]\n- 调用者: binder_transaction\n- 被调用者: []\n\n6. 函数名: binder_set_nice\n- 参数: [long nice]\n- 调用者: binder_transaction\n- 被调用者: []\n\n7. 函数名: binder_get_txn_from_and_acq_inner\n- 参数: [struct binder_transaction *t]\n- 调用者: binder_transaction\n- 被调用者: []\n\n8. 函数名: binder_proc_lock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_transaction\n- 被调用者: []\n\n9. 函数名: binder_get_ref_olocked\n- 参数: [struct binder_proc *proc, uint32_t desc, bool need_strong_ref]\n- 调用者: binder_transaction\n- 被调用者: []\n\n10. 函数名: binder_get_node_refs_for_txn\n- 参数: [struct binder_node *node, struct binder_proc **procp, uint32_t *error]\n- 调用者: binder_transaction\n- 被调用者: []\n\n11. 函数名: binder_proc_unlock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_transaction\n- 被调用者: []\n\n12. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: binder_transaction\n- 被调用者: []\n\n13. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: binder_transaction\n- 被调用者: []\n\n14. 函数名: security_binder_transaction\n- 参数: [struct task_struct *from, struct task_struct *to]\n- 调用者: binder_transaction\n- 被调用者: []\n\n15. 函数名: list_first_entry_or_null\n- 参数: [struct list_head *head, type, member]\n- 调用者: binder_transaction\n- 被调用者: []\n\n16. 函数名: atomic_inc_return\n- 参数: [atomic_t *v]\n- 调用者: binder_transaction\n- 被调用者: []\n\n17. 函数名: binder_alloc_new_buf\n- 参数: [struct binder_alloc *alloc, size_t data_size, size_t offsets_size, size_t extra_buffers_size, int is_async]\n- 调用者: binder_transaction\n- 被调用者: []\n\n18. 函数名: binder_alloc_copy_to_buffer\n- 参数: [struct binder_alloc *alloc, struct binder_buffer *buffer, binder_size_t buffer_offset, const void *from, size_t bytes]\n- 调用者: binder_transaction\n- 被调用者: []\n\n19. 函数名: binder_alloc_copy_user_to_buffer\n- 参数: [struct binder_alloc *alloc, struct binder_buffer *buffer, binder_size_t buffer_offset, const void __user *from, size_t bytes]\n- 调用者: binder_transaction\n- 被调用者: []\n\n20. 函数名: binder_get_object\n- 参数: [struct binder_proc *proc, struct binder_buffer *buffer, binder_size_t offset, struct binder_object *object]\n- 调用者: binder_transaction\n- 被调用者: []\n\n21. 函数名: binder_translate_binder\n- 参数: [struct flat_binder_object *fp, struct binder_transaction *t, struct binder_thread *thread]\n- 调用者: binder_transaction\n- 被调用者: []\n\n22. 函数名: binder_translate_handle\n- 参数: [struct flat_binder_object *fp, struct binder_transaction *t, struct binder_thread *thread]\n- 调用者: binder_transaction\n- 被调用者: []\n\n23. 函数名: binder_translate_fd\n- 参数: [int fd, binder_size_t fd_offset, struct binder_transaction *t, struct binder_thread *thread, struct binder_transaction *in_reply_to]\n- 调用者: binder_transaction\n- 被调用者: []\n\n24. 函数名: binder_validate_ptr\n- 参数: [struct binder_proc *proc, struct binder_buffer *buffer, struct binder_object *object, binder_size_t offset, binder_size_t off_start_offset, binder_size_t *offp, size_t num_valid]\n- 调用者: binder_transaction\n- 被调用者: []\n\n25. 函数名: binder_validate_fixup\n- 参数: [struct binder_proc *proc, struct binder_buffer *buffer, binder_size_t off_start_offset, binder_size_t object_offset, binder_size_t fixup_offset, binder_size_t last_obj_offset, binder_size_t last_min_offset]\n- 调用者: binder_transaction\n- 被调用者: []\n\n26. 函数名: binder_translate_fd_array\n- 参数: [struct binder_fd_array_object *fda, struct binder_buffer_object *parent, struct binder_transaction *t, struct binder_thread *thread, struct binder_transaction *in_reply_to]\n- 调用者: binder_transaction\n- 被调用者: []\n\n27. 函数名: binder_fixup_parent\n- 参数: [struct binder_transaction *t, struct binder_thread *thread, struct binder_buffer_object *bp, binder_size_t off_start_offset, size_t num_valid, binder_size_t last_obj_offset, binder_size_t last_min_offset]\n- 调用者: binder_transaction\n- 被调用者: []\n\n28. 函数名: binder_enqueue_thread_work\n- 参数: [struct binder_thread *thread, struct binder_work *work]\n- 调用者: binder_transaction\n- 被调用者: []\n\n29. 函数名: binder_pop_transaction_ilocked\n- 参数: [struct binder_thread *thread, struct binder_transaction *t]\n- 调用者: binder_transaction\n- 被调用者: []\n\n30. 函数名: binder_enqueue_thread_work_ilocked\n- 参数: [struct binder_thread *thread, struct binder_work *work]\n- 调用者: binder_transaction\n- 被调用者: []\n\n31. 函数名: wake_up_interruptible_sync\n- 参数: [wait_queue_head_t *q]\n- 调用者: binder_transaction\n- 被调用者: []\n\n32. 函数名: binder_free_transaction\n- 参数: [struct binder_transaction *t]\n- 调用者: binder_transaction\n- 被调用者: []\n\n33. 函数名: binder_enqueue_deferred_thread_work_ilocked\n- 参数: [struct binder_thread *thread, struct binder_work *work]\n- 调用者: binder_transaction\n- 被调用者: []\n\n34. 函数名: binder_proc_transaction\n- 参数: [struct binder_transaction *t, struct binder_proc *target_proc, struct binder_thread *target_thread]\n- 调用者: binder_transaction\n- 被调用者: []\n\n35. 函数名: binder_thread_dec_tmpref\n- 参数: [struct binder_thread *thread]\n- 调用者: binder_transaction\n- 被调用者: []\n\n36. 函数名: binder_proc_dec_tmpref\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_transaction\n- 被调用者: []\n\n37. 函数名: binder_dec_node_tmpref\n- 参数: [struct binder_node *node]\n- 调用者: binder_transaction\n- 被调用者: []\n\n38. 函数名: binder_dec_node\n- 参数: [struct binder_node *node, int strong, int internal]\n- 调用者: binder_transaction\n- 被调用者: []\n\n39. 函数名: binder_free_txn_fixups\n- 参数: [struct binder_transaction *t]\n- 调用者: binder_transaction\n- 被调用者: []\n\n40. 函数名: binder_transaction_buffer_release\n- 参数: [struct binder_proc *proc, struct binder_buffer *buffer, binder_size_t off_end_offset, bool is_failure]\n- 调用者: binder_transaction\n- 被调用者: []\n\n41. 函数名: binder_alloc_free_buf\n- 参数: [struct binder_alloc *alloc, struct binder_buffer *buffer]\n- 调用者: binder_transaction\n- 被调用者: []\n\n42. 函数名: security_release_secctx\n- 参数: [char *secctx, u32 secctx_sz]\n- 调用者: binder_transaction\n- 被调用者: []\n\n43. 函数名: kfree\n- 参数: [const void *x]\n- 调用者: binder_transaction\n- 被调用者: []\n\n44. 函数名: binder_stats_deleted\n- 参数: [enum binder_stat_types type]\n- 调用者: binder_transaction\n- 被调用者: []\n\n45. 函数名: binder_debug\n- 参数: [int mask, const char *format, ...]\n- 调用者: binder_transaction\n- 被调用者: []\n\n46. 函数名: binder_send_failed_reply\n- 参数: [struct binder_transaction *t, uint32_t error_code]\n- 调用者: binder_transaction\n- 被调用者: []"
    },
    {
        "id": 2310,
        "cwe": "CWE-787",
        "cve": "CVE-2019-3701",
        "purpose": "Code purpose:\"\"\"处理CAN网关接收到的数据帧，包括跳数限制检查、帧修改和转发功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺少对can_dlc字段的边界检查，特权用户可通过创建修改规则使数据长度码超过实际CAN帧数据大小，导致越界写入破坏skb尾部结构\"\"\"",
        "functions": "Functions:\n1. 函数名: can_can_gw_rcv\n- 参数: [struct sk_buff *skb, void *data]\n- 调用者: 未明确（由CAN网关框架调用）\n- 被调用者: [skb_copy, skb_clone, can_send]\n\n2. 函数名: skb_copy\n- 参数: [struct sk_buff *skb, gfp_t priority]\n- 调用者: can_can_gw_rcv\n- 被调用者: []\n\n3. 函数名: skb_clone\n- 参数: [struct sk_buff *skb, gfp_t priority]\n- 调用者: can_can_gw_rcv\n- 被调用者: []\n\n4. 函数名: can_send\n- 参数: [struct sk_buff *skb, int echo]\n- 调用者: can_can_gw_rcv\n- 被调用者: []\n\n5. 函数名: can_skb_prv\n- 参数: [struct sk_buff *skb]\n- 调用者: can_can_gw_rcv\n- 被调用者: []\n\n6. 函数名: BUG_ON\n- 参数: [condition]\n- 调用者: can_can_gw_rcv\n- 被调用者: []"
    },
    {
        "id": 2348,
        "cwe": "CWE-787",
        "cve": "CVE-2019-8956",
        "purpose": "Code purpose:\"\"\"该代码实现了SCTP协议中发送消息的功能，包括解析消息、查找或创建关联、检查发送标志，并将消息发送到指定的关联或所有关联(当设置SCTP_SENDALL标志时)。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Linux内核处理SCTP_SENDALL标志时，sctp_sendmsg()函数中存在释放后使用(UAF)错误，导致内存损坏。\"\"\"",
        "functions": "Functions:\n1. 函数名: sctp_sendmsg\n- 参数: [struct sock *sk, struct msghdr *msg, size_t msg_len]\n- 调用者: 外部调用\n- 被调用者: [sctp_sendmsg_parse, sctp_sendmsg_get_daddr, sctp_style, sctp_sendmsg_check_sflags, sctp_sendmsg_update_sinfo, sctp_sendmsg_to_asoc, iov_iter_revert, sctp_endpoint_lookup_assoc, sctp_sendmsg_new_asoc, sctp_id2assoc, sctp_association_free, release_sock, sctp_error]\n\n2. 函数名: sctp_sendmsg_parse\n- 参数: [struct sock *sk, struct sctp_cmsgs *cmsgs, struct sctp_sndrcvinfo *_sinfo, struct msghdr *msg, size_t msg_len]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n3. 函数名: sctp_sendmsg_get_daddr\n- 参数: [struct sock *sk, struct msghdr *msg, struct sctp_cmsgs *cmsgs]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n4. 函数名: sctp_style\n- 参数: [struct sock *sk, int style]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n5. 函数名: sctp_sendmsg_check_sflags\n- 参数: [struct sctp_association *asoc, __u16 sflags, struct msghdr *msg, size_t msg_len]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n6. 函数名: sctp_sendmsg_update_sinfo\n- 参数: [struct sctp_association *asoc, struct sctp_sndrcvinfo *sinfo, struct sctp_cmsgs *cmsgs]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n7. 函数名: sctp_sendmsg_to_asoc\n- 参数: [struct sctp_association *asoc, struct msghdr *msg, size_t msg_len, struct sctp_transport *transport, struct sctp_sndrcvinfo *sinfo]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n8. 函数名: iov_iter_revert\n- 参数: [struct iov_iter *i, size_t unrolled]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n9. 函数名: sctp_endpoint_lookup_assoc\n- 参数: [struct sctp_endpoint *ep, union sctp_addr *daddr, struct sctp_transport **transport]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n10. 函数名: sctp_sendmsg_new_asoc\n- 参数: [struct sock *sk, __u16 sflags, struct sctp_cmsgs *cmsgs, union sctp_addr *daddr, struct sctp_transport **transport]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n11. 函数名: sctp_id2assoc\n- 参数: [struct sock *sk, sctp_assoc_t id]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n12. 函数名: sctp_association_free\n- 参数: [struct sctp_association *asoc]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n13. 函数名: release_sock\n- 参数: [struct sock *sk]\n- 调用者: sctp_sendmsg\n- 被调用者: []\n\n14. 函数名: sctp_error\n- 参数: [struct sock *sk, int flags, int err]\n- 调用者: sctp_sendmsg\n- 被调用者: []"
    },
    {
        "id": 2352,
        "cwe": "CWE-787",
        "cve": "CVE-2019-9162",
        "purpose": "Code purpose:\"\"\"验证SNMP协议版本号是否有效，仅接受0或1作为有效版本号\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"SNMP NAT模块中的snmp_version函数对ASN.1长度检查不足，导致可能发生数组越界读写操作\"\"\"",
        "functions": "Functions:\n1. 函数名: snmp_version\n- 参数: [context, hdrlen, tag, data, datalen]\n- 调用者: 未明确（由SNMP NAT模块调用）\n- 被调用者: []"
    },
    {
        "id": 2353,
        "cwe": "CWE-787",
        "cve": "CVE-2019-9162",
        "purpose": "Code purpose:\"\"\"该代码片段是Linux内核中SNMP NAT模块的一部分，用于处理SNMP协议数据包的地址转换，将源IP地址(ctx->from)替换为目标IP地址(ctx->to)。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺乏对ASN.1数据长度的充分检查，导致在SNMP NAT模块中可能发生越界读写操作\"\"\"",
        "functions": "Functions:\n1. 函数名: snmp_helper\n- 参数: [void *context, size_t hdrlen, unsigned char tag, const void *data, size_t datalen]\n- 调用者: 未明确显示（应为SNMP NAT模块相关调用）\n- 被调用者: [pr_debug, fast_csum]\n\n2. 函数名: pr_debug\n- 参数: [const char *fmt, ...]（变参函数）\n- 调用者: snmp_helper\n- 被调用者: []\n\n3. 函数名: fast_csum\n- 参数: [struct snmp_ctx *ctx, unsigned char *data]\n- 调用者: snmp_helper\n- 被调用者: []"
    },
    {
        "id": 2360,
        "cwe": "CWE-787",
        "cve": "CVE-2019-9456",
        "purpose": "Code purpose:\"\"\"该代码用于从USB监控驱动中读取文本格式的事件数据并传输到用户空间缓冲区\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺少对ptr.cnt的边界检查，导致在snprintf操作时可能发生缓冲区溢出，造成越界写入漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: mon_text_read_u\n- 参数: [file, buf, nbytes, ppos]\n- 调用者: 未显示\n- 被调用者: [mon_text_read_wait, mutex_lock, mon_text_read_head_u, mon_text_read_statset, mon_text_read_isostat, mon_text_read_isodesc, mon_text_read_intstat, snprintf, mon_text_read_data, copy_to_user, mutex_unlock, kmem_cache_free]\n\n2. 函数名: mon_text_read_wait\n- 参数: [rp, file]\n- 调用者: mon_text_read_u\n- 被调用者: 未显示\n\n3. 函数名: mon_text_read_head_u\n- 参数: [rp, ptr, ep]\n- 调用者: mon_text_read_u\n- 被调用者: 未显示\n\n4. 函数名: mon_text_read_statset\n- 参数: [rp, ptr, ep]\n- 调用者: mon_text_read_u\n- 被调用者: 未显示\n\n5. 函数名: mon_text_read_isostat\n- 参数: [rp, ptr, ep]\n- 调用者: mon_text_read_u\n- 被调用者: 未显示\n\n6. 函数名: mon_text_read_isodesc\n- 参数: [rp, ptr, ep]\n- 调用者: mon_text_read_u\n- 被调用者: 未显示\n\n7. 函数名: mon_text_read_intstat\n- 参数: [rp, ptr, ep]\n- 调用者: mon_text_read_u\n- 被调用者: 未显示\n\n8. 函数名: mon_text_read_data\n- 参数: [rp, ptr, ep]\n- 调用者: mon_text_read_u\n- 被调用者: 未显示"
    },
    {
        "id": 2361,
        "cwe": "CWE-787",
        "cve": "CVE-2019-9456",
        "purpose": "Code purpose:\"\"\"该代码用于从USB监控驱动中读取文本格式的事件数据并将其复制到用户空间缓冲区\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺少对ptr.cnt的边界检查，可能导致snprintf操作时超出缓冲区rp->printf_buf的边界，造成越界写入漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: mon_text_read_t\n- 参数: [file, buf, nbytes, ppos]\n- 调用者: 未显示（由文件操作结构调用）\n- 被调用者: [mon_text_read_wait, IS_ERR, PTR_ERR, mutex_lock, mon_text_read_head_t, mon_text_read_statset, snprintf, mon_text_read_data, copy_to_user, mutex_unlock, kmem_cache_free]\n\n2. 函数名: mon_text_read_wait\n- 参数: [rp, file]\n- 调用者: mon_text_read_t\n- 被调用者: 未显示\n\n3. 函数名: IS_ERR\n- 参数: [ep]\n- 调用者: mon_text_read_t\n- 被调用者: 未显示\n\n4. 函数名: PTR_ERR\n- 参数: [ep]\n- 调用者: mon_text_read_t\n- 被调用者: 未显示\n\n5. 函数名: mutex_lock\n- 参数: [&rp->printf_lock]\n- 调用者: mon_text_read_t\n- 被调用者: 未显示\n\n6. 函数名: mon_text_read_head_t\n- 参数: [rp, &ptr, ep]\n- 调用者: mon_text_read_t\n- 被调用者: 未显示\n\n7. 函数名: mon_text_read_statset\n- 参数: [rp, &ptr, ep]\n- 调用者: mon_text_read_t\n- 被调用者: 未显示\n\n8. 函数名: snprintf\n- 参数: [ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt, \" %d\", ep->length]\n- 调用者: mon_text_read_t\n- 被调用者: 未显示\n\n9. 函数名: mon_text_read_data\n- 参数: [rp, &ptr, ep]\n- 调用者: mon_text_read_t\n- 被调用者: 未显示\n\n10. 函数名: copy_to_user\n- 参数: [buf, rp->printf_buf, ptr.cnt]\n- 调用者: mon_text_read_t\n- 被调用者: 未显示\n\n11. 函数名: mutex_unlock\n- 参数: [&rp->printf_lock]\n- 调用者: mon_text_read_t\n- 被调用者: 未显示\n\n12. 函数名: kmem_cache_free\n- 参数: [rp->e_slab, ep]\n- 调用者: mon_text_read_t\n- 被调用者: 未显示"
    },
    {
        "id": 2365,
        "cwe": "CWE-787",
        "cve": "CVE-2019-9500",
        "purpose": "Code purpose:\"\"\"处理无线局域网唤醒功能中的网络检测结果，包括验证事件数据、提取网络信息并更新配置\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理恶意构造的WiFi事件帧时，brcmf_wowl_nd_results函数未充分验证netinfo->SSID_len的长度，导致堆缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: brcmf_wowl_nd_results\n- 参数: [ifp, e, data]\n- 调用者: 未显示（由事件处理机制调用）\n- 被调用者: [brcmf_dbg, le32_to_cpu, brcmf_get_netinfo_array, memcpy, ieee80211_channel_to_frequency, wake_up]\n\n2. 函数名: brcmf_dbg\n- 参数: [SCAN, format string, ...]\n- 调用者: brcmf_wowl_nd_results\n- 被调用者: []\n\n3. 函数名: le32_to_cpu\n- 参数: [pfn_result->count]\n- 调用者: brcmf_wowl_nd_results\n- 被调用者: []\n\n4. 函数名: brcmf_get_netinfo_array\n- 参数: [pfn_result]\n- 调用者: brcmf_wowl_nd_results\n- 被调用者: []\n\n5. 函数名: memcpy\n- 参数: [cfg->wowl.nd->ssid.ssid, netinfo->SSID, netinfo->SSID_len]\n- 调用者: brcmf_wowl_nd_results\n- 被调用者: []\n\n6. 函数名: ieee80211_channel_to_frequency\n- 参数: [netinfo->channel, NL80211_BAND_2GHZ/NL80211_BAND_5GHZ]\n- 调用者: brcmf_wowl_nd_results\n- 被调用者: []\n\n7. 函数名: wake_up\n- 参数: [&cfg->wowl.nd_data_wait]\n- 调用者: brcmf_wowl_nd_results\n- 被调用者: []"
    },
    {
        "id": 2374,
        "cwe": "CWE-787",
        "cve": "CVE-2020-0066",
        "purpose": "Code purpose:\"\"\"该代码实现了netlink套接字的数据转储功能，处理网络链接消息的接收和发送，并包含回调机制用于数据处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于netlink驱动中存在竞态条件，导致可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: netlink_dump\n- 参数: [struct sock *sk]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [nlk_sk, max_t, netlink_rx_is_mmaped, atomic_read, netlink_alloc_skb, skb_reserve, netlink_skb_set_owner_r, sk_filter, kfree_skb, __netlink_sendskb, nlmsg_put_answer, nl_dump_check_consistent, memcpy, module_put, consume_skb, mutex_lock, mutex_unlock]\n\n2. 函数名: nlk_sk\n- 参数: [struct sock *sk]\n- 调用者: netlink_dump\n- 被调用者: []\n\n3. 函数名: max_t\n- 参数: [int, cb->min_dump_alloc, NLMSG_GOODSIZE]\n- 调用者: netlink_dump\n- 被调用者: []\n\n4. 函数名: netlink_rx_is_mmaped\n- 参数: [struct sock *sk]\n- 调用者: netlink_dump\n- 被调用者: []\n\n5. 函数名: atomic_read\n- 参数: [&sk->sk_rmem_alloc]\n- 调用者: netlink_dump\n- 被调用者: []\n\n6. 函数名: netlink_alloc_skb\n- 参数: [struct sock *sk, nlk->max_recvmsg_len, nlk->portid, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY] 和 [struct sock *sk, alloc_size, nlk->portid, GFP_KERNEL]\n- 调用者: netlink_dump\n- 被调用者: []\n\n7. 函数名: skb_reserve\n- 参数: [struct sk_buff *skb, skb_tailroom(skb) - nlk->max_recvmsg_len]\n- 调用者: netlink_dump\n- 被调用者: []\n\n8. 函数名: netlink_skb_set_owner_r\n- 参数: [struct sk_buff *skb, struct sock *sk]\n- 调用者: netlink_dump\n- 被调用者: []\n\n9. 函数名: sk_filter\n- 参数: [struct sock *sk, struct sk_buff *skb]\n- 调用者: netlink_dump\n- 被调用者: []\n\n10. 函数名: kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: netlink_dump\n- 被调用者: []\n\n11. 函数名: __netlink_sendskb\n- 参数: [struct sock *sk, struct sk_buff *skb]\n- 调用者: netlink_dump\n- 被调用者: []\n\n12. 函数名: nlmsg_put_answer\n- 参数: [struct sk_buff *skb, cb, NLMSG_DONE, sizeof(len), NLM_F_MULTI]\n- 调用者: netlink_dump\n- 被调用者: []\n\n13. 函数名: nl_dump_check_consistent\n- 参数: [cb, nlh]\n- 调用者: netlink_dump\n- 被调用者: []\n\n14. 函数名: memcpy\n- 参数: [nlmsg_data(nlh), &len, sizeof(len)]\n- 调用者: netlink_dump\n- 被调用者: []\n\n15. 函数名: module_put\n- 参数: [cb->module]\n- 调用者: netlink_dump\n- 被调用者: []\n\n16. 函数名: consume_skb\n- 参数: [cb->skb]\n- 调用者: netlink_dump\n- 被调用者: []\n\n17. 函数名: mutex_lock\n- 参数: [nlk->cb_mutex]\n- 调用者: netlink_dump\n- 被调用者: []\n\n18. 函数名: mutex_unlock\n- 参数: [nlk->cb_mutex]\n- 调用者: netlink_dump\n- 被调用者: []"
    },
    {
        "id": 2381,
        "cwe": "CWE-787",
        "cve": "CVE-2020-0429",
        "purpose": "Code purpose:\"\"\"关闭指定隧道中的所有L2TP会话并释放相关资源\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放会话资源后仍可能通过回调函数访问已释放的内存，导致释放后重用漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: l2tp_tunnel_closeall\n- 参数: [struct l2tp_tunnel *tunnel]\n- 调用者: 未显示\n- 被调用者: [BUG_ON, l2tp_info, write_lock_bh, hlist_for_each_safe, hlist_entry, hlist_del_init, write_unlock_bh, __l2tp_session_unhash, l2tp_session_queue_purge, l2tp_session_dec_refcount]\n\n2. 函数名: BUG_ON\n- 参数: [tunnel == NULL]\n- 调用者: l2tp_tunnel_closeall\n- 被调用者: []\n\n3. 函数名: l2tp_info\n- 参数: [tunnel, L2TP_MSG_CONTROL, format string, tunnel->name] 或 [session, L2TP_MSG_CONTROL, format string, session->name]\n- 调用者: l2tp_tunnel_closeall\n- 被调用者: []\n\n4. 函数名: write_lock_bh\n- 参数: [&tunnel->hlist_lock]\n- 调用者: l2tp_tunnel_closeall\n- 被调用者: []\n\n5. 函数名: hlist_for_each_safe\n- 参数: [walk, tmp, &tunnel->session_hlist[hash]]\n- 调用者: l2tp_tunnel_closeall\n- 被调用者: []\n\n6. 函数名: hlist_entry\n- 参数: [walk, struct l2tp_session, hlist]\n- 调用者: l2tp_tunnel_closeall\n- 被调用者: []\n\n7. 函数名: hlist_del_init\n- 参数: [&session->hlist]\n- 调用者: l2tp_tunnel_closeall\n- 被调用者: []\n\n8. 函数名: write_unlock_bh\n- 参数: [&tunnel->hlist_lock]\n- 调用者: l2tp_tunnel_closeall\n- 被调用者: []\n\n9. 函数名: __l2tp_session_unhash\n- 参数: [session]\n- 调用者: l2tp_tunnel_closeall\n- 被调用者: []\n\n10. 函数名: l2tp_session_queue_purge\n- 参数: [session]\n- 调用者: l2tp_tunnel_closeall\n- 被调用者: []\n\n11. 函数名: l2tp_session_dec_refcount\n- 参数: [session]\n- 调用者: l2tp_tunnel_closeall\n- 被调用者: []"
    },
    {
        "id": 2382,
        "cwe": "CWE-787",
        "cve": "CVE-2020-0429",
        "purpose": "Code purpose:\"\"\"该代码用于删除L2TP会话，包括解除会话哈希、清空会话队列、关闭会话并减少引用计数等功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放session内存后仍可能通过deref回调函数访问已释放的内存，导致释放后使用(UAF)漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: l2tp_session_delete\n- 参数: [session]\n- 调用者: 未明确（外部调用）\n- 被调用者: [__l2tp_session_unhash, l2tp_session_queue_purge, l2tp_session_dec_refcount]\n\n2. 函数名: __l2tp_session_unhash\n- 参数: [session]\n- 调用者: l2tp_session_delete\n- 被调用者: 未明确\n\n3. 函数名: l2tp_session_queue_purge\n- 参数: [session]\n- 调用者: l2tp_session_delete\n- 被调用者: 未明确\n\n4. 函数名: l2tp_session_dec_refcount\n- 参数: [session]\n- 调用者: l2tp_session_delete\n- 被调用者: 未明确"
    },
    {
        "id": 2385,
        "cwe": "CWE-787",
        "cve": "CVE-2020-0432",
        "purpose": "Code purpose:\"\"\"将网络数据包(skb)的内容和头部信息复制到MBO缓冲区中，并添加MEP协议头部\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于整数溢出导致缓冲区大小检查失效，可能引发越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: skb_to_mep\n- 参数: [const struct sk_buff *skb, struct mbo *mbo]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [memcpy, pr_err]\n\n2. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: skb_to_mep\n- 被调用者: []\n\n3. 函数名: pr_err\n- 参数: [const char *fmt, ...]\n- 调用者: skb_to_mep\n- 被调用者: []\n\n4. 函数名: HB\n- 参数: [未明确]\n- 调用者: skb_to_mep\n- 被调用者: []\n\n5. 函数名: LB\n- 参数: [未明确]\n- 调用者: skb_to_mep\n- 被调用者: []"
    },
    {
        "id": 2386,
        "cwe": "CWE-787",
        "cve": "CVE-2020-0432",
        "purpose": "Code purpose:\"\"\"将网络数据包(skb)转换为MAMAC格式的数据并写入缓冲区\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于整数溢出导致缓冲区边界检查失效，可能造成越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: skb_to_mamac\n- 参数: [const struct sk_buff *skb, struct mbo *mbo]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [memcpy, pr_err]\n\n2. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: skb_to_mamac\n- 被调用者: []\n\n3. 函数名: pr_err\n- 参数: [const char *fmt, ...]\n- 调用者: skb_to_mamac\n- 被调用者: []"
    },
    {
        "id": 2391,
        "cwe": "CWE-787",
        "cve": "CVE-2020-0465",
        "purpose": "Code purpose:\"\"\"该代码用于处理HID设备的输入映射，将HID设备的各类输入事件（如键盘按键、鼠标移动、游戏手柄控制等）转换为Linux输入子系统能识别的事件类型和代码\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺少边界检查，导致在hid-multitouch.c的多个方法中可能出现越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: hidinput_configure_usage\n- 参数: [struct hid_input *hidinput, struct hid_field *field, struct hid_usage *usage]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [input_get_drvdata, set_bit, map_key_clear, map_key, map_abs, map_abs_clear, map_rel, hidinput_setup_battery, __set_bit, test_bit, find_next_zero_bit, input_set_abs_params, input_abs_set_res, input_set_events_per_packet]\n\n2. 函数名: input_get_drvdata\n- 参数: [struct input_dev *input]\n- 调用者: hidinput_configure_usage\n- 被调用者: 未显示\n\n3. 函数名: set_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: hidinput_configure_usage\n- 被调用者: 未显示\n\n4. 函数名: map_key_clear\n- 参数: [int code]\n- 调用者: hidinput_configure_usage\n- 被调用者: 未显示\n\n5. 函数名: map_key\n- 参数: [int code]\n- 调用者: hidinput_configure_usage\n- 被调用者: 未显示\n\n6. 函数名: map_abs\n- 参数: [int code]\n- 调用者: hidinput_configure_usage\n- 被调用者: 未显示\n\n7. 函数名: map_abs_clear\n- 参数: [int code]\n- 调用者: hidinput_configure_usage\n- 被调用者: 未显示\n\n8. 函数名: map_rel\n- 参数: [int code]\n- 调用者: hidinput_configure_usage\n- 被调用者: 未显示\n\n9. 函数名: hidinput_setup_battery\n- 参数: [struct hid_device *device, int report_type, struct hid_field *field]\n- 调用者: hidinput_configure_usage\n- 被调用者: 未显示\n\n10. 函数名: __set_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: hidinput_configure_usage\n- 被调用者: 未显示\n\n11. 函数名: test_bit\n- 参数: [int nr, const volatile unsigned long *addr]\n- 调用者: hidinput_configure_usage\n- 被调用者: 未显示\n\n12. 函数名: find_next_zero_bit\n- 参数: [const unsigned long *addr, unsigned long size, unsigned long offset]\n- 调用者: hidinput_configure_usage\n- 被调用者: 未显示\n\n13. 函数名: input_set_abs_params\n- 参数: [struct input_dev *dev, unsigned int axis, int min, int max, int fuzz, int flat]\n- 调用者: hidinput_configure_usage\n- 被调用者: 未显示\n\n14. 函数名: input_abs_set_res\n- 参数: [struct input_dev *dev, unsigned int code, unsigned int res]\n- 调用者: hidinput_configure_usage\n- 被调用者: 未显示\n\n15. 函数名: input_set_events_per_packet\n- 参数: [struct input_dev *dev, int n_events]\n- 调用者: hidinput_configure_usage\n- 被调用者: 未显示\n\n16. 函数名: test_and_set_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: hidinput_configure_usage\n- 被调用者: 未显示"
    },
    {
        "id": 2392,
        "cwe": "CWE-787",
        "cve": "CVE-2020-0465",
        "purpose": "Code purpose:\"\"\"处理HID多点触摸设备的输入映射，将设备的物理输入转换为系统可识别的输入事件\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在hid-multitouch.c的多个方法中，由于缺少对数组索引的边界检查，可能导致越界写入漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: mt_touch_input_mapping\n- 参数: [struct hid_device *hdev, struct hid_input *hi, struct hid_field *field, struct hid_usage *usage, unsigned long **bit, int *max, struct mt_application *app]\n- 调用者: 未显示（由HID子系统调用）\n- 被调用者: [hid_get_drvdata, set_abs, __set_bit, input_set_abs_params, input_set_capability, hid_map_usage, test_bit]\n\n2. 函数名: hid_get_drvdata\n- 参数: [struct hid_device *hdev]\n- 调用者: mt_touch_input_mapping\n- 被调用者: 未显示\n\n3. 函数名: set_abs\n- 参数: 未完全显示（至少包含input设备、code、field等参数）\n- 调用者: mt_touch_input_mapping\n- 被调用者: 未显示\n\n4. 函数名: __set_bit\n- 参数: [int bitnr, volatile unsigned long *addr]\n- 调用者: mt_touch_input_mapping\n- 被调用者: 未显示\n\n5. 函数名: input_set_abs_params\n- 参数: [struct input_dev *dev, unsigned int code, int min, int max, int fuzz, int flat]\n- 调用者: mt_touch_input_mapping\n- 被调用者: 未显示\n\n6. 函数名: input_set_capability\n- 参数: [struct input_dev *dev, unsigned int type, unsigned int code]\n- 调用者: mt_touch_input_mapping\n- 被调用者: 未显示\n\n7. 函数名: hid_map_usage\n- 参数: [struct hid_input *hidinput, struct hid_usage *usage, unsigned long **bit, int *max, unsigned int type, unsigned int c]\n- 调用者: mt_touch_input_mapping\n- 被调用者: 未显示\n\n8. 函数名: test_bit\n- 参数: [int nr, const volatile unsigned long *addr]\n- 调用者: mt_touch_input_mapping\n- 被调用者: 未显示"
    },
    {
        "id": 2393,
        "cwe": "CWE-787",
        "cve": "CVE-2020-0465",
        "purpose": "Code purpose:\"\"\"该代码用于清除HID设备输入映射中的特定使用位，但缺少边界检查可能导致越界写入漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺少边界检查，导致在hid_map_usage_clear函数中可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: hid_map_usage_clear\n- 参数: [struct hid_input *hidinput, struct hid_usage *usage, unsigned long **bit, int *max, __u8 type, __u16 c]\n- 调用者: 未提供\n- 被调用者: [hid_map_usage, clear_bit]\n\n2. 函数名: hid_map_usage\n- 参数: [struct hid_input *hidinput, struct hid_usage *usage, unsigned long **bit, int *max, __u8 type, __u16 c]\n- 调用者: hid_map_usage_clear\n- 被调用者: 未提供\n\n3. 函数名: clear_bit\n- 参数: [__u16 c, unsigned long *bit]\n- 调用者: hid_map_usage_clear\n- 被调用者: 未提供"
    },
    {
        "id": 2409,
        "cwe": "CWE-787",
        "cve": "CVE-2020-10742",
        "purpose": "Code purpose:\"\"\"释放用户页面并处理脏页标记，最后释放页面数组内存\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在释放用户页面时未正确验证页面数组索引边界，导致可能发生缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: ll_free_user_pages\n- 参数: [struct page **pages, int npages, int do_dirty]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [set_page_dirty_lock, page_cache_release, OBD_FREE_LARGE]\n\n2. 函数名: set_page_dirty_lock\n- 参数: [struct page *page]\n- 调用者: ll_free_user_pages\n- 被调用者: 未明确\n\n3. 函数名: page_cache_release\n- 参数: [struct page *page]\n- 调用者: ll_free_user_pages\n- 被调用者: 未明确\n\n4. 函数名: OBD_FREE_LARGE\n- 参数: [void *ptr, size_t size]\n- 调用者: ll_free_user_pages\n- 被调用者: 未明确"
    },
    {
        "id": 2410,
        "cwe": "CWE-787",
        "cve": "CVE-2020-10742",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中直接I/O(Direct IO)的读写操作功能，处理用户空间与存储设备之间的数据传输，包括内存页管理、文件偏移量控制和并发访问保护等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在Direct IO写入操作中，由于未正确验证用户提供的缓冲区索引范围，导致索引缓冲区溢出，可能引发内核崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: ll_direct_IO_26\n- 参数: [rw, iocb, iter, file_offset]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [cl_inode2ccc, iov_iter_count, iov_iter_alignment, cl_env_get, ccc_env_io, i_size_read, ll_get_user_pages, ll_direct_IO_26_seg, ll_free_user_pages, obd_adjust_kms, cl_env_put, mutex_lock, mutex_unlock, lov_stripe_lock, lov_stripe_unlock, ccc_inode_lsm_get, ccc_inode_lsm_put]\n\n2. 函数名: cl_inode2ccc\n- 参数: [inode]\n- 调用者: ll_direct_IO_26\n- 被调用者: 未显示\n\n3. 函数名: iov_iter_count\n- 参数: [iter]\n- 调用者: ll_direct_IO_26\n- 被调用者: 未显示\n\n4. 函数名: iov_iter_alignment\n- 参数: [iter]\n- 调用者: ll_direct_IO_26\n- 被调用者: 未显示\n\n5. 函数名: cl_env_get\n- 参数: [refcheck]\n- 调用者: ll_direct_IO_26\n- 被调用者: 未显示\n\n6. 函数名: ccc_env_io\n- 参数: [env]\n- 调用者: ll_direct_IO_26\n- 被调用者: 未显示\n\n7. 函数名: i_size_read\n- 参数: [inode]\n- 调用者: ll_direct_IO_26\n- 被调用者: 未显示\n\n8. 函数名: ll_get_user_pages\n- 参数: [rw, user_addr, bytes, pages, max_pages]\n- 调用者: ll_direct_IO_26\n- 被调用者: 未显示\n\n9. 函数名: ll_direct_IO_26_seg\n- 参数: [env, io, rw, inode, file->f_mapping, bytes, file_offset, pages, page_count]\n- 调用者: ll_direct_IO_26\n- 被调用者: 未显示\n\n10. 函数名: ll_free_user_pages\n- 参数: [pages, max_pages, rw==READ]\n- 调用者: ll_direct_IO_26\n- 被调用者: 未显示\n\n11. 函数名: obd_adjust_kms\n- 参数: [ll_i2dtexp(inode), lsm, file_offset, 0]\n- 调用者: ll_direct_IO_26\n- 被调用者: 未显示\n\n12. 函数名: cl_env_put\n- 参数: [env, refcheck]\n- 调用者: ll_direct_IO_26\n- 被调用者: 未显示\n\n13. 函数名: mutex_lock\n- 参数: [&inode->i_mutex]\n- 调用者: ll_direct_IO_26\n- 被调用者: 未显示\n\n14. 函数名: mutex_unlock\n- 参数: [&inode->i_mutex]\n- 调用者: ll_direct_IO_26\n- 被调用者: 未显示\n\n15. 函数名: lov_stripe_lock\n- 参数: [lsm]\n- 调用者: ll_direct_IO_26\n- 被调用者: 未显示\n\n16. 函数名: lov_stripe_unlock\n- 参数: [lsm]\n- 调用者: ll_direct_IO_26\n- 被调用者: 未显示\n\n17. 函数名: ccc_inode_lsm_get\n- 参数: [inode]\n- 调用者: ll_direct_IO_26\n- 被调用者: 未显示\n\n18. 函数名: ccc_inode_lsm_put\n- 参数: [inode, lsm]\n- 调用者: ll_direct_IO_26\n- 被调用者: 未显示"
    },
    {
        "id": 2411,
        "cwe": "CWE-787",
        "cve": "CVE-2020-10742",
        "purpose": "Code purpose:\"\"\"该代码实现了NFS客户端直接读取文件的功能，处理从指定位置开始的直接I/O读取请求，并返回读取结果。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在NFS直接读取操作中，由于未正确验证输入数据的边界，导致索引缓冲区溢出，可能引发内核崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: nfs_file_direct_read\n- 参数: [struct kiocb *iocb, struct iov_iter *iter, loff_t pos, bool uio]\n- 调用者: N/A (top-level function)\n- 被调用者: [iov_iter_count, nfs_add_stats, mutex_lock, nfs_sync_mapping, task_io_account_read, nfs_direct_req_alloc, get_nfs_open_context, nfs_file_open_context, nfs_get_lock_context, is_sync_kiocb, nfs_direct_read_schedule_iovec, mutex_unlock, nfs_direct_wait, nfs_direct_req_release]\n\n2. 函数名: iov_iter_count\n- 参数: [struct iov_iter *iter]\n- 调用者: nfs_file_direct_read\n- 被调用者: N/A\n\n3. 函数名: nfs_add_stats\n- 参数: [struct inode *host, enum nfs_stat_eventcounters stat, long addend]\n- 调用者: nfs_file_direct_read\n- 被调用者: N/A\n\n4. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: nfs_file_direct_read\n- 被调用者: N/A\n\n5. 函数名: nfs_sync_mapping\n- 参数: [struct address_space *mapping]\n- 调用者: nfs_file_direct_read\n- 被调用者: N/A\n\n6. 函数名: task_io_account_read\n- 参数: [size_t count]\n- 调用者: nfs_file_direct_read\n- 被调用者: N/A\n\n7. 函数名: nfs_direct_req_alloc\n- 参数: []\n- 调用者: nfs_file_direct_read\n- 被调用者: N/A\n\n8. 函数名: get_nfs_open_context\n- 参数: [struct nfs_open_context *ctx]\n- 调用者: nfs_file_direct_read\n- 被调用者: N/A\n\n9. 函数名: nfs_file_open_context\n- 参数: [struct file *filp]\n- 调用者: nfs_file_direct_read\n- 被调用者: N/A\n\n10. 函数名: nfs_get_lock_context\n- 参数: [struct nfs_open_context *ctx]\n- 调用者: nfs_file_direct_read\n- 被调用者: N/A\n\n11. 函数名: is_sync_kiocb\n- 参数: [struct kiocb *iocb]\n- 调用者: nfs_file_direct_read\n- 被调用者: N/A\n\n12. 函数名: nfs_direct_read_schedule_iovec\n- 参数: [struct nfs_direct_req *dreq, struct iov_iter *iter, loff_t pos, bool uio]\n- 调用者: nfs_file_direct_read\n- 被调用者: N/A\n\n13. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: nfs_file_direct_read\n- 被调用者: N/A\n\n14. 函数名: nfs_direct_wait\n- 参数: [struct nfs_direct_req *dreq]\n- 调用者: nfs_file_direct_read\n- 被调用者: N/A\n\n15. 函数名: nfs_direct_req_release\n- 参数: [struct nfs_direct_req *dreq]\n- 调用者: nfs_file_direct_read\n- 被调用者: N/A"
    },
    {
        "id": 2412,
        "cwe": "CWE-787",
        "cve": "CVE-2020-10742",
        "purpose": "Code purpose:\"\"\"该代码实现了NFS客户端直接写入(Direct IO)功能，处理文件写入请求并确保数据正确同步到存储设备。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在NFS直接写入操作中，由于未正确验证写入位置和长度的边界条件，导致索引缓冲区溢出，可能引发内核崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: nfs_file_direct_write\n- 参数: [struct kiocb *iocb, struct iov_iter *iter, loff_t pos, bool uio]\n- 调用者: N/A (顶层函数)\n- 被调用者: [iov_iter_count, generic_write_checks, mutex_lock, nfs_sync_mapping, invalidate_inode_pages2_range, task_io_account_write, nfs_direct_req_alloc, get_nfs_open_context, nfs_file_open_context, nfs_get_lock_context, is_sync_kiocb, nfs_direct_write_schedule_iovec, invalidate_inode_pages2_range, mutex_unlock, nfs_direct_wait, i_size_read, i_size_write, nfs_direct_req_release]\n\n2. 函数名: iov_iter_count\n- 参数: [struct iov_iter *iter]\n- 调用者: nfs_file_direct_write\n- 被调用者: N/A\n\n3. 函数名: generic_write_checks\n- 参数: [struct file *file, loff_t *pos, size_t *count, int flags]\n- 调用者: nfs_file_direct_write\n- 被调用者: N/A\n\n4. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: nfs_file_direct_write\n- 被调用者: N/A\n\n5. 函数名: nfs_sync_mapping\n- 参数: [struct address_space *mapping]\n- 调用者: nfs_file_direct_write\n- 被调用者: N/A\n\n6. 函数名: invalidate_inode_pages2_range\n- 参数: [struct address_space *mapping, pgoff_t start, pgoff_t end]\n- 调用者: nfs_file_direct_write\n- 被调用者: N/A\n\n7. 函数名: task_io_account_write\n- 参数: [size_t count]\n- 调用者: nfs_file_direct_write\n- 被调用者: N/A\n\n8. 函数名: nfs_direct_req_alloc\n- 参数: []\n- 调用者: nfs_file_direct_write\n- 被调用者: N/A\n\n9. 函数名: get_nfs_open_context\n- 参数: [struct nfs_open_context *ctx]\n- 调用者: nfs_file_direct_write\n- 被调用者: N/A\n\n10. 函数名: nfs_file_open_context\n- 参数: [struct file *filp]\n- 调用者: nfs_file_direct_write\n- 被调用者: N/A\n\n11. 函数名: nfs_get_lock_context\n- 参数: [struct nfs_open_context *ctx]\n- 调用者: nfs_file_direct_write\n- 被调用者: N/A\n\n12. 函数名: is_sync_kiocb\n- 参数: [struct kiocb *iocb]\n- 调用者: nfs_file_direct_write\n- 被调用者: N/A\n\n13. 函数名: nfs_direct_write_schedule_iovec\n- 参数: [struct nfs_direct_req *dreq, struct iov_iter *iter, loff_t pos, bool uio]\n- 调用者: nfs_file_direct_write\n- 被调用者: N/A\n\n14. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: nfs_file_direct_write\n- 被调用者: N/A\n\n15. 函数名: nfs_direct_wait\n- 参数: [struct nfs_direct_req *dreq]\n- 调用者: nfs_file_direct_write\n- 被调用者: N/A\n\n16. 函数名: i_size_read\n- 参数: [struct inode *inode]\n- 调用者: nfs_file_direct_write\n- 被调用者: N/A\n\n17. 函数名: i_size_write\n- 参数: [struct inode *inode, loff_t i_size]\n- 调用者: nfs_file_direct_write\n- 被调用者: N/A\n\n18. 函数名: nfs_direct_req_release\n- 参数: [struct nfs_direct_req *dreq]\n- 调用者: nfs_file_direct_write\n- 被调用者: N/A"
    },
    {
        "id": 2424,
        "cwe": "CWE-787",
        "cve": "CVE-2020-10942",
        "purpose": "Code purpose:\"\"\"验证并获取原始套接字(socket)的结构体指针，同时检查套接字类型和地址族是否正确\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未验证sk_family字段，导致攻击者可能通过精心构造的系统调用触发内核栈损坏\"\"\"",
        "functions": "Functions:\n1. 函数名: get_raw_socket\n- 参数: [fd]\n- 调用者: 未明确（上下文未提供）\n- 被调用者: [sockfd_lookup, ERR_PTR, sockfd_put]\n\n2. 函数名: sockfd_lookup\n- 参数: [fd, r]\n- 调用者: get_raw_socket\n- 被调用者: 未明确（上下文未提供）\n\n3. 函数名: ERR_PTR\n- 参数: [r/-ENOTSOCK/-ESOCKTNOSUPPORT/-EPFNOSUPPORT]\n- 调用者: get_raw_socket\n- 被调用者: 未明确（上下文未提供）\n\n4. 函数名: sockfd_put\n- 参数: [sock]\n- 调用者: get_raw_socket\n- 被调用者: 未明确（上下文未提供）\n\n5. 函数名: sock->ops->getname\n- 参数: [sock, (struct sockaddr *)&uaddr.sa, 0]\n- 调用者: get_raw_socket\n- 被调用者: 未明确（上下文未提供）"
    },
    {
        "id": 2426,
        "cwe": "CWE-787",
        "cve": "CVE-2020-11565",
        "purpose": "Code purpose:\"\"\"解析内存策略字符串并创建对应的内存策略结构体\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理空节点列表时，mpol_parse_str函数存在栈缓冲区越界写入漏洞，由于在解析挂载选项时未正确处理空节点列表情况。\"\"\"",
        "functions": "Functions:\n1. 函数名: mpol_parse_str\n- 参数: [char *str, struct mempolicy **mpol]\n- 调用者: 未明确显示（应为内核中处理内存策略的调用者）\n- 被调用者: [strchr, nodelist_parse, nodes_subset, nodes_clear, match_string, isdigit, mpol_new, first_node]\n\n2. 函数名: strchr\n- 参数: [char *str, int c]\n- 调用者: mpol_parse_str\n- 被调用者: []\n\n3. 函数名: nodelist_parse\n- 参数: [char *nodelist, nodemask_t nodes]\n- 调用者: mpol_parse_str\n- 被调用者: []\n\n4. 函数名: nodes_subset\n- 参数: [nodemask_t nodes, nodemask_t node_states]\n- 调用者: mpol_parse_str\n- 被调用者: []\n\n5. 函数名: nodes_clear\n- 参数: [nodemask_t nodes]\n- 调用者: mpol_parse_str\n- 被调用者: []\n\n6. 函数名: match_string\n- 参数: [const char * const *array, size_t n, const char *string]\n- 调用者: mpol_parse_str\n- 被调用者: []\n\n7. 函数名: isdigit\n- 参数: [int c]\n- 调用者: mpol_parse_str\n- 被调用者: []\n\n8. 函数名: mpol_new\n- 参数: [int mode, unsigned short mode_flags, nodemask_t *nodes]\n- 调用者: mpol_parse_str\n- 被调用者: []\n\n9. 函数名: first_node\n- 参数: [nodemask_t nodes]\n- 调用者: mpol_parse_str\n- 被调用者: []\n\n10. 函数名: strcmp\n- 参数: [const char *str1, const char *str2]\n- 调用者: mpol_parse_str\n- 被调用者: []"
    },
    {
        "id": 2475,
        "cwe": "CWE-787",
        "cve": "CVE-2020-12653",
        "purpose": "Code purpose:\"\"\"将特定类型的供应商IE数据作为TLV附加到命令缓冲区中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于memcpy操作时未正确验证priv->vs_ie[id].ie的长度，导致缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: mwifiex_cmd_append_vsie_tlv\n- 参数: [struct mwifiex_private *priv, u16 vsie_mask, u8 **buffer]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [memcpy, cpu_to_le16, le16_to_cpu]\n\n2. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: mwifiex_cmd_append_vsie_tlv\n- 被调用者: 无\n\n3. 函数名: cpu_to_le16\n- 参数: [u16 val]\n- 调用者: mwifiex_cmd_append_vsie_tlv\n- 被调用者: 无\n\n4. 函数名: le16_to_cpu\n- 参数: [u16 val]\n- 调用者: mwifiex_cmd_append_vsie_tlv\n- 被调用者: 无"
    },
    {
        "id": 2476,
        "cwe": "CWE-787",
        "cve": "CVE-2020-12654",
        "purpose": "Code purpose:\"\"\"处理WMM (Wi-Fi Multimedia)状态获取命令的响应，解析TLV格式数据并更新WMM相关状态信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证WMM参数集长度，导致memcpy操作时可能发生堆缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: mwifiex_ret_wmm_get_status\n- 参数: [struct mwifiex_private *priv, const struct host_cmd_ds_command *resp]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [le16_to_cpu, mwifiex_dbg, memcpy, mwifiex_wmm_setup_queue_priorities, mwifiex_wmm_setup_ac_downgrade]\n\n2. 函数名: le16_to_cpu\n- 参数: [uint16_t]\n- 调用者: [mwifiex_ret_wmm_get_status]\n- 被调用者: 未显示（系统/库函数）\n\n3. 函数名: mwifiex_dbg\n- 参数: [struct mwifiex_adapter *, int, const char *, ...]\n- 调用者: [mwifiex_ret_wmm_get_status]\n- 被调用者: 未显示（驱动内部函数）\n\n4. 函数名: memcpy\n- 参数: [void *, const void *, size_t]\n- 调用者: [mwifiex_ret_wmm_get_status]\n- 被调用者: 未显示（标准库函数）\n\n5. 函数名: mwifiex_wmm_setup_queue_priorities\n- 参数: [struct mwifiex_private *, struct ieee_types_wmm_parameter *]\n- 调用者: [mwifiex_ret_wmm_get_status]\n- 被调用者: 未显示（驱动内部函数）\n\n6. 函数名: mwifiex_wmm_setup_ac_downgrade\n- 参数: [struct mwifiex_private *]\n- 调用者: [mwifiex_ret_wmm_get_status]\n- 被调用者: 未显示（驱动内部函数）"
    },
    {
        "id": 2480,
        "cwe": "CWE-787",
        "cve": "CVE-2020-12659",
        "purpose": "Code purpose:\"\"\"该代码用于注册和管理XDP(Express Data Path)用户空间内存区域(umem)，包括参数验证、内存分配和映射等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于xdp_umem_reg函数未对headroom参数进行充分验证，导致具有CAP_NET_ADMIN权限的用户可触发越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: xdp_umem_reg\n- 参数: [struct xdp_umem *umem, struct xdp_umem_reg *mr]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [div_u64, is_power_of_2, PAGE_ALIGNED, xdp_umem_account_pages, xdp_umem_pin_pages, kvcalloc, xdp_umem_map_pages, kvfree, xdp_umem_unpin_pages, xdp_umem_unaccount_pages]\n\n2. 函数名: div_u64\n- 参数: [u64 dividend, u32 divisor]\n- 调用者: xdp_umem_reg\n- 被调用者: 未显示\n\n3. 函数名: is_power_of_2\n- 参数: [unsigned long n]\n- 调用者: xdp_umem_reg\n- 被调用者: 未显示\n\n4. 函数名: PAGE_ALIGNED\n- 参数: [unsigned long addr]\n- 调用者: xdp_umem_reg\n- 被调用者: 未显示\n\n5. 函数名: xdp_umem_account_pages\n- 参数: [struct xdp_umem *umem]\n- 调用者: xdp_umem_reg\n- 被调用者: 未显示\n\n6. 函数名: xdp_umem_pin_pages\n- 参数: [struct xdp_umem *umem]\n- 调用者: xdp_umem_reg\n- 被调用者: 未显示\n\n7. 函数名: kvcalloc\n- 参数: [size_t n, size_t size, gfp_t flags]\n- 调用者: xdp_umem_reg\n- 被调用者: 未显示\n\n8. 函数名: xdp_umem_map_pages\n- 参数: [struct xdp_umem *umem]\n- 调用者: xdp_umem_reg\n- 被调用者: 未显示\n\n9. 函数名: kvfree\n- 参数: [const void *addr]\n- 调用者: xdp_umem_reg\n- 被调用者: 未显示\n\n10. 函数名: xdp_umem_unpin_pages\n- 参数: [struct xdp_umem *umem]\n- 调用者: xdp_umem_reg\n- 被调用者: 未显示\n\n11. 函数名: xdp_umem_unaccount_pages\n- 参数: [struct xdp_umem *umem]\n- 调用者: xdp_umem_reg\n- 被调用者: 未显示"
    },
    {
        "id": 2504,
        "cwe": "CWE-787",
        "cve": "CVE-2020-14305",
        "purpose": "Code purpose:\"\"\"初始化FTP连接跟踪功能，包括分配缓冲区、设置端口并注册IPv4和IPv6的FTP连接跟踪助手\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"内核中FTP连接跟踪功能在处理IPv6端口时存在边界检查不足，导致越界内存写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nf_conntrack_ftp_init\n- 参数: [void]\n- 调用者: 模块初始化调用\n- 被调用者: [kmalloc, nf_ct_helper_init, nf_conntrack_helpers_register, pr_err, kfree]\n\n2. 函数名: kmalloc\n- 参数: [65536, GFP_KERNEL]\n- 调用者: nf_conntrack_ftp_init\n- 被调用者: []\n\n3. 函数名: nf_ct_helper_init\n- 参数: [&ftp[2 * i], AF_INET, IPPROTO_TCP, \"ftp\", FTP_PORT, ports[i], ports[i], &ftp_exp_policy, 0, sizeof(struct nf_ct_ftp_master), help, nf_ct_ftp_from_nlattr, THIS_MODULE]\n- 调用者: nf_conntrack_ftp_init\n- 被调用者: []\n\n4. 函数名: nf_ct_helper_init\n- 参数: [&ftp[2 * i + 1], AF_INET6, IPPROTO_TCP, \"ftp\", FTP_PORT, ports[i], ports[i], &ftp_exp_policy, 0, sizeof(struct nf_ct_ftp_master), help, nf_ct_ftp_from_nlattr, THIS_MODULE]\n- 调用者: nf_conntrack_ftp_init\n- 被调用者: []\n\n5. 函数名: nf_conntrack_helpers_register\n- 参数: [ftp, ports_c * 2]\n- 调用者: nf_conntrack_ftp_init\n- 被调用者: []\n\n6. 函数名: pr_err\n- 参数: [\"failed to register helpers\"]\n- 调用者: nf_conntrack_ftp_init\n- 被调用者: []\n\n7. 函数名: kfree\n- 参数: [ftp_buffer]\n- 调用者: nf_conntrack_ftp_init\n- 被调用者: []"
    },
    {
        "id": 2505,
        "cwe": "CWE-787",
        "cve": "CVE-2020-14305",
        "purpose": "Code purpose:\"\"\"为网络连接添加辅助扩展区域并初始化期望链表\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证helper->data_len的长度，导致在添加helper扩展区域时可能发生越界内存写入\"\"\"",
        "functions": "Functions:\n1. 函数名: nf_ct_helper_ext_add\n- 参数: [struct nf_conn *ct, struct nf_conntrack_helper *helper, gfp_t gfp]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [nf_ct_ext_add_length, INIT_HLIST_HEAD, pr_debug]\n\n2. 函数名: nf_ct_ext_add_length\n- 参数: [struct nf_conn *ct, enum nf_ct_ext_id id, unsigned int len, gfp_t gfp]\n- 调用者: nf_ct_helper_ext_add\n- 被调用者: 未明确（可能为内核内部函数）\n\n3. 函数名: INIT_HLIST_HEAD\n- 参数: [struct hlist_head *head]\n- 调用者: nf_ct_helper_ext_add\n- 被调用者: 无\n\n4. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: nf_ct_helper_ext_add\n- 被调用者: 无"
    },
    {
        "id": 2506,
        "cwe": "CWE-787",
        "cve": "CVE-2020-14305",
        "purpose": "Code purpose:\"\"\"初始化IRC连接跟踪模块，设置最大DCC通道数，分配缓冲区，并注册网络连接跟踪助手。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证输入参数边界，导致在IPv6端口1720处理H.323连接时可能发生越界内存写入\"\"\"",
        "functions": "Functions:\n1. 函数名: nf_conntrack_irc_init\n- 参数: [void]\n- 调用者: 模块初始化调用\n- 被调用者: [pr_err, kmalloc, nf_ct_helper_init, nf_conntrack_helpers_register, kfree]\n\n2. 函数名: pr_err\n- 参数: [format_string, ...]\n- 调用者: nf_conntrack_irc_init\n- 被调用者: []\n\n3. 函数名: kmalloc\n- 参数: [size, flags]\n- 调用者: nf_conntrack_irc_init\n- 被调用者: []\n\n4. 函数名: nf_ct_helper_init\n- 参数: [helper, family, protocol, name, port, peer_port, class, expect_policy, queue_num, flags, help, module, me]\n- 调用者: nf_conntrack_irc_init\n- 被调用者: []\n\n5. 函数名: nf_conntrack_helpers_register\n- 参数: [helper, n]\n- 调用者: nf_conntrack_irc_init\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [ptr]\n- 调用者: nf_conntrack_irc_init\n- 被调用者: []"
    },
    {
        "id": 2507,
        "cwe": "CWE-787",
        "cve": "CVE-2020-14305",
        "purpose": "Code purpose:\"\"\"初始化并注册网络连接跟踪帮助程序，用于处理SANE协议在IPv4和IPv6上的TCP连接跟踪。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于IPv6连接跟踪功能在处理端口1720的连接时存在边界检查不足，导致越界内存写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nf_conntrack_sane_init\n- 参数: []\n- 调用者: 模块初始化调用\n- 被调用者: [NF_CT_HELPER_BUILD_BUG_ON, kmalloc, nf_ct_helper_init, nf_conntrack_helpers_register, pr_err, kfree]\n\n2. 函数名: NF_CT_HELPER_BUILD_BUG_ON\n- 参数: [sizeof(struct nf_ct_sane_master)]\n- 调用者: nf_conntrack_sane_init\n- 被调用者: []\n\n3. 函数名: kmalloc\n- 参数: [65536, GFP_KERNEL]\n- 调用者: nf_conntrack_sane_init\n- 被调用者: []\n\n4. 函数名: nf_ct_helper_init\n- 参数: [&sane[2 * i], AF_INET, IPPROTO_TCP, \"sane\", SANE_PORT, ports[i], ports[i], &sane_exp_policy, 0, sizeof(struct nf_ct_sane_master), help, NULL, THIS_MODULE]\n- 调用者: nf_conntrack_sane_init\n- 被调用者: []\n\n5. 函数名: nf_conntrack_helpers_register\n- 参数: [sane, ports_c * 2]\n- 调用者: nf_conntrack_sane_init\n- 被调用者: []\n\n6. 函数名: pr_err\n- 参数: [\"failed to register helpers\"]\n- 调用者: nf_conntrack_sane_init\n- 被调用者: []\n\n7. 函数名: kfree\n- 参数: [sane_buffer]\n- 调用者: nf_conntrack_sane_init\n- 被调用者: []"
    },
    {
        "id": 2508,
        "cwe": "CWE-787",
        "cve": "CVE-2020-14305",
        "purpose": "Code purpose:\"\"\"初始化SIP协议的网络连接跟踪功能，包括IPv4和IPv6下UDP/TCP协议的端口注册和帮助程序设置\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于IPv6端口1720的连接跟踪功能在处理H.323 VoIP连接时存在边界检查不足，导致越界内存写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: nf_conntrack_sip_init\n- 参数: [void]\n- 调用者: module initialization\n- 被调用者: [NF_CT_HELPER_BUILD_BUG_ON, nf_ct_helper_init, nf_conntrack_helpers_register, pr_err]\n\n2. 函数名: NF_CT_HELPER_BUILD_BUG_ON\n- 参数: [sizeof(struct nf_ct_sip_master)]\n- 调用者: nf_conntrack_sip_init\n- 被调用者: []\n\n3. 函数名: nf_ct_helper_init\n- 参数: [&sip[4 * i], AF_INET, IPPROTO_UDP, \"sip\", SIP_PORT, ports[i], i, sip_exp_policy, SIP_EXPECT_MAX, sizeof(struct nf_ct_sip_master), sip_help_udp, NULL, THIS_MODULE]\n- 调用者: nf_conntrack_sip_init\n- 被调用者: []\n\n4. 函数名: nf_ct_helper_init\n- 参数: [&sip[4 * i + 1], AF_INET, IPPROTO_TCP, \"sip\", SIP_PORT, ports[i], i, sip_exp_policy, SIP_EXPECT_MAX, sizeof(struct nf_ct_sip_master), sip_help_tcp, NULL, THIS_MODULE]\n- 调用者: nf_conntrack_sip_init\n- 被调用者: []\n\n5. 函数名: nf_ct_helper_init\n- 参数: [&sip[4 * i + 2], AF_INET6, IPPROTO_UDP, \"sip\", SIP_PORT, ports[i], i, sip_exp_policy, SIP_EXPECT_MAX, sizeof(struct nf_ct_sip_master), sip_help_udp, NULL, THIS_MODULE]\n- 调用者: nf_conntrack_sip_init\n- 被调用者: []\n\n6. 函数名: nf_ct_helper_init\n- 参数: [&sip[4 * i + 3], AF_INET6, IPPROTO_TCP, \"sip\", SIP_PORT, ports[i], i, sip_exp_policy, SIP_EXPECT_MAX, sizeof(struct nf_ct_sip_master), sip_help_tcp, NULL, THIS_MODULE]\n- 调用者: nf_conntrack_sip_init\n- 被调用者: []\n\n7. 函数名: nf_conntrack_helpers_register\n- 参数: [sip, ports_c * 4]\n- 调用者: nf_conntrack_sip_init\n- 被调用者: []\n\n8. 函数名: pr_err\n- 参数: [\"failed to register helpers\"]\n- 调用者: nf_conntrack_sip_init\n- 被调用者: []"
    },
    {
        "id": 2509,
        "cwe": "CWE-787",
        "cve": "CVE-2020-14305",
        "purpose": "Code purpose:\"\"\"初始化并注册TFTP连接跟踪助手，支持IPv4和IPv6协议\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证端口数组索引边界，导致可能发生越界内存写入\"\"\"",
        "functions": "Functions:\n1. 函数名: nf_conntrack_tftp_init\n- 参数: [void]\n- 调用者: __init\n- 被调用者: [NF_CT_HELPER_BUILD_BUG_ON, nf_ct_helper_init, nf_conntrack_helpers_register, pr_err]\n\n2. 函数名: NF_CT_HELPER_BUILD_BUG_ON\n- 参数: [0]\n- 调用者: nf_conntrack_tftp_init\n- 被调用者: []\n\n3. 函数名: nf_ct_helper_init\n- 参数: [&tftp[2 * i], AF_INET, IPPROTO_UDP, \"tftp\", TFTP_PORT, ports[i], i, &tftp_exp_policy, 0, 0, tftp_help, NULL, THIS_MODULE]\n- 调用者: nf_conntrack_tftp_init\n- 被调用者: []\n\n4. 函数名: nf_ct_helper_init\n- 参数: [&tftp[2 * i + 1], AF_INET6, IPPROTO_UDP, \"tftp\", TFTP_PORT, ports[i], i, &tftp_exp_policy, 0, 0, tftp_help, NULL, THIS_MODULE]\n- 调用者: nf_conntrack_tftp_init\n- 被调用者: []\n\n5. 函数名: nf_conntrack_helpers_register\n- 参数: [tftp, ports_c * 2]\n- 调用者: nf_conntrack_tftp_init\n- 被调用者: []\n\n6. 函数名: pr_err\n- 参数: [\"failed to register helpers\"]\n- 调用者: nf_conntrack_tftp_init\n- 被调用者: []"
    },
    {
        "id": 2511,
        "cwe": "CWE-787",
        "cve": "CVE-2020-14331",
        "purpose": "Code purpose:\"\"\"该代码用于更新VGA控制台的滚动缓冲区内容，处理控制台滚动时的数据拷贝和缓冲区管理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对vgacon_scrollback_cur->tail进行边界检查，导致在滚动缓冲区操作时可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: vgacon_scrollback_update\n- 参数: [struct vc_data *c, int t, int count]\n- 调用者: 未明确显示（应为VT_RESIZE ioctl处理流程）\n- 被调用者: [scr_memcpyw]\n\n2. 函数名: scr_memcpyw\n- 参数: [未完全显示，但包含目标地址、源地址和复制大小]\n- 调用者: vgacon_scrollback_update\n- 被调用者: []"
    },
    {
        "id": 2524,
        "cwe": "CWE-787",
        "cve": "CVE-2020-14386",
        "purpose": "Code purpose:\"\"\"处理网络数据包并将其从内核空间传递到用户空间，支持多种数据包格式版本(V1/V2/V3)。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在tpacket_rcv函数中处理网络数据包时，未能正确验证和限制macoff与snaplen的计算结果，导致可能发生越界写入内存的漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: tpacket_rcv\n- 参数: [struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev]\n- 调用者: 网络协议栈（packet接收处理）\n- 被调用者: [run_filter, __packet_rcv_has_room, skb_push, skb_pull, skb_clone, skb_get, skb_set_owner_r, skb_shared, skb_copy_bits, tpacket_get_timestamp, ktime_get_real_ts64, dev_parse_header, flush_dcache_page, pgv_to_page, consume_skb, kfree_skb, virtio_net_hdr_from_skb, prb_clear_blk_fill_status, packet_increment_rx_head, __set_bit, test_bit, __clear_bit, __packet_set_status, prb_clear_blk_fill_status]\n\n2. 函数名: run_filter\n- 参数: [struct sk_buff *skb, struct sock *sk, unsigned int snaplen]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n3. 函数名: __packet_rcv_has_room\n- 参数: [struct packet_sock *po, struct sk_buff *skb]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n4. 函数名: skb_push\n- 参数: [struct sk_buff *skb, unsigned int len]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n5. 函数名: skb_pull\n- 参数: [struct sk_buff *skb, unsigned int len]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n6. 函数名: skb_clone\n- 参数: [struct sk_buff *skb, gfp_t priority]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n7. 函数名: skb_get\n- 参数: [struct sk_buff *skb]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n8. 函数名: skb_set_owner_r\n- 参数: [struct sk_buff *skb, struct sock *sk]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n9. 函数名: skb_shared\n- 参数: [struct sk_buff *skb]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n10. 函数名: skb_copy_bits\n- 参数: [const struct sk_buff *skb, int offset, void *to, int len]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n11. 函数名: tpacket_get_timestamp\n- 参数: [struct sk_buff *skb, struct timespec64 *ts, unsigned int ts_type]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n12. 函数名: ktime_get_real_ts64\n- 参数: [struct timespec64 *ts]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n13. 函数名: dev_parse_header\n- 参数: [struct sk_buff *skb, u8 *haddr]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n14. 函数名: flush_dcache_page\n- 参数: [struct page *page]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n15. 函数名: pgv_to_page\n- 参数: [void *addr]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n16. 函数名: consume_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n17. 函数名: kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n18. 函数名: virtio_net_hdr_from_skb\n- 参数: [struct sk_buff *skb, void *hdr, bool little_endian, bool has_data_valid, int vlan_hlen]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n19. 函数名: prb_clear_blk_fill_status\n- 参数: [struct packet_ring_buffer *rb]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n20. 函数名: packet_increment_rx_head\n- 参数: [struct packet_sock *po, struct packet_ring_buffer *rb]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n21. 函数名: __set_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n22. 函数名: test_bit\n- 参数: [int nr, const volatile unsigned long *addr]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n23. 函数名: __clear_bit\n- 参数: [int nr, volatile unsigned long *addr]\n- 调用者: tpacket_rcv\n- 被调用者: []\n\n24. 函数名: __packet_set_status\n- 参数: [struct packet_sock *po, void *frame, int status]\n- 调用者: tpacket_rcv\n- 被调用者: []"
    },
    {
        "id": 2525,
        "cwe": "CWE-787",
        "cve": "CVE-2020-14390",
        "purpose": "Code purpose:\"\"\"计算并返回虚拟控制台在特定偏移量处的屏幕缓冲区位置\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在改变屏幕大小时，由于缺乏对偏移量的边界检查，导致可能发生越界内存写入\"\"\"",
        "functions": "Functions:\n1. 函数名: fbcon_screen_pos\n- 参数: [vc, offset]\n- 调用者: 未明确（由外部调用）\n- 被调用者: []"
    },
    {
        "id": 2526,
        "cwe": "CWE-787",
        "cve": "CVE-2020-14390",
        "purpose": "Code purpose:\"\"\"计算和控制台显示相关的屏幕位置坐标，并处理可能的边界条件\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在修改屏幕大小时，由于缺乏对pos参数的边界检查，可能导致越界内存写入，造成内存破坏或拒绝服务。\"\"\"",
        "functions": "Functions:\n1. 函数名: fbcon_getxy\n- 参数: [vc, pos, px, py]\n- 调用者: 未显示（由外部调用）\n- 被调用者: []"
    },
    {
        "id": 2527,
        "cwe": "CWE-787",
        "cve": "CVE-2020-14390",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理控制台屏幕区域的反转操作，包括颜色处理和字体掩码处理，同时管理软缓冲区的指针循环。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在改变屏幕大小时，由于缺乏对指针p的有效边界检查，可能导致越界内存写入，造成内存破坏或拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: fbcon_invert_region\n- 参数: [vc, p, cnt]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [scr_readw, scr_writew]\n\n2. 函数名: scr_readw\n- 参数: [p]\n- 调用者: fbcon_invert_region\n- 被调用者: 未明确（底层硬件操作）\n\n3. 函数名: scr_writew\n- 参数: [a, p]\n- 调用者: fbcon_invert_region\n- 被调用者: 未明确（底层硬件操作）"
    },
    {
        "id": 2528,
        "cwe": "CWE-787",
        "cve": "CVE-2020-14390",
        "purpose": "Code purpose:\"\"\"该代码片段用于初始化帧缓冲控制台(fbcon)的显示设置，包括字体、旋转、分辨率等参数，并处理屏幕大小变化时的相关操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在改变屏幕大小时，由于缺乏对边界条件的充分检查，导致可能发生越界内存写入\"\"\"",
        "functions": "Functions:\n1. 函数名: fbcon_startup\n- 参数: []\n- 调用者: \n- 被调用者: [try_module_get, module_put, kzalloc, kvmalloc, kvfree, find_font, get_default_font, vc_resize, fbcon_add_cursor_timer]\n\n2. 函数名: try_module_get\n- 参数: [owner]\n- 调用者: fbcon_startup\n- 被调用者: []\n\n3. 函数名: module_put\n- 参数: [owner]\n- 调用者: fbcon_startup\n- 被调用者: []\n\n4. 函数名: kzalloc\n- 参数: [sizeof(struct fbcon_ops), GFP_KERNEL]\n- 调用者: fbcon_startup\n- 被调用者: []\n\n5. 函数名: kvmalloc\n- 参数: [fbcon_softback_size, GFP_KERNEL]\n- 调用者: fbcon_startup\n- 被调用者: []\n\n6. 函数名: kvfree\n- 参数: [(void *) softback_buf]\n- 调用者: fbcon_startup\n- 被调用者: []\n\n7. 函数名: find_font\n- 参数: [fontname]\n- 调用者: fbcon_startup\n- 被调用者: []\n\n8. 函数名: get_default_font\n- 参数: [info->var.xres, info->var.yres, info->pixmap.blit_x, info->pixmap.blit_y]\n- 调用者: fbcon_startup\n- 被调用者: []\n\n9. 函数名: vc_resize\n- 参数: [vc, cols, rows]\n- 调用者: fbcon_startup\n- 被调用者: []\n\n10. 函数名: fbcon_add_cursor_timer\n- 参数: [info]\n- 调用者: fbcon_startup\n- 被调用者: []"
    },
    {
        "id": 2529,
        "cwe": "CWE-787",
        "cve": "CVE-2020-14390",
        "purpose": "Code purpose:\"\"\"处理控制台帧缓冲设备的切换和显示参数调整，包括屏幕大小改变、光标设置、滚动模式更新等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在改变屏幕大小时，由于缺乏对边界条件的充分检查，导致可能发生越界内存写入\"\"\"",
        "functions": "Functions:\n1. 函数名: fbcon_switch\n- 参数: [struct vc_data *vc]\n- 调用者: N/A\n- 被调用者: [fbcon_set_origin, fbcon_update_softback, display_to_var, fb_set_var, fbcon_del_cursor_timer, fbcon_add_cursor_timer, set_blitting_type, fb_get_color_depth, updatescrollmode, ops->update_start, fbcon_set_palette, fbcon_clear_margins, fb_show_logo, update_region]\n\n2. 函数名: fbcon_set_origin\n- 参数: [struct vc_data *vc]\n- 调用者: fbcon_switch\n- 被调用者: []\n\n3. 函数名: fbcon_update_softback\n- 参数: [struct vc_data *vc]\n- 调用者: fbcon_switch\n- 被调用者: []\n\n4. 函数名: display_to_var\n- 参数: [struct fb_var_screeninfo *var, struct fbcon_display *p]\n- 调用者: fbcon_switch\n- 被调用者: []\n\n5. 函数名: fb_set_var\n- 参数: [struct fb_info *info, struct fb_var_screeninfo *var]\n- 调用者: fbcon_switch\n- 被调用者: []\n\n6. 函数名: fbcon_del_cursor_timer\n- 参数: [struct fb_info *info]\n- 调用者: fbcon_switch\n- 被调用者: []\n\n7. 函数名: fbcon_add_cursor_timer\n- 参数: [struct fb_info *info]\n- 调用者: fbcon_switch\n- 被调用者: []\n\n8. 函数名: set_blitting_type\n- 参数: [struct vc_data *vc, struct fb_info *info]\n- 调用者: fbcon_switch\n- 被调用者: []\n\n9. 函数名: fb_get_color_depth\n- 参数: [struct fb_var_screeninfo *var, struct fb_fix_screeninfo *fix]\n- 调用者: fbcon_switch\n- 被调用者: []\n\n10. 函数名: updatescrollmode\n- 参数: [struct fbcon_display *p, struct fb_info *info, struct vc_data *vc]\n- 调用者: fbcon_switch\n- 被调用者: []\n\n11. 函数名: fbcon_set_palette\n- 参数: [struct vc_data *vc, color_table]\n- 调用者: fbcon_switch\n- 被调用者: []\n\n12. 函数名: fbcon_clear_margins\n- 参数: [struct vc_data *vc, int clear]\n- 调用者: fbcon_switch\n- 被调用者: []\n\n13. 函数名: fb_show_logo\n- 参数: [struct fb_info *info, int rotate]\n- 调用者: fbcon_switch\n- 被调用者: []\n\n14. 函数名: update_region\n- 参数: [struct vc_data *vc, unsigned long start, int count]\n- 调用者: fbcon_switch\n- 被调用者: []"
    },
    {
        "id": 2530,
        "cwe": "CWE-787",
        "cve": "CVE-2020-14390",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理帧缓冲控制台(fbcon)的显示设置，包括调整屏幕大小、字体属性和显示参数等。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在改变屏幕大小时，由于缺乏对内存边界的充分检查，导致可能发生越界内存写入\"\"\"",
        "functions": "Functions:\n1. 函数名: fbcon_set_disp\n- 参数: [struct fb_info *info, struct fb_var_screeninfo *var, int unit]\n- 调用者: N/A (top-level function)\n- 被调用者: [var_to_display, fb_set_var, fb_get_color_depth, con_set_default_unimap, con_copy_unimap, vc_resize, update_screen, fbcon_update_softback]\n\n2. 函数名: var_to_display\n- 参数: [struct fbcon_display *p, struct fb_var_screeninfo *var, struct fb_info *info]\n- 调用者: fbcon_set_disp\n- 被调用者: []\n\n3. 函数名: fb_set_var\n- 参数: [struct fb_info *info, struct fb_var_screeninfo *var]\n- 调用者: fbcon_set_disp\n- 被调用者: []\n\n4. 函数名: fb_get_color_depth\n- 参数: [struct fb_var_screeninfo *var, struct fb_fix_screeninfo *fix]\n- 调用者: fbcon_set_disp\n- 被调用者: []\n\n5. 函数名: con_set_default_unimap\n- 参数: [struct vc_data *svc]\n- 调用者: fbcon_set_disp\n- 被调用者: []\n\n6. 函数名: con_copy_unimap\n- 参数: [struct vc_data *vc, struct vc_data *svc]\n- 调用者: fbcon_set_disp\n- 被调用者: []\n\n7. 函数名: vc_resize\n- 参数: [struct vc_data *vc, int cols, int rows]\n- 调用者: fbcon_set_disp\n- 被调用者: []\n\n8. 函数名: update_screen\n- 参数: [struct vc_data *vc]\n- 调用者: fbcon_set_disp\n- 被调用者: []\n\n9. 函数名: fbcon_update_softback\n- 参数: [struct vc_data *vc]\n- 调用者: fbcon_set_disp\n- 被调用者: []\n\n10. 函数名: con_is_visible\n- 参数: [struct vc_data *vc]\n- 调用者: fbcon_set_disp\n- 被调用者: []"
    },
    {
        "id": 2531,
        "cwe": "CWE-787",
        "cve": "CVE-2020-14390",
        "purpose": "Code purpose:\"\"\"在改变屏幕大小时处理控制台的滚动偏移量\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在改变屏幕大小时，由于未正确验证softback_lines的值，导致可能发生越界内存写入\"\"\"",
        "functions": "Functions:\n1. 函数名: fbcon_set_origin\n- 参数: [struct vc_data *vc]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [fbcon_scrolldelta]\n\n2. 函数名: fbcon_scrolldelta\n- 参数: [struct vc_data *vc, int lines]\n- 调用者: [fbcon_set_origin]\n- 被调用者: 未明确"
    },
    {
        "id": 2532,
        "cwe": "CWE-787",
        "cve": "CVE-2020-14390",
        "purpose": "Code purpose:\"\"\"处理帧缓冲控制台的光标显示和闪烁功能，包括光标位置、颜色和闪烁时间的设置\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在改变屏幕大小时，由于缺乏对内存边界检查，导致越界内存写入，可能引发内存损坏或拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: fbcon_cursor\n- 参数: [vc, mode]\n- 调用者: 未显示\n- 被调用者: [scr_readw, fbcon_is_inactive, fbcon_del_cursor_timer, fbcon_add_cursor_timer, fbcon_set_origin, get_color, ops->cursor]\n\n2. 函数名: scr_readw\n- 参数: [(u16 *) vc->vc_pos]\n- 调用者: fbcon_cursor\n- 被调用者: 未显示\n\n3. 函数名: fbcon_is_inactive\n- 参数: [vc, info]\n- 调用者: fbcon_cursor\n- 被调用者: 未显示\n\n4. 函数名: fbcon_del_cursor_timer\n- 参数: [info]\n- 调用者: fbcon_cursor\n- 被调用者: 未显示\n\n5. 函数名: fbcon_add_cursor_timer\n- 参数: [info]\n- 调用者: fbcon_cursor\n- 被调用者: 未显示\n\n6. 函数名: fbcon_set_origin\n- 参数: [vc]\n- 调用者: fbcon_cursor\n- 被调用者: 未显示\n\n7. 函数名: get_color\n- 参数: [vc, info, c, 1/0]\n- 调用者: fbcon_cursor\n- 被调用者: 未显示\n\n8. 函数名: ops->cursor\n- 参数: [vc, info, mode, y, get_color(...), get_color(...)]\n- 调用者: fbcon_cursor\n- 被调用者: 未显示"
    },
    {
        "id": 2533,
        "cwe": "CWE-787",
        "cve": "CVE-2020-14390",
        "purpose": "Code purpose:\"\"\"该代码用于设置和控制Linux内核中虚拟控制台(fbcon)的字体显示，包括字体大小调整、内存管理和屏幕更新等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在调整屏幕大小时，由于缺乏对字体数据大小的充分验证，导致可能发生越界内存写入\"\"\"",
        "functions": "Functions:\n1. 函数名: fbcon_do_set_font\n- 参数: [vc, w, h, data, userfont]\n- 调用者: N/A (顶层函数)\n- 被调用者: [con_is_visible, fbcon_set_origin, FNTCHARCNT, set_vc_hi_font, vc_resize, fbcon_update_softback, fbcon_clear_margins, update_screen, kfree]\n\n2. 函数名: con_is_visible\n- 参数: [vc]\n- 调用者: fbcon_do_set_font\n- 被调用者: []\n\n3. 函数名: fbcon_set_origin\n- 参数: [vc]\n- 调用者: fbcon_do_set_font\n- 被调用者: []\n\n4. 函数名: FNTCHARCNT\n- 参数: [data]\n- 调用者: fbcon_do_set_font\n- 被调用者: []\n\n5. 函数名: set_vc_hi_font\n- 参数: [vc, bool]\n- 调用者: fbcon_do_set_font\n- 被调用者: []\n\n6. 函数名: vc_resize\n- 参数: [vc, cols, rows]\n- 调用者: fbcon_do_set_font\n- 被调用者: []\n\n7. 函数名: fbcon_update_softback\n- 参数: [vc]\n- 调用者: fbcon_do_set_font\n- 被调用者: []\n\n8. 函数名: fbcon_clear_margins\n- 参数: [vc, 0]\n- 调用者: fbcon_do_set_font\n- 被调用者: []\n\n9. 函数名: update_screen\n- 参数: [vc]\n- 调用者: fbcon_do_set_font\n- 被调用者: []\n\n10. 函数名: kfree\n- 参数: [old_data - FONT_EXTRA_WORDS * sizeof(int)]\n- 调用者: fbcon_do_set_font\n- 被调用者: []"
    },
    {
        "id": 2534,
        "cwe": "CWE-787",
        "cve": "CVE-2020-14390",
        "purpose": "Code purpose:\"\"\"该代码用于处理Linux内核中帧缓冲控制台的光标闪烁功能，包括获取控制台锁、检查可见性、读取光标位置并绘制或擦除光标。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在修改屏幕大小时，由于缺乏对数组索引的有效边界检查，导致可能发生越界内存写入\"\"\"",
        "functions": "Functions:\n1. 函数名: fb_flashcursor\n- 参数: [work]\n- 调用者: 未显示（由工作队列调用）\n- 被调用者: [container_of, console_trylock, console_unlock, scr_readw, ops->cursor, get_color]\n\n2. 函数名: container_of\n- 参数: [work, struct fb_info, queue]\n- 调用者: fb_flashcursor\n- 被调用者: []\n\n3. 函数名: console_trylock\n- 参数: []\n- 调用者: fb_flashcursor\n- 被调用者: []\n\n4. 函数名: console_unlock\n- 参数: []\n- 调用者: fb_flashcursor\n- 被调用者: []\n\n5. 函数名: scr_readw\n- 参数: [(u16 *) vc->vc_pos]\n- 调用者: fb_flashcursor\n- 被调用者: []\n\n6. 函数名: ops->cursor\n- 参数: [vc, info, mode, softback_lines, get_color(vc, info, c, 1), get_color(vc, info, c, 0)]\n- 调用者: fb_flashcursor\n- 被调用者: []\n\n7. 函数名: get_color\n- 参数: [vc, info, c, 1] 和 [vc, info, c, 0]\n- 调用者: fb_flashcursor\n- 被调用者: []\n\n8. 函数名: con_is_visible\n- 参数: [vc]\n- 调用者: 未显示（条件判断中调用）\n- 被调用者: []"
    },
    {
        "id": 2535,
        "cwe": "CWE-787",
        "cve": "CVE-2020-14390",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理帧缓冲控制台(fbcon)模式改变时的屏幕尺寸调整和相关显示参数更新。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在改变屏幕大小时，由于缺乏对rows和cols值的边界检查，导致可能发生越界内存写入\"\"\"",
        "functions": "Functions:\n1. 函数名: fbcon_modechanged\n- 参数: [struct fb_info *info]\n- 调用者: 未指定（由内核调用）\n- 被调用者: [vc_resize, updatescrollmode, fbcon_is_inactive, fbcon_set_palette, update_screen, fbcon_update_softback, set_blitting_type, var_to_display, con_is_visible]\n\n2. 函数名: vc_resize\n- 参数: [struct vc_data *vc, int cols, int rows]\n- 调用者: fbcon_modechanged\n- 被调用者: []\n\n3. 函数名: updatescrollmode\n- 参数: [struct fbcon_display *p, struct fb_info *info, struct vc_data *vc]\n- 调用者: fbcon_modechanged\n- 被调用者: []\n\n4. 函数名: fbcon_is_inactive\n- 参数: [struct vc_data *vc, struct fb_info *info]\n- 调用者: fbcon_modechanged\n- 被调用者: []\n\n5. 函数名: fbcon_set_palette\n- 参数: [struct vc_data *vc, color_table]\n- 调用者: fbcon_modechanged\n- 被调用者: []\n\n6. 函数名: update_screen\n- 参数: [struct vc_data *vc]\n- 调用者: fbcon_modechanged\n- 被调用者: []\n\n7. 函数名: fbcon_update_softback\n- 参数: [struct vc_data *vc]\n- 调用者: fbcon_modechanged\n- 被调用者: []\n\n8. 函数名: set_blitting_type\n- 参数: [struct vc_data *vc, struct fb_info *info]\n- 调用者: fbcon_modechanged\n- 被调用者: []\n\n9. 函数名: var_to_display\n- 参数: [struct fbcon_display *p, &info->var, info]\n- 调用者: fbcon_modechanged\n- 被调用者: []\n\n10. 函数名: con_is_visible\n- 参数: [struct vc_data *vc]\n- 调用者: fbcon_modechanged\n- 被调用者: []"
    },
    {
        "id": 2536,
        "cwe": "CWE-787",
        "cve": "CVE-2020-14390",
        "purpose": "Code purpose:\"\"\"该代码用于初始化帧缓冲控制台(fb_console)的设置参数，包括字体、滚动缓冲区、控制台映射、虚拟控制台、旋转角度、边距颜色等配置选项的解析和处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理控制台设置参数时，未对输入进行充分边界检查，导致可能发生越界写入内存的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: fb_console_setup\n- 参数: [char *this_opt]\n- 调用者: 未显示（应为内核初始化代码）\n- 被调用者: [strsep, strncmp, strlcpy, simple_strtoul, fbcon_map_override, simple_strtol, strcmp]\n\n2. 函数名: strsep\n- 参数: [char **stringp, const char *delim]\n- 调用者: fb_console_setup\n- 被调用者: []\n\n3. 函数名: strncmp\n- 参数: [const char *s1, const char *s2, size_t n]\n- 调用者: fb_console_setup\n- 被调用者: []\n\n4. 函数名: strlcpy\n- 参数: [char *dest, const char *src, size_t size]\n- 调用者: fb_console_setup\n- 被调用者: []\n\n5. 函数名: simple_strtoul\n- 参数: [const char *cp, char **endp, unsigned int base]\n- 调用者: fb_console_setup\n- 被调用者: []\n\n6. 函数名: fbcon_map_override\n- 参数: []\n- 调用者: fb_console_setup\n- 被调用者: []\n\n7. 函数名: simple_strtol\n- 参数: [const char *cp, char **endp, unsigned int base]\n- 调用者: fb_console_setup\n- 被调用者: []\n\n8. 函数名: strcmp\n- 参数: [const char *s1, const char *s2]\n- 调用者: fb_console_setup\n- 被调用者: []"
    },
    {
        "id": 2537,
        "cwe": "CWE-787",
        "cve": "CVE-2020-14390",
        "purpose": "Code purpose:\"\"\"初始化帧缓冲控制台并处理显示模式设置，包括字体、颜色、屏幕尺寸调整等参数配置\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在改变屏幕大小时，由于未正确验证新的行列值，导致越界内存写入，可能引发内存破坏或拒绝服务\"\"\"",
        "functions": "Functions:\n1. 函数名: fbcon_init\n- 参数: [vc, init]\n- 调用者: N/A (top-level function)\n- 被调用者: [WARN_ON, var_to_display, con2fb_acquire_newinfo, find_font, get_default_font, fb_get_color_depth, con_set_default_unimap, con_copy_unimap, msecs_to_jiffies, set_blitting_type, con_is_visible, fbcon_prepare_logo, fbcon_update_softback]\n\n2. 函数名: WARN_ON\n- 参数: [condition]\n- 调用者: fbcon_init\n- 被调用者: []\n\n3. 函数名: var_to_display\n- 参数: [p, &info->var, info]\n- 调用者: fbcon_init\n- 被调用者: []\n\n4. 函数名: con2fb_acquire_newinfo\n- 参数: [vc, info, vc->vc_num, -1]\n- 调用者: fbcon_init\n- 被调用者: []\n\n5. 函数名: find_font\n- 参数: [fontname]\n- 调用者: fbcon_init\n- 被调用者: []\n\n6. 函数名: get_default_font\n- 参数: [info->var.xres, info->var.yres, info->pixmap.blit_x, info->pixmap.blit_y]\n- 调用者: fbcon_init\n- 被调用者: []\n\n7. 函数名: fb_get_color_depth\n- 参数: [&info->var, &info->fix]\n- 调用者: fbcon_init\n- 被调用者: []\n\n8. 函数名: con_set_default_unimap\n- 参数: [svc]\n- 调用者: fbcon_init\n- 被调用者: []\n\n9. 函数名: con_copy_unimap\n- 参数: [vc, svc]\n- 调用者: fbcon_init\n- 被调用者: []\n\n10. 函数名: msecs_to_jiffies\n- 参数: [vc->vc_cur_blink_ms]\n- 调用者: fbcon_init\n- 被调用者: []\n\n11. 函数名: set_blitting_type\n- 参数: [vc, info]\n- 调用者: fbcon_init\n- 被调用者: []\n\n12. 函数名: con_is_visible\n- 参数: [vc]\n- 调用者: fbcon_init\n- 被调用者: []\n\n13. 函数名: fbcon_prepare_logo\n- 参数: [vc, info, cols, rows, new_cols, new_rows]\n- 调用者: fbcon_init\n- 被调用者: []\n\n14. 函数名: fbcon_update_softback\n- 参数: [vc]\n- 调用者: fbcon_init\n- 被调用者: []\n\n15. 函数名: FBCON_SWAP\n- 参数: [ops->rotate, info->var.xres, info->var.yres]\n- 调用者: fbcon_init\n- 被调用者: []\n\n16. 函数名: vc_resize\n- 参数: [vc, new_cols, new_rows]\n- 调用者: fbcon_init\n- 被调用者: []\n\n17. 函数名: REFCOUNT\n- 参数: [p->fontdata]\n- 调用者: fbcon_init\n- 被调用者: []"
    },
    {
        "id": 2538,
        "cwe": "CWE-787",
        "cve": "CVE-2020-14390",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理帧缓冲控制台(fbcon)的退出操作，包括释放相关资源、取消挂起工作、解除映射关系等清理工作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在修改屏幕大小时，由于缺乏对数组边界的检查，导致越界内存写入\"\"\"",
        "functions": "Functions:\n1. 函数名: fbcon_exit\n- 参数: []\n- 调用者: \n- 被调用者: [kvfree, cancel_work_sync, module_put, fbcon_del_cursor_timer, kfree]\n\n2. 函数名: dummycon_unregister_output_notifier\n- 参数: [&fbcon_output_nb]\n- 调用者: fbcon_exit\n- 被调用者: []\n\n3. 函数名: kvfree\n- 参数: [(void *)softback_buf]\n- 调用者: fbcon_exit\n- 被调用者: []\n\n4. 函数名: cancel_work_sync\n- 参数: [&info->queue]\n- 调用者: fbcon_exit\n- 被调用者: []\n\n5. 函数名: module_put\n- 参数: [info->fbops->owner]\n- 调用者: fbcon_exit\n- 被调用者: []\n\n6. 函数名: fbcon_del_cursor_timer\n- 参数: [info]\n- 调用者: fbcon_exit\n- 被调用者: []\n\n7. 函数名: kfree\n- 参数: [ops->cursor_src, ops->cursor_state.mask, info->fbcon_par]\n- 调用者: fbcon_exit\n- 被调用者: []"
    },
    {
        "id": 2539,
        "cwe": "CWE-787",
        "cve": "CVE-2020-14390",
        "purpose": "Code purpose:\"\"\"处理控制台屏幕滚动操作，包括向上和向下滚动，并管理相关的显示缓冲区和内存操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在改变屏幕大小时，由于缺乏对内存写入边界的充分检查，导致可能发生越界写入内存的情况\"\"\"",
        "functions": "Functions:\n1. 函数名: fbcon_scroll\n- 参数: [vc, t, b, dir, count]\n- 调用者: N/A (顶层函数)\n- 被调用者: [fbcon_is_inactive, fbcon_cursor, fbcon_softback_note, fbcon_redraw_blit, fbcon_clear, scr_memsetw, fbcon_bmove, ywrap_up, fbcon_redraw_move, ypan_up_redraw, ypan_up, fbcon_redraw, ywrap_down, ypan_down, ypan_down_redraw]\n\n2. 函数名: fbcon_is_inactive\n- 参数: [vc, info]\n- 调用者: fbcon_scroll\n- 被调用者: []\n\n3. 函数名: fbcon_cursor\n- 参数: [vc, CM_ERASE]\n- 调用者: fbcon_scroll\n- 被调用者: []\n\n4. 函数名: fbcon_softback_note\n- 参数: [vc, t, count]\n- 调用者: fbcon_scroll\n- 被调用者: []\n\n5. 函数名: fbcon_redraw_blit\n- 参数: [vc, info, p, t, b - t - count, count]\n- 调用者: fbcon_scroll\n- 被调用者: []\n\n6. 函数名: fbcon_clear\n- 参数: [vc, b - count, 0, count, vc->vc_cols]\n- 调用者: fbcon_scroll\n- 被调用者: []\n\n7. 函数名: scr_memsetw\n- 参数: [(unsigned short *) (vc->vc_origin + vc->vc_size_row * (b - count)), vc->vc_video_erase_char, vc->vc_size_row * count]\n- 调用者: fbcon_scroll\n- 被调用者: []\n\n8. 函数名: fbcon_bmove\n- 参数: [vc, 0, 0, count, 0, t, vc->vc_cols]\n- 调用者: fbcon_scroll\n- 被调用者: []\n\n9. 函数名: ywrap_up\n- 参数: [vc, count]\n- 调用者: fbcon_scroll\n- 被调用者: []\n\n10. 函数名: fbcon_redraw_move\n- 参数: [vc, p, 0, t, count]\n- 调用者: fbcon_scroll\n- 被调用者: []\n\n11. 函数名: ypan_up_redraw\n- 参数: [vc, t, count]\n- 调用者: fbcon_scroll\n- 被调用者: []\n\n12. 函数名: ypan_up\n- 参数: [vc, count]\n- 调用者: fbcon_scroll\n- 被调用者: []\n\n13. 函数名: fbcon_redraw\n- 参数: [vc, p, t, b - t - count, count * vc->vc_cols]\n- 调用者: fbcon_scroll\n- 被调用者: []\n\n14. 函数名: ywrap_down\n- 参数: [vc, count]\n- 调用者: fbcon_scroll\n- 被调用者: []\n\n15. 函数名: ypan_down\n- 参数: [vc, count]\n- 调用者: fbcon_scroll\n- 被调用者: []\n\n16. 函数名: ypan_down_redraw\n- 参数: [vc, t, count]\n- 调用者: fbcon_scroll\n- 被调用者: []"
    },
    {
        "id": 2578,
        "cwe": "CWE-787",
        "cve": "CVE-2020-25212",
        "purpose": "Code purpose:\"\"\"该代码用于从NFS服务器获取指定inode的安全标签信息，并将其复制到提供的缓冲区中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"NFS客户端代码中存在TOCTOU竞争条件，由于大小检查在nfs4proc.c而非nfs4xdr.c中进行，导致本地攻击者可能利用时间差破坏内存或造成其他影响\"\"\"",
        "functions": "Functions:\n1. 函数名: _nfs4_get_security_label\n- 参数: [struct inode *inode, void *buf, size_t buflen]\n- 调用者: 未显示\n- 被调用者: [nfs_fattr_init, nfs4_call_sync]\n\n2. 函数名: nfs_fattr_init\n- 参数: [struct nfs_fattr *fattr]\n- 调用者: _nfs4_get_security_label\n- 被调用者: 未显示\n\n3. 函数名: nfs4_call_sync\n- 参数: [struct rpc_clnt *clnt, struct nfs_server *server, struct rpc_message *msg, struct nfs4_sequence_args *args, struct nfs4_sequence_res *res, int cache_reply]\n- 调用者: _nfs4_get_security_label\n- 被调用者: 未显示"
    },
    {
        "id": 2579,
        "cwe": "CWE-787",
        "cve": "CVE-2020-25212",
        "purpose": "Code purpose:\"\"\"解码NFSv4安全标签属性并将其复制到标签结构中，同时进行长度检查以防止缓冲区溢出\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"NFS客户端代码中存在TOCTOU竞态条件漏洞，由于大小检查在fs/nfs/nfs4proc.c而非fs/nfs/nfs4xdr.c中执行，导致本地攻击者可利用时间差破坏内存或造成其他影响\"\"\"",
        "functions": "Functions:\n1. 函数名: decode_attr_security_label\n- 参数: [struct xdr_stream *xdr, uint32_t *bitmap, struct nfs4_label *label]\n- 调用者: 未明确显示（应为NFS客户端代码中的调用者）\n- 被调用者: [xdr_inline_decode, be32_to_cpup, memcpy, printk, dprintk]\n\n2. 函数名: xdr_inline_decode\n- 参数: [struct xdr_stream *xdr, int len]\n- 调用者: decode_attr_security_label\n- 被调用者: 未显示（应为XDR解码相关函数）\n\n3. 函数名: be32_to_cpup\n- 参数: [__be32 *p]\n- 调用者: decode_attr_security_label\n- 被调用者: 未显示（应为字节序转换函数）\n\n4. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: decode_attr_security_label\n- 被调用者: 未显示（标准库函数）\n\n5. 函数名: printk\n- 参数: [const char *fmt, ...]\n- 调用者: decode_attr_security_label\n- 被调用者: 未显示（内核打印函数）\n\n6. 函数名: dprintk\n- 参数: [const char *fmt, ...]\n- 调用者: decode_attr_security_label\n- 被调用者: 未显示（调试打印函数）"
    },
    {
        "id": 2586,
        "cwe": "CWE-787",
        "cve": "CVE-2020-25285",
        "purpose": "Code purpose:\"\"\"该代码用于处理Linux内核中hugetlb子系统的overcommit设置，通过proc文件系统接口允许读写大页内存的overcommit值\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在hugetlb_overcommit_handler函数中存在竞态条件，多个sysctl处理程序可能同时访问和修改h->nr_overcommit_huge_pages变量，导致内存损坏或空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: hugetlb_overcommit_handler\n- 参数: [struct ctl_table *table, int write, void *buffer, size_t *length, loff_t *ppos]\n- 调用者: 未明确显示（应为内核sysctl处理机制）\n- 被调用者: [hugepages_supported, hstate_is_gigantic, proc_doulongvec_minmax]\n\n2. 函数名: hugepages_supported\n- 参数: []\n- 调用者: hugetlb_overcommit_handler\n- 被调用者: []\n\n3. 函数名: hstate_is_gigantic\n- 参数: [struct hstate *h]\n- 调用者: hugetlb_overcommit_handler\n- 被调用者: []\n\n4. 函数名: proc_doulongvec_minmax\n- 参数: [struct ctl_table *table, int write, void *buffer, size_t *length, loff_t *ppos]\n- 调用者: hugetlb_overcommit_handler\n- 被调用者: []"
    },
    {
        "id": 2587,
        "cwe": "CWE-787",
        "cve": "CVE-2020-25285",
        "purpose": "Code purpose:\"\"\"该代码用于处理hugetlb系统控制参数的读写操作，包括设置和获取大页内存的最大数量\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于hugetlb_sysctl_handler_common函数在处理sysctl操作时存在竞态条件，多个处理器同时访问可能导致内存损坏或空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: hugetlb_sysctl_handler_common\n- 参数: [obey_mempolicy, table, write, buffer, length, ppos]\n- 调用者: 未明确显示（可能是sysctl处理函数）\n- 被调用者: [hugepages_supported, proc_doulongvec_minmax, __nr_hugepages_store_common]\n\n2. 函数名: hugepages_supported\n- 参数: []\n- 调用者: hugetlb_sysctl_handler_common\n- 被调用者: []\n\n3. 函数名: proc_doulongvec_minmax\n- 参数: [table, write, buffer, length, ppos]\n- 调用者: hugetlb_sysctl_handler_common\n- 被调用者: []\n\n4. 函数名: __nr_hugepages_store_common\n- 参数: [obey_mempolicy, h, NUMA_NO_NODE, tmp, *length]\n- 调用者: hugetlb_sysctl_handler_common\n- 被调用者: []"
    },
    {
        "id": 2808,
        "cwe": "CWE-787",
        "cve": "CVE-2020-8835",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的BPF验证器中设置和调整寄存器的最小/最大值范围，以验证32位操作的边界安全性，防止越界访问。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中的BPF验证器未正确限制32位操作的寄存器边界，导致内核内存的越界读写漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: reg_set_min_max_inv\n- 参数: [struct bpf_reg_state *true_reg, struct bpf_reg_state *false_reg, u64 val, u8 opcode, bool is_jmp32]\n- 调用者: 未明确（由BPF验证器调用）\n- 被调用者: [__is_pointer_value, __mark_reg_known, tnum_and, tnum_const, tnum_or, is_power_of_2, gen_hi_min, gen_hi_max, max, min, cmp_val_with_extended_s64, __reg_deduce_bounds, __reg_bound_offset, __reg_bound_offset32, __update_reg_bounds]\n\n2. 函数名: __is_pointer_value\n- 参数: [bool, struct bpf_reg_state *]\n- 调用者: reg_set_min_max_inv\n- 被调用者: []\n\n3. 函数名: __mark_reg_known\n- 参数: [struct bpf_reg_state *, u64]\n- 调用者: reg_set_min_max_inv\n- 被调用者: []\n\n4. 函数名: tnum_and\n- 参数: [struct tnum, struct tnum]\n- 调用者: reg_set_min_max_inv\n- 被调用者: []\n\n5. 函数名: tnum_const\n- 参数: [u64]\n- 调用者: reg_set_min_max_inv\n- 被调用者: []\n\n6. 函数名: tnum_or\n- 参数: [struct tnum, struct tnum]\n- 调用者: reg_set_min_max_inv\n- 被调用者: []\n\n7. 函数名: is_power_of_2\n- 参数: [u64]\n- 调用者: reg_set_min_max_inv\n- 被调用者: []\n\n8. 函数名: gen_hi_min\n- 参数: [struct tnum]\n- 调用者: reg_set_min_max_inv\n- 被调用者: []\n\n9. 函数名: gen_hi_max\n- 参数: [struct tnum]\n- 调用者: reg_set_min_max_inv\n- 被调用者: []\n\n10. 函数名: max\n- 参数: [u64, u64]\n- 调用者: reg_set_min_max_inv\n- 被调用者: []\n\n11. 函数名: min\n- 参数: [u64, u64]\n- 调用者: reg_set_min_max_inv\n- 被调用者: []\n\n12. 函数名: cmp_val_with_extended_s64\n- 参数: [s64, struct bpf_reg_state *]\n- 调用者: reg_set_min_max_inv\n- 被调用者: []\n\n13. 函数名: __reg_deduce_bounds\n- 参数: [struct bpf_reg_state *]\n- 调用者: reg_set_min_max_inv\n- 被调用者: []\n\n14. 函数名: __reg_bound_offset\n- 参数: [struct bpf_reg_state *]\n- 调用者: reg_set_min_max_inv\n- 被调用者: []\n\n15. 函数名: __reg_bound_offset32\n- 参数: [struct bpf_reg_state *]\n- 调用者: reg_set_min_max_inv\n- 被调用者: []\n\n16. 函数名: __update_reg_bounds\n- 参数: [struct bpf_reg_state *]\n- 调用者: reg_set_min_max_inv\n- 被调用者: []"
    },
    {
        "id": 2809,
        "cwe": "CWE-787",
        "cve": "CVE-2020-8835",
        "purpose": "Code purpose:\"\"\"该代码用于在BPF验证器中设置和调整寄存器的最小最大值范围，以进行边界检查和安全验证。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中的BPF验证器未正确限制32位操作的寄存器边界，导致内核内存的越界读写\"\"\"",
        "functions": "Functions:\n1. 函数名: reg_set_min_max\n- 参数: [struct bpf_reg_state *true_reg, struct bpf_reg_state *false_reg, u64 val, u8 opcode, bool is_jmp32]\n- 调用者: 未明确（由BPF验证器调用）\n- 被调用者: [__is_pointer_value, __mark_reg_known, tnum_and, tnum_or, is_power_of_2, gen_hi_max, gen_hi_min, cmp_val_with_extended_s64, __reg_deduce_bounds, __reg_bound_offset, __reg_bound_offset32, __update_reg_bounds]\n\n2. 函数名: __is_pointer_value\n- 参数: [bool, struct bpf_reg_state *]\n- 调用者: reg_set_min_max\n- 被调用者: []\n\n3. 函数名: __mark_reg_known\n- 参数: [struct bpf_reg_state *, u64]\n- 调用者: reg_set_min_max\n- 被调用者: []\n\n4. 函数名: tnum_and\n- 参数: [tnum, tnum]\n- 调用者: reg_set_min_max\n- 被调用者: []\n\n5. 函数名: tnum_or\n- 参数: [tnum, tnum]\n- 调用者: reg_set_min_max\n- 被调用者: []\n\n6. 函数名: is_power_of_2\n- 参数: [u64]\n- 调用者: reg_set_min_max\n- 被调用者: []\n\n7. 函数名: gen_hi_max\n- 参数: [tnum]\n- 调用者: reg_set_min_max\n- 被调用者: []\n\n8. 函数名: gen_hi_min\n- 参数: [tnum]\n- 调用者: reg_set_min_max\n- 被调用者: []\n\n9. 函数名: cmp_val_with_extended_s64\n- 参数: [s64, struct bpf_reg_state *]\n- 调用者: reg_set_min_max\n- 被调用者: []\n\n10. 函数名: __reg_deduce_bounds\n- 参数: [struct bpf_reg_state *]\n- 调用者: reg_set_min_max\n- 被调用者: []\n\n11. 函数名: __reg_bound_offset\n- 参数: [struct bpf_reg_state *]\n- 调用者: reg_set_min_max\n- 被调用者: []\n\n12. 函数名: __reg_bound_offset32\n- 参数: [struct bpf_reg_state *]\n- 调用者: reg_set_min_max\n- 被调用者: []\n\n13. 函数名: __update_reg_bounds\n- 参数: [struct bpf_reg_state *]\n- 调用者: reg_set_min_max\n- 被调用者: []"
    },
    {
        "id": 2812,
        "cwe": "CWE-787",
        "cve": "CVE-2020-9391",
        "purpose": "Code purpose:\"\"\"处理内存映射请求，包括匿名映射和hugepage映射，并返回映射结果\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在AArch64架构上处理brk系统调用时忽略了地址的高字节，导致内存边界可能向下移动而非应用程序预期的向上移动\"\"\"",
        "functions": "Functions:\n1. 函数名: ksys_mmap_pgoff\n- 参数: [addr, len, prot, flags, fd, pgoff]\n- 调用者: N/A (系统调用入口)\n- 被调用者: [untagged_addr, audit_mmap_fd, fget, is_file_hugepages, ALIGN, huge_page_size, hstate_file, hstate_sizelog, hugetlb_file_setup, vm_mmap_pgoff, fput]\n\n2. 函数名: untagged_addr\n- 参数: [addr]\n- 调用者: ksys_mmap_pgoff\n- 被调用者: []\n\n3. 函数名: audit_mmap_fd\n- 参数: [fd, flags]\n- 调用者: ksys_mmap_pgoff\n- 被调用者: []\n\n4. 函数名: fget\n- 参数: [fd]\n- 调用者: ksys_mmap_pgoff\n- 被调用者: []\n\n5. 函数名: is_file_hugepages\n- 参数: [file]\n- 调用者: ksys_mmap_pgoff\n- 被调用者: []\n\n6. 函数名: ALIGN\n- 参数: [len, size]\n- 调用者: ksys_mmap_pgoff\n- 被调用者: []\n\n7. 函数名: huge_page_size\n- 参数: [hs]\n- 调用者: ksys_mmap_pgoff\n- 被调用者: []\n\n8. 函数名: hstate_file\n- 参数: [file]\n- 调用者: ksys_mmap_pgoff\n- 被调用者: []\n\n9. 函数名: hstate_sizelog\n- 参数: [size_log]\n- 调用者: ksys_mmap_pgoff\n- 被调用者: []\n\n10. 函数名: hugetlb_file_setup\n- 参数: [HUGETLB_ANON_FILE, len, VM_NORESERVE, user, HUGETLB_ANONHUGE_INODE, mask]\n- 调用者: ksys_mmap_pgoff\n- 被调用者: []\n\n11. 函数名: vm_mmap_pgoff\n- 参数: [file, addr, len, prot, flags, pgoff]\n- 调用者: ksys_mmap_pgoff\n- 被调用者: []\n\n12. 函数名: fput\n- 参数: [file]\n- 调用者: ksys_mmap_pgoff\n- 被调用者: []"
    },
    {
        "id": 2813,
        "cwe": "CWE-787",
        "cve": "CVE-2020-9391",
        "purpose": "Code purpose:\"\"\"处理brk系统调用，用于调整进程的数据段内存边界\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在AArch64架构上处理brk系统调用时忽略了地址的最高字节，导致内存边界可能向下移动而非应用程序预期的向上移动\"\"\"",
        "functions": "Functions:\n1. 函数名: SYSCALL_DEFINE1(brk, unsigned long, brk)\n- 参数: [unsigned long brk]\n- 调用者: 系统调用\n- 被调用者: [untagged_addr, down_write_killable, check_data_rlimit, PAGE_ALIGN, __do_munmap, find_vma, do_brk_flags, up_read, up_write, userfaultfd_unmap_complete, mm_populate]\n\n2. 函数名: untagged_addr\n- 参数: [unsigned long brk]\n- 调用者: SYSCALL_DEFINE1(brk, unsigned long, brk)\n- 被调用者: []\n\n3. 函数名: down_write_killable\n- 参数: [&mm->mmap_sem]\n- 调用者: SYSCALL_DEFINE1(brk, unsigned long, brk)\n- 被调用者: []\n\n4. 函数名: check_data_rlimit\n- 参数: [rlimit(RLIMIT_DATA), brk, mm->start_brk, mm->end_data, mm->start_data]\n- 调用者: SYSCALL_DEFINE1(brk, unsigned long, brk)\n- 被调用者: []\n\n5. 函数名: PAGE_ALIGN\n- 参数: [brk, mm->brk]\n- 调用者: SYSCALL_DEFINE1(brk, unsigned long, brk)\n- 被调用者: []\n\n6. 函数名: __do_munmap\n- 参数: [mm, newbrk, oldbrk-newbrk, &uf, true]\n- 调用者: SYSCALL_DEFINE1(brk, unsigned long, brk)\n- 被调用者: []\n\n7. 函数名: find_vma\n- 参数: [mm, oldbrk]\n- 调用者: SYSCALL_DEFINE1(brk, unsigned long, brk)\n- 被调用者: []\n\n8. 函数名: do_brk_flags\n- 参数: [oldbrk, newbrk-oldbrk, 0, &uf]\n- 调用者: SYSCALL_DEFINE1(brk, unsigned long, brk)\n- 被调用者: []\n\n9. 函数名: up_read\n- 参数: [&mm->mmap_sem]\n- 调用者: SYSCALL_DEFINE1(brk, unsigned long, brk)\n- 被调用者: []\n\n10. 函数名: up_write\n- 参数: [&mm->mmap_sem]\n- 调用者: SYSCALL_DEFINE1(brk, unsigned long, brk)\n- 被调用者: []\n\n11. 函数名: userfaultfd_unmap_complete\n- 参数: [mm, &uf]\n- 调用者: SYSCALL_DEFINE1(brk, unsigned long, brk)\n- 被调用者: []\n\n12. 函数名: mm_populate\n- 参数: [oldbrk, newbrk - oldbrk]\n- 调用者: SYSCALL_DEFINE1(brk, unsigned long, brk)\n- 被调用者: []"
    },
    {
        "id": 2814,
        "cwe": "CWE-787",
        "cve": "CVE-2020-9391",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中的mremap系统调用，用于重新映射虚拟内存区域，支持内存区域的扩展、收缩和移动操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核在AArch64架构上处理brk系统调用时忽略了地址的高字节，导致内存边界可能向下移动而非应用程序预期的向上移动，从而引发堆损坏问题。\"\"\"",
        "functions": "Functions:\n1. 函数名: SYSCALL_DEFINE5(mremap)\n- 参数: [unsigned long addr, unsigned long old_len, unsigned long new_len, unsigned long flags, unsigned long new_addr]\n- 调用者: 系统调用\n- 被调用者: [untagged_addr, offset_in_page, PAGE_ALIGN, down_write_killable, mremap_to, __do_munmap, vma_to_resize, vma_expandable, vma_adjust, vm_stat_account, get_unmapped_area, move_vma, vm_unacct_memory, up_read, up_write, mm_populate, userfaultfd_unmap_complete, mremap_userfaultfd_complete]\n\n2. 函数名: untagged_addr\n- 参数: [unsigned long addr]\n- 调用者: SYSCALL_DEFINE5(mremap)\n- 被调用者: []\n\n3. 函数名: offset_in_page\n- 参数: [unsigned long addr]\n- 调用者: SYSCALL_DEFINE5(mremap)\n- 被调用者: []\n\n4. 函数名: PAGE_ALIGN\n- 参数: [unsigned long len]\n- 调用者: SYSCALL_DEFINE5(mremap)\n- 被调用者: []\n\n5. 函数名: down_write_killable\n- 参数: [struct rw_semaphore *sem]\n- 调用者: SYSCALL_DEFINE5(mremap)\n- 被调用者: []\n\n6. 函数名: mremap_to\n- 参数: [unsigned long addr, unsigned long old_len, unsigned long new_addr, unsigned long new_len, bool *locked, struct vm_userfaultfd_ctx *uf, struct list_head *uf_unmap_early, struct list_head *uf_unmap]\n- 调用者: SYSCALL_DEFINE5(mremap)\n- 被调用者: []\n\n7. 函数名: __do_munmap\n- 参数: [struct mm_struct *mm, unsigned long start, size_t len, struct list_head *uf, bool downgrade]\n- 调用者: SYSCALL_DEFINE5(mremap)\n- 被调用者: []\n\n8. 函数名: vma_to_resize\n- 参数: [unsigned long addr, unsigned long old_len, unsigned long new_len, unsigned long *charged]\n- 调用者: SYSCALL_DEFINE5(mremap)\n- 被调用者: []\n\n9. 函数名: vma_expandable\n- 参数: [struct vm_area_struct *vma, unsigned long delta]\n- 调用者: SYSCALL_DEFINE5(mremap)\n- 被调用者: []\n\n10. 函数名: vma_adjust\n- 参数: [struct vm_area_struct *vma, unsigned long start, unsigned long end, pgoff_t pgoff, struct vm_area_struct *insert]\n- 调用者: SYSCALL_DEFINE5(mremap)\n- 被调用者: []\n\n11. 函数名: vm_stat_account\n- 参数: [struct mm_struct *mm, unsigned long flags, long pages]\n- 调用者: SYSCALL_DEFINE5(mremap)\n- 被调用者: []\n\n12. 函数名: get_unmapped_area\n- 参数: [struct file *file, unsigned long addr, unsigned long len, unsigned long pgoff, unsigned long flags]\n- 调用者: SYSCALL_DEFINE5(mremap)\n- 被调用者: []\n\n13. 函数名: move_vma\n- 参数: [struct vm_area_struct *vma, unsigned long old_addr, unsigned long old_len, unsigned long new_len, unsigned long new_addr, bool *locked, struct vm_userfaultfd_ctx *uf, struct list_head *uf_unmap]\n- 调用者: SYSCALL_DEFINE5(mremap)\n- 被调用者: []\n\n14. 函数名: vm_unacct_memory\n- 参数: [unsigned long charged]\n- 调用者: SYSCALL_DEFINE5(mremap)\n- 被调用者: []\n\n15. 函数名: up_read\n- 参数: [struct rw_semaphore *sem]\n- 调用者: SYSCALL_DEFINE5(mremap)\n- 被调用者: []\n\n16. 函数名: up_write\n- 参数: [struct rw_semaphore *sem]\n- 调用者: SYSCALL_DEFINE5(mremap)\n- 被调用者: []\n\n17. 函数名: mm_populate\n- 参数: [unsigned long addr, unsigned long len]\n- 调用者: SYSCALL_DEFINE5(mremap)\n- 被调用者: []\n\n18. 函数名: userfaultfd_unmap_complete\n- 参数: [struct mm_struct *mm, struct list_head *uf_unmap]\n- 调用者: SYSCALL_DEFINE5(mremap)\n- 被调用者: []\n\n19. 函数名: mremap_userfaultfd_complete\n- 参数: [struct vm_userfaultfd_ctx *uf, unsigned long addr, unsigned long new_addr, unsigned long old_len]\n- 调用者: SYSCALL_DEFINE5(mremap)\n- 被调用者: []"
    },
    {
        "id": 2827,
        "cwe": "CWE-787",
        "cve": "CVE-2021-0512",
        "purpose": "Code purpose:\"\"\"该代码用于在HID解析器中添加字段，处理报告数据并注册字段信息，包括设置字段的各种属性和使用情况。\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在hid_add_field函数中未充分验证parser->local.usage_index与parser->global.report_count的关系，导致可能发生堆缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: hid_add_field\n- 参数: [struct hid_parser *parser, unsigned report_type, unsigned flags]\n- 调用者: 未提供\n- 被调用者: [hid_lookup_collection, hid_register_report, max_t, hid_register_field]\n\n2. 函数名: hid_lookup_collection\n- 参数: [struct hid_parser *parser, HID_COLLECTION_APPLICATION]\n- 调用者: hid_add_field\n- 被调用者: 未提供\n\n3. 函数名: hid_register_report\n- 参数: [parser->device, report_type, parser->global.report_id, application]\n- 调用者: hid_add_field\n- 被调用者: 未提供\n\n4. 函数名: max_t\n- 参数: [unsigned, parser->local.usage_index, parser->global.report_count]\n- 调用者: hid_add_field\n- 被调用者: 未提供\n\n5. 函数名: hid_register_field\n- 参数: [report, usages, parser->global.report_count]\n- 调用者: hid_add_field\n- 被调用者: 未提供"
    },
    {
        "id": 2832,
        "cwe": "CWE-787",
        "cve": "CVE-2021-0935",
        "purpose": "Code purpose:\"\"\"该代码实现了IPv6数据报的连接功能，处理IPv6套接字连接请求并设置相关参数，包括地址类型检查、流标签处理、地址映射转换等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在ip6_xmit函数中存在释放后使用(UAF)的情况，导致可能发生越界写入，从而引发本地权限提升漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: __ip6_datagram_connect\n- 参数: [struct sock *sk, struct sockaddr *uaddr, int addr_len]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [__ipv6_only_sock, __ip4_datagram_connect, ipv6_addr_any, ipv6_addr_v4mapped, ipv6_addr_set_v4mapped, ipv6_addr_type, ipv6_mapped_addr_any, sk_dev_equal_l3scope, ip6_datagram_dst_update, memset, sk_set_txhash]\n\n2. 函数名: __ipv6_only_sock\n- 参数: [struct sock *sk]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n3. 函数名: __ip4_datagram_connect\n- 参数: [struct sock *sk, struct sockaddr *uaddr, int addr_len]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n4. 函数名: ipv6_addr_any\n- 参数: [const struct in6_addr *addr]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n5. 函数名: ipv6_addr_v4mapped\n- 参数: [const struct in6_addr *addr]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n6. 函数名: ipv6_addr_set_v4mapped\n- 参数: [__be32 addr, struct in6_addr *v4mapped]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n7. 函数名: ipv6_addr_type\n- 参数: [const struct in6_addr *addr]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n8. 函数名: ipv6_mapped_addr_any\n- 参数: [const struct in6_addr *addr]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n9. 函数名: sk_dev_equal_l3scope\n- 参数: [struct sock *sk, int scope_id]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n10. 函数名: ip6_datagram_dst_update\n- 参数: [struct sock *sk, bool connect]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n11. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []\n\n12. 函数名: sk_set_txhash\n- 参数: [struct sock *sk]\n- 调用者: __ip6_datagram_connect\n- 被调用者: []"
    },
    {
        "id": 2881,
        "cwe": "CWE-787",
        "cve": "CVE-2021-22555",
        "purpose": "Code purpose:\"\"\"将兼容模式的ARP表规则转换为原生格式并进行验证和复制\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在转换兼容表时未正确验证用户提供的compatr->size和compatr->num_entries参数，导致堆越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: translate_compat_table\n- 参数: [struct net *net, struct xt_table_info **pinfo, void **pentry0, const struct compat_arpt_replace *compatr]\n- 调用者: 未显示\n- 被调用者: [xt_compat_lock, xt_compat_init_offsets, check_compat_entry_size_and_hooks, xt_alloc_table_info, compat_copy_entry_from_user, xt_compat_flush_offsets, xt_compat_unlock, memcpy, translate_table, xt_free_table_info, compat_release_entry]\n\n2. 函数名: xt_compat_lock\n- 参数: [NFPROTO_ARP]\n- 调用者: translate_compat_table\n- 被调用者: 未显示\n\n3. 函数名: xt_compat_init_offsets\n- 参数: [NFPROTO_ARP, compatr->num_entries]\n- 调用者: translate_compat_table\n- 被调用者: 未显示\n\n4. 函数名: check_compat_entry_size_and_hooks\n- 参数: [iter0, info, &size, entry0, entry0 + compatr->size]\n- 调用者: translate_compat_table\n- 被调用者: 未显示\n\n5. 函数名: xt_alloc_table_info\n- 参数: [size]\n- 调用者: translate_compat_table\n- 被调用者: 未显示\n\n6. 函数名: compat_copy_entry_from_user\n- 参数: [iter0, &pos, &size, newinfo, entry1]\n- 调用者: translate_compat_table\n- 被调用者: 未显示\n\n7. 函数名: xt_compat_flush_offsets\n- 参数: [NFPROTO_ARP]\n- 调用者: translate_compat_table\n- 被调用者: 未显示\n\n8. 函数名: xt_compat_unlock\n- 参数: [NFPROTO_ARP]\n- 调用者: translate_compat_table\n- 被调用者: 未显示\n\n9. 函数名: memcpy\n- 参数: [&repl, compatr, sizeof(*compatr)]\n- 调用者: translate_compat_table\n- 被调用者: 未显示\n\n10. 函数名: translate_table\n- 参数: [net, newinfo, entry1, &repl]\n- 调用者: translate_compat_table\n- 被调用者: 未显示\n\n11. 函数名: xt_free_table_info\n- 参数: [info] 或 [newinfo]\n- 调用者: translate_compat_table\n- 被调用者: 未显示\n\n12. 函数名: compat_release_entry\n- 参数: [iter0]\n- 调用者: translate_compat_table\n- 被调用者: 未显示"
    },
    {
        "id": 2882,
        "cwe": "CWE-787",
        "cve": "CVE-2021-22555",
        "purpose": "Code purpose:\"\"\"将兼容模式的iptables规则表转换为64位模式的规则表，并进行验证和偏移量处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证用户提供的compatr->size和compatr->num_entries参数，导致在复制条目时可能发生堆越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: translate_compat_table\n- 参数: [struct net *net, struct xt_table_info **pinfo, void **pentry0, const struct compat_ipt_replace *compatr]\n- 调用者: N/A (top-level function)\n- 被调用者: [xt_compat_lock, xt_compat_init_offsets, check_compat_entry_size_and_hooks, xt_alloc_table_info, compat_copy_entry_from_user, xt_compat_flush_offsets, xt_compat_unlock, translate_table, xt_free_table_info, compat_release_entry]\n\n2. 函数名: xt_compat_lock\n- 参数: [AF_INET]\n- 调用者: translate_compat_table\n- 被调用者: []\n\n3. 函数名: xt_compat_init_offsets\n- 参数: [AF_INET, compatr->num_entries]\n- 调用者: translate_compat_table\n- 被调用者: []\n\n4. 函数名: check_compat_entry_size_and_hooks\n- 参数: [iter0, info, &size, entry0, entry0 + compatr->size]\n- 调用者: translate_compat_table\n- 被调用者: []\n\n5. 函数名: xt_alloc_table_info\n- 参数: [size]\n- 调用者: translate_compat_table\n- 被调用者: []\n\n6. 函数名: compat_copy_entry_from_user\n- 参数: [iter0, &pos, &size, newinfo, entry1]\n- 调用者: translate_compat_table\n- 被调用者: []\n\n7. 函数名: xt_compat_flush_offsets\n- 参数: [AF_INET]\n- 调用者: translate_compat_table\n- 被调用者: []\n\n8. 函数名: xt_compat_unlock\n- 参数: [AF_INET]\n- 调用者: translate_compat_table\n- 被调用者: []\n\n9. 函数名: translate_table\n- 参数: [net, newinfo, entry1, &repl]\n- 调用者: translate_compat_table\n- 被调用者: []\n\n10. 函数名: xt_free_table_info\n- 参数: [info]\n- 调用者: translate_compat_table\n- 被调用者: []\n\n11. 函数名: compat_release_entry\n- 参数: [iter0]\n- 调用者: translate_compat_table\n- 被调用者: []"
    },
    {
        "id": 2883,
        "cwe": "CWE-787",
        "cve": "CVE-2021-22555",
        "purpose": "Code purpose:\"\"\"将兼容模式的IPv6防火墙规则表转换为原生格式并进行验证\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在转换兼容表时未正确验证用户提供的compatr->size和compatr->num_entries参数，导致堆越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: translate_compat_table\n- 参数: [struct net *net, struct xt_table_info **pinfo, void **pentry0, const struct compat_ip6t_replace *compatr]\n- 调用者: 未显示\n- 被调用者: [xt_compat_lock, xt_compat_init_offsets, check_compat_entry_size_and_hooks, xt_alloc_table_info, compat_copy_entry_from_user, xt_compat_flush_offsets, xt_compat_unlock, memcpy, translate_table, xt_free_table_info, compat_release_entry]\n\n2. 函数名: xt_compat_lock\n- 参数: [AF_INET6]\n- 调用者: translate_compat_table\n- 被调用者: 未显示\n\n3. 函数名: xt_compat_init_offsets\n- 参数: [AF_INET6, compatr->num_entries]\n- 调用者: translate_compat_table\n- 被调用者: 未显示\n\n4. 函数名: check_compat_entry_size_and_hooks\n- 参数: [iter0, info, &size, entry0, entry0 + compatr->size]\n- 调用者: translate_compat_table\n- 被调用者: 未显示\n\n5. 函数名: xt_alloc_table_info\n- 参数: [size]\n- 调用者: translate_compat_table\n- 被调用者: 未显示\n\n6. 函数名: compat_copy_entry_from_user\n- 参数: [iter0, &pos, &size, newinfo, entry1]\n- 调用者: translate_compat_table\n- 被调用者: 未显示\n\n7. 函数名: xt_compat_flush_offsets\n- 参数: [AF_INET6]\n- 调用者: translate_compat_table\n- 被调用者: 未显示\n\n8. 函数名: xt_compat_unlock\n- 参数: [AF_INET6]\n- 调用者: translate_compat_table\n- 被调用者: 未显示\n\n9. 函数名: memcpy\n- 参数: [&repl, compatr, sizeof(*compatr)]\n- 调用者: translate_compat_table\n- 被调用者: 未显示\n\n10. 函数名: translate_table\n- 参数: [net, newinfo, entry1, &repl]\n- 调用者: translate_compat_table\n- 被调用者: 未显示\n\n11. 函数名: xt_free_table_info\n- 参数: [info], [newinfo]\n- 调用者: translate_compat_table\n- 被调用者: 未显示\n\n12. 函数名: compat_release_entry\n- 参数: [iter0]\n- 调用者: translate_compat_table\n- 被调用者: 未显示"
    },
    {
        "id": 2884,
        "cwe": "CWE-787",
        "cve": "CVE-2021-22555",
        "purpose": "Code purpose:\"\"\"将兼容模式的xt_entry_match结构从用户空间转换到内核空间\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证用户提供的match_size大小，导致堆内存越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: xt_compat_match_from_user\n- 参数: [struct xt_entry_match *m, void **dstptr, unsigned int *size]\n- 调用者: N/A\n- 被调用者: [memcpy, memset, module_put, strlcpy, strncpy]\n\n2. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: xt_compat_match_from_user\n- 被调用者: N/A\n\n3. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: xt_compat_match_from_user\n- 被调用者: N/A\n\n4. 函数名: module_put\n- 参数: [struct module *module]\n- 调用者: xt_compat_match_from_user\n- 被调用者: N/A\n\n5. 函数名: strlcpy\n- 参数: [char *dest, const char *src, size_t size]\n- 调用者: xt_compat_match_from_user\n- 被调用者: N/A\n\n6. 函数名: strncpy\n- 参数: [char *dest, const char *src, size_t n]\n- 调用者: xt_compat_match_from_user\n- 被调用者: N/A"
    },
    {
        "id": 2885,
        "cwe": "CWE-787",
        "cve": "CVE-2021-22555",
        "purpose": "Code purpose:\"\"\"将兼容模式的xt_entry_target结构从用户空间转换到内核空间\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证用户提供的target_size大小，导致堆内存越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: xt_compat_target_from_user\n- 参数: [struct xt_entry_target *t, void **dstptr, unsigned int *size]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [memcpy, target->compat_from_user, memset, strlcpy, module_put, strncpy]\n\n2. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: xt_compat_target_from_user\n- 被调用者: []\n\n3. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: xt_compat_target_from_user\n- 被调用者: []\n\n4. 函数名: strlcpy\n- 参数: [char *dest, const char *src, size_t size]\n- 调用者: xt_compat_target_from_user\n- 被调用者: []\n\n5. 函数名: module_put\n- 参数: [struct module *module]\n- 调用者: xt_compat_target_from_user\n- 被调用者: []\n\n6. 函数名: strncpy\n- 参数: [char *dest, const char *src, size_t n]\n- 调用者: xt_compat_target_from_user\n- 被调用者: []\n\n7. 函数名: target->compat_from_user\n- 参数: [t->data, ct->data]\n- 调用者: xt_compat_target_from_user\n- 被调用者: []"
    },
    {
        "id": 2900,
        "cwe": "CWE-787",
        "cve": "CVE-2021-27365",
        "purpose": "Code purpose:\"\"\"该代码用于根据iSCSI连接参数获取并格式化IP地址或端口信息到缓冲区中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码中对iSCSI参数处理时未对缓冲区buf进行长度检查，可能导致超出PAGE_SIZE的越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: iscsi_conn_get_addr_param\n- 参数: [struct sockaddr_storage *addr, enum iscsi_param param, char *buf]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [sprintf, be16_to_cpu]\n\n2. 函数名: sprintf\n- 参数: [char *buf, const char *format, ...]\n- 调用者: iscsi_conn_get_addr_param\n- 被调用者: []\n\n3. 函数名: be16_to_cpu\n- 参数: [__be16 val]\n- 调用者: iscsi_conn_get_addr_param\n- 被调用者: []"
    },
    {
        "id": 2901,
        "cwe": "CWE-787",
        "cve": "CVE-2021-27365",
        "purpose": "Code purpose:\"\"\"该代码用于根据不同的iSCSI参数类型，将连接参数值格式化为字符串并写入缓冲区\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码中对iscsi_conn_get_param函数的输入参数缺乏长度检查，可能导致缓冲区溢出，特别是当处理persistent_address和local_ipaddr等字符串参数时，可能超过PAGE_SIZE限制。\"\"\"",
        "functions": "Functions:\n1. 函数名: iscsi_conn_get_param\n- 参数: [struct iscsi_cls_conn *cls_conn, enum iscsi_param param, char *buf]\n- 调用者: 未明确显示（应为处理iSCSI参数的调用者）\n- 被调用者: [sprintf]\n\n2. 函数名: sprintf\n- 参数: [char *buf, const char *format, ...]\n- 调用者: iscsi_conn_get_param\n- 被调用者: []"
    },
    {
        "id": 2902,
        "cwe": "CWE-787",
        "cve": "CVE-2021-27365",
        "purpose": "Code purpose:\"\"\"该代码用于根据不同的iSCSI参数类型，将iSCSI会话中的相关参数值格式化为字符串并写入缓冲区\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码中对iSCSI会话参数的处理缺乏对输出缓冲区长度的检查，可能导致缓冲区溢出，超过PAGE_SIZE限制\"\"\"",
        "functions": "Functions:\n1. 函数名: iscsi_session_get_param\n- 参数: [struct iscsi_cls_session *cls_session, enum iscsi_param param, char *buf]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [sprintf]\n\n2. 函数名: sprintf\n- 参数: [char *buf, const char *format, ...]\n- 调用者: iscsi_session_get_param\n- 被调用者: 无（标准库函数）"
    },
    {
        "id": 2903,
        "cwe": "CWE-787",
        "cve": "CVE-2021-27365",
        "purpose": "Code purpose:\"\"\"该代码用于通过iSCSI主机参数获取网络设备名称、硬件地址或启动器名称等信息，并将其格式化输出到提供的缓冲区中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该代码未对输入参数进行长度检查，可能导致缓冲区溢出，因为sprintf操作可能超出目标缓冲区的大小限制。\"\"\"",
        "functions": "Functions:\n1. 函数名: iscsi_host_get_param\n- 参数: [struct Scsi_Host *shost, enum iscsi_host_param param, char *buf]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [shost_priv, sprintf]\n\n2. 函数名: shost_priv\n- 参数: [struct Scsi_Host *shost]\n- 调用者: iscsi_host_get_param\n- 被调用者: 未明确\n\n3. 函数名: sprintf\n- 参数: [char *buf, const char *format, ...]\n- 调用者: iscsi_host_get_param\n- 被调用者: 未明确"
    },
    {
        "id": 2904,
        "cwe": "CWE-787",
        "cve": "CVE-2021-27365",
        "purpose": "Code purpose:\"\"\"该代码用于处理iSCSI传输层参数的设置，包括会话恢复超时等参数的配置和验证。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未对用户输入的Netlink消息长度进行适当约束和检查，导致可以超过PAGE_SIZE限制\"\"\"",
        "functions": "Functions:\n1. 函数名: iscsi_set_param\n- 参数: [struct iscsi_transport *transport, struct iscsi_uevent *ev]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [iscsi_session_lookup, iscsi_conn_lookup, sscanf, transport->set_param]\n\n2. 函数名: iscsi_session_lookup\n- 参数: [ev->u.set_param.sid]\n- 调用者: iscsi_set_param\n- 被调用者: 未显示\n\n3. 函数名: iscsi_conn_lookup\n- 参数: [ev->u.set_param.sid, ev->u.set_param.cid]\n- 调用者: iscsi_set_param\n- 被调用者: 未显示\n\n4. 函数名: sscanf\n- 参数: [data, \"%d\", &value]\n- 调用者: iscsi_set_param\n- 被调用者: 未显示\n\n5. 函数名: transport->set_param\n- 参数: [conn, ev->u.set_param.param, data, ev->u.set_param.len]\n- 调用者: iscsi_set_param\n- 被调用者: 未显示"
    },
    {
        "id": 2905,
        "cwe": "CWE-787",
        "cve": "CVE-2021-27365",
        "purpose": "Code purpose:\"\"\"该代码用于处理iSCSI传输层设置主机参数的请求，包括查找指定主机并调用传输层设置参数的回调函数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码中对iSCSI数据结构缺乏长度限制检查，允许发送超过PAGE_SIZE大小的Netlink消息\"\"\"",
        "functions": "Functions:\n1. 函数名: iscsi_set_host_param\n- 参数: [struct iscsi_transport *transport, struct iscsi_uevent *ev]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [scsi_host_lookup, printk, transport->set_host_param, scsi_host_put]\n\n2. 函数名: scsi_host_lookup\n- 参数: [ev->u.set_host_param.host_no]\n- 调用者: iscsi_set_host_param\n- 被调用者: 未显示\n\n3. 函数名: printk\n- 参数: [KERN_ERR, \"set_host_param could not find host no %u\\n\", ev->u.set_host_param.host_no]\n- 调用者: iscsi_set_host_param\n- 被调用者: 未显示\n\n4. 函数名: transport->set_host_param\n- 参数: [shost, ev->u.set_host_param.param, data, ev->u.set_host_param.len]\n- 调用者: iscsi_set_host_param\n- 被调用者: 未显示\n\n5. 函数名: scsi_host_put\n- 参数: [shost]\n- 调用者: iscsi_set_host_param\n- 被调用者: 未显示"
    },
    {
        "id": 2906,
        "cwe": "CWE-787",
        "cve": "CVE-2021-27365",
        "purpose": "Code purpose:\"\"\"该代码用于显示iSCSI传输句柄，但缺乏对缓冲区长度的适当检查，可能导致缓冲区溢出\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该代码未对iSCSI数据结构进行适当的长度限制或检查，可能导致数据超过PAGE_SIZE限制，从而允许非特权用户通过发送超长的Netlink消息触发漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: show_transport_handle\n- 参数: [dev, attr, buf]\n- 调用者: 未显示（由设备属性系统调用）\n- 被调用者: [dev_to_iscsi_internal, capable, iscsi_handle, sprintf]\n\n2. 函数名: dev_to_iscsi_internal\n- 参数: [dev]\n- 调用者: show_transport_handle\n- 被调用者: []\n\n3. 函数名: capable\n- 参数: [CAP_SYS_ADMIN]\n- 调用者: show_transport_handle\n- 被调用者: []\n\n4. 函数名: iscsi_handle\n- 参数: [priv->iscsi_transport]\n- 调用者: show_transport_handle\n- 被调用者: []\n\n5. 函数名: sprintf\n- 参数: [buf, \"%llu\\n\", (unsigned long long)iscsi_handle(priv->iscsi_transport)]\n- 调用者: show_transport_handle\n- 被调用者: []"
    },
    {
        "id": 2907,
        "cwe": "CWE-787",
        "cve": "CVE-2021-27365",
        "purpose": "Code purpose:\"\"\"将iSCSI端点的ID以字符串形式输出到缓冲区\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于iSCSI端点处理函数未对输出缓冲区大小进行适当检查，可能导致缓冲区溢出，超过PAGE_SIZE限制。\"\"\"",
        "functions": "Functions:\n1. 函数名: show_ep_handle\n- 参数: [struct device *dev, struct device_attribute *attr, char *buf]\n- 调用者: 未明确（由设备属性系统调用）\n- 被调用者: [iscsi_dev_to_endpoint, sprintf]\n\n2. 函数名: iscsi_dev_to_endpoint\n- 参数: [struct device *dev]\n- 调用者: show_ep_handle\n- 被调用者: 未明确\n\n3. 函数名: sprintf\n- 参数: [char *buf, const char *format, ...]\n- 调用者: show_ep_handle\n- 被调用者: 未明确"
    },
    {
        "id": 2914,
        "cwe": "CWE-787",
        "cve": "CVE-2021-28660",
        "purpose": "Code purpose:\"\"\"该代码用于处理无线网络扫描请求，包括设置扫描参数、执行扫描命令以及处理扫描结果。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对ssid_index进行边界检查，导致可以写入超过ssid数组边界的内存\"\"\"",
        "functions": "Functions:\n1. 函数名: rtw_wx_set_scan\n- 参数: [struct net_device *dev, struct iw_request_info *a, union iwreq_data *wrqu, char *extra]\n- 调用者: 未显示（由内核调用）\n- 被调用者: [rtw_netdev_priv, rtw_pwr_wakeup, indicate_wx_scan_complete_event, check_fwstate, memset, min_t, memcpy, spin_lock_bh, rtw_sitesurvey_cmd, spin_unlock_bh, rtw_set_802_11_bssid_list_scan]\n\n2. 函数名: rtw_netdev_priv\n- 参数: [struct net_device *dev]\n- 调用者: rtw_wx_set_scan\n- 被调用者: []\n\n3. 函数名: rtw_pwr_wakeup\n- 参数: [struct adapter *padapter]\n- 调用者: rtw_wx_set_scan\n- 被调用者: []\n\n4. 函数名: indicate_wx_scan_complete_event\n- 参数: [struct adapter *padapter]\n- 调用者: rtw_wx_set_scan\n- 被调用者: []\n\n5. 函数名: check_fwstate\n- 参数: [struct mlme_priv *pmlmepriv, _FW_UNDER_SURVEY | _FW_UNDER_LINKING]\n- 调用者: rtw_wx_set_scan\n- 被调用者: []\n\n6. 函数名: memset\n- 参数: [ssid, 0, sizeof(struct ndis_802_11_ssid) * RTW_SSID_SCAN_AMOUNT]\n- 调用者: rtw_wx_set_scan\n- 被调用者: []\n\n7. 函数名: min_t\n- 参数: [int, req->essid_len, IW_ESSID_MAX_SIZE]\n- 调用者: rtw_wx_set_scan\n- 被调用者: []\n\n8. 函数名: memcpy\n- 参数: [ssid[0].ssid, req->essid, len]\n- 调用者: rtw_wx_set_scan\n- 被调用者: []\n\n9. 函数名: spin_lock_bh\n- 参数: [&pmlmepriv->lock]\n- 调用者: rtw_wx_set_scan\n- 被调用者: []\n\n10. 函数名: rtw_sitesurvey_cmd\n- 参数: [padapter, ssid, 1, NULL, 0]\n- 调用者: rtw_wx_set_scan\n- 被调用者: []\n\n11. 函数名: spin_unlock_bh\n- 参数: [&pmlmepriv->lock]\n- 调用者: rtw_wx_set_scan\n- 被调用者: []\n\n12. 函数名: rtw_set_802_11_bssid_list_scan\n- 参数: [padapter, ssid, RTW_SSID_SCAN_AMOUNT] 或 [padapter, NULL, 0]\n- 调用者: rtw_wx_set_scan\n- 被调用者: []"
    },
    {
        "id": 2964,
        "cwe": "CWE-787",
        "cve": "CVE-2021-31916",
        "purpose": "Code purpose:\"\"\"该代码用于列出设备映射器(DM)中的所有设备信息，并将这些信息通过ioctl接口返回给用户空间。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在填充设备名称列表时未正确验证缓冲区边界，导致具有CAP_SYS_ADMIN特权的攻击者可能触发越界写入，造成系统崩溃或内核信息泄露\"\"\"",
        "functions": "Functions:\n1. 函数名: list_devices\n- 参数: [struct file *filp, struct dm_ioctl *param, size_t param_size]\n- 调用者: 未显示\n- 被调用者: [align_val, get_result_buffer, dm_disk, huge_encode_dev, disk_devt, strcpy, align_ptr, dm_get_event_nr, BUG_ON]\n\n2. 函数名: align_val\n- 参数: [未显示]\n- 调用者: list_devices\n- 被调用者: 未显示\n\n3. 函数名: get_result_buffer\n- 参数: [struct dm_ioctl *param, size_t param_size, size_t *len]\n- 调用者: list_devices\n- 被调用者: 未显示\n\n4. 函数名: dm_disk\n- 参数: [struct hash_cell *hc]\n- 调用者: list_devices\n- 被调用者: 未显示\n\n5. 函数名: huge_encode_dev\n- 参数: [dev_t dev]\n- 调用者: list_devices\n- 被调用者: 未显示\n\n6. 函数名: disk_devt\n- 参数: [struct gendisk *disk]\n- 调用者: list_devices\n- 被调用者: 未显示\n\n7. 函数名: strcpy\n- 参数: [char *dest, const char *src]\n- 调用者: list_devices\n- 被调用者: 未显示\n\n8. 函数名: align_ptr\n- 参数: [void *ptr]\n- 调用者: list_devices\n- 被调用者: 未显示\n\n9. 函数名: dm_get_event_nr\n- 参数: [struct mapped_device *md]\n- 调用者: list_devices\n- 被调用者: 未显示\n\n10. 函数名: BUG_ON\n- 参数: [bool condition]\n- 调用者: list_devices\n- 被调用者: 未显示"
    },
    {
        "id": 2982,
        "cwe": "CWE-787",
        "cve": "CVE-2021-33655",
        "purpose": "Code purpose:\"\"\"该代码用于设置控制台字体，包括验证字体参数、分配内存、复制字体数据并计算校验和，最终通过fbcon_do_set_font函数应用新字体。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证用户提供的font->width和font->height参数，导致计算size时可能产生整数溢出，从而造成内存越界写入。\"\"\"",
        "functions": "Functions:\n1. 函数名: fbcon_set_font\n- 参数: [vc, font, flags]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [fbcon_info_from_console, PITCH, fbcon_invalid_charcount, kmalloc, memset, memcpy, crc32, kfree, fbcon_do_set_font]\n\n2. 函数名: fbcon_info_from_console\n- 参数: [vc_num]\n- 调用者: fbcon_set_font\n- 被调用者: 未显示\n\n3. 函数名: PITCH\n- 参数: [font->width]\n- 调用者: fbcon_set_font\n- 被调用者: 未显示\n\n4. 函数名: fbcon_invalid_charcount\n- 参数: [info, charcount]\n- 调用者: fbcon_set_font\n- 被调用者: 未显示\n\n5. 函数名: kmalloc\n- 参数: [FONT_EXTRA_WORDS * sizeof(int) + size, GFP_USER]\n- 调用者: fbcon_set_font\n- 被调用者: 未显示\n\n6. 函数名: memset\n- 参数: [new_data, 0, FONT_EXTRA_WORDS * sizeof(int)]\n- 调用者: fbcon_set_font\n- 被调用者: 未显示\n\n7. 函数名: memcpy\n- 参数: [new_data + i*h*pitch, data + i*32*pitch, h*pitch]\n- 调用者: fbcon_set_font\n- 被调用者: 未显示\n\n8. 函数名: crc32\n- 参数: [0, new_data, size]\n- 调用者: fbcon_set_font\n- 被调用者: 未显示\n\n9. 函数名: kfree\n- 参数: [new_data - FONT_EXTRA_WORDS * sizeof(int)]\n- 调用者: fbcon_set_font\n- 被调用者: 未显示\n\n10. 函数名: fbcon_do_set_font\n- 参数: [vc, font->width, font->height, charcount, new_data, 1]\n- 调用者: fbcon_set_font\n- 被调用者: 未显示"
    },
    {
        "id": 2983,
        "cwe": "CWE-787",
        "cve": "CVE-2021-33656",
        "purpose": "Code purpose:\"\"\"该代码用于通过ioctl命令PIO_FONT获取控制台字体数据，并将其复制到用户空间。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证用户提供的字体数据大小，导致在拷贝数据到用户空间时可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: con_font_get\n- 参数: [vc, op]\n- 调用者: 未明确显示（可能是通过ioctl调用的）\n- 被调用者: [kmalloc, console_lock, console_unlock, copy_to_user, kfree]\n\n2. 函数名: kmalloc\n- 参数: [max_font_size, GFP_KERNEL]\n- 调用者: con_font_get\n- 被调用者: []\n\n3. 函数名: console_lock\n- 参数: []\n- 调用者: con_font_get\n- 被调用者: []\n\n4. 函数名: console_unlock\n- 参数: []\n- 调用者: con_font_get\n- 被调用者: []\n\n5. 函数名: copy_to_user\n- 参数: [op->data, font.data, c]\n- 调用者: con_font_get\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [font.data]\n- 调用者: con_font_get\n- 被调用者: []"
    },
    {
        "id": 2984,
        "cwe": "CWE-787",
        "cve": "CVE-2021-33656",
        "purpose": "Code purpose:\"\"\"该代码用于通过ioctl设置控制台字体，但存在内存越界写入漏洞\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在计算字体数据大小时未充分验证输入参数，导致可能的内存越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: con_font_set\n- 参数: [vc, op]\n- 调用者: 未明确显示（可能是通过ioctl调用的）\n- 被调用者: [memdup_user, IS_ERR, PTR_ERR, kfree, console_lock, console_unlock]\n\n2. 函数名: memdup_user\n- 参数: [op->data, size]\n- 调用者: con_font_set\n- 被调用者: []\n\n3. 函数名: IS_ERR\n- 参数: [font.data]\n- 调用者: con_font_set\n- 被调用者: []\n\n4. 函数名: PTR_ERR\n- 参数: [font.data]\n- 调用者: con_font_set\n- 被调用者: []\n\n5. 函数名: kfree\n- 参数: [font.data]\n- 调用者: con_font_set\n- 被调用者: []\n\n6. 函数名: console_lock\n- 参数: []\n- 调用者: con_font_set\n- 被调用者: []\n\n7. 函数名: console_unlock\n- 参数: []\n- 调用者: con_font_set\n- 被调用者: []\n\n8. 函数名: vc->vc_sw->con_font_set\n- 参数: [vc, &font, op->flags]\n- 调用者: con_font_set\n- 被调用者: []"
    },
    {
        "id": 2985,
        "cwe": "CWE-787",
        "cve": "CVE-2021-33656",
        "purpose": "Code purpose:\"\"\"处理虚拟控制台的字体和屏幕映射相关的IO控制命令，包括设置/获取字体、设置/获取颜色映射、屏幕映射等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理PIO_FONT命令时，未对用户提供的up指针进行充分边界检查，导致内核可能越界写入内存。\"\"\"",
        "functions": "Functions:\n1. 函数名: vt_io_ioctl\n- 参数: [vc, cmd, up, perm]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [con_font_op, con_set_cmap, con_get_cmap, do_fontx_ioctl, vt_io_fontreset, con_set_trans_old, con_get_trans_old, con_set_trans_new, con_get_trans_new, con_clear_unimap, do_unimap_ioctl]\n\n2. 函数名: con_font_op\n- 参数: [vc, &op]\n- 调用者: vt_io_ioctl\n- 被调用者: 未显示\n\n3. 函数名: con_set_cmap\n- 参数: [up]\n- 调用者: vt_io_ioctl\n- 被调用者: 未显示\n\n4. 函数名: con_get_cmap\n- 参数: [up]\n- 调用者: vt_io_ioctl\n- 被调用者: 未显示\n\n5. 函数名: do_fontx_ioctl\n- 参数: [vc, cmd, up, &op]\n- 调用者: vt_io_ioctl\n- 被调用者: 未显示\n\n6. 函数名: vt_io_fontreset\n- 参数: [vc, &op]\n- 调用者: vt_io_ioctl\n- 被调用者: 未显示\n\n7. 函数名: con_set_trans_old\n- 参数: [up]\n- 调用者: vt_io_ioctl\n- 被调用者: 未显示\n\n8. 函数名: con_get_trans_old\n- 参数: [up]\n- 调用者: vt_io_ioctl\n- 被调用者: 未显示\n\n9. 函数名: con_set_trans_new\n- 参数: [up]\n- 调用者: vt_io_ioctl\n- 被调用者: 未显示\n\n10. 函数名: con_get_trans_new\n- 参数: [up]\n- 调用者: vt_io_ioctl\n- 被调用者: 未显示\n\n11. 函数名: con_clear_unimap\n- 参数: [vc]\n- 调用者: vt_io_ioctl\n- 被调用者: 未显示\n\n12. 函数名: do_unimap_ioctl\n- 参数: [cmd, up, perm, vc]\n- 调用者: vt_io_ioctl\n- 被调用者: 未显示"
    },
    {
        "id": 2986,
        "cwe": "CWE-787",
        "cve": "CVE-2021-33656",
        "purpose": "Code purpose:\"\"\"该代码实现了虚拟终端(vt)的兼容性IO控制功能，处理各种字体、显示模式和终端设置相关的ioctl命令，包括权限检查和数据结构转换。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理PIO_FONT命令时，内核未对用户提供的恶意字体数据进行边界检查，导致越界写入内存。\"\"\"",
        "functions": "Functions:\n1. 函数名: vt_compat_ioctl\n- 参数: [struct tty_struct *tty, unsigned int cmd, unsigned long arg]\n- 调用者: 未显示（应为内核IOCTL调用）\n- 被调用者: [compat_fontx_ioctl, compat_kdfontop_ioctl, compat_unimap_ioctl, vt_ioctl]\n\n2. 函数名: compat_fontx_ioctl\n- 参数: [struct vc_data *vc, unsigned int cmd, void __user *up, int perm, struct console_font_op *op]\n- 调用者: vt_compat_ioctl\n- 被调用者: 未显示\n\n3. 函数名: compat_kdfontop_ioctl\n- 参数: [void __user *up, int perm, struct console_font_op *op, struct vc_data *vc]\n- 调用者: vt_compat_ioctl\n- 被调用者: 未显示\n\n4. 函数名: compat_unimap_ioctl\n- 参数: [unsigned int cmd, void __user *up, int perm, struct vc_data *vc]\n- 调用者: vt_compat_ioctl\n- 被调用者: 未显示\n\n5. 函数名: vt_ioctl\n- 参数: [struct tty_struct *tty, unsigned int cmd, unsigned long arg]\n- 调用者: vt_compat_ioctl\n- 被调用者: 未显示"
    },
    {
        "id": 2987,
        "cwe": "CWE-787",
        "cve": "CVE-2021-33909",
        "purpose": "Code purpose:\"\"\"为序列文件分配指定大小的内核缓冲区内存\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对size参数进行有效边界检查，导致整数溢出和越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: seq_buf_alloc\n- 参数: [size]\n- 调用者: 未提供（上下文不足）\n- 被调用者: [kvmalloc]\n\n2. 函数名: kvmalloc\n- 参数: [size, GFP_KERNEL_ACCOUNT]\n- 调用者: [seq_buf_alloc]\n- 被调用者: 未提供（上下文不足）"
    },
    {
        "id": 3009,
        "cwe": "CWE-787",
        "cve": "CVE-2021-3489",
        "purpose": "Code purpose:\"\"\"该代码实现了eBPF环形缓冲区中预留空间的功能，用于在内核中为BPF程序分配指定大小的缓冲区空间。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"函数未验证申请的内存大小是否小于环形缓冲区总大小，导致可分配超出缓冲区边界的内存，造成越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: __bpf_ringbuf_reserve\n- 参数: [struct bpf_ringbuf *rb, u64 size]\n- 调用者: 未明确（应为bpf_ringbuf_reserve等外部函数）\n- 被调用者: [smp_load_acquire, in_nmi, spin_trylock_irqsave, spin_lock_irqsave, bpf_ringbuf_rec_pg_off, smp_store_release, spin_unlock_irqrestore]\n\n2. 函数名: smp_load_acquire\n- 参数: [&rb->consumer_pos]\n- 调用者: __bpf_ringbuf_reserve\n- 被调用者: []\n\n3. 函数名: in_nmi\n- 参数: []\n- 调用者: __bpf_ringbuf_reserve\n- 被调用者: []\n\n4. 函数名: spin_trylock_irqsave\n- 参数: [&rb->spinlock, flags]\n- 调用者: __bpf_ringbuf_reserve\n- 被调用者: []\n\n5. 函数名: spin_lock_irqsave\n- 参数: [&rb->spinlock, flags]\n- 调用者: __bpf_ringbuf_reserve\n- 被调用者: []\n\n6. 函数名: bpf_ringbuf_rec_pg_off\n- 参数: [rb, hdr]\n- 调用者: __bpf_ringbuf_reserve\n- 被调用者: []\n\n7. 函数名: smp_store_release\n- 参数: [&rb->producer_pos, new_prod_pos]\n- 调用者: __bpf_ringbuf_reserve\n- 被调用者: []\n\n8. 函数名: spin_unlock_irqrestore\n- 参数: [&rb->spinlock, flags]\n- 调用者: __bpf_ringbuf_reserve\n- 被调用者: []"
    },
    {
        "id": 3010,
        "cwe": "CWE-787",
        "cve": "CVE-2021-3490",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理eBPF ALU32位操作时的边界跟踪，特别是对XOR操作的32位最小值/最大值进行更新，以确保正确的边界检查。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中eBPF ALU32边界跟踪对于位操作(AND、OR和XOR)未正确更新32位边界，导致可能产生越界读写和任意代码执行漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: scalar32_min_max_xor\n- 参数: [struct bpf_reg_state *dst_reg, struct bpf_reg_state *src_reg]\n- 调用者: 未明确显示（应为BPF验证器相关代码）\n- 被调用者: [tnum_subreg_is_const, tnum_subreg]\n\n2. 函数名: tnum_subreg_is_const\n- 参数: [未显示完整参数，应为tnum相关结构体]\n- 调用者: scalar32_min_max_xor\n- 被调用者: []\n\n3. 函数名: tnum_subreg\n- 参数: [未显示完整参数，应为tnum相关结构体]\n- 调用者: scalar32_min_max_xor\n- 被调用者: []"
    },
    {
        "id": 3011,
        "cwe": "CWE-787",
        "cve": "CVE-2021-3490",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中实现eBPF ALU32位操作(特别是AND运算)的边界跟踪功能，但不正确地处理了32位边界更新，可能导致越界读写问题。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中eBPF ALU32边界跟踪在按位操作(AND、OR和XOR)时未正确更新32位边界，导致可能越界读写\"\"\"",
        "functions": "Functions:\n1. 函数名: scalar32_min_max_and\n- 参数: [struct bpf_reg_state *dst_reg, struct bpf_reg_state *src_reg]\n- 调用者: 未明确（由BPF验证器调用）\n- 被调用者: [tnum_subreg_is_const, tnum_subreg, min]\n\n2. 函数名: tnum_subreg_is_const\n- 参数: [struct tnum var_off]\n- 调用者: scalar32_min_max_and\n- 被调用者: []\n\n3. 函数名: tnum_subreg\n- 参数: [struct tnum var_off]\n- 调用者: scalar32_min_max_and\n- 被调用者: []\n\n4. 函数名: min\n- 参数: [u32 a, u32 b]\n- 调用者: scalar32_min_max_and\n- 被调用者: []"
    },
    {
        "id": 3012,
        "cwe": "CWE-787",
        "cve": "CVE-2021-3490",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核中处理eBPF ALU32位操作(OR)时的32位边界跟踪，但不正确地更新了32位边界值，可能导致越界读写问题\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"Linux内核中eBPF ALU32边界跟踪在按位操作(AND、OR和XOR)时未能正确更新32位边界，导致可能越界读写\"\"\"",
        "functions": "Functions:\n1. 函数名: scalar32_min_max_or\n- 参数: [struct bpf_reg_state *dst_reg, struct bpf_reg_state *src_reg]\n- 调用者: 未明确（根据上下文推测可能是BPF验证器相关函数）\n- 被调用者: [max, tnum_subreg_is_const, tnum_subreg]\n\n2. 函数名: tnum_subreg_is_const\n- 参数: [未明确（应为tnum结构体）]\n- 调用者: scalar32_min_max_or\n- 被调用者: []\n\n3. 函数名: tnum_subreg\n- 参数: [未明确（应为tnum结构体）]\n- 调用者: scalar32_min_max_or\n- 被调用者: []\n\n4. 函数名: max\n- 参数: [未明确（应为两个可比较值）]\n- 调用者: scalar32_min_max_or\n- 被调用者: []"
    },
    {
        "id": 3013,
        "cwe": "CWE-787",
        "cve": "CVE-2021-3491",
        "purpose": "Code purpose:\"\"\"为io_uring子系统提供缓冲区分配功能，将用户提供的缓冲区添加到链表中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对提供的缓冲区长度进行适当限制，导致可以绕过MAX_RW_COUNT限制，从而可能造成堆溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: io_add_buffers\n- 参数: [struct io_provide_buf *pbuf, struct io_buffer **head]\n- 调用者: 未明确（应为调用PROVIDE_BUFFERS操作的相关代码）\n- 被调用者: [kmalloc, INIT_LIST_HEAD, list_add_tail]"
    },
    {
        "id": 3015,
        "cwe": "CWE-787",
        "cve": "CVE-2021-3501",
        "purpose": "Code purpose:\"\"\"处理虚拟机监控程序(VMX)中的虚拟机退出事件，包括异常处理、状态检查和相应操作的分发执行。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"用户进程可以随时修改internal.ndata的值，该值被用作数组索引，可能导致越界写入漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: __vmx_handle_exit\n- 参数: [vcpu, exit_fastpath]\n- 调用者: N/A\n- 被调用者: [to_vmx, is_guest_mode, vmx_flush_pml_buffer, handle_invalid_guest_state, nested_mark_vmcs12_pages_dirty, nested_vmx_reflect_vmexit, dump_vmcs, vmcs_read32, vmx_interrupt_blocked, printk, kvm_emulate_wrmsr, handle_preemption_timer, handle_interrupt_window, handle_external_interrupt, kvm_emulate_halt, handle_ept_misconfig, array_index_nospec, vcpu_unimpl]\n\n2. 函数名: to_vmx\n- 参数: [vcpu]\n- 调用者: __vmx_handle_exit\n- 被调用者: N/A\n\n3. 函数名: is_guest_mode\n- 参数: [vcpu]\n- 调用者: __vmx_handle_exit\n- 被调用者: N/A\n\n4. 函数名: vmx_flush_pml_buffer\n- 参数: [vcpu]\n- 调用者: __vmx_handle_exit\n- 被调用者: N/A\n\n5. 函数名: handle_invalid_guest_state\n- 参数: [vcpu]\n- 调用者: __vmx_handle_exit\n- 被调用者: N/A\n\n6. 函数名: nested_mark_vmcs12_pages_dirty\n- 参数: [vcpu]\n- 调用者: __vmx_handle_exit\n- 被调用者: N/A\n\n7. 函数名: nested_vmx_reflect_vmexit\n- 参数: [vcpu]\n- 调用者: __vmx_handle_exit\n- 被调用者: N/A\n\n8. 函数名: dump_vmcs\n- 参数: []\n- 调用者: __vmx_handle_exit\n- 被调用者: N/A\n\n9. 函数名: vmcs_read32\n- 参数: [VM_INSTRUCTION_ERROR]\n- 调用者: __vmx_handle_exit\n- 被调用者: N/A\n\n10. 函数名: vmx_interrupt_blocked\n- 参数: [vcpu]\n- 调用者: __vmx_handle_exit\n- 被调用者: N/A\n\n11. 函数名: printk\n- 参数: [KERN_WARNING, format_string, __func__, vcpu->vcpu_id]\n- 调用者: __vmx_handle_exit\n- 被调用者: N/A\n\n12. 函数名: kvm_emulate_wrmsr\n- 参数: [vcpu]\n- 调用者: __vmx_handle_exit\n- 被调用者: N/A\n\n13. 函数名: handle_preemption_timer\n- 参数: [vcpu]\n- 调用者: __vmx_handle_exit\n- 被调用者: N/A\n\n14. 函数名: handle_interrupt_window\n- 参数: [vcpu]\n- 调用者: __vmx_handle_exit\n- 被调用者: N/A\n\n15. 函数名: handle_external_interrupt\n- 参数: [vcpu]\n- 调用者: __vmx_handle_exit\n- 被调用者: N/A\n\n16. 函数名: kvm_emulate_halt\n- 参数: [vcpu]\n- 调用者: __vmx_handle_exit\n- 被调用者: N/A\n\n17. 函数名: handle_ept_misconfig\n- 参数: [vcpu]\n- 调用者: __vmx_handle_exit\n- 被调用者: N/A\n\n18. 函数名: array_index_nospec\n- 参数: [(u16)exit_reason.basic, kvm_vmx_max_exit_handlers]\n- 调用者: __vmx_handle_exit\n- 被调用者: N/A\n\n19. 函数名: vcpu_unimpl\n- 参数: [vcpu, format_string, exit_reason.full]\n- 调用者: __vmx_handle_exit\n- 被调用者: N/A\n\n20. 函数名: vmcs_read64\n- 参数: [GUEST_PHYSICAL_ADDRESS]\n- 调用者: __vmx_handle_exit\n- 被调用者: N/A"
    },
    {
        "id": 3023,
        "cwe": "CWE-787",
        "cve": "CVE-2021-3612",
        "purpose": "Code purpose:\"\"\"处理游戏手柄设备的按钮映射设置，通过ioctl JSIOCSBTNMAP将用户空间的按钮映射配置复制到内核空间并进行验证\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证用户输入的keypam数组长度与joydev->nkey的关系，导致可能越界写入内存\"\"\"",
        "functions": "Functions:\n1. 函数名: joydev_handle_JSIOCSBTNMAP\n- 参数: [struct joydev *joydev, void __user *argp, size_t len]\n- 调用者: 未指定（由外部调用）\n- 被调用者: [memdup_user, IS_ERR, PTR_ERR, kfree, memcpy]\n\n2. 函数名: memdup_user\n- 参数: [void __user *argp, size_t len]\n- 调用者: joydev_handle_JSIOCSBTNMAP\n- 被调用者: 未指定（通常是内核内存分配函数）\n\n3. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: joydev_handle_JSIOCSBTNMAP\n- 被调用者: 无\n\n4. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: joydev_handle_JSIOCSBTNMAP\n- 被调用者: 无\n\n5. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: joydev_handle_JSIOCSBTNMAP\n- 被调用者: 无\n\n6. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: joydev_handle_JSIOCSBTNMAP\n- 被调用者: 无"
    },
    {
        "id": 3024,
        "cwe": "CWE-787",
        "cve": "CVE-2021-3612",
        "purpose": "Code purpose:\"\"\"处理游戏手柄设备的绝对轴映射设置，验证用户提供的映射数据并将其复制到内核空间\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证用户输入的abspam数组元素是否超出joydev->absmap数组的边界，导致可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: joydev_handle_JSIOCSAXMAP\n- 参数: [struct joydev *joydev, void __user *argp, size_t len]\n- 调用者: 未指定（由外部调用）\n- 被调用者: [memdup_user, IS_ERR, PTR_ERR, min, kfree, memcpy]\n\n2. 函数名: memdup_user\n- 参数: [void __user *argp, size_t len]\n- 调用者: joydev_handle_JSIOCSAXMAP\n- 被调用者: 未指定（内核函数）\n\n3. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: joydev_handle_JSIOCSAXMAP\n- 被调用者: 未指定（内核宏）\n\n4. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: joydev_handle_JSIOCSAXMAP\n- 被调用者: 未指定（内核宏）\n\n5. 函数名: min\n- 参数: [size_t len, sizeof(joydev->abspam)]\n- 调用者: joydev_handle_JSIOCSAXMAP\n- 被调用者: 未指定（内核宏）\n\n6. 函数名: kfree\n- 参数: [void *abspam]\n- 调用者: joydev_handle_JSIOCSAXMAP\n- 被调用者: 未指定（内核函数）\n\n7. 函数名: memcpy\n- 参数: [joydev->abspam, abspam, len]\n- 调用者: joydev_handle_JSIOCSAXMAP\n- 被调用者: 未指定（内核函数）"
    },
    {
        "id": 3058,
        "cwe": "CWE-787",
        "cve": "CVE-2021-37576",
        "purpose": "Code purpose:\"\"\"该代码实现了KVM虚拟机中客户机通过RTAS(运行时抽象服务)调用与主机交互的功能，包括参数传递和处理结果的返回。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证rtas_args.nargs的值，导致可以越界访问args.args数组，造成内存损坏\"\"\"",
        "functions": "Functions:\n1. 函数名: kvmppc_rtas_hcall\n- 参数: [struct kvm_vcpu *vcpu]\n- 调用者: 未显示（由KVM框架调用）\n- 被调用者: [kvmppc_get_gpr, srcu_read_lock, kvm_read_guest, srcu_read_unlock, be32_to_cpu, mutex_lock, list_for_each_entry, mutex_unlock, kvm_write_guest]\n\n2. 函数名: kvmppc_get_gpr\n- 参数: [struct kvm_vcpu *vcpu, int reg_num]\n- 调用者: kvmppc_rtas_hcall\n- 被调用者: []\n\n3. 函数名: srcu_read_lock\n- 参数: [struct srcu_struct *sp]\n- 调用者: kvmppc_rtas_hcall\n- 被调用者: []\n\n4. 函数名: kvm_read_guest\n- 参数: [struct kvm *kvm, gpa_t gpa, void *data, unsigned long len]\n- 调用者: kvmppc_rtas_hcall\n- 被调用者: []\n\n5. 函数名: srcu_read_unlock\n- 参数: [struct srcu_struct *sp, int idx]\n- 调用者: kvmppc_rtas_hcall\n- 被调用者: []\n\n6. 函数名: be32_to_cpu\n- 参数: [__be32 val]\n- 调用者: kvmppc_rtas_hcall\n- 被调用者: []\n\n7. 函数名: mutex_lock\n- 参数: [struct mutex *lock]\n- 调用者: kvmppc_rtas_hcall\n- 被调用者: []\n\n8. 函数名: list_for_each_entry\n- 参数: [struct rtas_token_definition *d, &vcpu->kvm->arch.rtas_tokens, list]\n- 调用者: kvmppc_rtas_hcall\n- 被调用者: []\n\n9. 函数名: mutex_unlock\n- 参数: [struct mutex *lock]\n- 调用者: kvmppc_rtas_hcall\n- 被调用者: []\n\n10. 函数名: kvm_write_guest\n- 参数: [struct kvm *kvm, gpa_t gpa, void *data, unsigned long len]\n- 调用者: kvmppc_rtas_hcall\n- 被调用者: []"
    },
    {
        "id": 3069,
        "cwe": "CWE-787",
        "cve": "CVE-2021-38166",
        "purpose": "Code purpose:\"\"\"该代码实现了BPF哈希表映射的批量查找和删除功能，处理用户空间与内核空间之间的数据交互，并管理哈希表元素的并发访问。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当单个桶中的元素过多时，由于未正确检查bucket_cnt的边界，导致整数溢出和越界写入漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: __htab_map_lookup_and_delete_batch\n- 参数: [struct bpf_map *map, const union bpf_attr *attr, union bpf_attr __user *uattr, bool do_delete, bool is_lru_map, bool is_percpu]\n- 调用者: 未明确显示（通常由BPF系统调用触发）\n- 被调用者: [container_of, u64_to_user_ptr, put_user, copy_from_user, round_up, kvmalloc, htab_lock_bucket, hlist_nulls_for_each_entry_rcu, htab_unlock_bucket, kvfree, hlist_nulls_for_each_entry_safe, memcpy, htab_elem_get_ptr, for_each_possible_cpu, bpf_long_memcpy, copy_map_value_locked, copy_map_value, check_and_init_map_lock, hlist_nulls_del_rcu, free_htab_elem, bpf_lru_push_free, copy_to_user]\n\n2. 函数名: htab_lock_bucket\n- 参数: [struct bpf_htab *htab, struct bucket *b, u32 batch, unsigned long *flags]\n- 调用者: __htab_map_lookup_and_delete_batch\n- 被调用者: 未显示\n\n3. 函数名: htab_unlock_bucket\n- 参数: [struct bpf_htab *htab, struct bucket *b, u32 batch, unsigned long flags]\n- 调用者: __htab_map_lookup_and_delete_batch\n- 被调用者: 未显示\n\n4. 函数名: free_htab_elem\n- 参数: [struct bpf_htab *htab, struct htab_elem *l]\n- 调用者: __htab_map_lookup_and_delete_batch\n- 被调用者: 未显示\n\n5. 函数名: bpf_lru_push_free\n- 参数: [struct bpf_lru *lru, struct bpf_lru_node *node]\n- 调用者: __htab_map_lookup_and_delete_batch\n- 被调用者: 未显示\n\n6. 函数名: copy_map_value_locked\n- 参数: [struct bpf_map *map, void *dst, void *src, bool lock]\n- 调用者: __htab_map_lookup_and_delete_batch\n- 被调用者: 未显示\n\n7. 函数名: copy_map_value\n- 参数: [struct bpf_map *map, void *dst, void *src]\n- 调用者: __htab_map_lookup_and_delete_batch\n- 被调用者: 未显示\n\n8. 函数名: check_and_init_map_lock\n- 参数: [struct bpf_map *map, void *dst]\n- 调用者: __htab_map_lookup_and_delete_batch\n- 被调用者: 未显示"
    },
    {
        "id": 3096,
        "cwe": "CWE-787",
        "cve": "CVE-2021-39685",
        "purpose": "Code purpose:\"\"\"处理USB gadget设备的控制请求，包括配置、接口设置、状态获取等标准USB描述符操作，并处理可能的非标准请求。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于USB gadget子系统中各种设置方法对标志检查不正确，导致可能存在越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: composite_setup\n- 参数: [struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl]\n- 调用者: 未显示（应为USB gadget子系统调用）\n- 被调用者: [get_gadget_data, le16_to_cpu, count_configs, gadget_is_superspeed, cpu_to_le16, min, memcpy, gadget_is_dualspeed, device_qual, min_t, config_desc, get_string, bos_desc, gadget_is_otg, list_first_entry, min_t, set_config, put_unaligned_le16, count_ext_compat, fill_ext_compat, count_ext_prop, len_ext_prop, fill_ext_prop, composite_ep0_queue, composite_setup_complete]\n\n2. 函数名: get_gadget_data\n- 参数: [struct usb_gadget *gadget]\n- 调用者: composite_setup\n- 被调用者: []\n\n3. 函数名: le16_to_cpu\n- 参数: [u16 value]\n- 调用者: composite_setup\n- 被调用者: []\n\n4. 函数名: count_configs\n- 参数: [struct usb_composite_dev *cdev, int type]\n- 调用者: composite_setup\n- 被调用者: []\n\n5. 函数名: gadget_is_superspeed\n- 参数: [struct usb_gadget *gadget]\n- 调用者: composite_setup\n- 被调用者: []\n\n6. 函数名: cpu_to_le16\n- 参数: [u16 value]\n- 调用者: composite_setup\n- 被调用者: []\n\n7. 函数名: min\n- 参数: [u16 a, u16 b]\n- 调用者: composite_setup\n- 被调用者: []\n\n8. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: composite_setup\n- 被调用者: []\n\n9. 函数名: gadget_is_dualspeed\n- 参数: [struct usb_gadget *gadget]\n- 调用者: composite_setup\n- 被调用者: []\n\n10. 函数名: device_qual\n- 参数: [struct usb_composite_dev *cdev]\n- 调用者: composite_setup\n- 被调用者: []\n\n11. 函数名: min_t\n- 参数: [int type, int a, int b]\n- 调用者: composite_setup\n- 被调用者: []\n\n12. 函数名: config_desc\n- 参数: [struct usb_composite_dev *cdev, u16 w_value]\n- 调用者: composite_setup\n- 被调用者: []\n\n13. 函数名: get_string\n- 参数: [struct usb_composite_dev *cdev, u8 *buf, u16 w_index, u8 id]\n- 调用者: composite_setup\n- 被调用者: []\n\n14. 函数名: bos_desc\n- 参数: [struct usb_composite_dev *cdev]\n- 调用者: composite_setup\n- 被调用者: []\n\n15. 函数名: gadget_is_otg\n- 参数: [struct usb_gadget *gadget]\n- 调用者: composite_setup\n- 被调用者: []\n\n16. 函数名: list_first_entry\n- 参数: [struct list_head *list, type, member]\n- 调用者: composite_setup\n- 被调用者: []\n\n17. 函数名: set_config\n- 参数: [struct usb_composite_dev *cdev, const struct usb_ctrlrequest *ctrl, u16 w_value]\n- 调用者: composite_setup\n- 被调用者: []\n\n18. 函数名: put_unaligned_le16\n- 参数: [u16 val, void *p]\n- 调用者: composite_setup\n- 被调用者: []\n\n19. 函数名: count_ext_compat\n- 参数: [struct usb_configuration *os_desc_cfg]\n- 调用者: composite_setup\n- 被调用者: []\n\n20. 函数名: fill_ext_compat\n- 参数: [struct usb_configuration *os_desc_cfg, u8 *buf]\n- 调用者: composite_setup\n- 被调用者: []\n\n21. 函数名: count_ext_prop\n- 参数: [struct usb_configuration *os_desc_cfg, int interface]\n- 调用者: composite_setup\n- 被调用者: []\n\n22. 函数名: len_ext_prop\n- 参数: [struct usb_configuration *os_desc_cfg, int interface]\n- 调用者: composite_setup\n- 被调用者: []\n\n23. 函数名: fill_ext_prop\n- 参数: [struct usb_configuration *os_desc_cfg, int interface, u8 *buf]\n- 调用者: composite_setup\n- 被调用者: []\n\n24. 函数名: composite_ep0_queue\n- 参数: [struct usb_composite_dev *cdev, struct usb_request *req, gfp_t gfp_flags]\n- 调用者: composite_setup\n- 被调用者: []\n\n25. 函数名: composite_setup_complete\n- 参数: [struct usb_ep *ep, struct usb_request *req]\n- 调用者: composite_setup\n- 被调用者: []"
    },
    {
        "id": 3097,
        "cwe": "CWE-787",
        "cve": "CVE-2021-39685",
        "purpose": "Code purpose:\"\"\"处理USB gadget设备的设置请求，包括获取描述符和设置调试模式功能，并将数据复制到请求缓冲区中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在USB gadget子系统的多个setup方法中存在错误的标志检查，导致可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: dbgp_setup\n- 参数: [struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl]\n- 调用者: 未显示（由USB gadget子系统调用）\n- 被调用者: [le16_to_cpu, dev_dbg, dbgp_enable_ep, dbgp_configure_endpoints, gserial_connect, min, memcpy, usb_ep_queue]\n\n2. 函数名: le16_to_cpu\n- 参数: [u16 value]\n- 调用者: dbgp_setup\n- 被调用者: []\n\n3. 函数名: dev_dbg\n- 参数: [const struct device *dev, const char *fmt, ...]\n- 调用者: dbgp_setup\n- 被调用者: []\n\n4. 函数名: dbgp_enable_ep\n- 参数: []\n- 调用者: dbgp_setup\n- 被调用者: []\n\n5. 函数名: dbgp_configure_endpoints\n- 参数: [struct usb_gadget *gadget]\n- 调用者: dbgp_setup\n- 被调用者: []\n\n6. 函数名: gserial_connect\n- 参数: [struct gserial *serial, unsigned port_num]\n- 调用者: dbgp_setup\n- 被调用者: []\n\n7. 函数名: min\n- 参数: [u16 length, u16 len]\n- 调用者: dbgp_setup\n- 被调用者: []\n\n8. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: dbgp_setup\n- 被调用者: []\n\n9. 函数名: usb_ep_queue\n- 参数: [struct usb_ep *ep, struct usb_request *req, gfp_t gfp_flags]\n- 调用者: dbgp_setup\n- 被调用者: []\n\n10. 函数名: dbgp_setup_complete\n- 参数: [未显示]\n- 调用者: 未直接调用（作为回调函数指针赋值）\n- 被调用者: []"
    },
    {
        "id": 3098,
        "cwe": "CWE-787",
        "cve": "CVE-2021-39685",
        "purpose": "Code purpose:\"\"\"处理USB gadget设备的控制请求，包括设备描述符获取、配置设置等USB标准请求，并管理设备状态转换和数据传输。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于USB gadget子系统中各种setup方法对标志检查不正确，导致可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: gadgetfs_setup\n- 参数: [struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl]\n- 调用者: 未显示（应为USB gadget子系统调用）\n- 被调用者: [get_gadget_data, le16_to_cpu, gadget_is_dualspeed, next_event, ep0_readable, min, make_qualifier, config_buf, usb_gadget_vbus_draw, usb_gadget_set_state, setup_req, usb_ep_queue, clean_req]\n\n2. 函数名: get_gadget_data\n- 参数: [struct usb_gadget *gadget]\n- 调用者: gadgetfs_setup\n- 被调用者: 未显示\n\n3. 函数名: le16_to_cpu\n- 参数: [u16 value]\n- 调用者: gadgetfs_setup\n- 被调用者: 未显示\n\n4. 函数名: gadget_is_dualspeed\n- 参数: [struct usb_gadget *gadget]\n- 调用者: gadgetfs_setup\n- 被调用者: 未显示\n\n5. 函数名: next_event\n- 参数: [struct dev_data *dev, int type]\n- 调用者: gadgetfs_setup\n- 被调用者: 未显示\n\n6. 函数名: ep0_readable\n- 参数: [struct dev_data *dev]\n- 调用者: gadgetfs_setup\n- 被调用者: 未显示\n\n7. 函数名: min\n- 参数: [u16 a, u16 b]\n- 调用者: gadgetfs_setup\n- 被调用者: 未显示\n\n8. 函数名: make_qualifier\n- 参数: [struct dev_data *dev]\n- 调用者: gadgetfs_setup\n- 被调用者: 未显示\n\n9. 函数名: config_buf\n- 参数: [struct dev_data *dev, int type, int index]\n- 调用者: gadgetfs_setup\n- 被调用者: 未显示\n\n10. 函数名: usb_gadget_vbus_draw\n- 参数: [struct usb_gadget *gadget, unsigned mA]\n- 调用者: gadgetfs_setup\n- 被调用者: 未显示\n\n11. 函数名: usb_gadget_set_state\n- 参数: [struct usb_gadget *gadget, enum usb_device_state state]\n- 调用者: gadgetfs_setup\n- 被调用者: 未显示\n\n12. 函数名: setup_req\n- 参数: [struct usb_ep *ep, struct usb_request *req, int len]\n- 调用者: gadgetfs_setup\n- 被调用者: 未显示\n\n13. 函数名: usb_ep_queue\n- 参数: [struct usb_ep *ep, struct usb_request *req, gfp_t gfp_flags]\n- 调用者: gadgetfs_setup\n- 被调用者: 未显示\n\n14. 函数名: clean_req\n- 参数: [struct usb_ep *ep, struct usb_request *req]\n- 调用者: gadgetfs_setup\n- 被调用者: 未显示"
    },
    {
        "id": 3129,
        "cwe": "CWE-787",
        "cve": "CVE-2021-4090",
        "purpose": "Code purpose:\"\"\"该代码用于解码NFSv4协议中的位图数据，将接收到的位图数据写入到指定的内存区域中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在nfsd4_decode_bitmap4函数中，未对count参数进行足够严格的边界检查，导致可能写入超出bmval数组边界的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: nfsd4_decode_bitmap4\n- 参数: [struct nfsd4_compoundargs *argp, u32 *bmval, u32 bmlen]\n- 调用者: 未明确（由NFSD调用）\n- 被调用者: [xdr_stream_decode_u32, xdr_inline_decode, be32_to_cpup]\n\n2. 函数名: xdr_stream_decode_u32\n- 参数: [struct xdr_stream *xdr, u32 *ptr]\n- 调用者: nfsd4_decode_bitmap4\n- 被调用者: []\n\n3. 函数名: xdr_inline_decode\n- 参数: [struct xdr_stream *xdr, size_t nbytes]\n- 调用者: nfsd4_decode_bitmap4\n- 被调用者: []\n\n4. 函数名: be32_to_cpup\n- 参数: [const __be32 *p]\n- 调用者: nfsd4_decode_bitmap4\n- 被调用者: []"
    },
    {
        "id": 3130,
        "cwe": "CWE-787",
        "cve": "CVE-2021-4093",
        "purpose": "Code purpose:\"\"\"将vcpu中的pio数据复制到sev_pio_data缓冲区，并重置pio计数器\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对vcpu->arch.pio.count和vcpu->arch.pio.size进行边界检查，导致memcpy操作可能产生越界读写漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: complete_sev_es_emulated_ins\n- 参数: [vcpu]\n- 调用者: 未明确（需结合完整代码上下文）\n- 被调用者: [memcpy]"
    },
    {
        "id": 3131,
        "cwe": "CWE-787",
        "cve": "CVE-2021-4093",
        "purpose": "Code purpose:\"\"\"该代码用于处理KVM中SEV-ES虚拟机的字符串I/O操作，包括输入(ins)和输出(outs)指令的执行。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对输入参数进行边界检查，导致恶意虚拟机可以通过字符串I/O指令触发主机内核的越界读写\"\"\"",
        "functions": "Functions:\n1. 函数名: kvm_sev_es_string_io\n- 参数: [vcpu, size, port, data, count, in]\n- 调用者: 未指定\n- 被调用者: [kvm_sev_es_ins, kvm_sev_es_outs]\n\n2. 函数名: kvm_sev_es_ins\n- 参数: [vcpu, size, port, count]\n- 调用者: kvm_sev_es_string_io\n- 被调用者: 未指定\n\n3. 函数名: kvm_sev_es_outs\n- 参数: [vcpu, size, port, count]\n- 调用者: kvm_sev_es_string_io\n- 被调用者: 未指定"
    },
    {
        "id": 3144,
        "cwe": "CWE-787",
        "cve": "CVE-2021-42008",
        "purpose": "Code purpose:\"\"\"解码6pack协议数据并将结果存入缓冲区\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对sp->rx_count_cooked进行边界检查，导致在写入sp->cooked_buf时可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: decode_data\n- 参数: [struct sixpack *sp, unsigned char inbyte]\n- 调用者: 未提供（上下文缺失）\n- 被调用者: []"
    },
    {
        "id": 3156,
        "cwe": "CWE-787",
        "cve": "CVE-2021-42327",
        "purpose": "Code purpose:\"\"\"该代码用于处理用户通过调试文件系统写入的显示链接设置参数，并将这些参数应用到AMD GPU显示驱动中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于parse_write_buffer_into_params函数在使用copy_from_user拷贝用户空间缓冲区到40字节堆缓冲区时未对size参数进行有效性检查，导致堆缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: dp_link_settings_write\n- 参数: [struct file *f, const char __user *buf, size_t size, loff_t *pos]\n- 调用者: 外部调用（文件操作回调）\n- 被调用者: [file_inode, kcalloc, parse_write_buffer_into_params, kfree, DRM_DEBUG_DRIVER, dp_retrain_link_dp_test]\n\n2. 函数名: file_inode\n- 参数: [struct file *f]\n- 调用者: dp_link_settings_write\n- 被调用者: []\n\n3. 函数名: kcalloc\n- 参数: [size_t n, size_t size, gfp_t flags]\n- 调用者: dp_link_settings_write\n- 被调用者: []\n\n4. 函数名: parse_write_buffer_into_params\n- 参数: [char *wr_buf, size_t size, long *param, const char __user *buf, int max_param_num, uint8_t *param_nums]\n- 调用者: dp_link_settings_write\n- 被调用者: []\n\n5. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: dp_link_settings_write\n- 被调用者: []\n\n6. 函数名: DRM_DEBUG_DRIVER\n- 参数: [const char *fmt, ...]\n- 调用者: dp_link_settings_write\n- 被调用者: []\n\n7. 函数名: dp_retrain_link_dp_test\n- 参数: [struct dc_link *link, struct dc_link_settings *prefer_link_settings, bool false]\n- 调用者: dp_link_settings_write\n- 被调用者: []"
    },
    {
        "id": 3157,
        "cwe": "CWE-787",
        "cve": "CVE-2021-42739",
        "purpose": "Code purpose:\"\"\"处理FireDTV媒体卡驱动中的CA PMT(节目映射表)消息，包括解析消息内容、构建响应帧并进行CRC校验，用于条件接收系统的通信处理。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于程序在处理CA_SEND_MSG ioctl调用时，未能正确验证用户输入的msg长度和内容，导致堆缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: avc_ca_pmt\n- 参数: [struct firedtv *fdtv, char *msg, int length]\n- 调用者: 未显示（由ioctl调用）\n- 被调用者: [debug_pmt, mutex_lock, dev_info, dev_err, memcpy, crc32_be, pad_operands, ALIGN, avc_write, mutex_unlock]\n\n2. 函数名: debug_pmt\n- 参数: [char *msg, int length]\n- 调用者: avc_ca_pmt\n- 被调用者: []\n\n3. 函数名: mutex_lock\n- 参数: [struct mutex *avc_mutex]\n- 调用者: avc_ca_pmt\n- 被调用者: []\n\n4. 函数名: dev_info\n- 参数: [struct device *device, const char *fmt, ...]\n- 调用者: avc_ca_pmt\n- 被调用者: []\n\n5. 函数名: dev_err\n- 参数: [struct device *device, const char *fmt, ...]\n- 调用者: avc_ca_pmt\n- 被调用者: []\n\n6. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: avc_ca_pmt\n- 被调用者: []\n\n7. 函数名: crc32_be\n- 参数: [unsigned int crc, unsigned char const *p, size_t len]\n- 调用者: avc_ca_pmt\n- 被调用者: []\n\n8. 函数名: pad_operands\n- 参数: [struct avc_command_frame *c, int write_pos]\n- 调用者: avc_ca_pmt\n- 被调用者: []\n\n9. 函数名: ALIGN\n- 参数: [int x, int a]\n- 调用者: avc_ca_pmt\n- 被调用者: []\n\n10. 函数名: avc_write\n- 参数: [struct firedtv *fdtv]\n- 调用者: avc_ca_pmt\n- 被调用者: []\n\n11. 函数名: mutex_unlock\n- 参数: [struct mutex *avc_mutex]\n- 调用者: avc_ca_pmt\n- 被调用者: []"
    },
    {
        "id": 3158,
        "cwe": "CWE-787",
        "cve": "CVE-2021-42739",
        "purpose": "Code purpose:\"\"\"处理FireDTV媒体卡驱动中的CA消息，解析消息长度并将消息内容传递给avc_ca_pmt函数\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理CA_SEND_MSG ioctl消息时，未对msg->msg[3]的值进行充分验证，导致可能发生堆缓冲区溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: fdtv_ca_pmt\n- 参数: [struct firedtv *fdtv, void *arg]\n- 调用者: 未明确（由CA_SEND_MSG ioctl调用）\n- 被调用者: [avc_ca_pmt]\n\n2. 函数名: avc_ca_pmt\n- 参数: [struct firedtv *fdtv, &msg->msg[data_pos], data_length]\n- 调用者: fdtv_ca_pmt\n- 被调用者: 未明确"
    },
    {
        "id": 3165,
        "cwe": "CWE-787",
        "cve": "CVE-2021-43975",
        "purpose": "Code purpose:\"\"\"该代码用于等待并处理来自硬件固件的远程过程调用(RPC)响应，包括读取控制寄存器、验证状态和传输数据等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对fw.len进行有效边界检查，导致攻击者可通过精心构造的长度值触发越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: hw_atl_utils_fw_rpc_wait\n- 参数: [self, rpc]\n- 调用者: N/A (top-level function)\n- 被调用者: [aq_hw_read_reg, readx_poll_timeout_atomic, hw_atl_utils_rpc_state_get, aq_hw_err_from_flags, hw_atl_utils_fw_rpc_call, hw_atl_utils_fw_downld_dwords]\n\n2. 函数名: aq_hw_read_reg\n- 参数: [self, HW_ATL_RPC_CONTROL_ADR]\n- 调用者: hw_atl_utils_fw_rpc_wait\n- 被调用者: []\n\n3. 函数名: readx_poll_timeout_atomic\n- 参数: [hw_atl_utils_rpc_state_get, self, fw.val, sw.tid == fw.tid, 1000U, 100000U]\n- 调用者: hw_atl_utils_fw_rpc_wait\n- 被调用者: [hw_atl_utils_rpc_state_get]\n\n4. 函数名: hw_atl_utils_rpc_state_get\n- 参数: [self, fw.val]\n- 调用者: readx_poll_timeout_atomic\n- 被调用者: []\n\n5. 函数名: aq_hw_err_from_flags\n- 参数: [self]\n- 调用者: hw_atl_utils_fw_rpc_wait\n- 被调用者: []\n\n6. 函数名: hw_atl_utils_fw_rpc_call\n- 参数: [self, sw.len]\n- 调用者: hw_atl_utils_fw_rpc_wait\n- 被调用者: []\n\n7. 函数名: hw_atl_utils_fw_downld_dwords\n- 参数: [self, self->rpc_addr, (u32 *)(void *)&self->rpc, (fw.len + sizeof(u32) - sizeof(u8)) / sizeof(u32)]\n- 调用者: hw_atl_utils_fw_rpc_wait\n- 被调用者: []"
    },
    {
        "id": 3207,
        "cwe": "CWE-787",
        "cve": "CVE-2022-0435",
        "purpose": "Code purpose:\"\"\"处理TIPC协议接收到的消息，包括链接重置、激活、状态更新等操作，并维护链接状态和参数。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于TIPC协议在处理恶意数据包时未正确验证域成员节点数量，导致允许超过64个节点的域成员数，从而引发栈溢出漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: tipc_link_proto_rcv\n- 参数: [struct tipc_link *l, struct sk_buff *skb, struct sk_buff_head *xmitq]\n- 调用者: 未显示（由TIPC协议栈调用）\n- 被调用者: [buf_msg, msg_probe, msg_next_sent, msg_link_tolerance, msg_linkprio, msg_seq_gap, msg_ack, msg_type, trace_tipc_proto_rcv, tipc_link_is_blocked, tipc_own_addr, msg_prevnode, msg_net_plane, skb_linearize, msg_data, tipc_link_validate_msg, trace_tipc_skb_dump, trace_tipc_link_dump, strrchr, strncpy, in_range, msg_peer_stopping, tipc_link_fsm_evt, msg_dest_session_valid, less, msg_dest_session, link_is_up, msg_session, msg_bearer_id, msg_max_pkt, msg_seqno, tipc_get_gap_ack_blks, tipc_mon_rcv, msg_is_keepalive, tipc_link_is_synching, skb_queue_empty, tipc_link_build_proto_msg, tipc_link_advance_transmq, tipc_link_update_cwin, tipc_link_advance_backlog, link_prepare_wakeup, kfree_skb]\n\n2. 函数名: buf_msg\n- 参数: [struct sk_buff *skb]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n3. 函数名: msg_probe\n- 参数: [struct tipc_msg *hdr]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n4. 函数名: msg_next_sent\n- 参数: [struct tipc_msg *hdr]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n5. 函数名: msg_link_tolerance\n- 参数: [struct tipc_msg *hdr]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n6. 函数名: msg_linkprio\n- 参数: [struct tipc_msg *hdr]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n7. 函数名: msg_seq_gap\n- 参数: [struct tipc_msg *hdr]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n8. 函数名: msg_ack\n- 参数: [struct tipc_msg *hdr]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n9. 函数名: msg_type\n- 参数: [struct tipc_msg *hdr]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n10. 函数名: trace_tipc_proto_rcv\n- 参数: [struct sk_buff *skb, bool false, char *l->name]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n11. 函数名: tipc_link_is_blocked\n- 参数: [struct tipc_link *l]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n12. 函数名: tipc_own_addr\n- 参数: [struct net *l->net]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n13. 函数名: msg_prevnode\n- 参数: [struct tipc_msg *hdr]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n14. 函数名: msg_net_plane\n- 参数: [struct tipc_msg *hdr]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n15. 函数名: skb_linearize\n- 参数: [struct sk_buff *skb]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n16. 函数名: msg_data\n- 参数: [struct tipc_msg *hdr]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n17. 函数名: tipc_link_validate_msg\n- 参数: [struct tipc_link *l, struct tipc_msg *hdr]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n18. 函数名: trace_tipc_skb_dump\n- 参数: [struct sk_buff *skb, bool false, char *\"PROTO invalid (1)!\"]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n19. 函数名: trace_tipc_link_dump\n- 参数: [struct tipc_link *l, int TIPC_DUMP_NONE, char *\"PROTO invalid (1)!\"]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n20. 函数名: strrchr\n- 参数: [char *l->name, char ':']\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n21. 函数名: strncpy\n- 参数: [char *if_name, void *data, int TIPC_MAX_IF_NAME]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n22. 函数名: in_range\n- 参数: [u16 peers_tol, int TIPC_MIN_LINK_TOL, int TIPC_MAX_LINK_TOL]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n23. 函数名: msg_peer_stopping\n- 参数: [struct tipc_msg *hdr]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n24. 函数名: tipc_link_fsm_evt\n- 参数: [struct tipc_link *l, int LINK_FAILURE_EVT]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n25. 函数名: msg_dest_session_valid\n- 参数: [struct tipc_msg *hdr]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n26. 函数名: less\n- 参数: [u16 l->session, u16 msg_dest_session(hdr)]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n27. 函数名: msg_dest_session\n- 参数: [struct tipc_msg *hdr]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n28. 函数名: link_is_up\n- 参数: [struct tipc_link *l]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n29. 函数名: msg_session\n- 参数: [struct tipc_msg *hdr]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n30. 函数名: msg_bearer_id\n- 参数: [struct tipc_msg *hdr]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n31. 函数名: msg_max_pkt\n- 参数: [struct tipc_msg *hdr]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n32. 函数名: msg_seqno\n- 参数: [struct tipc_msg *hdr]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n33. 函数名: tipc_get_gap_ack_blks\n- 参数: [struct tipc_gap_ack_blks **ga, struct tipc_link *l, struct tipc_msg *hdr, bool true]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n34. 函数名: tipc_mon_rcv\n- 参数: [struct net *l->net, void *data + glen, u16 dlen - glen, u32 l->addr, struct tipc_mon_state *l->mon_state, u32 l->bearer_id]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n35. 函数名: msg_is_keepalive\n- 参数: [struct tipc_msg *hdr]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n36. 函数名: more\n- 参数: [u16 peers_snd_nxt, u16 rcv_nxt]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n37. 函数名: tipc_link_is_synching\n- 参数: [struct tipc_link *l]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n38. 函数名: skb_queue_empty\n- 参数: [struct sk_buff_head *l->deferdq]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n39. 函数名: tipc_link_build_proto_msg\n- 参数: [struct tipc_link *l, int STATE_MSG, int 0, bool reply, u16 rcvgap, int 0, int 0, struct sk_buff_head *xmitq]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n40. 函数名: tipc_link_advance_transmq\n- 参数: [struct tipc_link *l, struct tipc_link *l, u16 ack, u16 gap, struct tipc_gap_ack_blks *ga, struct sk_buff_head *xmitq, bool *retransmitted, int *rc]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n41. 函数名: tipc_link_update_cwin\n- 参数: [struct tipc_link *l, int released, bool retransmitted]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n42. 函数名: tipc_link_advance_backlog\n- 参数: [struct tipc_link *l, struct sk_buff_head *xmitq]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n43. 函数名: link_prepare_wakeup\n- 参数: [struct tipc_link *l]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []\n\n44. 函数名: kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: tipc_link_proto_rcv\n- 被调用者: []"
    },
    {
        "id": 3208,
        "cwe": "CWE-787",
        "cve": "CVE-2022-0435",
        "purpose": "Code purpose:\"\"\"处理接收到的TIPC监控域记录，更新对等节点状态并应用域变更，但存在对恶意构造的域成员数量缺乏充分检查的问题\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对接收到的域成员节点数量进行有效验证，导致当恶意构造的包中成员数量超过允许的64个时，会引发栈溢出漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: tipc_mon_rcv\n- 参数: [struct net *net, void *data, u16 dlen, u32 addr, struct tipc_mon_state *state, int bearer_id]\n- 调用者: 未显示\n- 被调用者: [tipc_monitor, mon_le16_to_cpu, dom_rec_len, more, get_peer, memcpy, kfree, kmalloc, mon_le64_to_cpu, mon_le32_to_cpu, mon_apply_domain, mon_identify_lost_members, mon_assign_roles, peer_head, write_lock_bh, write_unlock_bh]\n\n2. 函数名: tipc_monitor\n- 参数: [struct net *net, int bearer_id]\n- 调用者: tipc_mon_rcv\n- 被调用者: 未显示\n\n3. 函数名: mon_le16_to_cpu\n- 参数: [u16 value]\n- 调用者: tipc_mon_rcv\n- 被调用者: 未显示\n\n4. 函数名: dom_rec_len\n- 参数: [struct tipc_mon_domain *arrv_dom, int new_member_cnt]\n- 调用者: tipc_mon_rcv\n- 被调用者: 未显示\n\n5. 函数名: more\n- 参数: [u16 acked_gen, u16 peer_gen]\n- 调用者: tipc_mon_rcv\n- 被调用者: 未显示\n\n6. 函数名: get_peer\n- 参数: [struct tipc_monitor *mon, u32 addr]\n- 调用者: tipc_mon_rcv\n- 被调用者: 未显示\n\n7. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: tipc_mon_rcv\n- 被调用者: 未显示\n\n8. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: tipc_mon_rcv\n- 被调用者: 未显示\n\n9. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: tipc_mon_rcv\n- 被调用者: 未显示\n\n10. 函数名: mon_le64_to_cpu\n- 参数: [u64 value]\n- 调用者: tipc_mon_rcv\n- 被调用者: 未显示\n\n11. 函数名: mon_le32_to_cpu\n- 参数: [u32 value]\n- 调用者: tipc_mon_rcv\n- 被调用者: 未显示\n\n12. 函数名: mon_apply_domain\n- 参数: [struct tipc_monitor *mon, struct tipc_peer *peer]\n- 调用者: tipc_mon_rcv\n- 被调用者: 未显示\n\n13. 函数名: mon_identify_lost_members\n- 参数: [struct tipc_peer *peer, struct tipc_mon_domain *dom_bef, int applied_bef]\n- 调用者: tipc_mon_rcv\n- 被调用者: 未显示\n\n14. 函数名: mon_assign_roles\n- 参数: [struct tipc_monitor *mon, struct tipc_peer *peer]\n- 调用者: tipc_mon_rcv\n- 被调用者: 未显示\n\n15. 函数名: peer_head\n- 参数: [struct tipc_peer *peer]\n- 调用者: tipc_mon_rcv\n- 被调用者: 未显示\n\n16. 函数名: write_lock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: tipc_mon_rcv\n- 被调用者: 未显示\n\n17. 函数名: write_unlock_bh\n- 参数: [spinlock_t *lock]\n- 调用者: tipc_mon_rcv\n- 被调用者: 未显示"
    },
    {
        "id": 3228,
        "cwe": "CWE-787",
        "cve": "CVE-2022-0995",
        "purpose": "Code purpose:\"\"\"该代码用于设置或移除Linux内核中watch_queue事件通知子系统的过滤器，处理用户空间传递的过滤规则并构建内部过滤器结构。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证用户提供的filter.nr_filters值，导致可以分配不足的内存空间，从而在后续操作中造成越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: watch_queue_set_filter\n- 参数: [struct pipe_inode_info *pipe, struct watch_notification_filter __user *_filter]\n- 调用者: 未明确（系统调用或其他内核函数）\n- 被调用者: [copy_from_user, memdup_user, kzalloc, kfree, pipe_lock, rcu_replace_pointer, pipe_unlock, kfree_rcu]\n\n2. 函数名: copy_from_user\n- 参数: [void *to, const void __user *from, unsigned long n]\n- 调用者: watch_queue_set_filter\n- 被调用者: []\n\n3. 函数名: memdup_user\n- 参数: [const void __user *src, size_t len]\n- 调用者: watch_queue_set_filter\n- 被调用者: []\n\n4. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: watch_queue_set_filter\n- 被调用者: []\n\n5. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: watch_queue_set_filter\n- 被调用者: []\n\n6. 函数名: pipe_lock\n- 参数: [struct pipe_inode_info *pipe]\n- 调用者: watch_queue_set_filter\n- 被调用者: []\n\n7. 函数名: rcu_replace_pointer\n- 参数: [void __rcu **pptr, void *new, bool cond]\n- 调用者: watch_queue_set_filter\n- 被调用者: []\n\n8. 函数名: pipe_unlock\n- 参数: [struct pipe_inode_info *pipe]\n- 调用者: watch_queue_set_filter\n- 被调用者: []\n\n9. 函数名: kfree_rcu\n- 参数: [struct rcu_head *head, rcu_callback_t func]\n- 调用者: watch_queue_set_filter\n- 被调用者: []"
    },
    {
        "id": 3238,
        "cwe": "CWE-787",
        "cve": "CVE-2022-1015",
        "purpose": "Code purpose:\"\"\"解析并验证网络过滤器寄存器加载操作，将有效寄存器值存储到目标位置\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未对寄存器值进行充分验证，导致可以写入超出边界的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_parse_register_load\n- 参数: [const struct nlattr *attr, u8 *sreg, u32 len]\n- 调用者: 未提供\n- 被调用者: [nft_parse_register, nft_validate_register_load]\n\n2. 函数名: nft_parse_register\n- 参数: [const struct nlattr *attr]\n- 调用者: nft_parse_register_load\n- 被调用者: 未提供\n\n3. 函数名: nft_validate_register_load\n- 参数: [u32 reg, u32 len]\n- 调用者: nft_parse_register_load\n- 被调用者: 未提供"
    },
    {
        "id": 3239,
        "cwe": "CWE-787",
        "cve": "CVE-2022-1015",
        "purpose": "Code purpose:\"\"\"该代码用于解析并验证网络过滤器(nftables)中的寄存器存储操作，将验证通过的寄存器值存储到目标位置\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未对寄存器值进行充分验证，导致可以写入超出边界的内存区域\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_parse_register_store\n- 参数: [const struct nft_ctx *ctx, const struct nlattr *attr, u8 *dreg, const struct nft_data *data, enum nft_data_types type, unsigned int len]\n- 调用者: 未指定\n- 被调用者: [nft_parse_register, nft_validate_register_store]\n\n2. 函数名: nft_parse_register\n- 参数: [const struct nlattr *attr]\n- 调用者: nft_parse_register_store\n- 被调用者: 未指定\n\n3. 函数名: nft_validate_register_store\n- 参数: [const struct nft_ctx *ctx, u32 reg, const struct nft_data *data, enum nft_data_types type, unsigned int len]\n- 调用者: nft_parse_register_store\n- 被调用者: 未指定"
    },
    {
        "id": 3300,
        "cwe": "CWE-787",
        "cve": "CVE-2022-1943",
        "purpose": "Code purpose:\"\"\"该代码用于处理UDF文件系统中的文件标识符写入操作，包括数据拷贝、填充和CRC校验等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证输入参数边界，导致在内存拷贝操作时可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: udf_write_fi\n- 参数: [struct inode *inode, struct fileIdentDesc *cfi, struct fileIdentDesc *sfi, struct udf_fileident_bh *fibh, uint8_t *impuse, uint8_t *fileident]\n- 调用者: 未明确（由Linux内核UDF文件系统功能调用）\n- 被调用者: [memcpy, memset, crc_itu_t, cpu_to_le16, udf_tag_checksum, mark_inode_dirty, mark_buffer_dirty_inode, inode_inc_iversion, le16_to_cpu, udf_get_fi_ident]\n\n2. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: udf_write_fi\n- 被调用者: []\n\n3. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: udf_write_fi\n- 被调用者: []\n\n4. 函数名: crc_itu_t\n- 参数: [unsigned short crc, const unsigned char *buffer, size_t len]\n- 调用者: udf_write_fi\n- 被调用者: []\n\n5. 函数名: cpu_to_le16\n- 参数: [uint16_t val]\n- 调用者: udf_write_fi\n- 被调用者: []\n\n6. 函数名: udf_tag_checksum\n- 参数: [struct tag *t]\n- 调用者: udf_write_fi\n- 被调用者: []\n\n7. 函数名: mark_inode_dirty\n- 参数: [struct inode *inode]\n- 调用者: udf_write_fi\n- 被调用者: []\n\n8. 函数名: mark_buffer_dirty_inode\n- 参数: [struct buffer_head *bh, struct inode *inode]\n- 调用者: udf_write_fi\n- 被调用者: []\n\n9. 函数名: inode_inc_iversion\n- 参数: [struct inode *inode]\n- 调用者: udf_write_fi\n- 被调用者: []\n\n10. 函数名: le16_to_cpu\n- 参数: [uint16_t val]\n- 调用者: udf_write_fi\n- 被调用者: []\n\n11. 函数名: udf_get_fi_ident\n- 参数: [struct fileIdentDesc *fi]\n- 调用者: udf_write_fi\n- 被调用者: []"
    },
    {
        "id": 3347,
        "cwe": "CWE-787",
        "cve": "CVE-2022-20369",
        "purpose": "Code purpose:\"\"\"处理视频缓冲区队列操作，包括验证缓冲区类型和标志位，执行缓冲区入队操作，并根据流状态管理缓冲区状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺乏对输入参数的充分验证，导致在处理v4l2_buffer结构体时可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: v4l2_m2m_qbuf\n- 参数: [struct file *file, struct v4l2_m2m_ctx *m2m_ctx, struct v4l2_buffer *buf]\n- 调用者: 未显示（外部调用）\n- 被调用者: [video_devdata, v4l2_m2m_get_vq, V4L2_TYPE_IS_CAPTURE, dprintk, vb2_qbuf, vb2_is_streaming, vb2_start_streaming_called, v4l2_m2m_has_stopped, v4l2_m2m_dst_buf_is_last, v4l2_m2m_force_last_buf_done, v4l2_m2m_try_schedule]\n\n2. 函数名: video_devdata\n- 参数: [struct file *file]\n- 调用者: v4l2_m2m_qbuf\n- 被调用者: 未显示\n\n3. 函数名: v4l2_m2m_get_vq\n- 参数: [struct v4l2_m2m_ctx *m2m_ctx, enum v4l2_buf_type type]\n- 调用者: v4l2_m2m_qbuf\n- 被调用者: 未显示\n\n4. 函数名: V4L2_TYPE_IS_CAPTURE\n- 参数: [enum v4l2_buf_type type]\n- 调用者: v4l2_m2m_qbuf\n- 被调用者: 未显示\n\n5. 函数名: dprintk\n- 参数: [const char *fmt, ...]\n- 调用者: v4l2_m2m_qbuf\n- 被调用者: 未显示\n\n6. 函数名: vb2_qbuf\n- 参数: [struct vb2_queue *q, struct media_device *mdev, struct v4l2_buffer *b]\n- 调用者: v4l2_m2m_qbuf\n- 被调用者: 未显示\n\n7. 函数名: vb2_is_streaming\n- 参数: [struct vb2_queue *q]\n- 调用者: v4l2_m2m_qbuf\n- 被调用者: 未显示\n\n8. 函数名: vb2_start_streaming_called\n- 参数: [struct vb2_queue *q]\n- 调用者: v4l2_m2m_qbuf\n- 被调用者: 未显示\n\n9. 函数名: v4l2_m2m_has_stopped\n- 参数: [struct v4l2_m2m_ctx *m2m_ctx]\n- 调用者: v4l2_m2m_qbuf\n- 被调用者: 未显示\n\n10. 函数名: v4l2_m2m_dst_buf_is_last\n- 参数: [struct v4l2_m2m_ctx *m2m_ctx]\n- 调用者: v4l2_m2m_qbuf\n- 被调用者: 未显示\n\n11. 函数名: v4l2_m2m_force_last_buf_done\n- 参数: [struct v4l2_m2m_ctx *m2m_ctx, struct vb2_queue *vq]\n- 调用者: v4l2_m2m_qbuf\n- 被调用者: 未显示\n\n12. 函数名: v4l2_m2m_try_schedule\n- 参数: [struct v4l2_m2m_ctx *m2m_ctx]\n- 调用者: v4l2_m2m_qbuf\n- 被调用者: 未显示"
    },
    {
        "id": 3348,
        "cwe": "CWE-787",
        "cve": "CVE-2022-20369",
        "purpose": "Code purpose:\"\"\"该代码片段用于准备视频缓冲区，通过验证和配置缓冲区参数来实现视频内存到内存的传输功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺乏对输入参数buf->type的充分验证，导致可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: v4l2_m2m_prepare_buf\n- 参数: [struct file *file, struct v4l2_m2m_ctx *m2m_ctx, struct v4l2_buffer *buf]\n- 调用者: 未指定\n- 被调用者: [video_devdata, v4l2_m2m_get_vq, vb2_prepare_buf]\n\n2. 函数名: video_devdata\n- 参数: [struct file *file]\n- 调用者: v4l2_m2m_prepare_buf\n- 被调用者: 未指定\n\n3. 函数名: v4l2_m2m_get_vq\n- 参数: [struct v4l2_m2m_ctx *m2m_ctx, enum v4l2_buf_type type]\n- 调用者: v4l2_m2m_prepare_buf\n- 被调用者: 未指定\n\n4. 函数名: vb2_prepare_buf\n- 参数: [struct vb2_queue *vq, struct media_device *mdev, struct v4l2_buffer *buf]\n- 调用者: v4l2_m2m_prepare_buf\n- 被调用者: 未指定"
    },
    {
        "id": 3349,
        "cwe": "CWE-787",
        "cve": "CVE-2022-20369",
        "purpose": "Code purpose:\"\"\"该代码片段实现了从视频缓冲区队列中取出一个缓冲区的功能，用于视频输入输出处理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺乏对输入参数buf->type的充分验证，导致可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: v4l2_m2m_dqbuf\n- 参数: [file, m2m_ctx, buf]\n- 调用者: 未指定（由外部调用）\n- 被调用者: [v4l2_m2m_get_vq, vb2_dqbuf]\n\n2. 函数名: v4l2_m2m_get_vq\n- 参数: [m2m_ctx, buf->type]\n- 调用者: v4l2_m2m_dqbuf\n- 被调用者: 未指定（可能为内部实现）\n\n3. 函数名: vb2_dqbuf\n- 参数: [vq, buf, file->f_flags & O_NONBLOCK]\n- 调用者: v4l2_m2m_dqbuf\n- 被调用者: 未指定（可能为内部实现）"
    },
    {
        "id": 3350,
        "cwe": "CWE-787",
        "cve": "CVE-2022-20369",
        "purpose": "Code purpose:\"\"\"该代码用于查询视频缓冲区信息并调整内存映射偏移量，主要处理视频捕获队列的内存偏移计算\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对buf->length进行有效验证，导致在循环中可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: v4l2_m2m_querybuf\n- 参数: [file, m2m_ctx, buf]\n- 调用者: 未指定（由外部调用）\n- 被调用者: [v4l2_m2m_get_vq, vb2_querybuf]\n\n2. 函数名: v4l2_m2m_get_vq\n- 参数: [m2m_ctx, buf->type]\n- 调用者: v4l2_m2m_querybuf\n- 被调用者: 未指定（假设为内部实现）\n\n3. 函数名: vb2_querybuf\n- 参数: [vq, buf]\n- 调用者: v4l2_m2m_querybuf\n- 被调用者: 未指定（假设为内部实现）"
    },
    {
        "id": 3409,
        "cwe": "CWE-787",
        "cve": "CVE-2022-21499",
        "purpose": "Code purpose:\"\"\"该代码实现了KGDB和KDB调试器在处理器进入调试状态时的核心逻辑，包括处理主从CPU的调试请求、单步执行控制以及调试会话管理等功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"KGDB和KDB调试器在系统锁定模式下未正确限制对内核内存的读写访问，允许攻击者通过串口触发调试器绕过安全限制\"\"\"",
        "functions": "Functions:\n1. 函数名: kgdb_cpu_enter\n- 参数: [struct kgdb_state *ks, struct pt_regs *regs, int exception_state]\n- 调用者: 未显示\n- 被调用者: [num_online_cpus, atomic_inc, arch_kgdb_ops.disable_hw_break, rcu_read_lock, local_irq_save, hardirq_count, smp_mb, raw_spin_trylock, atomic_xchg, dump_stack, raw_spin_is_locked, arch_kgdb_ops.correct_hw_break, tracing_on, smp_mb__before_atomic, atomic_dec, dbg_touch_watchdogs, local_irq_restore, rcu_read_unlock, cpu_relax, atomic_read, kgdb_io_ready, kgdb_skipexception, atomic_inc, dbg_io_ops->pre_exception, raw_spin_lock, atomic_set, kgdb_roundup_cpus, udelay, pr_crit, dbg_deactivate_sw_breakpoints, tracing_is_on, tracing_off, kdb_stub, gdb_serial_stub, dbg_activate_sw_breakpoints, dbg_io_ops->post_exception, raw_spin_unlock, atomic_set]\n\n2. 函数名: num_online_cpus\n- 参数: []\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n3. 函数名: atomic_inc\n- 参数: [&masters_in_kgdb, &slaves_in_kgdb]\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n4. 函数名: arch_kgdb_ops.disable_hw_break\n- 参数: [regs]\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n5. 函数名: rcu_read_lock\n- 参数: []\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n6. 函数名: local_irq_save\n- 参数: [flags]\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n7. 函数名: hardirq_count\n- 参数: []\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n8. 函数名: smp_mb\n- 参数: []\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n9. 函数名: raw_spin_trylock\n- 参数: [&dbg_master_lock]\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n10. 函数名: atomic_xchg\n- 参数: [&kgdb_active, cpu]\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n11. 函数名: dump_stack\n- 参数: []\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n12. 函数名: raw_spin_is_locked\n- 参数: [&dbg_slave_lock]\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n13. 函数名: arch_kgdb_ops.correct_hw_break\n- 参数: []\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n14. 函数名: tracing_on\n- 参数: []\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n15. 函数名: smp_mb__before_atomic\n- 参数: []\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n16. 函数名: atomic_dec\n- 参数: [&slaves_in_kgdb, &masters_in_kgdb]\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n17. 函数名: dbg_touch_watchdogs\n- 参数: []\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n18. 函数名: local_irq_restore\n- 参数: [flags]\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n19. 函数名: rcu_read_unlock\n- 参数: []\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n20. 函数名: cpu_relax\n- 参数: []\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n21. 函数名: atomic_read\n- 参数: [&kgdb_cpu_doing_single_step, &masters_in_kgdb, &slaves_in_kgdb]\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n22. 函数名: kgdb_io_ready\n- 参数: [1]\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n23. 函数名: kgdb_skipexception\n- 参数: [ks->ex_vector, ks->linux_regs]\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n24. 函数名: dbg_io_ops->pre_exception\n- 参数: []\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n25. 函数名: raw_spin_lock\n- 参数: [&dbg_slave_lock]\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n26. 函数名: atomic_set\n- 参数: [ks->send_ready, 1, &kgdb_active, -1, &kgdb_cpu_doing_single_step]\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n27. 函数名: kgdb_roundup_cpus\n- 参数: []\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n28. 函数名: udelay\n- 参数: [1000]\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n29. 函数名: pr_crit\n- 参数: [\"Timed out waiting for secondary CPUs.\"]\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n30. 函数名: dbg_deactivate_sw_breakpoints\n- 参数: []\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n31. 函数名: tracing_is_on\n- 参数: []\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n32. 函数名: tracing_off\n- 参数: []\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n33. 函数名: kdb_stub\n- 参数: [ks]\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n34. 函数名: gdb_serial_stub\n- 参数: [ks]\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n35. 函数名: dbg_activate_sw_breakpoints\n- 参数: []\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n36. 函数名: dbg_io_ops->post_exception\n- 参数: []\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示\n\n37. 函数名: raw_spin_unlock\n- 参数: [&dbg_slave_lock, &dbg_master_lock]\n- 调用者: kgdb_cpu_enter\n- 被调用者: 未显示"
    },
    {
        "id": 3410,
        "cwe": "CWE-787",
        "cve": "CVE-2022-21499",
        "purpose": "Code purpose:\"\"\"检查并调整KDB调试器的权限标志，以确定是否允许执行特定命令\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"该漏洞是由于KGDB/KDB调试器在锁定模式下未能正确限制对内核内存的读写访问权限，导致攻击者可通过串口触发调试器绕过安全限制\"\"\"",
        "functions": "Functions:\n1. 函数名: kdb_check_flags\n- 参数: [kdb_cmdflags_t flags, int permissions, bool no_args]\n- 调用者: 未在代码片段中显示\n- 被调用者: []"
    },
    {
        "id": 3411,
        "cwe": "CWE-787",
        "cve": "CVE-2022-21499",
        "purpose": "Code purpose:\"\"\"该代码实现了内核调试器(KDB)的本地处理功能，包括调试原因判断、状态显示、命令获取与解析等核心调试操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"KGDB和KDB调试器在系统锁定模式下未正确限制对内核内存的读写访问权限，允许攻击者通过串口触发调试器从而绕过安全限制\"\"\"",
        "functions": "Functions:\n1. 函数名: kdb_local\n- 参数: [reason, error, regs, db_result]\n- 调用者: 未显示（外部调用）\n- 被调用者: [kdb_curr_task, raw_smp_processor_id, KDB_DEBUG_STATE, kdb_printf, instruction_pointer, kdb_dumpregs, kdbgetenv, snprintf, strncat, kdb_getstr, strscpy, handle_ctrl_cmd, kdb_parse, drop_newline, kdb_cmderror]\n\n2. 函数名: kdb_curr_task\n- 参数: [raw_smp_processor_id()]\n- 调用者: kdb_local\n- 被调用者: []\n\n3. 函数名: raw_smp_processor_id\n- 参数: []\n- 调用者: kdb_local, kdb_curr_task\n- 被调用者: []\n\n4. 函数名: KDB_DEBUG_STATE\n- 参数: [\"kdb_local 1\", reason], [\"kdb_local 4\", reason], [\"kdb_local 6\", reason], [\"kdb_local 8\", reason], [\"kdb_local 9\", diag]\n- 调用者: kdb_local\n- 被调用者: []\n\n5. 函数名: kdb_printf\n- 参数: [\"\\nEntering kdb (current=0x%px, pid %d) \", kdb_current, kdb_current ? kdb_current->pid : 0], [\"on processor %d \", raw_smp_processor_id()], [\"\\nEntering kdb (0x%px, pid %d) \", kdb_current, kdb_current->pid], [\"on processor %d \", raw_smp_processor_id()], [\"due to Debug @ \" kdb_machreg_fmt \"\\n\", instruction_pointer(regs)], [\"kdb: Bad result from kdba_db_trap: %d\\n\", db_result], [\"due to Keyboard Entry\\n\"], [\"due to KDB_ENTER()\\n\"], [\"due to cpu switch\\n\"], [\"Oops: %s\\n\", kdb_diemsg], [\"due to oops @ \" kdb_machreg_fmt \"\\n\", instruction_pointer(regs)], [\"due to System NonMaskable Interrupt\\n\"], [\"due to NonMaskable Interrupt @ \" kdb_machreg_fmt \"\\n\", instruction_pointer(regs)], [\"due to %s @ \" kdb_machreg_fmt \"\\n\", reason == KDB_REASON_BREAK ? \"Breakpoint\" : \"SS trap\", instruction_pointer(regs)], [\"kdb: error return from kdba_bp_trap: %d\\n\", db_result], [\"due to Recursion @ \" kdb_machreg_fmt \"\\n\", instruction_pointer(regs)], [\"kdb: unexpected reason code: %d\\n\", reason], [\"Unknown kdb command: '%s'\\n\", cmdbuf]\n- 调用者: kdb_local\n- 被调用者: []\n\n6. 函数名: instruction_pointer\n- 参数: [regs]\n- 调用者: kdb_local\n- 被调用者: []\n\n7. 函数名: kdb_dumpregs\n- 参数: [regs]\n- 调用者: kdb_local\n- 被调用者: []\n\n8. 函数名: kdbgetenv\n- 参数: [\"PROMPT\"]\n- 调用者: kdb_local\n- 被调用者: []\n\n9. 函数名: snprintf\n- 参数: [kdb_prompt_str, CMD_BUFLEN, kdbgetenv(\"PROMPT\"), raw_smp_processor_id()]\n- 调用者: kdb_local\n- 被调用者: []\n\n10. 函数名: strncat\n- 参数: [kdb_prompt_str, \"[defcmd]\", CMD_BUFLEN]\n- 调用者: kdb_local\n- 被调用者: []\n\n11. 函数名: kdb_getstr\n- 参数: [cmdbuf, CMD_BUFLEN, kdb_prompt_str]\n- 调用者: kdb_local\n- 被调用者: []\n\n12. 函数名: strscpy\n- 参数: [cmd_hist[cmd_head], cmd_cur, CMD_BUFLEN], [cmd_hist[cmd_head], cmd_cur, CMD_BUFLEN]\n- 调用者: kdb_local\n- 被调用者: []\n\n13. 函数名: handle_ctrl_cmd\n- 参数: [cmdbuf]\n- 调用者: kdb_local\n- 被调用者: []\n\n14. 函数名: kdb_parse\n- 参数: [cmdbuf]\n- 调用者: kdb_local\n- 被调用者: []\n\n15. 函数名: drop_newline\n- 参数: [cmdbuf]\n- 调用者: kdb_local\n- 被调用者: []\n\n16. 函数名: kdb_cmderror\n- 参数: [diag]\n- 调用者: kdb_local\n- 被调用者: []"
    },
    {
        "id": 3462,
        "cwe": "CWE-787",
        "cve": "CVE-2022-2380",
        "purpose": "Code purpose:\"\"\"该代码实现了从帧缓冲设备读取数据到用户空间缓冲区的功能，主要用于图形显示驱动的读取操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证用户提供的偏移量(ppos)和读取大小(count)参数，导致在内存访问时可能超出边界\"\"\"",
        "functions": "Functions:\n1. 函数名: smtcfb_read\n- 参数: [struct fb_info *info, char __user *buf, size_t count, loff_t *ppos]\n- 调用者: 未明确显示（通常由fb_ops结构中的函数指针调用）\n- 被调用者: [kmalloc, kfree, fb_readl, big_swap, fb_readb, copy_to_user]\n\n2. 函数名: kmalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: smtcfb_read\n- 被调用者: []\n\n3. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: smtcfb_read\n- 被调用者: []\n\n4. 函数名: fb_readl\n- 参数: [u32 __iomem *src]\n- 调用者: smtcfb_read\n- 被调用者: []\n\n5. 函数名: big_swap\n- 参数: [u32 val]\n- 调用者: smtcfb_read\n- 被调用者: []\n\n6. 函数名: fb_readb\n- 参数: [u8 __iomem *src]\n- 调用者: smtcfb_read\n- 被调用者: []\n\n7. 函数名: copy_to_user\n- 参数: [void __user *to, const void *from, unsigned long n]\n- 调用者: smtcfb_read\n- 被调用者: []"
    },
    {
        "id": 3538,
        "cwe": "CWE-787",
        "cve": "CVE-2022-2991",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的NVMe驱动中分配和初始化命名空间(ns)，包括创建关联的磁盘和队列，并处理可能的LightNVM子系统初始化\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未正确验证用户提供的数据长度就直接复制到固定长度的堆缓冲区，导致堆溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: nvme_alloc_ns\n- 参数: [struct nvme_ctrl *ctrl, unsigned nsid, struct nvme_ns_ids *ids]\n- 调用者: (未显示)\n- 被调用者: [nvme_identify_ns, kzalloc_node, blk_mq_init_queue, blk_queue_flag_set, kref_init, nvme_init_ns_head, alloc_disk_node, sprintf, nvme_mpath_set_disk_name, nvme_update_ns_info, nvme_nvm_register, down_write, list_add_tail, up_write, nvme_get_ctrl, device_add_disk, nvme_add_ns_cdev, nvme_mpath_add_disk, nvme_fault_inject_init, kfree, put_disk, mutex_lock, list_del_rcu, list_empty, list_del_init, mutex_unlock, nvme_put_ns_head, blk_cleanup_queue]\n\n2. 函数名: nvme_identify_ns\n- 参数: [struct nvme_ctrl *ctrl, unsigned nsid, struct nvme_ns_ids *ids, struct nvme_id_ns **id]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n3. 函数名: kzalloc_node\n- 参数: [sizeof(*ns), GFP_KERNEL, node]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n4. 函数名: blk_mq_init_queue\n- 参数: [ctrl->tagset]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n5. 函数名: blk_queue_flag_set\n- 参数: [QUEUE_FLAG_STABLE_WRITES, ns->queue], [QUEUE_FLAG_NONROT, ns->queue], [QUEUE_FLAG_PCI_P2PDMA, ns->queue]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n6. 函数名: kref_init\n- 参数: [&ns->kref]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n7. 函数名: nvme_init_ns_head\n- 参数: [ns, nsid, ids, id->nmic & NVME_NS_NMIC_SHARED]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n8. 函数名: alloc_disk_node\n- 参数: [0, node]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n9. 函数名: sprintf\n- 参数: [disk->disk_name, \"nvme%dn%d\", ctrl->instance, ns->head->instance]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n10. 函数名: nvme_mpath_set_disk_name\n- 参数: [ns, disk->disk_name, &disk->flags]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n11. 函数名: nvme_update_ns_info\n- 参数: [ns, id]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n12. 函数名: nvme_nvm_register\n- 参数: [ns, disk->disk_name, node]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n13. 函数名: down_write\n- 参数: [&ctrl->namespaces_rwsem]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n14. 函数名: list_add_tail\n- 参数: [&ns->list, &ctrl->namespaces]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n15. 函数名: up_write\n- 参数: [&ctrl->namespaces_rwsem]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n16. 函数名: nvme_get_ctrl\n- 参数: [ctrl]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n17. 函数名: device_add_disk\n- 参数: [ctrl->device, ns->disk, nvme_ns_id_attr_groups]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n18. 函数名: nvme_add_ns_cdev\n- 参数: [ns]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n19. 函数名: nvme_mpath_add_disk\n- 参数: [ns, id]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n20. 函数名: nvme_fault_inject_init\n- 参数: [&ns->fault_inject, ns->disk->disk_name]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n21. 函数名: kfree\n- 参数: [id]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n22. 函数名: put_disk\n- 参数: [ns->disk]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n23. 函数名: mutex_lock\n- 参数: [&ctrl->subsys->lock]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n24. 函数名: list_del_rcu\n- 参数: [&ns->siblings]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n25. 函数名: list_empty\n- 参数: [&ns->head->list]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n26. 函数名: list_del_init\n- 参数: [&ns->head->entry]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n27. 函数名: mutex_unlock\n- 参数: [&ctrl->subsys->lock]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n28. 函数名: nvme_put_ns_head\n- 参数: [ns->head]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)\n\n29. 函数名: blk_cleanup_queue\n- 参数: [ns->queue]\n- 调用者: nvme_alloc_ns\n- 被调用者: (未显示)"
    },
    {
        "id": 3539,
        "cwe": "CWE-787",
        "cve": "CVE-2022-2991",
        "purpose": "Code purpose:\"\"\"释放NVMe命名空间相关资源并清理内存\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"缺乏对用户提供数据长度的适当验证，导致可复制到固定长度的堆缓冲区中造成堆溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: nvme_free_ns\n- 参数: [kref]\n- 调用者: 未显示\n- 被调用者: [container_of, nvme_nvm_unregister, put_disk, nvme_put_ns_head, nvme_put_ctrl, kfree]\n\n2. 函数名: container_of\n- 参数: [kref, struct nvme_ns, kref]\n- 调用者: nvme_free_ns\n- 被调用者: 未显示\n\n3. 函数名: nvme_nvm_unregister\n- 参数: [ns->ndev]\n- 调用者: nvme_free_ns\n- 被调用者: 未显示\n\n4. 函数名: put_disk\n- 参数: [ns->disk]\n- 调用者: nvme_free_ns\n- 被调用者: 未显示\n\n5. 函数名: nvme_put_ns_head\n- 参数: [ns->head]\n- 调用者: nvme_free_ns\n- 被调用者: 未显示\n\n6. 函数名: nvme_put_ctrl\n- 参数: [ns->ctrl]\n- 调用者: nvme_free_ns\n- 被调用者: 未显示\n\n7. 函数名: kfree\n- 参数: [ns]\n- 调用者: nvme_free_ns\n- 被调用者: 未显示"
    },
    {
        "id": 3540,
        "cwe": "CWE-787",
        "cve": "CVE-2022-2991",
        "purpose": "Code purpose:\"\"\"处理NVMe命名空间的IO控制命令，包括ID获取、IO命令提交等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于缺乏对用户提供数据长度的适当验证，导致在将数据复制到固定长度的堆缓冲区时可能发生堆溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: nvme_ns_ioctl\n- 参数: [struct nvme_ns *ns, unsigned int cmd, void __user *argp]\n- 调用者: 未显示（系统调用或上层驱动）\n- 被调用者: [force_successful_syscall_return, nvme_user_cmd, nvme_submit_io, nvme_user_cmd64, nvme_nvm_ioctl]\n\n2. 函数名: force_successful_syscall_return\n- 参数: []\n- 调用者: nvme_ns_ioctl\n- 被调用者: []\n\n3. 函数名: nvme_user_cmd\n- 参数: [ns->ctrl, ns, argp]\n- 调用者: nvme_ns_ioctl\n- 被调用者: []\n\n4. 函数名: nvme_submit_io\n- 参数: [ns, argp]\n- 调用者: nvme_ns_ioctl\n- 被调用者: []\n\n5. 函数名: nvme_user_cmd64\n- 参数: [ns->ctrl, ns, argp]\n- 调用者: nvme_ns_ioctl\n- 被调用者: []\n\n6. 函数名: nvme_nvm_ioctl\n- 参数: [ns, cmd, argp]\n- 调用者: nvme_ns_ioctl\n- 被调用者: []"
    },
    {
        "id": 3542,
        "cwe": "CWE-787",
        "cve": "CVE-2022-3028",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的XFRM子系统中处理PF_KEY套接字的注册请求，包括验证消息类型、更新注册状态、探测算法并广播支持信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当多个线程同时调用xfrm_probe_algs函数时，由于缺乏同步机制导致竞态条件，可能引发越界写入或内核堆内存泄漏。\"\"\"",
        "functions": "Functions:\n1. 函数名: pfkey_register\n- 参数: [sk, skb, hdr, ext_hdrs]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [pfkey_sk, xfrm_probe_algs, compose_sadb_supported, pfkey_broadcast, sock_net]\n\n2. 函数名: pfkey_sk\n- 参数: [sk]\n- 调用者: pfkey_register\n- 被调用者: []\n\n3. 函数名: xfrm_probe_algs\n- 参数: []\n- 调用者: pfkey_register\n- 被调用者: []\n\n4. 函数名: compose_sadb_supported\n- 参数: [hdr, GFP_KERNEL | __GFP_ZERO]\n- 调用者: pfkey_register\n- 被调用者: []\n\n5. 函数名: pfkey_broadcast\n- 参数: [supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk, sock_net(sk)]\n- 调用者: pfkey_register\n- 被调用者: []\n\n6. 函数名: sock_net\n- 参数: [sk]\n- 调用者: pfkey_register\n- 被调用者: []"
    },
    {
        "id": 3650,
        "cwe": "CWE-787",
        "cve": "CVE-2022-3577",
        "purpose": "Code purpose:\"\"\"该代码用于为BigBen游戏手柄实现LED灯和力反馈功能的驱动探测和初始化\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码假设所有bigben设备都有输入，但恶意设备可以违反此假设，导致越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: bigben_probe\n- 参数: [struct hid_device *hid, const struct hid_device_id *id]\n- 调用者: 内核HID子系统\n- 被调用者: [devm_kzalloc, hid_set_drvdata, hid_parse, hid_err, hid_hw_start, list_entry, list_first_entry, set_bit, INIT_WORK, input_ff_create_memless, strlen, devm_kzalloc, snprintf, devm_led_classdev_register, schedule_work, hid_info, hid_hw_stop]\n\n2. 函数名: devm_kzalloc\n- 参数: [&hid->dev, sizeof(*bigben), GFP_KERNEL]\n- 调用者: bigben_probe\n- 被调用者: []\n\n3. 函数名: hid_set_drvdata\n- 参数: [hid, bigben]\n- 调用者: bigben_probe\n- 被调用者: []\n\n4. 函数名: hid_parse\n- 参数: [hid]\n- 调用者: bigben_probe\n- 被调用者: []\n\n5. 函数名: hid_err\n- 参数: [hid, \"parse failed\\n\"]\n- 调用者: bigben_probe\n- 被调用者: []\n\n6. 函数名: hid_hw_start\n- 参数: [hid, HID_CONNECT_DEFAULT & ~HID_CONNECT_FF]\n- 调用者: bigben_probe\n- 被调用者: []\n\n7. 函数名: list_entry\n- 参数: [report_list->next, struct hid_report, list]\n- 调用者: bigben_probe\n- 被调用者: []\n\n8. 函数名: list_first_entry\n- 参数: [&hid->inputs, struct hid_input, list]\n- 调用者: bigben_probe\n- 被调用者: []\n\n9. 函数名: set_bit\n- 参数: [FF_RUMBLE, hidinput->input->ffbit]\n- 调用者: bigben_probe\n- 被调用者: []\n\n10. 函数名: INIT_WORK\n- 参数: [&bigben->worker, bigben_worker]\n- 调用者: bigben_probe\n- 被调用者: []\n\n11. 函数名: input_ff_create_memless\n- 参数: [hidinput->input, NULL, hid_bigben_play_effect]\n- 调用者: bigben_probe\n- 被调用者: []\n\n12. 函数名: strlen\n- 参数: [dev_name(&hid->dev)]\n- 调用者: bigben_probe\n- 被调用者: []\n\n13. 函数名: snprintf\n- 参数: [name, name_sz, \"%s:red:bigben%d\", dev_name(&hid->dev), n + 1]\n- 调用者: bigben_probe\n- 被调用者: []\n\n14. 函数名: devm_led_classdev_register\n- 参数: [&hid->dev, led]\n- 调用者: bigben_probe\n- 被调用者: []\n\n15. 函数名: schedule_work\n- 参数: [&bigben->worker]\n- 调用者: bigben_probe\n- 被调用者: []\n\n16. 函数名: hid_info\n- 参数: [hid, \"LED and force feedback support for BigBen gamepad\\n\"]\n- 调用者: bigben_probe\n- 被调用者: []\n\n17. 函数名: hid_hw_stop\n- 参数: [hid]\n- 调用者: bigben_probe\n- 被调用者: []"
    },
    {
        "id": 3663,
        "cwe": "CWE-787",
        "cve": "CVE-2022-36280",
        "purpose": "Code purpose:\"\"\"该代码用于处理虚拟机图形设备驱动中的光标图像DMA传输，实现光标图像的复制和更新功能。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证用户提供的SVGA3dCopyBox结构体参数，导致在memcpy操作时可能发生越界内存访问\"\"\"",
        "functions": "Functions:\n1. 函数名: vmw_kms_cursor_snoop\n- 参数: [struct vmw_surface *srf, struct ttm_object_file *tfile, struct ttm_buffer_object *bo, SVGA3dCmdHeader *header]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [container_of, ttm_bo_reserve, ttm_bo_kmap, ttm_kmap_obj_virtual, memcpy, ttm_bo_kunmap, ttm_bo_unreserve]\n\n2. 函数名: container_of\n- 参数: [未显示完整参数]\n- 调用者: vmw_kms_cursor_snoop\n- 被调用者: []\n\n3. 函数名: ttm_bo_reserve\n- 参数: [struct ttm_buffer_object *bo, bool interruptible, bool no_wait, NULL]\n- 调用者: vmw_kms_cursor_snoop\n- 被调用者: []\n\n4. 函数名: ttm_bo_kmap\n- 参数: [struct ttm_buffer_object *bo, unsigned long kmap_offset, unsigned long kmap_num, struct ttm_bo_kmap_obj *map]\n- 调用者: vmw_kms_cursor_snoop\n- 被调用者: []\n\n5. 函数名: ttm_kmap_obj_virtual\n- 参数: [struct ttm_bo_kmap_obj *map, bool *dummy]\n- 调用者: vmw_kms_cursor_snoop\n- 被调用者: []\n\n6. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: vmw_kms_cursor_snoop\n- 被调用者: []\n\n7. 函数名: ttm_bo_kunmap\n- 参数: [struct ttm_bo_kmap_obj *map]\n- 调用者: vmw_kms_cursor_snoop\n- 被调用者: []\n\n8. 函数名: ttm_bo_unreserve\n- 参数: [struct ttm_buffer_object *bo]\n- 调用者: vmw_kms_cursor_snoop\n- 被调用者: []"
    },
    {
        "id": 3719,
        "cwe": "CWE-787",
        "cve": "CVE-2022-41674",
        "purpose": "Code purpose:\"\"\"该代码用于更新非传输BSS（基本服务集）的信息，包括替换SSID和跳过MBSSID IE，以生成新的信息元素并更新BSS的相关数据结构。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理WLAN帧时未正确验证输入数据的长度，导致缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: cfg80211_update_notlisted_nontrans\n- 参数: [wiphy, nontrans_bss, mgmt, len]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [offsetof, cfg80211_find_ie, ieee80211_bss_get_elem, kzalloc, memcpy, le64_to_cpu, ieee80211_is_beacon, ieee80211_is_probe_resp, rcu_access_pointer, rcu_assign_pointer, kfree_rcu, kfree]\n\n2. 函数名: cfg80211_find_ie\n- 参数: [WLAN_EID_SSID, ie, ielen] 和 [WLAN_EID_MULTIPLE_BSSID, ie, ielen]\n- 调用者: cfg80211_update_notlisted_nontrans\n- 被调用者: 未明确（假设是外部函数）\n\n3. 函数名: ieee80211_bss_get_elem\n- 参数: [nontrans_bss, WLAN_EID_SSID]\n- 调用者: cfg80211_update_notlisted_nontrans\n- 被调用者: 未明确（假设是外部函数）\n\n4. 函数名: kzalloc\n- 参数: [new_ie_len, GFP_ATOMIC] 和 [sizeof(*new_ies) + new_ie_len, GFP_ATOMIC]\n- 调用者: cfg80211_update_notlisted_nontrans\n- 被调用者: 未明确（内核内存分配函数）\n\n5. 函数名: memcpy\n- 参数: [pos, nontrans_ssid, cpy_len], [pos, (trans_ssid + cpy_len), (mbssid - (trans_ssid + cpy_len))], [pos, mbssid + cpy_len, ((ie + ielen) - (mbssid + cpy_len))], [new_ies->data, new_ie, new_ie_len]\n- 调用者: cfg80211_update_notlisted_nontrans\n- 被调用者: 未明确（标准库函数）\n\n6. 函数名: le64_to_cpu\n- 参数: [mgmt->u.probe_resp.timestamp]\n- 调用者: cfg80211_update_notlisted_nontrans\n- 被调用者: 未明确（字节序转换函数）\n\n7. 函数名: ieee80211_is_beacon\n- 参数: [mgmt->frame_control]\n- 调用者: cfg80211_update_notlisted_nontrans\n- 被调用者: 未明确（假设是外部函数）\n\n8. 函数名: ieee80211_is_probe_resp\n- 参数: [mgmt->frame_control]\n- 调用者: cfg80211_update_notlisted_nontrans\n- 被调用者: 未明确（假设是外部函数）\n\n9. 函数名: rcu_access_pointer\n- 参数: [nontrans_bss->proberesp_ies] 和 [nontrans_bss->beacon_ies]\n- 调用者: cfg80211_update_notlisted_nontrans\n- 被调用者: 未明确（RCU相关函数）\n\n10. 函数名: rcu_assign_pointer\n- 参数: [nontrans_bss->proberesp_ies, new_ies], [nontrans_bss->ies, new_ies], [nontrans_bss->beacon_ies, new_ies]\n- 调用者: cfg80211_update_notlisted_nontrans\n- 被调用者: 未明确（RCU相关函数）\n\n11. 函数名: kfree_rcu\n- 参数: [(struct cfg80211_bss_ies *)old, rcu_head]\n- 调用者: cfg80211_update_notlisted_nontrans\n- 被调用者: 未明确（RCU内存释放函数）\n\n12. 函数名: kfree\n- 参数: [new_ie]\n- 调用者: cfg80211_update_notlisted_nontrans\n- 被调用者: 未明确（内核内存释放函数）"
    },
    {
        "id": 3741,
        "cwe": "CWE-787",
        "cve": "CVE-2022-43750",
        "purpose": "Code purpose:\"\"\"该代码用于实现usbmon监控器的内存映射功能，设置虚拟内存区域的操作和标志，并将文件私有数据关联到内存区域。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对用户空间客户端访问监控器内部内存进行适当边界检查，导致内存损坏漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: mon_bin_mmap\n- 参数: [filp, vma]\n- 调用者: 未指定（通常由mmap系统调用触发）\n- 被调用者: [mon_bin_vma_open]\n\n2. 函数名: mon_bin_vma_open\n- 参数: [vma]\n- 调用者: mon_bin_mmap\n- 被调用者: 未指定"
    },
    {
        "id": 3742,
        "cwe": "CWE-787",
        "cve": "CVE-2022-4378",
        "purpose": "Code purpose:\"\"\"该代码用于处理内核参数和变量的读写操作，实现用户空间与内核空间之间长整型数组的转换和边界检查\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对用户输入的参数进行充分验证，导致在处理SYSCTL子系统参数时可能发生栈溢出，允许本地用户通过修改特定内核参数来触发漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: __do_proc_doulongvec_minmax\n- 参数: [data, table, write, buffer, lenp, ppos, convmul, convdiv]\n- 调用者: 未明确（可能是外部调用）\n- 被调用者: [proc_first_pos_non_zero_ignore, proc_skip_spaces, proc_get_long, WRITE_ONCE, READ_ONCE, proc_put_char, proc_put_long]\n\n2. 函数名: proc_first_pos_non_zero_ignore\n- 参数: [ppos, table]\n- 调用者: __do_proc_doulongvec_minmax\n- 被调用者: []\n\n3. 函数名: proc_skip_spaces\n- 参数: [p]\n- 调用者: __do_proc_doulongvec_minmax\n- 被调用者: []\n\n4. 函数名: proc_get_long\n- 参数: [p, left, val, neg, proc_wspace_sep, sizeof(proc_wspace_sep), NULL]\n- 调用者: __do_proc_doulongvec_minmax\n- 被调用者: []\n\n5. 函数名: WRITE_ONCE\n- 参数: [*i, val]\n- 调用者: __do_proc_doulongvec_minmax\n- 被调用者: []\n\n6. 函数名: READ_ONCE\n- 参数: [*i]\n- 调用者: __do_proc_doulongvec_minmax\n- 被调用者: []\n\n7. 函数名: proc_put_char\n- 参数: [buffer, left, '\\t'] 或 [buffer, left, '\\n']\n- 调用者: __do_proc_doulongvec_minmax\n- 被调用者: []\n\n8. 函数名: proc_put_long\n- 参数: [buffer, left, val, false]\n- 调用者: __do_proc_doulongvec_minmax\n- 被调用者: []"
    },
    {
        "id": 3743,
        "cwe": "CWE-787",
        "cve": "CVE-2022-4378",
        "purpose": "Code purpose:\"\"\"该代码用于处理内核参数和变量的读写操作，通过SYSCTL子系统实现用户空间与内核空间的数据交互\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证用户输入的缓冲区大小，导致在处理SYSCTL参数时可能发生栈溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: __do_proc_dointvec\n- 参数: [tbl_data, table, write, buffer, lenp, ppos, conv, data]\n- 调用者: (未显示在代码片段中)\n- 被调用者: [proc_first_pos_non_zero_ignore, proc_skip_spaces, proc_get_long, proc_put_char, proc_put_long]\n\n2. 函数名: proc_first_pos_non_zero_ignore\n- 参数: [ppos, table]\n- 调用者: __do_proc_dointvec\n- 被调用者: (未显示在代码片段中)\n\n3. 函数名: proc_skip_spaces\n- 参数: [p]\n- 调用者: __do_proc_dointvec\n- 被调用者: (未显示在代码片段中)\n\n4. 函数名: proc_get_long\n- 参数: [p, left, lval, neg, proc_wspace_sep, sizeof(proc_wspace_sep), NULL]\n- 调用者: __do_proc_dointvec\n- 被调用者: (未显示在代码片段中)\n\n5. 函数名: proc_put_char\n- 参数: [buffer, left, char]\n- 调用者: __do_proc_dointvec\n- 被调用者: (未显示在代码片段中)\n\n6. 函数名: proc_put_long\n- 参数: [buffer, left, lval, neg]\n- 调用者: __do_proc_dointvec\n- 被调用者: (未显示在代码片段中)\n\n7. 函数名: do_proc_dointvec_conv\n- 参数: (未显示完整参数)\n- 调用者: (通过函数指针调用)\n- 被调用者: __do_proc_dointvec"
    },
    {
        "id": 3744,
        "cwe": "CWE-787",
        "cve": "CVE-2022-4378",
        "purpose": "Code purpose:\"\"\"该代码用于处理用户空间通过sysctl接口修改内核无符号整型数组参数的过程，包括参数验证和转换\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理用户提供的输入数据时，未正确验证缓冲区大小限制，导致可能发生栈溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: do_proc_douintvec_w\n- 参数: [tbl_data, table, buffer, lenp, ppos, conv, data]\n- 调用者: 未提供\n- 被调用者: [proc_first_pos_non_zero_ignore, proc_skip_spaces, proc_get_long]\n\n2. 函数名: proc_first_pos_non_zero_ignore\n- 参数: [ppos, table]\n- 调用者: do_proc_douintvec_w\n- 被调用者: 未提供\n\n3. 函数名: proc_skip_spaces\n- 参数: [p]\n- 调用者: do_proc_douintvec_w\n- 被调用者: 未提供\n\n4. 函数名: proc_get_long\n- 参数: [p, left, lval, neg, proc_wspace_sep, sizeof(proc_wspace_sep), NULL]\n- 调用者: do_proc_douintvec_w\n- 被调用者: 未提供"
    },
    {
        "id": 3770,
        "cwe": "CWE-787",
        "cve": "CVE-2022-47942",
        "purpose": "Code purpose:\"\"\"该代码片段用于根据SMB2协议命令类型和参数动态分配响应缓冲区大小，处理不同大小的请求数据。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_QUERY_INFO_HE命令时，由于未充分验证输入数据的有效性，导致可能触发堆缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: smb2_allocate_rsp_buf\n- 参数: [struct ksmbd_work *work]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [smb2_get_msg, le16_to_cpu, le32_to_cpu, kvmalloc]\n\n2. 函数名: smb2_get_msg\n- 参数: [void *request_buf]\n- 调用者: [smb2_allocate_rsp_buf]\n- 被调用者: 未明确\n\n3. 函数名: le16_to_cpu\n- 参数: [__le16 hdr->Command]\n- 调用者: [smb2_allocate_rsp_buf]\n- 被调用者: 未明确\n\n4. 函数名: le32_to_cpu\n- 参数: [__le32 hdr->NextCommand]\n- 调用者: [smb2_allocate_rsp_buf]\n- 被调用者: 未明确\n\n5. 函数名: kvmalloc\n- 参数: [size_t sz, gfp_t GFP_KERNEL | __GFP_ZERO]\n- 调用者: [smb2_allocate_rsp_buf]\n- 被调用者: 未明确"
    },
    {
        "id": 3771,
        "cwe": "CWE-787",
        "cve": "CVE-2022-47942",
        "purpose": "Code purpose:\"\"\"该代码实现了SMB2协议中的文件打开功能，处理客户端发起的文件创建/打开请求，包括权限检查、文件属性设置、ACL处理等操作，并返回相应的文件句柄和状态信息。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_SET_INFO_HE命令时，由于对输入数据验证不足，导致在set_ntacl_dacl函数中发生堆缓冲区溢出。\"\"\"",
        "functions": "Functions:\n1. 函数名: smb2_open\n- 参数: [struct ksmbd_work *work]\n- 调用者: N/A (top-level function)\n- 被调用者: [create_smb2_pipe, smb2_get_name, parse_stream_name, ksmbd_validate_filename, ksmbd_share_veto_filename, kstrdup, parse_lease_state, smb2_find_context_vals, ksmbd_override_fsids, ksmbd_vfs_kern_path, ksmbd_vfs_query_maximal_access, smb2_creat, smb2_set_ea, inode_permission, ksmbd_vfs_may_delete, ksmbd_query_inode_status, dentry_open, ksmbd_open_fd, ksmbd_open_durable_fd, ksmbd_vfs_inherit_posix_acl, smb_inherit_dacl, smb2_create_sd_buffer, ksmbd_vfs_set_init_posix_acl, ksmbd_acls_fattr, build_sec_desc, ksmbd_vfs_set_sd_xattr, smb2_set_stream_name_xattr, smb_break_all_oplock, smb_grant_oplock, ksmbd_fd_set_delete_on_close, smb2_create_truncate, vfs_fallocate, smb_break_all_levII_oplock, smb2_update_xattrs, smb2_new_xattrs, generic_fillattr, create_lease_buf, create_mxac_rsp_buf, create_disk_id_rsp_buf, create_posix_rsp_buf, path_put, ksmbd_revert_fsids, ksmbd_fd_put, smb2_set_err_rsp, kfree]\n\n2. 函数名: create_smb2_pipe\n- 参数: [struct ksmbd_work *work]\n- 调用者: smb2_open\n- 被调用者: []\n\n3. 函数名: smb2_get_name\n- 参数: [req->Buffer, le16_to_cpu(req->NameLength), work->conn->local_nls]\n- 调用者: smb2_open\n- 被调用者: []\n\n4. 函数名: parse_stream_name\n- 参数: [name, &stream_name, &s_type]\n- 调用者: smb2_open\n- 被调用者: []\n\n5. 函数名: ksmbd_validate_filename\n- 参数: [name]\n- 调用者: smb2_open\n- 被调用者: []\n\n6. 函数名: ksmbd_share_veto_filename\n- 参数: [share, name]\n- 调用者: smb2_open\n- 被调用者: []\n\n7. 函数名: parse_lease_state\n- 参数: [req]\n- 调用者: smb2_open\n- 被调用者: []\n\n8. 函数名: smb2_find_context_vals\n- 参数: [req, SMB2_CREATE_EA_BUFFER], [req, SMB2_CREATE_QUERY_MAXIMAL_ACCESS_REQUEST], [req, SMB2_CREATE_TIMEWARP_REQUEST], [req, SMB2_CREATE_TAG_POSIX], [req, SMB2_CREATE_ALLOCATION_SIZE], [req, SMB2_CREATE_QUERY_ON_DISK_ID]\n- 调用者: smb2_open\n- 被调用者: []\n\n9. 函数名: ksmbd_override_fsids\n- 参数: [work]\n- 调用者: smb2_open\n- 被调用者: []\n\n10. 函数名: ksmbd_vfs_kern_path\n- 参数: [work, name, LOOKUP_NO_SYMLINKS, &path, 1]\n- 调用者: smb2_open\n- 被调用者: []\n\n11. 函数名: ksmbd_vfs_query_maximal_access\n- 参数: [user_ns, path.dentry, &daccess]\n- 调用者: smb2_open\n- 被调用者: []\n\n12. 函数名: smb2_creat\n- 参数: [work, &path, name, open_flags, posix_mode, req->CreateOptions & FILE_DIRECTORY_FILE_LE]\n- 调用者: smb2_open\n- 被调用者: []\n\n13. 函数名: smb2_set_ea\n- 参数: [&ea_buf->ea, le32_to_cpu(ea_buf->ccontext.DataLength), &path]\n- 调用者: smb2_open\n- 被调用者: []\n\n14. 函数名: ksmbd_vfs_inherit_posix_acl\n- 参数: [user_ns, inode, d_inode(path.dentry->d_parent)]\n- 调用者: smb2_open\n- 被调用者: []\n\n15. 函数名: smb_inherit_dacl\n- 参数: [conn, &path, sess->user->uid, sess->user->gid]\n- 调用者: smb2_open\n- 被调用者: []\n\n16. 函数名: smb2_create_sd_buffer\n- 参数: [work, req, &path]\n- 调用者: smb2_open\n- 被调用者: []\n\n17. 函数名: ksmbd_vfs_set_init_posix_acl\n- 参数: [user_ns, inode]\n- 调用者: smb2_open\n- 被调用者: []\n\n18. 函数名: ksmbd_acls_fattr\n- 参数: [&fattr, user_ns, inode]\n- 调用者: smb2_open\n- 被调用者: []\n\n19. 函数名: build_sec_desc\n- 参数: [user_ns, pntsd, NULL, OWNER_SECINFO | GROUP_SECINFO | DACL_SECINFO, &pntsd_size, &fattr]\n- 调用者: smb2_open\n- 被调用者: []\n\n20. 函数名: ksmbd_vfs_set_sd_xattr\n- 参数: [conn, user_ns, path.dentry, pntsd, pntsd_size]\n- 调用者: smb2_open\n- 被调用者: []\n\n21. 函数名: smb2_set_stream_name_xattr\n- 参数: [&path, fp, stream_name, s_type]\n- 调用者: smb2_open\n- 被调用者: []\n\n22. 函数名: smb_break_all_oplock\n- 参数: [work, fp]\n- 调用者: smb2_open\n- 被调用者: []\n\n23. 函数名: smb_grant_oplock\n- 参数: [work, req_op_level, fp->persistent_id, fp, le32_to_cpu(req->hdr.Id.SyncId.TreeId), lc, share_ret]\n- 调用者: smb2_open\n- 被调用者: []\n\n24. 函数名: ksmbd_fd_set_delete_on_close\n- 参数: [fp, file_info]\n- 调用者: smb2_open\n- 被调用者: []\n\n25. 函数名: smb2_create_truncate\n- 参数: [&path]\n- 调用者: smb2_open\n- 被调用者: []\n\n26. 函数名: smb_break_all_levII_oplock\n- 参数: [work, fp, 1]\n- 调用者: smb2_open\n- 被调用者: []\n\n27. 函数名: smb2_update_xattrs\n- 参数: [tcon, &path, fp]\n- 调用者: smb2_open\n- 被调用者: []\n\n28. 函数名: smb2_new_xattrs\n- 参数: [tcon, &path, fp]\n- 调用者: smb2_open\n- 被调用者: []\n\n29. 函数名: create_lease_buf\n- 参数: [rsp->Buffer, opinfo->o_lease]\n- 调用者: smb2_open\n- 被调用者: []\n\n30. 函数名: create_mxac_rsp_buf\n- 参数: [rsp->Buffer + le32_to_cpu(rsp->CreateContextsLength), le32_to_cpu(maximal_access)]\n- 调用者: smb2_open\n- 被调用者: []\n\n31. 函数名: create_disk_id_rsp_buf\n- 参数: [rsp->Buffer + le32_to_cpu(rsp->CreateContextsLength), stat.ino, tcon->id]\n- 调用者: smb2_open\n- 被调用者: []\n\n32. 函数名: create_posix_rsp_buf\n- 参数: [rsp->Buffer + le32_to_cpu(rsp->CreateContextsLength), fp]\n- 调用者: smb2_open\n- 被调用者: []\n\n33. 函数名: find_same_lease_key\n- 参数: [sess, fp->f_ci, lc]\n- 调用者: smb2_open\n- 被调用者: []\n\n34. 函数名: ksmbd_inode_pending_delete\n- 参数: [fp]\n- 调用者: smb2_open\n- 被调用者: []\n\n35. 函数名: ksmbd_smb_check_shared_mode\n- 参数: [fp->filp, fp]\n- 调用者: smb2_open\n- 被调用者: []\n\n36. 函数名: smb_map_generic_desired_access\n- 参数: [req->DesiredAccess]\n- 调用者: smb2_open\n- 被调用者: []\n\n37. 函数名: smb_check_perm_dacl\n- 参数: [conn, &path, &daccess, sess->user->uid]\n- 调用者: smb2_open\n- 被调用者: []\n\n38. 函数名: smb2_create_open_flags\n- 参数: [file_present, daccess, req->CreateDisposition, &may_flags]\n- 调用者: smb2_open\n- 被调用者: []\n\n39. 函数名: ksmbd_vfs_set_fadvise\n- 参数: [filp, req->CreateOptions]\n- 调用者: smb2_open\n- 被调用者: []\n\n40. 函数名: ksmbd_open_fd\n- 参数: [work, filp]\n- 调用者: smb2_open\n- 被调用者: []\n\n41. 函数名: ksmbd_open_durable_fd\n- 参数: [fp]\n- 调用者: smb2_open\n- 被调用者: []\n\n42. 函数名: has_file_id\n- 参数: [fp->persistent_id]\n- 调用者: smb2_open\n- 被调用者: []\n\n43. 函数名: ksmbd_UnixTimeToNT\n- 参数: [stat.btime], [stat.ctime], [stat.atime], [stat.mtime], [stat.ctime]\n- 调用者: smb2_open\n- 被调用者: []\n\n44. 函数名: smb2_get_dos_mode\n- 参数: [&stat, le32_to_cpu(req->FileAttributes)]\n- 调用者: smb2_open\n- 被调用者: []\n\n45. 函数名: path_put\n- 参数: [&path]\n- 调用者: smb2_open\n- 被调用者: []\n\n46. 函数名: ksmbd_revert_fsids\n- 参数: [work]\n- 调用者: smb2_open\n- 被调用者: []\n\n47. 函数名: ksmbd_fd_put\n- 参数: [work, fp]\n- 调用者: smb2_open\n- 被调用者: []\n\n48. 函数名: smb2_set_err_rsp\n- 参数: [work]\n- 调用者: smb2_open\n- 被调用者: []"
    },
    {
        "id": 3772,
        "cwe": "CWE-787",
        "cve": "CVE-2022-47942",
        "purpose": "Code purpose:\"\"\"计算SMB2协议中输出缓冲区的最大可用长度，确保不超过连接的最大传输大小和响应缓冲区剩余空间\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2协议信息时，由于对输入参数out_buf_len和计算得到的free_len缺乏充分验证，导致可能发生堆缓冲区溢出。\"\"\"",
        "functions": "Functions:\n1. 函数名: smb2_calc_max_out_buf_len\n- 参数: [work, hdr2_len, out_buf_len]\n- 调用者: 未明确（需查看完整代码）\n- 被调用者: [get_rfc1002_len, min_t]\n\n2. 函数名: get_rfc1002_len\n- 参数: [work->response_buf]\n- 调用者: smb2_calc_max_out_buf_len\n- 被调用者: 未明确（需查看完整代码）\n\n3. 函数名: min_t\n- 参数: [int, out_buf_len, free_len]\n- 调用者: smb2_calc_max_out_buf_len\n- 被调用者: 未明确（需查看完整代码）"
    },
    {
        "id": 3773,
        "cwe": "CWE-787",
        "cve": "CVE-2022-47942",
        "purpose": "Code purpose:\"\"\"处理SMB2协议中的安全信息查询请求，构建并返回安全描述符信息\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_QUERY_INFO_HE请求时，由于缺乏对输入数据的充分验证，导致在构建安全描述符时可能发生堆缓冲区溢出。\"\"\"",
        "functions": "Functions:\n1. 函数名: smb2_get_info_sec\n- 参数: [work, req, rsp]\n- 调用者: 未显示（由外部调用）\n- 被调用者: [le32_to_cpu, ksmbd_debug, cpu_to_le16, has_file_id, ksmbd_lookup_fd_slow, file_mnt_user_ns, file_inode, ksmbd_acls_fattr, test_share_config_flag, ksmbd_vfs_get_sd_xattr, build_sec_desc, posix_acl_release, kfree, ksmbd_fd_put, cpu_to_le32, inc_rfc1001_len]\n\n2. 函数名: le32_to_cpu\n- 参数: [req->AdditionalInformation]\n- 调用者: smb2_get_info_sec\n- 被调用者: []\n\n3. 函数名: ksmbd_debug\n- 参数: [SMB, \"Unsupported addition info: 0x%x)\\n\", addition_info]\n- 调用者: smb2_get_info_sec\n- 被调用者: []\n\n4. 函数名: cpu_to_le16\n- 参数: [1], [SELF_RELATIVE | DACL_PROTECTED]\n- 调用者: smb2_get_info_sec\n- 被调用者: []\n\n5. 函数名: has_file_id\n- 参数: [req->VolatileFileId], [id]\n- 调用者: smb2_get_info_sec\n- 被调用者: []\n\n6. 函数名: ksmbd_lookup_fd_slow\n- 参数: [work, id, pid]\n- 调用者: smb2_get_info_sec\n- 被调用者: []\n\n7. 函数名: file_mnt_user_ns\n- 参数: [fp->filp]\n- 调用者: smb2_get_info_sec\n- 被调用者: []\n\n8. 函数名: file_inode\n- 参数: [fp->filp]\n- 调用者: smb2_get_info_sec\n- 被调用者: []\n\n9. 函数名: ksmbd_acls_fattr\n- 参数: [&fattr, user_ns, inode]\n- 调用者: smb2_get_info_sec\n- 被调用者: []\n\n10. 函数名: test_share_config_flag\n- 参数: [work->tcon->share_conf, KSMBD_SHARE_FLAG_ACL_XATTR]\n- 调用者: smb2_get_info_sec\n- 被调用者: []\n\n11. 函数名: ksmbd_vfs_get_sd_xattr\n- 参数: [work->conn, user_ns, fp->filp->f_path.dentry, &ppntsd]\n- 调用者: smb2_get_info_sec\n- 被调用者: []\n\n12. 函数名: build_sec_desc\n- 参数: [user_ns, pntsd, ppntsd, addition_info, &secdesclen, &fattr]\n- 调用者: smb2_get_info_sec\n- 被调用者: []\n\n13. 函数名: posix_acl_release\n- 参数: [fattr.cf_acls], [fattr.cf_dacls]\n- 调用者: smb2_get_info_sec\n- 被调用者: []\n\n14. 函数名: kfree\n- 参数: [ppntsd]\n- 调用者: smb2_get_info_sec\n- 被调用者: []\n\n15. 函数名: ksmbd_fd_put\n- 参数: [work, fp]\n- 调用者: smb2_get_info_sec\n- 被调用者: []\n\n16. 函数名: cpu_to_le32\n- 参数: [secdesclen]\n- 调用者: smb2_get_info_sec\n- 被调用者: []\n\n17. 函数名: inc_rfc1001_len\n- 参数: [work->response_buf, secdesclen]\n- 调用者: smb2_get_info_sec\n- 被调用者: []"
    },
    {
        "id": 3774,
        "cwe": "CWE-787",
        "cve": "CVE-2022-47942",
        "purpose": "Code purpose:\"\"\"该代码实现了SMB协议中继承父目录ACL权限到子目录或文件的功能，处理安全描述符和访问控制列表的继承逻辑。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_SET_INFO_HE命令时，由于缺乏对输入数据的有效边界检查，导致在set_ntacl_dacl函数中发生堆缓冲区溢出。\"\"\"",
        "functions": "Functions:\n1. 函数名: smb_inherit_dacl\n- 参数: [conn, path, uid, gid]\n- 调用者: N/A (top-level function)\n- 被调用者: [ksmbd_vfs_get_sd_xattr, compare_sids, id_to_sid, smb_set_ace, kzalloc, memcpy, ksmbd_vfs_set_sd_xattr, kfree, le32_to_cpu, le16_to_cpu, cpu_to_le16, S_ISDIR, d_inode, mnt_user_ns]\n\n2. 函数名: ksmbd_vfs_get_sd_xattr\n- 参数: [conn, user_ns, parent, parent_pntsd]\n- 调用者: smb_inherit_dacl\n- 被调用者: N/A\n\n3. 函数名: compare_sids\n- 参数: [creator_owner, parent_aces->sid], [creator_group, parent_aces->sid]\n- 调用者: smb_inherit_dacl\n- 被调用者: N/A\n\n4. 函数名: id_to_sid\n- 参数: [uid, SIDOWNER, owner_sid], [gid, SIDUNIX_GROUP, group_sid]\n- 调用者: smb_inherit_dacl\n- 被调用者: N/A\n\n5. 函数名: smb_set_ace\n- 参数: [aces, psid, parent_aces->type, inherited_flags, parent_aces->access_req], [aces, psid, parent_aces->type, flags | inherited_flags, parent_aces->access_req]\n- 调用者: smb_inherit_dacl\n- 被调用者: N/A\n\n6. 函数名: kzalloc\n- 参数: [sizeof(struct smb_ntsd) + powner_sid_size + pgroup_sid_size + sizeof(struct smb_acl) + nt_size, GFP_KERNEL]\n- 调用者: smb_inherit_dacl\n- 被调用者: N/A\n\n7. 函数名: memcpy\n- 参数: [owner_sid, powner_sid, powner_sid_size], [group_sid, pgroup_sid, pgroup_sid_size], [pace, aces_base, nt_size]\n- 调用者: smb_inherit_dacl\n- 被调用者: N/A\n\n8. 函数名: ksmbd_vfs_set_sd_xattr\n- 参数: [conn, user_ns, path->dentry, pntsd, pntsd_size]\n- 调用者: smb_inherit_dacl\n- 被调用者: N/A\n\n9. 函数名: kfree\n- 参数: [aces_base], [parent_pntsd], [pntsd]\n- 调用者: smb_inherit_dacl\n- 被调用者: N/A\n\n10. 函数名: le32_to_cpu\n- 参数: [parent_pntsd->dacloffset], [parent_pntsd->osidoffset], [parent_pntsd->gsidoffset], [parent_pntsd->dacloffset], [pntsd->osidoffset], [pntsd->gsidoffset], [pntsd->dacloffset]\n- 调用者: smb_inherit_dacl\n- 被调用者: N/A\n\n11. 函数名: le16_to_cpu\n- 参数: [parent_pntsd->type], [aces->size], [parent_aces->size], [parent_pntsd->type]\n- 调用者: smb_inherit_dacl\n- 被调用者: N/A\n\n12. 函数名: cpu_to_le16\n- 参数: [1], [SELF_RELATIVE | DACL_PRESENT], [DACL_AUTO_INHERITED], [2], [sizeof(struct smb_acl) + nt_size], [ace_cnt]\n- 调用者: smb_inherit_dacl\n- 被调用者: N/A\n\n13. 函数名: S_ISDIR\n- 参数: [d_inode(path->dentry)->i_mode]\n- 调用者: smb_inherit_dacl\n- 被调用者: N/A\n\n14. 函数名: d_inode\n- 参数: [path->dentry]\n- 调用者: smb_inherit_dacl\n- 被调用者: N/A\n\n15. 函数名: mnt_user_ns\n- 参数: [path->mnt]\n- 调用者: smb_inherit_dacl\n- 被调用者: N/A"
    },
    {
        "id": 3775,
        "cwe": "CWE-787",
        "cve": "CVE-2022-47942",
        "purpose": "Code purpose:\"\"\"该代码用于检查SMB连接中客户端对文件路径的访问权限，通过解析Windows ACL（访问控制列表）来确定是否授予请求的访问权限。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_QUERY_INFO_HE请求时，由于对输入的ACL数据结构缺乏充分边界检查，导致堆缓冲区溢出漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: smb_check_perm_dacl\n- 参数: [struct ksmbd_conn *conn, struct path *path, __le32 *pdaccess, int uid]\n- 调用者: N/A (top-level function)\n- 被调用者: [mnt_user_ns, le32_to_cpu, ksmbd_debug, ksmbd_vfs_get_sd_xattr, kfree, id_to_sid, compare_sids, get_acl, posix_acl_uid_translate, posix_acl_gid_translate, mode_to_access_flags, posix_acl_release, cpu_to_le32]\n\n2. 函数名: mnt_user_ns\n- 参数: [struct vfsmount *mnt]\n- 调用者: smb_check_perm_dacl\n- 被调用者: []\n\n3. 函数名: le32_to_cpu\n- 参数: [__le32]\n- 调用者: smb_check_perm_dacl\n- 被调用者: []\n\n4. 函数名: ksmbd_debug\n- 参数: [int level, const char *fmt, ...]\n- 调用者: smb_check_perm_dacl\n- 被调用者: []\n\n5. 函数名: ksmbd_vfs_get_sd_xattr\n- 参数: [struct ksmbd_conn *conn, struct user_namespace *user_ns, struct dentry *dentry, struct smb_ntsd **pntsd]\n- 调用者: smb_check_perm_dacl\n- 被调用者: []\n\n6. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: smb_check_perm_dacl\n- 被调用者: []\n\n7. 函数名: id_to_sid\n- 参数: [int id, unsigned int sid_type, struct smb_sid *sid]\n- 调用者: smb_check_perm_dacl\n- 被调用者: []\n\n8. 函数名: compare_sids\n- 参数: [struct smb_sid *sid1, struct smb_sid *sid2]\n- 调用者: smb_check_perm_dacl\n- 被调用者: []\n\n9. 函数名: get_acl\n- 参数: [struct inode *inode, int type]\n- 调用者: smb_check_perm_dacl\n- 被调用者: []\n\n10. 函数名: posix_acl_uid_translate\n- 参数: [struct user_namespace *user_ns, struct posix_acl_entry *pa_entry]\n- 调用者: smb_check_perm_dacl\n- 被调用者: []\n\n11. 函数名: posix_acl_gid_translate\n- 参数: [struct user_namespace *user_ns, struct posix_acl_entry *pa_entry]\n- 调用者: smb_check_perm_dacl\n- 被调用者: []\n\n12. 函数名: mode_to_access_flags\n- 参数: [mode_t perm, mode_t mask, unsigned int *access_flags]\n- 调用者: smb_check_perm_dacl\n- 被调用者: []\n\n13. 函数名: posix_acl_release\n- 参数: [struct posix_acl *acl]\n- 调用者: smb_check_perm_dacl\n- 被调用者: []\n\n14. 函数名: cpu_to_le32\n- 参数: [__u32]\n- 调用者: smb_check_perm_dacl\n- 被调用者: []\n\n15. 函数名: le16_to_cpu\n- 参数: [__le16]\n- 调用者: smb_check_perm_dacl\n- 被调用者: []"
    },
    {
        "id": 3776,
        "cwe": "CWE-787",
        "cve": "CVE-2022-47942",
        "purpose": "Code purpose:\"\"\"该代码用于从文件系统中获取并解码安全描述符(SD)扩展属性，验证其哈希值，并调整安全描述符中的偏移量。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理SMB2_SET_INFO_HE命令时，由于缺乏对输入数据的充分验证，导致在set_ntacl_dacl函数中发生堆缓冲区溢出。\"\"\"",
        "functions": "Functions:\n1. 函数名: ksmbd_vfs_get_sd_xattr\n- 参数: [struct ksmbd_conn *conn, struct user_namespace *user_ns, struct dentry *dentry, struct smb_ntsd **pntsd]\n- 调用者: 未显示\n- 被调用者: [ksmbd_vfs_getxattr, ndr_decode_v4_ntacl, ksmbd_vfs_make_xattr_posix_acl, ndr_encode_posix_acl, ksmbd_gen_sd_hash, memcmp, cpu_to_le32, le32_to_cpu, kfree, pr_err]\n\n2. 函数名: ksmbd_vfs_getxattr\n- 参数: [struct user_namespace *user_ns, struct dentry *dentry, XATTR_NAME_SD, &n.data]\n- 调用者: ksmbd_vfs_get_sd_xattr\n- 被调用者: 未显示\n\n3. 函数名: ndr_decode_v4_ntacl\n- 参数: [&n, &acl]\n- 调用者: ksmbd_vfs_get_sd_xattr\n- 被调用者: 未显示\n\n4. 函数名: ksmbd_vfs_make_xattr_posix_acl\n- 参数: [struct user_namespace *user_ns, struct inode *inode, ACL_TYPE_ACCESS/ACL_TYPE_DEFAULT]\n- 调用者: ksmbd_vfs_get_sd_xattr\n- 被调用者: 未显示\n\n5. 函数名: ndr_encode_posix_acl\n- 参数: [&acl_ndr, user_ns, inode, smb_acl, def_smb_acl]\n- 调用者: ksmbd_vfs_get_sd_xattr\n- 被调用者: 未显示\n\n6. 函数名: ksmbd_gen_sd_hash\n- 参数: [conn, acl_ndr.data, acl_ndr.offset, cmp_hash]\n- 调用者: ksmbd_vfs_get_sd_xattr\n- 被调用者: 未显示\n\n7. 函数名: memcmp\n- 参数: [cmp_hash, acl.posix_acl_hash, XATTR_SD_HASH_SIZE]\n- 调用者: ksmbd_vfs_get_sd_xattr\n- 被调用者: 未显示\n\n8. 函数名: cpu_to_le32\n- 参数: [le32_to_cpu((*pntsd)->osidoffset) - NDR_NTSD_OFFSETOF]\n- 调用者: ksmbd_vfs_get_sd_xattr\n- 被调用者: 未显示\n\n9. 函数名: le32_to_cpu\n- 参数: [(*pntsd)->osidoffset]\n- 调用者: ksmbd_vfs_get_sd_xattr\n- 被调用者: 未显示\n\n10. 函数名: kfree\n- 参数: [acl_ndr.data/smb_acl/def_smb_acl/acl.sd_buf/n.data]\n- 调用者: ksmbd_vfs_get_sd_xattr\n- 被调用者: 未显示\n\n11. 函数名: pr_err\n- 参数: [\"failed to encode ndr to posix acl\"/\"failed to generate hash for ndr acl\"/\"hash value diff\"]\n- 调用者: ksmbd_vfs_get_sd_xattr\n- 被调用者: 未显示"
    },
    {
        "id": 3789,
        "cwe": "CWE-787",
        "cve": "CVE-2022-48423",
        "purpose": "Code purpose:\"\"\"该代码用于枚举和验证NTFS文件系统中的文件记录属性，确保属性的合法性和边界安全性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"代码未对resident属性的名称进行验证，可能导致越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: mi_enum_attr\n- 参数: [mi, attr]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [le32_to_cpu, le16_to_cpu, IS_ALIGNED, is_rec_inuse, Add2Ptr, PtrOffset, static_assert, is_attr_ext]\n\n2. 函数名: le32_to_cpu\n- 参数: [value]\n- 调用者: mi_enum_attr\n- 被调用者: []\n\n3. 函数名: le16_to_cpu\n- 参数: [value]\n- 调用者: mi_enum_attr\n- 被调用者: []\n\n4. 函数名: IS_ALIGNED\n- 参数: [value, alignment]\n- 调用者: mi_enum_attr\n- 被调用者: []\n\n5. 函数名: is_rec_inuse\n- 参数: [rec]\n- 调用者: mi_enum_attr\n- 被调用者: []\n\n6. 函数名: Add2Ptr\n- 参数: [ptr, offset]\n- 调用者: mi_enum_attr\n- 被调用者: []\n\n7. 函数名: PtrOffset\n- 参数: [ptr1, ptr2]\n- 调用者: mi_enum_attr\n- 被调用者: []\n\n8. 函数名: static_assert\n- 参数: [condition, message]\n- 调用者: mi_enum_attr\n- 被调用者: []\n\n9. 函数名: is_attr_ext\n- 参数: [attr]\n- 调用者: mi_enum_attr\n- 被调用者: []"
    },
    {
        "id": 3814,
        "cwe": "CWE-787",
        "cve": "CVE-2023-0210",
        "purpose": "Code purpose:\"\"\"该代码用于解码和处理NTLMSSP认证blob数据，实现NTLMv2认证流程，包括验证签名、提取域信息、处理挑战响应以及可能的会话密钥交换。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理NTLMSSP认证时，未充分验证输入数据的偏移量和长度，导致可能发生越界访问，引发系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: ksmbd_decode_ntlmssp_auth_blob\n- 参数: [authblob, blob_len, conn, sess]\n- 调用者: 未显示\n- 被调用者: [memcmp, le32_to_cpu, le16_to_cpu, smb_strndup_from_utf16, ksmbd_debug, ksmbd_auth_ntlmv2, kfree, kmalloc, cifs_arc4_setkey, cifs_arc4_crypt, kfree_sensitive]\n\n2. 函数名: memcmp\n- 参数: [authblob->Signature, \"NTLMSSP\", 8]\n- 调用者: ksmbd_decode_ntlmssp_auth_blob\n- 被调用者: 无\n\n3. 函数名: le32_to_cpu\n- 参数: [authblob->NtChallengeResponse.BufferOffset]\n- 调用者: ksmbd_decode_ntlmssp_auth_blob\n- 被调用者: 无\n\n4. 函数名: le16_to_cpu\n- 参数: [authblob->NtChallengeResponse.Length]\n- 调用者: ksmbd_decode_ntlmssp_auth_blob\n- 被调用者: 无\n\n5. 函数名: smb_strndup_from_utf16\n- 参数: [(const char *)authblob + dn_off, dn_len, true, conn->local_nls]\n- 调用者: ksmbd_decode_ntlmssp_auth_blob\n- 被调用者: 无\n\n6. 函数名: ksmbd_debug\n- 参数: [AUTH, \"negotiate blob len %d too small\\n\", blob_len]\n- 调用者: ksmbd_decode_ntlmssp_auth_blob\n- 被调用者: 无\n\n7. 函数名: ksmbd_auth_ntlmv2\n- 参数: [conn, sess, (struct ntlmv2_resp *)((char *)authblob + nt_off), nt_len - CIFS_ENCPWD_SIZE, domain_name, conn->ntlmssp.cryptkey]\n- 调用者: ksmbd_decode_ntlmssp_auth_blob\n- 被调用者: 无\n\n8. 函数名: kfree\n- 参数: [domain_name]\n- 调用者: ksmbd_decode_ntlmssp_auth_blob\n- 被调用者: 无\n\n9. 函数名: kmalloc\n- 参数: [sizeof(*ctx_arc4), GFP_KERNEL]\n- 调用者: ksmbd_decode_ntlmssp_auth_blob\n- 被调用者: 无\n\n10. 函数名: cifs_arc4_setkey\n- 参数: [ctx_arc4, sess->sess_key, SMB2_NTLMV2_SESSKEY_SIZE]\n- 调用者: ksmbd_decode_ntlmssp_auth_blob\n- 被调用者: 无\n\n11. 函数名: cifs_arc4_crypt\n- 参数: [ctx_arc4, sess->sess_key, (char *)authblob + sess_key_off, sess_key_len]\n- 调用者: ksmbd_decode_ntlmssp_auth_blob\n- 被调用者: 无\n\n12. 函数名: kfree_sensitive\n- 参数: [ctx_arc4]\n- 调用者: ksmbd_decode_ntlmssp_auth_blob\n- 被调用者: 无"
    },
    {
        "id": 3840,
        "cwe": "CWE-787",
        "cve": "CVE-2023-1073",
        "purpose": "Code purpose:\"\"\"验证HID报告的值是否合法，确保报告类型、ID、字段索引和报告计数的有效性\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在验证HID报告值时未充分检查字段索引和报告计数的边界条件，导致可能的内存越界访问\"\"\"",
        "functions": "Functions:\n1. 函数名: hid_validate_values\n- 参数: [struct hid_device *hid, enum hid_report_type type, unsigned int id, unsigned int field_index, unsigned int report_counts]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [list_entry, hid_err]\n\n2. 函数名: hid_err\n- 参数: [struct hid_device *hid, const char *fmt, ...]\n- 调用者: hid_validate_values\n- 被调用者: 未明确（可能是内核打印函数）\n\n3. 函数名: list_entry\n- 参数: [ptr, type, member]\n- 调用者: hid_validate_values\n- 被调用者: 未明确（内核链表宏）"
    },
    {
        "id": 3915,
        "cwe": "CWE-787",
        "cve": "CVE-2023-2124",
        "purpose": "Code purpose:\"\"\"该代码用于在XFS文件系统日志恢复过程中处理缓冲区提交，包括验证缓冲区状态、恢复缓冲区内容以及管理缓冲区的写入操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理XFS日志恢复时，代码未能正确验证缓冲区长度，导致可能发生越界内存访问。\"\"\"",
        "functions": "Functions:\n1. 函数名: xlog_recover_buf_commit_pass2\n- 参数: [log, buffer_list, item, current_lsn]\n- 调用者: N/A (top-level function)\n- 被调用者: [xlog_put_buffer_cancelled, xlog_is_buffer_cancelled, trace_xfs_log_recover_buf_recover, xfs_buf_read, xlog_recover_get_buf_lsn, trace_xfs_log_recover_buf_skip, xlog_recover_validate_buf_type, xlog_recover_do_inode_buffer, xlog_recover_do_dquot_buffer, xlog_recover_do_reg_buffer, xfs_buf_stale, xfs_bwrite, xfs_buf_delwri_queue, xfs_buf_relse, trace_xfs_log_recover_buf_cancel]\n\n2. 函数名: xlog_put_buffer_cancelled\n- 参数: [log, blf_blkno, blf_len]\n- 调用者: xlog_recover_buf_commit_pass2\n- 被调用者: []\n\n3. 函数名: xlog_is_buffer_cancelled\n- 参数: [log, blf_blkno, blf_len]\n- 调用者: xlog_recover_buf_commit_pass2\n- 被调用者: []\n\n4. 函数名: trace_xfs_log_recover_buf_recover\n- 参数: [log, buf_f]\n- 调用者: xlog_recover_buf_commit_pass2\n- 被调用者: []\n\n5. 函数名: xfs_buf_read\n- 参数: [mp->m_ddev_targp, buf_f->blf_blkno, buf_f->blf_len, buf_flags, &bp, NULL]\n- 调用者: xlog_recover_buf_commit_pass2\n- 被调用者: []\n\n6. 函数名: xlog_recover_get_buf_lsn\n- 参数: [mp, bp, buf_f]\n- 调用者: xlog_recover_buf_commit_pass2\n- 被调用者: []\n\n7. 函数名: trace_xfs_log_recover_buf_skip\n- 参数: [log, buf_f]\n- 调用者: xlog_recover_buf_commit_pass2\n- 被调用者: []\n\n8. 函数名: xlog_recover_validate_buf_type\n- 参数: [mp, bp, buf_f, NULLCOMMITLSN]\n- 调用者: xlog_recover_buf_commit_pass2\n- 被调用者: []\n\n9. 函数名: xlog_recover_do_inode_buffer\n- 参数: [mp, item, bp, buf_f]\n- 调用者: xlog_recover_buf_commit_pass2\n- 被调用者: []\n\n10. 函数名: xlog_recover_do_dquot_buffer\n- 参数: [mp, log, item, bp, buf_f]\n- 调用者: xlog_recover_buf_commit_pass2\n- 被调用者: []\n\n11. 函数名: xlog_recover_do_reg_buffer\n- 参数: [mp, item, bp, buf_f, current_lsn]\n- 调用者: xlog_recover_buf_commit_pass2\n- 被调用者: []\n\n12. 函数名: xfs_buf_stale\n- 参数: [bp]\n- 调用者: xlog_recover_buf_commit_pass2\n- 被调用者: []\n\n13. 函数名: xfs_bwrite\n- 参数: [bp]\n- 调用者: xlog_recover_buf_commit_pass2\n- 被调用者: []\n\n14. 函数名: xfs_buf_delwri_queue\n- 参数: [bp, buffer_list]\n- 调用者: xlog_recover_buf_commit_pass2\n- 被调用者: []\n\n15. 函数名: xfs_buf_relse\n- 参数: [bp]\n- 调用者: xlog_recover_buf_commit_pass2\n- 被调用者: []\n\n16. 函数名: trace_xfs_log_recover_buf_cancel\n- 参数: [log, buf_f]\n- 调用者: xlog_recover_buf_commit_pass2\n- 被调用者: []"
    },
    {
        "id": 3916,
        "cwe": "CWE-787",
        "cve": "CVE-2023-21255",
        "purpose": "Code purpose:\"\"\"释放binder缓冲区并处理相关事务，确保内存正确释放和状态更新\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在释放内存缓冲区后仍可能被访问，导致释放后使用(UAF)的内存损坏漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_free_buf\n- 参数: [proc, thread, buffer, is_failure]\n- 调用者: 未显示\n- 被调用者: [binder_inner_proc_lock, binder_inner_proc_unlock, binder_node_inner_lock, binder_dequeue_work_head_ilocked, binder_enqueue_work_ilocked, binder_wakeup_proc_ilocked, binder_node_inner_unlock, trace_binder_transaction_buffer_release, binder_transaction_buffer_release, binder_alloc_free_buf]\n\n2. 函数名: binder_inner_proc_lock\n- 参数: [proc]\n- 调用者: binder_free_buf\n- 被调用者: 未显示\n\n3. 函数名: binder_inner_proc_unlock\n- 参数: [proc]\n- 调用者: binder_free_buf\n- 被调用者: 未显示\n\n4. 函数名: binder_node_inner_lock\n- 参数: [buf_node]\n- 调用者: binder_free_buf\n- 被调用者: 未显示\n\n5. 函数名: binder_dequeue_work_head_ilocked\n- 参数: [&buf_node->async_todo]\n- 调用者: binder_free_buf\n- 被调用者: 未显示\n\n6. 函数名: binder_enqueue_work_ilocked\n- 参数: [w, &proc->todo]\n- 调用者: binder_free_buf\n- 被调用者: 未显示\n\n7. 函数名: binder_wakeup_proc_ilocked\n- 参数: [proc]\n- 调用者: binder_free_buf\n- 被调用者: 未显示\n\n8. 函数名: binder_node_inner_unlock\n- 参数: [buf_node]\n- 调用者: binder_free_buf\n- 被调用者: 未显示\n\n9. 函数名: trace_binder_transaction_buffer_release\n- 参数: [buffer]\n- 调用者: binder_free_buf\n- 被调用者: 未显示\n\n10. 函数名: binder_transaction_buffer_release\n- 参数: [proc, thread, buffer, 0, is_failure]\n- 调用者: binder_free_buf\n- 被调用者: 未显示\n\n11. 函数名: binder_alloc_free_buf\n- 参数: [&proc->alloc, buffer]\n- 调用者: binder_free_buf\n- 被调用者: 未显示"
    },
    {
        "id": 3917,
        "cwe": "CWE-787",
        "cve": "CVE-2023-21255",
        "purpose": "Code purpose:\"\"\"处理Binder进程间通信事务，包括事务的排队、线程唤醒和内存管理\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在释放过时的交易对象(t_outdated)后未正确处理相关内存引用，导致存在释放后使用(use-after-free)的内存破坏漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: binder_proc_transaction\n- 参数: [struct binder_transaction *t, struct binder_proc *proc, struct binder_thread *thread]\n- 调用者: N/A\n- 被调用者: [binder_node_lock, binder_inner_proc_lock, binder_inner_proc_unlock, binder_node_unlock, binder_select_thread_ilocked, binder_enqueue_thread_work_ilocked, binder_enqueue_work_ilocked, binder_find_outdated_transaction_ilocked, binder_wakeup_thread_ilocked, binder_transaction_buffer_release, binder_alloc_free_buf, kfree, binder_stats_deleted]\n\n2. 函数名: binder_node_lock\n- 参数: [struct binder_node *node]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n3. 函数名: binder_inner_proc_lock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n4. 函数名: binder_inner_proc_unlock\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n5. 函数名: binder_node_unlock\n- 参数: [struct binder_node *node]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n6. 函数名: binder_select_thread_ilocked\n- 参数: [struct binder_proc *proc]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n7. 函数名: binder_enqueue_thread_work_ilocked\n- 参数: [struct binder_thread *thread, struct binder_work *work]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n8. 函数名: binder_enqueue_work_ilocked\n- 参数: [struct binder_work *work, struct list_head *target_list]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n9. 函数名: binder_find_outdated_transaction_ilocked\n- 参数: [struct binder_transaction *t, struct list_head *list]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n10. 函数名: binder_wakeup_thread_ilocked\n- 参数: [struct binder_proc *proc, struct binder_thread *thread, bool sync]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n11. 函数名: binder_transaction_buffer_release\n- 参数: [struct binder_proc *proc, struct binder_thread *thread, struct binder_buffer *buffer, int debug_id, int last]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n12. 函数名: binder_alloc_free_buf\n- 参数: [struct binder_alloc *alloc, struct binder_buffer *buffer]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n13. 函数名: kfree\n- 参数: [const void *objp]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A\n\n14. 函数名: binder_stats_deleted\n- 参数: [enum binder_stat_types type]\n- 调用者: binder_proc_transaction\n- 被调用者: N/A"
    },
    {
        "id": 3934,
        "cwe": "CWE-787",
        "cve": "CVE-2023-2194",
        "purpose": "Code purpose:\"\"\"该代码实现了SLIMpro I2C设备驱动中的块写入功能，将用户空间数据通过DMA映射后发送到I2C设备。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"用户空间提供的writelen参数未被正确限制范围，导致memcpy操作可能超出dma_buffer边界，造成越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: slimpro_i2c_blkwr\n- 参数: [struct slimpro_i2c_dev *ctx, u32 chip, u32 addr, u32 addrlen, u32 protocol, u32 writelen, void *data]\n- 调用者: 未指定\n- 被调用者: [memcpy, dma_map_single, dma_mapping_error, dev_err, reinit_completion, slimpro_i2c_send_msg, dma_unmap_single]\n\n2. 函数名: memcpy\n- 参数: [ctx->dma_buffer, data, writelen]\n- 调用者: slimpro_i2c_blkwr\n- 被调用者: []\n\n3. 函数名: dma_map_single\n- 参数: [ctx->dev, ctx->dma_buffer, writelen, DMA_TO_DEVICE]\n- 调用者: slimpro_i2c_blkwr\n- 被调用者: []\n\n4. 函数名: dma_mapping_error\n- 参数: [ctx->dev, paddr]\n- 调用者: slimpro_i2c_blkwr\n- 被调用者: []\n\n5. 函数名: dev_err\n- 参数: [&ctx->adapter.dev, \"Error in mapping dma buffer %p\\n\", ctx->dma_buffer]\n- 调用者: slimpro_i2c_blkwr\n- 被调用者: []\n\n6. 函数名: reinit_completion\n- 参数: [&ctx->rd_complete]\n- 调用者: slimpro_i2c_blkwr\n- 被调用者: []\n\n7. 函数名: slimpro_i2c_send_msg\n- 参数: [ctx, msg, msg]\n- 调用者: slimpro_i2c_blkwr\n- 被调用者: []\n\n8. 函数名: dma_unmap_single\n- 参数: [ctx->dev, paddr, writelen, DMA_TO_DEVICE]\n- 调用者: slimpro_i2c_blkwr\n- 被调用者: []"
    },
    {
        "id": 3967,
        "cwe": "CWE-787",
        "cve": "CVE-2023-2598",
        "purpose": "Code purpose:\"\"\"该代码用于在io_uring中注册固定缓冲区，处理用户空间提供的IO向量并将其映射到内核空间\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理固定缓冲区注册时，未能正确验证和限制缓冲区边界，导致可以访问超出缓冲区范围的物理内存\"\"\"",
        "functions": "Functions:\n1. 函数名: io_sqe_buffer_register\n- 参数: [struct io_ring_ctx *ctx, struct iovec *iov, struct io_mapped_ubuf **pimu, struct page **last_hpage]\n- 调用者: N/A\n- 被调用者: [io_pin_pages, page_folio, unpin_user_pages, kvmalloc, io_buffer_account_pin, bvec_set_page, kvfree]\n\n2. 函数名: io_pin_pages\n- 参数: [(unsigned long) iov->iov_base, iov->iov_len, &nr_pages]\n- 调用者: io_sqe_buffer_register\n- 被调用者: N/A\n\n3. 函数名: page_folio\n- 参数: [pages[0], pages[i]]\n- 调用者: io_sqe_buffer_register\n- 被调用者: N/A\n\n4. 函数名: unpin_user_pages\n- 参数: [&pages[1], nr_pages - 1], [pages, nr_pages]\n- 调用者: io_sqe_buffer_register\n- 被调用者: N/A\n\n5. 函数名: kvmalloc\n- 参数: [struct_size(imu, bvec, nr_pages), GFP_KERNEL]\n- 调用者: io_sqe_buffer_register\n- 被调用者: N/A\n\n6. 函数名: io_buffer_account_pin\n- 参数: [ctx, pages, nr_pages, imu, last_hpage]\n- 调用者: io_sqe_buffer_register\n- 被调用者: N/A\n\n7. 函数名: bvec_set_page\n- 参数: [&imu->bvec[0], pages[0], size, off], [&imu->bvec[i], pages[i], vec_len, off]\n- 调用者: io_sqe_buffer_register\n- 被调用者: N/A\n\n8. 函数名: kvfree\n- 参数: [imu], [pages]\n- 调用者: io_sqe_buffer_register\n- 被调用者: N/A"
    },
    {
        "id": 3977,
        "cwe": "CWE-787",
        "cve": "CVE-2023-28410",
        "purpose": "Code purpose:\"\"\"该代码用于处理Intel i915显卡驱动中对图形内存对象的读写访问控制，包括权限检查和内存边界验证。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"未正确验证用户提供的addr和len参数是否超出内存缓冲区边界，导致越界内存访问\"\"\"",
        "functions": "Functions:\n1. 函数名: vm_access\n- 参数: [struct vm_area_struct *area, unsigned long addr, void *buf, int len, int write]\n- 调用者: 未显示\n- 被调用者: [i915_gem_object_is_readonly, i915_gem_ww_ctx_init, i915_gem_object_lock, i915_gem_object_pin_map, IS_ERR, PTR_ERR, memcpy, __i915_gem_object_flush_map, i915_gem_object_unpin_map, i915_gem_ww_ctx_backoff, i915_gem_ww_ctx_fini]\n\n2. 函数名: i915_gem_object_is_readonly\n- 参数: [struct drm_i915_gem_object *obj]\n- 调用者: vm_access\n- 被调用者: 未显示\n\n3. 函数名: i915_gem_ww_ctx_init\n- 参数: [struct i915_gem_ww_ctx *ww, bool intr]\n- 调用者: vm_access\n- 被调用者: 未显示\n\n4. 函数名: i915_gem_object_lock\n- 参数: [struct drm_i915_gem_object *obj, struct i915_gem_ww_ctx *ww]\n- 调用者: vm_access\n- 被调用者: 未显示\n\n5. 函数名: i915_gem_object_pin_map\n- 参数: [struct drm_i915_gem_object *obj, enum i915_map_type type]\n- 调用者: vm_access\n- 被调用者: 未显示\n\n6. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: vm_access\n- 被调用者: 未显示\n\n7. 函数名: PTR_ERR\n- 参数: [const void *ptr]\n- 调用者: vm_access\n- 被调用者: 未显示\n\n8. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: vm_access\n- 被调用者: 未显示\n\n9. 函数名: __i915_gem_object_flush_map\n- 参数: [struct drm_i915_gem_object *obj, unsigned long offset, unsigned int size]\n- 调用者: vm_access\n- 被调用者: 未显示\n\n10. 函数名: i915_gem_object_unpin_map\n- 参数: [struct drm_i915_gem_object *obj]\n- 调用者: vm_access\n- 被调用者: 未显示\n\n11. 函数名: i915_gem_ww_ctx_backoff\n- 参数: [struct i915_gem_ww_ctx *ww]\n- 调用者: vm_access\n- 被调用者: 未显示\n\n12. 函数名: i915_gem_ww_ctx_fini\n- 参数: [struct i915_gem_ww_ctx *ww]\n- 调用者: vm_access\n- 被调用者: 未显示"
    },
    {
        "id": 3990,
        "cwe": "CWE-787",
        "cve": "CVE-2023-3090",
        "purpose": "Code purpose:\"\"\"处理IPv4出站数据包的路由选择和发送\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"ipvlan网络驱动中缺少对skb->cb的初始化，导致堆越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: ipvlan_process_v4_outbound\n- 参数: [struct sk_buff *skb]\n- 调用者: 未显示（由网络驱动调用）\n- 被调用者: [ip_hdr, dev_net, ip_route_output_flow, IS_ERR, ip_rt_put, skb_dst_set, ip_local_out, net_xmit_eval, kfree_skb]\n\n2. 函数名: ip_hdr\n- 参数: [const struct sk_buff *skb]\n- 调用者: ipvlan_process_v4_outbound\n- 被调用者: []\n\n3. 函数名: dev_net\n- 参数: [const struct net_device *dev]\n- 调用者: ipvlan_process_v4_outbound\n- 被调用者: []\n\n4. 函数名: ip_route_output_flow\n- 参数: [struct net *net, struct flowi4 *flp, const struct sock *sk]\n- 调用者: ipvlan_process_v4_outbound\n- 被调用者: []\n\n5. 函数名: IS_ERR\n- 参数: [const void *ptr]\n- 调用者: ipvlan_process_v4_outbound\n- 被调用者: []\n\n6. 函数名: ip_rt_put\n- 参数: [struct rtable *rt]\n- 调用者: ipvlan_process_v4_outbound\n- 被调用者: []\n\n7. 函数名: skb_dst_set\n- 参数: [struct sk_buff *skb, struct dst_entry *dst]\n- 调用者: ipvlan_process_v4_outbound\n- 被调用者: []\n\n8. 函数名: ip_local_out\n- 参数: [struct net *net, struct sock *sk, struct sk_buff *skb]\n- 调用者: ipvlan_process_v4_outbound\n- 被调用者: []\n\n9. 函数名: net_xmit_eval\n- 参数: [int err]\n- 调用者: ipvlan_process_v4_outbound\n- 被调用者: []\n\n10. 函数名: kfree_skb\n- 参数: [struct sk_buff *skb]\n- 调用者: ipvlan_process_v4_outbound\n- 被调用者: []"
    },
    {
        "id": 4002,
        "cwe": "CWE-787",
        "cve": "CVE-2023-31436",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的QFQ调度器中修改或创建流量控制类，处理权重和最大包长度等参数，并将类添加到聚合组中。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在qfq_change_class函数中，对lmax参数的校验不足，允许其小于QFQ_MIN_LMAX的值，导致可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: qfq_change_class\n- 参数: [sch, classid, parentid, tca, arg, extack]\n- 调用者: 未显示（通常由网络调度器框架调用）\n- 被调用者: [nla_parse_nested_deprecated, nla_get_u32, qdisc_priv, qdisc_dev, gen_replace_estimator, kzalloc, qdisc_create_dflt, gen_new_estimator, qdisc_hash_add, sch_tree_lock, qfq_find_agg, sch_tree_unlock, qfq_init_agg, qfq_deact_rm_from_agg, qdisc_class_hash_insert, qfq_add_to_agg, qdisc_class_hash_grow, qdisc_put, gen_kill_estimator]\n\n2. 函数名: nla_parse_nested_deprecated\n- 参数: [tb, TCA_QFQ_MAX, tca[TCA_OPTIONS], qfq_policy, NULL]\n- 调用者: qfq_change_class\n- 被调用者: 未显示（内核网络链接属性解析函数）\n\n3. 函数名: nla_get_u32\n- 参数: [tb[TCA_QFQ_WEIGHT], tb[TCA_QFQ_LMAX]]\n- 调用者: qfq_change_class\n- 被调用者: 未显示（内核网络链接属性获取函数）\n\n4. 函数名: qdisc_priv\n- 参数: [sch]\n- 调用者: qfq_change_class\n- 被调用者: 未显示（获取Qdisc私有数据函数）\n\n5. 函数名: qdisc_dev\n- 参数: [sch]\n- 调用者: qfq_change_class\n- 被调用者: 未显示（获取Qdisc关联设备函数）\n\n6. 函数名: gen_replace_estimator\n- 参数: [&cl->bstats, NULL, &cl->rate_est, NULL, true, tca[TCA_RATE]]\n- 调用者: qfq_change_class\n- 被调用者: 未显示（流量估算器替换函数）\n\n7. 函数名: kzalloc\n- 参数: [sizeof(struct qfq_class), GFP_KERNEL], [sizeof(*new_agg), GFP_KERNEL]\n- 调用者: qfq_change_class\n- 被调用者: 未显示（内核内存分配函数）\n\n8. 函数名: qdisc_create_dflt\n- 参数: [sch->dev_queue, &pfifo_qdisc_ops, classid, NULL]\n- 调用者: qfq_change_class\n- 被调用者: 未显示（创建默认队列规则函数）\n\n9. 函数名: gen_new_estimator\n- 参数: [&cl->bstats, NULL, &cl->rate_est, NULL, true, tca[TCA_RATE]]\n- 调用者: qfq_change_class\n- 被调用者: 未显示（新建流量估算器函数）\n\n10. 函数名: qdisc_hash_add\n- 参数: [cl->qdisc, true]\n- 调用者: qfq_change_class\n- 被调用者: 未显示（将Qdisc加入哈希表函数）\n\n11. 函数名: sch_tree_lock\n- 参数: [sch]\n- 调用者: qfq_change_class\n- 被调用者: 未显示（锁定调度器树函数）\n\n12. 函数名: qfq_find_agg\n- 参数: [q, lmax, weight]\n- 调用者: qfq_change_class\n- 被调用者: 未显示（查找聚合器函数）\n\n13. 函数名: sch_tree_unlock\n- 参数: [sch]\n- 调用者: qfq_change_class\n- 被调用者: 未显示（解锁调度器树函数）\n\n14. 函数名: qfq_init_agg\n- 参数: [q, new_agg, lmax, weight]\n- 调用者: qfq_change_class\n- 被调用者: 未显示（初始化聚合器函数）\n\n15. 函数名: qfq_deact_rm_from_agg\n- 参数: [q, cl]\n- 调用者: qfq_change_class\n- 被调用者: 未显示（从聚合器移除类函数）\n\n16. 函数名: qdisc_class_hash_insert\n- 参数: [&q->clhash, &cl->common]\n- 调用者: qfq_change_class\n- 被调用者: 未显示（将类插入哈希表函数）\n\n17. 函数名: qfq_add_to_agg\n- 参数: [q, new_agg, cl]\n- 调用者: qfq_change_class\n- 被调用者: 未显示（将类加入聚合器函数）\n\n18. 函数名: qdisc_class_hash_grow\n- 参数: [sch, &q->clhash]\n- 调用者: qfq_change_class\n- 被调用者: 未显示（扩展类哈希表函数）\n\n19. 函数名: qdisc_put\n- 参数: [cl->qdisc]\n- 调用者: qfq_change_class\n- 被调用者: 未显示（释放Qdisc引用函数）\n\n20. 函数名: gen_kill_estimator\n- 参数: [&cl->rate_est]\n- 调用者: qfq_change_class\n- 被调用者: 未显示（销毁流量估算器函数）"
    },
    {
        "id": 4098,
        "cwe": "CWE-787",
        "cve": "CVE-2023-34319",
        "purpose": "Code purpose:\"\"\"处理网络数据包的拆分和重组，确保数据包头部信息完整，同时处理极端情况下的数据包分割问题\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在处理极端情况下被分割成多个小片段的网络数据包时，未能正确计算缓冲区边界，导致缓冲区溢出漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: xenvif_get_requests\n- 参数: [queue, skb, first, txfrags, copy_ops, map_ops, frag_overflow, nskb, extra_count, data_len]\n- 调用者: 未显示（应为网络后端驱动调用）\n- 被调用者: [skb_shinfo, skb_shinfo, pending_index, virt_to_gfn, memcpy, xenvif_tx_create_map_op, frag_set_pending_idx]\n\n2. 函数名: skb_shinfo\n- 参数: [skb]\n- 调用者: xenvif_get_requests\n- 被调用者: []\n\n3. 函数名: pending_index\n- 参数: [queue->pending_cons]\n- 调用者: xenvif_get_requests\n- 被调用者: []\n\n4. 函数名: virt_to_gfn\n- 参数: [skb->data + skb_headlen(skb) - data_len]\n- 调用者: xenvif_get_requests\n- 被调用者: []\n\n5. 函数名: memcpy\n- 参数: [&queue->pending_tx_info[pending_idx].req, txp, sizeof(*txp)]\n- 调用者: xenvif_get_requests\n- 被调用者: []\n\n6. 函数名: xenvif_tx_create_map_op\n- 参数: [queue, pending_idx, txp, txp == first ? extra_count : 0, gop]\n- 调用者: xenvif_get_requests\n- 被调用者: []\n\n7. 函数名: frag_set_pending_idx\n- 参数: [&frags[shinfo->nr_frags], pending_idx]\n- 调用者: xenvif_get_requests\n- 被调用者: []"
    },
    {
        "id": 4106,
        "cwe": "CWE-787",
        "cve": "CVE-2023-35001",
        "purpose": "Code purpose:\"\"\"该代码用于处理nftables中的字节序转换操作，根据指定的操作类型和大小对寄存器中的数据进行网络字节序和主机字节序之间的转换。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"nft_byteorder函数在处理虚拟寄存器内容时未正确验证priv->len参数边界，导致在CAP_NET_ADMIN权限下可能发生越界读写\"\"\"",
        "functions": "Functions:\n1. 函数名: nft_byteorder_eval\n- 参数: [const struct nft_expr *expr, struct nft_regs *regs, const struct nft_pktinfo *pkt]\n- 调用者: 未指定\n- 被调用者: [nft_expr_priv, nft_reg_load64, nft_reg_store64, be64_to_cpu, cpu_to_be64, ntohl, htonl, ntohs, htons]\n\n2. 函数名: nft_expr_priv\n- 参数: [const struct nft_expr *expr]\n- 调用者: nft_byteorder_eval\n- 被调用者: 未指定\n\n3. 函数名: nft_reg_load64\n- 参数: [u32 *src]\n- 调用者: nft_byteorder_eval\n- 被调用者: 未指定\n\n4. 函数名: nft_reg_store64\n- 参数: [u32 *dst, u64 value]\n- 调用者: nft_byteorder_eval\n- 被调用者: 未指定\n\n5. 函数名: be64_to_cpu\n- 参数: [__be64]\n- 调用者: nft_byteorder_eval\n- 被调用者: 未指定\n\n6. 函数名: cpu_to_be64\n- 参数: [u64]\n- 调用者: nft_byteorder_eval\n- 被调用者: 未指定\n\n7. 函数名: ntohl\n- 参数: [__be32]\n- 调用者: nft_byteorder_eval\n- 被调用者: 未指定\n\n8. 函数名: htonl\n- 参数: [u32]\n- 调用者: nft_byteorder_eval\n- 被调用者: 未指定\n\n9. 函数名: ntohs\n- 参数: [__be16]\n- 调用者: nft_byteorder_eval\n- 被调用者: 未指定\n\n10. 函数名: htons\n- 参数: [u16]\n- 调用者: nft_byteorder_eval\n- 被调用者: 未指定"
    },
    {
        "id": 4108,
        "cwe": "CWE-787",
        "cve": "CVE-2023-35788",
        "purpose": "Code purpose:\"\"\"处理GENEVE隧道选项的设置，包括验证和解析网络层属性，并将有效数据复制到流分类键中\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证用户提供的option_len参数，导致可以写入超出key->enc_opts.data边界的内存，造成越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: fl_set_geneve_opt\n- 参数: [const struct nlattr *nla, struct fl_flow_key *key, int depth, int option_len, struct netlink_ext_ack *extack]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [nla_type, nla_parse_nested_deprecated, nla_len, nla_get_be16, nla_get_u8, nla_data, memcpy, memset, NL_SET_ERR_MSG]\n\n2. 函数名: nla_type\n- 参数: [const struct nlattr *nla]\n- 调用者: fl_set_geneve_opt\n- 被调用者: []\n\n3. 函数名: nla_parse_nested_deprecated\n- 参数: [struct nlattr **tb, int maxtype, const struct nlattr *nla, const struct nla_policy *policy, struct netlink_ext_ack *extack]\n- 调用者: fl_set_geneve_opt\n- 被调用者: []\n\n4. 函数名: nla_len\n- 参数: [const struct nlattr *nla]\n- 调用者: fl_set_geneve_opt\n- 被调用者: []\n\n5. 函数名: nla_get_be16\n- 参数: [const struct nlattr *nla]\n- 调用者: fl_set_geneve_opt\n- 被调用者: []\n\n6. 函数名: nla_get_u8\n- 参数: [const struct nlattr *nla]\n- 调用者: fl_set_geneve_opt\n- 被调用者: []\n\n7. 函数名: nla_data\n- 参数: [const struct nlattr *nla]\n- 调用者: fl_set_geneve_opt\n- 被调用者: []\n\n8. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: fl_set_geneve_opt\n- 被调用者: []\n\n9. 函数名: memset\n- 参数: [void *s, int c, size_t n]\n- 调用者: fl_set_geneve_opt\n- 被调用者: []\n\n10. 函数名: NL_SET_ERR_MSG\n- 参数: [struct netlink_ext_ack *extack, const char *msg]\n- 调用者: fl_set_geneve_opt\n- 被调用者: []"
    },
    {
        "id": 4131,
        "cwe": "CWE-787",
        "cve": "CVE-2023-3611",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的QFQ调度器中修改或创建聚合结构，并将类添加到聚合中，但存在对lmax参数缺乏边界检查的问题\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"qfq_change_agg()函数在更新lmax时未对数据包大小进行边界检查，导致越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: qfq_change_agg\n- 参数: [struct Qdisc *sch, struct qfq_class *cl, u32 weight, u32 lmax]\n- 调用者: 未指定\n- 被调用者: [qfq_find_agg, kzalloc, qfq_init_agg, qfq_deact_rm_from_agg, qfq_add_to_agg]\n\n2. 函数名: qfq_find_agg\n- 参数: [struct qfq_sched *q, u32 lmax, u32 weight]\n- 调用者: qfq_change_agg\n- 被调用者: 未指定\n\n3. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: qfq_change_agg\n- 被调用者: 未指定\n\n4. 函数名: qfq_init_agg\n- 参数: [struct qfq_sched *q, struct qfq_aggregate *agg, u32 lmax, u32 weight]\n- 调用者: qfq_change_agg\n- 被调用者: 未指定\n\n5. 函数名: qfq_deact_rm_from_agg\n- 参数: [struct qfq_sched *q, struct qfq_class *cl]\n- 调用者: qfq_change_agg\n- 被调用者: 未指定\n\n6. 函数名: qfq_add_to_agg\n- 参数: [struct qfq_sched *q, struct qfq_aggregate *agg, struct qfq_class *cl]\n- 调用者: qfq_change_agg\n- 被调用者: 未指定"
    },
    {
        "id": 4136,
        "cwe": "CWE-787",
        "cve": "CVE-2023-3812",
        "purpose": "Code purpose:\"\"\"该代码用于在TUN/TAP设备驱动中通过NAPI机制分配和组装网络数据包的片段，处理用户空间传入的网络数据。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未正确验证用户提供的网络包片段数量，导致超出边界的内存访问漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: tun_napi_alloc_frags\n- 参数: [tfile, len, it]\n- 调用者: 未指定\n- 被调用者: [ERR_PTR, local_bh_disable, napi_get_frags, local_bh_enable, iov_iter_single_seg_count, __skb_grow, netdev_alloc_frag, virt_to_head_page, page_address, skb_fill_page_desc, napi_free_frags]\n\n2. 函数名: ERR_PTR\n- 参数: [error_code]\n- 调用者: tun_napi_alloc_frags\n- 被调用者: 未指定\n\n3. 函数名: local_bh_disable\n- 参数: []\n- 调用者: tun_napi_alloc_frags\n- 被调用者: 未指定\n\n4. 函数名: napi_get_frags\n- 参数: [&tfile->napi]\n- 调用者: tun_napi_alloc_frags\n- 被调用者: 未指定\n\n5. 函数名: local_bh_enable\n- 参数: []\n- 调用者: tun_napi_alloc_frags\n- 被调用者: 未指定\n\n6. 函数名: iov_iter_single_seg_count\n- 参数: [it]\n- 调用者: tun_napi_alloc_frags\n- 被调用者: 未指定\n\n7. 函数名: __skb_grow\n- 参数: [skb, linear]\n- 调用者: tun_napi_alloc_frags\n- 被调用者: 未指定\n\n8. 函数名: netdev_alloc_frag\n- 参数: [fragsz]\n- 调用者: tun_napi_alloc_frags\n- 被调用者: 未指定\n\n9. 函数名: virt_to_head_page\n- 参数: [frag]\n- 调用者: tun_napi_alloc_frags\n- 被调用者: 未指定\n\n10. 函数名: page_address\n- 参数: [page]\n- 调用者: tun_napi_alloc_frags\n- 被调用者: 未指定\n\n11. 函数名: skb_fill_page_desc\n- 参数: [skb, i-1, page, frag-page_address(page), fragsz]\n- 调用者: tun_napi_alloc_frags\n- 被调用者: 未指定\n\n12. 函数名: napi_free_frags\n- 参数: [&tfile->napi]\n- 调用者: tun_napi_alloc_frags\n- 被调用者: 未指定"
    },
    {
        "id": 4204,
        "cwe": "CWE-787",
        "cve": "CVE-2023-4273",
        "purpose": "Code purpose:\"\"\"从exFAT文件系统的目录条目中提取并合并文件名的Unicode字符到指定缓冲区\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未对文件名长度进行有效验证，导致将文件名字符复制到栈变量时可能发生内核栈溢出\"\"\"",
        "functions": "Functions:\n1. 函数名: exfat_get_uniname_from_ext_entry\n- 参数: [struct super_block *sb, struct exfat_chain *p_dir, int entry, unsigned short *uniname]\n- 调用者: 未指定\n- 被调用者: [exfat_get_dentry_set, exfat_get_dentry_cached, exfat_get_entry_type, exfat_extract_uni_name, exfat_put_dentry_set]\n\n2. 函数名: exfat_get_dentry_set\n- 参数: [struct exfat_entry_set_cache *es, struct super_block *sb, struct exfat_chain *p_dir, int entry, int type]\n- 调用者: exfat_get_uniname_from_ext_entry\n- 被调用者: 未指定\n\n3. 函数名: exfat_get_dentry_cached\n- 参数: [struct exfat_entry_set_cache *es, int num]\n- 调用者: exfat_get_uniname_from_ext_entry\n- 被调用者: 未指定\n\n4. 函数名: exfat_get_entry_type\n- 参数: [struct exfat_dentry *ep]\n- 调用者: exfat_get_uniname_from_ext_entry\n- 被调用者: 未指定\n\n5. 函数名: exfat_extract_uni_name\n- 参数: [struct exfat_dentry *ep, unsigned short *uniname]\n- 调用者: exfat_get_uniname_from_ext_entry\n- 被调用者: 未指定\n\n6. 函数名: exfat_put_dentry_set\n- 参数: [struct exfat_entry_set_cache *es, bool sync]\n- 调用者: exfat_get_uniname_from_ext_entry\n- 被调用者: 未指定"
    },
    {
        "id": 4205,
        "cwe": "CWE-787",
        "cve": "CVE-2023-4273",
        "purpose": "Code purpose:\"\"\"该代码用于在exFAT文件系统中查找目录条目并重构文件名，通过遍历目录簇和条目来匹配给定的文件名\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在exFAT驱动程序中，文件名重构功能将文件名字符复制到栈变量时未进行充分边界检查，导致本地特权攻击者可能利用此缺陷溢出内核栈。\"\"\"",
        "functions": "Functions:\n1. 函数名: exfat_find_dir_entry\n- 参数: [struct super_block *sb, struct exfat_inode_info *ei, struct exfat_chain *p_dir, struct exfat_uni_name *p_uniname, struct exfat_hint *hint_opt]\n- 调用者: N/A (顶层函数)\n- 被调用者: [exfat_calc_num_entries, exfat_chain_dup, exfat_reset_empty_hint, exfat_get_dentry, exfat_get_entry_type, exfat_set_empty_hint, exfat_extract_uni_name, exfat_uniname_ncmp, exfat_get_next_cluster]\n\n2. 函数名: exfat_calc_num_entries\n- 参数: [struct exfat_uni_name *p_uniname]\n- 调用者: exfat_find_dir_entry\n- 被调用者: []\n\n3. 函数名: exfat_chain_dup\n- 参数: [struct exfat_chain *clu, struct exfat_chain *p_dir]\n- 调用者: exfat_find_dir_entry\n- 被调用者: []\n\n4. 函数名: exfat_reset_empty_hint\n- 参数: [struct exfat_hint_femp *hint]\n- 调用者: exfat_find_dir_entry\n- 被调用者: []\n\n5. 函数名: exfat_get_dentry\n- 参数: [struct super_block *sb, struct exfat_chain *clu, int i, struct buffer_head **bh]\n- 调用者: exfat_find_dir_entry\n- 被调用者: []\n\n6. 函数名: exfat_get_entry_type\n- 参数: [struct exfat_dentry *ep]\n- 调用者: exfat_find_dir_entry\n- 被调用者: []\n\n7. 函数名: exfat_set_empty_hint\n- 参数: [struct exfat_inode_info *ei, struct exfat_hint_femp *candi_empty, struct exfat_chain *clu, int dentry, int num_entries, unsigned int entry_type]\n- 调用者: exfat_find_dir_entry\n- 被调用者: []\n\n8. 函数名: exfat_extract_uni_name\n- 参数: [struct exfat_dentry *ep, unsigned short entry_uniname[16]]\n- 调用者: exfat_find_dir_entry\n- 被调用者: []\n\n9. 函数名: exfat_uniname_ncmp\n- 参数: [struct super_block *sb, unsigned short *name1, unsigned short *name2, int len]\n- 调用者: exfat_find_dir_entry\n- 被调用者: []\n\n10. 函数名: exfat_get_next_cluster\n- 参数: [struct super_block *sb, unsigned int *clu]\n- 调用者: exfat_find_dir_entry\n- 被调用者: []"
    },
    {
        "id": 4224,
        "cwe": "CWE-787",
        "cve": "CVE-2023-45863",
        "purpose": "Code purpose:\"\"\"该代码用于获取内核对象(kobject)的路径字符串并返回分配的内存指针\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于在分配路径缓冲区长度和填充路径内容之间存在竞争条件，导致fill_kobj_path函数可能发生越界写入。\"\"\"",
        "functions": "Functions:\n1. 函数名: kobject_get_path\n- 参数: [const struct kobject *kobj, gfp_t gfp_mask]\n- 调用者: 未指定\n- 被调用者: [get_kobj_path_length, kzalloc, fill_kobj_path]\n\n2. 函数名: get_kobj_path_length\n- 参数: [const struct kobject *kobj]\n- 调用者: kobject_get_path\n- 被调用者: 未指定\n\n3. 函数名: kzalloc\n- 参数: [size_t size, gfp_t flags]\n- 调用者: kobject_get_path\n- 被调用者: 未指定\n\n4. 函数名: fill_kobj_path\n- 参数: [const struct kobject *kobj, char *path, int len]\n- 调用者: kobject_get_path\n- 被调用者: 未指定"
    },
    {
        "id": 4225,
        "cwe": "CWE-787",
        "cve": "CVE-2023-45863",
        "purpose": "Code purpose:\"\"\"该代码用于构建并填充kobject对象的完整路径字符串\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于fill_kobj_path函数在处理kobject路径时未正确验证缓冲区长度，导致可能发生越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: fill_kobj_path\n- 参数: [const struct kobject *kobj, char *path, int length]\n- 调用者: 未明确（由外部调用）\n- 被调用者: [strlen, kobject_name, memcpy, pr_debug]\n\n2. 函数名: strlen\n- 参数: [const char *str]\n- 调用者: fill_kobj_path\n- 被调用者: []\n\n3. 函数名: kobject_name\n- 参数: [const struct kobject *kobj]\n- 调用者: fill_kobj_path\n- 被调用者: []\n\n4. 函数名: memcpy\n- 参数: [void *dest, const void *src, size_t n]\n- 调用者: fill_kobj_path\n- 被调用者: []\n\n5. 函数名: pr_debug\n- 参数: [const char *fmt, ...]\n- 调用者: fill_kobj_path\n- 被调用者: []"
    },
    {
        "id": 4288,
        "cwe": "CWE-787",
        "cve": "CVE-2023-5717",
        "purpose": "Code purpose:\"\"\"该代码用于处理Linux内核性能事件(perf)组件中的事件组分离操作，包括从组中移除事件、处理兄弟事件关系以及更新事件头部大小等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当事件sibling_list小于其子事件的sibling_list时，perf_read_group()调用可能导致堆越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: perf_group_detach\n- 参数: [struct perf_event *event]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [lockdep_assert_held, perf_put_aux_event, list_del_init, perf_remove_sibling_event, add_event_to_groups, list_add_tail, WARN_ON_ONCE, for_each_sibling_event, perf_event__header_size]\n\n2. 函数名: lockdep_assert_held\n- 参数: [&ctx->lock]\n- 调用者: perf_group_detach\n- 被调用者: []\n\n3. 函数名: perf_put_aux_event\n- 参数: [event]\n- 调用者: perf_group_detach\n- 被调用者: []\n\n4. 函数名: list_del_init\n- 参数: [&event->sibling_list], [&sibling->sibling_list]\n- 调用者: perf_group_detach\n- 被调用者: []\n\n5. 函数名: perf_remove_sibling_event\n- 参数: [sibling]\n- 调用者: perf_group_detach\n- 被调用者: []\n\n6. 函数名: add_event_to_groups\n- 参数: [sibling, event->ctx]\n- 调用者: perf_group_detach\n- 被调用者: []\n\n7. 函数名: list_add_tail\n- 参数: [&sibling->active_list, get_event_list(sibling)]\n- 调用者: perf_group_detach\n- 被调用者: []\n\n8. 函数名: WARN_ON_ONCE\n- 参数: [sibling->ctx != event->ctx]\n- 调用者: perf_group_detach\n- 被调用者: []\n\n9. 函数名: for_each_sibling_event\n- 参数: [tmp, leader]\n- 调用者: perf_group_detach\n- 被调用者: []\n\n10. 函数名: perf_event__header_size\n- 参数: [tmp], [leader]\n- 调用者: perf_group_detach\n- 被调用者: []\n\n11. 函数名: get_event_list\n- 参数: [sibling]\n- 调用者: list_add_tail\n- 被调用者: []"
    },
    {
        "id": 4289,
        "cwe": "CWE-787",
        "cve": "CVE-2023-5717",
        "purpose": "Code purpose:\"\"\"该代码用于读取并汇总性能事件组(perf event group)中各个事件的计数和状态信息，包括总启用时间、总运行时间、事件计数、ID和丢失样本数等数据。\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当perf_read_group()被调用时，如果事件的sibling_list比其子事件的sibling_list小，会导致超出分配缓冲区边界的内存写入\"\"\"",
        "functions": "Functions:\n1. 函数名: __perf_read_group_add\n- 参数: [struct perf_event *leader, u64 read_format, u64 *values]\n- 调用者: 未明确指定（应为perf_read_group或其他调用者）\n- 被调用者: [perf_event_read, perf_event_count, primary_event_id, atomic64_read, raw_spin_lock_irqsave, raw_spin_unlock_irqrestore]\n\n2. 函数名: perf_event_read\n- 参数: [struct perf_event *event, bool group]\n- 调用者: __perf_read_group_add\n- 被调用者: 未明确指定\n\n3. 函数名: perf_event_count\n- 参数: [struct perf_event *event]\n- 调用者: __perf_read_group_add\n- 被调用者: 未明确指定\n\n4. 函数名: primary_event_id\n- 参数: [struct perf_event *event]\n- 调用者: __perf_read_group_add\n- 被调用者: 未明确指定\n\n5. 函数名: atomic64_read\n- 参数: [atomic64_t *v]\n- 调用者: __perf_read_group_add\n- 被调用者: 未明确指定\n\n6. 函数名: raw_spin_lock_irqsave\n- 参数: [raw_spinlock_t *lock, unsigned long flags]\n- 调用者: __perf_read_group_add\n- 被调用者: 未明确指定\n\n7. 函数名: raw_spin_unlock_irqrestore\n- 参数: [raw_spinlock_t *lock, unsigned long flags]\n- 调用者: __perf_read_group_add\n- 被调用者: 未明确指定\n\n8. 函数名: for_each_sibling_event\n- 参数: [struct perf_event *sub, struct perf_event *leader]\n- 调用者: __perf_read_group_add\n- 被调用者: 未明确指定"
    },
    {
        "id": 4290,
        "cwe": "CWE-787",
        "cve": "CVE-2023-5717",
        "purpose": "Code purpose:\"\"\"该代码用于读取性能事件组的数据并将其复制到用户空间缓冲区，涉及事件组及其子事件的数据收集和传输。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当事件sibling_list小于其子事件的sibling_list时，perf_read_group()函数会越界写入分配的缓冲区之外的内存位置\"\"\"",
        "functions": "Functions:\n1. 函数名: perf_read_group\n- 参数: [event, read_format, buf]\n- 调用者: 未明确（由内核其他部分调用）\n- 被调用者: [kzalloc, mutex_lock, __perf_read_group_add, list_for_each_entry, mutex_unlock, copy_to_user, kfree]\n\n2. 函数名: __perf_read_group_add\n- 参数: [leader, read_format, values]\n- 调用者: perf_read_group\n- 被调用者: 未明确（可能为内部辅助函数）\n\n3. 函数名: kzalloc\n- 参数: [event->read_size, GFP_KERNEL]\n- 调用者: perf_read_group\n- 被调用者: 内核内存分配函数\n\n4. 函数名: mutex_lock\n- 参数: [&leader->child_mutex]\n- 调用者: perf_read_group\n- 被调用者: 内核互斥锁函数\n\n5. 函数名: list_for_each_entry\n- 参数: [child, &leader->child_list, child_list]\n- 调用者: perf_read_group\n- 被调用者: 内核链表遍历宏\n\n6. 函数名: mutex_unlock\n- 参数: [&leader->child_mutex]\n- 调用者: perf_read_group\n- 被调用者: 内核互斥锁函数\n\n7. 函数名: copy_to_user\n- 参数: [buf, values, event->read_size]\n- 调用者: perf_read_group\n- 被调用者: 内核用户空间拷贝函数\n\n8. 函数名: kfree\n- 参数: [values]\n- 调用者: perf_read_group\n- 被调用者: 内核内存释放函数"
    },
    {
        "id": 4291,
        "cwe": "CWE-787",
        "cve": "CVE-2023-5717",
        "purpose": "Code purpose:\"\"\"该代码用于在Linux内核的性能事件(perf)组件中实现父进程性能事件组到子进程的继承功能\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当perf_read_group()被调用时，如果事件的sibling_list比其子事件的sibling_list小，会导致越界写入堆内存\"\"\"",
        "functions": "Functions:\n1. 函数名: inherit_group\n- 参数: [parent_event, parent, parent_ctx, child, child_ctx]\n- 调用者: 未显示\n- 被调用者: [inherit_event, perf_get_aux_event]\n\n2. 函数名: inherit_event\n- 参数: [parent_event, parent, parent_ctx, child, leader, child_ctx]\n- 调用者: inherit_group\n- 被调用者: 未显示\n\n3. 函数名: perf_get_aux_event\n- 参数: [child_ctr, leader]\n- 调用者: inherit_group\n- 被调用者: 未显示\n\n4. 函数名: for_each_sibling_event\n- 参数: [sub, parent_event]\n- 调用者: inherit_group\n- 被调用者: 未显示\n\n5. 函数名: IS_ERR\n- 参数: [leader] 或 [child_ctr]\n- 调用者: inherit_group\n- 被调用者: 未显示\n\n6. 函数名: PTR_ERR\n- 参数: [leader] 或 [child_ctr]\n- 调用者: inherit_group\n- 被调用者: 未显示"
    },
    {
        "id": 4292,
        "cwe": "CWE-787",
        "cve": "CVE-2023-5717",
        "purpose": "Code purpose:\"\"\"该代码用于将性能事件(event)附加到其组领导者(group_leader)的兄弟列表中，并更新相关属性和头部大小\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"当事件sibling_list小于其子事件的sibling_list时，perf_read_group()调用可能导致堆越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: perf_group_attach\n- 参数: [struct perf_event *event]\n- 调用者: 未明确显示（可能是perf_event_open等调用者）\n- 被调用者: [lockdep_assert_held, WARN_ON_ONCE, list_add_tail, perf_event__header_size, for_each_sibling_event]\n\n2. 函数名: lockdep_assert_held\n- 参数: [&event->ctx->lock]\n- 调用者: perf_group_attach\n- 被调用者: []\n\n3. 函数名: WARN_ON_ONCE\n- 参数: [group_leader->ctx != event->ctx]\n- 调用者: perf_group_attach\n- 被调用者: []\n\n4. 函数名: list_add_tail\n- 参数: [&event->sibling_list, &group_leader->sibling_list]\n- 调用者: perf_group_attach\n- 被调用者: []\n\n5. 函数名: perf_event__header_size\n- 参数: [group_leader]\n- 调用者: perf_group_attach\n- 被调用者: []\n\n6. 函数名: for_each_sibling_event\n- 参数: [pos, group_leader]\n- 调用者: perf_group_attach\n- 被调用者: [perf_event__header_size]"
    },
    {
        "id": 4309,
        "cwe": "CWE-787",
        "cve": "CVE-2023-6931",
        "purpose": "Code purpose:\"\"\"验证性能事件(perf_event)的各个大小字段总和是否超过64k的记录限制\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于未充分验证perf_event的read_size大小，导致整数溢出进而引发堆越界写入漏洞\"\"\"",
        "functions": "Functions:\n1. 函数名: perf_event_validate_size\n- 参数: [struct perf_event *event]\n- 调用者: 未提供\n- 被调用者: [__perf_event_read_size, __perf_event_header_size, perf_event__id_header_size]\n\n2. 函数名: __perf_event_read_size\n- 参数: [struct perf_event *event, event->group_leader->nr_siblings + 1]\n- 调用者: perf_event_validate_size\n- 被调用者: 未提供\n\n3. 函数名: __perf_event_header_size\n- 参数: [struct perf_event *event, event->attr.sample_type & ~PERF_SAMPLE_READ]\n- 调用者: perf_event_validate_size\n- 被调用者: 未提供\n\n4. 函数名: perf_event__id_header_size\n- 参数: [struct perf_event *event]\n- 调用者: perf_event_validate_size\n- 被调用者: 未提供"
    },
    {
        "id": 4310,
        "cwe": "CWE-787",
        "cve": "CVE-2023-6931",
        "purpose": "Code purpose:\"\"\"计算性能事件(perf_event)的头部大小和读取大小\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"由于perf_event的read_size可能发生溢出，导致在perf_read_group()中出现堆越界写入\"\"\"",
        "functions": "Functions:\n1. 函数名: perf_event__header_size\n- 参数: [struct perf_event *event]\n- 调用者: 未提供\n- 被调用者: [__perf_event_read_size, __perf_event_header_size]\n\n2. 函数名: __perf_event_read_size\n- 参数: [struct perf_event *event, event->group_leader->nr_siblings]\n- 调用者: perf_event__header_size\n- 被调用者: 未提供\n\n3. 函数名: __perf_event_header_size\n- 参数: [struct perf_event *event, event->attr.sample_type]\n- 调用者: perf_event__header_size\n- 被调用者: 未提供"
    },
    {
        "id": 1896,
        "cwe": "CWE-476",
        "cve": "CVE-2019-10207",
        "purpose": "Code purpose:\"\"\"初始化蓝牙HCI UART接口的ath_struct结构体并设置相关工作队列\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在ath_open函数中分配的内存未进行空指针检查，可能导致空指针解引用，当攻击者通过特殊构造的ioctl调用时会造成系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: ath_open\n- 参数: [struct hci_uart *hu]\n- 调用者: 未明确（应为蓝牙驱动初始化相关代码）\n- 被调用者: [kzalloc, skb_queue_head_init, INIT_WORK]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*ath), GFP_KERNEL]\n- 调用者: ath_open\n- 被调用者: []\n\n3. 函数名: skb_queue_head_init\n- 参数: [&ath->txq]\n- 调用者: ath_open\n- 被调用者: []\n\n4. 函数名: INIT_WORK\n- 参数: [&ath->ctxtsw, ath_hci_uart_work]\n- 调用者: ath_open\n- 被调用者: []\n\n5. 函数名: ath_hci_uart_work\n- 参数: []\n- 调用者: INIT_WORK（作为工作队列函数）\n- 被调用者: []"
    },
    {
        "id": 1897,
        "cwe": "CWE-476",
        "cve": "CVE-2019-10207",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核中蓝牙UART设备的打开和初始化功能，包括分配内存、设置设备参数、管理电源状态等操作。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在bcm_open函数中，当hu->tty->dev为空时未进行空指针检查直接访问其parent成员，导致空指针解引用漏洞。\"\"\"",
        "functions": "Functions:\n1. 函数名: bcm_open\n- 参数: [struct hci_uart *hu]\n- 调用者: 未明确显示（应为蓝牙驱动调用）\n- 被调用者: [kzalloc, skb_queue_head_init, mutex_lock, serdev_device_get_drvdata, list_for_each, list_entry, bcm_gpio_set_power, mutex_unlock, kfree]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*bcm), GFP_KERNEL]\n- 调用者: bcm_open\n- 被调用者: []\n\n3. 函数名: skb_queue_head_init\n- 参数: [&bcm->txq]\n- 调用者: bcm_open\n- 被调用者: []\n\n4. 函数名: mutex_lock\n- 参数: [&bcm_device_lock]\n- 调用者: bcm_open\n- 被调用者: []\n\n5. 函数名: serdev_device_get_drvdata\n- 参数: [hu->serdev]\n- 调用者: bcm_open\n- 被调用者: []\n\n6. 函数名: list_for_each\n- 参数: [p, &bcm_device_list]\n- 调用者: bcm_open\n- 被调用者: [list_entry]\n\n7. 函数名: list_entry\n- 参数: [p, struct bcm_device, list]\n- 调用者: list_for_each\n- 被调用者: []\n\n8. 函数名: bcm_gpio_set_power\n- 参数: [bcm->dev, true]\n- 调用者: bcm_open\n- 被调用者: []\n\n9. 函数名: mutex_unlock\n- 参数: [&bcm_device_lock]\n- 调用者: bcm_open\n- 被调用者: []\n\n10. 函数名: kfree\n- 参数: [bcm]\n- 调用者: bcm_open\n- 被调用者: []"
    },
    {
        "id": 1898,
        "cwe": "CWE-476",
        "cve": "CVE-2019-10207",
        "purpose": "Code purpose:\"\"\"初始化Intel蓝牙设备的UART接口并设置电源状态\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在intel_open函数中，当intel_set_power调用失败时未正确处理资源释放，可能导致空指针解引用。\"\"\"",
        "functions": "Functions:\n1. 函数名: intel_open\n- 参数: [struct hci_uart *hu]\n- 调用者: 未显示\n- 被调用者: [kzalloc, skb_queue_head_init, INIT_WORK, intel_set_power, set_bit]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*intel), GFP_KERNEL]\n- 调用者: intel_open\n- 被调用者: []\n\n3. 函数名: skb_queue_head_init\n- 参数: [&intel->txq]\n- 调用者: intel_open\n- 被调用者: []\n\n4. 函数名: INIT_WORK\n- 参数: [&intel->busy_work, intel_busy_work]\n- 调用者: intel_open\n- 被调用者: []\n\n5. 函数名: intel_set_power\n- 参数: [hu, true]\n- 调用者: intel_open\n- 被调用者: []\n\n6. 函数名: set_bit\n- 参数: [STATE_BOOTING, &intel->flags]\n- 调用者: intel_open\n- 被调用者: []\n\n7. 函数名: intel_busy_work\n- 参数: []\n- 调用者: INIT_WORK\n- 被调用者: []"
    },
    {
        "id": 1899,
        "cwe": "CWE-476",
        "cve": "CVE-2019-10207",
        "purpose": "Code purpose:\"\"\"该代码实现了Linux内核蓝牙UART驱动中mrvl设备的打开和初始化功能，包括内存分配、队列初始化和设备状态设置。\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在错误处理路径中未正确释放已分配的资源和清理状态，可能导致空指针解引用或系统崩溃\"\"\"",
        "functions": "Functions:\n1. 函数名: mrvl_open\n- 参数: [struct hci_uart *hu]\n- 调用者: 未显示（应为外部蓝牙驱动调用）\n- 被调用者: [kzalloc, skb_queue_head_init, set_bit, serdev_device_open, kfree]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(*mrvl), GFP_KERNEL]\n- 调用者: mrvl_open\n- 被调用者: []\n\n3. 函数名: skb_queue_head_init\n- 参数: [&mrvl->txq]\n- 调用者: mrvl_open\n- 被调用者: []\n\n4. 函数名: skb_queue_head_init\n- 参数: [&mrvl->rawq]\n- 调用者: mrvl_open\n- 被调用者: []\n\n5. 函数名: set_bit\n- 参数: [STATE_CHIP_VER_PENDING, &mrvl->flags]\n- 调用者: mrvl_open\n- 被调用者: []\n\n6. 函数名: serdev_device_open\n- 参数: [hu->serdev]\n- 调用者: mrvl_open\n- 被调用者: []\n\n7. 函数名: kfree\n- 参数: [mrvl]\n- 调用者: mrvl_open\n- 被调用者: []"
    },
    {
        "id": 1900,
        "cwe": "CWE-476",
        "cve": "CVE-2019-10207",
        "purpose": "Code purpose:\"\"\"初始化蓝牙HCI UART QCA驱动，包括分配内存、创建工作队列、设置定时器以及处理电源管理等操作\"\"\"",
        "vulnerability_cause": "Vulnerability cause: \"\"\"在蓝牙UART实现中，未对ioctl函数调用进行充分的权限和参数检查，导致本地攻击者可通过特制的ioctl调用引发系统崩溃。\"\"\"",
        "functions": "Functions:\n1. 函数名: qca_open\n- 参数: [struct hci_uart *hu]\n- 调用者: 未显示\n- 被调用者: [kzalloc, skb_queue_head_init, spin_lock_init, alloc_ordered_workqueue, INIT_WORK, init_completion, serdev_device_get_drvdata, qca_is_wcn399x, gpiod_set_value_cansleep, msleep, qca_power_setup, destroy_workqueue, kfree_skb, kfree, timer_setup]\n\n2. 函数名: kzalloc\n- 参数: [sizeof(struct qca_data), GFP_KERNEL]\n- 调用者: qca_open\n- 被调用者: []\n\n3. 函数名: skb_queue_head_init\n- 参数: [&qca->txq], [&qca->tx_wait_q]\n- 调用者: qca_open\n- 被调用者: []\n\n4. 函数名: spin_lock_init\n- 参数: [&qca->hci_ibs_lock]\n- 调用者: qca_open\n- 被调用者: []\n\n5. 函数名: alloc_ordered_workqueue\n- 参数: [\"qca_wq\", 0]\n- 调用者: qca_open\n- 被调用者: []\n\n6. 函数名: INIT_WORK\n- 参数: [&qca->ws_awake_rx, qca_wq_awake_rx], [&qca->ws_awake_device, qca_wq_awake_device], [&qca->ws_rx_vote_off, qca_wq_serial_rx_clock_vote_off], [&qca->ws_tx_vote_off, qca_wq_serial_tx_clock_vote_off]\n- 调用者: qca_open\n- 被调用者: []\n\n7. 函数名: init_completion\n- 参数: [&qca->drop_ev_comp]\n- 调用者: qca_open\n- 被调用者: []\n\n8. 函数名: serdev_device_get_drvdata\n- 参数: [hu->serdev]\n- 调用者: qca_open\n- 被调用者: []\n\n9. 函数名: qca_is_wcn399x\n- 参数: [qcadev->btsoc_type]\n- 调用者: qca_open\n- 被调用者: []\n\n10. 函数名: gpiod_set_value_cansleep\n- 参数: [qcadev->bt_en, 1]\n- 调用者: qca_open\n- 被调用者: []\n\n11. 函数名: msleep\n- 参数: [150]\n- 调用者: qca_open\n- 被调用者: []\n\n12. 函数名: qca_power_setup\n- 参数: [hu, true]\n- 调用者: qca_open\n- 被调用者: []\n\n13. 函数名: destroy_workqueue\n- 参数: [qca->workqueue]\n- 调用者: qca_open\n- 被调用者: []\n\n14. 函数名: kfree_skb\n- 参数: [qca->rx_skb]\n- 调用者: qca_open\n- 被调用者: []\n\n15. 函数名: kfree\n- 参数: [qca]\n- 调用者: qca_open\n- 被调用者: []\n\n16. 函数名: timer_setup\n- 参数: [&qca->wake_retrans_timer, hci_ibs_wake_retrans_timeout, 0], [&qca->tx_idle_timer, hci_ibs_tx_idle_timeout, 0]\n- 调用者: qca_open\n- 被调用者: []"
    }
]